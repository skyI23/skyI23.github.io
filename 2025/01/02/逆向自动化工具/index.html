<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2025/01/02/逆向自动化工具/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            逆向自动化工具 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">8</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">10</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">30</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">逆向自动化工具</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-01-02 01:21:55</span>
        <span class="mobile">2025-01-02 01:21:55</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-02-22 20:25:31</span>
            <span class="mobile">2025-02-22 20:25:31</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>33.3k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>138 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="Keystone"><a href="#Keystone" class="headerlink" title="Keystone"></a>Keystone</h1><p><strong>Keystone</strong> 是一个开源的汇编器（assembler），用于生成二进制机器码。它支持多种 CPU 架构和操作模式，并且具有高效、轻量级、跨平台等特点，适合用在逆向工程、漏洞研究、二进制分析等领域。</p>
<p><code>keystone-engine</code> 是 Keystone 项目的 Python 绑定，它允许开发者在 Python 环境中使用 Keystone 汇编器的强大功能。通过 <code>keystone-engine</code>，你可以在 Python 中执行汇编代码，将汇编转换为机器码，或者将机器码反汇编成汇编代码。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.keystone-engine.org/" >Keystone 官方文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="Keystone-安装"><a href="#Keystone-安装" class="headerlink" title="Keystone 安装"></a>Keystone 安装</h2><p><code>keystone-engine</code> 库已经发布到 PyPI（Python Package Index），所以你可以直接使用 <code>pip</code> 来安装它：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install keystone-engine</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>这里安装的是 <code>keystone-engine</code> 而不是 <code>keystone</code>，<code>keystone</code> 是另外一个模块。</p>

    </div>
  </div>

<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="创建-Keystone-对象"><a href="#创建-Keystone-对象" class="headerlink" title="创建 Keystone 对象"></a>创建 Keystone 对象</h3><p>要开始使用 Keystone，我们首先需要创建一个 <strong>Keystone 对象</strong>。这个对象将负责后续的汇编和反汇编工作。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keystone <span class="keyword">import</span> Ks, KS_ARCH_X86, KS_MODE_32</span><br><span class="line"></span><br><span class="line">ks = Ks(KS_ARCH_X86, KS_MODE_32)</span><br></pre></td></tr></table></figure></div>

<p><code>Ks</code> 构造函数的两个参数是 <strong>架构类型</strong> 和 <strong>模式类型</strong>。这两个参数定义了要汇编或反汇编的目标架构和模式。</p>
<ul>
<li><p><strong>架构类型</strong>指定了目标处理器的架构。Keystone 支持多种不同的处理器架构，包括：</p>
<ul>
<li><code>KS_ARCH_ARM</code>：ARM 处理器架构</li>
<li><code>KS_ARCH_ARM64</code>：ARM 64 位处理器架构</li>
<li><code>KS_ARCH_MIPS</code>：MIPS 处理器架构</li>
<li><code>KS_ARCH_X86</code>：x86 处理器架构</li>
<li><code>KS_ARCH_PPC</code>：PowerPC 处理器架构</li>
<li><code>KS_ARCH_SPARC</code>：SPARC 处理器架构</li>
<li><code>KS_ARCH_SYSTEMZ</code>：SystemZ 架构（IBM Z 系列）</li>
<li><code>KS_ARCH_HEXAGON</code>：Hexagon 架构（Qualcomm Hexagon DSP）</li>
<li><code>KS_ARCH_EVM</code>：EVM 架构（TCS&#x2F;EVM 虚拟机）</li>
</ul>
</li>
<li><p><strong>模式类型</strong>用于指定特定架构下的工作模式（如 32 位或 64 位模式），Keystone 在同一架构下支持多种模式。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>在 Keystone 中，如果你希望同时设置多个模式，可以通过 <strong>按位“或”操作</strong> (<code>|</code>) 来组合不同的模式。这样可以在一个构造函数中同时指定多个模式类型。</p>

    </div>
  </div>

<ul>
<li><p>首先是最基本的大小端序，<strong>Keystone 默认是小端序</strong>。</p>
<ul>
<li><strong><code>KS_MODE_LITTLE_ENDIAN</code></strong> ：小端模式（默认）。</li>
<li><strong><code>KS_MODE_BIG_ENDIAN</code></strong> ：大端模式。</li>
</ul>
</li>
<li><p>另外就是一些针对特定架构下的模式类型。</p>
<ul>
<li><p>ARM 架构相关模式：</p>
<ul>
<li><strong><code>KS_MODE_ARM</code></strong> ：ARM 模式。</li>
<li><strong><code>KS_MODE_THUMB</code></strong> ：Thumb 模式（ARM 特有，表示压缩指令集模式）。</li>
<li><strong><code>KS_MODE_V8</code></strong> ：ARMv8 模式（用于支持 ARMv8 架构）。</li>
</ul>
</li>
<li><p>MIPS 架构相关模式：</p>
<ul>
<li><p><strong><code>KS_MODE_MIPS3</code></strong> ：MIPS3 模式。</p>
</li>
<li><p><strong><code>KS_MODE_MIPS32R6</code></strong> ：MIPS32R6 模式。</p>
</li>
<li><p><strong><code>KS_MODE_MIPS32</code></strong> ：MIPS32 模式。</p>
</li>
<li><p><strong><code>KS_MODE_MIPS64</code></strong> ：MIPS64 模式。</p>
</li>
</ul>
</li>
<li><p>x86 架构相关模式：</p>
<ul>
<li><p><strong><code>KS_MODE_16</code></strong> ：16 位模式。</p>
</li>
<li><p><strong><code>KS_MODE_32</code></strong> ：32 位模式。</p>
</li>
<li><p><strong><code>KS_MODE_64</code></strong> ：64 位模式。</p>
</li>
</ul>
</li>
<li><p>PowerPC 架构相关模式：</p>
<ul>
<li><p><strong><code>KS_MODE_PPC32</code></strong> ：PowerPC 32 位模式。</p>
</li>
<li><p><strong><code>KS_MODE_PPC64</code></strong> ：PowerPC 64 位模式。</p>
</li>
<li><p><strong><code>KS_MODE_QPX</code></strong> ：QPX 模式（专门用于某些 PowerPC 处理器）。</p>
</li>
</ul>
</li>
<li><p>SPARC 架构相关模式：</p>
<ul>
<li><p><strong><code>KS_MODE_SPARC32</code></strong> ：SPARC 32 位模式。</p>
</li>
<li><p><strong><code>KS_MODE_SPARC64</code></strong> ：SPARC 64 位模式。</p>
</li>
<li><p><strong><code>KS_MODE_V9</code></strong> ：SPARC V9 模式（64 位）。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这里给出我们在逆向辅助工具开发中常用的 Keystone 对象：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keystone <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># X86-64</span></span><br><span class="line"><span class="keyword">from</span> keystone.x86_const <span class="keyword">import</span> *</span><br><span class="line">ks = Ks(KS_ARCH_X86, KS_MODE_64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ARM</span></span><br><span class="line"><span class="keyword">from</span> keystone.arm_const <span class="keyword">import</span> *</span><br><span class="line">ks = Ks(KS_ARCH_ARM, KS_MODE_ARM)</span><br><span class="line">ks = ks(KS_ARCH_ARM, KS_MODE_THUMB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># AARCH64</span></span><br><span class="line"><span class="keyword">from</span> keystone.arm64_const <span class="keyword">import</span> *</span><br><span class="line">ks = ks(KS_ARCH_ARM64, KS_MODE_ARM)</span><br></pre></td></tr></table></figure></div>

<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p> Keystone 对象只有一个公开的成员函数 <code>asm</code>，该函数定义如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">asm</span>(<span class="params">self, string: <span class="built_in">str</span>, addr: <span class="built_in">int</span> = <span class="number">0</span>, as_bytes: <span class="built_in">bool</span> = <span class="literal">False</span></span>) -&gt; <span class="built_in">tuple</span>:</span><br></pre></td></tr></table></figure></div>

<p><strong>参数：</strong></p>
<ul>
<li><p><strong><code>string: str</code></strong> ：表示输入参数 <code>string</code> 是一个字符串，包含汇编语言的代码。</p>
</li>
<li><p><strong><code>addr: int = 0</code></strong> ：<code>addr</code> 是一个整数类型的参数，表示机器码开始的内存地址，默认值为 <code>0</code>。</p>
</li>
<li><p><strong><code>as_bytes: bool = False</code></strong> ：<code>as_bytes</code> 是一个布尔值，表示是否返回机器码的字节表示。默认值为 <code>False</code>，即返回一个整数列表。</p>
</li>
</ul>
<p><strong>返回值：</strong>该函数返回一个元组，元组包含两个元素。</p>
<ul>
<li><strong><code>encoded</code></strong> ：机器码的字节表示。<ul>
<li>如果 <code>as_bytes=True</code>，返回 <code>bytes</code> 类型。</li>
<li>如果 <code>as_bytes=False</code>，返回 <code>list[int]</code> 类型，表示机器码的字节序列对应的整数。</li>
</ul>
</li>
<li><code>count</code>：生成的机器码指令的数量。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> keystone <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ks = Ks(KS_ARCH_X86, KS_MODE_64)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ks.asm(<span class="string">&quot;inc rax; inc rax&quot;</span>)</span><br><span class="line">([<span class="number">72</span>, <span class="number">255</span>, <span class="number">192</span>, <span class="number">72</span>, <span class="number">255</span>, <span class="number">192</span>], <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ks.asm(<span class="string">&quot;inc rax; inc rax&quot;</span>, as_bytes=<span class="literal">True</span>)</span><br><span class="line">(<span class="string">b&#x27;H\xff\xc0H\xff\xc0&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>默认情况下，Keystone 使用 Intel 语法解析 x86 架构的汇编指令，如果要切换为 AT&amp;T 语法，可以使用以下代码：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ks = Ks(KS_ARCH_X86, KS_MODE_32)</span><br><span class="line">ks.syntax = KS_OPT_SYNTAX_ATT</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h1 id="Capstone"><a href="#Capstone" class="headerlink" title="Capstone"></a>Capstone</h1><p><strong>Capstone</strong> 是一个流行的反汇编框架，它与 Keystone 密切相关，但其功能侧重点不同。Keystone 主要负责将汇编代码转换为机器码（即汇编器），而 Capstone 则是一个反汇编库，专注于将机器码转换为汇编代码（即反汇编器）。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.capstone-engine.org/lang_python.html" >Capstone 官方文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="Capstone-安装"><a href="#Capstone-安装" class="headerlink" title="Capstone 安装"></a>Capstone 安装</h2><p>Capstone 提供了 Python 绑定，可以通过 <code>pip</code> 安装：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install capstone</span><br></pre></td></tr></table></figure></div>

<h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="创建-Capstone-对象"><a href="#创建-Capstone-对象" class="headerlink" title="创建 Capstone 对象"></a>创建 Capstone 对象</h3><p>首先，你需要创建一个 <strong>Capstone</strong> 反汇编对象，并设置目标架构和模式。<code>Cs</code> 类用于创建 Capstone 对象，<code>CS_ARCH_*</code> 和 <code>CS_MODE_*</code> 常量用于指定架构和模式。</p>
<p>这里架构和模式定义和 Keystone 库的类似，但具体类别稍有不同。不过对于我们绝大多数逆向需求来说我们不需要关系两者的区别。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># X86-64</span></span><br><span class="line"><span class="keyword">from</span> capstone.x86_const <span class="keyword">import</span> *</span><br><span class="line">cs = Cs(CS_ARCH_X86, CS_MODE_64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ARM</span></span><br><span class="line"><span class="keyword">from</span> capstone.arm_const <span class="keyword">import</span> *</span><br><span class="line">cs = Cs(CS_ARCH_ARM, CS_MODE_ARM)</span><br><span class="line">cs = Cs(CS_ARCH_ARM, CS_MODE_THUMB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># AARCH64</span></span><br><span class="line"><span class="keyword">from</span> capstone.arm64_const <span class="keyword">import</span> *</span><br><span class="line">cs = Cs(CS_ARCH_ARM64, CS_MODE_ARM)</span><br></pre></td></tr></table></figure></div>

<h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><p>我们可以使用 Capstone 反汇编对象的 <code>disasm</code> 方法来进行反汇编，该函数定义如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">disasm</span>(<span class="params">self, code, offset, count=<span class="number">0</span></span>) -&gt; <span class="string">&#x27;CsInsn&#x27;</span>:</span><br></pre></td></tr></table></figure></div>

<p><strong>参数：</strong></p>
<ul>
<li><p><strong><code>code: bytes</code></strong> ：表示输入参数 <code>code</code> 是一个字节串（<code>bytes</code> 类型），包含要反汇编的机器码。这个字节串通常来自二进制文件或内存中的机器码表示。</p>
</li>
<li><p><strong><code>offset: int</code></strong> ：<code>offset</code> 是一个整数类型的参数，表示机器码开始的地址（通常是内存中的起始地址）。这个参数是必需的，用来确定反汇编指令的起始位置，帮助计算每条指令的地址。</p>
</li>
<li><p><strong><code>count: int = 0</code></strong> ：<code>count</code> 是一个整数类型的参数，表示最多反汇编的指令数。默认值为 0，表示反汇编尽可能多的指令，直到代码结束或者遇到无效指令。如果设置了非零的 <code>count</code>，则最多反汇编 <code>count</code> 条指令。</p>
</li>
</ul>
<p><strong>返回值：</strong> 该函数返回一个生成器，每次迭代返回一个 <code>CsInsn</code> 对象，代表一条反汇编指令。<code>CsInsn</code> 对象包含以下信息：</p>
<ul>
<li><strong><code>address</code></strong> ：指令的地址，表示这条指令在内存中的位置（十六进制格式）。</li>
<li><strong><code>mnemonic</code></strong> ：指令的助记符（如：<code>mov</code>、<code>add</code>、<code>push</code> 等）。</li>
<li><strong><code>op_str</code></strong> ：指令的操作数（如：<code>eax, ebx</code> 或 <code>mem[rax]</code>）。</li>
<li><strong><code>size</code></strong> ：指令的字节大小，表示该指令在内存中占用了多少字节。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cs = Cs(CS_ARCH_X86, CS_MODE_64)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> insn <span class="keyword">in</span> cs.disasm(<span class="built_in">bytes</span>([<span class="number">72</span>, <span class="number">255</span>, <span class="number">192</span>, <span class="number">72</span>, <span class="number">255</span>, <span class="number">192</span>]),<span class="number">0</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;insn.mnemonic&#125;</span> <span class="subst">&#123;insn.op_str&#125;</span>&quot;</span>)</span><br><span class="line">...</span><br><span class="line">inc rax</span><br><span class="line">inc rax</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>默认情况下，Capstone 使用 Intel 语法解析 x86 架构的汇编指令，如果要切换为 AT&amp;T 语法，可以使用以下代码：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cs = Cs(CS_ARCH_X86, CS_MODE_32)</span><br><span class="line">cs.syntax = CS_OPT_SYNTAX_ATT</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<p>从 <code>disasm</code> 的函数定义我们发现，Capstone 不仅仅是简单的将机器码转为汇编指令，而是提供了一个描述汇编指令的对象 <code>CsInsn</code>，从而对汇编指令提供更细粒度的描述。</p>
<p>因此在打印汇编的时候我们需要手动将 <code>CsInsn.mnemonic</code> 和 <code>CsInsn.op_str</code> 拼接成一条汇编。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> insn <span class="keyword">in</span> cs.disasm(machine_code, address):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;insn.address:#x&#125;</span>: <span class="subst">&#123;insn.mnemonic&#125;</span> <span class="subst">&#123;insn.op_str&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>另外由于 <code>disasm</code> 返回的是一个迭代器，因此我们还可以作如下封装：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">disasm</span>(<span class="params">machine_code, address=<span class="number">0</span></span>):</span><br><span class="line">    asm_code = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> insn <span class="keyword">in</span> cs.disasm(machine_code, address):</span><br><span class="line">        asm_code += <span class="string">&quot;&#123;:8s&#125; &#123;&#125;;\n&quot;</span>.<span class="built_in">format</span>(insn.mnemonic, insn.op_str)</span><br><span class="line">    <span class="keyword">return</span> asm_code.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>另外除了上述四个成员外，如果我们开启 <code>Cs.detail = True</code> 选项时，<code>CsInsn</code> 还会多一个名为 <code>operands</code> 的字段，这个字段对于不同的架构是不同的。<code>CsInsn</code> 的 <code>operands</code> 在我们逆向辅助工具编写过程中十分重要，后面会有单独一节介绍。</p>
<p>当然如果我们将机器码反汇编得到 <code>CsInsn</code> 对象，尤其是 <code>Cs.detail</code> 选项开启时性能损耗将相当大。如果我们只需要基本数据，如地址、大小、助记符和操作数，我们可以使用更轻量的 API <code>disasm_lite()</code>。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">disasm_lite</span>(<span class="params">self, code: <span class="built_in">bytes</span>, offset: <span class="built_in">int</span>, count: <span class="built_in">int</span> = <span class="number">0</span></span>) -&gt; Generator[<span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">str</span>, <span class="built_in">str</span>], <span class="literal">None</span>, <span class="literal">None</span>]:</span><br></pre></td></tr></table></figure></div>

<p>从版本 2.1 开始，Python 绑定提供了这个新的 <code>disasm_lite()</code> 方法。与 <code>disasm()</code> 不同，<code>disasm_lite()</code> 只返回一个包含 <code>(address, size, mnemonic, op_str)</code> 的元组。基准测试显示，这个轻量级 API 比 <code>disasm()</code> 快最多 30%。</p>
<h2 id="CsInsn-对象"><a href="#CsInsn-对象" class="headerlink" title="CsInsn 对象"></a>CsInsn 对象</h2><p><code>CsInsn</code> 是 Capstone 库中用于表示反汇编指令的对象。在反汇编过程中，<code>CsInsn</code> 对象提供了每条指令的详细信息。通过 <code>CsInsn</code>，你可以访问与该指令相关的各种信息，如指令地址、助记符、操作数、寄存器访问、指令分组等。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>为了描述不同架构的指令，<code>CsInsn</code> 的成员比较多样，并且在的架构、指令不同时这成员也不同。因此这里给出一段辅助代码，可以方便在编写代码的时候快速查看 <code>CsInsn</code> 中的成员。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone.x86 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone.arm <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone.arm64 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone.mips <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone.ppc <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通用操作数处理函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_common_operands</span>(<span class="params">insn: CsInsn</span>):</span><br><span class="line">    <span class="keyword">for</span> i, op <span class="keyword">in</span> <span class="built_in">enumerate</span>(insn.operands):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Operand <span class="subst">&#123;i&#125;</span>:&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> op.<span class="built_in">type</span> == CS_OP_REG:</span><br><span class="line">            op_type = <span class="string">&quot;CS_OP_REG&quot;</span></span><br><span class="line">            value = insn.reg_name(op.reg)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;    Type: <span class="subst">&#123;op_type&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;    Value: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> op.<span class="built_in">type</span> == CS_OP_IMM:</span><br><span class="line">            op_type = <span class="string">&quot;CS_OP_IMM&quot;</span></span><br><span class="line">            value = <span class="string">f&quot;0x<span class="subst">&#123;op.imm:x&#125;</span>&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;    Type: <span class="subst">&#123;op_type&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;    Value: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> op.<span class="built_in">type</span> == CS_OP_MEM:</span><br><span class="line">            op_type = <span class="string">&quot;CS_OP_MEM&quot;</span></span><br><span class="line">            mem = op.mem</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;    Type: <span class="subst">&#123;op_type&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;    Value:&quot;</span>)</span><br><span class="line">            indent = <span class="string">&quot;        &quot;</span></span><br><span class="line">            <span class="keyword">if</span> mem.segment != <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;indent&#125;</span>Segment: <span class="subst">&#123;insn.reg_name(mem.segment)&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> mem.base != <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;indent&#125;</span>Base: <span class="subst">&#123;insn.reg_name(mem.base)&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> mem.index != <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;indent&#125;</span>Index: <span class="subst">&#123;insn.reg_name(mem.index)&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;indent&#125;</span>Scale: <span class="subst">&#123;mem.scale&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> mem.disp != <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;indent&#125;</span>Disp: <span class="subst">&#123;mem.disp:#x&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> mem.segment == <span class="number">0</span> <span class="keyword">and</span> mem.base == <span class="number">0</span> <span class="keyword">and</span> mem.index == <span class="number">0</span> <span class="keyword">and</span> mem.disp == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;indent&#125;</span>None&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> op.<span class="built_in">type</span> == CS_OP_FP:</span><br><span class="line">            op_type = <span class="string">&quot;CS_OP_FP&quot;</span></span><br><span class="line">            value = <span class="string">f&quot;<span class="subst">&#123;op.fp&#125;</span>&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;    Type: <span class="subst">&#123;op_type&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;    Value: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;    Type: Unknown&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;    Value: N/A&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 架构特有的操作数处理函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_x86_operands</span>(<span class="params">insn: CsInsn</span>):</span><br><span class="line">    <span class="comment"># 这里只处理 x86 特有的操作数类型</span></span><br><span class="line">    <span class="comment"># 其他通用操作数类型在 handle_common_operands 里处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_arm64_operands</span>(<span class="params">insn: CsInsn</span>):</span><br><span class="line">    <span class="comment"># 这里只处理 ARM64 特有的操作数类型</span></span><br><span class="line">    <span class="comment"># 其他通用操作数类型在 handle_common_operands 里处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_arm_operands</span>(<span class="params">insn: CsInsn</span>):</span><br><span class="line">    <span class="comment"># 这里只处理 ARM 特有的操作数类型</span></span><br><span class="line">    <span class="comment"># 其他通用操作数类型在 handle_common_operands 里处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_mips_operands</span>(<span class="params">insn: CsInsn</span>):</span><br><span class="line">    <span class="comment"># 这里只处理 MIPS 特有的操作数类型</span></span><br><span class="line">    <span class="comment"># 其他通用操作数类型在 handle_common_operands 里处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_ppc_operands</span>(<span class="params">insn: CsInsn</span>):</span><br><span class="line">    <span class="comment"># 这里只处理 PPC 特有的操作数类型</span></span><br><span class="line">    <span class="comment"># 其他通用操作数类型在 handle_common_operands 里处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义架构到操作数处理函数的映射</span></span><br><span class="line">ARCH_OPERAND_HANDLERS = &#123;</span><br><span class="line">    CS_ARCH_X86: handle_x86_operands,</span><br><span class="line">    CS_ARCH_ARM64: handle_arm64_operands,</span><br><span class="line">    CS_ARCH_ARM: handle_arm_operands,</span><br><span class="line">    CS_ARCH_MIPS: handle_mips_operands,</span><br><span class="line">    CS_ARCH_PPC: handle_ppc_operands,</span><br><span class="line">    <span class="comment"># 添加更多架构的处理函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_insn_detail</span>(<span class="params">insn: CsInsn</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 打印指令的基本信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;========== Instruction Detail ==========&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;insn.address:#x&#125;</span> [<span class="subst">&#123;<span class="string">&#x27; &#x27;</span>.join([<span class="string">f&#x27;<span class="subst">&#123;b:02X&#125;</span>&#x27;</span> <span class="keyword">for</span> b <span class="keyword">in</span> insn.<span class="built_in">bytes</span>])&#125;</span>]: <span class="subst">&#123;insn.mnemonic&#125;</span> <span class="subst">&#123;insn.op_str&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打印寄存器读写情况</span></span><br><span class="line">        regs_read, regs_write = insn.regs_access()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> regs_read:</span><br><span class="line">            regs_read_names = <span class="string">&#x27;, &#x27;</span>.join(insn.reg_name(reg) <span class="keyword">for</span> reg <span class="keyword">in</span> regs_read)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Registers read: <span class="subst">&#123;regs_read_names&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> regs_write:</span><br><span class="line">            regs_write_names = <span class="string">&#x27;, &#x27;</span>.join(insn.reg_name(reg) <span class="keyword">for</span> reg <span class="keyword">in</span> regs_write)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Registers written: <span class="subst">&#123;regs_write_names&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打印操作数详细信息</span></span><br><span class="line">        <span class="comment"># 获取并调用对应架构的操作数处理函数</span></span><br><span class="line">        arch = insn._cs.arch</span><br><span class="line">        handler = ARCH_OPERAND_HANDLERS.get(arch)</span><br><span class="line">        <span class="keyword">if</span> handler:</span><br><span class="line">            handler(insn)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Unsupported architecture: <span class="subst">&#123;arch&#125;</span>\n&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 调用通用的操作数处理函数</span></span><br><span class="line">        handle_common_operands(insn)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;=========================================\n&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error processing instruction at 0x<span class="subst">&#123;insn.address:x&#125;</span>: <span class="subst">&#123;e&#125;</span>\n&quot;</span>)</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h3 id="基本字段"><a href="#基本字段" class="headerlink" title="基本字段"></a>基本字段</h3><p><code>CsInsn</code> 对象提供了对反汇编指令的基本信息的访问，主要包括以下四个基本字段：</p>
<ul>
<li><strong><code>address</code></strong> ：指令的地址，表示这条指令在内存中的位置（十六进制格式）。</li>
<li><strong><code>mnemonic</code></strong> ：指令的助记符（如：<code>mov</code>、<code>add</code>、<code>push</code> 等）。</li>
<li><strong><code>op_str</code></strong> ：指令的操作数（如：<code>eax, ebx</code> 或 <code>mem[rax]</code>）。</li>
<li><strong><code>size</code></strong> ：指令的字节大小，表示该指令在内存中占用了多少字节。</li>
</ul>
<h3 id="寄存器读写"><a href="#寄存器读写" class="headerlink" title="寄存器读写"></a>寄存器读写</h3><p><code>CsInsn</code> 还提供了关于寄存器操作的详细信息。通过该信息可以知道指令涉及到哪些寄存器，并且是如何使用它们的：</p>
<ul>
<li><p><strong><code>regs_read()</code></strong> ：该方法返回一个指令中被读取的寄存器的集合，通常是一个整数列表，代表寄存器的编号。</p>
</li>
<li><p><strong><code>regs_write()</code></strong> ：该方法返回一个指令中被写入的寄存器的集合，通常也是一个整数列表，表示写入的寄存器编号。</p>
</li>
<li><p><strong><code>reg_read(reg_id)</code></strong> ：该方法用于检查特定的寄存器是否被指令读取。传入寄存器的 ID，如果该寄存器被读取，返回 <code>True</code>，否则返回 <code>False</code>。</p>
</li>
<li><p><strong><code>reg_write(reg_id)</code></strong> ：该方法用于检查特定的寄存器是否被指令写入。传入寄存器的 ID，如果该寄存器被写入，返回 <code>True</code>，否则返回 <code>False</code>。</p>
</li>
<li><p><strong><code>regs_access()</code></strong> ：返回一个元组，包含 <code>regs_read()</code> 和 <code>regs_write()</code> 两个方法的结果。</p>
</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>这里得到的寄存器 ID 不是很直观，<code>CsInsn</code> 有一个 <code>reg_name</code> 方法可以将寄存器编号转换为寄存器的名称。</p>

    </div>
  </div>

<h3 id="操作数字段"><a href="#操作数字段" class="headerlink" title="操作数字段"></a>操作数字段</h3><h4 id="操作数结构"><a href="#操作数结构" class="headerlink" title="操作数结构"></a>操作数结构</h4><p><code>CsInsn</code> 中的 <code>operands</code> 字段包含了与指令相关的操作数。由于一条指令可能涉及多个操作数，因此 <code>operands</code> 是一个数组其中每一个元素对应一个操作数，顺序和指令中操作数的顺序相同。</p>
<p>由于操作数是 Capstone 底层库获取到的，因此实际上这里 <code>operands</code> 中的元素是定义的 <code>ctypes</code> 结构体。对于不同的架构这个结构体的成员不同。</p>
<p>以 X86 架构为例，<code>operands</code> 中的元素是的类型 <code>X86Op</code> 定义如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X86OpMem</span>(ctypes.Structure):</span><br><span class="line">    <span class="comment"># 该类表示x86架构中的内存操作数结构。</span></span><br><span class="line">    <span class="comment"># 定义了用于内存寻址的不同部分：段、基址、索引、缩放因子和偏移量</span></span><br><span class="line">    _fields_ = (</span><br><span class="line">        (<span class="string">&#x27;segment&#x27;</span>, ctypes.c_uint),  <span class="comment"># 内存段（如：段寄存器，通常为0）</span></span><br><span class="line">        (<span class="string">&#x27;base&#x27;</span>, ctypes.c_uint),     <span class="comment"># 基址寄存器（如：eax、ebx等）</span></span><br><span class="line">        (<span class="string">&#x27;index&#x27;</span>, ctypes.c_uint),    <span class="comment"># 索引寄存器（通常用于数组或结构体寻址）</span></span><br><span class="line">        (<span class="string">&#x27;scale&#x27;</span>, ctypes.c_int),     <span class="comment"># 缩放因子（例如：4，用于字节对齐）</span></span><br><span class="line">        (<span class="string">&#x27;disp&#x27;</span>, ctypes.c_int64),    <span class="comment"># 偏移量（例如：+0x10或-8）</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X86OpValue</span>(ctypes.<span class="type">Union</span>):</span><br><span class="line">    <span class="comment"># 该类定义了x86操作数的值，可以是寄存器、立即数或内存。</span></span><br><span class="line">    <span class="comment"># 使用ctypes.Union以节省内存，只能使用其中一个值</span></span><br><span class="line">    _fields_ = (</span><br><span class="line">        (<span class="string">&#x27;reg&#x27;</span>, ctypes.c_uint),    <span class="comment"># 寄存器（如：eax、ebx等）</span></span><br><span class="line">        (<span class="string">&#x27;imm&#x27;</span>, ctypes.c_int64),   <span class="comment"># 立即数（如：0x10、42等）</span></span><br><span class="line">        (<span class="string">&#x27;mem&#x27;</span>, X86OpMem),         <span class="comment"># 内存操作数，包含内存段、基址、索引、缩放因子和偏移量</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X86Op</span>(ctypes.Structure):</span><br><span class="line">    <span class="comment"># 该类表示x86指令中的操作数，包含了操作数的类型、值、大小、访问权限等信息</span></span><br><span class="line">    _fields_ = (</span><br><span class="line">        (<span class="string">&#x27;type&#x27;</span>, ctypes.c_uint),           <span class="comment"># 操作数类型，表示该操作数是寄存器、立即数、内存等</span></span><br><span class="line">        (<span class="string">&#x27;value&#x27;</span>, X86OpValue),             <span class="comment"># 操作数的具体值（寄存器、立即数或内存）</span></span><br><span class="line">        (<span class="string">&#x27;size&#x27;</span>, ctypes.c_uint8),          <span class="comment"># 操作数的大小（例如：32位或64位）</span></span><br><span class="line">        (<span class="string">&#x27;access&#x27;</span>, ctypes.c_uint8),        <span class="comment"># 操作数的访问类型（读、写或读写）</span></span><br><span class="line">        (<span class="string">&#x27;avx_bcast&#x27;</span>, ctypes.c_uint),      <span class="comment"># AVX广播类型</span></span><br><span class="line">        (<span class="string">&#x27;avx_zero_opmask&#x27;</span>, ctypes.c_bool), <span class="comment"># AVX零操作掩码</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">imm</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 返回立即数值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.value.imm</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reg</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 返回寄存器编号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.value.reg</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mem</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 返回内存操作数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.value.mem</span><br></pre></td></tr></table></figure></div>

<p>从上述代码中可以看出，操作数可以是寄存器、立即数、内存地址等不同的类型。Capstone 通过操作数结构体中的 <code>type</code> 字段来描述操作数的类型，见的操作数类型有（当然除了这些之外还有一些各架构独有的操作数类型，这些类型的名称通常为 <code>&lt;架构&gt;_OP_&lt;类型&gt;</code>，例如 <code>ARM64_OP_CIMM</code>）：</p>
<ul>
<li><strong><code>CS_OP_REG</code></strong> ：表示寄存器操作数（如 <code>eax</code>、<code>ebx</code>）。</li>
<li><strong><code>CS_OP_IMM</code></strong> ：表示立即数操作数（如 <code>0x10</code>、<code>42</code>）。</li>
<li><strong><code>CS_OP_MEM</code></strong> ：表示内存操作数（如 <code>mem[eax+4]</code>）。</li>
<li><strong><code>CS_OP_FP</code></strong> ：表示浮点数操作数。</li>
</ul>
<p>对应不同类型的操作数，<code>value</code> 字段作为联合体有 <code>reg</code>、<code>imm</code>、<code>mem</code> 三种类型。我们可以根据操作数的类型从对应的结构中获取我们想要的值。</p>
<p>由于操作数对象提供了 <code>imm</code>、<code>reg</code>、<code>mem</code> 三种方法来封装 <code>value</code> 字段的访问，因此我们可以使用例如 <code>insn.operands[1].mem.base</code> 这种方式跳过 <code>value</code> 直接访问联合体中的成员。</p>
<h4 id="内存操作数"><a href="#内存操作数" class="headerlink" title="内存操作数"></a>内存操作数</h4><p>因为会经常用到，这里要着重说明一下内存操作数的结构。内存操作数是指令中用于描述内存地址的操作数类型，通常在汇编指令中通过指定内存地址、基址寄存器、索引寄存器和偏移量来进行内存访问。</p>
<p>在 Capstone 库中，内存操作数的类型为 <code>CS_OP_MEM</code>，并且通过 <code>CsOperand</code> 对象的 <code>mem</code> 字段来描述相关的内存信息。还是以前面的 <code>X86OpMem</code> 结构体举例：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X86OpMem</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = (</span><br><span class="line">        (<span class="string">&#x27;segment&#x27;</span>, ctypes.c_uint),  <span class="comment"># 内存段寄存器，通常为 0</span></span><br><span class="line">        (<span class="string">&#x27;base&#x27;</span>, ctypes.c_uint),     <span class="comment"># 基址寄存器，例如 eax、rbx 等</span></span><br><span class="line">        (<span class="string">&#x27;index&#x27;</span>, ctypes.c_uint),    <span class="comment"># 索引寄存器，例如 esi、edi 等</span></span><br><span class="line">        (<span class="string">&#x27;scale&#x27;</span>, ctypes.c_int),     <span class="comment"># 缩放因子，例如 4（字节对齐）</span></span><br><span class="line">        (<span class="string">&#x27;disp&#x27;</span>, ctypes.c_int64),    <span class="comment"># 偏移量，表示地址的固定偏移</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>segment</code></strong> ：内存段寄存器，在现代架构中通常为 <code>0</code>，表示直接访问内存，而不通过特定的段寄存器。如果涉及到段寻址（例如在 x86 16 位模式下），此字段可能会有所变化。</li>
<li><strong><code>base</code></strong> ：基址寄存器，是计算内存地址的基础寄存器。通过将基址寄存器的值与偏移量 <code>disp</code> 相加，可以确定内存地址。例如，<code>eax</code> 或 <code>ebx</code> 通常用于存储基地址。</li>
<li><strong><code>index</code></strong> ：索引寄存器，是一个可选的寄存器，通常用于数组、结构体等类型的数据访问。通过 <code>base + (index * scale) + disp</code> 可以计算出最终的内存地址。<code>index</code> 通常用于访问内存中的多个元素，例如数组的每个元素，<code>scale</code> 会控制每次索引跳跃的大小。</li>
<li><strong><code>scale</code></strong> ：缩放因子，用于乘以索引寄存器的值，以调整访问的大小。对于数据结构的访问，这个字段决定了如何调整内存访问的步长。例如，访问一个 <code>int</code> 类型数组时，<code>scale</code> 通常为 <code>4</code>（因为一个 <code>int</code> 占 4 字节）。</li>
<li><strong><code>disp</code></strong> ：偏移量，表示相对于基址和索引寄存器的地址偏移量。它通常是一个常数，表示在基地址或索引基础上额外的偏移量。例如，<code>[eax + 4]</code> 中的偏移量就是 <code>4</code>。</li>
</ul>
<h5 id="x86-架构"><a href="#x86-架构" class="headerlink" title="x86 架构"></a>x86 架构</h5><p>在 x86-64 架构中，内存操作数常常包含基址寄存器、索引寄存器、缩放因子和偏移量，下面的汇编指令是 x86-64 中的一个常见例子：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">rax</span>, [<span class="built_in">rbx</span> + <span class="built_in">rcx</span>*<span class="number">4</span> + <span class="number">0x10</span>]</span><br></pre></td></tr></table></figure></div>

<p>这条指令的操作数对应 Capstone 的内存操作数结构如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对应 Capstone 解析的结构体</span></span><br><span class="line">mem = insn.operands[<span class="number">1</span>].mem</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Segment: <span class="subst">&#123;mem.segment&#125;</span>&quot;</span>)   <span class="comment"># 通常为 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Base: <span class="subst">&#123;insn.reg_name(mem.base)&#125;</span>&quot;</span>)  <span class="comment"># rbx</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Index: <span class="subst">&#123;insn.reg_name(mem.index)&#125;</span>&quot;</span>)  <span class="comment"># rcx</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Scale: <span class="subst">&#123;mem.scale&#125;</span>&quot;</span>)  <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Disp: <span class="subst">&#123;<span class="built_in">hex</span>(mem.disp)&#125;</span>&quot;</span>)  <span class="comment"># 0x10</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>segment</strong> ：<code>0</code>（通常为 0，因为没有特别指定段寄存器）</li>
<li><strong>base</strong> ：<code>rbx</code>（基址寄存器）</li>
<li><strong>index</strong> ：<code>rcx</code>（索引寄存器）</li>
<li><strong>scale</strong> ：<code>4</code>（数组或数据元素大小，通常是 <code>4</code>）</li>
<li><strong>disp</strong> ：<code>0x10</code>（偏移量）</li>
</ul>
<p>通常来说，X86 从全局变量读取数据的指令为：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> reg, <span class="built_in">qword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">rip</span> + disp]</span><br></pre></td></tr></table></figure></div>

<p>因此我们可以计算全局变量的地址：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insn.operands[<span class="number">1</span>].mem.disp + insn.address + insn.size</span><br></pre></td></tr></table></figure></div>

<h5 id="ARM-架构"><a href="#ARM-架构" class="headerlink" title="ARM 架构"></a>ARM 架构</h5><p>ARM 架构使用类似于 <code>x86</code> 的寻址模式，但是语法和寄存器命名方式不同。例如下面这条汇编指令是将 <code>r1 + (r2 &lt;&lt; 2)</code> 计算出的内存地址中的值加载到 <code>r0</code> 寄存器：</p>
<div class="code-container" data-rel="Armasm"><figure class="iseeu highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr</span> <span class="built_in">r0</span>, [<span class="built_in">r1</span>, <span class="built_in">r2</span>, <span class="keyword">lsl</span> <span class="number">#2</span>]</span><br></pre></td></tr></table></figure></div>

<p>这条指令的操作数对应 Capstone 的内存操作数结构如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对应 Capstone 解析的结构体</span></span><br><span class="line">mem = op.mem</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Segment: <span class="subst">&#123;mem.segment&#125;</span>&quot;</span>)   <span class="comment"># 通常为 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Base: <span class="subst">&#123;insn.reg_name(mem.base)&#125;</span>&quot;</span>)  <span class="comment"># r1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Index: <span class="subst">&#123;insn.reg_name(mem.index)&#125;</span>&quot;</span>)  <span class="comment"># r2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Scale: <span class="subst">&#123;mem.scale&#125;</span>&quot;</span>)  <span class="comment"># 4 (因为 lsl #2 是左移两位，相当于乘 4)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Disp: <span class="subst">&#123;<span class="built_in">hex</span>(mem.disp)&#125;</span>&quot;</span>)  <span class="comment"># 0</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>segment</strong> ：<code>0</code>（默认段选择符）</li>
<li><strong>base</strong> ：<code>r1</code>（基址寄存器）</li>
<li><strong>index</strong> ：<code>r2</code>（索引寄存器）</li>
<li><strong>scale</strong> ：<code>4</code>（因为 <code>lsl #2</code> 是左移 2 位，相当于乘 4）</li>
<li><strong>disp</strong> ：<code>0</code>（没有偏移量）</li>
</ul>
<p>由于 ARM 架构的指令不能直接操作内存，因此无法直接根据全局变量的地址读取全局变量的数据，而是：</p>
<ol>
<li>先将编译在函数后面的地址表中的全局变量的地址加载到寄存器中。</li>
<li>然后还可能跟 <code>pc</code> 寄存器相加顺便实现地址无关代码</li>
<li>最后再通过寄存器访问全局变量所在的地址读取数据。</li>
</ol>
<p>也就是通常来说 ARM 架构从全局变量读取数据的指令为：</p>
<div class="code-container" data-rel="Armasm"><figure class="iseeu highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr</span> <span class="built_in">r1</span>, [<span class="built_in">pc</span>, <span class="symbol">#disp</span>]	<span class="comment">; 从 (pc + disp) 计算出的内存地址加载数据到 r1</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">r1</span>, <span class="built_in">r1</span>, <span class="built_in">pc</span>      <span class="comment">; 将 pc 加上偏移量后的地址值加到 r1，得到目标地址</span></span><br><span class="line"><span class="keyword">ldr</span> <span class="built_in">r2</span>, [<span class="built_in">r1</span>]        <span class="comment">; 从 r1 指向的内存地址加载数据到 r2</span></span><br></pre></td></tr></table></figure></div>

<p>由于编译器的针对 CPU 流水线的优化，这些指令之间可能还会穿插其它的指令。因此我们不能直接通过指令得出全局变量的地址。不过这里我们可以先获取指令序列 <code>insn_list</code>，然后简单模拟一下这个从内存加载数据的过程来计算全局变量的地址。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">reg_value = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> insn <span class="keyword">in</span> insn_list:</span><br><span class="line">    <span class="comment"># ldr r1, [pc, #0xf0]</span></span><br><span class="line">    <span class="keyword">if</span> insn.mnemonic == <span class="string">&#x27;ldr&#x27;</span> \</span><br><span class="line">            <span class="keyword">and</span> insn.operands[<span class="number">0</span>].<span class="built_in">type</span> == ARM_OP_REG \</span><br><span class="line">            <span class="keyword">and</span> insn.operands[<span class="number">1</span>].<span class="built_in">type</span> == ARM_OP_MEM \</span><br><span class="line">            <span class="keyword">and</span> insn.operands[<span class="number">1</span>].mem.base == ARM_REG_PC:</span><br><span class="line">        reg_value[insn.operands[<span class="number">0</span>].reg] = idc.get_wide_dword((insn.address + <span class="number">4</span> + insn.operands[<span class="number">1</span>].mem.disp) &amp; ~<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># add r1, pc</span></span><br><span class="line">    <span class="keyword">elif</span> insn.mnemonic == <span class="string">&#x27;add&#x27;</span> \</span><br><span class="line">            <span class="keyword">and</span> insn.operands[<span class="number">0</span>].<span class="built_in">type</span> == ARM_OP_REG \</span><br><span class="line">            <span class="keyword">and</span> insn.operands[<span class="number">1</span>].<span class="built_in">type</span> == ARM_OP_REG \</span><br><span class="line">            <span class="keyword">and</span> insn.operands[<span class="number">1</span>].reg == ARM_REG_PC \</span><br><span class="line">            <span class="keyword">and</span> insn.operands[<span class="number">0</span>].reg <span class="keyword">in</span> reg_value.keys():</span><br><span class="line">        reg = insn.operands[<span class="number">0</span>].reg</span><br><span class="line">        reg_value[reg] = reg_value[reg] + insn.address + <span class="number">4</span></span><br><span class="line">        <span class="keyword">if</span> idc.get_segm_name(reg_value[reg]) == <span class="string">&#x27;.rodata&#x27;</span>: <span class="comment"># 全局变量应该放在 .rodata 段中</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;global var addr: <span class="subst">&#123;reg_value[reg]:#x&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> insn.mnemonic.startswith(<span class="string">&#x27;b&#x27;</span>):</span><br><span class="line">        reg_value.clear()</span><br></pre></td></tr></table></figure></div>

<h5 id="AArch64-架构"><a href="#AArch64-架构" class="headerlink" title="AArch64 架构"></a>AArch64 架构</h5><p>AArch64 是 ARM 的 64 位版本，它使用与 ARM 相似的寻址模式。AArch64 允许更复杂的寻址模式，包括有符号立即数、寄存器和可选的缩放因子。例如下面这条汇编指令是将 <code>x1 + (x2 &lt;&lt; 3)</code> 计算出的内存地址中的值加载到 <code>x0</code> 寄存器：</p>
 <div class="code-container" data-rel="Armasm"><figure class="iseeu highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr</span> <span class="built_in">x0</span>, [<span class="built_in">x1</span>, <span class="built_in">x2</span>, <span class="keyword">lsl</span> <span class="number">#3</span>]</span><br></pre></td></tr></table></figure></div>

<p>这条指令的操作数对应 Capstone 的内存操作数结构如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对应 Capstone 解析的结构体</span></span><br><span class="line">mem = op.mem</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Segment: <span class="subst">&#123;mem.segment&#125;</span>&quot;</span>)   <span class="comment"># 通常为 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Base: <span class="subst">&#123;insn.reg_name(mem.base)&#125;</span>&quot;</span>)  <span class="comment"># x1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Index: <span class="subst">&#123;insn.reg_name(mem.index)&#125;</span>&quot;</span>)  <span class="comment"># x2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Scale: <span class="subst">&#123;mem.scale&#125;</span>&quot;</span>)  <span class="comment"># 8 (因为 lsl #3 是左移三位，相当于乘 8)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Disp: <span class="subst">&#123;<span class="built_in">hex</span>(mem.disp)&#125;</span>&quot;</span>)  <span class="comment"># 0</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>segment</strong> ：<code>0</code>（默认段选择符）</li>
<li><strong>base</strong> ：<code>x1</code>（基址寄存器）</li>
<li><strong>index</strong> ：<code>x2</code>（索引寄存器）</li>
<li><strong>scale</strong> ：<code>8</code>（因为 <code>lsl #3</code> 是左移 3 位，相当于乘 8）</li>
<li><strong>disp</strong> ：<code>0</code>（没有偏移量）</li>
</ul>
<p>AArch64 架构的指令同样不能直接操作内存，因此无法直接根据全局变量的地址读取全局变量的数据，而是：</p>
<ol>
<li>通过 <code>adrp</code> 指令将全局变量地址所在内存页的基地址加载到寄存器中。由于 AArch64 是基于页面地址访问的，<code>adrp</code> 将会设置寄存器为地址的页对齐值。</li>
<li>将存有页基址的寄存器加上某个偏移量，使其指向全局变量。</li>
<li>通过 <code>ldr</code> 或 <code>ldp</code> 等指令从该寄存器指向的内存中读入数据。</li>
</ol>
<p>也就是通常来说 AArch64 架构从全局变量读取数据的指令为：</p>
<div class="code-container" data-rel="Armasm"><figure class="iseeu highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">adrp</span> <span class="built_in">x2</span>, <span class="number">#0x37ff000</span>	<span class="comment">; 将页面的基地址加载到寄存器 x2 中</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">x2</span>, <span class="built_in">x2</span>, <span class="number">#0x148</span>	<span class="comment">; 将基地址加上偏移量 #0x148 从而计算出完整的内存地址</span></span><br><span class="line"><span class="symbol">ldp</span> <span class="built_in">x4</span>, <span class="built_in">x5</span>, [<span class="built_in">x2</span>]	<span class="comment">; 从 x2 指向的地址加载两个数据项，分别存入寄存器 x4 和 x5</span></span><br></pre></td></tr></table></figure></div>

<p>同样我们可以参考 ARM 架构的做法来计算全局变量的地址。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">reg_value = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> insn <span class="keyword">in</span> insn_list:</span><br><span class="line">    <span class="comment"># adrp x2, #0x37ff000</span></span><br><span class="line">    <span class="keyword">if</span> insn.mnemonic == <span class="string">&#x27;adrp&#x27;</span> \</span><br><span class="line">            <span class="keyword">and</span> insn.operands[<span class="number">0</span>].<span class="built_in">type</span> == ARM64_OP_REG \</span><br><span class="line">            <span class="keyword">and</span> insn.operands[<span class="number">1</span>].<span class="built_in">type</span> == ARM64_OP_IMM:</span><br><span class="line">        reg_value[insn.operands[<span class="number">0</span>].reg] = insn.operands[<span class="number">1</span>].imm</span><br><span class="line">    <span class="comment"># add x2, x2, #0x148</span></span><br><span class="line">    <span class="keyword">elif</span> insn.mnemonic == <span class="string">&#x27;add&#x27;</span> \</span><br><span class="line">            <span class="keyword">and</span> insn.operands[<span class="number">0</span>].<span class="built_in">type</span> == ARM64_OP_REG \</span><br><span class="line">            <span class="keyword">and</span> insn.operands[<span class="number">1</span>].<span class="built_in">type</span> == ARM64_OP_REG \</span><br><span class="line">            <span class="keyword">and</span> insn.operands[<span class="number">2</span>].<span class="built_in">type</span> == ARM64_OP_IMM \</span><br><span class="line">            <span class="keyword">and</span> insn.operands[<span class="number">0</span>].reg == insn.operands[<span class="number">1</span>].reg \</span><br><span class="line">            <span class="keyword">and</span> insn.operands[<span class="number">0</span>].reg <span class="keyword">in</span> reg_value.keys():</span><br><span class="line">        reg = insn.operands[<span class="number">0</span>].reg</span><br><span class="line">        reg_value[reg] += insn.operands[<span class="number">2</span>].imm</span><br><span class="line">        <span class="keyword">if</span> idc.get_segm_name(reg_value[reg]) == <span class="string">&#x27;.rodata&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;global var addr: <span class="subst">&#123;reg_value[reg]:#x&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> insn.mnemonic.startswith(<span class="string">&#x27;b&#x27;</span>):</span><br><span class="line">        reg_value.clear()</span><br></pre></td></tr></table></figure></div>

<h1 id="angr"><a href="#angr" class="headerlink" title="angr"></a>angr</h1><p><strong>angr</strong> 是一个多架构二进制分析工具包，能够执行动态符号执行（类似于 Mayhem、KLEE 等）以及各种静态分析。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://docs.angr.io/en/latest/" >angr 官方文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>我们可以简单的将 angr 理解为 <strong>IdaPython + 符号执行</strong>。也就是说：</p>
<ul>
<li>我们可以将 angr 作为 IdaPython 的替代品。<ul>
<li>可以批量对二进制程序进行静态分析，因为不需要将待分析的二进制文件逐个用 Ida 打开。</li>
<li>可以加快分析速度，因为我们不需要像 IdaPython 那样对程序进行完整的分析，比如说我们可以先通过搜索特征定位到关键位置，然后只分析关键位置处的代码。</li>
<li>可以结合 Unicorn 等模拟执行工具实现程序的动态分析，可以应对批量处理分析二进制程序时遇到不同程序之间代码存在差异的问题。</li>
</ul>
</li>
<li>我们还可以使用 angr 的符号执行功能，来弥补静态分析和动态分析的缺陷。<ul>
<li>静态分析可能难以处理复杂的控制流（如动态跳转），而动态分析需要依赖真实输入才能覆盖路径。angr 的符号执行功能通过符号化输入的方式探索路径，可以弥补这两者的不足。</li>
<li>由于结合 Unicorn 等模拟执行工具实现程序的动态分析是手动结合的，对于一些特殊的二进制文件可能会出问题，如果可以的话直接用 angr 的符号执行计算一些结果会稳定一些。</li>
</ul>
</li>
</ul>

    </div>
  </div>

<h2 id="angr-安装"><a href="#angr-安装" class="headerlink" title="angr 安装"></a>angr 安装</h2><p>直接通过 pip 安装。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install angr</span><br></pre></td></tr></table></figure></div>

<p>另外还有一个 <code>angr-management</code> 是基于 angr 实现的低配版 IDA。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install angr-management</span><br></pre></td></tr></table></figure></div>

<p>安装完之后运行 <code>angr-management</code> 命令即可启动，用法和 IDA 基本一样。不过这里我们主要还是在编写逆向辅助工具的时候使用里面的一些 API。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">angr-management</span><br></pre></td></tr></table></figure></div>

<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><h3 id="二进制文件加载"><a href="#二进制文件加载" class="headerlink" title="二进制文件加载"></a>二进制文件加载</h3><h4 id="加载项目（Project）"><a href="#加载项目（Project）" class="headerlink" title="加载项目（Project）"></a>加载项目（Project）</h4><h5 id="加载选项"><a href="#加载选项" class="headerlink" title="加载选项"></a>加载选项</h5><p>angr 的第一步是将二进制文件加载到一个项目中。</p>
<blockquote>
<p>项目（Project）是你在 angr 中的控制中心。通过它，你可以对加载的可执行文件执行分析和模拟。在 angr 中，几乎所有你要使用的对象都在某种形式上依赖于一个项目。</p>
</blockquote>
<p>我们以 <code>/bin/true</code> 为例：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> angr</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj = angr.Project(<span class="string">&#x27;/bin/true&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>当你使用 <code>angr.Project</code> 加载文件时，可以将选项直接传递给 <code>Project</code> 构造函数，它们会被转发给 CLE。CLE 有如下常用选项：</p>
<ul>
<li><strong><code>auto_load_libs</code></strong> ：控制是否自动解析共享库依赖，默认值为 <code>True</code>。</li>
<li><strong><code>except_missing_libs</code></strong> ：与 <code>auto_load_libs</code> 相反。如果设置为 <code>True</code>，当无法解析共享库依赖时会抛出异常。</li>
<li><strong><code>force_load_libs</code></strong> ：一个字符串列表，强制指定某些库为未解析的共享库依赖。</li>
<li><strong><code>skip_libs</code></strong> ：一个字符串列表，防止某些库名被解析为依赖。</li>
<li><strong><code>ld_path</code></strong> ：一个字符串或字符串列表，用作共享库的额外搜索路径，优先于默认路径。</li>
</ul>
<p>你还可以使用 <code>main_opts</code> 和 <code>lib_opts</code> 来针对特定的二进制对象设置选项：</p>
<ul>
<li><strong><code>main_opts</code></strong> ：是一个选项名称到值的映射，适用于主二进制。</li>
<li><strong><code>lib_opts</code></strong> ：是一个以库名为键、选项字典为值的映射，适用于特定共享库。</li>
</ul>
<p>常见选项包括：</p>
<ul>
<li><p><strong><code>backend</code></strong> ：指定使用的后端。</p>
<blockquote>
<p>CLE 当前支持以下静态加载后端：ELF、PE、CGC、Mach-O、ELF 核心转储（core dump）文件。通常情况下，CLE 会自动检测正确的后端，因此除非有非常特殊的需求，否则无需手动指定后端。</p>
<p>如果需要强制使用某个后端，可以在选项字典中包含一个 <code>backend</code> 键。某些后端无法自动检测架构，必须通过 <code>arch</code> 参数指定。</p>
<p>以下是支持的后端列表：</p>
<table>
<thead>
<tr>
<th>后端名称</th>
<th>描述</th>
<th>是否需要指定架构（arch）？</th>
</tr>
</thead>
<tbody><tr>
<td><strong>elf</strong></td>
<td>基于 PyELFTools 的 ELF 文件静态加载器</td>
<td>否</td>
</tr>
<tr>
<td><strong>pe</strong></td>
<td>基于 PEFile 的 PE 文件静态加载器</td>
<td>否</td>
</tr>
<tr>
<td><strong>mach-o</strong></td>
<td>Mach-O 文件静态加载器，不支持动态链接或重定位</td>
<td>否</td>
</tr>
<tr>
<td><strong>cgc</strong></td>
<td>Cyber Grand Challenge 二进制文件静态加载器</td>
<td>否</td>
</tr>
<tr>
<td><strong>backedcgc</strong></td>
<td>支持指定内存和寄存器的 CGC 二进制加载器</td>
<td>否</td>
</tr>
<tr>
<td><strong>elfcore</strong></td>
<td>ELF 核心转储静态加载器</td>
<td>否</td>
</tr>
<tr>
<td><strong>blob</strong></td>
<td>将文件作为平坦映像加载到内存中</td>
<td>是</td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p><strong><code>base_addr</code></strong> ：指定基址。</p>
</li>
<li><p><strong><code>entry_point</code></strong> ：指定入口点。</p>
</li>
<li><p><strong><code>arch</code></strong> ：指定架构。</p>
</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>angr.Project(</span><br><span class="line"><span class="meta">... </span>    <span class="string">&#x27;examples/fauxware/fauxware&#x27;</span>,</span><br><span class="line"><span class="meta">... </span>    main_opts=&#123;<span class="string">&#x27;backend&#x27;</span>: <span class="string">&#x27;blob&#x27;</span>, <span class="string">&#x27;arch&#x27;</span>: <span class="string">&#x27;i386&#x27;</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    lib_opts=&#123;<span class="string">&#x27;libc.so.6&#x27;</span>: &#123;<span class="string">&#x27;backend&#x27;</span>: <span class="string">&#x27;elf&#x27;</span>&#125;&#125;</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line">&lt;Project examples/fauxware/fauxware&gt;</span><br></pre></td></tr></table></figure></div>


<h5 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h5><p>加载项目后，可以查看一些基本属性，比如 CPU 架构、文件名和入口点的地址。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> monkeyhex  <span class="comment"># 用于以十六进制格式显示数值结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.arch</span><br><span class="line">&lt;Arch AMD64 (LE)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.entry</span><br><span class="line"><span class="number">0x401670</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.filename</span><br><span class="line"><span class="string">&#x27;/bin/true&#x27;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>arch</code></strong> 是一个 <code>archinfo.Arch</code> 对象的实例，表示程序的编译架构。在本例中，它是小端的 AMD64 架构。该对象包含关于 CPU 的大量信息，常用的属性有 <code>arch.bits</code>（位数）、<code>arch.bytes</code>（字节数）、<code>arch.name</code> 和 <code>arch.memory_endness</code>。</li>
<li><strong><code>entry</code></strong> 是二进制文件的入口点地址。</li>
<li><strong><code>filename</code></strong> 是二进制文件的绝对路径。</li>
</ul>
<h4 id="加载器（The-Loader）"><a href="#加载器（The-Loader）" class="headerlink" title="加载器（The Loader）"></a>加载器（The Loader）</h4><p>将二进制文件加载为虚拟地址空间的表示形式是一个复杂的过程。angr 中有一个模块叫 CLE（CLE Loads Everything）来处理这个问题。CLE 可以通过项目的 <code>.loader</code> 属性访问。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader</span><br><span class="line">&lt;Loaded true, maps [<span class="number">0x400000</span>:<span class="number">0x5004000</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader.min_addr</span><br><span class="line"><span class="number">0x400000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader.max_addr</span><br><span class="line"><span class="number">0x5004000</span></span><br></pre></td></tr></table></figure></div>

<h5 id="已加载的对象"><a href="#已加载的对象" class="headerlink" title="已加载的对象"></a>已加载的对象</h5><p>CLE 加载器将二进制文件及其所依赖的动态库（这里被称之为二进制对象）加载并映射到一个统一的内存空间中。每个二进制对象由能够处理其文件类型的加载器后端加载（如 <code>cle.Backend</code> 的子类）。例如，<code>cle.ELF</code> 用于加载 ELF 二进制文件。</p>
<p>此外，内存中还有一些对象并不对应任何加载的二进制文件，例如提供线程局部存储（TLS）支持的对象和用于未解析符号的 <code>externs</code> 对象。</p>
<p>CLE 加载器内部对这些对象简单做了一些分类，并存放在 <code>loader</code> 的几个属性中。常见的包括：</p>
<ul>
<li><p><code>all_objects</code>：即 CLE 加载的所有对象。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有加载的对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader.all_objects</span><br><span class="line">[&lt;ELF Object fauxware, maps [<span class="number">0x400000</span>:<span class="number">0x60105f</span>]&gt;,</span><br><span class="line"> &lt;ELF Object libc-<span class="number">2.23</span>.so, maps [<span class="number">0x1000000</span>:<span class="number">0x13c999f</span>]&gt;,</span><br><span class="line"> &lt;ELF Object ld-<span class="number">2.23</span>.so, maps [<span class="number">0x2000000</span>:<span class="number">0x2227167</span>]&gt;,</span><br><span class="line"> &lt;ELFTLSObject Object cle<span class="comment">##tls, maps [0x3000000:0x3015010]&gt;,</span></span><br><span class="line"> &lt;ExternObject Object cle<span class="comment">##externs, maps [0x4000000:0x4008000]&gt;,</span></span><br><span class="line"> &lt;KernelObject Object cle<span class="comment">##kernel, maps [0x5000000:0x5008000]&gt;]</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>main_object</code> ：主对象，即 <code>angr.Project</code> 指定加载的二进制文件。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader.main_object  <span class="comment"># 加载多个二进制文件时，这是主对象</span></span><br><span class="line">&lt;ELF Object true, maps [<span class="number">0x400000</span>:<span class="number">0x60721f</span>]&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>shared_objects</code>：共享对象，即主对象所依赖的动态库。<code>shared_objects</code> 以字典的形式表示，内容为从共享对象名称到对象的映射。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader.shared_objects</span><br><span class="line">&#123; <span class="string">&#x27;fauxware&#x27;</span>: &lt;ELF Object fauxware, maps [<span class="number">0x400000</span>:<span class="number">0x60105f</span>]&gt;,</span><br><span class="line">  <span class="string">&#x27;libc.so.6&#x27;</span>: &lt;ELF Object libc-<span class="number">2.23</span>.so, maps [<span class="number">0x1000000</span>:<span class="number">0x13c999f</span>]&gt;,</span><br><span class="line">  <span class="string">&#x27;ld-linux-x86-64.so.2&#x27;</span>: &lt;ELF Object ld-<span class="number">2.23</span>.so, maps [<span class="number">0x2000000</span>:<span class="number">0x2227167</span>]&gt; &#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>all_elf_objects</code>：所有从 ELF 文件加载的对象。如果是 Windows 程序，可以使用 <code>all_pe_objects</code>。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader.all_elf_objects</span><br><span class="line">[&lt;ELF Object fauxware, maps [<span class="number">0x400000</span>:<span class="number">0x60105f</span>]&gt;,</span><br><span class="line"> &lt;ELF Object libc-<span class="number">2.23</span>.so, maps [<span class="number">0x1000000</span>:<span class="number">0x13c999f</span>]&gt;,</span><br><span class="line"> &lt;ELF Object ld-<span class="number">2.23</span>.so, maps [<span class="number">0x2000000</span>:<span class="number">0x2227167</span>]&gt;]</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>extern_object</code>：用于为未解析的导入和 angr 内部地址。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader.extern_object</span><br><span class="line">&lt;ExternObject Object cle<span class="comment">##externs, maps [0x4000000:0x4008000]&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>kernel_object</code>：用于模拟系统调用的对象。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader.kernel_object</span><br><span class="line">&lt;KernelObject Object cle<span class="comment">##kernel, maps [0x5000000:0x5008000]&gt;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>除了从 <code>loader</code> 的某个属性中获取加载对象外，我们还可以通过 <code>find_object_containing</code> 方法获取指定地址所在的对象：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader.find_object_containing(<span class="number">0x400000</span>)</span><br><span class="line">&lt;ELF Object fauxware, maps [<span class="number">0x400000</span>:<span class="number">0x60105f</span>]&gt;</span><br></pre></td></tr></table></figure></div>

<p>也可以通过 <code>find_object</code> 方法根据对象名称获取对象：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader.find_object(<span class="string">&#x27;fauxware&#x27;</span>)</span><br><span class="line">&lt;ELF Object fauxware, maps [<span class="number">0x400000</span>:<span class="number">0x60105f</span>]&gt;</span><br></pre></td></tr></table></figure></div>

<h5 id="对象基本信息"><a href="#对象基本信息" class="headerlink" title="对象基本信息"></a>对象基本信息</h5><p>CLE 加载的二进制对象的属性中包含了一些基本信息：</p>
<ul>
<li><p><code>entry</code>：对象的入口点</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader.main_object.entry</span><br><span class="line"><span class="number">0x400580</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>min_addr</code>，<code>max_addr</code>：对象的最低地址和最高地址，即对象所在的地址空间范围。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader.main_object.min_addr, obj.max_addr</span><br><span class="line">(<span class="number">0x400000</span>, <span class="number">0x60105f</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>linked_base</code>：对象的预链接基址</p>
<blockquote>
<p><strong>预链接基址（Prelinked Base Address）</strong> 是在<strong>预链接（Prelinking）</strong> 过程中为共享对象（Shared Objects，如共享库 <code>*.so</code> 或可执行文件）分配的<strong>固定加载地址</strong>。</p>
</blockquote>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.linked_base</span><br><span class="line"><span class="number">0x400000</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>mapped_base</code>：对象实际被 CLE 映射到内存的基址</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.mapped_base</span><br><span class="line"><span class="number">0x400000</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>execstack</code>：查询该二进制文件是否有可执行栈，即 <code>NX</code> 保护是否未被开启。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader.main_object.execstack</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>pic</code>：查询该二进制文件是否是地址无关，即 <code>PIE</code> 保护是否开启。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader.main_object.pic</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h5 id="段（Segment）和节（Section）"><a href="#段（Segment）和节（Section）" class="headerlink" title="段（Segment）和节（Section）"></a>段（Segment）和节（Section）</h5><p>CLE 加载的二进制对象还会解析获取对应二进制文件的段和节信息。这些信息分别存放在二进制对象的 <code>segments</code> 和 <code>sections</code> 属性中。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取 ELF 的段（segments）和节（sections）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.segments</span><br><span class="line">&lt;Regions: [&lt;ELFSegment memsize=<span class="number">0xa74</span>, filesize=<span class="number">0xa74</span>, vaddr=<span class="number">0x400000</span>, flags=<span class="number">0x5</span>, offset=<span class="number">0x0</span>&gt;,</span><br><span class="line">           &lt;ELFSegment memsize=<span class="number">0x238</span>, filesize=<span class="number">0x228</span>, vaddr=<span class="number">0x600e28</span>, flags=<span class="number">0x6</span>, offset=<span class="number">0xe28</span>&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.sections</span><br><span class="line">&lt;Regions: [&lt;Unnamed | offset <span class="number">0x0</span>, vaddr <span class="number">0x0</span>, size <span class="number">0x0</span>&gt;,</span><br><span class="line">           &lt;.interp | offset <span class="number">0x238</span>, vaddr <span class="number">0x400238</span>, size <span class="number">0x1c</span>&gt;,</span><br><span class="line">           &lt;.note.ABI-tag | offset <span class="number">0x254</span>, vaddr <span class="number">0x400254</span>, size <span class="number">0x20</span>&gt;,</span><br><span class="line">           ...（省略部分输出）]&gt;</span><br></pre></td></tr></table></figure></div>

<p>我们可以通过二进制对象的 <code>find_segment_containing</code> 和 <code>find_section_containing</code> 获取指定地址所位于的段和节。</p>
  <div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.find_segment_containing(obj.entry)</span><br><span class="line">&lt;ELFSegment memsize=<span class="number">0xa74</span>, filesize=<span class="number">0xa74</span>, vaddr=<span class="number">0x400000</span>, flags=<span class="number">0x5</span>, offset=<span class="number">0x0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.find_section_containing(obj.entry)</span><br><span class="line">&lt;.text | offset <span class="number">0x580</span>, vaddr <span class="number">0x400580</span>, size <span class="number">0x338</span>&gt;</span><br></pre></td></tr></table></figure></div>

<p>angr 没有直接通过节的名称搜索节的 api，因此需要手动遍历节来获取。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text_section = [section <span class="keyword">for</span> section <span class="keyword">in</span> <span class="variable language_">self</span>.project.loader.main_object.sections <span class="keyword">if</span> section.name == <span class="string">&#x27;.text&#x27;</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure></div>

<h5 id="内存数据"><a href="#内存数据" class="headerlink" title="内存数据"></a>内存数据</h5><p>angr 的内存操作接口分为 <strong>静态内存接口</strong>（加载时内存布局）和 <strong>动态内存接口</strong>（符号执行时的内存状态）。其中 <code>project.loader.memory</code> 属于静态内存接口，是二进制文件加载到内存后的初始布局（如代码段、数据段、符号表等）。</p>
<ul>
<li><p><strong>搜索内存</strong> ：首先我们可以通过其中的 <code>find</code> 方法搜索我们想要的数据，返回结果是一个迭代器：</p>
  <div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, data: <span class="built_in">bytes</span>, search_min: <span class="built_in">int</span> = <span class="literal">None</span>, search_max: <span class="built_in">int</span> = <span class="literal">None</span></span>) -&gt; Iterator[<span class="built_in">int</span>]:</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><p><strong><code>data</code></strong> ：要搜索的字节序列（<code>bytes</code> 类型）。这是你希望在内存中查找的数据模式。</p>
</li>
<li><p><strong><code>search_min</code></strong> ：可选参数，指定搜索的最小地址。只有在该地址之后或等于该地址的内存区域才会被搜索。如果不提供，默认从内存的起始位置开始。</p>
</li>
<li><p><strong><code>search_max</code></strong> ：可选参数，指定搜索的最大地址。只有在该地址之前或等于该地址的内存区域才会被搜索。如果不提供，默认搜索到内存的末尾。</p>
</li>
</ul>
</li>
<li><p><strong>返回值：</strong>该方法返回一个迭代器，迭代器会逐一返回包含字节序列 <code>data</code> 的所有内存地址。</p>
</li>
</ul>
</li>
<li><p><strong>读取内存</strong> ：通过 <code>load</code> 方法可以读取指定内存地址的数据，返回值是一个字节序列。此方法会读取指定地址开始的最多 <code>n</code> 个字节，直到达到指定字节数或者遇到未分配的内存区域：</p>
  <div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">self, addr: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><p><strong><code>addr</code></strong> ：指定读取的起始内存地址。</p>
</li>
<li><p><strong><code>n</code></strong> ：要读取的字节数。</p>
</li>
</ul>
</li>
<li><p><strong>返回值：</strong>返回一个字节对象（<code>bytes</code> 类型），包含读取到的数据。如果在读取过程中遇到未分配的内存区域，方法会停止，并返回已读取的字节数据。</p>
</li>
</ul>
</li>
<li><p><strong>写入内存</strong> ：通过 <code>store</code> 方法可以将字节数据 <code>data</code> 写入到指定的内存地址 <code>addr</code>。如果写入操作超过了当前内存区域的范围，方法会尝试更新现有的内存区域，并抛出 <code>KeyError</code> 异常。</p>
  <div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">self, addr, data</span>):</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>参数：</strong><ul>
<li><strong><code>addr</code></strong> ：要写入的目标内存地址（<code>int</code> 类型）。</li>
<li><strong><code>data</code></strong> ：要写入内存的字节数据（<code>bytes</code> 类型）。</li>
</ul>
</li>
<li><strong>返回值：</strong>此方法没有返回值。如果成功写入数据，它会直接修改内存中的数据；如果出现问题，它会抛出 <code>KeyError</code> 异常。</li>
</ul>
</li>
</ul>
<h4 id="符号信息"><a href="#符号信息" class="headerlink" title="符号信息"></a>符号信息</h4><h5 id="符号地址"><a href="#符号地址" class="headerlink" title="符号地址"></a>符号地址</h5><p>从 CLE 中获取符号最简单的方法是使用 <code>loader.find_symbol</code>，它接受一个名称或地址，并返回一个 <code>Symbol</code> 对象。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>strcmp = proj.loader.find_symbol(<span class="string">&#x27;strcmp&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>strcmp</span><br><span class="line">&lt;Symbol <span class="string">&quot;strcmp&quot;</span> <span class="keyword">in</span> libc.so<span class="number">.6</span> at <span class="number">0x1089cd0</span>&gt;</span><br></pre></td></tr></table></figure></div>

<p>符号最有用的属性包括其名称（<code>name</code>）、所属对象（<code>owner</code>）以及地址（<code>address</code>）。但符号的“地址”可能是模糊的，<code>Symbol</code> 对象提供了三种方式报告其地址：</p>
<ul>
<li><strong><code>.rebased_addr</code></strong> ：符号在全局地址空间中的地址，这也是打印输出中显示的地址。</li>
<li><strong><code>.linked_addr</code></strong> ：符号相对于二进制文件预链接基址（prelinked base）的地址。例如，这是 <code>readelf</code> 等工具中报告的地址。</li>
<li><strong><code>.relative_addr</code></strong> ：符号相对于其所属对象基址（object base）的地址。在文献（尤其是 Windows 文献）中，这被称为 RVA（Relative Virtual Address）。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>strcmp.name</span><br><span class="line"><span class="string">&#x27;strcmp&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>strcmp.owner</span><br><span class="line">&lt;ELF Object libc-<span class="number">2.23</span>.so, maps [<span class="number">0x1000000</span>:<span class="number">0x13c999f</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>strcmp.rebased_addr</span><br><span class="line"><span class="number">0x1089cd0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>strcmp.linked_addr</span><br><span class="line"><span class="number">0x89cd0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>strcmp.relative_addr</span><br><span class="line"><span class="number">0x89cd0</span></span><br></pre></td></tr></table></figure></div>

<p>除了调试信息外，符号还支持动态链接（dynamic linking）的概念。例如，libc 提供了 <code>strcmp</code> 作为导出符号，而主二进制程序依赖它。如果我们让 CLE 直接从主对象中返回 <code>strcmp</code> 符号，它会告诉我们这是一个导入符号（import symbol）。导入符号没有有意义的地址，但它会提供一个引用，指向用于解析它的符号（通过 <code>.resolvedby</code> 属性）。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>strcmp.is_export</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>strcmp.is_import</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 Loader 来说，使用的是 find_symbol 方法，因为它需要进行搜索以找到符号。</span></span><br><span class="line"><span class="comment"># 对单个对象来说，使用的是 get_symbol 方法，因为给定名称的符号在对象内部只能有一个。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main_strcmp = proj.loader.main_object.get_symbol(<span class="string">&#x27;strcmp&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main_strcmp</span><br><span class="line">&lt;Symbol <span class="string">&quot;strcmp&quot;</span> <span class="keyword">in</span> fauxware (<span class="keyword">import</span>)&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main_strcmp.is_export</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main_strcmp.is_import</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>main_strcmp.resolvedby</span><br><span class="line">&lt;Symbol <span class="string">&quot;strcmp&quot;</span> <span class="keyword">in</span> libc.so<span class="number">.6</span> at <span class="number">0x1089cd0</span>&gt;</span><br></pre></td></tr></table></figure></div>

<h5 id="符号的-PLT-地址"><a href="#符号的-PLT-地址" class="headerlink" title="符号的 PLT 地址"></a>符号的 PLT 地址</h5><p>对于某些符号，你可以通过加载的对象获取它们在 PLT表（Procedure Linkage Table）中的地址：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = proj.loader.main_object</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>addr = obj.plt[<span class="string">&#x27;strcmp&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>addr</span><br><span class="line"><span class="number">0x400550</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 PLT 地址反向查找符号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.reverse_plt[addr]</span><br><span class="line"><span class="string">&#x27;strcmp&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h5 id="符号的-GOT-地址"><a href="#符号的-GOT-地址" class="headerlink" title="符号的 GOT 地址"></a>符号的 GOT 地址</h5><p>导入和导出符号之间的链接方式是通过<strong>重定位（relocations）</strong>管理的。重定位记录了以下信息：</p>
<blockquote>
<p>当你将 [import] 符号与某个导出符号匹配时，请将导出符号的地址写入 [location]（即符号对应的 GOT 表地址），格式为 [format]。</p>
</blockquote>
<p>我们可以获取重定位的相关信息：</p>
<ul>
<li>通过 <code>obj.relocs</code> 获取某个对象的所有重定位列表（以 <code>Relocation</code> 实例表示）。</li>
<li>通过 <code>obj.imports</code> 获取从符号名称到重定位的映射。注意，导出符号没有对应的列表。</li>
</ul>
<p>例如我们可以通过 <code>imports</code> 获取 <code>exit</code> 函数的 GOT 表地址：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader.main_object.imports[<span class="string">&#x27;exit&#x27;</span>].rebased_addr</span><br><span class="line"><span class="number">0x406f88</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.loader.main_object.find_section_containing(<span class="number">0x406f88</span>)</span><br><span class="line">&lt;.got | offset <span class="number">0x5e88</span>, vaddr <span class="number">0x406e88</span>, size <span class="number">0x178</span>&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="二进制代码分析"><a href="#二进制代码分析" class="headerlink" title="二进制代码分析"></a>二进制代码分析</h3><h4 id="基本块（Blocks）"><a href="#基本块（Blocks）" class="headerlink" title="基本块（Blocks）"></a>基本块（Blocks）</h4><p>在 angr 中，<strong>基本块（Basic Block）</strong> 是指一段连续的、没有跳跃（即没有分支指令）的指令序列，通常在程序执行过程中，这些指令是按顺序执行的。</p>
<p>具体来说，基本块有以下几个特点：</p>
<ul>
<li><p><strong>没有跳跃或分支</strong> ：基本块内的指令是顺序执行的，不包含跳转（如 <code>jmp</code>、<code>call</code>、<code>ret</code> 等指令）或条件分支指令（如 <code>if</code>、<code>branch</code> 等）。当程序执行到一个基本块时，它会按照顺序执行该块内的所有指令，直到遇到跳转指令或基本块结束。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>与 IDA 的 CFG 的代码块不同的是，angr 的代码块把函数调用（<code>call</code>）也作为代码块结束的标志。</p>

    </div>
  </div>
</li>
<li><p><strong>入口和出口</strong> ：每个基本块有一个入口（起始地址）和出口（结束地址）。出口通常是一个跳转或返回的指令，也可能是下一个基本块的开始。</p>
</li>
<li><p><strong>分析单元</strong> ：在程序分析过程中，基本块是分析的最小单元。angr 就是通过将程序拆分成多个基本块来进行符号执行（symbolic execution）和路径探索。</p>
</li>
</ul>
<h5 id="基本块的获取"><a href="#基本块的获取" class="headerlink" title="基本块的获取"></a>基本块的获取</h5><p>在 angr 中，通过 <code>project.factory.block()</code> 方法可以提取某个地址的基本块。</p>
<blockquote>
<p>在 <code>angr</code> 中有很多类，其中大多数需要实例化一个项目（project）。为了避免你到处传递项目实例，我们提供了 <code>project.factory</code>，它包含了几个方便的构造器，用于创建你经常需要使用的常见对象。</p>
</blockquote>
<p>这些基本块的内容被封装在 <code>Block</code> 对象中，你可以通过该对象访问基本块的反汇编信息、指令数量、指令地址等数据。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>project.factory.block</code> 提取的代码块并不是控制流程图中的代码块。控制流图会考虑到代码的所有跳转关系，包括跳转到基本块的中间位置，因此在控制流图中，基本块的划分会比单纯用 <code>project.factory.block</code> 提取的基本块更加复杂。</p>

    </div>
  </div>

<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>block = proj.factory.block(proj.entry)  <span class="comment"># 从程序入口点提取一个代码块</span></span><br><span class="line">&lt;Block <span class="keyword">for</span> <span class="number">0x401670</span>, <span class="number">42</span> <span class="built_in">bytes</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>block.pp()  <span class="comment"># 将反汇编结果打印到标准输出</span></span><br><span class="line"><span class="number">0x401670</span>:       xor     ebp, ebp</span><br><span class="line"><span class="number">0x401672</span>:       mov     r9, rdx</span><br><span class="line"><span class="number">0x401675</span>:       pop     rsi</span><br><span class="line"><span class="number">0x401676</span>:       mov     rdx, rsp</span><br><span class="line"><span class="number">0x401679</span>:       <span class="keyword">and</span>     rsp, <span class="number">0xfffffffffffffff0</span></span><br><span class="line"><span class="number">0x40167d</span>:       push    rax</span><br><span class="line"><span class="number">0x40167e</span>:       push    rsp</span><br><span class="line"><span class="number">0x40167f</span>:       lea     r8, [rip + <span class="number">0x2e2a</span>]</span><br><span class="line"><span class="number">0x401686</span>:       lea     rcx, [rip + <span class="number">0x2db3</span>]</span><br><span class="line"><span class="number">0x40168d</span>:       lea     rdi, [rip - <span class="number">0xd4</span>]</span><br><span class="line"><span class="number">0x401694</span>:       call    qword ptr [rip + <span class="number">0x205866</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>block.instructions  <span class="comment"># 这个代码块有多少条指令？</span></span><br><span class="line"><span class="number">0xb</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>block.instruction_addrs  <span class="comment"># 指令的地址是什么？</span></span><br><span class="line">[<span class="number">0x401670</span>, <span class="number">0x401672</span>, <span class="number">0x401675</span>, <span class="number">0x401676</span>, <span class="number">0x401679</span>, <span class="number">0x40167d</span>, <span class="number">0x40167e</span>, <span class="number">0x40167f</span>, <span class="number">0x401686</span>, <span class="number">0x40168d</span>, <span class="number">0x401694</span>]</span><br></pre></td></tr></table></figure></div>

<h5 id="基本块的使用"><a href="#基本块的使用" class="headerlink" title="基本块的使用"></a>基本块的使用</h5><p>每个 <code>Block</code> 对象包含一个反汇编的指令列表。你可以通过 <code>block.capstone</code> 获取该基本块的反汇编指令。<code>capstone</code> 是一个流行的反汇编库，<code>angr</code> 使用它来生成反汇编指令。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> insn <span class="keyword">in</span> block.capstone.insns:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;insn.address:#x&#125;</span>: <span class="subst">&#123;insn.mnemonic&#125;</span> <span class="subst">&#123;insn.op_str&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>在我们开发逆向辅助脚本的时候，基本块的其中一个作用就是可以提取某个地址处的 <code>gadget</code>。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_gadget</span>(<span class="params">addr</span>):</span><br><span class="line">    gadget_str = <span class="string">&quot;; &quot;</span>.join([<span class="string">f&quot;<span class="subst">&#123;insn.mnemonic&#125;</span> <span class="subst">&#123;insn.op_str&#125;</span>&quot;</span> <span class="keyword">for</span> insn <span class="keyword">in</span> proj.factory.block(addr).disassembly.insns]).strip()</span><br><span class="line">    <span class="keyword">return</span> gadget_str + <span class="string">&quot;;&quot;</span> <span class="keyword">if</span> gadget_str != <span class="string">&quot;&quot;</span> <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div>

<p>我们还可以借助基本块来进行一些复杂的程序分析，不过这里先不做介绍。</p>
<h4 id="控制流程图（CFG）"><a href="#控制流程图（CFG）" class="headerlink" title="控制流程图（CFG）"></a>控制流程图（CFG）</h4><p><strong>控制流图（Control Flow Graph，简称 CFG）</strong> 是一种图形化的表示方法，用于描述程序中各个基本块之间的控制流关系。它将程序中的 <strong>基本块</strong> 作为节点，表示控制流的 <strong>跳转指令</strong>（如 <code>jmp</code>、<code>call</code>、<code>ret</code> 等）作为边。</p>
<h5 id="利用-angr-提取-CFG"><a href="#利用-angr-提取-CFG" class="headerlink" title="利用 angr 提取 CFG"></a>利用 angr 提取 CFG</h5><p>在 <code>angr</code> 中，有两种类型的控制流图（CFG）可以生成：静态 CFG（<code>CFGFast</code>）和动态 CFG（<code>CFGEmulated</code>）。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>如果你不确定使用哪个 CFG，或者遇到 <code>CFGEmulated</code> 的问题，建议首先尝试使用 <code>CFGFast</code>。</p>

    </div>
  </div>

<ul>
<li><strong><code>CFGFast</code></strong> 使用静态分析来生成控制流图。它显著更快，但理论上受限于一些控制流转换只能在执行时解析的事实。这是其他流行的逆向工程工具执行的同类控制流图分析，其结果与它们的输出可比。</li>
<li><strong><code>CFGEmulated</code></strong> 使用符号执行来捕捉控制流图。尽管它理论上更精确，但它显著更慢。由于模拟精度的问题（如系统调用、缺少硬件特性等），通常它也不那么完整。</li>
</ul>
<p>可以通过以下代码构建控制流图：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> angr</span><br><span class="line"><span class="comment"># 加载项目</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = angr.Project(<span class="string">&#x27;/bin/true&#x27;</span>, load_options=&#123;<span class="string">&#x27;auto_load_libs&#x27;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态控制流图（CFG）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cfg = p.analyses.CFGFast()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成动态控制流图（CFG）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cfg = p.analyses.CFGEmulated(keep_state=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>控制流图分析不会区分来自不同二进制对象的代码。这意味着默认情况下，它会尝试分析通过加载的共享库进行的控制流。这几乎从来不是预期的行为，因为这会使分析时间变得极长。要加载没有共享库的二进制文件，可以在 <code>Project</code> 构造函数中添加以下关键字参数：<code>load_options={&#39;auto_load_libs&#39;: False}</code>。</p>

    </div>
  </div>

<p>控制流图的核心是一个 <code>NetworkX</code> <strong>有向图（di-graph）</strong>。这意味着所有常规的 <code>NetworkX</code> API 都可用：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;This is the graph:&quot;</span>, cfg.graph)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;It has %d nodes and %d edges&quot;</span> % (<span class="built_in">len</span>(cfg.graph.nodes()), <span class="built_in">len</span>(cfg.graph.edges())))</span><br></pre></td></tr></table></figure></div>

<p><code>CFGNode</code> 类的实例代表了控制流图中的每个基本块。你可以通过 <code>cfg.get_any_node()</code> 获取给定地址的任何一个节点，或者通过 <code>cfg.get_all_nodes()</code> 获取所有上下文下的节点。</p>
<blockquote>
<p>由于程序可能在多个上下文中执行，相同的基本块在不同的上下文下可能会有不同的表现。因此，同一个基本块可能会在图中有多个节点（表示不同的执行上下文）。</p>
</blockquote>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取给定位置（入口点）对应的任意一个节点</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>entry_node = cfg.get_any_node(p.entry)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取给定位置（入口点）所有上下文的节点</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;There were %d contexts for the entry block&quot;</span> % <span class="built_in">len</span>(cfg.get_all_nodes(p.entry)))</span><br></pre></td></tr></table></figure></div>

<p><code>CFGNode</code> 还具有 <code>predecessors</code> 和 <code>successors</code> 属性，分别表示当前节点的前驱和后继节点。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取入口节点的前驱</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Predecessors of the entry point:&quot;</span>, entry_node.predecessors)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取入口节点的后继</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Successors of the entry point:&quot;</span>, entry_node.successors)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取入口节点的后继节点及跳转类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Successors (and type of jump) of the entry point:&quot;</span>, [jumpkind + <span class="string">&quot; to &quot;</span> + <span class="built_in">str</span>(node.addr) <span class="keyword">for</span> node, jumpkind <span class="keyword">in</span> cfg.get_successors_and_jumpkind(entry_node)])</span><br></pre></td></tr></table></figure></div>

<p>在 IDA 中，控制流图是以函数为单位的，也就是说，IDA 将每个函数作为一个单独的基本块进行分析，并将函数的入口和出口视为控制流的边界。而在 <code>angr</code> 中，控制流图是基于 <strong>基本块</strong> 的，<code>call</code> 指令通常被视为 <strong>跳转</strong>（或控制流转移）的一个标志，而不是函数的边界。控制流图会继续分析 <code>call</code> 指令后的指令，但不会自动将其视为函数的边界。</p>
<p><code>angrmanagement</code> 的 <code>to_supergraph</code> 函数用于将 <code>angr</code> 的控制流图转换成一个函数级别的控制流图。<code>to_supergraph</code> 会把 <code>angr</code> 的单个函数的 CFG 提取出来，并将其转化为 IDA 样式的图。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_cfg</span>():</span><br><span class="line">    <span class="comment"># 使用 CFGFast 分析生成控制流图</span></span><br><span class="line">    cfg = proj.analyses.CFGFast(normalize=<span class="literal">True</span>, force_complete_scan=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取某个函数的控制流图</span></span><br><span class="line">    function_cfg = cfg.functions.get(start).transition_graph</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用 to_supergraph 将该函数的控制流图转化为类似 IDA 的图</span></span><br><span class="line">    super_cfg = to_supergraph(function_cfg)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> super_cfg</span><br></pre></td></tr></table></figure></div>

<h5 id="手动提取-CFG"><a href="#手动提取-CFG" class="headerlink" title="手动提取 CFG"></a>手动提取 CFG</h5><p>如果一个二进制程序比较大，那么使用 angr 内置的 CFG 生成方法会非常的慢。对于这种情况通常我们都会自己实现一个近似的提取 CFG 的方法，针对一个特定函数开始提取 CFG。</p>
<p>下面这段代码是针对 x86 架构遍历一个特定函数的 CFG 的代码：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs_cfg</span>(<span class="params">self, block_handler: <span class="type">Callable</span>[[<span class="type">List</span>[CsInsn]], <span class="type">Any</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    广度优先遍历函数内控制流图（CFG）的核心方法（x86架构专用）</span></span><br><span class="line"><span class="string">    :param block_handler: 基本块处理回调函数，接收指令列表，返回非空值时终止遍历</span></span><br><span class="line"><span class="string">    :return: block_handler的返回值或None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 缓存分支路径已分析的基本块（避免重复处理）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.blocks != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> <span class="variable language_">self</span>.blocks:</span><br><span class="line">            <span class="comment"># 获取基本块的反汇编指令列表，调用处理函数</span></span><br><span class="line">            result = block_handler(<span class="built_in">list</span>(<span class="variable language_">self</span>.project.factory.block(block).capstone.insns))</span><br><span class="line">            <span class="keyword">if</span> result: <span class="keyword">return</span> result  <span class="comment"># 根据回调结果提前终止</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 内部函数：判断地址是否在当前函数范围内 --------------------------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">in_func_range</span>(<span class="params">addr</span>):</span><br><span class="line">        <span class="comment"># 首次运行初始化.text段地址范围</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.text_range == <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 从二进制文件获取.text段信息（ELF/PE格式）</span></span><br><span class="line">            text_section = [section <span class="keyword">for</span> section <span class="keyword">in</span> <span class="variable language_">self</span>.project.loader.main_object.sections </span><br><span class="line">                           <span class="keyword">if</span> section.name == <span class="string">&#x27;.text&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">            <span class="variable language_">self</span>.text_range = <span class="built_in">range</span>(text_section.vaddr, text_section.vaddr + text_section.filesize)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 地址超出.text段范围直接过滤</span></span><br><span class="line">        <span class="keyword">if</span> addr <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.text_range: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 排除其他函数入口（通过识别函数序言）</span></span><br><span class="line">        block = <span class="variable language_">self</span>.project.factory.block(addr)</span><br><span class="line">        insns: <span class="type">List</span>[CsInsn] = <span class="built_in">list</span>(block.capstone.insns)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (</span><br><span class="line">            <span class="built_in">len</span>(insns) &gt;= <span class="number">2</span> <span class="keyword">and</span> </span><br><span class="line">            insns[<span class="number">0</span>].mnemonic == <span class="string">&#x27;push&#x27;</span> <span class="keyword">and</span> insns[<span class="number">0</span>].op_str == <span class="string">&#x27;rbp&#x27;</span>  <span class="comment"># 函数开头push rbp</span></span><br><span class="line">            <span class="keyword">and</span> insns[<span class="number">1</span>].mnemonic == <span class="string">&#x27;mov&#x27;</span> <span class="keyword">and</span> insns[<span class="number">1</span>].op_str == <span class="string">&#x27;rbp, rsp&#x27;</span>  <span class="comment"># mov rbp, rsp</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># BFS初始化 --------------------------------------------------------</span></span><br><span class="line">    block_queue = Queue()          <span class="comment"># 使用队列实现广度优先搜索</span></span><br><span class="line">    <span class="variable language_">self</span>.blocks: <span class="type">Set</span>[<span class="built_in">int</span>] = <span class="built_in">set</span>()  <span class="comment"># 记录已访问的基本块地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将起始地址加入队列（函数入口地址）</span></span><br><span class="line">    block_queue.put(<span class="variable language_">self</span>.addr)</span><br><span class="line">    <span class="variable language_">self</span>.blocks.add(<span class="variable language_">self</span>.addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># BFS主循环 --------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> block_queue.empty():</span><br><span class="line">        <span class="comment"># 获取当前基本块（通过angr解析）</span></span><br><span class="line">        block = <span class="variable language_">self</span>.project.factory.block(block_queue.get())</span><br><span class="line">        insns: <span class="type">List</span>[CsInsn] = block.capstone.insns  <span class="comment"># Capstone反汇编结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理当前基本块指令（回调机制）</span></span><br><span class="line">        result = block_handler(insns)</span><br><span class="line">        <span class="keyword">if</span> result: <span class="keyword">return</span> result  <span class="comment"># 回调返回非空值时终止遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取最后一条指令（分支指令分析）</span></span><br><span class="line">        last_insn = insns[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遇到返回指令（ret）停止当前路径探索</span></span><br><span class="line">        <span class="keyword">if</span> last_insn.mnemonic.startswith(<span class="string">&#x27;ret&#x27;</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理条件跳转指令（jz/jne等）------------------------------------</span></span><br><span class="line">        <span class="keyword">if</span> (last_insn.mnemonic.startswith(<span class="string">&#x27;j&#x27;</span>) <span class="keyword">and</span>  <span class="comment"># 跳转指令族</span></span><br><span class="line">            last_insn.operands[<span class="number">0</span>].<span class="built_in">type</span> == X86_OP_IMM):  <span class="comment"># 立即数操作数</span></span><br><span class="line">            next_block = last_insn.operands[<span class="number">0</span>].imm  <span class="comment"># 跳转目标地址</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 过滤跨函数跳转（通过地址范围和函数序言判断）</span></span><br><span class="line">            <span class="keyword">if</span> next_block <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.blocks <span class="keyword">and</span> in_func_range(next_block):</span><br><span class="line">                <span class="variable language_">self</span>.blocks.add(next_block)</span><br><span class="line">                block_queue.put(next_block)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理顺序执行流（非jmp指令）-------------------------------------</span></span><br><span class="line">        <span class="keyword">if</span> last_insn.mnemonic != <span class="string">&#x27;jmp&#x27;</span>:  <span class="comment"># 排除无条件跳转</span></span><br><span class="line">            next_block = last_insn.address + last_insn.size  <span class="comment"># 计算下一条指令地址</span></span><br><span class="line">            <span class="keyword">if</span> next_block <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.blocks:</span><br><span class="line">                <span class="variable language_">self</span>.blocks.add(next_block)</span><br><span class="line">                block_queue.put(next_block)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div>

<p>下面这段代码是针对 arm 架构遍历一个特定函数的 CFG 的代码：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs_cfg</span>(<span class="params">self, block_handler: <span class="type">Callable</span>[[<span class="type">List</span>[CsInsn]], <span class="type">Any</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    广度优先遍历控制流图（CFG）的核心方法</span></span><br><span class="line"><span class="string">    :param block_handler: 基本块处理回调函数，接收指令列表，返回非空值时终止遍历</span></span><br><span class="line"><span class="string">    :return: block_handler的返回值或None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果已缓存基本块地址，直接遍历处理（缓存优化）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.blocks != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> <span class="variable language_">self</span>.blocks:</span><br><span class="line">            <span class="comment"># 获取基本块的反汇编指令列表，调用处理函数</span></span><br><span class="line">            result = block_handler(<span class="built_in">list</span>(<span class="variable language_">self</span>.project.factory.block(block).capstone.insns))</span><br><span class="line">            <span class="keyword">if</span> result: <span class="keyword">return</span> result  <span class="comment"># 根据回调结果提前终止</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># BFS初始化 ----------------------------------------------------------</span></span><br><span class="line">    block_queue = Queue()          <span class="comment"># 使用队列实现广度优先搜索</span></span><br><span class="line">    <span class="variable language_">self</span>.blocks: <span class="type">Set</span>[<span class="built_in">int</span>] = <span class="built_in">set</span>()  <span class="comment"># 记录已访问的基本块地址（Thumb模式地址需|1）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将起始地址加入队列（ARM Thumb模式处理：地址末位置1）</span></span><br><span class="line">    block_queue.put(<span class="variable language_">self</span>.addr | <span class="number">1</span>)  <span class="comment"># 例如 0x1000 -&gt; 0x1001</span></span><br><span class="line">    <span class="variable language_">self</span>.blocks.add(<span class="variable language_">self</span>.addr | <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># BFS主循环 ----------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> block_queue.empty():</span><br><span class="line">        <span class="comment"># 获取当前基本块</span></span><br><span class="line">        block_addr = block_queue.get()</span><br><span class="line">        block = <span class="variable language_">self</span>.project.factory.block(block_addr)  <span class="comment"># 获取基本块对象</span></span><br><span class="line">        cs_block = block.capstone  <span class="comment"># Capstone反汇编对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理当前基本块指令</span></span><br><span class="line">        result = block_handler(cs_block.insns)  <span class="comment"># 传递指令列表给回调函数</span></span><br><span class="line">        <span class="keyword">if</span> result: <span class="keyword">return</span> result  <span class="comment"># 回调返回非空值时终止遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取最后一条指令</span></span><br><span class="line">        last_insn = cs_block.insns[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分支指令处理逻辑 -----------------------------------------------</span></span><br><span class="line">        <span class="comment"># 情况1：跳过无条件跳转（b.w）</span></span><br><span class="line">        <span class="keyword">if</span> last_insn.mnemonic == <span class="string">&#x27;b.w&#x27;</span>: </span><br><span class="line">            <span class="keyword">continue</span>  <span class="comment"># 不处理后续逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况2：处理非函数调用的直接跳转（非bl指令的立即数操作）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> last_insn.mnemonic.startswith(<span class="string">&#x27;bl&#x27;</span>)) <span class="keyword">and</span> \</span><br><span class="line">           (last_insn.operands[<span class="number">0</span>].<span class="built_in">type</span> == ARM_OP_IMM):</span><br><span class="line">            next_block = last_insn.operands[<span class="number">0</span>].imm  <span class="comment"># 获取跳转目标地址</span></span><br><span class="line">            <span class="variable language_">self</span>._add_next_block(next_block, block_queue)  <span class="comment"># 添加到队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况3：顺序执行的下一个块（非分支/非返回指令）</span></span><br><span class="line">        <span class="keyword">if</span> (last_insn.mnemonic != <span class="string">&#x27;b&#x27;</span>) <span class="keyword">and</span> \</span><br><span class="line">           (<span class="keyword">not</span> last_insn.mnemonic.startswith(<span class="string">&#x27;pop&#x27;</span>)) <span class="keyword">and</span> \</span><br><span class="line">           (last_insn.mnemonic != <span class="string">&#x27;bx&#x27;</span>):</span><br><span class="line">            next_block = last_insn.address + last_insn.size  <span class="comment"># 计算下一条指令地址</span></span><br><span class="line">            <span class="variable language_">self</span>._add_next_block(next_block, block_queue)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况4：处理条件分支指令（cbz/cbnz等）</span></span><br><span class="line">        <span class="keyword">for</span> insn <span class="keyword">in</span> cs_block.insns:</span><br><span class="line">            <span class="keyword">if</span> insn.mnemonic.startswith(<span class="string">&#x27;cb&#x27;</span>) <span class="keyword">and</span> \</span><br><span class="line">               insn.operands[<span class="number">1</span>].<span class="built_in">type</span> == ARM_OP_IMM:</span><br><span class="line">                next_block = insn.operands[<span class="number">1</span>].imm  <span class="comment"># 条件跳转目标地址</span></span><br><span class="line">                <span class="variable language_">self</span>._add_next_block(next_block, block_queue)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div>

<p>下面这段代码是针对 aarch64 架构遍历一个特定函数的 CFG 的代码：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs_cfg</span>(<span class="params">self, block_handler: <span class="type">Callable</span>[[<span class="type">List</span>[CsInsn]], <span class="type">Any</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    ARM64架构函数内控制流图广度优先遍历方法</span></span><br><span class="line"><span class="string">    :param block_handler: 基本块处理回调函数，返回非空值时终止遍历</span></span><br><span class="line"><span class="string">    :return: block_handler的返回值或None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 缓存分支路径已分析的基本块（避免重复处理）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.blocks != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> <span class="variable language_">self</span>.blocks:</span><br><span class="line">            <span class="comment"># 获取基本块的反汇编指令列表，调用处理函数</span></span><br><span class="line">            result = block_handler(<span class="built_in">list</span>(<span class="variable language_">self</span>.project.factory.block(block).capstone.insns))</span><br><span class="line">            <span class="keyword">if</span> result: <span class="keyword">return</span> result  <span class="comment"># 根据回调结果提前终止</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取.text段地址范围 -----------------------------------------------</span></span><br><span class="line">    text_section = [section <span class="keyword">for</span> section <span class="keyword">in</span> <span class="variable language_">self</span>.project.loader.main_object.sections </span><br><span class="line">                   <span class="keyword">if</span> section.name == <span class="string">&#x27;.text&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">    text_section_range = <span class="built_in">range</span>(text_section.vaddr, </span><br><span class="line">                              text_section.vaddr + text_section.filesize)  <span class="comment"># 注意修正结束地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 内部函数：判断地址是否在当前函数范围内 ------------------------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">in_func_range</span>(<span class="params">addr</span>):</span><br><span class="line">        <span class="comment"># 地址超出.text段范围直接过滤</span></span><br><span class="line">        <span class="keyword">if</span> addr <span class="keyword">not</span> <span class="keyword">in</span> text_section_range: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查是否为其他函数入口（通过识别函数序言指令）</span></span><br><span class="line">        block = <span class="variable language_">self</span>.project.factory.block(addr)</span><br><span class="line">        <span class="keyword">for</span> insn <span class="keyword">in</span> block.capstone.insns:</span><br><span class="line">            <span class="comment"># ARM64函数序言特征：stp x29, x30（保存帧指针和链接寄存器）</span></span><br><span class="line">            <span class="keyword">if</span> insn.mnemonic == <span class="string">&#x27;stp&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;x29, x30&#x27;</span> <span class="keyword">in</span> insn.op_str:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># BFS初始化 --------------------------------------------------------</span></span><br><span class="line">    block_queue = Queue()          <span class="comment"># 使用队列实现广度优先搜索</span></span><br><span class="line">    <span class="variable language_">self</span>.blocks: <span class="type">Set</span>[<span class="built_in">int</span>] = <span class="built_in">set</span>()  <span class="comment"># 记录已访问的基本块地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将起始地址加入队列（函数入口地址）</span></span><br><span class="line">    block_queue.put(<span class="variable language_">self</span>.addr)</span><br><span class="line">    <span class="variable language_">self</span>.blocks.add(<span class="variable language_">self</span>.addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># BFS主循环 --------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> block_queue.empty():</span><br><span class="line">        <span class="comment"># 获取当前基本块（通过angr解析）</span></span><br><span class="line">        block = <span class="variable language_">self</span>.project.factory.block(block_queue.get())</span><br><span class="line">        cs_block = block.capstone  <span class="comment"># Capstone反汇编对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理当前基本块指令（回调机制）</span></span><br><span class="line">        result = block_handler(cs_block.insns)</span><br><span class="line">        <span class="keyword">if</span> result: <span class="keyword">return</span> result  <span class="comment"># 回调返回非空值时终止遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取最后一条指令（分支指令分析）</span></span><br><span class="line">        last_insn = cs_block.insns[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遇到返回指令（ret）停止当前路径探索</span></span><br><span class="line">        <span class="keyword">if</span> last_insn.mnemonic == <span class="string">&#x27;ret&#x27;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理非函数调用的直接跳转（b指令）------------------------------</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> last_insn.mnemonic.startswith(<span class="string">&#x27;bl&#x27;</span>)) <span class="keyword">and</span> \  <span class="comment"># 排除bl指令（函数调用）</span></span><br><span class="line">           (last_insn.operands[<span class="number">0</span>].<span class="built_in">type</span> == ARM64_OP_IMM):    <span class="comment"># 立即数跳转目标</span></span><br><span class="line">            next_block = last_insn.operands[<span class="number">0</span>].imm</span><br><span class="line">            <span class="keyword">if</span> next_block <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.blocks <span class="keyword">and</span> in_func_range(next_block):</span><br><span class="line">                <span class="variable language_">self</span>.blocks.add(next_block)</span><br><span class="line">                block_queue.put(next_block)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理条件分支指令（cbz/cbnz等）-------------------------------</span></span><br><span class="line">        <span class="keyword">if</span> last_insn.mnemonic.startswith(<span class="string">&#x27;cb&#x27;</span>) <span class="keyword">and</span> \  <span class="comment"># 条件分支指令族</span></span><br><span class="line">           last_insn.operands[<span class="number">1</span>].<span class="built_in">type</span> == ARM64_OP_IMM:</span><br><span class="line">            next_block = last_insn.operands[<span class="number">1</span>].imm</span><br><span class="line">            <span class="keyword">if</span> next_block <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.blocks <span class="keyword">and</span> in_func_range(next_block):</span><br><span class="line">                <span class="variable language_">self</span>.blocks.add(next_block)</span><br><span class="line">                block_queue.put(next_block)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理顺序执行流（非无条件跳转）-------------------------------</span></span><br><span class="line">        <span class="keyword">if</span> last_insn.mnemonic != <span class="string">&#x27;b&#x27;</span>:  <span class="comment"># 排除无条件跳转指令</span></span><br><span class="line">            next_block = last_insn.address + last_insn.size  <span class="comment"># 计算下一条指令地址</span></span><br><span class="line">            <span class="keyword">if</span> next_block <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.blocks:</span><br><span class="line">                <span class="variable language_">self</span>.blocks.add(next_block)</span><br><span class="line">                block_queue.put(next_block)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div>

<p>上述示例代码只是近似遍历指定函数 CFG，然后针对其中的每一个代码块调用回调函数。由于没有对整个二进制文件进行完整分析，并且例如判断函数边界等都过于简略，因此并不适用于所有情况（例如有 switch 跳转表的函数会丢失大量分支代码，需要额外编写针对跳转表的处理逻辑）。</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="angr-的函数分析"><a href="#angr-的函数分析" class="headerlink" title="angr 的函数分析"></a>angr 的函数分析</h5><p>控制流图（CFG）的结果会生成一个名为 <strong>函数管理器（Function Manager）</strong> 的对象，可以通过 <code>cfg.kb.functions</code> 访问。该对象最常见的使用方式是像字典一样访问，它将地址映射到 <code>Function</code> 对象，<code>Function</code> 对象可以提供关于函数的各种属性。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>entry_func = cfg.kb.functions[p.entry]</span><br></pre></td></tr></table></figure></div>

<p><code>Function</code> 对象具有多个重要属性：</p>
<ul>
<li><strong><code>entry_func.block_addrs</code></strong> ：一个集合，包含函数中所有基本块的起始地址。</li>
<li><strong><code>entry_func.blocks</code></strong> ：包含该函数所有基本块的集合，可以使用 Capstone 进行反汇编和探索。</li>
<li><strong><code>entry_func.string_references()</code></strong> ：返回一个列表，包含函数中所有被引用的常量字符串。列表中的每个项是一个元组 <code>(addr, string)</code>，其中：<ul>
<li><code>addr</code> 是字符串所在的二进制数据段中的地址。</li>
<li><code>string</code> 是一个 Python 字符串，包含字符串的实际内容。</li>
</ul>
</li>
<li><strong><code>entry_func.returning</code></strong> ：一个布尔值，表示函数是否能返回。<code>False</code> 表示该函数的所有路径都不会返回。</li>
<li><strong><code>entry_func.callable</code></strong> ：一个 <code>angr</code> 的 <code>Callable</code> 对象，表示该函数。你可以像调用 Python 函数一样调用它，并传入 Python 参数，返回的结果可能是实际结果（可能是符号化的），就像你运行了该函数一样。</li>
<li><strong><code>entry_func.transition_graph</code></strong> ：一个 <code>NetworkX</code> 的有向图（DiGraph），描述函数内部的控制流。它类似于 IDA 所显示的每个函数级别的控制流图。</li>
<li><strong><code>entry_func.name</code></strong> ：函数的名称。</li>
<li><strong><code>entry_func.has_unresolved_calls</code></strong> 和 <strong><code>entry_func.has_unresolved_jumps</code></strong> ：这些属性与检测 CFG 的不精确性有关。有时，分析无法检测出间接调用或跳转的目标地址。如果发生这种情况，该函数的相关属性将被设置为 <code>True</code>。</li>
<li><strong><code>entry_func.get_call_sites()</code></strong> ：返回一个列表，包含所有以调用指令结尾的基本块地址。</li>
<li><strong><code>entry_func.get_call_target(callsite_addr)</code></strong> ：给定一个调用地址 <code>callsite_addr</code>，返回该调用指令的目标地址。</li>
<li><strong><code>entry_func.get_call_return(callsite_addr)</code></strong> ：给定一个调用地址 <code>callsite_addr</code>，返回该调用指令应该返回的地址。</li>
</ul>
<h5 id="手动提取函数"><a href="#手动提取函数" class="headerlink" title="手动提取函数"></a>手动提取函数</h5><p>实际上前面的遍历 CFG 本质上就是在遍历函数的代码，这里主要介绍一下如何确定函数的起始地址。</p>
<p>为了避免代码速度过慢，我们需要通过搜索特征而不是 angr 的函数分析来确定函数起始地址，这种方法虽然不严谨，但是在多数情况下是准确的。</p>
<p>下面这段代码是针对 x86 架构寻找函数开头的代码，主要思路是搜索函数开头的特征 <code>push rbp; mov rbp, rsp</code>。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_func_by_addr</span>(<span class="params">addr, project, size=<span class="number">0x1000</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据给定的地址，查找该地址所在的函数的起始地址。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param addr: 目标地址，想要查找的地址</span></span><br><span class="line"><span class="string">    :param project: angr 项目的实例</span></span><br><span class="line"><span class="string">    :param size: 查找范围的大小，默认为 0x1000 字节</span></span><br><span class="line"><span class="string">    :return: 该地址所在的函数的起始地址</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 从目标地址往前加载指定大小的内存数据</span></span><br><span class="line">    data = project.loader.memory.load(addr - size, size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在加载的数据中查找函数的起始指令（假设是 &quot;push rbp; mov rbp, rsp&quot; 作为函数的前导）</span></span><br><span class="line">    addr = addr - size + data.rfind(<span class="string">b&quot;\x55\x48\x89\xE5&quot;</span>)  <span class="comment"># 0x55 0x48 0x89 0xE5 是 &quot;push rbp; mov rbp, rsp&quot; 的机器码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回查找到的函数起始地址</span></span><br><span class="line">    <span class="keyword">return</span> addr</span><br></pre></td></tr></table></figure></div>

<p>下面这段代码是针对 arm 架构寻找函数开头的代码，由于 arm 架构的机器码长度比较固定，因此可以精确的分析汇编代码。不过要注意的是 arm 架构的函数后面可能会有一些全局变量的地址指针，被识别为汇编可能会影响分析结果，这里简单的用经验规则过滤一下。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_func_by_addr</span>(<span class="params">addr, project</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据给定的地址，逐步向上查找，直到找到函数的起始地址。</span></span><br><span class="line"><span class="string">    假设函数的开始是通过检查指令 `push lr` 来确定的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param addr: 目标地址，想要查找的地址</span></span><br><span class="line"><span class="string">    :param project: angr 项目的实例</span></span><br><span class="line"><span class="string">    :return: 找到的函数起始地址</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 读取从给定地址开始的 8 个字节，并反汇编为指令</span></span><br><span class="line">        insns: <span class="type">List</span>[CsInsn] = <span class="built_in">list</span>(CS.disasm(project.loader.memory.load(addr, <span class="number">8</span>), addr))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判断是否找到函数的起始指令</span></span><br><span class="line">        <span class="comment"># 规则：第一条指令是 &#x27;push lr&#x27;，第二条指令不是 &#x27;lsls&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(insns) &gt; <span class="number">1</span> \</span><br><span class="line">                <span class="keyword">and</span> insns[<span class="number">0</span>].mnemonic.startswith(<span class="string">&#x27;push&#x27;</span>) \</span><br><span class="line">                <span class="keyword">and</span> <span class="string">&#x27;lr&#x27;</span> <span class="keyword">in</span> insns[<span class="number">0</span>].op_str \</span><br><span class="line">                <span class="keyword">and</span> insns[<span class="number">1</span>].mnemonic != <span class="string">&#x27;lsls&#x27;</span>: <span class="comment"># 经验值，对应代码段中嵌入的地址表。</span></span><br><span class="line">            <span class="comment"># 如果符合条件，返回当前地址作为函数的起始地址</span></span><br><span class="line">            <span class="keyword">return</span> addr</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果不符合条件，继续向上移动地址（减去 2 字节）查找</span></span><br><span class="line">        addr -= <span class="number">2</span></span><br></pre></td></tr></table></figure></div>

<p>下面这段代码是针对 aarch64 架构寻找函数开头的代码，同样是搜索汇编实现的。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_func_by_addr</span>(<span class="params">addr, project</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据给定的地址，逐步向上查找，直到找到函数的起始地址。</span></span><br><span class="line"><span class="string">    假设函数的开始是通过检查指令 `stp x29, x30` 来确定的，通常这是 ARM64 函数的前导指令。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param addr: 目标地址，想要查找的地址</span></span><br><span class="line"><span class="string">    :param project: angr 项目的实例</span></span><br><span class="line"><span class="string">    :return: 找到的函数起始地址</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 读取从给定地址开始的 4 个字节，并反汇编为指令</span></span><br><span class="line">        insn: CsInsn = <span class="built_in">list</span>(CS.disasm(project.loader.memory.load(addr, <span class="number">4</span>), addr))[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判断是否为 ARM64 函数的起始指令 &quot;stp x29, x30&quot;</span></span><br><span class="line">        <span class="keyword">if</span> insn.mnemonic == <span class="string">&#x27;stp&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;x29, x30&#x27;</span> <span class="keyword">in</span> insn.op_str:</span><br><span class="line">            <span class="comment"># 如果符合条件，返回当前地址作为函数的起始地址</span></span><br><span class="line">            <span class="keyword">return</span> addr</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果不符合条件，继续向上移动地址（减去 4 字节）查找</span></span><br><span class="line">        addr -= <span class="number">4</span></span><br></pre></td></tr></table></figure></div>

<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>前面定位函数起始地址的前提是需要有一个函数内部的地址，而我们通常是用一些特征数据（例如字符串）的引用来定位函数内部的地址的。</p>
<p>其中 arm32 架构由于全局变量的地址会被写到引用的函数后面，因此我们可以直接通过搜索全局变量的地址的方式来定位函数。而对于 x86 和 aarch64 架构则需要我们扫描汇编预处理出全局变量的引用关系。</p>
<h5 id="x86-架构-1"><a href="#x86-架构-1" class="headerlink" title="x86 架构"></a>x86 架构</h5><p>在 x86 架构下，我们常见的字符串引用的汇编代码一般是如下两种形式：</p>
<ul>
<li><p><code>lea</code> 形式，适用于地址无关代码。对于这种形式被引用的字符串的地址在汇编指令的硬编码中体现不出来，因此不能直接通过搜索地址的方式定位到引用字符串的汇编代码，需要扫描分析汇编预处理引用表。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lea</span> reg, [<span class="built_in">rip</span> + offset]<span class="comment">;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>mov</code> 形式，直接将目标地址设置到寄存器中。对于这种形式被引用的字符串的地址在汇编指令的硬编码中自带字符串地址，因此可以通过在代码段中搜索字符串地址来定位。</p>
 <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> reg, address<span class="comment">;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>最终的代码实现如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> rich.progress <span class="keyword">import</span> Progress  <span class="comment"># 用于显示进度条</span></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone.x86 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefDictX86</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用于分析x86二进制文件并建立数据引用关系的工具类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, project: angr.project.Project</span>):</span><br><span class="line">        <span class="variable language_">self</span>.project = project</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据二进制文件MD5生成缓存文件名</span></span><br><span class="line">        ref_file = <span class="string">f&#x27;<span class="subst">&#123;project.loader.main_object.md5.<span class="built_in">hex</span>()&#125;</span>_ref.json&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果存在缓存文件直接加载</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(ref_file):</span><br><span class="line">            <span class="variable language_">self</span>.ref_dict = &#123;<span class="built_in">int</span>(k): v <span class="keyword">for</span> k, v <span class="keyword">in</span> json.load(<span class="built_in">open</span>(ref_file)).items()&#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化引用字典并获取.text节数据</span></span><br><span class="line">        <span class="variable language_">self</span>.ref_dict = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        text_section = [s <span class="keyword">for</span> s <span class="keyword">in</span> project.loader.main_object.sections <span class="keyword">if</span> s.name == <span class="string">&#x27;.text&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        data = project.loader.memory.load(text_section.vaddr, text_section.filesize)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用进度条显示反汇编进度</span></span><br><span class="line">        <span class="keyword">with</span> Progress() <span class="keyword">as</span> progress:</span><br><span class="line">            task = progress.add_task(<span class="string">&quot;[*] 分析引用关系...&quot;</span>, total=text_section.filesize)</span><br><span class="line">            cs = Cs(CS_ARCH_X86, CS_MODE_64)  <span class="comment"># 初始化x64反汇编引擎</span></span><br><span class="line">            cs.detail = <span class="literal">True</span>  <span class="comment"># 启用详细模式获取操作数信息</span></span><br><span class="line"></span><br><span class="line">            disasm_offset = <span class="number">0</span>  <span class="comment"># 反汇编偏移指针</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 遍历.text节的每条指令</span></span><br><span class="line">            <span class="keyword">while</span> disasm_offset &lt; text_section.filesize:</span><br><span class="line">                <span class="comment"># 快速反汇编获取基础指令信息</span></span><br><span class="line">                <span class="keyword">for</span> (addr, size, mnemonic, op_str) <span class="keyword">in</span> cs.disasm_lite(data[disasm_offset:], text_section.vaddr + disasm_offset):</span><br><span class="line">                    progress.update(task, advance=size)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 处理RIP相对寻址的LEA指令（常见于字符串加载）</span></span><br><span class="line">                    <span class="keyword">if</span> mnemonic == <span class="string">&#x27;lea&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;rip&#x27;</span> <span class="keyword">in</span> op_str:</span><br><span class="line">                        <span class="comment"># 完整反汇编获取详细操作数信息</span></span><br><span class="line">                        insn = <span class="built_in">next</span>(cs.disasm(data[disasm_offset:disasm_offset + size], text_section.vaddr + disasm_offset))</span><br><span class="line">                        <span class="comment"># 验证LEA指令格式：lea reg, [rip+offset]</span></span><br><span class="line">                        <span class="keyword">if</span> (insn.operands[<span class="number">1</span>].mem.base == X86_REG_RIP</span><br><span class="line">                                <span class="keyword">and</span> insn.operands[<span class="number">1</span>].<span class="built_in">type</span> == X86_OP_MEM):</span><br><span class="line">                            <span class="comment"># 计算实际内存地址 = 下条指令地址 + 偏移量</span></span><br><span class="line">                            target_addr = insn.address + insn.size + insn.operands[<span class="number">1</span>].mem.disp</span><br><span class="line">                            <span class="variable language_">self</span>.ref_dict[target_addr].append(insn.address)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 处理直接加载立即数的MOV指令（常见于全局变量访问）</span></span><br><span class="line">                    <span class="keyword">elif</span> mnemonic == <span class="string">&#x27;mov&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;[&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> op_str:  <span class="comment"># 排除内存操作数</span></span><br><span class="line">                        insn = <span class="built_in">next</span>(cs.disasm(data[disasm_offset:disasm_offset + size], text_section.vaddr + disasm_offset))</span><br><span class="line">                        <span class="comment"># 验证MOV指令格式：mov reg, imm</span></span><br><span class="line">                        <span class="keyword">if</span> (insn.operands[<span class="number">1</span>].<span class="built_in">type</span> == X86_OP_IMM</span><br><span class="line">                                <span class="keyword">and</span> insn.operands[<span class="number">1</span>].imm <span class="keyword">in</span> <span class="variable language_">self</span>.project.loader.main_object.reverse_plt):</span><br><span class="line">                            <span class="comment"># 检查目标地址是否在.rodata节</span></span><br><span class="line">                            sec = <span class="variable language_">self</span>.project.loader.main_object.find_section_containing(insn.operands[<span class="number">1</span>].imm)</span><br><span class="line">                            <span class="keyword">if</span> sec <span class="keyword">and</span> sec.name == <span class="string">&#x27;.rodata&#x27;</span>:</span><br><span class="line">                                <span class="variable language_">self</span>.ref_dict[insn.operands[<span class="number">1</span>].imm].append(insn.address)</span><br><span class="line"></span><br><span class="line">                    disasm_offset += size  <span class="comment"># 移动反汇编指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将结果序列化到JSON文件</span></span><br><span class="line">        json.dump(<span class="variable language_">self</span>.ref_dict, <span class="built_in">open</span>(ref_file, <span class="string">&#x27;w+&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">str_ref</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查找字符串引用地址&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 在内存中搜索字符串</span></span><br><span class="line">        str_addrs = <span class="built_in">list</span>(<span class="variable language_">self</span>.project.loader.memory.find(s.encode()))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] 字符串地址: <span class="subst">&#123;<span class="string">&#x27; &#x27;</span>.join(<span class="string">f&#x27;0x<span class="subst">&#123;addr:x&#125;</span>&#x27;</span> <span class="keyword">for</span> addr <span class="keyword">in</span> str_addrs)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 收集所有引用该字符串的指令地址</span></span><br><span class="line">        <span class="keyword">return</span> [ref <span class="keyword">for</span> addr <span class="keyword">in</span> str_addrs <span class="keyword">for</span> ref <span class="keyword">in</span> <span class="variable language_">self</span>.ref_dict.get(addr, [])]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试用例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 示例：分析文件&quot;init&quot;中&quot;r+&quot;字符串的引用</span></span><br><span class="line">    ref_dict = RefDictX86(angr.Project(<span class="string">&quot;init&quot;</span>))  <span class="comment"># 初始化分析器</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;引用指令地址:&quot;</span>, <span class="string">&#x27; &#x27;</span>.join(<span class="string">f&#x27;0x<span class="subst">&#123;addr:x&#125;</span>&#x27;</span> <span class="keyword">for</span> addr <span class="keyword">in</span> ref_dict.str_ref(<span class="string">&quot;r+&quot;</span>)))</span><br></pre></td></tr></table></figure></div>

<h5 id="AArch64-架构-1"><a href="#AArch64-架构-1" class="headerlink" title="AArch64 架构"></a>AArch64 架构</h5><p>aarch 架构可以参考前面计算内存操作数对应的地址的方法扫描汇编进行预处理。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> rich.progress <span class="keyword">import</span> Progress  <span class="comment"># 更现代的进度条库</span></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone.arm64 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefDictARM64</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用于分析ARM64二进制文件并建立数据引用关系的工具类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, project: angr.project.Project</span>):</span><br><span class="line">        <span class="variable language_">self</span>.project = project</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据二进制文件MD5生成缓存文件名</span></span><br><span class="line">        ref_file = <span class="string">f&#x27;<span class="subst">&#123;project.loader.main_object.md5.<span class="built_in">hex</span>()&#125;</span>_ref.json&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果存在缓存文件直接加载</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(ref_file):</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(ref_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="variable language_">self</span>.ref_dict = &#123;<span class="built_in">int</span>(k): v <span class="keyword">for</span> k, v <span class="keyword">in</span> json.load(f).items()&#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化引用字典并获取.text节数据</span></span><br><span class="line">        <span class="variable language_">self</span>.ref_dict = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        text_section = <span class="built_in">next</span>(s <span class="keyword">for</span> s <span class="keyword">in</span> project.loader.main_object.sections <span class="keyword">if</span> s.name == <span class="string">&#x27;.text&#x27;</span>)</span><br><span class="line">        data = project.loader.memory.load(text_section.vaddr, text_section.filesize)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化反汇编引擎</span></span><br><span class="line">        cs = Cs(CS_ARCH_ARM64, CS_MODE_ARM)</span><br><span class="line">        cs.detail = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用上下文管理器管理进度条</span></span><br><span class="line">        <span class="keyword">with</span> Progress() <span class="keyword">as</span> progress:</span><br><span class="line">            task = progress.add_task(<span class="string">&quot;[*] 分析ARM64引用关系...&quot;</span>, total=text_section.filesize)</span><br><span class="line">            reg_value = &#123;&#125;  <span class="comment"># 用于跟踪寄存器存储的基地址</span></span><br><span class="line"></span><br><span class="line">            disasm_offset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (address, size, mnemonic, op_str) <span class="keyword">in</span> cs.disasm_lite(data[disasm_offset:], text_section.vaddr + disasm_offset):</span><br><span class="line">                progress.update(task, advance=size)</span><br><span class="line">                <span class="keyword">if</span> mnemonic == <span class="string">&#x27;adrp&#x27;</span> <span class="keyword">or</span> mnemonic == <span class="string">&#x27;add&#x27;</span>:</span><br><span class="line">                    insn = <span class="built_in">next</span>(cs.disasm(data[disasm_offset:disasm_offset + size], text_section.vaddr + disasm_offset))</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 处理ADRP指令（页地址加载）</span></span><br><span class="line">                    <span class="keyword">if</span> insn.mnemonic == <span class="string">&#x27;adrp&#x27;</span>:</span><br><span class="line">                        <span class="keyword">if</span> (insn.operands[<span class="number">0</span>].<span class="built_in">type</span> == ARM64_OP_REG <span class="keyword">and</span></span><br><span class="line">                                insn.operands[<span class="number">1</span>].<span class="built_in">type</span> == ARM64_OP_IMM):</span><br><span class="line">                            <span class="comment"># 记录寄存器存储的页基地址</span></span><br><span class="line">                            reg_value[insn.operands[<span class="number">0</span>].reg] = insn.operands[<span class="number">1</span>].imm</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 处理ADD指令（偏移地址计算）</span></span><br><span class="line">                    <span class="keyword">elif</span> insn.mnemonic == <span class="string">&#x27;add&#x27;</span>:</span><br><span class="line">                        <span class="keyword">if</span> (insn.operands[<span class="number">0</span>].<span class="built_in">type</span> == ARM64_OP_REG <span class="keyword">and</span></span><br><span class="line">                                insn.operands[<span class="number">1</span>].<span class="built_in">type</span> == ARM64_OP_REG <span class="keyword">and</span></span><br><span class="line">                                insn.operands[<span class="number">2</span>].<span class="built_in">type</span> == ARM64_OP_IMM <span class="keyword">and</span></span><br><span class="line">                                insn.operands[<span class="number">0</span>].reg == insn.operands[<span class="number">1</span>].reg <span class="keyword">and</span></span><br><span class="line">                                insn.operands[<span class="number">1</span>].reg <span class="keyword">in</span> reg_value):</span><br><span class="line">                            <span class="comment"># 计算完整地址 = 页基地址 + 偏移量</span></span><br><span class="line">                            base = reg_value[insn.operands[<span class="number">1</span>].reg]</span><br><span class="line">                            full_addr = base + insn.operands[<span class="number">2</span>].imm</span><br><span class="line">                            <span class="variable language_">self</span>.ref_dict[full_addr].append(insn.address)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 分支指令清空寄存器跟踪状态</span></span><br><span class="line">                <span class="keyword">if</span> mnemonic.startswith(<span class="string">&#x27;b&#x27;</span>):</span><br><span class="line">                    reg_value.clear()</span><br><span class="line"></span><br><span class="line">                disasm_offset += size</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存结果到JSON文件</span></span><br><span class="line">        os.makedirs(<span class="string">&#x27;refs&#x27;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(ref_file, <span class="string">&#x27;w+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(<span class="variable language_">self</span>.ref_dict, f)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">str_ref</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查找字符串引用地址&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 在内存中搜索字符串</span></span><br><span class="line">        str_addrs = <span class="built_in">list</span>(<span class="variable language_">self</span>.project.loader.memory.find(s.encode()))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] 字符串地址: <span class="subst">&#123;<span class="string">&#x27; &#x27;</span>.join(<span class="string">f&#x27;0x<span class="subst">&#123;addr:x&#125;</span>&#x27;</span> <span class="keyword">for</span> addr <span class="keyword">in</span> str_addrs)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 收集所有引用该字符串的指令地址</span></span><br><span class="line">        <span class="keyword">return</span> [ref <span class="keyword">for</span> addr <span class="keyword">in</span> str_addrs <span class="keyword">for</span> ref <span class="keyword">in</span> <span class="variable language_">self</span>.ref_dict.get(addr, [])]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试用例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 示例：分析文件&quot;init&quot;中&quot;r+&quot;字符串的引用</span></span><br><span class="line">    ref_dict = RefDictARM64(angr.Project(<span class="string">&quot;init&quot;</span>, auto_load_libs=<span class="literal">False</span>))  <span class="comment"># 初始化分析器</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;引用指令地址:&quot;</span>, <span class="string">&#x27; &#x27;</span>.join(<span class="string">f&#x27;0x<span class="subst">&#123;addr:x&#125;</span>&#x27;</span> <span class="keyword">for</span> addr <span class="keyword">in</span> ref_dict.str_ref(<span class="string">&quot;r+&quot;</span>)))</span><br></pre></td></tr></table></figure></div>

<h2 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h2><h3 id="符号执行原理"><a href="#符号执行原理" class="headerlink" title="符号执行原理"></a>符号执行原理</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>符号执行（Symbolic Execution）</strong>是一种程序分析技术，它通过使用符号（而不是具体的值）来代替程序中的输入数据，在程序执行时跟踪符号变量的值。这使得我们能够推理出程序的行为，而不需要实际运行它。符号执行可以帮助发现程序的潜在问题，如漏洞、错误和安全问题，尤其在静态分析、漏洞挖掘和逆向工程等领域有广泛应用。</p>
<p>符号执行中的 <strong>符号状态</strong> 和 <strong>路径约束</strong> 是符号执行中两个非常重要的概念，它们帮助我们表达程序的执行过程和各种条件。</p>
<ul>
<li>符号状态（Symbolic State）：当前状态所有参数的集合，用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">σ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> 表示。集合中的每个元素用表示初始参数的变量表示。</li>
<li>路径约束（Path Constraint）：到达当前路径需要表示初始参数满足的关系，通常用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>PC</mtext></mrow><annotation encoding="application/x-tex">\text{PC}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">PC</span></span></span></span></span> 表示。</li>
</ul>
<p>例如下面的程序：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    z = <span class="number">2</span> * y;</span><br><span class="line">    <span class="keyword">if</span> (x == z) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y + <span class="number">10</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Path-1&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Path-2&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Path-3&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对应的程序框图如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/02/%E9%80%86%E5%90%91%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/images/simulation.svg"
                      alt="simulation"
                ></p>
<p>我们用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>s</mi><mi>i</mi><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{sim}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">im</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>s</mi><mi>i</mi><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">y_{sim}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">im</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 分别表示初始输入的参数 <code>x</code> ，<code>y</code> 。如果程序执行到 <code>Path-1</code> ，则：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mo>=</mo><msub><mi>x</mi><mrow><mi>s</mi><mi>i</mi><mi>m</mi></mrow></msub><mo separator="true">,</mo><mi>y</mi><mo>=</mo><msub><mi>y</mi><mrow><mi>s</mi><mi>i</mi><mi>m</mi></mrow></msub><mo separator="true">,</mo><mi>z</mi><mo>=</mo><mn>2</mn><mo>⋅</mo><msub><mi>y</mi><mrow><mi>s</mi><mi>i</mi><mi>m</mi></mrow></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">σ=\{x=x_{sim},y=y_{sim},z=2\cdot y_{sim}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">im</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">im</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">im</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>PC</mtext><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>s</mi><mi>i</mi><mi>m</mi></mrow></msub><mo>=</mo><mn>2</mn><mo>⋅</mo><msub><mi>y</mi><mrow><mi>s</mi><mi>i</mi><mi>m</mi></mrow></msub><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>s</mi><mi>i</mi><mi>m</mi></mrow></msub><mo>&gt;</mo><msub><mi>y</mi><mrow><mi>s</mi><mi>i</mi><mi>m</mi></mrow></msub><mo>+</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{PC}=(x_{sim}=2\cdot y_{sim}) \wedge ( x_{sim}&gt;y_{sim}+10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord">PC</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">im</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">im</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">im</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">im</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">10</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h4 id="约束求解"><a href="#约束求解" class="headerlink" title="约束求解"></a>约束求解</h4><p>即根据符号执行求得的执行到目标位置时的状态，反推出初始时假设的各个变量的值。</p>
<p>例如上面计算出执行到 <code>Path-1</code> 时的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">σ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> 和 PC 。如果执行到 <code>Path-1</code> 则应当满足 PC 为真，进一步推出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>s</mi><mi>i</mi><mi>m</mi></mrow></msub><mo>=</mo><mn>22</mn><mo separator="true">,</mo><msub><mi>y</mi><mrow><mi>s</mi><mi>i</mi><mi>m</mi></mrow></msub><mo>=</mo><mn>11</mn></mrow><annotation encoding="application/x-tex">x_{sim} = 22,y_{sim}=11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">im</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">22</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">im</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span> 为一组合法解。</p>
<p>为了进行约束求解，angr 内置了 z3 约束求解器（封装为 claripy）。</p>
<h4 id="动态符号执行"><a href="#动态符号执行" class="headerlink" title="动态符号执行"></a>动态符号执行</h4><p>由于 angr 分析基于的是低级语言，会涉及内存、寄存器等结构，如果全部符号化会使得路径约束变得十分复杂且没有必要。</p>
<p>因此 angr 采取<strong>动态符号执行（Dynamic Symbloic Execution）</strong>或者叫做<strong>混合执行（Concolic Execution）</strong>的方式，即将关键变量符号化，其他变量都赋一个合理的初始值。</p>
<p>angr 在默认情况下，只有从标准输入流中读取的数据会被符号化，其他数据都是具有实际值的。</p>
<h3 id="符号执行引擎（Claripy）"><a href="#符号执行引擎（Claripy）" class="headerlink" title="符号执行引擎（Claripy）"></a>符号执行引擎（Claripy）</h3><p><strong>Claripy</strong> 是由 z3 封装的二进制分析框架 angr 的核心符号执行引擎，专注于 <strong>符号表达式操作</strong> 和 <strong>约束求解</strong>。它为二进制分析提供了一套高级抽象接口，简化了符号变量管理、约束构建和求解过程，使复杂的符号执行任务更易实现。</p>
<h4 id="位向量创建"><a href="#位向量创建" class="headerlink" title="位向量创建"></a>位向量创建</h4><p><strong>位向量（Bitvectors）</strong> 是符号执行中一个非常核心的概念，特别是在像 angr 这样的符号执行框架中，位向量用于表示程序中变量的值和各种计算结果。</p>
<p>位向量是一个由多个比特（bit）组成的向量。在符号执行的上下文中，位向量被用来表示程序中未确定的数值（如变量、内存中的数据等）。每个比特的位置可以表示不同的数值或者数据状态。</p>
<p>我们可以通过 Claripy 创建位向量常量：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 64 位位向量，具体值为 1 和 100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one = claripy.BVV(<span class="number">1</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one</span><br><span class="line">&lt;BV64 <span class="number">0x1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one._model_concrete.value</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_hundred = claripy.BVV(<span class="number">100</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_hundred</span><br><span class="line">&lt;BV64 <span class="number">0x64</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 27 位位向量，具体值为 9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_nine = claripy.BVV(<span class="number">9</span>, <span class="number">27</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_nine</span><br><span class="line">&lt;BV27 <span class="number">0x9</span>&gt;</span><br></pre></td></tr></table></figure></div>

<p>除了位向量常量，我们还可以创建位向量符号：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 &quot;x&quot; 的 64 位位向量符号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = claripy.BVS(<span class="string">&quot;x&quot;</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">&lt;BV64 x_9_64&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = claripy.BVS(<span class="string">&quot;y&quot;</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">&lt;BV64 y_10_64&gt;</span><br></pre></td></tr></table></figure></div>

<p>z3 支持 IEEE754 浮点数理论，因此 angr 也可以使用它们。主要的区别是，浮点数不是通过宽度来表示的，而是通过 <code>claripy.fp.FSORT_FLOAT/claripy.fp.FSORT_DOUBLE</code> 来表示。你可以使用 <code>FPV</code> 和 <code>FPS</code> 来创建浮点符号和浮点值。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = claripy.FPV(<span class="number">3.2</span>, claripy.fp.FSORT_DOUBLE)  <span class="comment"># 创建浮点值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;FP64 FPV(<span class="number">3.2</span>, DOUBLE)&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = claripy.FPS(<span class="string">&#x27;b&#x27;</span>, claripy.fp.FSORT_DOUBLE)  <span class="comment"># 创建浮点符号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">&lt;FP64 FPS(<span class="string">&#x27;FP_b_0_64&#x27;</span>, DOUBLE)&gt;</span><br></pre></td></tr></table></figure></div>

<p>浮点数和整数类型的向量可以互相转换。</p>
<p>如果是使用 <code>raw_to_bv</code> 和 <code>raw_to_fp</code> 转换则表示的是数据不变，数据的解释方式改变（就像你将浮点数指针转换为整数指针或反之一样）。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.raw_to_bv()</span><br><span class="line">&lt;BV64 <span class="number">0x400999999999999a</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.raw_to_bv()</span><br><span class="line">&lt;BV64 fpToIEEEBV(FPS(<span class="string">&#x27;FP_b_0_64&#x27;</span>, DOUBLE))&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>claripy.BVV(<span class="number">0</span>, <span class="number">64</span>).raw_to_fp()</span><br><span class="line">&lt;FP64 FPV(<span class="number">0.0</span>, DOUBLE)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>claripy.BVS(<span class="string">&#x27;x&#x27;</span>, <span class="number">64</span>).raw_to_fp()</span><br><span class="line">&lt;FP64 fpToFP(x_1_64, DOUBLE)&gt;</span><br></pre></td></tr></table></figure></div>

<p>如果是类型转换则需要使用 <code>val_to_fp</code> 和 <code>val_to_bv</code>：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;FP64 FPV(<span class="number">3.2</span>, DOUBLE)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.val_to_bv(<span class="number">12</span>)</span><br><span class="line">&lt;BV12 <span class="number">0x3</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.val_to_bv(<span class="number">12</span>).val_to_fp(claripy.fp.FSORT_FLOAT)</span><br><span class="line">&lt;FP32 FPV(<span class="number">3.0</span>, FLOAT)&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="位向量运算"><a href="#位向量运算" class="headerlink" title="位向量运算"></a>位向量运算</h4><p>同样长度的位向量可以进行运算，其中 Pyhton 的整数类型也可以参与运算，在运算过程中会被强制转换为适当的类型。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>one + one_hundred</span><br><span class="line">&lt;BV64 <span class="number">0x65</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_hundred + <span class="number">0x100</span></span><br><span class="line">&lt;BV64 <span class="number">0x164</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_hundred - one*<span class="number">200</span></span><br><span class="line">&lt;BV64 <span class="number">0xffffffffffffff9c</span>&gt;</span><br></pre></td></tr></table></figure></div>

<p>但是，你不能执行 <code>one + weird_nine</code>，因为操作数位向量的长度不同，这是一个类型错误。然而，你可以扩展 <code>weird_nine</code> 使它具有适当的位数：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_nine.zero_extend(<span class="number">64</span> - <span class="number">27</span>)</span><br><span class="line">&lt;BV64 <span class="number">0x9</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one + weird_nine.zero_extend(<span class="number">64</span> - <span class="number">27</span>)</span><br><span class="line">&lt;BV64 <span class="number">0xa</span>&gt;</span><br></pre></td></tr></table></figure></div>

<p><code>zero_extend</code> 将在位向量的左侧填充给定数量的零位。你还可以使用 <code>sign_extend</code> 来用最高位的副本进行填充，保持位向量在二进制补码有符号整数语义下的值。</p>
<p>位向量符号同样也可以参与到位向量运算中。你可以对它们进行任意算术运算，但你不会得到一个数字，而是得到一个 AST（抽象语法树）。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x + one</span><br><span class="line">&lt;BV64 x_9_64 + <span class="number">0x1</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(x + one) / <span class="number">2</span></span><br><span class="line">&lt;BV64 (x_9_64 + <span class="number">0x1</span>) / <span class="number">0x2</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x - y</span><br><span class="line">&lt;BV64 x_9_64 - y_10_64&gt;</span><br></pre></td></tr></table></figure></div>

<p>每个 AST 都有 <code>.op</code> 和 <code>.args</code> 属性：</p>
<ul>
<li><code>op</code> 是一个字符串，表示正在执行的操作。</li>
<li><code>args</code> 是该操作接受的输入值。</li>
</ul>
<p>除非 <code>op</code> 是 <code>BVV</code> 或 <code>BVS</code>（或其他少数几种情况），否则 <code>args</code> 都是其他的 AST，最终树将终止于 <code>BVV</code> 或 <code>BVS</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/02/%E9%80%86%E5%90%91%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/images/AST.svg"
                      alt="AST"
                ></p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree = (x + <span class="number">1</span>) / (y + <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree</span><br><span class="line">&lt;BV64 (x_9_64 + <span class="number">0x1</span>) / (y_10_64 + <span class="number">0x2</span>)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree.op</span><br><span class="line"><span class="string">&#x27;__floordiv__&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree.args</span><br><span class="line">(&lt;BV64 x_9_64 + <span class="number">0x1</span>&gt;, &lt;BV64 y_10_64 + <span class="number">0x2</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree.args[<span class="number">0</span>].op</span><br><span class="line"><span class="string">&#x27;__add__&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree.args[<span class="number">0</span>].args</span><br><span class="line">(&lt;BV64 x_9_64&gt;, &lt;BV64 <span class="number">0x1</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree.args[<span class="number">0</span>].args[<span class="number">1</span>].op</span><br><span class="line"><span class="string">&#x27;BVV&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree.args[<span class="number">0</span>].args[<span class="number">1</span>].args</span><br><span class="line">(<span class="number">1</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure></div>

<p>另外浮点数向量也支持数学运算：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + b</span><br><span class="line">&lt;FP64 fpAdd(<span class="string">&#x27;RNE&#x27;</span>, FPV(<span class="number">3.2</span>, DOUBLE), FPS(<span class="string">&#x27;FP_b_0_64&#x27;</span>, DOUBLE))&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + <span class="number">4.4</span></span><br><span class="line">&lt;FP64 FPV(<span class="number">7.6000000000000005</span>, DOUBLE)&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b + <span class="number">2</span> &lt; <span class="number">0</span></span><br><span class="line">&lt;Bool fpLT(fpAdd(<span class="string">&#x27;RNE&#x27;</span>, FPS(<span class="string">&#x27;FP_b_0_64&#x27;</span>, DOUBLE), FPV(<span class="number">2.0</span>, DOUBLE)), FPV(<span class="number">0.0</span>, DOUBLE))&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="符号约束（Symbolic-Constraints）"><a href="#符号约束（Symbolic-Constraints）" class="headerlink" title="符号约束（Symbolic Constraints）"></a>符号约束（Symbolic Constraints）</h4><p>对任何两个相同类型的 AST 执行比较操作将生成另一个 AST。这个新生成的 AST 不是位向量，而是一个符号布尔值。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>AST 默认情况下的比较是无符号的。最后一个例子中的 <code>-5</code> 会被强制转换为 <code>&lt;BV64 0xfffffffffffffffb&gt;</code>，它显然不小于 100。如果你想要进行有符号的比较，可以使用 <code>one_hundred.SGT(-5)</code>（即“有符号大于”）。</p>

    </div>
  </div>

<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == <span class="number">1</span></span><br><span class="line">&lt;Bool x_9_64 == <span class="number">0x1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == one</span><br><span class="line">&lt;Bool x_9_64 == <span class="number">0x1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x &gt; <span class="number">2</span></span><br><span class="line">&lt;Bool x_9_64 &gt; <span class="number">0x2</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x + y == one_hundred + <span class="number">5</span></span><br><span class="line">&lt;Bool (x_9_64 + y_10_64) == <span class="number">0x69</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_hundred &gt; <span class="number">5</span></span><br><span class="line">&lt;Bool <span class="literal">True</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_hundred &gt; -<span class="number">5</span></span><br><span class="line">&lt;Bool <span class="literal">False</span>&gt;</span><br></pre></td></tr></table></figure></div>

<p>符号布尔值可以通过 <code>claripy.is_true/claripy.is_false</code> 或本身的 <code>is_true</code> 和 <code>is_false</code> 方法来判断真假。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>is_true</code> 和 <code>is_false</code> 只是用来判断符号布尔值是否永真或永假。对于结果不确定的符号布尔值两个方法都会返回 <code>False</code>。</p>

    </div>
  </div>

<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>yes = one == <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>no = one == <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>maybe = x == y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>claripy.is_true(yes) <span class="comment"># 等价于 yes.is_true()</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>claripy.is_false(yes)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>claripy.is_true(no)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>claripy.is_false(no)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>claripy.is_true(maybe)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>claripy.is_false(maybe)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></div>

<p>另外符号布尔值不应直接在 <code>if</code> 语句或 <code>while</code> 语句的条件中使用，因为答案可能没有具体的真值，并且即使有具体真值也会触发异常。</p>
<p>通常情况下，Claripy 支持所有常见的 Python 操作符（如 <code>+</code>、<code>-</code>、<code>|</code>、<code>==</code> 等），并通过 Claripy 实例对象提供了额外的一些操作。这些操作是 Claripy 提供的用于处理符号表达式的基本操作，通过它们可以进行位运算、条件判断、扩展和提取等操作，在符号执行和分析中非常有用。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>LShR</strong></td>
<td>逻辑右移位操作（适用于位表达式，如 BV、SI）。</td>
<td><code>claripy.LShR(x, 10)</code></td>
</tr>
<tr>
<td><strong>SignExt</strong></td>
<td>对位表达式进行符号扩展。</td>
<td><code>claripy.SignExt(32, x)</code> 或 <code>x.sign_extend(32)</code></td>
</tr>
<tr>
<td><strong>ZeroExt</strong></td>
<td>对位表达式进行零扩展。</td>
<td><code>claripy.ZeroExt(32, x)</code> 或 <code>x.zero_extend(32)</code></td>
</tr>
<tr>
<td><strong>Extract</strong></td>
<td>从位表达式中提取指定的位（从右侧零索引开始，包含边界）。</td>
<td>提取 <code>x</code> 最右边的字节：<code>claripy.Extract(7, 0, x)</code> 或 <code>x[7:0]</code></td>
</tr>
<tr>
<td><strong>Concat</strong></td>
<td>将多个位表达式拼接成一个新的位表达式。</td>
<td><code>claripy.Concat(x, y, z)</code></td>
</tr>
<tr>
<td><strong>RotateLeft</strong></td>
<td>将位表达式左旋转。</td>
<td><code>claripy.RotateLeft(x, 8)</code></td>
</tr>
<tr>
<td><strong>RotateRight</strong></td>
<td>将位表达式右旋转。</td>
<td><code>claripy.RotateRight(x, 8)</code></td>
</tr>
<tr>
<td><strong>Reverse</strong></td>
<td>对位表达式进行字节序反转。</td>
<td><code>claripy.Reverse(x)</code> 或 <code>x.reversed</code></td>
</tr>
<tr>
<td><strong>And</strong></td>
<td>逻辑与（适用于布尔表达式）。</td>
<td><code>claripy.And(x == y, x &gt; 0)</code></td>
</tr>
<tr>
<td><strong>Or</strong></td>
<td>逻辑或（适用于布尔表达式）。</td>
<td><code>claripy.Or(x == y, y &lt; 10)</code></td>
</tr>
<tr>
<td><strong>Not</strong></td>
<td>逻辑非（适用于布尔表达式）。</td>
<td><code>claripy.Not(x == y)</code> 等同于 <code>x != y</code></td>
</tr>
<tr>
<td><strong>If</strong></td>
<td>条件选择（If-then-else）。</td>
<td>选择 <code>x</code> 和 <code>y</code> 中的最大值：<code>claripy.If(x &gt; y, x, y)</code></td>
</tr>
<tr>
<td><strong>ULE</strong></td>
<td>无符号小于或等于。</td>
<td>检查 <code>x</code> 是否小于或等于 <code>y</code>：<code>claripy.ULE(x, y)</code></td>
</tr>
<tr>
<td><strong>ULT</strong></td>
<td>无符号小于。</td>
<td>检查 <code>x</code> 是否小于 <code>y</code>：<code>claripy.ULT(x, y)</code></td>
</tr>
<tr>
<td><strong>UGE</strong></td>
<td>无符号大于或等于。</td>
<td>检查 <code>x</code> 是否大于或等于 <code>y</code>：<code>claripy.UGE(x, y)</code></td>
</tr>
<tr>
<td><strong>UGT</strong></td>
<td>无符号大于。</td>
<td>检查 <code>x</code> 是否大于 <code>y</code>：<code>claripy.UGT(x, y)</code></td>
</tr>
<tr>
<td><strong>SLE</strong></td>
<td>有符号小于或等于。</td>
<td>检查 <code>x</code> 是否小于或等于 <code>y</code>：<code>claripy.SLE(x, y)</code></td>
</tr>
<tr>
<td><strong>SLT</strong></td>
<td>有符号小于。</td>
<td>检查 <code>x</code> 是否小于 <code>y</code>：<code>claripy.SLT(x, y)</code></td>
</tr>
<tr>
<td><strong>SGE</strong></td>
<td>有符号大于或等于。</td>
<td>检查 <code>x</code> 是否大于或等于 <code>y</code>：<code>claripy.SGE(x, y)</code></td>
</tr>
<tr>
<td><strong>SGT</strong></td>
<td>有符号大于。</td>
<td>检查 <code>x</code> 是否大于 <code>y</code>：<code>claripy.SGT(x, y)</code></td>
</tr>
</tbody></table>
<h4 id="约束求解（Constraint-Solving）"><a href="#约束求解（Constraint-Solving）" class="headerlink" title="约束求解（Constraint Solving）"></a>约束求解（Constraint Solving）</h4><p>你可以将任何符号布尔值视为对符号变量有效值的断言，通过将其作为约束添加到状态中。然后，你可以通过请求对符号表达式的求值，查询符号变量的有效值。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>solver = claripy.Solver()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>solver.add(x &gt; y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>solver.add(y &gt; <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>solver.add(<span class="number">10</span> &gt; x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>solver.<span class="built_in">eval</span>(x, <span class="number">4</span>) <span class="comment"># 第二个参数表示获取的解的个数</span></span><br><span class="line">(<span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>solver.<span class="built_in">eval</span>(x + y, <span class="number">3</span>) <span class="comment"># 支持求解表达式</span></span><br><span class="line">(<span class="number">7</span>, <span class="number">15</span>, <span class="number">16</span>)</span><br></pre></td></tr></table></figure></div>

<p>如果我们添加了相互冲突或矛盾的约束，导致没有任何值可以赋给变量以满足约束条件，状态将变得不可满足（unsat），查询时会引发异常。你可以通过 <code>solver.satisfiable()</code> 检查状态是否可满足。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>solver.satisfiable()</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></div>

<p>另外如果我们想要获取解的最大或最小值则应当使用 <code>max</code> 和 <code>min</code> 方法：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>solver.<span class="built_in">max</span>(x)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>solver.<span class="built_in">min</span>(x)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></div>

<h3 id="状态（States）"><a href="#状态（States）" class="headerlink" title="状态（States）"></a>状态（States）</h3><p><code>Project</code> 对象只代表程序的一个“初始化镜像”。当你在 angr 中执行程序时，你实际上是在操作一个代表程序状态的对象——<code>SimState</code>。</p>
<h4 id="状态创建"><a href="#状态创建" class="headerlink" title="状态创建"></a>状态创建</h4><p>我们可以通过 <code>factory</code> 的 <code>entry_state</code> 创建状态。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()</span><br><span class="line">&lt;SimState @ <span class="number">0x401670</span>&gt;</span><br></pre></td></tr></table></figure></div>

<p>当然 <code>entry_state</code> 只是项目工厂提供的多个状态构造函数之一，常见的状态构造函数有：</p>
<ul>
<li><code>.blank_state()</code>构造一个“空白”状态，数据大部分没有初始化。当访问未初始化的数据时，会返回一个没有约束的符号值。适用于要完全控制初始条件的场景。<ul>
<li><strong>addr</strong> ：状态应该开始的地址，而不是入口点。</li>
</ul>
</li>
<li><code>.entry_state()</code>：构造一个准备从主二进制的入口点开始执行的状态。<ul>
<li><strong>argc</strong> ：用作程序 <code>argc</code> 的自定义值，可以是整数或比特向量。如果未提供，则默认为 args 的长度。</li>
<li><strong>args</strong> ：一个值的列表，用作程序的 <code>argv</code>。可以是混合字符串和比特向量。</li>
<li><strong>env</strong> ：一个字典，用作程序的环境。键和值都可以是混合的字符串和比特向量。</li>
<li><strong>stdin</strong> ：程序的输入流。可以是字符串或比特向量，不过最好长度给的要足够。</li>
</ul>
</li>
<li><code>.full_init_state()</code>：构造一个准备执行所有需要在主二进制入口点之前运行的初始化器的状态，例如共享库构造函数或预初始化器。当这些完成后，它将跳转到入口点。它可以接受 <code>entry_state</code> 可以提供的任何参数，除了 <code>addr</code>。</li>
<li><code>.call_state()</code>：构造一个准备执行给定函数的状态。<ul>
<li><strong>addr</strong> ：状态应该开始的地址，而不是入口点。</li>
<li><strong>args</strong> ：任何额外的位置参数将作为函数调用的参数。</li>
</ul>
</li>
</ul>
<p><code>SimState</code> 包含了程序的内存、寄存器、文件系统数据等内容……任何在执行过程中可能被修改的“实时数据”都存储在这个状态中。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.rip        <span class="comment"># 获取当前的指令指针</span></span><br><span class="line">&lt;BV64 <span class="number">0x401670</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.rax</span><br><span class="line">&lt;BV64 <span class="number">0x1c</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[proj.entry].<span class="built_in">int</span>.resolved  <span class="comment"># 将入口点处的内存作为 C int 解释</span></span><br><span class="line">&lt;BV32 <span class="number">0x8949ed31</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准输入内容</span></span><br><span class="line"><span class="comment"># state.posix.dumps(fileno) 获取对应文件描述符上的流</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.posix.dumps(<span class="number">0</span>)</span><br><span class="line"><span class="string">b&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>可以看到无论是内存还是寄存器，angr 的 <code>SimState</code> 都是用位向量的形式来维护。这种策略方便符号执行完之后进行约束求解。另外就是除了输入和用户指定的数据外，其余数据都是给定一个合理的初始值而不都是符号化，这样可以极大的简化最终生成的表达式的复杂程度。</p>
<h4 id="内存设置"><a href="#内存设置" class="headerlink" title="内存设置"></a>内存设置</h4><p>在 angr 中，<code>state.mem</code> 和 <code>state.memory</code> 是用于操作内存的两个核心接口，分别提供 <strong>类型化内存访问</strong> 和 <strong>原始字节级操作</strong> 的功能。</p>
<p><code>state.memory</code> 提供 <strong>原始字节级操作</strong>，这意味着你可以直接访问内存的字节，而不需要考虑类型的转换。<code>state.memory</code> 用于处理低级操作，适合那些需要进行细粒度控制的场景，或者需要直接修改内存数据的情况。</p>
<ul>
<li><code>load(addr, size)</code>：从地址 <code>addr</code> 读取 <code>size</code> 字节，返回位向量（<code>claripy.BV</code>）。</li>
<li><code>store(addr, data)</code>：将数据 <code>data</code>（位向量或字节）写入地址 <code>addr</code>。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state = proj.factory.blank_state()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.memory.store(<span class="number">0x4000</span>, s.solver.BVV(<span class="number">0x0123456789abcdef0123456789abcdef</span>, <span class="number">128</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.memory.load(<span class="number">0x4004</span>, <span class="number">6</span>)</span><br><span class="line">&lt;BV48 <span class="number">0x89abcdef0123</span>&gt;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>state.memory</code> 的主要用途是加载和存储数据块，没有附加语义，因此数据默认按照<strong>“大端序”</strong>读写。如果你想对加载或存储的数据进行字节交换，你可以传递一个关键字参数 <code>endness</code>。</p>
<p><code>endness</code> 应该是 <code>archinfo</code> 包中的 <code>Endness</code> 枚举的成员，该包用于保存关于 <code>angr</code> 中 CPU 架构的声明性数据。此外，正在分析的程序的字节序可以通过 <code>arch.memory_endness</code> 获取，比如 <code>state.arch.memory_endness</code>。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> archinfo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.memory.load(<span class="number">0x4000</span>, <span class="number">4</span>, endness=archinfo.Endness.LE)</span><br><span class="line">&lt;BV32 <span class="number">0x67452301</span>&gt;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<p><code>state.mem</code> 提供 <strong>类型化内存访问</strong>，允许你对内存进行更高层次的操作，通常与寄存器、结构体、数组等数据结构的交互更为便捷。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li><code>state.mem</code> 赋值的时候可以使用 <code>bytes</code>、数字、位向量，但是位向量要确保类型长度一致。</li>
<li><code>state.mem</code> 按照二进制默认的大小端序读写。</li>
</ul>

    </div>
  </div>

<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state = proj.factory.blank_state()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0x4000</span>].int64_t = <span class="number">0xdeadbeefcafebabe</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0x4000</span>].uint32_t</span><br><span class="line">&lt;uint32_t &lt;BV32 <span class="number">0xcafebabe</span>&gt; at <span class="number">0x4000</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0x4000</span>].uint32_t.resolved</span><br><span class="line">&lt;BV32 <span class="number">0xcafebabe</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0x4000</span>].uint32_t.resolved._model_concrete.value</span><br><span class="line"><span class="number">0xcafebabe</span></span><br></pre></td></tr></table></figure></div>

<h4 id="寄存器设置"><a href="#寄存器设置" class="headerlink" title="寄存器设置"></a>寄存器设置</h4><p>和内存接口一样，angr 的寄存器接口也有 <code>state.regs</code> 和 <code>state.registers</code> 两种。和 <code>state.memory</code> 一样，<code>state.registers</code> 也提供了没有具体类型的底层数据访问接口，因为 angr 的寄存器本质上也是通过某个地址空间的内存来模拟的。</p>
<p>不过在实际使用中我们通常还是使用 <code>state.regs</code> 接口来读写寄存器。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> angr, claripy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj = angr.Project(<span class="string">&#x27;/bin/true&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 rsp 复制到 rbp</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.rbp = state.regs.rsp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 rdx 存储到内存地址 0x1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0x1000</span>].uint64_t = state.regs.rdx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解引用 rbp</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.rbp = state.mem[state.regs.rbp].uint64_t.resolved</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 add rax, qword ptr [rsp + 8]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.rax += state.mem[state.regs.rsp + <span class="number">8</span>].uint64_t.resolved</span><br></pre></td></tr></table></figure></div>

<h4 id="文件设置"><a href="#文件设置" class="headerlink" title="文件设置"></a>文件设置</h4><p><code>SimFile</code> 是 <code>angr</code> 中用于模拟文件操作的类，它实现了对文件的模拟，包括文件读取、写入、以及其他文件操作。它设计的目标是模拟磁盘文件的行为，并且允许符号执行引擎（symbolic execution engine）对文件的内容和文件系统操作进行符号化处理。</p>
<p><code>SimFile</code> 构造函数中常用的参数有：</p>
<ul>
<li><strong><code>name</code></strong> ：文件的名称，用于标识文件。这个名称通常是文件路径的一部分。</li>
<li><strong><code>content</code></strong> ：可选的初始内容，可以是字符串或者位向量（bitvector）。如果没有提供内容，文件内容将默认为零。</li>
<li><strong><code>size</code></strong> ：可选的文件大小。如果没有提供大小，文件大小默认为零。如果提供了 <code>content</code>，则文件大小将根据内容的大小确定。</li>
</ul>
<p>例如下面的示例代码，我们将 <code>password.txt</code> 这个文件符号化，这样如果程序的执行受到了该文件内容的影响，那么我们就可以在目标状态下求解文件的内容。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, <span class="number">0x40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sim_file = angr.SimFile(name=<span class="string">&#x27;password.txt&#x27;</span>, content=password, size=<span class="number">0x40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.fs.insert(<span class="string">&#x27;password.txt&#x27;</span>, sim_file)</span><br></pre></td></tr></table></figure></div>

<h3 id="仿真管理器（Simulation-Managers）"><a href="#仿真管理器（Simulation-Managers）" class="headerlink" title="仿真管理器（Simulation Managers）"></a>仿真管理器（Simulation Managers）</h3><p>在 <code>angr</code> 中，仿真管理器（Simulation Managers）是用于管理模拟状态（<code>SimState</code>）的核心组件之一。仿真管理器负责维护符号执行过程中所有可能的路径，并为每个路径创建并管理相应的状态。</p>
<h4 id="仿真管理器创建"><a href="#仿真管理器创建" class="headerlink" title="仿真管理器创建"></a>仿真管理器创建</h4><p>仿真管理器通过 <code>factory</code> 的 <code>simulation_manager</code> 构造函数生成，该函数接收一个状态或状态列表。一个仿真管理器可以包含多个状态堆栈。默认的状态堆栈是 <code>active</code>，它使用我们传入的状态进行初始化。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr = proj.factory.simulation_manager(state)</span><br><span class="line">&lt;SimulationManager <span class="keyword">with</span> <span class="number">1</span> active&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr.active</span><br><span class="line">[&lt;SimState @ <span class="number">0x401670</span>&gt;]</span><br></pre></td></tr></table></figure></div>

<p>在 angr 当中，不同的状态被组织到 simulation manager 的不同的 stash 当中，我们可以按照自己的需求进行步进、过滤、合并、移动等。在 angr 当中一共有以下几种 stash：</p>
<ul>
<li><code>simgr.active</code>：活跃的状态列表。在未指定替代的情况下会被模拟器默认执行。</li>
<li><code>simgr.deadended</code>：死亡的状态列表。当一个状态无法再被继续执行时（例如没有有效指令、无效的指令指针、不满足其所有的后继（successors））便会被归入该列表。</li>
<li><code>simgr.pruned</code>：被剪枝的状态列表。在指定了 <code>LAZY_SOLVES</code> 时，状态仅在必要时检查可满足性，当一个状态在指定了 <code>LAZY_SOLVES</code> 时被发现是不可满足的（unsat），状态层（state hierarchy）将会被遍历以确认在其历史中最初变为不满足的时间，该点及其所有后代都会被 <em>剪枝</em> （pruned）并放入该列表。</li>
<li><code>simgr.unconstrained</code>：不受约束的状态列表。当创建 <code>SimulationManager</code> 时指定了 <code>save_unconstrained=True</code>，则被认为<strong>不受约束的</strong>（unconstrained，即指令指针被用户数据或其他来源的符号化数据控制）状态会被归入该列表。</li>
<li><code>simgr.unsat</code>：不可满足的状态列表。当创建 <code>SimulationManager</code> 时指定了 <code>save_unsat=True</code>，则被认为无法被满足的（unsatisfiable，即存在<strong>约束冲突</strong>的状态，例如在同一时刻要求输入既是<code>&quot;AAAA&quot;</code> 又是 <code>&quot;BBBB&quot;</code>）状态会被归入该列表。</li>
</ul>
<p>还有一种不是 stash 的状态列表——<code>errored</code>，若在执行中产生了错误，则状态与其产生的错误会被包裹在一个 <code>ErrorRecord</code> 实例中（可通过 <code>record.state</code> 与 <code>record.error</code> 访问），该 record 会被插入到 <code>errored</code> 中，我们可以通过 <code>record.debug()</code> 启动一个调试窗口。</p>
<p>我们可以使用 <code>stash.move()</code> 来在 stash 之间转移放置状态，用法如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr.move(from_stash = <span class="string">&#x27;unconstrained&#x27;</span>, to_stash = <span class="string">&#x27;active&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>在转移当中我们还可以通过指定 <code>filter_func</code> 参数来进行过滤：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">filter_func</span>(<span class="params">state</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">b&#x27;Right!&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr.move(from_stash = <span class="string">&#x27;unconstrained&#x27;</span>, to_stash = <span class="string">&#x27;active&#x27;</span>, filter_func = filter_func)</span><br></pre></td></tr></table></figure></div>

<p>stash 本质上就是个 list，因此在初始化时我们可以通过字典的方式指定每个 stash 的初始内容：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr = proj.factory.simgr(init_state,</span><br><span class="line"><span class="meta">... </span>    stashes = &#123;</span><br><span class="line"><span class="meta">... </span>            <span class="string">&#x27;active&#x27;</span>:[init_state],</span><br><span class="line"><span class="meta">... </span>            <span class="string">&#x27;found&#x27;</span>:[],</span><br><span class="line"><span class="meta">... </span>    &#125;)</span><br></pre></td></tr></table></figure></div>

<h4 id="路径探索"><a href="#路径探索" class="headerlink" title="路径探索"></a>路径探索</h4><p>仿真管理器以<strong>基本块</strong>为单位对程序进行符号执行，对应的方法为 <code>simgr.step()</code>。每当仿真管理器调用一次 <code>step</code> 方法时：</p>
<ul>
<li>内部维护的 <code>active</code> 列表中的所有活跃状态都会执行一个基本块。</li>
<li>每个状态在执行完一个基本块后根据基本块后根据执行的结果决定状态是否分裂或从 <code>active</code> 中移除。</li>
</ul>
<p>我们可以循环调用 <code>simgr.step()</code> 然后遍历 <code>active</code> 列表判断是否有执行到我们预想的目标地址的状态。然后再对执行到目标地址的状态求解所需的输入。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(simgr.active):</span><br><span class="line">    <span class="keyword">for</span> active <span class="keyword">in</span> simgr.active:</span><br><span class="line">        <span class="keyword">if</span> active.addr == target_addr:</span><br><span class="line">            <span class="comment"># 执行到目标地址</span></span><br><span class="line">            <span class="comment"># [...] </span></span><br><span class="line">    simgr.step()</span><br></pre></td></tr></table></figure></div>

<p>上述过程实际上在仿真管理器中被封装成一个路径探索函数 <code>simgr.explore()</code>。</p>
<p><code>explore</code> 函数主要有两个参数：</p>
<ul>
<li><strong><code>find</code></strong> ：一个地址或条件，表示我们希望探索到的目标状态。当仿真管理器的任何路径到达该地址时，仿真过程会停止或返回该路径。</li>
<li><strong><code>avoid</code></strong> ：一个地址或条件，表示我们希望避免的状态。即仿真管理器会尽量避免路径到达此地址或条件，通常用于避开错误路径或崩溃点。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><code>find</code> 和 <code>avoid</code> 可以接受多种类型的参数：</p>
<ul>
<li><p>如果参数类型是数字表示的是地址，即仿真管理器应当或不应当执行到的地址。</p>
</li>
<li><p>如果参数是一个回调函数（或者 <code>lambda</code> 表达式），则会根据函数的返回结果对当前探索的路径进行剪枝。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div></li>
</ul>

    </div>
  </div>

<p>当 <code>simgr.explore</code> 执行完之后所有能执行到目标地址的状态都会放到 <code>simgr.found</code> 列表中。</p>
<p>另外仿真管理器还提供了多种技术来防止路径探索过程中出现路径爆炸的问题。例如出自2014年的一篇论文 <a class="link"   target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/2927924" >Enhancing Symbolic Execution with Veritesting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 的路径归并算法：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在创建仿真管理器的时候指定开启 veritesting</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr = proj.factory.simgr(state, veritesting=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种方式，可以通过 use_technique 方法使用。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr.use_technique(angr.exploration_techniques.Veritesting())</span><br></pre></td></tr></table></figure></div>

<p>路径归并算法主要是结合了先前两种符号执行算法 <code>DSE</code>（动态符号执行）和 <code>SSE</code>（静态符号执行）的优缺点：</p>
<ul>
<li><strong>动态符号执行（DSE）</strong> ：DSE 在执行过程中针对每一条路径进行符号执行，能够精确模拟每个路径的执行。然而，当程序包含大量条件分支时，路径数量会呈指数级增长，导致路径爆炸的问题，这对计算资源造成很大的压力。</li>
<li><strong>静态符号执行（SSE）</strong> ：SSE 在静态分析阶段通过控制流图（CFG）来处理路径，通常能减少路径的数量，避免路径爆炸问题。然而，它在处理包含复杂系统调用、间接跳转或其他难以静态推理的语句时效果较差（很难用符号约束表示整个程序的逻辑）。</li>
</ul>
<p>Veritesting 算法结合了动态符号执行和静态符号执行的优势。当程序中遇到不适合静态分析的部分（如系统调用、间接跳转等），可以切换到静态符号执行；而对于可以精确分析的部分，则使用动态符号执行，从而提高了符号执行的效率和精度。同时 Veritesting 使用路径合并技术，将多个路径合并成一个路径，避免了 DSE 中路径数量爆炸的问题。通过合并路径，Veritesting 在保持精确度的同时，显著减少了需要处理的路径数量。当然具体的细节还得阅读论文。</p>
<p>另外根据官方的说法，Versitesting 通常与其他 exploration techniques 不兼容。</p>
<blockquote>
<p>Note that it frequenly doesn’t play nice with other techniques due to the invasive way it implements static symbolic execution.</p>
</blockquote>
<h4 id="函数-hook"><a href="#函数-hook" class="headerlink" title="函数 hook"></a>函数 hook</h4><p>仿真管理器在路径探索的过程中，可能因为某个函数导致路径爆炸。例如：</p>
<ul>
<li><p><strong>程序自身实现的函数</strong> ：例如字符串比较函数，在比较到不同字符时跳出循环。如果该函数被符号执行，那么每循环一次所有状态都会因为跳出和不跳出循环两种情况而“分裂”一次。</p>
</li>
<li><p><strong>静态链接的程序中调用的比较复杂的库函数</strong> ：例如 <code>malloc</code>。这些函数在静态链接的程序中无法自动 hook，因为 <code>angr</code> 默认只会自动 hook 动态链接的库函数。</p>
<blockquote>
<p>在 angr 中，动态链接的程序调用的库函数会被自动 hook 为 angr 自身实现的库函数，这样可以有效避免路径爆炸问题。但是对于静态链接的程序，即使有调试符号 angr 也不会去自动 hook 这些函数，从而可能导致路径爆炸的问题。</p>
</blockquote>
</li>
</ul>
<p>为了解决这一问题，我们需要对造成路径爆炸的函数进行 hook。<code>angr</code> 提供了两种主要的方式来 hook 函数：<code>proj.hook</code> 和 <code>SimProcedure</code>。</p>
<p><code>project.hook</code> 方法类似于二进制层面的 hook，即将指定位置的指定长度的二进制指令替换为调用我们自己实现的 Python 函数。具体来说，可以通过以下方式来 hook 掉对应的 <code>call</code> 指令：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project.hook(addr = call_insn_addr, hook = my_function, length = n)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>call_insn_addr</code></strong> ：被 hook 的 <code>call</code> 指令的地址。</li>
<li><strong><code>my_function</code></strong> ：我们自定义的 Python 函数。</li>
<li><strong><code>length</code></strong> ：<code>call</code> 指令的长度。</li>
</ul>
<p>其中我们的自定义函数应该接受 <code>state</code> 作为参数，我们可以通过操作 <code>state</code> 模拟该函数对程序执行状态造成的影响。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_hook_func</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="comment"># 执行自定义的操作，这里是一个示例</span></span><br><span class="line">    state.regs.eax = <span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line">proj.hook(addr = <span class="number">0x5678</span>, hook = my_hook_func, length = <span class="number">5</span>)</span><br></pre></td></tr></table></figure></div>

<p>另外 angr 还支持注解的方式进行 hook，下面这段代码与前面的代码等价：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@project.hook(<span class="params"><span class="number">0x5678</span>, length=<span class="number">5</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_hook_func</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="comment"># 执行自定义的操作，这里是一个示例</span></span><br><span class="line">    state.regs.eax = <span class="number">0xdeadbeef</span></span><br></pre></td></tr></table></figure></div>

<p><code>SimProcedure</code> 主要用于替换文件中的原有函数，例如 <code>angr</code> 默认会使用一些内置的 <code>SimProcedure</code> 来替换掉一些常见的库函数。在二进制程序中，像 <code>malloc</code> 这样的复杂库函数通常会被自动 hook，以避免路径爆炸和进行符号化分析。</p>
<p>如果我们已经有该二进制文件的符号表，我们可以直接使用 <code>project.hook_symbol(symbol_str, sim_procedure_instance)</code> 来自动 hook 掉文件中所有的对应符号，<code>run()</code> 方法的参数为被替换函数所接收的参数。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCheckEquals</span>(angr.SimProcedure):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, buffer_addr, length</span>):</span><br><span class="line">        buffer = <span class="variable language_">self</span>.state.memory.load(buffer_addr, length)</span><br><span class="line">        <span class="keyword">return</span> claripy.If(buffer == <span class="string">b&#x27;XCKPBIWXXTQAFOST&#x27;</span>, claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">proj.hook_symbol(symbol_name=<span class="string">&#x27;check_equals_XCKPBIWXXTQAFOST&#x27;</span>, simproc=MyCheckEquals())</span><br></pre></td></tr></table></figure></div>

<p>在 <code>SimProcedure</code> 的 <code>run()</code> 方法中，我们可以使用一些有用的成员函数来控制执行过程，例如：</p>
<ul>
<li><strong><code>ret(expr)</code></strong> ：返回一个表达式值。</li>
<li><strong><code>jump(addr)</code></strong> ：跳转到指定的地址。</li>
<li><strong><code>exit(code)</code></strong> ：终止程序执行，通常用于模拟程序退出。</li>
<li><strong><code>call(addr, args, continue_at)</code></strong> ：调用文件中的一个函数，<code>args</code> 是传递给函数的参数，<code>continue_at</code> 是继续执行的位置。</li>
<li><strong><code>inline_call(procedure, *args)</code></strong> ：内联地调用另一个 <code>SimProcedure</code>。</li>
</ul>
<p>这些成员函数使得我们可以更灵活地控制程序的模拟执行，尤其在处理复杂的系统调用、库函数和跳转时非常有用。</p>
<h4 id="符号求解"><a href="#符号求解" class="headerlink" title="符号求解"></a>符号求解</h4><p>在完成路径探索之后，如果目标位置可达，则我们可以从仿真管理器的 <code>found</code> 列表中找到执行到目标位置的所有路径对应的状态：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要求解的内容</span></span><br><span class="line">bvs_to_solve = claripy.BVS(<span class="string">&#x27;bvs_to_solve&#x27;</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建初始状态</span></span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">state.memory.store(<span class="number">0xdeadbeef</span>, bvs_to_solve)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 路径探索</span></span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find = <span class="number">0xbeefdead</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 found 列表中取出任意一个执行到目标位置的状态</span></span><br><span class="line">found = simgr.found[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></div>

<p><code>state</code> 中实际上内置了符号执行引擎 <code>claripy</code>，前面的路径探索本质上就是为每个 <code>state</code> 内置的符号执行引擎中添加对应的条件。当执行到目标位置时，<code>state</code> 中的符号执行引擎已经添加了能够执行目标位置所需的所有条件。因此我们可以利用符号执行引擎的约束求解功能（<code>state.solver</code>）求解出前面设置的需要求解的内容。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">found.solver.<span class="built_in">eval</span>(bvs_to_solve)</span><br></pre></td></tr></table></figure></div>

<p>如果是标准输入之类的则不需要我们显式的调用约束求解，直接获取即可：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<p>符号执行引擎不仅可以通过路径探索添加约束条件，还可以手动添加条件。因此在有些场景下我们不需要完整的执行整个过程，而是只执行前面一部分内容，而后的部分可以手动添加相应的规则。这种策略可以一定程度上避免一些路径爆炸的情况。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">found = simgr.found[<span class="number">0</span>]</span><br><span class="line">found.add_constraints(found.memory.load(buffer_addr, <span class="number">16</span>) == <span class="string">b&#x27;XCKPBIWXXTQAFOST&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(found.solver.<span class="built_in">eval</span>(password, cast_to=<span class="built_in">bytes</span>))</span><br></pre></td></tr></table></figure></div>

<h1 id="IdaPython"><a href="#IdaPython" class="headerlink" title="IdaPython"></a>IdaPython</h1><p><strong>IDAPython</strong> 是 IDA Pro （Interactive Disassembler）的一个插件，它为 IDA Pro 提供了 Python 脚本支持，使得用户能够使用 Python 来进行二进制分析、自动化任务、定制插件以及扩展 IDA Pro 的功能。IDAPython 提供了访问 IDA 内部数据结构、功能和 API 的能力，因此开发人员可以通过编写 Python 脚本来执行诸如代码分析、数据提取、自动化任务和图形化操作等任务。</p>
<p>IDAPython 的核心 API 基于 IDA 的 C++ API，用户可以通过 Python 来访问这些功能。</p>
<ul>
<li><p><strong>idaapi 类</strong> ：<code>idaapi</code> 是 IDAPython 的核心类，包含许多用于操作 IDA 的函数和数据结构。</p>
</li>
<li><p><strong>idc 类</strong> ：<code>idc</code> 类提供了更多面向用户的接口，通常用于处理汇编代码。</p>
</li>
<li><p><strong>ida_bytes 类</strong> ：<code>ida_bytes</code> 主要用于内存操作，提供了读取和写入内存的功能。</p>
</li>
<li><p><strong>ida_nalt 类</strong> ：<code>da_nalt</code> 主要用于符号表的操作，如获取、设置和删除符号。</p>
</li>
<li><p><strong>idautils 类</strong> ：高级实用的模块，主要是前面几种类的封装或者基于前面的类的 api 实现的常用功能。</p>
</li>
</ul>
<p><a class="link"   target="_blank" rel="noopener" href="https://python.docs.hex-rays.com/" >IdaPython 官方文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="切换-python-版本"><a href="#切换-python-版本" class="headerlink" title="切换 python 版本"></a>切换 python 版本</h3><p><strong>管理员权限</strong>运行 IDA 安装目录下的 <code>idapyswitch.exe</code> ，选择使用的 python 解释器。</p>
<h3 id="安装-IPyIDA-插件"><a href="#安装-IPyIDA-插件" class="headerlink" title="安装 IPyIDA 插件"></a>安装 IPyIDA 插件</h3><p><a class="link"   target="_blank" rel="noopener" href="https://github.com/eset/ipyida" >IPyIDA<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 是一个仅依赖 Python 的解决方案，用于将 IPython 控制台添加到 IDA Pro 中。通过使用 <code>&lt;Shift+&gt;</code>，你可以打开一个内嵌 Qt 控制台的窗口。这样你就可以享受到 IPython 的自动补全、在线帮助、等宽字体输入框、图表等功能。</p>
<p>IPyIDA 提供了一个安装脚本，可以自动从 IDA 控制台安装 IPyIDA 及其依赖项。只需将以下代码复制到 IDA 控制台中即可完成 IPyIDA 的安装：</p>
<ul>
<li><p>python2：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2; <span class="built_in">exec</span> urllib2.urlopen(<span class="string">&#x27;https://github.com/eset/ipyida/raw/stable/install_from_ida.py&#x27;</span>).read()</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>python3：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request; <span class="built_in">exec</span>(urllib.request.urlopen(<span class="string">&#x27;https://github.com/eset/ipyida/raw/stable/install_from_ida.py&#x27;</span>).read())</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>脚本将执行以下操作：</p>
<ol>
<li>如果尚未安装 <code>pip</code>，将安装 <code>pip</code>。</li>
<li>从 PyPi 安装 <code>ipyida</code> 包。</li>
<li>将 <code>ipyida_plugin_stub.py</code> 复制到用户的插件目录。</li>
<li>加载 IPyIDA 插件。</li>
</ol>
<p>另外 IPyIDA 也可以手动安装，用户只需要将 <a target="_blank" rel="noopener" href="https://github.com/eset/ipyida/blob/master/ipyida/ipyida_plugin_stub.py"><code>ipyida_plugin_stub.py</code></a> 和 <a target="_blank" rel="noopener" href="https://github.com/eset/ipyida/tree/master/ipyida"><code>ipyida</code></a> 目录复制到 IDA 的插件目录中即可。</p>
<p>手动安装需要用户自己管理依赖项和更新。IPyIDA 需要 <code>ipykernel</code> 和 <code>qtconsole</code> 包，并且如果使用 <code>ipykernel</code> 版本 5 或更高版本，还需要 <code>qasync</code> 包。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install ipykernel qtconsole</span><br><span class="line">pip install qasync</span><br></pre></td></tr></table></figure></div>

<h3 id="pycharm-自动补全"><a href="#pycharm-自动补全" class="headerlink" title="pycharm 自动补全"></a>pycharm 自动补全</h3><p>在 PyCharm 的<code>设置→项目→Python 解释器</code>点击设置选择<code>全部显示...</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/02/%E9%80%86%E5%90%91%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/images/image-20250206083959462.png"
                      alt="image-20250206083959462"
                ></p>
<p>点击<code>显示解释器路径</code>图标，然后在弹出的解释器路径对话框中添加 IdaPython 的 python 库路径。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/02/%E9%80%86%E5%90%91%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/images/image-20250206084626008.png"
                      alt="image-20250206084626008"
                ></p>
<p>旧版本的 IDA 的 python 库有 3 和 2 的区分，分别表示 Python3 和 Python2 对应的 python 库。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/02/%E9%80%86%E5%90%91%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/images/image-20250206084747455.png"
                      alt="image-20250206084747455"
                ></p>
<p>添加完 IdaPython 的代码库之后就可以使用 PyCharm 的自动补全功能了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/02/%E9%80%86%E5%90%91%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/images/image-20250206085043394.png"
                      alt="image-20250206085043394"
                ></p>
<h2 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="段相关"><a href="#段相关" class="headerlink" title="段相关"></a>段相关</h3><ul>
<li><code>idc.get_segm_name(addr)</code>：获取地址 <code>addr</code> 所在段的名字（参数为当前的地址）。</li>
<li><code>idc.get_segm_start(addr)</code>：获取地址 <code>addr</code> 所在段的开始地址</li>
<li><code>idc.get_segm_end(addr)</code>：获取地址 <code>addr</code> 所在段的结束地址</li>
<li><code>idc.get_first_seg()</code>：获取第一个段的地址</li>
<li><code>idc.get_next_seg(addr)</code>：获取地址大于 <code>addr</code> 的第一个段的起始地址</li>
<li><code>idautil.Segments()</code>：返回一个列表记录所有段的地址</li>
</ul>
<p>例如遍历所有的段：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> seg <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">    segname = idc.get_segm_name(seg)</span><br><span class="line">    segstart = idc.get_segm_start(seg)</span><br><span class="line">    segend = idc.get_segm_end(seg)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;段名：&quot;</span> + segname + <span class="string">&quot; 起始地址：&quot;</span> + <span class="built_in">hex</span>(segstart) + <span class="string">&quot; 结束地址：&quot;</span> + <span class="built_in">hex</span>(segend))</span><br></pre></td></tr></table></figure></div>

<h3 id="地址相关"><a href="#地址相关" class="headerlink" title="地址相关"></a>地址相关</h3><h4 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h4><ul>
<li><code>idautils.CodeRefsTo(ea, flow)</code>：获取引用 <code>ea</code> 地址处的代码的地址。<ul>
<li><strong>参数</strong>：<ul>
<li><code>ea</code>：被引用的代码的地址</li>
<li><code>flow</code>：表示代码顺序执行的是否计算在内（布尔值，0&#x2F;1 或 False&#x2F;True），比如如果 <code>flow = True</code> 那么认为当前指令的上一条指令引用了当前指令。</li>
</ul>
</li>
<li><strong>返回值</strong> ：代码引用列表（可能是空列表）</li>
</ul>
</li>
<li><code>idautils.CodeRefsFrom(ea, flow)</code>：<code>ea</code> 地址处的代码引用了何处的代码。<ul>
<li><strong>参数</strong>：<ul>
<li><code>ea</code>：查询的代码的地址</li>
<li><code>flow</code>：表示代码顺序执行的是否计算在内（布尔值，0&#x2F;1 或 False&#x2F;True），比如如果 <code>flow = True</code> 那么认为当前指令的下一条指令被当前指令引用。</li>
</ul>
</li>
<li><strong>返回值</strong> ：代码引用列表（可能是空列表）</li>
</ul>
</li>
<li><code>idautils.DataRefsTo(ea)</code>：获取引用 <code>ea</code> 地址处的内容的地址。</li>
<li><code>idautils.DataRefsFrom(ea)</code>：<code>ea</code> 地址处的数据引用了何处的数据。</li>
</ul>
<h4 id="符号地址-1"><a href="#符号地址-1" class="headerlink" title="符号地址"></a>符号地址</h4><ul>
<li><p><code>idc.get_name_ea_simple(name)</code>：获取名称对应的地址，如果获取不到则返回 <code>ida_idaapi.BADADDR</code> 。</p>
</li>
<li><p>获取符号在 got 表中的地址：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_got_addr</span>(<span class="params">symbol</span>):</span><br><span class="line">    <span class="comment"># 获取符号的地址</span></span><br><span class="line">    symbol_addr = idc.get_name_ea_simple(symbol)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果该地址不在 &#x27;extern&#x27; 段中，尝试获取对应的 __imp_ 符号地址</span></span><br><span class="line">    <span class="keyword">if</span> idc.get_segm_name(symbol_addr) != <span class="string">&#x27;extern&#x27;</span>:</span><br><span class="line">        symbol_addr = idc.get_name_ea_simple(<span class="string">f&#x27;__imp_<span class="subst">&#123;symbol&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确保符号地址在 &#x27;extern&#x27; 段中</span></span><br><span class="line">    <span class="keyword">assert</span> idc.get_segm_name(symbol_addr) == <span class="string">&#x27;extern&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 查找所有引用该符号地址的代码或数据引用</span></span><br><span class="line">    <span class="keyword">for</span> ref_addr <span class="keyword">in</span> (<span class="built_in">list</span>(idautils.CodeRefsTo(symbol_addr, <span class="literal">False</span>)) + <span class="built_in">list</span>(idautils.DataRefsTo(symbol_addr))):</span><br><span class="line">        <span class="comment"># 如果引用地址位于 .got 或 .got.plt 段中，返回该引用地址</span></span><br><span class="line">        <span class="keyword">if</span> idc.get_segm_name(ref_addr) <span class="keyword">in</span> [<span class="string">&#x27;.got&#x27;</span>, <span class="string">&#x27;.got.plt&#x27;</span>]:</span><br><span class="line">            <span class="keyword">return</span> ref_addr</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>获取符号在 plt 表中的地址：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_plt_addr</span>(<span class="params">symbol</span>):</span><br><span class="line">    <span class="comment"># 获取符号的 GOT 地址</span></span><br><span class="line">    <span class="keyword">for</span> ref_addr <span class="keyword">in</span> (<span class="built_in">list</span>(idautils.CodeRefsTo(get_got_addr(symbol), <span class="literal">False</span>)) + <span class="built_in">list</span>(idautils.DataRefsTo(get_got_addr(symbol)))):</span><br><span class="line">        <span class="comment"># 如果引用地址位于 .plt 或 .plt.got 段中，返回该函数的起始地址</span></span><br><span class="line">        <span class="keyword">if</span> idc.get_segm_name(ref_addr) <span class="keyword">in</span> [<span class="string">&#x27;.plt&#x27;</span>, <span class="string">&#x27;.plt.got&#x27;</span>]:</span><br><span class="line">            <span class="keyword">return</span> idaapi.get_func(ref_addr).start_ea</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h3><h4 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h4><ul>
<li><p><code>ida_bytes.get_wide_byte(addr)</code>：以 1 字节为单位获取地址处的值。</p>
</li>
<li><p><code>ida_bytes.patch_byte(addr, value)</code>：以 1 字节为单位修改地址处的值。</p>
</li>
<li><p><code>ida_bytes.get_wide_word(addr)</code>：以 2 字节为的单位获取地址处的值。</p>
</li>
<li><p><code>ida_bytes.patch_word(addr, value)</code>：以 2 字节为的单位修改地址处的值。</p>
</li>
<li><p><code>ida_bytes.get_wide_dword(addr)</code>：以 4 字节的单位获取地址处的值。</p>
</li>
<li><p><code>ida_bytes.patch_dword(addr, value)</code>：以 4 字节为的单位修改地址处的值。</p>
</li>
<li><p><code>ida_bytes.get_qword(addr)</code>：以 8 字节的单位获取地址处的值。</p>
</li>
<li><p><code>ida_bytes.patch_qword(addr, value)</code>：以 8 字节为的单位修改地址处的值。</p>
</li>
<li><p><code>idc.get_bytes(addr, len)</code>：获取 <code>addr</code> 地址处 <code>len</code> 长度的数据。</p>
</li>
<li><p><code>idc.patch_bytes(addr, data)</code>：在 <code>addr</code> 地址处写入 <code>data</code>（bytes 类型数据）。</p>
</li>
</ul>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul>
<li><code>idc.get_item_size(addr)</code>：获取 <code>addr</code> 地址处的数据大小，例如汇编指令长度。</li>
<li><code>idc.del_items(addr)</code>：去除目标地址处数据的属性。</li>
<li><code>idc.set_name(ea, name, flags=0)</code>： 为指定地址的对象设置或删除名称，并将名称添加到名称列表中。对象可以是任何类型（如指令、函数、数据字节、字符串、结构体等）。<strong>其中参数 <code>name</code> 如果是空字符串则表示删除名称。</strong></li>
<li><code>idc.create_insn(addr)</code>：将目标地址处的数据设置为代码。有可能会失败，可以与 <code>ida_name.set_name(addr, &#39;&#39;)</code> 配合来避免失败。</li>
</ul>
<h4 id="数据查找"><a href="#数据查找" class="headerlink" title="数据查找"></a>数据查找</h4><p>IdaPython 没有什么好用的数据查找的 API，因此通常搜索数据都是先将数据读出来然后手动搜索。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_bytes_in_segment</span>(<span class="params">segment_name, byte_sequence</span>):</span><br><span class="line">    <span class="comment"># 将目标字节序列转换为字节对象</span></span><br><span class="line">    target_bytes = <span class="built_in">bytearray</span>(byte_sequence)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取指定段的起始地址和结束地址</span></span><br><span class="line">    <span class="keyword">for</span> seg <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">        <span class="keyword">if</span> idaapi.get_segm_name(seg) == segment_name:</span><br><span class="line">            start_addr = idaapi.get_segm_start(seg)</span><br><span class="line">            end_addr = idaapi.get_segm_end(seg)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Segment <span class="subst">&#123;segment_name&#125;</span> not found&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取整个段的字节</span></span><br><span class="line">    segment_bytes = ida_bytes.get_bytes(start_addr, end_addr - start_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 find() 查找目标字节序列</span></span><br><span class="line">    results = []</span><br><span class="line">    pos = segment_bytes.find(target_bytes)</span><br><span class="line">    <span class="keyword">while</span> pos != -<span class="number">1</span>:</span><br><span class="line">        results.append(start_addr + pos)</span><br><span class="line">        pos = segment_bytes.find(target_bytes, pos + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：在 .text 段中查找字节序列</span></span><br><span class="line">byte_sequence = <span class="string">b&#x27;\x55\x48\x89\xe5&#x27;</span>  <span class="comment"># 比如这是一段x86_64的指令</span></span><br><span class="line">matches = find_bytes_in_segment(<span class="string">&#x27;.text&#x27;</span>, byte_sequence)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出匹配的地址</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> matches:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Found at address: <span class="subst">&#123;<span class="built_in">hex</span>(<span class="keyword">match</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h3><p>在 IdaPython 脚本中，字符串起到了非常关键的作用。例如通过字符串定位关键代码，或者通过字符串恢复函数符号等。因此这里单独介绍一下 IdaPython 中字符串相关的功能。</p>
<h4 id="字符串提取"><a href="#字符串提取" class="headerlink" title="字符串提取"></a>字符串提取</h4><p>字符串获取主要有 <code>idautils.Strings</code> 和 <code>idc.get_strlit_contents</code>两种方式。</p>
<h5 id="idautils-Strings"><a href="#idautils-Strings" class="headerlink" title="idautils.Strings"></a>idautils.Strings</h5><p><code>idautils.Strings()</code> 是一个非常常用的 API，它会自动识别和遍历整个二进制文件中的所有字符串，得到一个 <code>Strings</code> 对象。</p>
<p><code>Strings</code> 对象支持下标访问，得到的结果是一个 <code>StringItem</code> 对象，该对象有如下属性：</p>
<ul>
<li><code>ea</code>：字符串的地址。</li>
<li><code>strtype</code>：字符串类型，有下面几种常见类型：<ul>
<li><strong><code>STRTYPE_TERMCHR</code></strong> ：字符终止的字符串，字符串以特定字符结束。</li>
<li><strong><code>STRTYPE_C</code></strong> ：C 风格字符串（零终止）。</li>
<li><strong><code>STRTYPE_C_16</code></strong> ：16 位字符的 C 风格字符串（零终止）。</li>
<li><strong><code>STRTYPE_C_32</code></strong> ：32 位字符的 C 风格字符串（零终止）。</li>
<li><strong><code>STRTYPE_PASCAL</code></strong> ：Pascal 风格的字符串，带一个字节长度前缀。</li>
<li><strong><code>STRTYPE_PASCAL_16</code></strong> ：Pascal 风格的 16 位字符字符串，带一个字节长度前缀。</li>
<li><strong><code>STRTYPE_LEN2</code></strong> ：Pascal 风格的字符串，带两个字节的长度前缀。</li>
<li><strong><code>STRTYPE_LEN2_16</code></strong> ：Pascal 风格的 16 位字符字符串，带两个字节的长度前缀。</li>
<li><strong><code>STRTYPE_LEN4</code></strong> ：Pascal 风格的字符串，带四个字节的长度前缀。</li>
<li><strong><code>STRTYPE_LEN4_16</code></strong> ：Pascal 风格的 16 位字符字符串，带四个字节的长度前缀。</li>
</ul>
</li>
<li><code>length</code>：字符串长度。</li>
</ul>
<p>另外我们可以通过 <code>str()</code> 将 <code>StringItem</code> 对象对象强制转换为字符串形式。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> idautils</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = idautils.Strings()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(s[<span class="number">0</span>])</span><br><span class="line"><span class="string">&#x27;/lib64/ld-linux-x86-64.so.2&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>].ea</span><br><span class="line"><span class="number">0x318</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>].length</span><br><span class="line"><span class="number">0x1c</span></span><br></pre></td></tr></table></figure></div>

<h5 id="idc-get-strlit-contents"><a href="#idc-get-strlit-contents" class="headerlink" title="idc.get_strlit_contents"></a>idc.get_strlit_contents</h5><p><code>idc.get_strlit_contents</code> 主要用于从指定地址提取字符串：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_strlit_contents</span>(<span class="params">ea, length = -<span class="number">1</span>, strtype = STRTYPE_C</span>):</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>参数</strong>：<ul>
<li><code>ea</code>：字符串起始地址。</li>
<li><code>length</code>：字符串长度。默认是 -1，此时 IDA 会计算最大字符串长度。</li>
<li><code>strtype</code>：字符串类型，使用 <code>STRTYPE_*</code> 常量。</li>
</ul>
</li>
<li><strong>返回值</strong> ：返回字符串内容。如果在指定的地址无法找到有效的字符串，或者字符串内容为空，则返回空字符串。</li>
</ul>
<h4 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h4><p>我们可以通过 <code>idautils.Strings()</code> 构建出程序的字符串表，之后就可以在这个表中查询字符串的地址。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 defaultdict 直接管理字符串缓存</span></span><br><span class="line">string_cache = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_string</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在缓存的字符串表中查找指定字符串的地址</span></span><br><span class="line"><span class="string">    :param string: 要查找的字符串</span></span><br><span class="line"><span class="string">    :return: 字符串的地址列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 如果缓存为空，则初始化缓存</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> string_cache:</span><br><span class="line">        <span class="keyword">for</span> string_info <span class="keyword">in</span> idautils.Strings():</span><br><span class="line">            string_cache[<span class="built_in">hash</span>(<span class="built_in">str</span>(string_info))].append(string_info.ea)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回匹配的地址列表，如果没有找到则返回空列表</span></span><br><span class="line">    <span class="keyword">return</span> string_cache.get(<span class="built_in">hash</span>(string), [])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：查找字符串</span></span><br><span class="line">address_list = find_string(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> address_list:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;String found at addresses: <span class="subst">&#123;address_list&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;String not found.&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<h4 id="字符串创建"><a href="#字符串创建" class="headerlink" title="字符串创建"></a>字符串创建</h4><p><code>idc.create_strlit</code> 可以在指定地址创建字符串（字符串类型由 <code>get_inf_attr(INF_STRTYPE)</code> 的值决定）：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_strlit</span>(<span class="params">ea, endea</span>):</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>参数</strong>：<ul>
<li><code>ea</code>：字符串起始地址。</li>
<li><code>endea</code>：字符串的结束地址（不包括该地址）。如果 <code>endea == BADADDR</code> 则 IDA 会计算最大字符串长度。</li>
</ul>
</li>
<li><strong>返回值</strong> ：返回 1 表示成功，0 表示失败。</li>
</ul>
<h3 id="汇编指令相关"><a href="#汇编指令相关" class="headerlink" title="汇编指令相关"></a>汇编指令相关</h3><p>IdaPython 内置了汇编指令相关的 API，但是 IDA 的汇编与主流的汇编库 Keystone 和 Capstone 不通用，进而导致与主流的二进制相关库不兼容。</p>
<p>因此我们通常只是使用 IdaPython 的部分汇编指令功能（主要是获取指令地址和长度），而实际的汇编和反汇编操作主要还是通过 keystone 和 Capstone 实现。</p>
<ul>
<li><p><code>idc.GetDisasm(addr)</code> 或 <code>idc.generate_disasm_line(addr,flags)</code>：获取地址处的汇编语句，这里 <code>flags</code> 通常为 0 。</p>
</li>
<li><p><code>idc.print_operand(addr,index)</code>：获取指定地址 <code>addr</code> 的汇编指令的第 <code>index</code> 个操作数（字符串形式），如果 <code>index</code> 索引超过操作数的个数则返回空字符串。下面简单举几个例子感受一下：</p>
<table>
<thead>
<tr>
<th align="left">汇编</th>
<th align="left">inxex &#x3D; 0</th>
<th align="left">index &#x3D; 1</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>pop rax</code></td>
<td align="left"><code>rax</code></td>
<td align="left">‘’</td>
</tr>
<tr>
<td align="left"><code>mov [rsp+10h], rax</code></td>
<td align="left"><code>[rsp+10h]</code></td>
<td align="left"><code>rax</code></td>
</tr>
<tr>
<td align="left"><code>call $+5</code></td>
<td align="left"><code>$+5</code></td>
<td align="left">‘’</td>
</tr>
<tr>
<td align="left"><code>add rax, 68FBh</code></td>
<td align="left"><code>rax</code></td>
<td align="left"><code>68FBh</code></td>
</tr>
<tr>
<td align="left"><code>jz short loc_1400100CC</code></td>
<td align="left"><code>loc_1400100CC</code></td>
<td align="left">‘’</td>
</tr>
<tr>
<td align="left"><code>popfq</code></td>
<td align="left">‘’</td>
<td align="left">‘’</td>
</tr>
<tr>
<td align="left"><code>retn</code></td>
<td align="left">‘’</td>
<td align="left">‘’</td>
</tr>
</tbody></table>
</li>
<li><p><code>idc.get_operand_type(addr, index)</code>：获取操作数的类型。</p>
<ul>
<li><code>o_void (0)</code>：无效操作数，表示没有操作数。</li>
<li><code>o_reg (1)</code>：寄存器操作数，表示一个寄存器。</li>
<li><code>o_mem (2)</code>：内存操作数，表示一个内存地址。</li>
<li><code>o_phrase (3)</code>：短语操作数，表示根据寄存器和偏移量计算的内存地址。</li>
<li><code>o_displ (4)</code>：带偏移量的内存操作数，表示根据寄存器、偏移量和可选标志寄存器计算的内存地址。</li>
<li><code>o_imm (5)</code>：立即数操作数，表示一个立即数值。</li>
<li><code>o_far (6)</code>：远跳转操作数，表示一个远跳转地址。</li>
<li><code>o_near (7)</code>：相对跳转操作数，表示一个相对于当前指令地址的跳转地址。</li>
</ul>
</li>
<li><p><code>idc.get_operand_value(addr, index)</code>：获取指定索引操作数中的值。</p>
<ul>
<li>对于寄存器操作数 (<code>o_reg</code>)，返回寄存器的编号。</li>
<li>对于内存操作数 (<code>o_mem</code>)，返回内存地址的值。</li>
<li>对于立即数操作数 (<code>o_imm</code>)，返回立即数的值。</li>
<li>对于相对跳转操作数 (<code>o_near</code>)，返回跳转的地址。</li>
<li>对于其他特定于处理器的操作数类型，返回相应的值，具体含义需要参考相关文档。</li>
</ul>
</li>
<li><p><code>idc.print_insn_mnem(addr)</code>：获取指定地址 <code>addr</code> 的汇编指令的操作指令（如 <code>mov</code>、<code>add</code>）。</p>
</li>
<li><p><code>idc.next_head(addr)</code>：获取当前地址的汇编的下一条汇编的地址。</p>
</li>
<li><p><code>idc.prev_head(addr)</code>：获取当前地址的汇编的上一条汇编的地址。</p>
</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> ida_ida</span><br><span class="line"><span class="keyword">from</span> keystone <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> idc.get_inf_attr(idc.INF_PROCNAME) == <span class="string">&#x27;metapc&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> idc.get_inf_attr(idc.INF_LFLAGS) &amp; ida_ida.LFLG_64BIT:</span><br><span class="line">        ks = Ks(KS_ARCH_X86, KS_MODE_64)</span><br><span class="line">        cs = Cs(CS_ARCH_X86, CS_MODE_64)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ks = Ks(KS_ARCH_X86, KS_MODE_32)</span><br><span class="line">        cs = Cs(CS_ARCH_X86, CS_MODE_32)</span><br><span class="line"><span class="keyword">elif</span> idc.get_inf_attr(idc.INF_PROCNAME) == <span class="string">&#x27;ARM&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> idc.get_inf_attr(idc.INF_LFLAGS) &amp; ida_ida.LFLG_64BIT:</span><br><span class="line">        ks = Ks(KS_ARCH_ARM64, KS_MODE_ARM)</span><br><span class="line">        cs = Cs(CS_ARCH_ARM64, CS_MODE_ARM)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ks = Ks(KS_ARCH_ARM, KS_MODE_THUMB)</span><br><span class="line">        cs = Cs(CS_ARCH_ARM64, CS_MODE_THUMB)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">f&quot;unsport arch&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_disasm</span>(<span class="params">addr</span>):</span><br><span class="line">    insn = <span class="built_in">next</span>(cs.disasm(idc.get_bytes(addr, idc.get_item_size(addr)), addr))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;insn.address:#x&#125;</span>: <span class="subst">&#123;insn.mnemonic&#125;</span> <span class="subst">&#123;insn.op_str&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> insn</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">asm</span>(<span class="params">asm_code, addr=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(ks.asm(asm_code, addr)[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></div>

<h3 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h3><ul>
<li><p><code>ida_funcs.FuncItems(start)</code>：<code>FuncItems</code> 函数接收一个函数起始地址，并返回一个迭代器，允许你遍历并打印函数内部的每条汇编的地址。</p>
</li>
<li><p><code>idautils.Functions(startaddr,endaddr)</code>：获取指定地址之间的所有函数</p>
</li>
<li><p><code>idc.get_func_name(addr)</code>：获取指定地址所在函数的函数名</p>
</li>
<li><p><code>get_func_cmt(addr, repeatable)</code>：获取函数的注释</p>
<ul>
<li><code>repeatable</code>：0 是获取常规注释，1 是获取重复注释。</li>
</ul>
</li>
<li><p><code>idc.set_func_cmt(ea, cmt, repeatable)</code>：设置函数注释</p>
</li>
<li><p><code>idc.find_func_end(ea)</code>：寻找函数结尾，如果函数存在则返回结尾地址，否则返回 <code>BADADDR</code> 。</p>
</li>
<li><p><code>ida_funcs.set_func_end(addr,  newend)</code>：设置函数结尾为 <code>newend</code></p>
</li>
<li><p><code>ida_funcs.set_func_start(addr,  newstart)</code>：设置函数开头为 <code>newstart</code></p>
</li>
<li><p><code>ida_funcs.get_func(addr).start_ea</code>：获取 <code>addr</code> 所在函数的地址</p>
</li>
<li><p><code>idc.get_prev_func(addr)</code>：获取 <code>addr</code> 所在函数的前一个函数的地址</p>
</li>
<li><p><code>idc.get_next_func(addr)</code>：获取 <code>addr</code> 所在函数的后一个函数的地址</p>
</li>
<li><p><code>ida_funcs.add_func(addr)</code>：在 <code>addr</code> 地址创建函数</p>
</li>
<li><p><code>idaapi.FlowChart(func)</code>：接受一个函数对象，返回这个函数所有的代码块。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_basic_block</span>(<span class="params">address</span>):</span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> idaapi.FlowChart(idaapi.get_func(address)):</span><br><span class="line">        <span class="keyword">if</span> block.start_ea &lt;= address &lt; block.end_ea:</span><br><span class="line">            <span class="keyword">return</span> block</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prev_call</span>(<span class="params">addr</span>):</span><br><span class="line">    addr = idc.prev_head(addr)</span><br><span class="line">    block = get_basic_block(addr)</span><br><span class="line">    <span class="keyword">while</span> addr &gt;= block.start_ea:</span><br><span class="line">        <span class="keyword">if</span> arch_ctx.is_call(<span class="built_in">next</span>(arch_ctx.cs.disasm(ida_bytes.get_bytes(addr, idc.get_item_size(addr)), addr))):</span><br><span class="line">            <span class="keyword">return</span> addr</span><br><span class="line">        addr = idc.prev_head(addr)</span><br><span class="line">    <span class="keyword">return</span> block.start_ea</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">next_call</span>(<span class="params">addr</span>):</span><br><span class="line">    addr = idc.next_head(addr)</span><br><span class="line">    block = get_basic_block(addr)</span><br><span class="line">    <span class="keyword">while</span> addr &lt; block.end_ea:</span><br><span class="line">        <span class="keyword">if</span> arch_ctx.is_call(<span class="built_in">next</span>(arch_ctx.cs.disasm(ida_bytes.get_bytes(addr, idc.get_item_size(addr)), addr))):</span><br><span class="line">            <span class="keyword">return</span> addr</span><br><span class="line">        addr = idc.next_head(addr)</span><br><span class="line">    <span class="keyword">return</span> block.end_ea</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="常用脚本"><a href="#常用脚本" class="headerlink" title="常用脚本"></a>常用脚本</h2><h3 id="全局符号错误修复"><a href="#全局符号错误修复" class="headerlink" title="全局符号错误修复"></a>全局符号错误修复</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/02/%E9%80%86%E5%90%91%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/images/c535ebdc-9440-4019-8bbe-580daa4842bf.png"
                      alt="c535ebdc-9440-4019-8bbe-580daa4842bf"
                ></p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> ida_segment</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">data_seg = <span class="built_in">range</span>(ida_segment.get_segm_by_name(<span class="string">&quot;.data&quot;</span>).start_ea, ida_segment.get_segm_by_name(<span class="string">&quot;.data&quot;</span>).end_ea)</span><br><span class="line">rodata_seg = <span class="built_in">range</span>(ida_segment.get_segm_by_name(<span class="string">&quot;.rodata&quot;</span>).start_ea, ida_segment.get_segm_by_name(<span class="string">&quot;.rodata&quot;</span>).end_ea)</span><br><span class="line">text_seg = <span class="built_in">range</span>(ida_segment.get_segm_by_name(<span class="string">&quot;.text&quot;</span>).start_ea, ida_segment.get_segm_by_name(<span class="string">&quot;.text&quot;</span>).end_ea)</span><br><span class="line">got_plt_base = ida_segment.get_segm_by_name(<span class="string">&quot;.got.plt&quot;</span>).start_ea</span><br><span class="line"></span><br><span class="line">start_ea = text_seg.start</span><br><span class="line">end_ea = text_seg.stop</span><br><span class="line"></span><br><span class="line">ea = start_ea</span><br><span class="line"><span class="keyword">while</span> ea &lt; end_ea:</span><br><span class="line">    <span class="keyword">if</span> idc.print_insn_mnem(ea) == <span class="string">&#x27;lea&#x27;</span>:</span><br><span class="line">        sym_addr = ctypes.c_int64(idc.get_operand_value(ea, <span class="number">1</span>)).value + got_plt_base</span><br><span class="line">        <span class="keyword">if</span> sym_addr <span class="keyword">in</span> data_seg <span class="keyword">or</span> sym_addr <span class="keyword">in</span> rodata_seg <span class="keyword">or</span> sym_addr <span class="keyword">in</span> text_seg:</span><br><span class="line">            idc.op_plain_offset(ea, <span class="number">1</span>, got_plt_base)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%08x: %s&quot;</span> % (ea, idc.generate_disasm_line(ea, <span class="number">0</span>)))</span><br><span class="line">    ea = idc.next_head(ea)</span><br></pre></td></tr></table></figure></div>

<h3 id="修复函数参数"><a href="#修复函数参数" class="headerlink" title="修复函数参数"></a>修复函数参数</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func_ea <span class="keyword">in</span> idautils.Functions():</span><br><span class="line">    tif = idaapi.tinfo_t()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> idaapi.get_tinfo(tif, func_ea):</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 无法获取类型信息，跳过</span></span><br><span class="line"></span><br><span class="line">    func_type = idaapi.func_type_data_t()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tif.get_func_details(func_type):</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 无法获取函数详细信息，跳过</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 统计 double 类型参数的数量</span></span><br><span class="line">    double_param_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> func_type:</span><br><span class="line">        <span class="keyword">if</span> arg.<span class="built_in">type</span>.is_double():</span><br><span class="line">            double_param_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> double_param_count &lt;= <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 如果 double 参数数量不超过 4 个，跳过</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建新的函数类型数据，去除 double 参数</span></span><br><span class="line">    new_func_type = idaapi.func_type_data_t()</span><br><span class="line">    new_func_type.cc = func_type.cc</span><br><span class="line">    new_func_type.rettype = func_type.rettype</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> func_type:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arg.<span class="built_in">type</span>.is_double():</span><br><span class="line">            new_func_type.push_back(arg)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 应用新的函数类型信息</span></span><br><span class="line">    new_tif = idaapi.tinfo_t()</span><br><span class="line">    new_tif.create_func(new_func_type)</span><br><span class="line">    idaapi.apply_tinfo(func_ea, new_tif, idaapi.TINFO_DEFINITE)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;已更新函数 <span class="subst">&#123;idc.get_func_name(func_ea)&#125;</span> 的原型，删除了 <span class="subst">&#123;double_param_count&#125;</span> 个 double 参数。&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<h1 id="Unicorn"><a href="#Unicorn" class="headerlink" title="Unicorn"></a>Unicorn</h1><p><strong>Unicorn</strong> 是一个轻量级、跨平台的开源模拟器（Emulator），可以用于模拟不同架构的程序执行。它基于 QEMU 项目，但比 QEMU 更加轻量和易于使用，主要面向动态分析、漏洞挖掘和逆向工程等领域。Unicorn 允许开发者模拟目标平台的指令集架构（ISA），并且能够执行二进制代码，模拟程序运行时的行为，捕捉寄存器、内存等状态。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.unicorn-engine.org/docs/tutorial.html" >Unicorn 官方文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="Unicorn-安装"><a href="#Unicorn-安装" class="headerlink" title="Unicorn 安装"></a>Unicorn 安装</h2><p>可以通过 Python 的包管理工具 <code>pip</code> 安装：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install unicorn</span><br></pre></td></tr></table></figure></div>

<h2 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="创建-Unicorn-对象"><a href="#创建-Unicorn-对象" class="headerlink" title="创建 Unicorn 对象"></a>创建 Unicorn 对象</h3><p>和前面提到的 Keystone 和 Capstone 的流程类似，Unicorn 模拟执行首先需要创建一个 Unicorn 对象，并设置目标架构和模式。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># X86-64</span></span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br><span class="line">mu = Uc(UC_ARCH_X86, UC_MODE_64)</span><br><span class="line">mu.mem_map(<span class="number">0</span>, <span class="number">0x1000</span>) <span class="comment"># 避免异常 &quot;mov rax, gs:[0x28]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ARM</span></span><br><span class="line"><span class="keyword">from</span> unicorn.arm_const <span class="keyword">import</span> *</span><br><span class="line">mu = Uc(UC_ARCH_ARM, UC_MODE_THUMB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># AARCH64</span></span><br><span class="line"><span class="keyword">from</span> unicorn.arm64_const <span class="keyword">import</span> *</span><br><span class="line">mu = Uc(UC_ARCH_ARM64, UC_MODE_ARM)</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>在模拟 x86 架构时，程序可能会访问特定段（如 <code>gs</code> 或 <code>fs</code>）中的数据，这些数据通常与操作系统、线程信息、TLS（线程局部存储）等有关（例如 <code>mov rax, gs:[0x28]</code> 指令获取 canary）。</p>
<p>由于 Unicorn 模拟器仅提供模拟功能，导致像 <code>fs</code>、<code>gs</code> 这样的段寄存器都被默认初始化为 0，因此访问这些段中数据的指令会触发程序内存读写异常。</p>
<p>为了避免这种情况影响程序模拟执行，最好在 0 地址处映射一段内存。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mu.mem_map(<span class="number">0</span>, <span class="number">0x1000</span>) <span class="comment"># 避免异常 &quot;mov rax, gs:[0x28]&quot;</span></span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h3 id="寄存器操作"><a href="#寄存器操作" class="headerlink" title="寄存器操作"></a>寄存器操作</h3><p>Unicorn 允许你模拟寄存器的读写操作，你可以通过 <code>mu.reg_write()</code> 来写入寄存器的值，使用 <code>mu.reg_read()</code> 来读取寄存器的值。</p>
<h4 id="写入寄存器"><a href="#写入寄存器" class="headerlink" title="写入寄存器"></a>写入寄存器</h4><p><code>mu.reg_write(reg_id, value)</code> 用来写入寄存器的值，<code>reg_id</code> 是寄存器的标识符，<code>value</code> 是要写入的值。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>一些特殊的寄存器如 <code>gs</code> 寄存器不能直接通过 <code>reg_write</code> 修改。</p>

    </div>
  </div>

<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mu.reg_write(UC_X86_REG_RIP, <span class="number">0x1000</span>)  <span class="comment"># 设置 RIP 寄存器的值</span></span><br></pre></td></tr></table></figure></div>

<h4 id="读取寄存器"><a href="#读取寄存器" class="headerlink" title="读取寄存器"></a>读取寄存器</h4><p><code>mu.reg_read(reg_id)</code> 返回指定寄存器的当前值。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rip_value = mu.reg_read(UC_X86_REG_RIP)  <span class="comment"># 读取 RIP 寄存器的值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;RIP: <span class="subst">&#123;rip_value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h3><p>Unicorn 允许你模拟内存的读写操作，模拟程序运行时的内存访问。你可以通过 <code>mu.mem_map()</code> 来映射内存区域，通过 <code>mu.mem_write()</code> 来写入数据，通过 <code>mu.mem_read()</code> 来读取内存数据。</p>
<h4 id="映射内存"><a href="#映射内存" class="headerlink" title="映射内存"></a>映射内存</h4><p><code>mu.mem_map(start, size)</code> 用来映射一段内存区域，<code>start</code> 是内存起始地址，<code>size</code> 是内存的大小。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li><code>start</code> 和 <code>end</code> 要关于 0x1000 对齐。</li>
<li>要确保映射的内存地址空间不要与之前映射的内存出现重叠。</li>
</ul>

    </div>
  </div>

<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mu.mem_map(<span class="number">0x1000</span>, <span class="number">0x1000</span>)  <span class="comment"># 映射 0x1000 大小的内存</span></span><br></pre></td></tr></table></figure></div>

<h4 id="写入内存"><a href="#写入内存" class="headerlink" title="写入内存"></a>写入内存</h4><p><code>mu.mem_write(addr, data)</code> 将数据写入指定地址的内存区域。<code>data</code> 是二进制数据（字节串），<code>addr</code> 是写入的地址。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code = <span class="string">b&quot;\x48\x31\xc0&quot;</span>  <span class="comment"># x86_64: xor rax, rax</span></span><br><span class="line">mu.mem_write(<span class="number">0x1000</span>, code)  <span class="comment"># 将机器码写入模拟内存</span></span><br></pre></td></tr></table></figure></div>

<h4 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h4><p><code>mu.mem_read(addr, size)</code> 从指定地址读取 <code>size</code> 字节的数据。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = mu.mem_read(<span class="number">0x1000</span>, <span class="number">4</span>)  <span class="comment"># 从地址 0x1000 读取 4 字节</span></span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure></div>

<h4 id="加载二进制程序"><a href="#加载二进制程序" class="headerlink" title="加载二进制程序"></a>加载二进制程序</h4><p>实际情况下我们可能需要模拟执行一个二进制程序中的某个解密算法函数。与 shellcode 不同，在二进制程序中即使一个纯算法函数也不是只加载代码段就可以正常仿真的，因为这个函数在执行过程中还可能访问全局变量。因此我们需要想办法将这个二进制程序加载到内存中，因此通常 Unicorn 还要配合 angr 的静态分析功能使用。</p>
<p>下面这段代码是加载二进制到 Unicorn 中的模板，可以应对大多数情况。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <ul>
<li>这个模板的段映射部分写的很奇怪，这是因为有的二进制程序（比如一些 Linux 内核镜像）的段并不是关于 0x1000 对齐，但是 Unicorn 的 <code>mem_map</code> 要求地址范围按 0x1000 对齐，并且不能与之前映射的内存重叠。因此这里要做内存对齐处理并且多次捕获异常。</li>
<li>x86 架构设置 <code>bp</code> 寄存器是因为有的函数会通过 <code>bp</code> 寄存器访问函数的参数和局部变量。</li>
<li>为了实现代码复用，通常的做法是把每个架构相关的操作抽象为接口类，然后每个架构实现这个接口类，而真正的核心逻辑不需要关注架构的细节。下面的模板就是遵循这一设计原则。</li>
</ul>

    </div>
  </div>

<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 amd64 架构的上下文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">amd64_ctx</span>:</span><br><span class="line">    <span class="comment"># 架构寄存器映射</span></span><br><span class="line">    regs = &#123;</span><br><span class="line">        <span class="string">&#x27;sp&#x27;</span>: UC_X86_REG_RSP,  <span class="comment"># 堆栈指针寄存器（RSP）</span></span><br><span class="line">        <span class="string">&#x27;bp&#x27;</span>: UC_X86_REG_RBP,  <span class="comment"># 基指针寄存器（RBP）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_emu</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建并返回一个 X86-64 架构的模拟器对象</span></span><br><span class="line">        emu = Uc(UC_ARCH_X86, UC_MODE_64)</span><br><span class="line">        emu.mem_map(<span class="number">0</span>, <span class="number">0x1000</span>)  <span class="comment"># 映射内存，以避免访问 gs 或 fs 时发生异常</span></span><br><span class="line">        <span class="keyword">return</span> emu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 ARM 架构的上下文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">arm_ctx</span>:</span><br><span class="line">    <span class="comment"># 架构寄存器映射</span></span><br><span class="line">    regs = &#123;</span><br><span class="line">        <span class="string">&#x27;sp&#x27;</span>: UC_ARM_REG_SP,  <span class="comment"># 堆栈指针寄存器（SP）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_emu</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建并返回一个 ARM 架构的模拟器对象（使用 THUMB 模式）</span></span><br><span class="line">        <span class="keyword">return</span> Uc(UC_ARCH_ARM, UC_MODE_THUMB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 AARCH64 架构的上下文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">aarch64_ctx</span>:</span><br><span class="line">    <span class="comment"># 架构寄存器映射</span></span><br><span class="line">    regs = &#123;</span><br><span class="line">        <span class="string">&#x27;sp&#x27;</span>: UC_ARM64_REG_SP,  <span class="comment"># 堆栈指针寄存器（SP）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_emu</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建并返回一个 AARCH64 架构的模拟器对象（使用 ARM 模式）</span></span><br><span class="line">        <span class="keyword">return</span> Uc(UC_ARCH_ARM64, UC_MODE_ARM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 angr 项目，加载目标二进制文件，禁用自动加载库</span></span><br><span class="line">project = angr.Project(binary, load_options=&#123;<span class="string">&#x27;auto_load_libs&#x27;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据架构类型选择对应的上下文对象</span></span><br><span class="line"><span class="keyword">if</span> project.arch.name == <span class="string">&quot;ARMEL&quot;</span>:</span><br><span class="line">    arch_ctx = arm_ctx()</span><br><span class="line"><span class="keyword">elif</span> project.arch.name == <span class="string">&quot;AMD64&quot;</span>:</span><br><span class="line">    arch_ctx = amd64_ctx()</span><br><span class="line"><span class="keyword">elif</span> project.arch.name == <span class="string">&quot;AARCH64&quot;</span>:</span><br><span class="line">    arch_ctx = aarch64_ctx()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 如果不支持的架构，抛出异常</span></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;Unsupported architecture&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取模拟器对象</span></span><br><span class="line">emu = arch_ctx.get_emu()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置堆栈地址和大小</span></span><br><span class="line">STACK_ADDRESS = <span class="number">0x1234000</span></span><br><span class="line">STACK_SIZE = <span class="number">0x3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为堆栈区域映射内存</span></span><br><span class="line">emu.mem_map(STACK_ADDRESS, STACK_SIZE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置堆栈指针（SP）寄存器</span></span><br><span class="line">emu.reg_write(arch_ctx.regs[<span class="string">&#x27;sp&#x27;</span>], STACK_ADDRESS + STACK_SIZE - <span class="number">0x1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有基指针（BP）寄存器，设置 BP 寄存器</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;bp&#x27;</span> <span class="keyword">in</span> arch_ctx.regs:</span><br><span class="line">    emu.reg_write(arch_ctx.regs[<span class="string">&#x27;bp&#x27;</span>], STACK_ADDRESS + STACK_SIZE - <span class="number">0x1000</span> + <span class="number">0x300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 映射二进制文件的各个段到模拟器内存</span></span><br><span class="line"><span class="keyword">for</span> seg <span class="keyword">in</span> project.loader.main_object.segments:</span><br><span class="line">    <span class="comment"># 计算段的起始地址和结束地址（对齐到页面边界）</span></span><br><span class="line">    mem_start = seg.vaddr &amp; ~<span class="number">0xFFF</span></span><br><span class="line">    mem_end = (seg.vaddr + seg.memsize + <span class="number">0xFFF</span>) &amp; ~<span class="number">0xFFF</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 映射内存区域</span></span><br><span class="line">        emu.mem_map(mem_start, mem_end - mem_start)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 如果映射失败，尝试重新计算起始地址</span></span><br><span class="line">        mem_start = (seg.vaddr + <span class="number">0xFFF</span>) &amp; ~<span class="number">0xFFF</span></span><br><span class="line">        <span class="keyword">if</span> mem_start &lt; mem_end <span class="keyword">and</span> mem_start:</span><br><span class="line">            emu.mem_map(mem_start, mem_end - mem_start)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将段的内容写入模拟器内存</span></span><br><span class="line">    emu.mem_write(seg.vaddr, project.loader.memory.load(seg.vaddr, seg.filesize))</span><br></pre></td></tr></table></figure></div>

<h3 id="模拟执行"><a href="#模拟执行" class="headerlink" title="模拟执行"></a>模拟执行</h3><h4 id="虚拟机启动"><a href="#虚拟机启动" class="headerlink" title="虚拟机启动"></a>虚拟机启动</h4><p>当前期虚拟机初始化完成之后（主要是程序加载、栈初始化、寄存器设置等），就可以启动虚拟机进行模拟了。虚拟机通过 <code>emu_start</code> 函数启动，该函数定义如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">emu_start</span>(<span class="params">self, begin: <span class="built_in">int</span>, until: <span class="built_in">int</span>, timeout: <span class="built_in">int</span>=<span class="number">0</span>, count: <span class="built_in">int</span>=<span class="number">0</span></span>) -&gt; <span class="literal">None</span>:</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>begin</code></strong> ：仿真开始的地址。表示从该地址开始执行机器码，通常是程序的入口点。</li>
<li><strong><code>until</code></strong> ：仿真结束的地址。表示程序执行到该地址时仿真停止。<code>until</code> 应大于 <code>begin</code>，否则可能导致仿真无限执行。</li>
<li><strong><code>timeout</code></strong> ：超时设置（单位：毫秒）。在仿真执行过程中，如果超时值非零，仿真会在超时后自动停止。如果设置为 0，表示不限制时间。</li>
<li><strong><code>count</code></strong> ：执行次数。如果 <code>count</code> 非零，仿真会执行指定的次数后停止。如果为 0，表示按地址范围执行，直到 <code>end</code> 地址或其他条件触发。</li>
</ul>
<p>在虚拟机执行过程中可能会抛出异常，如访问非法内存地址、执行未定义指令等，通常这些异常会触发钩子函数或返回错误信息。为了应对这些可能的异常，可以通过在模拟中添加错误处理代码，保证仿真顺利进行或在发生错误时及时停止仿真。</p>
<p>常见的异常包括：</p>
<ul>
<li><strong><code>UC_ERR_READ_UNMAPPED</code></strong> ：尝试读取未映射的内存。</li>
<li><strong><code>UC_ERR_WRITE_UNMAPPED</code></strong> ：尝试写入未映射的内存。</li>
<li><strong><code>UC_ERR_FETCH_UNMAPPED</code></strong> ：尝试获取未映射的指令。</li>
<li><strong><code>UC_ERR_READ_PROT</code></strong> ：尝试读取保护内存。</li>
<li><strong><code>UC_ERR_WRITE_PROT</code></strong> ：尝试写入保护内存。</li>
<li><strong><code>UC_ERR_FETCH_PROT</code></strong> ：尝试获取受保护的指令。</li>
</ul>
<p>异常处理可以通过 <code>try-except</code> 结构来完成。下面是一个例子，展示了如何捕捉异常并处理：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 启动仿真，从地址 0x1000 开始执行，直到 0x1003</span></span><br><span class="line">    mu.emu_start(<span class="number">0x1000</span>, <span class="number">0x1003</span>)</span><br><span class="line"><span class="keyword">except</span> UcError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error during emulation: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<h4 id="事件监控"><a href="#事件监控" class="headerlink" title="事件监控"></a>事件监控</h4><p>Unicorn 提供了事件钩子（hooks）功能，用于在程序执行过程中捕获特定的事件（如指令执行、内存读写、寄存器访问等）。通过钩子机制，用户可以在仿真时监控程序的特定行为并调用用户自己实现的回调函数处理。</p>
<p>Unicorn 提供了多种类型的监控事件，这里只介绍我们常用的事件类型。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>在添加事件钩子之后 Unicorn 的执行效率会变得非常低。因此在实际编写脚本的时候应当尽量避免使用 Unicorn 的事件监控功能，而是将其作为调试脚本的工具。</p>
<p>例如在一段代码中间的某个位置处需要做一些额外操作，时候可以可以以该位置为边界将代码分为两部分模拟，而不是设置一个指令执行事件来监控程序只不是执行到需要做额外操作的位置了。</p>

    </div>
  </div>

<h5 id="指令执行事件"><a href="#指令执行事件" class="headerlink" title="指令执行事件"></a>指令执行事件</h5><p>指令执行事件 <code>UC_HOOK_CODE</code> 在每执行一条指令时触发，该事件对应的回调函数如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_code</span>(<span class="params">uc, address, size, user_data</span>):</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>uc</code></strong> ：当前的 Unicorn 仿真对象，类型为 <code>Uc</code>。它是对当前仿真状态的一个引用，用户可以通过它访问模拟环境中的寄存器、内存等。</li>
<li><strong><code>address</code></strong> ：当前执行指令的地址（内存中的位置）。这个地址是指指令被执行时在仿真内存中加载的地址。</li>
<li><strong><code>size</code></strong> ：当前指令的大小（以字节为单位）。这表示指令在内存中占用的字节数。</li>
<li><strong><code>user_data</code></strong> ：用户自定义的数据。可以在调用 <code>hook_add</code> 时传入，通常用于传递上下文信息或者保持状态。</li>
</ul>
<p>我们通常使用下面这个模板打印模拟执行的汇编指令来调试脚本：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line">cs = Cs(CS_ARCH_X86, CS_MODE_64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个回调函数，用于监控指令执行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_code</span>(<span class="params">uc, address, size, user_data</span>):</span><br><span class="line">    insn = <span class="built_in">next</span>(cs.disasm(uc.mem_read(address, size), address))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;address:#x&#125;</span>: <span class="subst">&#123;insn.mnemonic&#125;</span> <span class="subst">&#123;insn.op_str&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">mu.hook_add(UC_HOOK_CODE, hook_code)  <span class="comment"># 注册指令执行钩子</span></span><br></pre></td></tr></table></figure></div>

<h5 id="内存事件"><a href="#内存事件" class="headerlink" title="内存事件"></a>内存事件</h5><p>我们常用的内存事件有<strong>内存读入事件</strong>（<code>UC_HOOK_MEM_READ</code>）和<strong>内存写入事件</strong>（<code>UC_HOOK_MEM_WRITE</code>），另外针对指令的有<strong>获取指令事件</strong>（<code>UC_HOOK_MEM_FETCH</code>）。对应的回调函数定义如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_mem</span>(<span class="params">uc, access, address, size, value, user_data</span>):</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong><code>uc</code></strong> ：当前的 Unicorn 仿真对象，类型为 <code>Uc</code>，同样提供对仿真环境的访问。</li>
<li><strong><code>access</code></strong> ：内存访问的类型。可以是以下几种类型：<ul>
<li><code>UC_MEM_READ</code>：表示是数据读取。</li>
<li><code>UC_MEM_WRITE</code>：表示是数据写入。</li>
<li><code>UC_MEM_FETCH</code>：表示读取的是指令（通常用于指令获取）。</li>
</ul>
</li>
<li><strong><code>address</code></strong> ：发生内存访问的地址（内存中的位置）。这个地址指的是访问的内存单元的地址。</li>
<li><strong><code>size</code></strong> ：内存读取操作的大小（以字节为单位）。表示读取或写入了多少字节的数据。</li>
<li><strong><code>value</code></strong> ：读取或写入的值。指在指定地址处读取或写入的实际内容（以整数形式表示）。</li>
<li><strong><code>user_data</code></strong> ：用户自定义的数据，通常用于在钩子中传递一些额外的上下文信息。</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个回调函数，用于监控内存读取</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_mem_read</span>(<span class="params">uc, access, address, size, value, user_data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Memory read at address: 0x<span class="subst">&#123;address:X&#125;</span>, size: <span class="subst">&#123;size&#125;</span>, value: 0x<span class="subst">&#123;value:X&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个回调函数，用于监控内存写入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_mem_write</span>(<span class="params">uc, access, address, size, value, user_data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Memory write at address: 0x<span class="subst">&#123;address:X&#125;</span>, size: <span class="subst">&#123;size&#125;</span>, value: 0x<span class="subst">&#123;value:X&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个回调函数，用于监控内存获取指令</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_mem_fetch</span>(<span class="params">uc, address, size, user_data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Instruction fetched from address: 0x<span class="subst">&#123;address:X&#125;</span>, size: <span class="subst">&#123;size&#125;</span> bytes&quot;</span>)</span><br><span class="line">    </span><br><span class="line">mu.hook_add(UC_HOOK_MEM_READ, hook_mem_read)  <span class="comment"># 注册内存读取钩子</span></span><br><span class="line">mu.hook_add(UC_HOOK_MEM_WRITE, hook_mem_write)  <span class="comment"># 注册内存写入钩子</span></span><br><span class="line">mu.hook_add(UC_HOOK_MEM_FETCH, hook_mem_fetch)  <span class="comment"># 注册内存获取指令钩子</span></span><br></pre></td></tr></table></figure></div>

<h2 id="常用脚本-1"><a href="#常用脚本-1" class="headerlink" title="常用脚本"></a>常用脚本</h2><h3 id="trace-shellcode"><a href="#trace-shellcode" class="headerlink" title="trace shellcode"></a>trace shellcode</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">CODE_ADDRESS = <span class="number">0x74B000</span>  <span class="comment"># 0x6F8618  # Shellcode 的加载地址</span></span><br><span class="line">STACK_ADDRESS = <span class="number">0x0019C000</span>  <span class="comment"># 栈的起始地址（分配在高地址区域）</span></span><br><span class="line">STACK_SIZE = <span class="number">0x00080000</span>  <span class="comment"># 栈大小</span></span><br><span class="line">ORIG_SP = STACK_ADDRESS + STACK_SIZE // <span class="number">2</span></span><br><span class="line">JUMP_BLOCK_RANGE = <span class="built_in">range</span>(CODE_ADDRESS + <span class="number">0x3fd0</span>, CODE_ADDRESS + <span class="number">0x137f0</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="built_in">open</span>(<span class="string">&quot;shellcode.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 Unicorn 模拟器</span></span><br><span class="line">mu = Uc(UC_ARCH_X86, UC_MODE_32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 映射内存</span></span><br><span class="line">mu.mem_map(CODE_ADDRESS &amp; ~<span class="number">0xFFF</span>, ((<span class="built_in">len</span>(shellcode) + <span class="number">0xFFF</span>) &amp; ~<span class="number">0xFFF</span>) + <span class="number">0x1000</span>)  <span class="comment"># 为代码分配内存</span></span><br><span class="line"></span><br><span class="line">mu.mem_map(STACK_ADDRESS, STACK_SIZE)  <span class="comment"># 为栈分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入 Shellcode</span></span><br><span class="line">mu.mem_write(CODE_ADDRESS, shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化栈指针（ESP 指向栈顶）</span></span><br><span class="line">mu.reg_write(UC_X86_REG_ESP, STACK_ADDRESS + <span class="number">0x0019F998</span> - <span class="number">0x0019C000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 Capstone 用于反汇编</span></span><br><span class="line">cs = Cs(CS_ARCH_X86, CS_MODE_32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;trace.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TraceInfo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, uc: unicorn.Uc, address, size</span>):</span><br><span class="line">        code = uc.mem_read(address, size)</span><br><span class="line">        <span class="variable language_">self</span>.addr = address</span><br><span class="line">        <span class="variable language_">self</span>.insn = <span class="built_in">next</span>(cs.disasm(code, address))</span><br><span class="line">        <span class="variable language_">self</span>.regs = <span class="variable language_">self</span>.get_registers(uc)</span><br><span class="line">        <span class="variable language_">self</span>.regs_change = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.mem_change = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_registers</span>(<span class="params">self, uc: unicorn.Uc</span>):</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;eax&#x27;</span>: uc.reg_read(UC_X86_REG_EAX),</span><br><span class="line">            <span class="string">&#x27;ebx&#x27;</span>: uc.reg_read(UC_X86_REG_EBX),</span><br><span class="line">            <span class="string">&#x27;ecx&#x27;</span>: uc.reg_read(UC_X86_REG_ECX),</span><br><span class="line">            <span class="string">&#x27;edx&#x27;</span>: uc.reg_read(UC_X86_REG_EDX),</span><br><span class="line">            <span class="string">&#x27;esi&#x27;</span>: uc.reg_read(UC_X86_REG_ESI),</span><br><span class="line">            <span class="string">&#x27;edi&#x27;</span>: uc.reg_read(UC_X86_REG_EDI),</span><br><span class="line">            <span class="string">&#x27;esp&#x27;</span>: uc.reg_read(UC_X86_REG_ESP),</span><br><span class="line">            <span class="string">&#x27;ebp&#x27;</span>: uc.reg_read(UC_X86_REG_EBP),</span><br><span class="line">            <span class="comment"># &#x27;eip&#x27;: uc.reg_read(UC_X86_REG_EIP),</span></span><br><span class="line">            <span class="string">&#x27;eflags&#x27;</span>: uc.reg_read(UC_X86_REG_EFLAGS),</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 段寄存器（如需要可以添加调试信息）</span></span><br><span class="line">            <span class="comment"># &#x27;cs&#x27;: uc.reg_read(UC_X86_REG_CS),</span></span><br><span class="line">            <span class="comment"># &#x27;ds&#x27;: uc.reg_read(UC_X86_REG_DS),</span></span><br><span class="line">            <span class="comment"># &#x27;es&#x27;: uc.reg_read(UC_X86_REG_ES),</span></span><br><span class="line">            <span class="comment"># &#x27;fs&#x27;: uc.reg_read(UC_X86_REG_FS),</span></span><br><span class="line">            <span class="comment"># &#x27;gs&#x27;: uc.reg_read(UC_X86_REG_GS),</span></span><br><span class="line">            <span class="comment"># &#x27;ss&#x27;: uc.reg_read(UC_X86_REG_SS),</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_regs_change</span>(<span class="params">self, uc: unicorn.Uc</span>):</span><br><span class="line">        new_regs = <span class="variable language_">self</span>.get_registers(uc)</span><br><span class="line">        diffs = []</span><br><span class="line">        <span class="keyword">for</span> reg, old_val <span class="keyword">in</span> <span class="variable language_">self</span>.regs.items():</span><br><span class="line">            new_val = new_regs[reg]</span><br><span class="line">            <span class="keyword">if</span> old_val != new_val:</span><br><span class="line">                diffs.append(<span class="string">f&quot;<span class="subst">&#123;reg&#125;</span>: <span class="subst">&#123;<span class="built_in">hex</span>(old_val)&#125;</span>-&gt; <span class="subst">&#123;<span class="built_in">hex</span>(new_val)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.regs_change = <span class="string">&quot; &quot;</span>.join(diffs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_mem_change</span>(<span class="params">self, uc: unicorn.Uc, address, size, value</span>):</span><br><span class="line">        old_value = <span class="built_in">int</span>.from_bytes(uc.mem_read(address, size), byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.mem_change = <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">hex</span>(address)&#125;</span>: <span class="subst">&#123;<span class="built_in">hex</span>(old_value)&#125;</span>-&gt; <span class="subst">&#123;<span class="built_in">hex</span>(value)&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_state_trace_info</span>(<span class="params">self</span>):</span><br><span class="line">        addr_str = <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">hex</span>(self.addr)&#125;</span>&quot;</span>.ljust(<span class="number">10</span>)</span><br><span class="line">        insn_str = <span class="string">f&quot;<span class="subst">&#123;self.insn.mnemonic&#125;</span> <span class="subst">&#123;self.insn.op_str&#125;</span>&quot;</span>.ljust(<span class="number">40</span>)</span><br><span class="line">        regs_str = <span class="variable language_">self</span>.regs_change.ljust(<span class="number">60</span>)</span><br><span class="line">        mem_str = <span class="variable language_">self</span>.mem_change.ljust(<span class="number">60</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;addr_str&#125;</span> | <span class="subst">&#123;insn_str&#125;</span> | <span class="subst">&#123;regs_str&#125;</span> | <span class="subst">&#123;mem_str&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">trace_info: TraceInfo = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hook：捕获内存写入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_mem_write</span>(<span class="params">uc, access, address, size, value, user_data</span>):</span><br><span class="line">    trace_info.set_mem_change(uc, address, size, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化计数器和时间</span></span><br><span class="line">trace_count = <span class="number">0</span></span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hook：捕获指令执行后的状态</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_code</span>(<span class="params">uc, address, size, user_data</span>):</span><br><span class="line">    <span class="keyword">global</span> trace_info, trace_count, start_time</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新指令计数器</span></span><br><span class="line">    trace_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 动态显示执行速度</span></span><br><span class="line">    current_time = time.time()</span><br><span class="line">    elapsed_time = current_time - start_time</span><br><span class="line">    <span class="keyword">if</span> elapsed_time &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">f&quot;\rProcessed: <span class="subst">&#123;trace_count&#125;</span> instructions, Speed: <span class="subst">&#123;trace_count / elapsed_time:<span class="number">.2</span>f&#125;</span> instructions/sec&quot;</span>,</span><br><span class="line">            end=<span class="string">&quot;&quot;</span>,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> trace_info <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        trace_info.set_regs_change(uc)</span><br><span class="line">        <span class="built_in">print</span>(trace_info.get_state_trace_info(), file=f)</span><br><span class="line"></span><br><span class="line">    trace_info = TraceInfo(uc, address, size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 Hook</span></span><br><span class="line">mu.hook_add(UC_HOOK_MEM_WRITE, hook_mem_write)  <span class="comment"># 捕获内存写入</span></span><br><span class="line">mu.hook_add(UC_HOOK_CODE, hook_code)  <span class="comment"># 捕获指令执行后的状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始模拟执行</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starting execution...&quot;</span>)</span><br><span class="line">    mu.emu_start(CODE_ADDRESS, CODE_ADDRESS + <span class="built_in">len</span>(shellcode))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Execution finished.&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> UcError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Unicorn execution failed: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(mu.reg_read(UC_X86_REG_ESP)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(mu.reg_read(UC_X86_REG_EIP)))</span><br><span class="line">    esp = mu.reg_read(UC_X86_REG_ESP)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(esp, esp + <span class="number">0x50</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>.from_bytes(mu.mem_read(i, <span class="number">4</span>), byteorder=<span class="string">&quot;little&quot;</span>)))</span><br></pre></td></tr></table></figure></div>












		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> 逆向自动化工具</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2025-01-02 01:21:55</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-02-22 20:25:31
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2025/01/02/逆向自动化工具/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/01/03/Linux%20%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">Linux 软件分析基础</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/11/30/CVE-2024-26809/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">CVE-2024-26809 分析</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">逆向自动化工具</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Keystone"><span class="nav-text">Keystone</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Keystone-%E5%AE%89%E8%A3%85"><span class="nav-text">Keystone 安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-text">基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-Keystone-%E5%AF%B9%E8%B1%A1"><span class="nav-text">创建 Keystone 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%87%E7%BC%96"><span class="nav-text">汇编</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Capstone"><span class="nav-text">Capstone</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Capstone-%E5%AE%89%E8%A3%85"><span class="nav-text">Capstone 安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-1"><span class="nav-text">基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-Capstone-%E5%AF%B9%E8%B1%A1"><span class="nav-text">创建 Capstone 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E6%B1%87%E7%BC%96"><span class="nav-text">反汇编</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CsInsn-%E5%AF%B9%E8%B1%A1"><span class="nav-text">CsInsn 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%AD%97%E6%AE%B5"><span class="nav-text">基本字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E8%AF%BB%E5%86%99"><span class="nav-text">寄存器读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E5%AD%97%E6%AE%B5"><span class="nav-text">操作数字段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%93%E6%9E%84"><span class="nav-text">操作数结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="nav-text">内存操作数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#x86-%E6%9E%B6%E6%9E%84"><span class="nav-text">x86 架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ARM-%E6%9E%B6%E6%9E%84"><span class="nav-text">ARM 架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AArch64-%E6%9E%B6%E6%9E%84"><span class="nav-text">AArch64 架构</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#angr"><span class="nav-text">angr</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#angr-%E5%AE%89%E8%A3%85"><span class="nav-text">angr 安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"><span class="nav-text">静态分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD"><span class="nav-text">二进制文件加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E9%A1%B9%E7%9B%AE%EF%BC%88Project%EF%BC%89"><span class="nav-text">加载项目（Project）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E9%80%89%E9%A1%B9"><span class="nav-text">加载选项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="nav-text">基本属性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88The-Loader%EF%BC%89"><span class="nav-text">加载器（The Loader）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%B2%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">已加载的对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="nav-text">对象基本信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AE%B5%EF%BC%88Segment%EF%BC%89%E5%92%8C%E8%8A%82%EF%BC%88Section%EF%BC%89"><span class="nav-text">段（Segment）和节（Section）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="nav-text">内存数据</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E4%BF%A1%E6%81%AF"><span class="nav-text">符号信息</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E5%9C%B0%E5%9D%80"><span class="nav-text">符号地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E7%9A%84-PLT-%E5%9C%B0%E5%9D%80"><span class="nav-text">符号的 PLT 地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E7%9A%84-GOT-%E5%9C%B0%E5%9D%80"><span class="nav-text">符号的 GOT 地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">二进制代码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%9D%97%EF%BC%88Blocks%EF%BC%89"><span class="nav-text">基本块（Blocks）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%9D%97%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="nav-text">基本块的获取</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">基本块的使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%88CFG%EF%BC%89"><span class="nav-text">控制流程图（CFG）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-angr-%E6%8F%90%E5%8F%96-CFG"><span class="nav-text">利用 angr 提取 CFG</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%8F%90%E5%8F%96-CFG"><span class="nav-text">手动提取 CFG</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#angr-%E7%9A%84%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="nav-text">angr 的函数分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%8F%90%E5%8F%96%E5%87%BD%E6%95%B0"><span class="nav-text">手动提取函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-text">引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#x86-%E6%9E%B6%E6%9E%84-1"><span class="nav-text">x86 架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AArch64-%E6%9E%B6%E6%9E%84-1"><span class="nav-text">AArch64 架构</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C"><span class="nav-text">符号执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-text">符号执行原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3"><span class="nav-text">约束求解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C"><span class="nav-text">动态符号执行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88Claripy%EF%BC%89"><span class="nav-text">符号执行引擎（Claripy）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E5%90%91%E9%87%8F%E5%88%9B%E5%BB%BA"><span class="nav-text">位向量创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97"><span class="nav-text">位向量运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E7%BA%A6%E6%9D%9F%EF%BC%88Symbolic-Constraints%EF%BC%89"><span class="nav-text">符号约束（Symbolic Constraints）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3%EF%BC%88Constraint-Solving%EF%BC%89"><span class="nav-text">约束求解（Constraint Solving）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%EF%BC%88States%EF%BC%89"><span class="nav-text">状态（States）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%88%9B%E5%BB%BA"><span class="nav-text">状态创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE"><span class="nav-text">内存设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E8%AE%BE%E7%BD%AE"><span class="nav-text">寄存器设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE"><span class="nav-text">文件设置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BF%E7%9C%9F%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%88Simulation-Managers%EF%BC%89"><span class="nav-text">仿真管理器（Simulation Managers）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BF%E7%9C%9F%E7%AE%A1%E7%90%86%E5%99%A8%E5%88%9B%E5%BB%BA"><span class="nav-text">仿真管理器创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E6%8E%A2%E7%B4%A2"><span class="nav-text">路径探索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0-hook"><span class="nav-text">函数 hook</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E6%B1%82%E8%A7%A3"><span class="nav-text">符号求解</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IdaPython"><span class="nav-text">IdaPython</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-text">环境配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E6%8D%A2-python-%E7%89%88%E6%9C%AC"><span class="nav-text">切换 python 版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85-IPyIDA-%E6%8F%92%E4%BB%B6"><span class="nav-text">安装 IPyIDA 插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pycharm-%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"><span class="nav-text">pycharm 自动补全</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-2"><span class="nav-text">基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E7%9B%B8%E5%85%B3"><span class="nav-text">段相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3"><span class="nav-text">地址相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8"><span class="nav-text">交叉引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E5%9C%B0%E5%9D%80-1"><span class="nav-text">符号地址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3"><span class="nav-text">数据相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="nav-text">数据读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE"><span class="nav-text">数据查找</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3"><span class="nav-text">字符串相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%90%E5%8F%96"><span class="nav-text">字符串提取</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#idautils-Strings"><span class="nav-text">idautils.Strings</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#idc-get-strlit-contents"><span class="nav-text">idc.get_strlit_contents</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE"><span class="nav-text">字符串查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA"><span class="nav-text">字符串创建</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%9B%B8%E5%85%B3"><span class="nav-text">汇编指令相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3"><span class="nav-text">函数相关</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC"><span class="nav-text">常用脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E7%AC%A6%E5%8F%B7%E9%94%99%E8%AF%AF%E4%BF%AE%E5%A4%8D"><span class="nav-text">全局符号错误修复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E5%A4%8D%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-text">修复函数参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Unicorn"><span class="nav-text">Unicorn</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Unicorn-%E5%AE%89%E8%A3%85"><span class="nav-text">Unicorn 安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-3"><span class="nav-text">基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-Unicorn-%E5%AF%B9%E8%B1%A1"><span class="nav-text">创建 Unicorn 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="nav-text">寄存器操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">写入寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">读取寄存器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C"><span class="nav-text">内存操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E5%86%85%E5%AD%98"><span class="nav-text">映射内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E5%86%85%E5%AD%98"><span class="nav-text">写入内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E5%86%85%E5%AD%98"><span class="nav-text">读取内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A8%8B%E5%BA%8F"><span class="nav-text">加载二进制程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C"><span class="nav-text">模拟执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%AF%E5%8A%A8"><span class="nav-text">虚拟机启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E6%8E%A7"><span class="nav-text">事件监控</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%BA%8B%E4%BB%B6"><span class="nav-text">指令执行事件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BA%8B%E4%BB%B6"><span class="nav-text">内存事件</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC-1"><span class="nav-text">常用脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#trace-shellcode"><span class="nav-text">trace shellcode</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        30 posts in total
                    </span>
                    
                        <span>
                            527.2k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>