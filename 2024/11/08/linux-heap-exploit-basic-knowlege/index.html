<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2024/11/08/linux-heap-exploit-basic-knowlege/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            linux 堆利用基础知识 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">13</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">16</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">51</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">linux 堆利用基础知识</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-11-08 13:29:47</span>
        <span class="mobile">2024-11-08 13:29:47</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-08-19 01:06:29</span>
            <span class="mobile">2025-08-19 01:06:29</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/pwn/">pwn</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/pwn/linux-user/">linux user</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/linux-user-pwn/">linux user pwn</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>18.8k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>83 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<p>ptmalloc2 是目前 Linux 标准发行版中使用的堆分配器。</p>
<h1 id="内存分配基本思想"><a href="#内存分配基本思想" class="headerlink" title="内存分配基本思想"></a>内存分配基本思想</h1><ul>
<li>堆管理器负责向操作系统申请内存，然后将其返回给用户程序，但是频繁的系统调用会造成大量的开销。为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</li>
<li>一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li>
</ul>
<h1 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h1><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p><code>malloc</code> (memory allocation) 函数是 C 语言标准库中用于动态内存分配的一个基本函数。它分配一块至少为 size 字节的连续内存区域，并返回一个指向这块内存的指针</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>malloc</code> 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理：</p>
<ul>
<li>当 <code>n = 0</code> 时，返回当前系统允许的堆的最小内存块。</li>
<li>当 <code>n</code> 为负数时，由于在大多数系统上，<code>size_t</code> 是无符号数（这一点非常重要），所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li>
</ul>
<h2 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h2><p><code>realloc</code> 函数用于重新分配之前通过 <code>malloc</code> ，<code>calloc</code> 或 <code>realloc</code> 函数分配的内存区域。它可以改变内存块的大小，或者释放内存块，或分配新的内存块。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>ptr</code>：指向需要重新分配的内存块的指针。</li>
<li><code>size</code>：新的内存块的大小，以字节为单位。</li>
</ul>
<p>有如下情况：</p>
<ul>
<li><code>ptr</code> 不为空，<code>size = 0</code> ，相当于释放原来的堆块。</li>
<li><code>ptr</code> 为空且 <code>size &gt; 0</code> ，相当于 <code>malloc</code> 。</li>
<li><code>ptr</code> 不为空，<code>size</code> 大于原来的堆块大小则如果该堆块后面的堆块空闲则合并堆块，否则先释放原堆块，然后再申请一个更大的堆块，原堆块内容会被拷贝过去。</li>
<li><code>ptr</code> 不为空，<code>size</code> 不大于原来的堆块大小，如果切割后剩下的堆块大于等于 <code>MINSIZE</code> 则切割并释放，然后返回原堆块。</li>
</ul>
<h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h2><p><code>calloc</code> (contiguous allocation) 函数是 C 语言标准库中用于动态内存分配的一个函数。与 <code>malloc</code> 相似，<code>calloc</code> 用于分配内存。该函数在分配时会清空 <code>chunk</code> 上的内容，这使得我们无法通过以往的重复存取后通过 <code>chunk</code> 上残留的脏数据的方式泄露信息（例如通过 <code>bins</code> 数组遗留的脏数据泄露 libc 基址等），同时该函数不从 <code>tcache</code> 中拿 <code>chunk</code>，但是 <code>free()</code> 函数默认还是会先往 <code>tcache</code> 里放的，这无疑增加了我们利用的难度。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>nmemb</code>：需要分配的元素个数。</li>
<li><code>size</code>：每个元素的大小，以字节为单位。</li>
</ul>
<p>总的分配的字节大小是 <code>nmemb * size</code> 。</p>
<p><strong>注意：如果 size 的 IS_MAPPED 位置 1 则不清空数据。</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">memset</span> (mem, <span class="number">0</span>, sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mem;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>可以看出，free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</p>
<p>此外，该函数也同样对异常情况进行了处理：</p>
<ul>
<li>当 p 为空指针时，函数不执行任何操作。</li>
<li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 double free。</li>
<li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。</li>
</ul>
<h2 id="mallopt"><a href="#mallopt" class="headerlink" title="mallopt"></a>mallopt</h2><p><code>mallopt</code> 函数通过控制堆的特定参数用于改变堆的分配策略。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mallopt</span><span class="params">(<span class="type">int</span> param,<span class="type">int</span> value)</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>param</code>：指定要修改的动态内存分配参数。这个参数是一个整数，定义了哪一个特性将会被修改。例如，它可以是控制内存对齐、缓存大小或者相似行为的选项。<ul>
<li><code>M_MXFAST</code>：设置 <code>malloc</code> 用于小块内存分配的最大 fast bin 的大小。</li>
<li><code>M_TRIM_THRESHOLD</code>：设置 <code>sbrk</code> 释放内存回操作系统的阈值。</li>
<li><code>M_TOP_PAD</code>：设置 <code>sbrk</code> 请求额外内存时，上面的额外内存量。</li>
<li><code>M_MMAP_THRESHOLD</code>：设置使用 <code>mmap</code> 进行内存分配的阈值。</li>
<li><code>M_MMAP_MAX</code>：设置可以使用 <code>mmap</code> 进行内存分配的最大数目。</li>
</ul>
</li>
<li><code>value</code>：新的值，针对 param 指定的特性。具体的值取决于 param，有些特性可能需要非零值来启用，零值来禁用，有些则需要具体的数值。</li>
<li>返回值是一个整数，指示函数调用是否成功。<ul>
<li>如果成功，返回非零值。</li>
<li>如果失败（例如，不支持的参数或值），返回零。</li>
</ul>
</li>
</ul>
<h1 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h1><p>内存管理函数背后的系统调用主要是 (s)brk 函数以及 mmap, munmap 函数。<br>在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/7b0091679197656e97d7a468abccb56d.png"
                     
                ></p>
<h2 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h2><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk 的大小来向操作系统申请内存。</p>
<p>初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同</p>
<p>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data&#x2F;bss 段的结尾。<br>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data&#x2F;bss 段结尾后的随机偏移处。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/4a281327dd16657c32c2916e176a2c99.png"
                     
                ></p>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>malloc 会使用 mmap 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。</p>
<h1 id="堆相关数据结构"><a href="#堆相关数据结构" class="headerlink" title="堆相关数据结构"></a>堆相关数据结构</h1><h2 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h2><p>在 ptmalloc 中使用 <code>malloc_par</code> 结构体来记录堆管理器的相关参数，该结构体定义于 <code>malloc.c</code> 中，如下：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_par</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Tunable parameters */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> trim_threshold;</span><br><span class="line">  INTERNAL_SIZE_T top_pad;</span><br><span class="line">  INTERNAL_SIZE_T mmap_threshold;</span><br><span class="line">  INTERNAL_SIZE_T arena_test;</span><br><span class="line">  INTERNAL_SIZE_T arena_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory map support */</span></span><br><span class="line">  <span class="type">int</span> n_mmaps;</span><br><span class="line">  <span class="type">int</span> n_mmaps_max;</span><br><span class="line">  <span class="type">int</span> max_n_mmaps;</span><br><span class="line">  <span class="comment">/* the mmap_threshold is dynamic, until the user sets</span></span><br><span class="line"><span class="comment">     it manually, at which point we need to disable any</span></span><br><span class="line"><span class="comment">     dynamic behavior. */</span></span><br><span class="line">  <span class="type">int</span> no_dyn_threshold;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Statistics */</span></span><br><span class="line">  INTERNAL_SIZE_T mmapped_mem;</span><br><span class="line">  <span class="comment">/*INTERNAL_SIZE_T  sbrked_mem;*/</span></span><br><span class="line">  <span class="comment">/*INTERNAL_SIZE_T  max_sbrked_mem;*/</span></span><br><span class="line">  INTERNAL_SIZE_T max_mmapped_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_total_mem;  <span class="comment">/* only kept for NO_THREADS */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First address handed out by MORECORE/sbrk.  */</span></span><br><span class="line">  <span class="type">char</span> *sbrk_base;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>主要是定义了和 <code>mmap</code> 和 <code>arena</code> 相关的一些参数（如数量上限等），以及 <code>sbrk</code> 的基址，其中重要的参数解释如下：</p>
<ul>
<li><code>top_pad</code>：初始化或扩展堆的时候需要多申请的内存大小。</li>
<li><code>mmap_threshold</code>：决定 <code>sysmalloc</code> 是通过 <code>mmap</code> 还是 <code>sbrk</code> 分配内存的界限，即如果申请的内存大小不小于该值则采用 <code>mmap</code> 分配，否则采用 <code>sbrk</code> 扩展 <code>heap</code> 区域分配。并且这个值是动态调整的，如果释放的内存是通过 <code>mmap</code> 得到的则 <code>mmap_threshold</code> 与该内存大小取 <code>max</code> 。并且 <code>mmap_threshold</code> 最大不能超过 <code>DEFAULT_MMAP_THRESHOLD_MAX</code> ，即 0x2000000 。</li>
<li><code>trim_threshold</code>：用于 <code>main_arena</code> 中保留内存量的控制。当释放的 <code>chunk</code> 为 <code>mmap</code> 获得的，同时大小大于 <code>mmap_threshold</code> ，则除了更新 <code>mmap_threshold</code> 外还会将 <code>trim_threshold</code> 乘 2 。当释放的 <code>chunk</code> 大小不在 fast bin 范围合并完 <code>size</code> 大于 <code>FASTBIN_CONSOLIDATION_THRESHOLD</code> 即 0x10000 ，且为 <code>main_arena</code> ，且 top chunk 的大小大于 <code>trim_threshold</code> 则将 <code>heap</code> 区域在 top chunk 不会小于 <code>pagesize</code> 的前提下减小 <code>top_pad</code> 。</li>
<li><code>n_mmaps</code>：<code>mmap</code> 的内存数量，即 ptmalloc 每次成功 <code>mmap</code> 则 <code>n_mmaps</code> 加 1，ptmalloc 每次成功 <code>munmap</code> 则 <code>n_mmaps</code> 减 1 。</li>
<li><code>n_mmaps_max</code>：<code>n_mmaps</code> 的上限，即最多能 <code>mmap</code> 的内存数量。</li>
<li><code>max_n_mmaps</code>：<code>n_mmaps</code> 达到过的最大值。</li>
<li><code>mmapped_mem</code>：当前 <code>mmap</code> 的内存大小总和。</li>
<li><code>max_mmapped_mem</code>：<code>mmap</code> 的内存大小总和达到过的最大值。</li>
<li><code>sbrk_base</code>：表示通过 <code>brk</code> 系统调用申请的 <code>heap</code> 区域的起始地址。</li>
<li><code>no_dyn_threshold</code>：表示是否禁用 <code>heap</code> 动态调整保留内存的大小，默认为 0 。</li>
</ul>
<p>该结构体类型的实例 <code>mp_</code> 用以记录 ptmalloc 相关参数，同样定义于 <code>malloc.c</code> 中，如下：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> DEFAULT_TOP_PAD 131072 <span class="comment">// 0x20000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_MAX       (65536) <span class="comment">// 0x10000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN <span class="comment">// 0x20000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_TRIM_THRESHOLD (128 * 1024) <span class="comment">// 0x20000</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">malloc_par</span> mp_ =</span><br><span class="line">&#123;</span><br><span class="line">  .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">  .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">  .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span></span><br><span class="line">  .arena_test = <span class="built_in">NARENAS_FROM_NCORES</span> (<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h2><p><code>heap_info</code> 位于一个 <code>heap</code> 块的开头，用以记录通过 <code>mmap</code> 系统调用从 Memory Mapping Segment 处申请到的内存块的信息。定义于 <code>arena.c</code> 中。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A heap is a single contiguous memory region holding (coalesceable)</span></span><br><span class="line"><span class="comment">   malloc_chunks.  It is allocated with mmap() and always starts at an</span></span><br><span class="line"><span class="comment">   address aligned to HEAP_MAX_SIZE.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_heap_info</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_heap_info</span> *prev; <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure></div>

<p><code>heap_info</code> 结构体的成员如下：</p>
<ul>
<li><code>ar_ptr</code>：指向管理该堆块的 arena</li>
<li><code>prev</code>：该heap_info所链接的上一个 heap_info</li>
<li><code>size</code>：记录该堆块的大小</li>
<li><code>mprotect_size</code>：记录该堆块中被保护（<code>mprotected</code>）的大小</li>
<li><code>pad</code>：即 <code>padding</code> ，用以在 <code>SIZE_SZ</code> 不正常的情况下进行填充以让内存对齐，正常情况下 <code>pad</code> 所占用空间应为 0 字节</li>
</ul>
<h2 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h2><p>大部分情况下对于每个线程而言其都会单独有着一个 <code>arena</code> 实例用以管理属于该线程的堆内存区域。<code>ptmalloc</code> 内部的内存池结构是由 <code>malloc_state</code> 结构体进行定义的，即 <code>arena</code> 本身便为 <code>malloc_state</code> 的一个实例对象。<br><code>malloc_state</code> 结构体定义于<code>malloc/malloc.c</code> 中，代码如下：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_state</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_state</span> *next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_state</span> *next_free;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>malloc_state</code> 结构体的成员如下：</p>
<ul>
<li><code>mutex</code>：<code>mutex</code> 变量即为多线程互斥锁，用以保证线程安全。</li>
<li><code>flags</code>：标志位，用以表示 <code>arena</code> 的一些状态，如：是否有 <code>fastbin</code> 、内存是否连续等。</li>
<li><code>fastbinY</code>：存放 fastbin chunk 的数组。</li>
<li><code>top</code>：指向 Top Chunk 的指针。</li>
<li><code>last_remainder</code>：<code>chunk</code> 切割中的剩余部分。<code>malloc</code> 在分配 <code>chunk</code> 时若是没找到 <code>size</code> 合适的 <code>chunk</code> 而是找到了一个 <code>size</code> 更大的 <code>chunk</code> ，则会从大 <code>chunk</code> 中切割掉一块返回给用户，剩下的那一块便是 <code>last_remainder</code> ，其随后会被放入 unsorted bin 中。</li>
<li><code>bins</code>：存放闲置 <code>chunk</code> 的数组。<code>bins</code> 包括 large bin，small bin 和 unsorted bin 。</li>
<li><code>binmap</code>：记录 <code>bin</code> 是否为空的 <code>bitset</code> 。需要注意的是 <code>chunk</code> 被取出后若一个 <code>bin</code> 空了并不会立即被置 0 ，而会在下一次遍历到时重新置位。</li>
<li><code>next</code>：指向下一个 <code>arena</code> 的指针。一个进程内所有的 <code>arena</code> 串成了一条循环单向链表，<code>malloc_state</code> 中的 <code>next</code> 指针便是用以指向下一个 <code>arena</code> ，方便后续的遍历  <code>arena</code> 的操作（因为不是所有的线程都有自己独立的 <code>arena</code> ）。</li>
<li><code>next_free</code>：指向下一个空闲的 <code>arena</code> 的指针。与 <code>next</code> 指针类似，只不过指向的是空闲的 <code>arena</code>（即没有被任一线程所占用）。</li>
<li><code>attached_threads</code>：与该 <code>arena</code> 相关联的线程数。该变量用以表示有多少个线程与该<code>arena</code> 相关联，这是因为 <code>aerna</code> 的数量是有限的，并非每一个线程都有机会分配到一个<code>arena</code>，在线程数量较大的情况下会存在着多个线程共用一个 <code>arena</code> 的情况。</li>
<li><code>system_mem</code>：记录当前 <code>arena</code> 在堆区中所分配到的内存的总大小。</li>
<li><code>max_system_mem</code>：当操作系统予进程以内存时，<code>system_mem</code> 会随之增大，当内存被返还给操作系统时，<code>sysyetm_mem</code> 会随之减小，<code>max_system_mem</code> 变量便是用来记录在这个过程当中 <code>system_mem</code> 的峰值。</li>
</ul>
<p><code>main_arena</code> 为一个定义于 <code>malloc.c</code> 中的静态的 <code>malloc_state</code> 结构体。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">malloc_state</span> main_arena =</span><br><span class="line">&#123;</span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>由于其为 libc 中的静态变量，该 <code>arena</code> 会被随着 libc 文件一同加载到 Memory Mapping Segment。因此在堆题中通常通过泄露 <code>arena</code> 的地址以获得 libc 在内存中的基地址。</p>
<h2 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h2><p>在程序的执行过程中，我们称由 <code>malloc</code> 申请的内存为 <code>chunk</code> 。这块内存在 <code>ptmalloc</code> 内部用 <code>malloc_chunk</code> 结构体来表示。当程序申请的 <code>chunk</code> 被 <code>free</code> 后，会被加入到相应的空闲管理列表中。<br><code>malloc_chunk</code> 定义如下：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">malloc_chunk</span> &#123;</span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd;         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* fd_nextsize; <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span>* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>每个字段的具体的解释如下：</p>
<ul>
<li><p><code>prev_size</code>：如果物理相邻的前一地址 <code>chunk</code> 是空闲的话，那该字段记录的是前一个 <code>chunk</code> 的大小 (包括 <code>chunk</code> 头)。否则，该字段可以用来存储物理相邻的前一个 <code>chunk</code> 的数据。</p>
</li>
<li><p><code>size</code>：该 <code>chunk</code> 的大小，大小必须是 <code>2 * SIZE_SZ</code> 的整数倍。该字段的低三个比特位对 <code>chunk</code> 的大小没有影响，它们从高到低分别表示为：</p>
<ul>
<li><code>NON_MAIN_ARENA</code>，记录当前 <code>chunk</code> 是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li><code>IS_MAPPED</code>，记录当前 <code>chunk</code> 是否是由 <code>mmap</code> 分配的。</li>
<li><code>PREV_INUSE</code>，记录前一个 <code>chunk</code> 块是否被分配。一般来说，堆中第一个被分配的内存块的 <code>size</code> 字段的 <code>P</code> 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 <code>chunk</code> 的 <code>size</code> 的 <code>P</code> 位为 0 时，我们能通过 <code>prev_size</code> 字段来获取上一个 <code>chunk</code> 的大小以及地址。这也方便进行空闲 <code>chunk</code> 之间的合并。</li>
</ul>
</li>
<li><p><code>fd</code>，<code>bk</code>。 <code>chunk</code> 处于分配状态时，从 <code>fd</code> 字段开始是用户的数据。<code>chunk</code> 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</p>
<ul>
<li><code>fd</code> 指向下一个（非物理相邻）空闲的 <code>chunk</code></li>
<li><code>bk</code> 指向上一个（非物理相邻）空闲的 <code>chunk</code></li>
</ul>
<p>通过 <code>fd</code> 和 <code>bk</code> 可以将空闲的 <code>chunk</code> 块加入到空闲的 <code>chunk</code> 块链表进行统一管理</p>
</li>
<li><p><code>fd_nextsize</code>， <code>bk_nextsize</code>，也是只有 <code>chunk</code> 空闲的时候才使用，不过其用于较大的 <code>chunk</code>（large chunk）。</p>
<ul>
<li><code>fd_nextsize</code> 指向前一个与当前 <code>chunk</code> 大小不同的第一个空闲块，不包含 <code>bin</code> 的头指针。</li>
<li><code>bk_nextsize</code> 指向后一个与当前 <code>chunk</code> 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 <code>fd</code> 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 <code>chunk</code> 时挨个遍历。（<del>好在 large bin 限制了值域范围，不然也会很慢</del> ）</li>
</ul>
</li>
</ul>
<p><code>chunk</code> 的结构如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f439d9936936ea9634731a2829b84bcf.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p>
<h2 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h2><h2 id="bins-1"><a href="#bins-1" class="headerlink" title="bins"></a>bins</h2><p>我们曾经说过，用户释放掉的 <code>chunk</code> 不会马上归还给系统，ptmalloc 会统一管理 <code>heap</code> 和 <code>mmap</code> 映射区域中的空闲的 <code>chunk</code>。当用户再一次请求分配内存时，<code>ptmalloc</code> 分配器会试图在空闲的 <code>chunk</code> 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。<br>在具体的实现中，ptmalloc 采用分箱式方法对空闲的 <code>chunk</code> 进行管理。首先，它会根据空闲的 <code>chunk</code> 的大小以及使用状态将 <code>chunk</code> 初步分为 4 类：fast bins，small bins，large bins，unsorted bin 。对于 libc2.26 以上版本还有 <code>tcache</code> 。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于 small bins，large bins，unsorted bin 来说，ptmalloc 将它们维护在一个 <code>bins</code> 数组中。这些 <code>bin</code> 对应的数据结构在 <code>malloc_state</code> 中，如下：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br></pre></td></tr></table></figure></div>

<p><code>bins</code> 数组实际上可以看做是以 <code>chunk</code> 为单位，只不过采用空间复用策略，因为实际用到的只有 <code>fd</code> 和 <code>bk</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))			      \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/9d6b2cc483c3f8a156e4c445dc0e4797.png"
                     
                ><br>由于是双链表结构 <code>bins</code> 数组每连续两个 <code>chunk</code> 指针维护一个 <code>bin</code>（即 <code>fd</code> 和 <code>bk</code> ），其结构如下图所示（64位）。其中 small bins 中 <code>chunk</code> 大小已给出。large bins 的每个 <code>bin</code> 中的 <code>chunk</code> 大小在一个范围内。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/08c0ec1b811090f35577a73cebba6a99.png"
                     
                ><br> large bin 的 <code>chunk</code> 范围如下：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>64位最小</th>
<th>64位最大</th>
<th>64位公差</th>
<th>32位最小</th>
<th>32位最大</th>
<th>32位公差</th>
</tr>
</thead>
<tbody><tr>
<td>64</td>
<td>0x400</td>
<td>0x430</td>
<td>0x40</td>
<td>0x200</td>
<td>0x238</td>
<td>0x40</td>
</tr>
<tr>
<td>65</td>
<td>0x440</td>
<td>0x470</td>
<td>0x40</td>
<td>0x240</td>
<td>0x278</td>
<td>0x40</td>
</tr>
<tr>
<td>66</td>
<td>0x480</td>
<td>0x4b0</td>
<td>0x40</td>
<td>0x280</td>
<td>0x2b8</td>
<td>0x40</td>
</tr>
<tr>
<td>67</td>
<td>0x4c0</td>
<td>0x4f0</td>
<td>0x40</td>
<td>0x2c0</td>
<td>0x2f8</td>
<td>0x40</td>
</tr>
<tr>
<td>68</td>
<td>0x500</td>
<td>0x530</td>
<td>0x40</td>
<td>0x300</td>
<td>0x338</td>
<td>0x40</td>
</tr>
<tr>
<td>69</td>
<td>0x540</td>
<td>0x570</td>
<td>0x40</td>
<td>0x340</td>
<td>0x378</td>
<td>0x40</td>
</tr>
<tr>
<td>70</td>
<td>0x580</td>
<td>0x5b0</td>
<td>0x40</td>
<td>0x380</td>
<td>0x3b8</td>
<td>0x40</td>
</tr>
<tr>
<td>71</td>
<td>0x5c0</td>
<td>0x5f0</td>
<td>0x40</td>
<td>0x3c0</td>
<td>0x3f8</td>
<td>0x40</td>
</tr>
<tr>
<td>72</td>
<td>0x600</td>
<td>0x630</td>
<td>0x40</td>
<td>0x400</td>
<td>0x438</td>
<td>0x40</td>
</tr>
<tr>
<td>73</td>
<td>0x640</td>
<td>0x670</td>
<td>0x40</td>
<td>0x440</td>
<td>0x478</td>
<td>0x40</td>
</tr>
<tr>
<td>74</td>
<td>0x680</td>
<td>0x6b0</td>
<td>0x40</td>
<td>0x480</td>
<td>0x4b8</td>
<td>0x40</td>
</tr>
<tr>
<td>75</td>
<td>0x6c0</td>
<td>0x6f0</td>
<td>0x40</td>
<td>0x4c0</td>
<td>0x4f8</td>
<td>0x40</td>
</tr>
<tr>
<td>76</td>
<td>0x700</td>
<td>0x730</td>
<td>0x40</td>
<td>0x500</td>
<td>0x538</td>
<td>0x40</td>
</tr>
<tr>
<td>77</td>
<td>0x740</td>
<td>0x770</td>
<td>0x40</td>
<td>0x540</td>
<td>0x578</td>
<td>0x40</td>
</tr>
<tr>
<td>78</td>
<td>0x780</td>
<td>0x7b0</td>
<td>0x40</td>
<td>0x580</td>
<td>0x5b8</td>
<td>0x40</td>
</tr>
<tr>
<td>79</td>
<td>0x7c0</td>
<td>0x7f0</td>
<td>0x40</td>
<td>0x5c0</td>
<td>0x5f8</td>
<td>0x40</td>
</tr>
<tr>
<td>80</td>
<td>0x800</td>
<td>0x830</td>
<td>0x40</td>
<td>0x600</td>
<td>0x638</td>
<td>0x40</td>
</tr>
<tr>
<td>81</td>
<td>0x840</td>
<td>0x870</td>
<td>0x40</td>
<td>0x640</td>
<td>0x678</td>
<td>0x40</td>
</tr>
<tr>
<td>82</td>
<td>0x880</td>
<td>0x8b0</td>
<td>0x40</td>
<td>0x680</td>
<td>0x6b8</td>
<td>0x40</td>
</tr>
<tr>
<td>83</td>
<td>0x8c0</td>
<td>0x8f0</td>
<td>0x40</td>
<td>0x6c0</td>
<td>0x6f8</td>
<td>0x40</td>
</tr>
<tr>
<td>84</td>
<td>0x900</td>
<td>0x930</td>
<td>0x40</td>
<td>0x700</td>
<td>0x738</td>
<td>0x40</td>
</tr>
<tr>
<td>85</td>
<td>0x940</td>
<td>0x970</td>
<td>0x40</td>
<td>0x740</td>
<td>0x778</td>
<td>0x40</td>
</tr>
<tr>
<td>86</td>
<td>0x980</td>
<td>0x9b0</td>
<td>0x40</td>
<td>0x780</td>
<td>0x7b8</td>
<td>0x40</td>
</tr>
<tr>
<td>87</td>
<td>0x9c0</td>
<td>0x9f0</td>
<td>0x40</td>
<td>0x7c0</td>
<td>0x7f8</td>
<td>0x40</td>
</tr>
<tr>
<td>88</td>
<td>0xa00</td>
<td>0xa30</td>
<td>0x40</td>
<td>0x800</td>
<td>0x838</td>
<td>0x40</td>
</tr>
<tr>
<td>89</td>
<td>0xa40</td>
<td>0xa70</td>
<td>0x40</td>
<td>0x840</td>
<td>0x878</td>
<td>0x40</td>
</tr>
<tr>
<td>90</td>
<td>0xa80</td>
<td>0xab0</td>
<td>0x40</td>
<td>0x880</td>
<td>0x8b8</td>
<td>0x40</td>
</tr>
<tr>
<td>91</td>
<td>0xac0</td>
<td>0xaf0</td>
<td>0x40</td>
<td>0x8c0</td>
<td>0x8f8</td>
<td>0x40</td>
</tr>
<tr>
<td>92</td>
<td>0xb00</td>
<td>0xb30</td>
<td>0x40</td>
<td>0x900</td>
<td>0x938</td>
<td>0x40</td>
</tr>
<tr>
<td>93</td>
<td>0xb40</td>
<td>0xb70</td>
<td>0x40</td>
<td>0x940</td>
<td>0x978</td>
<td>0x40</td>
</tr>
<tr>
<td>94</td>
<td>0xb80</td>
<td>0xbb0</td>
<td>0x40</td>
<td>0x980</td>
<td>0x9b8</td>
<td>0x40</td>
</tr>
<tr>
<td>95</td>
<td>0xbc0</td>
<td>0xbf0</td>
<td>0x40</td>
<td>0x9c0</td>
<td>0x9f8</td>
<td>0x40</td>
</tr>
<tr>
<td>96</td>
<td>0xc00</td>
<td>0xc30</td>
<td>0x40</td>
<td>0xa00</td>
<td>0xbf8</td>
<td>0x200</td>
</tr>
<tr>
<td>97</td>
<td>0xc40</td>
<td>0xdf0</td>
<td>0x1c0</td>
<td>0xc00</td>
<td>0xdf8</td>
<td>0x200</td>
</tr>
<tr>
<td>98</td>
<td>0xe00</td>
<td>0xff0</td>
<td>0x200</td>
<td>0xe00</td>
<td>0xff8</td>
<td>0x200</td>
</tr>
<tr>
<td>99</td>
<td>0x1000</td>
<td>0x11f0</td>
<td>0x200</td>
<td>0x1000</td>
<td>0x11f8</td>
<td>0x200</td>
</tr>
<tr>
<td>100</td>
<td>0x1200</td>
<td>0x13f0</td>
<td>0x200</td>
<td>0x1200</td>
<td>0x13f8</td>
<td>0x200</td>
</tr>
<tr>
<td>101</td>
<td>0x1400</td>
<td>0x15f0</td>
<td>0x200</td>
<td>0x1400</td>
<td>0x15f8</td>
<td>0x200</td>
</tr>
<tr>
<td>102</td>
<td>0x1600</td>
<td>0x17f0</td>
<td>0x200</td>
<td>0x1600</td>
<td>0x17f8</td>
<td>0x200</td>
</tr>
<tr>
<td>103</td>
<td>0x1800</td>
<td>0x19f0</td>
<td>0x200</td>
<td>0x1800</td>
<td>0x19f8</td>
<td>0x200</td>
</tr>
<tr>
<td>104</td>
<td>0x1a00</td>
<td>0x1bf0</td>
<td>0x200</td>
<td>0x1a00</td>
<td>0x1bf8</td>
<td>0x200</td>
</tr>
<tr>
<td>105</td>
<td>0x1c00</td>
<td>0x1df0</td>
<td>0x200</td>
<td>0x1c00</td>
<td>0x1df8</td>
<td>0x200</td>
</tr>
<tr>
<td>106</td>
<td>0x1e00</td>
<td>0x1ff0</td>
<td>0x200</td>
<td>0x1e00</td>
<td>0x1ff8</td>
<td>0x200</td>
</tr>
<tr>
<td>107</td>
<td>0x2000</td>
<td>0x21f0</td>
<td>0x200</td>
<td>0x2000</td>
<td>0x21f8</td>
<td>0x200</td>
</tr>
<tr>
<td>108</td>
<td>0x2200</td>
<td>0x23f0</td>
<td>0x200</td>
<td>0x2200</td>
<td>0x23f8</td>
<td>0x200</td>
</tr>
<tr>
<td>109</td>
<td>0x2400</td>
<td>0x25f0</td>
<td>0x200</td>
<td>0x2400</td>
<td>0x25f8</td>
<td>0x200</td>
</tr>
<tr>
<td>110</td>
<td>0x2600</td>
<td>0x27f0</td>
<td>0x200</td>
<td>0x2600</td>
<td>0x27f8</td>
<td>0x200</td>
</tr>
<tr>
<td>111</td>
<td>0x2800</td>
<td>0x29f0</td>
<td>0x200</td>
<td>0x2800</td>
<td>0x29f8</td>
<td>0x200</td>
</tr>
<tr>
<td>112</td>
<td>0x2a00</td>
<td>0x2ff0</td>
<td>0x600</td>
<td>0x2a00</td>
<td>0x2ff8</td>
<td>0x600</td>
</tr>
<tr>
<td>113</td>
<td>0x3000</td>
<td>0x3ff0</td>
<td>0x1000</td>
<td>0x3000</td>
<td>0x3ff8</td>
<td>0x1000</td>
</tr>
<tr>
<td>114</td>
<td>0x4000</td>
<td>0x4ff0</td>
<td>0x1000</td>
<td>0x4000</td>
<td>0x4ff8</td>
<td>0x1000</td>
</tr>
<tr>
<td>115</td>
<td>0x5000</td>
<td>0x5ff0</td>
<td>0x1000</td>
<td>0x5000</td>
<td>0x5ff8</td>
<td>0x1000</td>
</tr>
<tr>
<td>116</td>
<td>0x6000</td>
<td>0x6ff0</td>
<td>0x1000</td>
<td>0x6000</td>
<td>0x6ff8</td>
<td>0x1000</td>
</tr>
<tr>
<td>117</td>
<td>0x7000</td>
<td>0x7ff0</td>
<td>0x1000</td>
<td>0x7000</td>
<td>0x7ff8</td>
<td>0x1000</td>
</tr>
<tr>
<td>118</td>
<td>0x8000</td>
<td>0x8ff0</td>
<td>0x1000</td>
<td>0x8000</td>
<td>0x8ff8</td>
<td>0x1000</td>
</tr>
<tr>
<td>119</td>
<td>0x9000</td>
<td>0x9ff0</td>
<td>0x1000</td>
<td>0x9000</td>
<td>0x9ff8</td>
<td>0x1000</td>
</tr>
<tr>
<td>120</td>
<td>0xa000</td>
<td>0xfff0</td>
<td>0x6000</td>
<td>0xa000</td>
<td>0xfff8</td>
<td>0x6000</td>
</tr>
<tr>
<td>121</td>
<td>0x10000</td>
<td>0x17ff0</td>
<td>0x8000</td>
<td>0x10000</td>
<td>0x17ff8</td>
<td>0x8000</td>
</tr>
<tr>
<td>122</td>
<td>0x18000</td>
<td>0x1fff0</td>
<td>0x8000</td>
<td>0x18000</td>
<td>0x1fff8</td>
<td>0x8000</td>
</tr>
<tr>
<td>123</td>
<td>0x20000</td>
<td>0x27ff0</td>
<td>0x8000</td>
<td>0x20000</td>
<td>0x27ff8</td>
<td>0x8000</td>
</tr>
<tr>
<td>124</td>
<td>0x28000</td>
<td>0x3fff0</td>
<td>0x18000</td>
<td>0x28000</td>
<td>0x3fff8</td>
<td>0x18000</td>
</tr>
<tr>
<td>125</td>
<td>0x40000</td>
<td>0x7fff0</td>
<td>0x40000</td>
<td>0x40000</td>
<td>0x7fff8</td>
<td>0x40000</td>
</tr>
<tr>
<td>126</td>
<td>0x80000</td>
<td>inf</td>
<td></td>
<td>0x80000</td>
<td>inf</td>
<td></td>
</tr>
</tbody></table>
<p>对于 fast bin ，在 <code>malloc_state</code> 又单独定义了一个 <code>fastbinsY</code> 的结构维护。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">malloc_chunk</span> *mfastbinptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This is in malloc_state.</span></span><br><span class="line"><span class="comment">    /* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></div>

<p>由于 fast bin 为单链表结构，因此数组中一个指针就可以维护一个 <code>bin</code> 。结构如图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/2c72c332b07fc4f69047f8afdd7dff79.png"
                     
                ></p>
<h3 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h3><p>为了避免大部分时间花在了合并、分割以及中间检查的过程中影响效率，因此 ptmalloc 中专门设计了 fast bin。</p>
<p>fast bin 采用单链表形式，结构如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4aab9d846457a48f637c2d5a244af954.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>fast bin 有如下性质：</p>
<ul>
<li>由于采用单链表结构，fast bin 采取 LIFO 策略。</li>
<li>每个 fast bin 中维护的 chunk 大小确定，并且 fast bin 维护的最大的 <code>chunk</code> 为 128 字节（64位），因此不超过 0x80（<code>chunk</code> 大小）的内存释放会进入 fast bin 。</li>
<li>fast bin 范围的 <code>chunk</code> <strong>下一个相邻 <code>chunk</code></strong> 的 <code>PREV_INUSE</code> 始终被置为 1。因此它们不会和其它被释放的 <code>chunk</code> 合并。除非调用 <code>malloc_consolidate</code> 函数。</li>
</ul>
<p>安全检查：</p>
<ul>
<li><p><code>size</code>：在 <code>malloc()</code> 函数分配 fastbin size 范围的 <code>chunk</code> 时，若是对应的 <code>fastbin</code> 中有空闲 <code>chunk</code>，在取出前会检查其 <code>size</code> 域与对应下标是否一致，不会检查标志位，若否便会触发<code>abort</code> 。</p>
</li>
<li><p>double free：在 <code>free()</code> 函数中会对 fast bin 链表的头结点进行检查，若将要被放入 fast bin 中的 <code>chunk</code> 与对应下标的链表的头结点为同一 <code>chunk</code>，则会触发 <code>abort</code> 。</p>
</li>
<li><p>Safe linking 机制（only glibc2.32 and up）：自 glibc 2.32 起引入了 safe-linking 机制，其核心思想是在链表上的 <code>chunk</code> 中并不直接存放其所连接的下一个 <code>chunk</code> 的地址，而是存放下一个 <code>chunk</code> 的地址与【 <code>fd</code> 指针自身地址右移 12位】所异或得的值，使得攻击者在得知该 <code>chunk</code> 的地址之前无法直接利用其构造任意地址写。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure></div>

<p>需要注意的是 fast bin 的入口节点存放的仍是未经异或的 <code>chunk</code> 地址。<br>另外第一个加入 fast bin 的 <code>chunk</code> 的 <code>fd</code> 字段可以泄露堆地址（右移 12 位）。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);</span><br><span class="line">  fb = &amp;fastbin (av, idx);</span><br><span class="line">  mchunkptr old = *fb, old2;</span><br><span class="line">  ...</span><br><span class="line">p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class="line">*fb = p;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="Small-Bin"><a href="#Small-Bin" class="headerlink" title="Small Bin"></a>Small Bin</h3><p>small bin 采用双向链表，结构如下图所示。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/86163676dc9adde0954c070bc0eeef6a.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>small bin 有如下性质：</p>
<ul>
<li>small bins 中每个 <code>bin</code> 对应的链表采用 FIFO 的规则。</li>
<li>每个 small bin 维护的 <code>chunk</code> 大小确定，并且 small bin 维护的最大的 <code>chunk</code> 为 1008 字节（64位），即 0x3f0 的 <code>chunk</code> 大小。</li>
</ul>
<h3 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h3><p>large bins 中一共包括 63 个 <code>bin</code>，每个 <code>bin</code> 中的 <code>chunk</code> 的大小不一致，而是处于一定区间范围内。large bin 的结构如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/f3b03f72266a82c4dfe82b7dda5bcfed.png"
                     
                ><br>关于 <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 的机制，这里以 <code>fd_nextsize</code> 为例：</p>
<ul>
<li><code>fd_nextsize</code> 和 <code>bk_nextsize</code> 与 <code>bins</code> 数组没有连接关系（这就解释了为什么 <code>bins</code> 上 没有体现 <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 结构）。</li>
<li>large bin 里的 <code>chunk</code> 在 <code>fd</code> 指针指向的方向上按照 <code>chunk</code> 大小降序排序。</li>
<li>当 large bin 里有一个 <code>chunk</code> 时， <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 指向自己（如上面 large bin 的结构图所示）。</li>
<li>当 large bin 里同一大小的 <code>chunk</code> 有多个时，只有相同大小 <code>chunk</code> 中的第一个的 <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 指针有效，其余的 <code>chunk</code> 的 <code>fd_nextsize</code> 和 <code>bk_nextsize</code>  设为 NULL 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/8e05f44b0395a5b18b622a0707184874.png"
                     
                ></li>
<li>large bin 中有多个不同大小的 <code>chunk</code> 时 <code>fd_nextsize</code> 连接比它小的第一个 <code>chunk</code> ，<code>bk_nextsize</code> 就是把 <code>fd_nextsize</code> 反过来连到对应结构上。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/64b10a726bbcc36d3ec99900a9e8237e.png"
                     
                ></li>
<li>large bin 最小的一组 <code>chunk</code> 中的第一个 <code>chunk</code> 的 <code>fd_nextsize</code> 连接的是最大的 <code>chunk</code>，最大的 <code>chunk</code> 的 <code>bk_nextsize</code> 相反。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/0d80fe66f57e24c95ac69650b80f81c7.png"
                     
                ></li>
</ul>
<h3 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h3><p>unsorted bin 可以视为空闲 <code>chunk</code> 回归其所属 <code>bin</code> 之前的缓冲区。像 small bin 一样采用双向链表维护。<code>chunk</code> 大小乱序。</p>
<h2 id="Top-Chunk"><a href="#Top-Chunk" class="headerlink" title="Top Chunk"></a>Top Chunk</h2><p>程序第一次进行 <code>malloc</code> 的时候，<code>heap</code> 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 <code>chunk</code> 。这个 <code>chunk</code> 不属于任何一个 <code>bin</code> ，它的作用在于当所有的 <code>bin</code> 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 <code>heap</code> 进行扩展后再进行分配。在 <code>main_arena</code> 中通过 <code>sbrk</code> 扩展 <code>heap</code>，而在 <code>thread arena</code> 中通过 <code>mmap</code> 分配新的 <code>heap </code>。<br>需要注意的是，top chunk 的 <code>prev_inuse</code> 比特位始终为 1，否则其前面的 <code>chunk</code> 就会被合并到 top chunk 中。</p>
<h2 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h2><p>在用户使用 <code>malloc</code> 请求分配内存时，ptmalloc2 找到的 <code>chunk</code> 可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为 last remainder chunk ，unsort bin 也会存这一块。top chunk 分割剩下的部分不会作为 <code>last_remainder</code> 。</p>
<h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><p><code>tcache</code> 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术，目的是提升堆管理的性能，与 fast bin 类似。<code>tcache</code> 引入了两个新的结构体，<code>tcache_entry</code> 和 <code>tcache_perthread_struct</code> 。</p>
<p><code>tcache_entry</code> 定义如下：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tcache_entry</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tcache_entry</span> *next;</span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure></div>

<p><code>tcache_entry</code> 用于链接空闲的 <code>chunk</code> 结构体，其中的 <code>next</code> 指针指向下一个大小相同的 chunk。需要注意的是这里的 <code>next</code> 指向 <code>chunk</code> 的 user data，而 fast bin 的 <code>fd</code> 指向 <code>chunk</code> 开头的地址。而且，<code>tcache_entry</code> 会复用空闲 <code>chunk</code> 的 user data 部分。</p>
<p><code>tcache_perthread_struct</code> 定义如下：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tcache_perthread_struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></div>

<p>对应结构如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/b095b05bdaa8e1675787b765e1f4b332.png"
                     
                ><br>每个 thread 都会维护一个 <code>tcache_perthread_struct</code> ，它是整个 <code>tcache</code> 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code> 项 <code>tcache_entry</code>。这个结构在 <code>tcache_init</code> 函数中被初始化在堆上，大小为 0x250（高版本为 0x290）。其中数据部分前 0x40 为 <code>counts</code> ，剩下的为 <code>entries</code> 结构。如果能控制这个堆块就可以控制整个 <code>tcache</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<p><code>tcache_perthread_struct</code> 中的 <code>tcache_entry</code> 用单向链表的方式链接了相同大小的处于空闲状态（<code>free</code> 后）的 <code>chunk</code>，这一点上和 fast bin 很像。</p>
<p>另外与 fast bin 相同的是释放进入 <code>tcache</code> 的 <code>chunk</code> 的下一个相邻 <code>chunk</code> 的 <code>PREV_INUSE</code> 位不清零。</p>
<p><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 <code>chunk</code> 的数目，每条链上最多可以有 7 个 <code>chunk</code> 。注意指针指向的位置是 <code>fd</code> 指针，这一点与 fast bin 不同。</p>
<p>结构如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit-basic-knowlege/images/06577694365bfca457c02a0664f6d368.png"
                     
                ><br>stash 机制：<br>当申请的大小在 <code>tcache</code> 范围的 <code>chunk</code> 在 <code>tcache</code> 中没有，此时 ptmalloc 会在其他 <code>bin</code> 里面找，如果找到了会将该 <code>chunk</code> 放到 <code>tcache</code> 中，直到 <code>tcache</code> 填满，最后直接返回找到的 <code>chunk</code> 或是从 <code>tcache</code> 中取出并返回。</p>
<p>安全检查：</p>
<ul>
<li>tcache key（only libc2.29 and up）：自 glibc2.29 版本起 <code>tcache</code> 新增了一个 key 字段，该字段位于 <code>chunk</code> 的 bk 字段，值为 <code>tcache</code> 结构体的地址，若 <code>free()</code> 检测到 <code>chunk-&gt;bk == tcache</code> 则会遍历 <code>tcache</code> 查找对应链表中是否有该 <code>chunk</code><br>最新版本的一些老 glibc （如新版2.27等）也引入了该防护机制</li>
<li>Safe linking 机制（only glibc2.32 and up）：与 fast bin 类似。<br>绕过方法：<ul>
<li>在 <code>tcache</code> 的一个 <code>entry</code> 中放入第一个 <code>chunk</code> 时，其同样会对该 <code>entry</code> 中的 “<code>chunk</code>” （NULL）进行异或运算后写入到将放入 <code>tcache</code> 中的 <code>chunk</code> 的 <code>fd</code> 字段，若是我们能够打印该 free chunk 的 <code>fd</code> 字段，便能够直接获得未经异或运算的堆上相关地址（右移 12 位）</li>
<li>在 <code>tcache-&gt;entry</code> 中存放的仍是未经加密过的地址，若是我们能够控制 <code>tcache</code> 管理器则仍可以在不知道堆相关地址时进行任意地址写。</li>
</ul>
</li>
</ul>
<h1 id="关键过程"><a href="#关键过程" class="headerlink" title="关键过程"></a>关键过程</h1><p>仅简要介绍大致过程，具体细节最好还是查看 libc 源码。</p>
<h2 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h2><ul>
<li>首先在 _libc_malloc 函数中先判断 __malloc_hook 函数指针是否为空，如果不为空则调用 __malloc_hook 函数。</li>
<li>如果存在 tcache 且有相应大小的 chunk 则将其从 tcache 中取出并返回结果。</li>
<li>调用 _int_malloc 函数。<ul>
<li>首先把申请的内存的字节数转化为 chunk 的大小。</li>
<li>如果 arena 未初始化 ，则调用 sysmalloc 向系统申请内存，然后将获取的 chunk 返回。</li>
<li>如果申请的 chunk 大小不超过 fast bin 的最大值，则尝试从对应的 fast bin 的头部获取 chunk 。在获取到 chunk 后，如果对应的 fast bin 还有 chunk 并且大小在 tcache 范围就将它们依次从头结点取出放到 tcache 中，直到把 tcache 放满。最后将申请到的 chunk 返回。</li>
<li>如果申请的 chunk 在 small bin 大小范围则进行与 fast bin 一样的操作，只不过这次取 chunk 是依次从链表尾部取。</li>
<li>如果申请的 chunk 在 large bin 大小范围则调用 malloc_consolidate 函数将 fast bin 中的 chunk 合并后放入 unsorted bin 。</li>
<li>循环进行如下操作：<ul>
<li>循环取 unsorted bin 最后一个 chunk 。<ul>
<li>如果用户的请求为 small bin chunk，那么我们首先考虑 last remainder，如果当前 chunk 是 last remainder ，且 last remainder 是 unsorted bin 中的唯一一个 chunk ， 并且 last remainder 的大小分割后还可以作为一个 chunk，则从 last reminder 中切下一块内存返回。</li>
<li>如果 chunk 的大小恰好等于申请的 chunk 大小，则如果该内存大小在 tcache 范围且 tcache 没有满，则先将其放入 tcache，之后会考虑从 tcache 中找 chunk 。否则直接将找到的 chunk 返回。</li>
<li>根据 chunk 的大小将其放入 small bin 或 large bin 中。对于 small bin 直接从链表头部加入；对于 large bin，首先特判加入链表尾部的情况，如果不在链表尾部则从头部遍历找位置，如果 large bin 中有与加入的 chunk 大小相同的 chunk ，则加到第一个相等 chunk 后面，否则加到合适位置后还需要更新 nextsize 指针。</li>
<li>尝试从 tcache 找 chunk 。</li>
<li>如果循环超过 10000 次则跳出循环。</li>
</ul>
</li>
<li>尝试从 tcache 找 chunk 。</li>
<li>如果申请 chunk 大小不在 small bin 范围，则从后往前遍历对应 large bin ，找到第一个不小于申请 chunk 大小的 chunk 。为了 unlink 时避免修改 nextsize 的操作，如果存在多个合适的 chunk 则选择第二个 chunk 。如果选取的 chunk 比申请的 chunk 大不少于 MINSIZE ，则需要将多出来的部分切出来作为 remainder ，并将其加入 unsorted bin 头部。然后将获取的 chunk 返回。</li>
<li>找一个 chunk 范围比申请 chunk 大的非空 bin 里面找最后一个 chunk ，这个过程用 binmap 优化，同时也可以更新 binmap 的状态。这个 chunk 上切下所需的 chunk ，剩余部分放入 unsorted bin 头部。然后将获取的 chunk 返回。</li>
<li>如果 top chunk 切下所需 chunk 后剩余部分还是不小于 MINSIZE 则从top chunk 上切下所需 chunk 返回。</li>
<li>如果 fast bins 还有 chunk 则调用 malloc_consolidate 合并 fast bin 中的 chunk 并放入 unsorted bin 中，然后继续循环。</li>
<li>最后 sysmalloc 系统调用向操作系统申请内存分配 chunk 。<ul>
<li>如果 arena 没有初始化或者申请的内存大于 mp_.mmap_threshold，并且 mmap 的次数小于最大值，则使用 mmap 申请内存。然后检查一下是否 16 字节对齐然后更新 mmap 次数和 mmap 申请过的最大内存大小后就将 chunk 返回。</li>
<li>如果 arena 没有初始化就返回 0</li>
<li>对之前的 top chunk 进行检查，如果是 dummy top 的话，因为是用 unsorted bin 表示的，因此 top chunk 的大小需要是 0 。否则堆的大小应该不小于 MINSIZE，并且前一个堆块应该处于使用中，并且堆的结束地址应该是页对齐的，由于页对齐的大小默认是 0x1000，所以低 12 个比特需要为 0。除此之外，top chunk 大小必须比申请 chunk 大小加上 MINSIZE 要小。</li>
<li>如果 arena 不是 main arena<ul>
<li>尝试将 top chunk 所在的 heap 扩展大小，如果成功则更新 arena 记录的内存总大小 system_mem 和 top chunk 大小。</li>
<li>尝试申请一个新的 heap 。设置新的 heap 以及 arena 的参数并且将原来的 top chunk 先从尾部切下 2 个 0x10 大小的 chunk ，剩余部分如果不小于 MINSIZE 则将其释放掉。</li>
<li>否则，如果前面没有执行到 mmap 申请 chunk 的分支就尝试执行。</li>
</ul>
</li>
<li>如果 arena 是 main arena<ul>
<li>计算需要获取的内存大小。需要获取的内存大小等于申请的 chunk 大小加上 0x20000 和 MINSIZE 。如果堆空间连续，则可以再减去原来内存的大小。然后将需要获取的内存大小与页大小对齐。</li>
<li>sbrk 扩展内存如果成功则会尝试调用一个 hook 函数，否则 mmap 申请内存，然后 brk 移到申请的内存处并设置堆不连续参数。</li>
<li>如果成功获取到内存，则更新 arena 记录的内存总大小 system_mem 和 sbrk_base。之后对一系列的情况进行处理，在这期间，之前的 top chunk 会被从尾部切下两个 0x10 大小的chunk，剩余部分如果不小于 MINSIZE 则将其释放掉。</li>
</ul>
</li>
<li>最后从新获取的 top chunk 上切下所需的 chunk 并返回。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h2><ul>
<li>首先在 __libc_free 函数中先判断 __free_hook 函数指针是否为空，如果不为空则调用 __free_hook 函数。</li>
<li>如果 chunk 是 mmap 申请的，则调用 munmap_chunk 释放。</li>
<li>调用 _int_free 函数 <ul>
<li>如果释放的 chunk 大小在 tcache 范围且对应的 tcache 没有满，则直接放到 tcache 中然后返回。</li>
<li>如果在 fast bin 范围则加入到 fast bin 头部并返回。</li>
<li>如果不是 mmap 申请的内存<ul>
<li>如果与释放 chunk 相邻的前一个 chunk 是空闲的，则将前一个 chunk 从 bin 中取出和释放 chunk 合并。</li>
<li>如果与释放 chunk 相邻的后一个 chunk 不是 top chunk<ul>
<li>如果与释放 chunk 相邻的后一个 chunk 是空闲的，则将其从 bin 中取出和释放 chunk 合并，否则将其 PREV_INUSE 位置 0</li>
<li>将释放的 chunk 加入到 unsorted bin 头部。</li>
</ul>
</li>
<li>否则将其合并到 top chunk</li>
<li>如果合并后的 chunk 的大小大于FASTBIN_CONSOLIDATION_THRESHOLD 就向系统返还内存</li>
</ul>
</li>
<li>否则调用 munmap_chunk 释放 chunk</li>
</ul>
</li>
</ul>
<h1 id="源码注释（glibc-2-23）"><a href="#源码注释（glibc-2-23）" class="headerlink" title="源码注释（glibc-2.23）"></a>源码注释（glibc-2.23）</h1><h2 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="comment">//用于保存指向分配区的指针</span></span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line">  <span class="comment">//用于保存获得的mem指针:chunk_addr + 0x10</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取 __malloc_hook</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="comment">// 如果 __malloc_hook 不为 NULL 则调用 __malloc_hook ，参数为申请的内存大小。</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 获取本线程对应的 thread_arena ，即 malloc_state 结构体。</span></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">// 调用 _int_malloc 申请内存</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="comment">// 如果 ar_ptr 不为 NULL 且内存没有申请成功则重新申请一次内存</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      <span class="comment">//获取下一个分配区</span></span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      <span class="comment">//再次调用_int_malloc</span></span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//如果此时分配区指针不为空,释放分配区,这里分配已经结束了</span></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">  <span class="comment">// 确保只有 3 种情况，即要么没有申请成功，要么是通过 mmap 获取的内存，要么内存是从当前线程对应的 thread_arena 管理的内存中获取的。</span></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="comment">// 返回申请到的内存。</span></span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="libc-calloc"><a href="#libc-calloc" class="headerlink" title="__libc_calloc"></a>__libc_calloc</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_calloc (<span class="type">size_t</span> n, <span class="type">size_t</span> elem_size)</span><br><span class="line">&#123;</span><br><span class="line">  mstate av;</span><br><span class="line">  mchunkptr oldtop, p;</span><br><span class="line">  INTERNAL_SIZE_T bytes, sz, csz, oldtopsize;</span><br><span class="line">  <span class="type">void</span> *mem;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> clearsize;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> nclears;</span><br><span class="line">  INTERNAL_SIZE_T *d;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* size_t is unsigned so the behavior on overflow is defined.  */</span></span><br><span class="line">  <span class="comment">// 将需要申请的内存大小转换为以字节为单位</span></span><br><span class="line">  bytes = n * elem_size;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HALF_INTERNAL_SIZE_T \</span></span><br><span class="line"><span class="meta">  (((INTERNAL_SIZE_T) 1) &lt;&lt; (8 * sizeof (INTERNAL_SIZE_T) / 2))</span></span><br><span class="line">  /</span><br><span class="line">  <span class="comment">// 如果 n 和 elem_size 中的任何一个不小于 HALF_INTERNAL_SIZE_T</span></span><br><span class="line">  <span class="comment">// 以 64 位为例，HALF_INTERNAL_SIZE_T = 2^32</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((n | elem_size) &gt;= HALF_INTERNAL_SIZE_T, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 判断 bytes 是否溢出</span></span><br><span class="line">      <span class="keyword">if</span> (elem_size != <span class="number">0</span> &amp;&amp; bytes / elem_size != n)</span><br><span class="line">        &#123;</span><br><span class="line">          __set_errno (ENOMEM);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 获取 __malloc_hook</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">    atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="comment">// 如果 __malloc_hook 不为 NULL 则调用 __malloc_hook，参数为申请内存的大小。</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      sz = bytes;</span><br><span class="line">      mem = (*hook)(sz, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">memset</span> (mem, <span class="number">0</span>, sz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  sz = bytes;</span><br><span class="line"></span><br><span class="line">  arena_get (av, sz);</span><br><span class="line">  <span class="keyword">if</span> (av)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check if we hand out the top chunk, in which case there may be no</span></span><br><span class="line"><span class="comment">   need to clear. */</span></span><br><span class="line">   <span class="comment">// 获取 top chunk 和 top chunk 的大小，这里的 top chunk 的大小是指 top chunk 头之后可以“控制”的的内存大小，具体看后面的解释。</span></span><br><span class="line">   <span class="comment">// 获取这些的原因是无论是 main_arena 控制的 heap 区域通过 sbrk 扩展还是非 main_arena 区域通过对 heap_info 向后扩展受保护的内存区域，</span></span><br><span class="line">   <span class="comment">// 新扩展的内存初始值为 0，即这些内存不需要清空，因此后面会将需要清零的内存大小减去和这部分内存重合的区域，提升程序效率。</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CLEARS</span></span><br><span class="line">      oldtop = top (av);</span><br><span class="line">      oldtopsize = chunksize (top (av));</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> MORECORE_CLEARS &lt; 2</span></span><br><span class="line">      <span class="comment">/* Only newly allocated memory is guaranteed to be cleared.  */</span></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena &amp;&amp;</span><br><span class="line">    oldtopsize &lt; mp_.sbrk_base + av-&gt;max_system_mem - (<span class="type">char</span> *) oldtop)</span><br><span class="line">  <span class="comment">// 对于 main_arena 管理的内存，top chunk 后需要清空的内存大小为 top chunk 到原先 heap 区域末尾位置</span></span><br><span class="line">  oldtopsize = (mp_.sbrk_base + av-&gt;max_system_mem - (<span class="type">char</span> *) oldtop);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 对于非 main_arena 管理的内存，top chunk 后需要清空的内存大小为 top chunk 到原先 heap_info 受保护区域末尾位置</span></span><br><span class="line">    heap_info *heap = heap_for_ptr (oldtop);</span><br><span class="line">    <span class="keyword">if</span> (oldtopsize &lt; (<span class="type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="type">char</span> *) oldtop)</span><br><span class="line">      oldtopsize = (<span class="type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="type">char</span> *) oldtop;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* No usable arenas.  */</span></span><br><span class="line">      <span class="comment">// av 为 NULL ，那么之后 _int_malloc 会直接 mmap 获取内存，而 mmap 获取的内存初始值为 0，因此不需要清零。</span></span><br><span class="line">      oldtop = <span class="number">0</span>;</span><br><span class="line">      oldtopsize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 调用 _int_malloc 获取内存</span></span><br><span class="line">  mem = _int_malloc (av, sz);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同 __libc_malloc 的 3 种情况</span></span><br><span class="line">  assert (!mem || chunk_is_mmapped (mem2chunk (mem)) ||</span><br><span class="line">          av == arena_for_chunk (mem2chunk (mem)));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span> &amp;&amp; av != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_calloc_retry, <span class="number">1</span>, sz);</span><br><span class="line">      av = arena_get_retry (av, sz);</span><br><span class="line">      mem = _int_malloc (av, sz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocation failed even after a retry.  */</span></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Two optional cases in which clearing not necessary */</span></span><br><span class="line">  <span class="comment">// 如果是 mmap 获取的不需要清零，因此只要 chunk 的 size 字段中的 IS_MMAPPED 位置 1 就不会清零。</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">memset</span> (mem, <span class="number">0</span>, sz);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> mem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  csz = chunksize (p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CLEARS</span></span><br><span class="line">  <span class="comment">// 如果是从 top chunk 上切下来的则只需要清零 top chunk 范围的内存。</span></span><br><span class="line">  <span class="keyword">if</span> (perturb_byte == <span class="number">0</span> &amp;&amp; (p == oldtop &amp;&amp; csz &gt; oldtopsize))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* clear only the bytes from non-freshly-sbrked memory */</span></span><br><span class="line">      csz = oldtopsize;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Unroll clear of &lt;= 36 bytes (72 if 8byte sizes).  We know that</span></span><br><span class="line"><span class="comment">     contents have an odd number of INTERNAL_SIZE_T-sized words;</span></span><br><span class="line"><span class="comment">     minimally 3.  */</span></span><br><span class="line">  <span class="comment">// 清空内存，包括下一个 chunk 的 prev_size 。    </span></span><br><span class="line">  d = (INTERNAL_SIZE_T *) mem;</span><br><span class="line">  clearsize = csz - SIZE_SZ;</span><br><span class="line">  nclears = clearsize / <span class="keyword">sizeof</span> (INTERNAL_SIZE_T);</span><br><span class="line">  assert (nclears &gt;= <span class="number">3</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (nclears &gt; <span class="number">9</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memset</span> (d, <span class="number">0</span>, clearsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(d + <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">      *(d + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">      *(d + <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (nclears &gt; <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          *(d + <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">          *(d + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (nclears &gt; <span class="number">6</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              *(d + <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line">              *(d + <span class="number">6</span>) = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">if</span> (nclears &gt; <span class="number">8</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  *(d + <span class="number">7</span>) = <span class="number">0</span>;</span><br><span class="line">                  *(d + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="libc-realloc"><a href="#libc-realloc" class="headerlink" title="__libc_realloc"></a>__libc_realloc</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_realloc (<span class="type">void</span> *oldmem, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  INTERNAL_SIZE_T nb;         <span class="comment">/* padded request size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *newp;             <span class="comment">/* chunk to return */</span></span><br><span class="line">  <span class="comment">// 调用 __realloc_hook</span></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">void</span> *, <span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">    atomic_forced_read (__realloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">  <span class="comment">//如果 bytes 为 0 则相当于 free(oldmem)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> REALLOC_ZERO_BYTES_FREES</span></span><br><span class="line">  <span class="keyword">if</span> (bytes == <span class="number">0</span> &amp;&amp; oldmem != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __libc_free (oldmem); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">//   如果 oldmem 为 NULL 相当于 malloc(bytes)</span></span><br><span class="line">  <span class="comment">/* realloc of null is supposed to be same as malloc */</span></span><br><span class="line">  <span class="keyword">if</span> (oldmem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __libc_malloc (bytes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 oldmem 对应的 chunk 的指针和大小</span></span><br><span class="line">  <span class="comment">/* chunk corresponding to oldmem */</span></span><br><span class="line">  <span class="type">const</span> mchunkptr oldp = mem2chunk (oldmem);</span><br><span class="line">  <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">const</span> INTERNAL_SIZE_T oldsize = chunksize (oldp);</span><br><span class="line">  <span class="comment">// 寻找 oldp 对应的 arena</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (oldp))</span><br><span class="line">    ar_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ar_ptr = arena_for_chunk (oldp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">  <span class="comment">// 检查 oldp + oldsize 是否超过地址上限</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) oldp &gt; (<span class="type">uintptr_t</span>) -oldsize, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (oldp), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;realloc(): invalid pointer&quot;</span>, oldmem,</span><br><span class="line">           ar_ptr);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 检查如果申请最小的 chunk 是否会超过地址上限 </span></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是 mmap 得到的内存会单独处理</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (oldp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> *newmem;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MREMAP</span></span><br><span class="line">      <span class="comment">// 如果是 mmap 得到的内存则利用 mremap 系统调用实现 realloc。</span></span><br><span class="line">      <span class="comment">// mremap 会重新分配一块内存并将之前的数据复制到新的内存上。</span></span><br><span class="line">      newp = mremap_chunk (oldp, nb);</span><br><span class="line">      <span class="keyword">if</span> (newp)</span><br><span class="line">        <span class="keyword">return</span> chunk2mem (newp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Note the extra SIZE_SZ overhead. */</span></span><br><span class="line">      <span class="keyword">if</span> (oldsize - SIZE_SZ &gt;= nb)</span><br><span class="line">        <span class="keyword">return</span> oldmem;                         <span class="comment">/* do nothing */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Must alloc, copy, free. */</span></span><br><span class="line">      <span class="comment">// 如果 mremap 获取不到所需的内存则通过 malloc 获取内存，并将原先内存的数据复制过来然后 munmap 将原先的内存释放掉</span></span><br><span class="line">      newmem = __libc_malloc (bytes);</span><br><span class="line">      <span class="keyword">if</span> (newmem == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;              <span class="comment">/* propagate failure */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">memcpy</span> (newmem, oldmem, oldsize - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">      munmap_chunk (oldp);</span><br><span class="line">      <span class="keyword">return</span> newmem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>) mutex_lock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 _int_realloc 调整内存</span></span><br><span class="line">  newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line">  <span class="comment">// 检查内存分配后的 3 种情况</span></span><br><span class="line">  assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (newp)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 _int_realloc 没有成功则尝试调用 _int_malloc 重新分配内存</span></span><br><span class="line">  <span class="keyword">if</span> (newp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Try harder to allocate memory in other arenas.  */</span></span><br><span class="line">      LIBC_PROBE (memory_realloc_retry, <span class="number">2</span>, bytes, oldmem);</span><br><span class="line">      newp = __libc_malloc (bytes);</span><br><span class="line">      <span class="comment">// 如果 malloc 成功则将数据拷贝后释放原先的内存</span></span><br><span class="line">      <span class="keyword">if</span> (newp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (newp, oldmem, oldsize - SIZE_SZ);</span><br><span class="line">          _int_free (ar_ptr, oldp, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line">  <span class="comment">// 调用 __free_hook ，参数是是否的内存的地址。</span></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line">  <span class="comment">// 如果是 mmapp 得到的内存单独处理</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">      <span class="comment">// 释放的内存大小如果大于 mmap_threshold 并且小于 DEFAULT_MMAP_THRESHOLD_MAX(0x20000)</span></span><br><span class="line">      <span class="comment">// 则更新 mmap_threshold 为释放内存的大小，trim_threshold 为两倍释放内存的大小。</span></span><br><span class="line">      <span class="comment">// 其中 mmap_threshold 是 sysmalloc 中 brk 和 mmap 两种系统调用获取内存的选择的边界值</span></span><br><span class="line">      <span class="comment">// trim_threshold 为是否 systrim 减少 ptmalloc 保留内存的参考值</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 调用 nummap 释放内存</span></span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 _int_free 释放内存</span></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> * _int_malloc (mstate av, <span class="type">size_t</span> bytes) &#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* 请求的chunk_size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* 对应bin数组中的index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* 指向对应bin的指针 */</span></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* 指向分配的chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* 分配的chunk的size */</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* 分配的chunk的bin的index */</span></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* 指向分割后剩下的那块chunk */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* 分割后剩下的那块chunk的size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* 一个block值 */</span></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* 用于链表操作 */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* 用于链表操作 */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;        <span class="comment">/* 报错字符串指针 */</span></span><br><span class="line">  checked_request2size (bytes, nb); <span class="comment">/* 计算chunk_size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="comment">//无可用的分配区,使用sysmalloc获取内存</span></span><br><span class="line">    <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="comment">//对数据用memset进行处理</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ())) &#123;</span><br><span class="line">    <span class="comment">//要分配的chunk大小小于global_max_fast则先从fastbin中寻找</span></span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    <span class="comment">//通过size获取在fastbin中对应的index</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    <span class="comment">//通过index获取分配区的fastbin中对应的bin</span></span><br><span class="line">    mchunkptr pp = *fb;</span><br><span class="line">    <span class="comment">//获取bin的首个chunk</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      victim = pp;</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) != victim);</span><br><span class="line">    <span class="comment">//将头指针的下一个chunk作为空闲chunk链表的头部,这里使用lock-free的技术实现.Lock-free算法的基础是CAS(Compareand-Swap)原子操作.避免了ABA问题</span></span><br><span class="line">    <span class="comment">//此时victim是该fb原来的首个chunk,或者为0</span></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//存在可使用的fastbin chunk</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">//检测该chunk的size是否符合该bin的index</span></span><br><span class="line">        errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">      errout:</span><br><span class="line">        malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      check_remalloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">      #if !MALLOC_DEBUG</span></span><br><span class="line"><span class="comment">      # define check_chunk(A, P)</span></span><br><span class="line"><span class="comment">      # define check_free_chunk(A, P)</span></span><br><span class="line"><span class="comment">      # define check_inuse_chunk(A, P)</span></span><br><span class="line"><span class="comment">      # define check_remalloced_chunk(A, P, N)</span></span><br><span class="line"><span class="comment">      # define check_malloced_chunk(A, P, N)</span></span><br><span class="line"><span class="comment">      # define check_malloc_state(A)</span></span><br><span class="line"><span class="comment">      非debug模式下这些宏定义为空</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      <span class="comment">//将chunk指针转化为mem指针,即指向data区域</span></span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      # define __glibc_unlikely(cond)	(cond)</span></span><br><span class="line"><span class="comment">      static int perturb_byte;</span></span><br><span class="line"><span class="comment">      static void alloc_perturb (char *p, size_t n) &#123;</span></span><br><span class="line"><span class="comment">        if (__glibc_unlikely (perturb_byte))</span></span><br><span class="line"><span class="comment">          memset (p, perturb_byte ^ 0xff, n);</span></span><br><span class="line"><span class="comment">      &#125; </span></span><br><span class="line"><span class="comment">      该函数配合calloc使用</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">      <span class="comment">//将分配出来的mem指针返回</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//victim为0说明对应fastbin无空闲chunk,继续进行分配</span></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb)) &#123;</span><br><span class="line">    <span class="comment">//所需的chunk大小属于smallbin</span></span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line">    <span class="comment">//根据index获得对应smallbin的表头</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin) &#123;</span><br><span class="line">      <span class="comment">//victim赋值为表尾,如果该表不为空</span></span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//victim为0,表示smallbin还没有初始化为双向循环链表,调用malloc_consolidate函数,此时由于global_max_fast也未初始化,所以会调用malloc_init_state初始化</span></span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) &#123;</span><br><span class="line">            <span class="comment">//双向链表检测,last(bin)-&gt;bk-&gt;fd == last(bin)</span></span><br><span class="line">            errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">        <span class="comment">//设置inuse标志</span></span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line">        <span class="comment">//将victim从smallbin的双向循环链表中取出</span></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          <span class="comment">//如果是非主分配区,将标志bit清零</span></span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//同上,正常的分配流程</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该表为空则继续分配</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//所需的chunk大小属于largebin</span></span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">      <span class="comment">//调用malloc_consolidate()函数合并fastbin chunk,并将这些空闲chunk加入unsorted_bin中</span></span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123;</span><br><span class="line">      <span class="comment">//反向遍历unsorted_bin,遍历结束的条件是unsorted_bin为空</span></span><br><span class="line">      <span class="comment">//victim是unsorted_bin中最后一个chunk</span></span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="comment">//bck是unsorted_bin中倒数第二个chunk</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        <span class="comment">//chunk的大小不能小于等于2 * SIZE_SZ,也不能超过该分配区总的内存分配量</span></span><br><span class="line">        malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>, chunk2mem (victim), av);</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line">      <span class="comment">//获取最后一个chunk的size</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">        <span class="comment">//如果请求的chunk大小为smallbin范围,且unsorted_bin中只有一个last_remainder chunk,且其大小大于所需chunk的大小加上MINSIZE</span></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        <span class="comment">//计算切分后剩余chunk的size</span></span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line">        <span class="comment">//计算切分后剩余chunk的地址</span></span><br><span class="line">        unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">        <span class="comment">//将切分后剩余的chunk放入unsorted_bin</span></span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        <span class="comment">//设置为last_remainder chunk</span></span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">        <span class="comment">//设置last_remainder chunk的bk和fd</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (remainder_size)) &#123;</span><br><span class="line">          <span class="comment">//若剩下的chunk属于largebin chunk,将其fd_nextsize和bk_nextsize设置为NULL</span></span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//设置头部(addr + 0x8),包括大小和标志位,由于临近的前一个chunk一定位于使用中,所以PREV_INUSE为1</span></span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        <span class="comment">//同理,由于victim会被分配给用户,所以PREV_INUSE为1</span></span><br><span class="line">        set_foot (remainder, remainder_size);</span><br><span class="line">        <span class="comment">//该chunk不在使用中,使用set_foot对该chunk的inuse标志位置零</span></span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//同上,正常的分配流程</span></span><br><span class="line">      &#125;</span><br><span class="line">      unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">      <span class="comment">//不满足上述情况则将该chunk从unsorted_bin链表中取出</span></span><br><span class="line">      <span class="keyword">if</span> (size == nb) &#123;</span><br><span class="line">        <span class="comment">//victim大小与所需的chunk大小一致</span></span><br><span class="line">        set_inuse_bit_at_offset (victim, size);</span><br><span class="line">        <span class="comment">//对victim的inuse标志位置零</span></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          <span class="comment">//不属于主分配区则对对应的标志位置零</span></span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//同上,正常的分配流程</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//到这说明该victim会放入对应的bin链表</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (size)) &#123;</span><br><span class="line">        <span class="comment">//victim属于smallbin</span></span><br><span class="line">        victim_index = smallbin_index (size);</span><br><span class="line">        <span class="comment">//获得所属smallbin的index</span></span><br><span class="line">        bck = bin_at (av, victim_index);</span><br><span class="line">        <span class="comment">//将该smallbin的链表表头赋值给bck</span></span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="comment">//该smallbin第一个chunk赋值给fwd</span></span><br><span class="line">        <span class="comment">//victim会插入到bck和fwd之间,作为该smallbin链表的第一个chunk.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//victim属于largebin</span></span><br><span class="line">        victim_index = largebin_index (size);</span><br><span class="line">        <span class="comment">//获得所属largebin的index</span></span><br><span class="line">        bck = bin_at (av, victim_index);</span><br><span class="line">        <span class="comment">//将该largebin的链表表头赋值给bck</span></span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="comment">//该largebin第一个chunk赋值给fwd</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line">          <span class="comment">//该largebin中有空闲chunk存在</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">//将当前chunk的size的inuse标志bit置位,便于加快chunk大小的比较</span></span><br><span class="line">          assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          <span class="comment">//断言该largebin最后一个chunk的size字段中的非主分配区的标志bit没有置位</span></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line">            <span class="comment">//当前chunk比最后一个chunk小,就插入到该largebin的链表的最后</span></span><br><span class="line">            fwd = bck;</span><br><span class="line">            <span class="comment">//fwd赋值为表头</span></span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line">            <span class="comment">//bck赋值为最后一个chunk</span></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            <span class="comment">//将victim插入chunk size链表的尾部,该链表是从大到小排列的</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//断言该largebin第一个chunk的size字段中的非主分配区的标志bit没有置位</span></span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size) &#123;</span><br><span class="line">              <span class="comment">//正向遍历chunk size链表,直到找到第一个小于等于当前chunk大小的chunk</span></span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">              <span class="comment">//同一大小的chunk已经存在,则不需要修改chunk size链表,当前chunk插入fwd之后</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//当前chunk大于fwd,则将当前chunk作为该chunk size的代表加入chunk size链表,位置为fwd的前面</span></span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          <span class="comment">//如果largebin中没有chunk,直接将当前chunk加入chunk size链表,chunk size链表表头位于第一个chunk的fd_nextsize和bk_nextsize,所以第一个chunk是最大的</span></span><br><span class="line">          victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line">      mark_bin (av, victim_index);</span><br><span class="line">      <span class="comment">//将对应map里该index对应的标志位置1</span></span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line">      <span class="comment">//将当前chunk插入到对应bin中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="comment">//如果unsorted_bin中的chunk超过了10000个,最多遍历10000个就退出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时unsorted_bin链表已经处理完成</span></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (nb)) &#123;</span><br><span class="line">      <span class="comment">//所需分配的chunk大小为largebin</span></span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      <span class="comment">//获取对应的bin</span></span><br><span class="line">      <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb)) &#123;</span><br><span class="line">        <span class="comment">//如果largebin链表不为空且链表中最大的chunk大于所需chunk的大小,则遍历该largebin链表,找到合适的chunk</span></span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="comment">//从最后一个也就是最小一个开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">          <span class="comment">//反向遍历chunk size链表,直到找到第一个大于等于所需chunk大小的chunk退出循环</span></span><br><span class="line">          victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">          <span class="comment">//如果victim不是链表中的最后一个chunk且与victim大小相同的chunk不止一个,意味着victim为chunk size链表中的节点,取victim-&gt;fd节点对应的chunk作为候选chunk</span></span><br><span class="line">          victim = victim-&gt;fd;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        <span class="comment">//由于size可能大于所需的chunk,所以要计算看是否要划分</span></span><br><span class="line">        unlink (av, victim, bck, fwd);</span><br><span class="line">        <span class="comment">//调用unlink宏函数将victim从largebin链表中取出</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">          <span class="comment">//如果将victim切分后剩余大小小于MINSIZE,则将整个victim返回,实际分配的chunk比所需的chunk要大一些</span></span><br><span class="line">          set_inuse_bit_at_offset (victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//从victim中切分出所需的chunk,剩余部分作为一个新的chunk加入到unsorted_bin,其他处理与前面类似</span></span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          bck = unsorted_chunks (av);</span><br><span class="line">          fwd = bck-&gt;fd;</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) &#123;</span><br><span class="line">            <span class="comment">//验证第一个chunk的bk</span></span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">          &#125;</span><br><span class="line">          remainder-&gt;bk = bck;</span><br><span class="line">          remainder-&gt;fd = fwd;</span><br><span class="line">          bck-&gt;fd = remainder;</span><br><span class="line">          fwd-&gt;bk = remainder;</span><br><span class="line">          <span class="comment">//将remainder插入为unsorted_bin的第一个chunk</span></span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range (remainder_size)) &#123;</span><br><span class="line">            <span class="comment">//若剩下的chunk属于largebin chunk,将该chunk的fd_nextsize和bk_nextsize设置为NULL</span></span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot (remainder, remainder_size);</span><br><span class="line">          <span class="comment">//划分后设置,同上</span></span><br><span class="line">        &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//返回chunk过程,同上</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从最合适的smallbin或largebin中都没有分配到需要的chunk,则查看比当前bin的index大的smallbin或largebin是否有空闲chunk可利用来分配所需的chunk</span></span><br><span class="line">    ++idx;</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line">    <span class="comment">//获取下一个相邻bin的空闲chunk链表</span></span><br><span class="line">    block = idx2block (idx);</span><br><span class="line">    <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">    bit = idx2bit (idx);</span><br><span class="line">    <span class="comment">//获取该bin对于binmap中的bit位的值,使用binmap可以加快查找bin是否包含空闲chunk,idx2bit宏将idx指定的位设置为1,其它位清零</span></span><br><span class="line">    <span class="keyword">for</span> (;; ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//map为0即该block所对应的所有bins中都没有空闲chunk.于是遍历binmap的下一个block,直到找到一个不为0的block或者遍历完所有的block</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (++block &gt;= BINMAPSIZE)</span><br><span class="line">            <span class="comment">//遍历完所有的block都没有则使用top chunk分配</span></span><br><span class="line">            <span class="keyword">goto</span> use_top;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//在一个block遍历对应的bin直到找到一个bit不为0退出遍历</span></span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        assert (bit != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      victim = last (bin);</span><br><span class="line">      <span class="comment">//将bin链表中的最后一个chunk赋值给victim</span></span><br><span class="line">      <span class="keyword">if</span> (victim == bin) &#123;</span><br><span class="line">        <span class="comment">//victim与bin链表头指针相同,表示该bin中没有空闲chunk,binmap中的相应位设置不准确,将binmap的相应bit位清零,获取当前bin下一个bin,将bit移到下一个bit位,即乘以2</span></span><br><span class="line">        av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit;</span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//当前bin中的最后一个chunk满足要求,获取该chunk的大小,计算切分出所需chunk后剩余部分的大小,然后将victim从bin的链表中取出</span></span><br><span class="line">        size = chunksize (victim);</span><br><span class="line">        assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        unlink (av, victim, bck, fwd);</span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">          set_inuse_bit_at_offset (victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          bck = unsorted_chunks (av);</span><br><span class="line">          fwd = bck-&gt;fd;</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">          &#125;</span><br><span class="line">          remainder-&gt;bk = bck;</span><br><span class="line">          remainder-&gt;fd = fwd;</span><br><span class="line">          bck-&gt;fd = remainder;</span><br><span class="line">          fwd-&gt;bk = remainder;</span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            <span class="comment">//剩余部分chunk属于smallbin,将分配区的last_remainder chunk设置为剩余部分构成的chunk</span></span><br><span class="line">            av-&gt;last_remainder = remainder;</span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range (remainder_size)) &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot (remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  use_top:</span><br><span class="line">    <span class="comment">//从top chunk中分配所需chunk</span></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line">    <span class="comment">//将当前分配区的top chunk赋值给victim,并获得victim的大小</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">      <span class="comment">//top chunk切分出所需chunk后还需要MINSIZE的空间来作为fencepost</span></span><br><span class="line">      <span class="comment">//切分后的剩余部分将作为新的top chunk,原top chunk的fencepost仍然作为新的top chunk的fencepost,所以切分之后剩余的chunk不用set_foot</span></span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset (victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av)) &#123;</span><br><span class="line">      <span class="comment">//如果top chunk也不能满足要求,查看fastbin中是否有空闲chunk存在,因为free属于fastbin的chunk时不需要获得分配区的锁,调用malloc_consolidate函数并重新设置当前bin的index,再次循环</span></span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        idx = smallbin_index (nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = largebin_index (nb);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果fastbin中没有空闲chunk存在,向系统申请内存</span></span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="int-realloc"><a href="#int-realloc" class="headerlink" title="_int_realloc"></a>_int_realloc</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _int_realloc函数用于重新分配内存块。它尝试更改内存块的大小并可能移动它以满足新的大小要求。</span></span><br><span class="line"><span class="comment">// 参数:</span></span><br><span class="line"><span class="comment">// av - 指向内存状态的指针。</span></span><br><span class="line"><span class="comment">// oldp - 指向当前内存块的指针。</span></span><br><span class="line"><span class="comment">// oldsize - 当前内存块的大小。</span></span><br><span class="line"><span class="comment">// nb - 请求的新大小。</span></span><br><span class="line"><span class="type">void</span>* _int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize, INTERNAL_SIZE_T nb) &#123;</span><br><span class="line">  <span class="comment">// 定义一系列局部变量来存储分配的状态和中间结果。</span></span><br><span class="line">  mchunkptr newp; <span class="comment">// 新分配的内存块指针。</span></span><br><span class="line">  INTERNAL_SIZE_T newsize; <span class="comment">// 新内存块的大小。</span></span><br><span class="line">  <span class="type">void</span>* newmem; <span class="comment">// 对应用户内存的指针。</span></span><br><span class="line"></span><br><span class="line">  mchunkptr next; <span class="comment">// 指向oldp后面的连续内存块。</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder; <span class="comment">// 新分配内存后剩余的内存块。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size; <span class="comment">// 剩余内存块的大小。</span></span><br><span class="line"></span><br><span class="line">  mchunkptr bck; <span class="comment">// 用于链接的临时变量。</span></span><br><span class="line">  mchunkptr fwd; <span class="comment">// 用于链接的临时变量。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> copysize; <span class="comment">// 需要复制的字节数。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ncopies; <span class="comment">// 需要复制的INTERNAL_SIZE_T字数。</span></span><br><span class="line">  INTERNAL_SIZE_T* s; <span class="comment">// 复制源的指针。</span></span><br><span class="line">  INTERNAL_SIZE_T* d; <span class="comment">// 复制目标的指针。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>; <span class="comment">// 用于错误处理的字符串。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查oldp的大小是否合法。</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(oldp-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(oldsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;realloc(): invalid old size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, oldp); <span class="comment">// 检查oldp是否正在使用中。</span></span><br><span class="line"></span><br><span class="line">  assert(!chunk_is_mmapped(oldp)); <span class="comment">// 确保oldp不是映射内存。</span></span><br><span class="line"></span><br><span class="line">  next = chunk_at_offset(oldp, oldsize); <span class="comment">// 计算下一个内存块的位置。</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize = chunksize(next); <span class="comment">// 获取下一个内存块的大小。</span></span><br><span class="line">  <span class="comment">// 检查下一个内存块的大小是否合法。</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(next-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;realloc(): invalid next size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前内存块已经足够大，则直接返回当前内存块。</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(oldsize) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line">    newp = oldp;</span><br><span class="line">    newsize = oldsize;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果下一个内存块是顶部内存块，并且可以合并以满足请求的大小，则进行合并。</span></span><br><span class="line">    <span class="keyword">if</span> (next == av-&gt;top &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>)(newsize = oldsize + nextsize) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">      set_head_size(oldp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      av-&gt;top = chunk_at_offset(oldp, nb);</span><br><span class="line">      set_head(av-&gt;top, (newsize - nb) | PREV_INUSE);</span><br><span class="line">      check_inuse_chunk(av, oldp);</span><br><span class="line">      <span class="keyword">return</span> chunk2mem(oldp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果下一个内存块不在使用中，并且可以合并以满足请求的大小，则进行合并。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (next != av-&gt;top &amp;&amp; !inuse(next) &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>)(newsize = oldsize + nextsize) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line">      newp = oldp;</span><br><span class="line">      unlink(av, next, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，分配新内存，复制数据，然后释放旧内存。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      newmem = _int_malloc(av, nb - MALLOC_ALIGN_MASK);</span><br><span class="line">      <span class="keyword">if</span> (newmem == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果分配失败，则返回0。</span></span><br><span class="line"></span><br><span class="line">      newp = mem2chunk(newmem);</span><br><span class="line">      newsize = chunksize(newp);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果新分配的内存块紧跟在旧内存块后面，则合并这两个内存块。</span></span><br><span class="line">      <span class="keyword">if</span> (newp == next) &#123;</span><br><span class="line">        newsize += oldsize;</span><br><span class="line">        newp = oldp;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，复制旧内存块的内容到新内存块。</span></span><br><span class="line">        copysize = oldsize - SIZE_SZ;</span><br><span class="line">        s = (INTERNAL_SIZE_T*)(chunk2mem(oldp));</span><br><span class="line">        d = (INTERNAL_SIZE_T*)(newmem);</span><br><span class="line">        ncopies = copysize / <span class="keyword">sizeof</span>(INTERNAL_SIZE_T);</span><br><span class="line">        assert(ncopies &gt;= <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ncopies &gt; <span class="number">9</span>)</span><br><span class="line">          <span class="built_in">memcpy</span>(d, s, copysize);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 对于小内存块，使用手动复制以提高效率。</span></span><br><span class="line">          *(d + <span class="number">0</span>) = *(s + <span class="number">0</span>);</span><br><span class="line">          *(d + <span class="number">1</span>) = *(s + <span class="number">1</span>);</span><br><span class="line">          *(d + <span class="number">2</span>) = *(s + <span class="number">2</span>);</span><br><span class="line">          <span class="keyword">if</span> (ncopies &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            *(d + <span class="number">3</span>) = *(s + <span class="number">3</span>);</span><br><span class="line">            *(d + <span class="number">4</span>) = *(s + <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (ncopies &gt; <span class="number">6</span>) &#123;</span><br><span class="line">              *(d + <span class="number">5</span>) = *(s + <span class="number">5</span>);</span><br><span class="line">              *(d + <span class="number">6</span>) = *(s + <span class="number">6</span>);</span><br><span class="line">              <span class="keyword">if</span> (ncopies &gt; <span class="number">8</span>) &#123;</span><br><span class="line">                *(d + <span class="number">7</span>) = *(s + <span class="number">7</span>);</span><br><span class="line">                *(d + <span class="number">8</span>) = *(s + <span class="number">8</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _int_free(av, oldp, <span class="number">1</span>); <span class="comment">// 释放旧内存块。</span></span><br><span class="line">        check_inuse_chunk(av, newp); <span class="comment">// 检查新内存块是否正在使用中。</span></span><br><span class="line">        <span class="keyword">return</span> chunk2mem(newp); <span class="comment">// 返回新内存块的用户可用部分。</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尝试释放新内存块中的多余空间。</span></span><br><span class="line">  assert((<span class="type">unsigned</span> <span class="type">long</span>)(newsize) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb));</span><br><span class="line">  remainder_size = newsize - nb;</span><br><span class="line">  <span class="comment">// 如果剩余空间太小，无法分割为独立的内存块，则保留它。</span></span><br><span class="line">  <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">    set_head_size(newp, newsize | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_inuse_bit_at_offset(newp, newsize);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则，分割剩余空间为独立的内存块。</span></span><br><span class="line">    remainder = chunk_at_offset(newp, nb);</span><br><span class="line">    set_head_size(newp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_inuse_bit_at_offset(remainder, remainder_size); <span class="comment">// 标记剩余部分为正在使用中，以便_free()不会报错。</span></span><br><span class="line">    _int_free(av, remainder, <span class="number">1</span>); <span class="comment">// 释放剩余部分。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, newp); <span class="comment">// 检查新内存块是否正在使用中。</span></span><br><span class="line">  <span class="keyword">return</span> chunk2mem(newp); <span class="comment">// 返回新内存块的用户可用部分。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock) &#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* 释放的chunk的size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* 对应的fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* 内存空间中下一个chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* 下一个chunk的大小 */</span></span><br><span class="line">  <span class="type">int</span> nextinuse;               <span class="comment">/* 下一个chunk是否在使用 */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* 内存空间中上一个chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* 用于储存bin链表指针 */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* 用于储存bin链表指针 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line">  size = chunksize (p);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>) || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">//chunk的指针地址不能溢出</span></span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">      (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) &#123;</span><br><span class="line">    <span class="comment">//chunk的大小必须大于等于MINSIZE且对齐</span></span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">//当前free的chunk属于fastbin</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">//查看下一个相邻的chunk的大小是否小于等于2 * SIZE_SZ,或是否大于分配区所分配的内存总量</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock || (&#123; assert (locked == <span class="number">0</span>); mutex_lock(&amp;av-&gt;mutex); locked = <span class="number">1</span>; chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem; &#125;)) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//读取分配区所分配的内存总量需要对分配区加锁,检查完以后,释放分配区的锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line">    <span class="comment">//设置当前分配区的fastbin的flag,表示当前分配区的fastbin中已有空闲chunk.然后根据当前free的chunk大小获取所属的fastbin</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">//fastbin double free检测</span></span><br><span class="line">        errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">        old_idx = fastbin_index(chunksize(old));</span><br><span class="line">      p-&gt;fd = old2 = old;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line">    <span class="comment">//使用lock-free技术实现fastbin的单向链表插入操作</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">      errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="comment">//当前free的chunk不是通过mmap分配的,并且当前还没有获得分配区的锁,获取分配区的锁</span></span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top)) &#123;</span><br><span class="line">      <span class="comment">//free的是top chunk</span></span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av) &amp;&amp; (<span class="type">char</span> *) nextchunk &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">//内存中下一个chunk的地址大于top chunk的末尾</span></span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk))) &#123;</span><br><span class="line">      <span class="comment">//该chunk已经是free状态</span></span><br><span class="line">      errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">//查看下一个相邻的chunk的大小是否小于等于2 * SIZE_SZ,或是否大于分配区所分配的内存总量</span></span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      <span class="comment">//如果当前free的chunk的前一个相邻chunk为空闲状态,与前一个空闲chunk合并</span></span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">//与当前free的chunk相邻的下一个chunk不是分配区的top chunk</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        <span class="comment">//如果当前free的chunk的下一个相邻chunk为空闲状态,与下一个空闲chunk合并</span></span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//与当前free的chunk相邻的下一个chunk处于inuse状态,清除当前chunk的inuse状态</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) &#123;</span><br><span class="line">        <span class="comment">//unsorted_bin第一个chunk的fd的bk不是第一个chunk</span></span><br><span class="line">        errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size)) &#123;</span><br><span class="line">        p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line">      <span class="comment">//将合并后的chunk加入unsorted_bin的双向循环链表中</span></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//当前free的chunk下一个相邻的chunk为top chunk,则将当前chunk合并入top chunk</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="comment">//如果合并后的chunk大小大于64KB</span></span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))</span><br><span class="line">          <span class="comment">//如果当前分配区为主分配区且top chunk的大小大于heap的收缩阈值,调用systrim函数收缩heap</span></span><br><span class="line">          systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//为非主分配区,调用heap_trim函数收缩非主分配区的sub_heap</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      <span class="comment">//有锁则对分配区解锁</span></span><br><span class="line">      assert (locked);</span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//当前free的chunk是通过mmap分配则调用munma_chunk释放</span></span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span> &#123;</span><br><span class="line">  mfastbinptr*    fb;</span><br><span class="line">  mfastbinptr*    maxfb;</span><br><span class="line">  mchunkptr       p;</span><br><span class="line">  mchunkptr       nextp;</span><br><span class="line">  mchunkptr       unsorted_bin;</span><br><span class="line">  mchunkptr       first_unsorted;</span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//global_max_fast不为0,表示ptmalloc已经初始化,清除分配区flag中fastbin的标志位</span></span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//将分配区最大的一个fastbin赋值给maxfb,第一个fastbin赋值给fb,然后遍历fastbin</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="comment">//获取当前遍历的fastbin中空闲chunk单向链表的头指针</span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          check_inuse_chunk(av, p);</span><br><span class="line">          nextp = p-&gt;fd;</span><br><span class="line">          size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">          nextchunk = chunk_at_offset(p, size);</span><br><span class="line">          nextsize = chunksize(nextchunk);</span><br><span class="line">          <span class="comment">//获得当前chunk的size并去除size中的PREV_INUSE和NON_MAIN_ARENA标志,获取相邻的下一个chunk和下一个chunk的大小</span></span><br><span class="line">          <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">            <span class="comment">//如果当前chunk的前一个chunk空闲则将当前chunk与前一个chunk合并成一个空闲chunk</span></span><br><span class="line">            prevsize = p-&gt;prev_size;</span><br><span class="line">            size += prevsize;</span><br><span class="line">            p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">            unlink(av, p, bck, fwd);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">            <span class="comment">//如果与当前chunk相邻的下一个chunk不是分配区的top chunk,查看与当前chunk相邻的下一个chunk是否处于inuse状态</span></span><br><span class="line">            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">            <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">              <span class="comment">//下一个chunk空闲则将当前chunk与下一个chunk合并成一个空闲chunk</span></span><br><span class="line">              size += nextsize;</span><br><span class="line">              unlink(av, nextchunk, bck, fwd);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">              <span class="comment">//与当前chunk相邻的下一个chunk处于inuse状态,清除当前chunk的inuse状态</span></span><br><span class="line">              clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">            unsorted_bin-&gt;fd = p;</span><br><span class="line">            first_unsorted-&gt;bk = p;</span><br><span class="line">            <span class="comment">//将合并后的chunk加入unsorted_bin的双向循环链表中</span></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">              p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            p-&gt;bk = unsorted_bin;</span><br><span class="line">            p-&gt;fd = first_unsorted;</span><br><span class="line">            set_foot(p, size);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前chunk的下一个chunk为top chunk则将当前chunk合并入top chunk</span></span><br><span class="line">            size += nextsize;</span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            av-&gt;top = p;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//直到遍历完当前fastbin中的所有空闲chunk</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">    <span class="comment">//直到遍历完所有的fastbin</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果ptmalloc没有初始化,初始化ptmalloc</span></span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __libc_free (<span class="type">void</span> *mem) &#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *) = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p)) &#123;</span><br><span class="line">    <span class="comment">//如果当前free的chunk是通过mmap分配的,调用munmap_chunk函数</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX) &#123;</span><br><span class="line">      <span class="comment">//如果开启了mmap分配阈值动态调整机制且chunk的大小大于设置的mmap分配阈值,小于mmap分配阈值的最大值.则将当前chunk的大小赋值给mmap分配阈值,并修改mmap收缩阈值为mmap分配阈值的2倍</span></span><br><span class="line">      mp_.mmap_threshold = chunksize (p);</span><br><span class="line">      mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">      LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>, mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//不需要对分配区加锁,调用_int_free函数执行实际的释放工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   sysmalloc函数处理需要从系统获取更多内存的malloc情况。</span></span><br><span class="line"><span class="comment">   在进入函数时，假设av-&gt;top没有足够的空间来满足对nb字节的请求，</span></span><br><span class="line"><span class="comment">   因此需要扩展或替换av-&gt;top。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">sysmalloc</span><span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr old_top;              <span class="comment">// av-&gt;top的原始值。</span></span><br><span class="line">  INTERNAL_SIZE_T old_size;       <span class="comment">// 它的大小。</span></span><br><span class="line">  <span class="type">char</span> *old_end;                  <span class="comment">// 它的结束地址。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> size;                      <span class="comment">// 参数给MORECORE或mmap调用。</span></span><br><span class="line">  <span class="type">char</span> *brk;                      <span class="comment">// MORECORE的返回值。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> correction;                <span class="comment">// 参数给第二个MORECORE调用。</span></span><br><span class="line">  <span class="type">char</span> *snd_brk;                  <span class="comment">// 第二个返回值。</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">// 新空间前面的不可用字节。</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">// 新空间末端的部分页。</span></span><br><span class="line">  <span class="type">char</span> *aligned_brk;              <span class="comment">// 对齐的brk偏移。</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                    <span class="comment">// 分配/返回的内存块。</span></span><br><span class="line">  mchunkptr remainder;            <span class="comment">// 分配后的剩余部分。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;   <span class="comment">// 它的大小。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO(dl_pagesize); <span class="comment">// 系统页的大小。</span></span><br><span class="line">  <span class="type">bool</span> tried_mmap = <span class="literal">false</span>;             <span class="comment">// 标记是否尝试过mmap。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     如果使用mmap，并且请求的大小达到mmap阈值，并且系统支持mmap，</span></span><br><span class="line"><span class="comment">     并且当前分配的mmap区域数量较少，尝试直接映射这个请求，</span></span><br><span class="line"><span class="comment">     而不是扩展top。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">      || ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.mmap_threshold)</span><br><span class="line">          &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">char</span> *mm;           <span class="comment">// mmap调用的返回值。</span></span><br><span class="line"></span><br><span class="line">    try_mmap:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         将大小上调到最近的页大小。对于mmapped区块，开销比普通区块多一个SIZE_SZ单位，</span></span><br><span class="line"><span class="comment">         因为没有后续区块的prev_size字段可用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         对于glibc，没有必要进行进一步对齐，除非我们需要更高的对齐。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">        size = ALIGN_UP(nb + SIZE_SZ, pagesize);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        size = ALIGN_UP(nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</span><br><span class="line">      tried_mmap = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb))</span><br><span class="line">      &#123;</span><br><span class="line">          mm = (<span class="type">char</span> *)(MMAP(<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mm != MAP_FAILED)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 mmapped区域的开始偏移存储在区块的prev_size字段中。这允许我们在这里</span></span><br><span class="line"><span class="comment">                 和memalign()中调整返回的开始地址以满足对齐要求，并且仍然能够在</span></span><br><span class="line"><span class="comment">                 free()和realloc()中计算出正确的munmap参数地址。</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">/* 对于glibc，chunk2mem增加地址2*SIZE_SZ，并且MALLOC_ALIGN_MASK是2*SIZE_SZ-1。</span></span><br><span class="line"><span class="comment">                     每个mmap区域都是页面对齐的，因此一定是MALLOC_ALIGN_MASK对齐的。*/</span></span><br><span class="line">                  assert(((INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">                  front_misalign = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                  <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                      p = (mchunkptr)(mm + correction);</span><br><span class="line">                      p-&gt;prev_size = correction;</span><br><span class="line">                      set_head(p, (size - correction) | IS_MMAPPED);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                      p = (mchunkptr)mm;</span><br><span class="line">                      set_head(p, size | IS_MMAPPED);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* 更新统计数据 */</span></span><br><span class="line"></span><br><span class="line">              <span class="type">int</span> new = atomic_exchange_and_add(&amp;mp_.n_mmaps, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">              <span class="type">atomic_max</span>(&amp;mp_.max_n_mmaps, new);</span><br><span class="line"></span><br><span class="line">              <span class="type">unsigned</span> <span class="type">long</span> sum;</span><br><span class="line">              sum = atomic_exchange_and_add(&amp;mp_.mmapped_mem, size) + size;</span><br><span class="line">              <span class="type">atomic_max</span>(&amp;mp_.max_mmapped_mem, sum);</span><br><span class="line"></span><br><span class="line">              check_chunk(av, p);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> chunk2mem(p);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果没有可用的arena，并且mmap也失败了。 */</span></span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 记录进入时top的配置 */</span></span><br><span class="line"></span><br><span class="line">  old_top = av-&gt;top;</span><br><span class="line">  old_size = chunksize(old_top);</span><br><span class="line">  old_end = (<span class="type">char</span> *)(chunk_at_offset(old_top, old_size));</span><br><span class="line"></span><br><span class="line">  brk = snd_brk = (<span class="type">char</span> *)(MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     如果不是第一次通过，我们需要old_size至少是MINSIZE，并且设置了prev_inuse位。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  assert((old_top == initial_top(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>)(old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">          prev_inuse(old_top) &amp;&amp;</span><br><span class="line">          ((<span class="type">unsigned</span> <span class="type">long</span>)old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 前提条件: 当前空间不足以满足nb请求 */</span></span><br><span class="line">  assert((<span class="type">unsigned</span> <span class="type">long</span>)(old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果av不是主arena，则尝试扩展当前堆或创建新堆。</span></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">  &#123;</span><br><span class="line">      heap_info *old_heap, *heap;</span><br><span class="line">      <span class="type">size_t</span> old_heap_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 首先尝试扩展当前堆。 */</span></span><br><span class="line">      old_heap = heap_for_ptr(old_top);</span><br><span class="line">      old_heap_size = old_heap-&gt;size;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">long</span>)(MINSIZE + nb - old_size) &gt; <span class="number">0</span></span><br><span class="line">          &amp;&amp; grow_heap(old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">          arena_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">          set_head(old_top, (((<span class="type">char</span> *)old_heap + old_heap-&gt;size) - (<span class="type">char</span> *)old_top)</span><br><span class="line">                   | PREV_INUSE);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap(nb + (MINSIZE + <span class="keyword">sizeof</span>(*heap)), mp_.top_pad)))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">/* 使用新分配的堆。 */</span></span><br><span class="line">          heap-&gt;ar_ptr = av;</span><br><span class="line">          heap-&gt;prev = old_heap;</span><br><span class="line">          av-&gt;system_mem += heap-&gt;size;</span><br><span class="line">          arena_mem += heap-&gt;size;</span><br><span class="line">          <span class="comment">/* 设置新的 top chunk 。 */</span></span><br><span class="line">          top(av) = chunk_at_offset(heap, <span class="keyword">sizeof</span>(*heap));</span><br><span class="line">          set_head(top(av), (heap-&gt;size - <span class="keyword">sizeof</span>(*heap)) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 释放旧的 top chunk 。 */</span></span><br><span class="line">          old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">          set_head(chunk_at_offset(old_top, old_size + <span class="number">2</span> * SIZE_SZ), <span class="number">0</span> | PREV_INUSE);</span><br><span class="line">          <span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line">          &#123;</span><br><span class="line">              set_head(chunk_at_offset(old_top, old_size), (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">              set_foot(chunk_at_offset(old_top, old_size), (<span class="number">2</span> * SIZE_SZ));</span><br><span class="line">              set_head(old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">              _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              set_head(old_top, (old_size + <span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">              set_foot(old_top, (old_size + <span class="number">2</span> * SIZE_SZ));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!tried_mmap)</span><br><span class="line">          <span class="comment">/* 至少可以尝试使用mmap内存。 */</span></span><br><span class="line">          <span class="keyword">goto</span> try_mmap;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>     <span class="comment">/* av == main_arena */</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">/* 请求足够的空间来满足nb + pad + 开销 */</span></span><br><span class="line">      size = nb + mp_.top_pad + MINSIZE;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         如果是连续的，我们可以减去希望与新空间合并的现有空间。</span></span><br><span class="line"><span class="comment">         我们稍后只在我们实际没有获得连续空间时再加回来。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (contiguous(av))</span><br><span class="line">          size -= old_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         将大小调整为页的倍数。</span></span><br><span class="line"><span class="comment">         如果MORECORE不是连续的，这确保我们只用整页参数调用它。</span></span><br><span class="line"><span class="comment">         并且如果MORECORE是连续的，并且这不是第一次通过，</span></span><br><span class="line"><span class="comment">         这会保持先前调用的页对齐。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      size = ALIGN_UP(size, pagesize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         如果参数太大，看起来是负的，不尝试调用MORECORE。</span></span><br><span class="line"><span class="comment">         注意，由于mmap接受size_t参数，即使我们无法调用MORECORE，</span></span><br><span class="line"><span class="comment">         下面如果使用mmap，也可能成功。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          brk = (<span class="type">char</span> *)(MORECORE(size));</span><br><span class="line">          LIBC_PROBE(memory_sbrk_more, <span class="number">2</span>, brk, size);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (brk != (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">/* 必要时调用 morecore hook 。 */</span></span><br><span class="line">          <span class="type">void</span> (*hook)(<span class="type">void</span>) = atomic_forced_read(__after_morecore_hook);</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">              (*hook)();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             如果有mmap，尝试使用它作为MORECORE失败或不能使用时的后备。</span></span><br><span class="line"><span class="comment">             在地址空间有“洞”的系统上，这是值得做的，</span></span><br><span class="line"><span class="comment">             所以sbrk不能扩展以提供连续的空间，但空间在其他地方是可用的。</span></span><br><span class="line"><span class="comment">             注意我们忽略了mmap最大计数和阈值限制，</span></span><br><span class="line"><span class="comment">             因为空间将不会被用作分离的mmap区域。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 不能与旧的top合并，所以加回它的大小 */</span></span><br><span class="line">          <span class="keyword">if</span> (contiguous(av))</span><br><span class="line">              size = ALIGN_UP(size + old_size, pagesize);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 如果我们依赖mmap作为后备，那么使用更大的单位 */</span></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(MMAP_AS_MORECORE_SIZE))</span><br><span class="line">              size = MMAP_AS_MORECORE_SIZE;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="type">char</span> *mbrk = (<span class="type">char</span> *)(MMAP(<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (mbrk != MAP_FAILED)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">/* 我们不需要也不能使用另一个sbrk调用来找到结束 */</span></span><br><span class="line">                  brk = mbrk;</span><br><span class="line">                  snd_brk = brk + size;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     记录我们不再有一个连续的sbrk区域。</span></span><br><span class="line"><span class="comment">                     第一次使用mmap作为后备后，我们不再依赖连续的空间，</span></span><br><span class="line"><span class="comment">                     因为这可能会错误地连接区域。</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                  set_noncontiguous(av);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (brk != (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (mp_.sbrk_base == <span class="number">0</span>)</span><br><span class="line">              mp_.sbrk_base = brk;</span><br><span class="line">          av-&gt;system_mem += size;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             如果MORECORE扩展了前一个空间，我们可以同样扩展top大小。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">              set_head(old_top, (size + old_size) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (contiguous(av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)</span><br><span class="line">              &#123;</span><br><span class="line">                  malloc_printerr(<span class="number">3</span>, <span class="string">&quot;break adjusted to free malloc space&quot;</span>, brk, av);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             否则，做出调整:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * 如果是第一次通过或不连续，我们需要调用sbrk</span></span><br><span class="line"><span class="comment">              只是为了找出内存的结束在哪里。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * 我们需要确保所有从malloc返回的内存块都满足</span></span><br><span class="line"><span class="comment">              MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * 如果有一个干预的外部sbrk，我们需要调整sbrk</span></span><br><span class="line"><span class="comment">              请求大小以考虑到我们将无法与old_top中的现有空间合并。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           * 几乎所有系统在内部都以整页为单位分配，</span></span><br><span class="line"><span class="comment">              在这种情况下，我们最好使用请求的最后一页。</span></span><br><span class="line"><span class="comment">              所以我们现在分配足够多的内存来达到页面边界，</span></span><br><span class="line"><span class="comment">              这反过来会导致未来连续的调用进行页面对齐。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              front_misalign = <span class="number">0</span>;</span><br><span class="line">              end_misalign = <span class="number">0</span>;</span><br><span class="line">              correction = <span class="number">0</span>;</span><br><span class="line">              aligned_brk = brk;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* 处理连续情况 */</span></span><br><span class="line">              <span class="keyword">if</span> (contiguous(av))</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">/* 计算外部sbrk作为system_mem。 */</span></span><br><span class="line">                  <span class="keyword">if</span> (old_size)</span><br><span class="line">                      av-&gt;system_mem += brk - old_end;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* 确保第一个新区块符合对齐要求 */</span></span><br><span class="line"></span><br><span class="line">                  front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                  <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         跳过一些字节以达到一个对齐的位置。</span></span><br><span class="line"><span class="comment">                         我们不需要特别标记这些浪费的前端字节。</span></span><br><span class="line"><span class="comment">                         它们永远不会被访问到，因为</span></span><br><span class="line"><span class="comment">                         av-&gt;top的prev_inuse（以及任何从它的开始创建的区块）</span></span><br><span class="line"><span class="comment">                         在初始化后总是为真。</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line"></span><br><span class="line">                      correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                      aligned_brk += correction;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     如果这不是与现有空间相邻的，那么我们将无法</span></span><br><span class="line"><span class="comment">                     与old_top空间合并，所以必须在第二个请求中加上这部分。</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                  correction += old_size;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* 扩展结束地址以达到页面边界 */</span></span><br><span class="line">                  end_misalign = (INTERNAL_SIZE_T)(brk + size + correction);</span><br><span class="line">                  correction += (ALIGN_UP(end_misalign, pagesize)) - end_misalign;</span><br><span class="line"></span><br><span class="line">                  assert(correction &gt;= <span class="number">0</span>);</span><br><span class="line">                  snd_brk = (<span class="type">char</span> *)(MORECORE(correction));</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     如果不能分配修正空间，尝试至少找出当前的brk。</span></span><br><span class="line"><span class="comment">                     它可能足以继续进行而不会失败。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                     注意如果第二个sbrk没有失败，我们假设空间与第一个sbrk连续。</span></span><br><span class="line"><span class="comment">                     这是一个安全的假设，除非程序是多线程的但不使用锁，</span></span><br><span class="line"><span class="comment">                     并且在我们的第一个和第二个调用之间发生了一个外部的sbrk。</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">                  &#123;</span><br><span class="line">                      correction = <span class="number">0</span>;</span><br><span class="line">                      snd_brk = (<span class="type">char</span> *)(MORECORE(<span class="number">0</span>));</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="comment">/* 必要时调用 morecore hook 。 */</span></span><br><span class="line">                      <span class="type">void</span> (*hook)(<span class="type">void</span>) = atomic_forced_read(__after_morecore_hook);</span><br><span class="line">                      <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">                          (*hook)();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* 处理非连续情况 */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">                      <span class="comment">/* MORECORE/mmap必须正确对齐 */</span></span><br><span class="line">                      assert(((<span class="type">unsigned</span> <span class="type">long</span>)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                      front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                      <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>)</span><br><span class="line">                      &#123;</span><br><span class="line">                          <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             跳过一些字节以达到一个对齐的位置。</span></span><br><span class="line"><span class="comment">                             我们不需要特别标记这些浪费的前端字节。</span></span><br><span class="line"><span class="comment">                             它们永远不会被访问到，因为</span></span><br><span class="line"><span class="comment">                             av-&gt;top的prev_inuse（以及任何从它的开始创建的区块）</span></span><br><span class="line"><span class="comment">                             在初始化后总是为真。</span></span><br><span class="line"><span class="comment">                           */</span></span><br><span class="line"></span><br><span class="line">                          aligned_brk += MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* 找出当前的内存结束位置 */</span></span><br><span class="line">                  <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">                  &#123;</span><br><span class="line">                      snd_brk = (<span class="type">char</span> *)(MORECORE(<span class="number">0</span>));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* 根据第二个sbrk的结果调整top */</span></span><br><span class="line">              <span class="keyword">if</span> (snd_brk != (<span class="type">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">              &#123;</span><br><span class="line">                  av-&gt;top = (mchunkptr)aligned_brk;</span><br><span class="line">                  set_head(av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);</span><br><span class="line">                  av-&gt;system_mem += correction;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     如果不是第一次通过，我们要么有一个由于外部sbrk造成的间隙，</span></span><br><span class="line"><span class="comment">                     要么是一个非连续的区域。在old_top处插入一个双重栅栏防止合并</span></span><br><span class="line"><span class="comment">                     我们不拥有的空间。这些栅栏是标记为使用中的人工区块，</span></span><br><span class="line"><span class="comment">                     无论如何都太小而不能使用。我们需要两个栅栏以使大小和对齐工作。</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (old_size != <span class="number">0</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         缩小old_top以插入栅栏，保持大小为MALLOC_ALIGNMENT的倍数。</span></span><br><span class="line"><span class="comment">                         我们知道old_top中至少有足够的空间来做到这一点。</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line">                      old_size = (old_size - <span class="number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">                      set_head(old_top, old_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         注意以下分配会完全覆盖old_top，</span></span><br><span class="line"><span class="comment">                         当old_size之前是MINSIZE时。这是故意的。</span></span><br><span class="line"><span class="comment">                         我们需要栅栏，即使old_top可能会因此丢失。</span></span><br><span class="line"><span class="comment">                       */</span></span><br><span class="line">                      chunk_at_offset(old_top, old_size)-&gt;size =</span><br><span class="line">                          (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">                      chunk_at_offset(old_top, old_size + <span class="number">2</span> * SIZE_SZ)-&gt;size =</span><br><span class="line">                          (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">/* 如果可能，释放其余的部分。 */</span></span><br><span class="line">                      <span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line">                      &#123;</span><br><span class="line">                          _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="comment">/* if (av !=  &amp;main_arena) */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新最大系统内存使用量。</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)av-&gt;system_mem &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(av-&gt;max_system_mem))</span><br><span class="line">      av-&gt;max_system_mem = av-&gt;system_mem;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查内存状态。</span></span><br><span class="line">  check_malloc_state(av);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 最后，执行分配 */</span></span><br><span class="line">  p = av-&gt;top;</span><br><span class="line">  size = chunksize(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 检查上述分配路径之一是否成功 */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset(p, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head(p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">      check_malloced_chunk(av, p, nb);</span><br><span class="line">      <span class="keyword">return</span> chunk2mem(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 捕获所有失败的路径 */</span></span><br><span class="line">  __set_errno(ENOMEM);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="systrim"><a href="#systrim" class="headerlink" title="systrim"></a>systrim</h2><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">systrim</span> <span class="params">(<span class="type">size_t</span> pad, mstate av)</span> &#123;</span><br><span class="line">  <span class="type">long</span> top_size;</span><br><span class="line">  <span class="type">long</span> extra;</span><br><span class="line">  <span class="type">long</span> released;</span><br><span class="line">  <span class="type">char</span> *current_brk;</span><br><span class="line">  <span class="type">char</span> *new_brk;</span><br><span class="line">  <span class="type">size_t</span> pagesize;</span><br><span class="line">  <span class="type">long</span> top_area;</span><br><span class="line"></span><br><span class="line">  pagesize = GLRO (dl_pagesize);</span><br><span class="line">  top_size = chunksize (av-&gt;top);</span><br><span class="line">  top_area = top_size - MINSIZE - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (top_area &lt;= pad)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  extra = ALIGN_DOWN(top_area - pad, pagesize);</span><br><span class="line">  <span class="comment">//计算top chunk中最大可释放的整数页大小,top chunk中至少需要MINSIZE的内存保存fencepost</span></span><br><span class="line">  <span class="keyword">if</span> (extra == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  current_brk = (<span class="type">char</span> *) (MORECORE (<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">if</span> (current_brk == (<span class="type">char</span> *) (av-&gt;top) + top_size) &#123;</span><br><span class="line">    <span class="comment">//如果当前top chunk的结束地址与当前的brk值相等,执行heap收缩</span></span><br><span class="line">    MORECORE (-extra);</span><br><span class="line">    <span class="comment">//调用sbrk释放指定大小的内存</span></span><br><span class="line">    <span class="type">void</span> (*hook) (<span class="type">void</span>) = atomic_forced_read (__after_morecore_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">      (*hook)();</span><br><span class="line">    new_brk = (<span class="type">char</span> *) (MORECORE (<span class="number">0</span>));</span><br><span class="line">    LIBC_PROBE (memory_sbrk_less, <span class="number">2</span>, new_brk, extra);</span><br><span class="line">    <span class="keyword">if</span> (new_brk != (<span class="type">char</span> *) MORECORE_FAILURE) &#123;</span><br><span class="line">      <span class="comment">//计算释放的内存大小,更新当前分配区所分配的内存总量,更新top chunk的大小</span></span><br><span class="line">      released = (<span class="type">long</span>) (current_brk - new_brk);</span><br><span class="line">      <span class="keyword">if</span> (released != <span class="number">0</span>) &#123;</span><br><span class="line">        av-&gt;system_mem -= released;</span><br><span class="line">        set_head (av-&gt;top, (top_size - released) | PREV_INUSE);</span><br><span class="line">        check_malloc_state (av);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="版本变化"><a href="#版本变化" class="headerlink" title="版本变化"></a>版本变化</h1><h2 id="2-24"><a href="#2-24" class="headerlink" title="2.24"></a>2.24</h2><h2 id="2-25"><a href="#2-25" class="headerlink" title="2.25"></a>2.25</h2><h2 id="2-27"><a href="#2-27" class="headerlink" title="2.27"></a>2.27</h2><h2 id="2-28"><a href="#2-28" class="headerlink" title="2.28"></a>2.28</h2><h2 id="2-29"><a href="#2-29" class="headerlink" title="2.29"></a>2.29</h2>
		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> linux 堆利用基础知识</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2024-11-08 13:29:47</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-08-19 01:06:29
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2024/11/08/linux-heap-exploit-basic-knowlege/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/linux-user-pwn/">#linux user pwn</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/11/08/Chrome-v8-pwn/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Chrome V8 Pwn</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/11/08/linux-heap-exploit/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">linux 堆利用</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">linux 堆利用基础知识</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-text">内存分配基本思想</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">堆的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc"><span class="nav-text">malloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#realloc"><span class="nav-text">realloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#calloc"><span class="nav-text">calloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#free"><span class="nav-text">free</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mallopt"><span class="nav-text">mallopt</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%83%8C%E5%90%8E%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">内存分配背后的系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#s-brk"><span class="nav-text">(s)brk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mmap"><span class="nav-text">mmap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">堆相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc-par"><span class="nav-text">malloc_par</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#heap-info"><span class="nav-text">heap_info</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arena"><span class="nav-text">arena</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chunk"><span class="nav-text">chunk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bins"><span class="nav-text">bins</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bins-1"><span class="nav-text">bins</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fast-Bin"><span class="nav-text">Fast Bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Small-Bin"><span class="nav-text">Small Bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Large-Bin"><span class="nav-text">Large Bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsorted-Bin"><span class="nav-text">Unsorted Bin</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Top-Chunk"><span class="nav-text">Top Chunk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#last-remainder"><span class="nav-text">last remainder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache"><span class="nav-text">tcache</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%BF%87%E7%A8%8B"><span class="nav-text">关键过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc-1"><span class="nav-text">malloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#free-1"><span class="nav-text">free</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A%EF%BC%88glibc-2-23%EF%BC%89"><span class="nav-text">源码注释（glibc-2.23）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#libc-malloc"><span class="nav-text">__libc_malloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libc-calloc"><span class="nav-text">__libc_calloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libc-realloc"><span class="nav-text">__libc_realloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libc-free"><span class="nav-text">__libc_free</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int-malloc"><span class="nav-text">_int_malloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int-realloc"><span class="nav-text">_int_realloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int-free"><span class="nav-text">_int_free</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc-consolidate"><span class="nav-text">malloc_consolidate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sysmalloc"><span class="nav-text">sysmalloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#systrim"><span class="nav-text">systrim</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96"><span class="nav-text">版本变化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-24"><span class="nav-text">2.24</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-25"><span class="nav-text">2.25</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-27"><span class="nav-text">2.27</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-28"><span class="nav-text">2.28</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-29"><span class="nav-text">2.29</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        51 posts in total
                    </span>
                    
                        <span>
                            963.6k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>