<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2024/11/08/windows-user-pwn-basic-knowlege/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            windows user pwn 基础知识 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">8</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">10</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">27</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">windows user pwn 基础知识</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-11-08 20:54:39</span>
        <span class="mobile">2024-11-08 20:54:39</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-11-21 19:22:41</span>
            <span class="mobile">2024-11-21 19:22:41</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/pwn/">pwn</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/pwn/windows-user-pwn/">windows user pwn</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/windows-user-pwn/">windows user pwn</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>30.4k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>131 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><h3 id="winchecksec"><a href="#winchecksec" class="headerlink" title="winchecksec"></a>winchecksec</h3><p><a class="link"   target="_blank" rel="noopener" href="https://github.com/trailofbits/winchecksec" >winchecksec<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 是 windows 版的 checksec ，不过有时候结果不太准确。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/7ef236576d51ace32a8893c30cff0e9a.png"
                     
                ></p>
<h3 id="checksec（x64dbg）"><a href="#checksec（x64dbg）" class="headerlink" title="checksec（x64dbg）"></a>checksec（x64dbg）</h3><p><a class="link"   target="_blank" rel="noopener" href="https://x64dbg.com/" >x64dbg<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 的插件 <a class="link"   target="_blank" rel="noopener" href="https://github.com/klks/checksec" >checksec<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 检查效果比较准确，并且可以连同加载的 dll 一起检测。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/975a35d6a67ece4db6590375e3b13fe4.png"
                     
                ><br>将 release 的插件按 32 和 64 位分别放到 x32dbg 和 x64dbg 的 plugins 目录，如果找不到 plugins 目录则打开调试器然后关闭就出现了。</p>
<h2 id="winpwn"><a href="#winpwn" class="headerlink" title="winpwn"></a>winpwn</h2><p><a class="link"   target="_blank" rel="noopener" href="https://github.com/byzero512/winpwn" >winpwn<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 是 windows 平台上类似 pwntools 的 python 库，使用这个库可以更方便的编写 exp 。</p>
<p>winpwn 支持如下功能：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> process</span><br><span class="line">   + process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">   + process([<span class="string">&quot;./pwn&quot;</span>,<span class="string">&quot;argv[1]&quot;</span>,<span class="string">&quot;argv[2]&quot;</span>])</span><br><span class="line">   + p.readm(addr,n) <span class="comment"># read process memory</span></span><br><span class="line">   + p.writem(addr,con=<span class="string">&quot;&quot;</span>) <span class="comment"># write process memory</span></span><br><span class="line"><span class="number">2.</span> remote</span><br><span class="line">   + remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">65535</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> context</span><br><span class="line">   + context.timeout=<span class="number">512</span></span><br><span class="line">   + context.debugger=<span class="string">&quot;gdb&quot;</span> <span class="comment"># or &quot;windbg&quot; or &quot;x64dbg&quot;</span></span><br><span class="line">   + context.endian=<span class="string">&quot;little&quot;</span></span><br><span class="line">   + context.log_level=<span class="string">&quot;&quot;</span> <span class="comment"># or &quot;debug&quot;</span></span><br><span class="line">   + context.terminal=[ ]</span><br><span class="line">   + context.newline=<span class="string">&quot;\r\n&quot;</span></span><br><span class="line">   + context.arch=<span class="string">&quot;i386&quot;</span> <span class="comment"># or &quot;amd64&quot;</span></span><br><span class="line">   + content.pie=<span class="literal">None</span></span><br><span class="line">   + context.dbginit=<span class="literal">None</span> <span class="comment"># used to set debugger init script</span></span><br><span class="line">   + context.windbg=<span class="literal">None</span> <span class="comment"># set debugger path, or use .winpwn to find debugger path</span></span><br><span class="line">   + context.windbgx=<span class="literal">None</span></span><br><span class="line">   + content.gdb=<span class="literal">None</span></span><br><span class="line">   + context.x64dbg=<span class="literal">None</span></span><br><span class="line">   + context.nocolor=<span class="literal">None</span> <span class="comment"># if set, will print non-colorful output to terminal</span></span><br><span class="line">   </span><br><span class="line"><span class="number">4.</span> dbg: windbgx, windbg, gdb, x64dbg</span><br><span class="line">   + windbgx.attach(p,script=<span class="string">&quot;bp 0x401000&quot;</span>)</span><br><span class="line">   + windbg.attach(p,script=<span class="string">&quot;bp 0x401000&quot;</span>)</span><br><span class="line">   + gdb.attach(p, script=<span class="string">&quot;b *0x401000&quot;</span>)</span><br><span class="line">   + x64dbg.attach(p) <span class="comment">#can not parse script file yet</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> disable PIE:</span><br><span class="line">   + PIE(exe_fpath=<span class="string">&quot;&quot;</span>)</span><br><span class="line">   + NOPIE(exe_fpath=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="number">6.</span> asm/disasm:</span><br><span class="line">   + asm(<span class="string">&quot;push ebp&quot;</span>)</span><br><span class="line">   + disasm(<span class="string">&quot;\x55&quot;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="number">7.</span> winfile(fpath=<span class="string">&quot;./main.exe&quot;</span>):</span><br><span class="line">   + winfile.symbols[<span class="string">&quot;CreateProcessA&quot;</span>] <span class="comment"># return symbol&#x27;s IAT/EAT offset of CreateProcessA by image base</span></span><br><span class="line"><span class="number">8.</span> wincs(ip,port)</span><br><span class="line">   + wincs(ip=<span class="literal">None</span>,port=<span class="number">512</span>): run a server to asm/disasm <span class="keyword">in</span> remote machine <span class="keyword">for</span> client where does <span class="keyword">not</span> install keystone/capstone</span><br><span class="line">   + wincs(ip=<span class="string">&#x27;123.123.123.123&#x27;</span>,<span class="number">512</span>): create a client to connet to server</span><br><span class="line">      + wincs.asm(asmcode=<span class="string">&#x27;push ebp&#x27;</span>)</span><br><span class="line">      + wincs.disasm(machinecode=<span class="string">&#x27;\x55&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>这里我使用的是 python2 版本的 winpwn 。</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install pefile</span><br><span class="line">pip install keystone-engine</span><br><span class="line">pip install capstone</span><br><span class="line">pip install winpwn</span><br></pre></td></tr></table></figure></div>

<h3 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h3><p> winpwn 中缺失了一些 pwntools 中的功能，这里我们修改 winpwn 库添加一下（<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/winpwn" >修改好的项目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>）。</p>
<ul>
<li><p>添加 sendline&#x2F;sendlineafter</p>
</li>
<li><p>添加 search ，这里 rebase 决定是否按照 ImageBase 进行重定位。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> winpwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">pe = winfile(<span class="string">&quot;./stackoverflow.exe&quot;</span>, rebase=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(pe.search(asm(<span class="string">&#x27;push eax&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>())</span><br><span class="line"><span class="comment"># 0x4117cd</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>symbols 返回符号地址而不是导入&#x2F;出表地址</p>
</li>
<li><p>设置默认调试器路径，可以在 <code>context.py</code> 中设置调试器路径，这样就不用每次写脚本都设置了。这里我的调试器都添加到环境变量了，所以不需要写完整路径。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb = <span class="string">&quot;gdb&quot;</span></span><br><span class="line">windbg = <span class="string">&quot;WinDbgX&quot;</span></span><br><span class="line">windbgx = <span class="string">&quot;WinDbgX&quot;</span></span><br><span class="line">x64dbg = <span class="string">&quot;x64dbg&quot;</span> <span class="keyword">if</span> arch == <span class="string">&quot;amd64&quot;</span> <span class="keyword">else</span> <span class="string">&quot;x32dbg&quot;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>添加 info，success，fail 的 log 功能与 pwntools 类似。</p>
</li>
</ul>
<h2 id="windbg"><a href="#windbg" class="headerlink" title="windbg"></a>windbg</h2><h3 id="安装-windbg"><a href="#安装-windbg" class="headerlink" title="安装 windbg"></a>安装 windbg</h3><p>直接在微软商店下载 WinDbg Preview 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/2d6cc9a537931fb30b98d491f389e8b1.png"
                     
                ><br>如果 <code>WinDbgX</code> 已经添加到环境变量就可以使用在 winpwn 脚本中用 windbg 附加调试进程。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.windbgx = <span class="string">&#x27;WinDbgX&#x27;</span></span><br><span class="line">windbgx.attach(p)</span><br></pre></td></tr></table></figure></div>

<p>在 windbg 中 选择 setting-&gt;Debugging settings ，在 Default symbol path 一栏填上，其中 <code>c:\mysymbols</code> 可以换成其他路径。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srv*C:\mysymbols*https://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/d106b9e7b7c5d4722a8d0bedb5f7347d.png"
                     
                ></p>
<p>这样 windbg 下载的调试符号就可以保存到对应路径下，下一次调试就不用重新下载符号了。</p>
<p>另外 WinDbg 支持安装插件，比如 <a class="link"   target="_blank" rel="noopener" href="https://github.com/0vercl0k/windbg-scripts" >windbg-scripts<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 可以让 WinDbg 支持 <code>!telescope</code> 命令。</p>
<p>将 windbg-scripts 项目下载下来后，修改项目目录下的 <code>Minfest</code> 目录下的 <code>config.xml</code> ，将其中的 <code>LocalCacheRootFolder</code> 的路径改为 <code>Minfest</code> 目录的绝对路径。之后在 WinDbg 命令行中输入 <code>.settings load c:\path\where\cloned\windbg-scripts\Manifest\config.xml</code> 和 <code>.settings save</code> 然后重启 WinDbg 就可以使用 <code>!telescope</code> 命令。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; !telescope 0x0168fdf4</span><br><span class="line">Populating the VA space with modules..</span><br><span class="line">Populating the VA space with TEBs &amp; thread stacks..</span><br><span class="line">Populating the VA space with the PEB..</span><br><span class="line">0x0168fdf4|+0x0000: 0x76f335f9 (ntdll.dll (.text)) -&gt; jmp ntdll!_DbgUiRemoteBreakin@4+0x42 (76f33602) ; xor eax,eax ; inc eax</span><br><span class="line">0x0168fdf8|+0x0004: 0xe8b095a5 (Unknown)</span><br><span class="line">0x0168fdfc|+0x0008: 0x76f335c0 (ntdll.dll (.text)) -&gt; push 8 ; push 76F937F8h ; call ntdll!__SEH_prolog4 (76f17810)</span><br><span class="line">0x0168fe00|+0x000c: 0x76f335c0 (ntdll.dll (.text)) -&gt; push 8 ; push 76F937F8h ; call ntdll!__SEH_prolog4 (76f17810)</span><br><span class="line">0x0168fe04|+0x0010: 0x00000000 (Unknown)</span><br><span class="line">0x0168fe08|+0x0014: 0x0168fdf8 (Stack) -&gt; 0xe8b095a5 (Unknown)</span><br><span class="line">0x0168fe0c|+0x0018: 0x00000000 (Unknown)</span><br><span class="line">0x0168fe10|+0x001c: 0x0168fe78 (Stack) -&gt; 0x0168fe90 (Stack) -&gt; 0xffffffff (Unknown)</span><br><span class="line">0x0168fe14|+0x0020: 0x76efe8b0 (ntdll.dll (.text)) -&gt; mov edi,edi ; push ebp ; mov ebp,esp</span><br><span class="line">0x0168fe18|+0x0024: 0x9f215c7d (Unknown)</span><br><span class="line">@$telescope(0x0168fdf4)</span><br></pre></td></tr></table></figure></div>

<h3 id="ret-sync-实现-ida-和-windbg-联动调试"><a href="#ret-sync-实现-ida-和-windbg-联动调试" class="headerlink" title="ret_sync 实现 ida 和 windbg 联动调试"></a>ret_sync 实现 ida 和 windbg 联动调试</h3><p>ret_sync 可以把 windbg 的调试位置同步到 ida 上，配置方法如下：</p>
<ul>
<li><p>将 <a class="link"   target="_blank" rel="noopener" href="https://github.com/bootleg/ret-sync" >ret_sync<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 项目下的 <code>ext_ida</code> 文件夹中的文件都复制到 IDA 的 plugins 文件夹下。</p>
</li>
<li><p>到这个<a class="link"   target="_blank" rel="noopener" href="https://dev.azure.com/bootlegdev/ret-sync-release/_build/results?buildId=109&view=artifacts&pathAsName=false&type=publishedArtifacts" >网址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>下载 <code>ret-sync-release-windbg-Win32</code> 和 <code>ret-sync-release-windbg-x64</code> 两个插件。</p>
</li>
<li><p>把下载好的 <code>sync.dll</code> 和 <code>sync32.dll</code>（ 32 位文件夹下的 <code>sync.dll</code> 改名为 <code>sync32.dll</code> ），复制到 <code>C:\Users\username\AppData\Local\Microsoft\WindowsApps</code> 文件夹下（与 WinDbg 在同一目录）。旧版windbg插件安装，参考<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/a684c3f07fae107bc22bd0a613316326.png"
                     
                ></p>
</li>
<li><p>把要调试的 exe 和 dll 都用 ida 打开，然后都选择 Edit-&gt;plugins-&gt;ret_sync 。<br>如果正常的话在 ida 的命令行中会看到如下输出：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[sync] default idb name: stackoverflow.exe</span><br><span class="line">[sync] sync enabled</span><br><span class="line">[sync] cmdline: &quot;C:\Python27\python.exe&quot; -u &quot;C:\Program Files\IDA_Pro_7.7\plugins\retsync\broker.py&quot; --idb &quot;stackoverflow.exe&quot;</span><br><span class="line">[sync] module base 0x400000</span><br><span class="line">[sync] hexrays #7.7.0.220118 found</span><br><span class="line">[sync] broker started</span><br><span class="line">[sync] plugin loaded</span><br><span class="line">[sync] &lt;&lt; broker &lt;&lt; connected to dispatcher</span><br><span class="line">[sync] &lt;&lt; broker &lt;&lt; dispatcher msg: add new client (listening on port 4730), nb client(s): 2</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>打开 WinDbg，选择 文件-&gt;Launch executable 或者附加进程进入调试状态，然后输入 <code>!load sync</code> ，如果是调试 32  位程序则输入的是 <code>!load sync32</code> 。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; !load sync32</span><br><span class="line">[sync] DebugExtensionInitialize, ExtensionApis loaded</span><br></pre></td></tr></table></figure></div>

<p>sync 常用命令如下：</p>
</li>
<li><p><code>!synchelp</code> 查看帮助</p>
</li>
<li><p><code>!sync</code> 完成ida 和 WinDbg 同步。结合 ida 的 Synchronize with 就可以实现 windbg 与 ida 反编译结果的同步。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/df32d63c51ec977256e5dfcc835a6394.png"
                     
                ></p>
</li>
<li><p><code>!idblist</code> 查看已建立连接的 idb 。因为前面我打开了 <code>ntdll.dll</code> 和 <code>stackoverflow.exe</code> 并且都运行了 ret_sync 插件，因此这里可以看到 <code>ntdll.dll</code> 和 <code>stackoverflow.exe</code> 。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; !sync</span><br><span class="line">[sync] No argument found, using default host (127.0.0.1:9100)</span><br><span class="line">[sync] sync success, sock 0x76c</span><br><span class="line">[sync] probing sync</span><br><span class="line">[sync] sync is now enabled with host 127.0.0.1</span><br><span class="line">0:000&gt; !idblist</span><br><span class="line">    [0] ntdll.dll</span><br><span class="line">    [1] stackoverflow.exe</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>可以在 exp 脚本上写好同步命令，这样附加进程后就能与 ida同步。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windbgx.attach(p,<span class="string">&quot;!load sync32\n!sync\nbp 00700000+0119B7\n&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>windbg 的 LocalHelp 可以查看帮助文档。</p>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ul>
<li><p><code>r</code> 查看寄存器状态和当前运行指令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; r</span><br><span class="line">eax=00000210 ebx=003ac000 ecx=001ef9d0 edx=00000000 esi=001efbd4 edi=001efda8</span><br><span class="line">eip=007119b7 esp=001efbd4 ebp=001efda8 iopl=0         nv up ei pl nz ac pe nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000216</span><br><span class="line">stackoverflow+0x119b7:</span><br><span class="line">007119b7 ff1574b17100    call    dword ptr [stackoverflow+0x1b174 (0071b174)] ds:002b:0071b174=&#123;ucrtbased!getchar (7aebcf70)&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code> r @rax=1234</code> 可以修改寄存器的值</p>
</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><ul>
<li><p><code>lmi</code> 查看进程加载的各个模块。通过这个命令可以获得模块的加载基址。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; lmi</span><br><span class="line">start    end        module name</span><br><span class="line">00700000 00720000   stackoverflow C (no symbols)           </span><br><span class="line">753e0000 75652000   KERNELBASE   (deferred)             </span><br><span class="line">75b20000 75c10000   KERNEL32   (pdb symbols)          C:\Windows\System32\KERNEL32.DLL</span><br><span class="line">76e80000 7702f000   ntdll      (pdb symbols)          C:\Windows\SYSTEM32\ntdll.dll</span><br><span class="line">7add0000 7adee000   VCRUNTIME140D   (deferred)             </span><br><span class="line">7adf0000 7af94000   ucrtbased   (private pdb symbols)  C:\Windows\SYSTEM32\ucrtbased.dll</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>!address</code> 查看更详细的段信息，类似 pwndbg 的 <code>vmmap</code> 功能。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; !address	</span><br><span class="line">                                     </span><br><span class="line">Mapping file section regions...</span><br><span class="line">Mapping module regions...</span><br><span class="line">Mapping PEB regions...</span><br><span class="line">Mapping TEB and stack regions...</span><br><span class="line">Mapping heap regions...</span><br><span class="line">Mapping page heap regions...</span><br><span class="line">Mapping other regions...</span><br><span class="line">Mapping stack trace database regions...</span><br><span class="line">Mapping activation context regions...</span><br><span class="line"></span><br><span class="line">  BaseAddr EndAddr+1 RgnSize     Type       State                 Protect             Usage</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line">+        0    60000    60000             MEM_FREE    PAGE_NOACCESS                      Free       </span><br><span class="line">+    60000    63000     3000 MEM_MAPPED  MEM_COMMIT  PAGE_READONLY                      MappedFile &quot;\Device\HarddiskVolume3\Windows\System32\l_intl.nls&quot;</span><br><span class="line">+    63000    70000     d000             MEM_FREE    PAGE_NOACCESS                      Free       </span><br><span class="line">+    70000    80000    10000 MEM_MAPPED  MEM_COMMIT  PAGE_READWRITE                     MappedFile &quot;PageFile&quot;</span><br><span class="line">+    80000    83000     3000 MEM_MAPPED  MEM_COMMIT  PAGE_READONLY                      MappedFile &quot;\Device\HarddiskVolume3\Windows\System32\l_intl.nls&quot;</span><br><span class="line">+    83000    90000     d000             MEM_FREE    PAGE_NOACCESS                      Free       </span><br><span class="line">+    90000    af000    1f000 MEM_MAPPED  MEM_COMMIT  PAGE_READONLY                      Other      [API Set Map]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>!address 地址</code> 查看某个地址所在段信息。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; !address 75bd0000</span><br><span class="line"></span><br><span class="line">Usage:                  Image</span><br><span class="line">Base Address:           75bd0000</span><br><span class="line">End Address:            75bd1000</span><br><span class="line">Region Size:            00001000 (   4.000 kB)</span><br><span class="line">State:                  00001000          MEM_COMMIT</span><br><span class="line">Protect:                00000004          PAGE_READWRITE</span><br><span class="line">Type:                   01000000          MEM_IMAGE</span><br><span class="line">Allocation Base:        75b20000</span><br><span class="line">Allocation Protect:     00000080          PAGE_EXECUTE_WRITECOPY</span><br><span class="line">Image Path:             C:\Windows\System32\KERNEL32.DLL</span><br><span class="line">Module Name:            KERNEL32</span><br><span class="line">Loaded Image Name:      C:\Windows\System32\KERNEL32.DLL</span><br><span class="line">Mapped Image Name:      </span><br><span class="line">More info:              lmv m KERNEL32</span><br><span class="line">More info:              !lmi KERNEL32</span><br><span class="line">More info:              ln 0x75bd0000</span><br><span class="line">More info:              !dh 0x75b20000</span><br><span class="line"></span><br><span class="line">Content source: 1 (target), length: 1000</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h4><ul>
<li><p><code>bp 地址</code> 在某地址处下断点，另外常见命令如 <code>bp ucrtbased!system</code> 可以在 <code>system</code> 函数下断点。</p>
</li>
<li><p><code>bp &lt;address&gt; &quot;&lt;condition&gt;&quot;</code> 在某地址处下条件断点，例如 <code>bp 00401234 &quot;eax==0&quot;</code> 。</p>
</li>
<li><p><code>bl</code> 查看断点，直接点击 <code>Disable</code> 来暂时停用断点，点击 <code>Clear</code> 清除断点。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; bp ucrtbased!system</span><br><span class="line">0:000&gt; bl</span><br><span class="line">     0 e Disable Clear  007119b7     0001 (0001)  0:**** stackoverflow+0x119b7</span><br><span class="line">     1 e Disable Clear  7ae6b8f0  [minkernel\crts\ucrt\src\desktopcrt\exec\system.cpp @ 79]     0001 (0001)  0:**** ucrtbased!system</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><ul>
<li><p><code>dq</code> 八字节查看，<code>dd</code> 四字节查看，<code>dw</code> 两字节查看，<code>dc</code> 一字节查看。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dc 001efbd4</span><br><span class="line">001efbd4  00711348 00711348 003ac000 cccccccc  H.q.H.q...:.....</span><br><span class="line">001efbe4  cccccccc cccccccc cccccccc cccccccc  ................</span><br><span class="line">001efbf4  cccccccc cccccccc cccccccc cccccccc  ................</span><br><span class="line">001efc04  cccccccc cccccccc cccccccc cccccccc  ................</span><br><span class="line">001efc14  cccccccc cccccccc cccccccc cccccccc  ................</span><br><span class="line">001efc24  cccccccc cccccccc cccccccc cccccccc  ................</span><br><span class="line">001efc34  cccccccc cccccccc cccccccc cccccccc  ................</span><br><span class="line">001efc44  cccccccc cccccccc cccccccc cccccccc  ................</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>eq &lt;address&gt; &lt;value&gt;</code> 修改 8 字节长度的内存中的值。<code>ed</code>，<code>ew</code>，<code>eb</code> 同理，只是修改内存长度有区别。 </p>
</li>
<li><p><code>u 地址</code> 查看某地址处的汇编，<code>u</code> 查看程序运行位置的汇编，<code>uf</code> 会一值反汇编到 ret 指令。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; u 00700000+119b7</span><br><span class="line">stackoverflow+0x119b7:</span><br><span class="line">007119b7 ff1574b17100    call    dword ptr [stackoverflow+0x1b174 (0071b174)]</span><br><span class="line">007119bd 3bf4            cmp     esi,esp</span><br><span class="line">007119bf e85df8ffff      call    stackoverflow+0x11221 (00711221)</span><br><span class="line">007119c4 33c0            xor     eax,eax</span><br><span class="line">007119c6 52              push    edx</span><br><span class="line">007119c7 8bcd            mov     ecx,ebp</span><br><span class="line">007119c9 50              push    eax</span><br><span class="line">007119ca 8d15ec197100    lea     edx,[stackoverflow+0x119ec (007119ec)]</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>dt structure [address]</code> 把 address 当成 structure 类型的结构体解析，如果不加 address 就会单纯打印出结构体。<br>例如已知 4 个堆，想查看第一个 heap 的 _HEAP ，因为  _HEAP 就在 heap 的开头，所以第一个 heap 的  _HEAP 就是 23c9cb00000 。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0:001&gt; !heap</span><br><span class="line">        Heap Address      NT/Segment Heap</span><br><span class="line"></span><br><span class="line">         23c9cb00000              NT Heap</span><br><span class="line">         23c9c9d0000              NT Heap</span><br><span class="line">         23c9e530000              NT Heap</span><br><span class="line">         23c9e990000              NT Heap</span><br><span class="line">0:001&gt; dt _heap 23c9cb00000</span><br><span class="line">ntdll!_HEAP</span><br><span class="line">   +0x000 Segment          : _HEAP_SEGMENT</span><br><span class="line">   +0x000 Entry            : _HEAP_ENTRY</span><br><span class="line">   +0x010 SegmentSignature : 0xffeeffee</span><br><span class="line">   +0x014 SegmentFlags     : 2</span><br><span class="line">   +0x018 SegmentListEntry : _LIST_ENTRY [ 0x0000023c`9cb00120 - 0x0000023c`9cb00120 ]</span><br><span class="line">   +0x028 Heap             : 0x0000023c`9cb00000 _HEAP</span><br><span class="line">   +0x030 BaseAddress      : 0x0000023c`9cb00000 Void</span><br><span class="line">   +0x038 NumberOfPages    : 0xff</span><br><span class="line">   +0x040 FirstEntry       : 0x0000023c`9cb00740 _HEAP_ENTRY</span><br><span class="line">   +0x048 LastValidEntry   : 0x0000023c`9cbff000 _HEAP_ENTRY</span><br><span class="line">   +0x050 NumberOfUnCommittedPages : 0xce</span><br><span class="line">   +0x054 NumberOfUnCommittedRanges : 1</span><br><span class="line">   +0x058 SegmentAllocatorBackTraceIndex : 0</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>s -a 7adf0000 L100000 &quot;cmd.exe&quot;</code> 搜索字符串</p>
<ul>
<li><code>-a</code> 表示搜索 ascii 码</li>
<li><code>6a450000</code> 表示搜索起始位置</li>
<li><code>L100000</code> 表示搜索范围是 100000 字节</li>
<li><code>&quot;cmd.exe&quot;</code> 表示搜索内容为 “cmd.exe”</li>
</ul>
<p> 效果如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; s -a 7adf0000 L100000 &quot;cmd.exe&quot;</span><br><span class="line">7ae360ec  63 6d 64 2e 65 78 65 00-69 00 73 00 6c 00 65 00  cmd.exe.i.s.l.e.</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><ul>
<li><code>g</code> 继续运行</li>
<li><code>p</code> 步过</li>
<li><code>t</code> 步入</li>
<li><code>gu</code> 步出</li>
<li><code>k</code> 查看 trace back</li>
</ul>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul>
<li><p><code>~*</code> 用来查看所有线程的信息，可以用来获取 TEB 基址。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; ~*</span><br><span class="line">.  0  Id: b7d0.3784 Suspend: 1 Teb: 00000063`08c76000 Unfrozen</span><br><span class="line">      Start: dadadb+0x1125 (00007ff6`6cb51125)</span><br><span class="line">      Priority: 0  Priority class: 32  Affinity: ffffffff</span><br><span class="line">   1  Id: b7d0.dc20 Suspend: 1 Teb: 00000063`08c78000 Unfrozen</span><br><span class="line">      Start: ntdll!TppWorkerThread (00007ff9`02ca5080)</span><br><span class="line">      Priority: 0  Priority class: 32  Affinity: ffffffff</span><br><span class="line">   2  Id: b7d0.9a54 Suspend: 1 Teb: 00000063`08c7c000 Unfrozen</span><br><span class="line">      Start: ntdll!TppWorkerThread (00007ff9`02ca5080)</span><br><span class="line">      Priority: 0  Priority class: 32  Affinity: ffffffff</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>~#</code> 显示最初导致异常的线程（或在调试器附加到进程时处于活动状态）。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; ~#</span><br><span class="line">.  0  Id: b7d0.3784 Suspend: 1 Teb: 00000063`08c76000 Unfrozen</span><br><span class="line">      Start: dadadb+0x1125 (00007ff6`6cb51125)</span><br><span class="line">      Priority: 0  Priority class: 32  Affinity: ffffffff</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>~[线程编号]s</code>：调试的时候切换线程，例如 <code>~0s</code> 表示切换到 0 号线程，这里的编号即前面 <code>~*</code> 显示在前面的 0，1，2 。</p>
</li>
</ul>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p><code>? 0074fbf4 - 74fa68</code> 可以进行简单运算。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; ? 0074fbf4 - 74fa68</span><br><span class="line">Evaluate expression: 396 = 0000018c</span><br></pre></td></tr></table></figure></div>

<h4 id="查看符号"><a href="#查看符号" class="headerlink" title="查看符号"></a>查看符号</h4><p><code>x ucrtbased!_read</code> 打印 <code>read</code> 函数的地址和其他信息。这个命令支持通配符，比如 <code>x ucrtbased!*read</code> 。 </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; x ucrtbased!_read</span><br><span class="line">7af371d0          ucrtbased!_read (int, void *, unsigned int)</span><br><span class="line">0:000&gt; x ucrtbased!_system</span><br><span class="line">7ae6b8f0          ucrtbased!system (char *)</span><br><span class="line">0:000&gt; x ucrtbased!*system</span><br><span class="line">7ae6b910          ucrtbased!_wsystem (wchar_t *)</span><br><span class="line">7ae88730          ucrtbased!_o__wsystem (wchar_t *)</span><br><span class="line">7ae6b8f0          ucrtbased!system (char *)</span><br><span class="line">7ae8adb0          ucrtbased!_o_system (char *)</span><br></pre></td></tr></table></figure></div>

<h2 id="gadget-搜索工具"><a href="#gadget-搜索工具" class="headerlink" title="gadget 搜索工具"></a>gadget 搜索工具</h2><p>linux 平台的 gadget 搜索工具实际上是支持 PE 文件的，为了方便起见，我把这些工具安装在 wsl 中。这里推荐安装 wsl1 ，因为 wsl2 会与虚拟机中的一些设置冲突。</p>
<h3 id="ROPGadget"><a href="#ROPGadget" class="headerlink" title="ROPGadget"></a>ROPGadget</h3><p>安装方法如下：</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/JonathanSalwan/ROPgadget.git</span><br><span class="line">cd ROPgadget</span><br><span class="line">sudo python3 setup.py install</span><br></pre></td></tr></table></figure></div>

<p>使用方法如下，这样搜索到的 gadget 都写入了 rop 文件中。</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ntdll.dll &gt; rop</span><br></pre></td></tr></table></figure></div>

<h3 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h3><p>安装方法如下：</p>
<ul>
<li><p>在 pypi 的 <a class="link"   target="_blank" rel="noopener" href="https://pypi.org/project/ropper/#files" >ropper 官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>上下载 ropper</p>
</li>
<li><p>运行安装脚本完成 ropper 安装</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>使用方法如下，个人感觉 ropper 搜的全一些。</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper --file ntdll.dll --nocolor &gt; rop</span><br></pre></td></tr></table></figure></div>

<h2 id="远程环境"><a href="#远程环境" class="headerlink" title="远程环境"></a>远程环境</h2><p>在做 windows pwn 题目时需要搭一个接近远程环境的环境。</p>
<h3 id="系统获取"><a href="#系统获取" class="headerlink" title="系统获取"></a>系统获取</h3><p>通常题目会提供一个系统版本截图，例如下图所示系统版本为 <code>1809 17763.615</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/dfbb8bb84197fd13b83fa87b676782a5.png"
                     
                ><br>搜索这个版本号发现该系统的<a class="link"   target="_blank" rel="noopener" href="https://support.microsoft.com/zh-cn/topic/2019-%E5%B9%B4-7-%E6%9C%88-9-%E6%97%A5-kb4507469-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E9%83%A8%E7%89%88%E6%9C%AC-17763-615-388089ed-7308-664f-dc72-d8c91b4e1b23" >相关信息<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，从中可以获取到该版本系统的发布日期。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/bd9c87ff265567ed56db1eaa4155d70e.png"
                     
                ><br>在一个收集 Windows 系统下载的<a class="link"   target="_blank" rel="noopener" href="https://files.rg-adguard.net/version/f0bd8307-d897-ef77-dbd6-216fefbe94c5" >网站<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>上搜索时间相近的版本，比如这里我下载的 2019 年 8 月份发布的 <a class="link"   target="_blank" rel="noopener" href="https://files.rg-adguard.net/file/c936c649-a7cc-7b46-11c6-dc0936c05461" >Windows Server 2019<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 。（<del>最好想办法搞一个 迅雷会员，不然下到一半会失败</del> ）<br>（现在这个网站已经不让下载了，可以用这个<a class="link"   target="_blank" rel="noopener" href="https://msdn.sjjzm.com/" >网站<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>代替）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/53115c30ae685fce4893795642b396ab.png"
                     
                ><br>搭完后，<code>win+r</code>，输入 <code>winver</code> 查看版本 <code>1809 17763.678</code>，非常接近题目给的 <code>1809 17763.615</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/26d895aeb336947262c6ccb24dd0dbb4.png"
                     
                ><br>通过对比发现 <code>ntdll.dll</code> 的关键结构偏移都相同。</p>
<h3 id="AppJailLauncher"><a href="#AppJailLauncher" class="headerlink" title="AppJailLauncher"></a>AppJailLauncher</h3><p><a class="link"   target="_blank" rel="noopener" href="https://github.com/trailofbits/AppJailLauncher" >AppJailLauncher<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 可以将一个 windows 程序的 IO 映射到一个端口上并且能无限重启。</p>
<p>例如下面的命令可以将 <code>stackoverflow_32.exe</code> 的 IO 映射到 22333 端口上，之后用 nc 命令连对应 IP 的 22333 端口上。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; .\AppJailLauncher.exe /nojail /port:22333 /timeout:2000000 stackoverflow_32.exe</span><br><span class="line">Listening for incoming connections on port 22333...</span><br></pre></td></tr></table></figure></div>

<p><strong>注意要关闭 Windows 防火墙。</strong></p>
<h3 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h3><p>为了很好的利用 winpwn 库的便捷性，我直接将调试环境搭建在虚拟机中。</p>
<p>由于该操作系统版本无应用商店，因此我们下载 <a class="link"   target="_blank" rel="noopener" href="https://developer.microsoft.com/zh-cn/windows/downloads/windows-sdk/" >Windows SDK<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 来安装 WinDbg 。在安装时可以只勾选调试器选项。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/30561a046c100aacc2ba2b9011a862be.png"
                     
                ><br>调试发现符号偏移基本一致（我用题目提供的相关 dll 可以正确计算出虚拟机中 dll 的基址）。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/f36df3e07aa785eb147bb307b269348f.png"
                     
                ></p>
<h3 id="替换-dll"><a href="#替换-dll" class="headerlink" title="替换 dll"></a>替换 dll</h3><p>在一些情况下把题目的 dll 和题目的 exe 程序放在同一目录下可以完成替换，不过由于    dll 的加载是按照导入表搜索的过程，因此可能会出现 A.dll 导入一个目录下不存在的 B.dll ，而操作系统找到的 B.dll 在系统目录下因此 B.dll 加载了系统目录下的 C.dll 而没有加载 exe 程序所在目录下的 C.dll 。为了解决这一问题，最直接的办法是想办法找一个使用 dll 的版本与题目所给的 dll 版本相差不大的操作系统然后将题目 dll 替换系统目录下的 dll 实现 dll 替换。</p>
<p>首先看 dll 的签名信息，里面会有一个签名时间。这个时间跟操做系统的发布时间比较接近（大概有5个月左右的误差，这个误差是可接受的）。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/adeaad39c4e86aeba4208415e24d2b5a.png"
                     
                ><br>同样在这个收集 Windows 系统下载的<a class="link"   target="_blank" rel="noopener" href="https://files.rg-adguard.net/version/f0bd8307-d897-ef77-dbd6-216fefbe94c5" >网站<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>上搜索时间相近的版本，这次用到还是 2019 年 8 月发布的 Windows Server 2019 。</p>
<p><strong>另外操作系统的内部版本号与 dll 版本号的倒数第二个数字相同，可以通过搜索内部版本号确定操作系统版本。</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/e60805dd648fd35a1d7c936d63aa70f6.png"
                     
                ></p>
<p>系统原 dll 和要替换的 dll 的版本差别如下（版本号中 <code>.</code> 分隔的数字中如果只有最后一个数字不同那么就可以替换）：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/b2ff719b00e7d7b9b38f2395d350458a.png"
                     
                ><br>正常情况下我们没有权限去操作系统目录下的 dll 也就无法完成 dll 替换，但是有如下方法可以完成。</p>
<p>正常右键查看 dll 属性，<code>property → security → Edit → 选择 users</code> 发现发现权限栏是灰色的，无法修改。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/3ffb29e1cd65f7ae612a7979296d9a9f.png"
                     
                ><br>打开 <code>property → security → Advanced → Change</code> ，然后填入一个存在的用户名，比如创建系统时注册的用户名就行（一般来说这个用户名同时也是当前登录的用户名，我的用户名是 winpwn），然后点击 ok 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/f5b3fc2cc891d11472cb07c11dab7c80.png"
                     
                ><br>此时，打开 <code>property → security → Edit → 选择 users</code> ，发现权限栏变成黑色，选择 Full control ，然后 ok 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/281d86db328c28a3a02d74a90da0de09.png"
                     
                ></p>
<p>此时，就可以改名了（但是无法删除），把dll改成其他名字后，就可以把题目环境同名 dll 复制到 system32 或 sysWOW64 文件夹下了。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/45521a3078a45486de5384127f5d269c.png"
                     
                ><br><strong>重启系统</strong>之后 dll 被成功替换，并且程序可以成功运行。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/468c407535f6cf5add4f745e1110a038.png"
                     
                ><br>按照题目提供的 dll 的偏移可以打通。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/0583d8b406f84999354151e529f9bb8c.png"
                     
                ></p>
<h3 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h3><h4 id="0x1a-问题"><a href="#0x1a-问题" class="headerlink" title="0x1a 问题"></a>0x1a 问题</h4><p>在Windows的命令行窗口(控制台)中，<code>\x1a</code> 代表结束符(End of Text character)，输入包含 <code>\x1a</code> 导致程序 EOF 。<strong>注意，接收 <code>\x1a</code> 不会导致程序 EOF 。</strong></p>
<p><strong>具体表现为交互卡在某个地方，而且这个地方可能是输入 <code>\x1a</code> 后的某一步。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/3675ae1287216ddc4766c1a5fb26def4.png"
                     
                ></p>
<p>要想解决上述问题除了避免输入出现 <code>\x1a</code> 外还可以通过任意地址写修改 <code>ucrtbase.dll</code> 中的 <code>__pioinfo</code> 实现绕过。</p>
<p><code>__pioinfo</code> 是一个 <code>__crt_lowio_handle_data</code> 类型的<strong>结构体指针</strong>。其指向的  <code>__crt_lowio_handle_data</code>  结构体在进程默认堆上，并且每次重启 <code>__crt_lowio_handle_data</code> 进程相对于进程默认堆基址的偏移<strong>相同</strong>。</p>
<p><code>__crt_lowio_handle_data</code>  结构体的定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">declspec</span>(<span class="title">align</span>(8)) __<span class="title">crt_lowio_handle_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _RTL_CRITICAL_SECTION lock;</span><br><span class="line">  __int64 osfhnd;</span><br><span class="line">  __int64 startpos;</span><br><span class="line">  <span class="type">unsigned</span> __int8 osfile;</span><br><span class="line">  __crt_lowio_text_mode textmode;</span><br><span class="line">  <span class="type">char</span> _pipe_lookahead[<span class="number">3</span>];</span><br><span class="line">  <span class="type">unsigned</span> __int8 unicode : <span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> __int8 utf8translations : <span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> __int8 dbcsBufferUsed : <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> mbBuffer[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>其中偏移 0x38 的 <code>osfile</code> 决定着程序的输入流模式，当我们把 <code>osfile</code> 改为 0xc1（也可以是 0x09。<strong>这里建议是 0x9 ，经调试 0xc1 只能读一个 0x1a</strong>）就可以把输入流模式从字符流改为二进制流，从而实现任意字符读入。</p>
<h4 id="回车问题"><a href="#回车问题" class="headerlink" title="回车问题"></a>回车问题</h4><p>Windows 中的回车是 <code>\r\n</code> ，因此如果看到一个程序写的是 <code>printf(&quot;%p\n&quot;,value);</code> 那么实际输出的回车不是 <code>\n</code> 而是 <code>\r\n</code> ，<code>puts</code> 函数在输出完字符串后也会在后面添加 <code>\r\n</code> 。</p>
<p>不过如果需要输入回车那么 <code>\n</code> 和 <code>\r\n</code> 都可以。如果规定只能输入一个字符那么只能是 <code>\n</code> 。</p>
<p>另外如果输入的地址等数据包含 <code>\x0a</code> 那么远程程序接收数据的时候会被 <code>\x0a</code> 截断导致数据接收不完整。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/240ee55fa0621fd16b66a5ea02f1a3c4.png"
                     
                ></p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="windows-函数调用约定"><a href="#windows-函数调用约定" class="headerlink" title="windows 函数调用约定"></a>windows 函数调用约定</h2><p>下面是一些常见的调用约定，实际情况不同类型的编译器具体传参规则会有所不同，需要具体分析。</p>
<h3 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h3><table>
<thead>
<tr>
<th></th>
<th>__cdecl</th>
<th>__stdcall</th>
<th>__fastcall</th>
<th>__thiscall</th>
</tr>
</thead>
<tbody><tr>
<td>参数传递顺序</td>
<td>从右到左</td>
<td>从右到左</td>
<td>使用寄存器和栈</td>
<td>使用寄存器和栈</td>
</tr>
<tr>
<td>平衡栈者</td>
<td>调用者</td>
<td>函数</td>
<td>函数</td>
<td>函数</td>
</tr>
</tbody></table>
<ul>
<li>VARARG 表示参数的个数可以是不确定的，如果使用 VARARG 参数类型，就是调用程序平衡栈，否则按照默认方式平衡栈。</li>
<li><code>__fastcall</code> 传参规则为前两个参数通过 ecx 和 edx 传递，之后的参数通过栈传递。</li>
<li><code>__thiscall</code> 传参规则为 ecx 传递 this 指针，其余参数按照从右到左顺序入栈。</li>
</ul>
<h3 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h3><ul>
<li><code>__thiscall</code> 传参规则为 rcx 传递 this 指针，前三个参数通过 rdx、r8、r9 传递，剩余参数布置在栈中。</li>
<li>其他类型的函数调用传参规则为前四个参数通过 rcx、rdx、r8、r9，剩余参数布置在栈中。</li>
<li>栈平衡由调用者完成。</li>
</ul>
<p>这里需要着重强调一下 windows 64 位函数调用的堆栈。</p>
<p>在函数调用前前 4 个参数放在寄存器中，第 5 个参数开始依次从 <code>[rsp + 0x20]</code> 位置处开始存放。进入调用的函数后会将寄存器中的参数存放到返回地址后空缺的位置上。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/7c8c529968457fcf18a71c74afd7bfcf.png"
                     
                ></p>
<h2 id="PE-文件格式"><a href="#PE-文件格式" class="headerlink" title="PE 文件格式"></a>PE 文件格式</h2><p>这里以 32 位 PE 文件为例，64 位除数据长度外变化不大。</p>
<p>其中 PE 头结构如下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/b0b45f115a50ae1c708e89693d335ec2.png"
                      width="70%"
                >

<h3 id="IMAGE-DOS-HEADER"><a href="#IMAGE-DOS-HEADER" class="headerlink" title="IMAGE_DOS_HEADER"></a>IMAGE_DOS_HEADER</h3><ul>
<li><strong><code>WORD   e_magic</code>：“MZ”标记，用于判断是否为可执行文件</strong>		</li>
<li><strong><code>DWORD  e_lfanew</code> ：PE 头相对于文件的偏移，用于定位 PE 文件</strong></li>
</ul>
<p>			</p>
<h3 id="IMAGE-NT-HEADERS32"><a href="#IMAGE-NT-HEADERS32" class="headerlink" title="IMAGE_NT_HEADERS32"></a>IMAGE_NT_HEADERS32</h3><ul>
<li><code>DWORD Signature</code>：“PE”标记，标记 <code>IMAGE_NT_HEADERS</code> 起始位置</li>
</ul>
<h4 id="IMAGE-FILE-HEADER"><a href="#IMAGE-FILE-HEADER" class="headerlink" title="IMAGE_FILE_HEADER"></a>IMAGE_FILE_HEADER</h4><ul>
<li><strong><code>WORD    Machine</code>：程序运行的CPU型号，0x0 为任何处理器；0x14C 为 i386 及后续处理器</strong></li>
<li><strong><code>WORD    NumberOfSections</code>：文件中存在的节的总数，如果要新增节或者合并节 就要修改这个值</strong></li>
<li><code>DWORD   TimeDateStamp</code>：时间戳，文件的创建时间（和操作系统的创建时间无关），编译器填写的</li>
<li><code>DWORD   PointerToSymbolTable</code></li>
<li><code>DWORD   NumberOfSymbols</code></li>
<li><strong><code>WORD    SizeOfOptionalHeader</code>：可选 PE 头的大小，32 位 PE 文件默认 E0h，64 位 PE 文件默认为 F0h ，大小可以自定义</strong></li>
<li><strong><code>WORD    Characteristics</code>：每个位有不同的含义，可执行文件值为 10F 即 0 1 2 3 8 位置 1</strong></li>
</ul>
<h4 id="IMAGE-OPTIONAL-HEADER32"><a href="#IMAGE-OPTIONAL-HEADER32" class="headerlink" title="IMAGE_OPTIONAL_HEADER32"></a>IMAGE_OPTIONAL_HEADER32</h4><ul>
<li><p><strong><code>WORD    Magic</code>：说明文件类型，10B 为 32 位下的 PE 文件；20B 为 64 位下的 PE 文件</strong></p>
</li>
<li><p><code>BYTE    MajorLinkerVersion</code>									</p>
</li>
<li><p><code>BYTE    MinorLinkerVersion</code>									</p>
</li>
<li><p><code>DWORD   SizeOfCode</code>：所有代码节的和，必须是 <code>FileAlignment</code> 的整数倍，编译器填的，没用	</p>
</li>
<li><p><code>DWORD   SizeOfInitializedData</code>：已初始化数据大小的和，必须是 <code>FileAlignment</code> 的整数倍，编译器填的，没用						</p>
</li>
<li><p><code>DWORD   SizeOfUninitializedData</code>：未初始化数据大小的和，必须是 <code>FileAlignment</code> 的整数倍，编译器填的，没用						</p>
</li>
<li><p><strong><code>DWORD   AddressOfEntryPoint</code>：程序入口</strong></p>
</li>
<li><p><code>DWORD   BaseOfCode</code>：代码开始的基址，编译器填的，没用						</p>
</li>
<li><p><code>DWORD   BaseOfData</code>：数据开始的基址，编译器填的，没用						</p>
</li>
<li><p><strong><code>DWORD   ImageBase</code>：内存镜像基址</strong></p>
</li>
<li><p><strong><code>DWORD   SectionAlignment</code>：内存对齐</strong></p>
</li>
<li><p><strong><code>DWORD   FileAlignment</code>：文件对齐</strong>						</p>
</li>
<li><p><code>WORD    MajorOperatingSystemVersion</code></p>
</li>
<li><p><code>WORD    MinorOperatingSystemVersion</code></p>
</li>
<li><p><code>WORD    MajorImageVersion</code></p>
</li>
<li><p><code>WORD    MinorImageVersion</code></p>
</li>
<li><p><code>WORD    MajorSubsystemVersion</code></p>
</li>
<li><p><code>WORD    MinorSubsystemVersion</code></p>
</li>
<li><p><code>DWORD   Win32VersionValue</code></p>
</li>
<li><p><strong><code>DWORD   SizeOfImage</code>：内存中整个 PE 文件的映射的尺寸，可以比实际的值大，但必须是 <code>SectionAlignment</code> 的整数倍</strong></p>
</li>
<li><p><strong><code>DWORD   SizeOfHeaders</code>：所有头 + 节表按照文件对齐后的大小，否则加载会出错</strong>						</p>
</li>
<li><p><code>DWORD   CheckSum</code>：校验和，一些系统文件有要求，用来判断文件是否被修改</p>
</li>
<li><p><code>WORD    Subsystem</code></p>
</li>
<li><p><code>WORD    DllCharacteristics</code></p>
</li>
<li><p><code>DWORD   SizeOfStackReserve</code>：初始化时保留的堆栈大小</p>
</li>
<li><p><code>DWORD   SizeOfStackCommit</code>：初始化时实际提交的大小 </p>
</li>
<li><p><code>DWORD   SizeOfHeapReserve</code>：初始化时保留的堆大小</p>
</li>
<li><p><code>DWORD   SizeOfHeapCommit</code>：初始化时实践提交的大小 					</p>
</li>
<li><p><code>DWORD   LoaderFlags</code></p>
</li>
<li><p><code>DWORD   NumberOfRvaAndSizes</code>：目录项数目</p>
</li>
<li><p><strong><code>IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]</code>：</strong><br>我们所了解的 PE 分为头和节，在每个节中，都包含了我们写的一些代码和数据，但还有一些非常重要的信息是编译器替我们加到 PE 文件中的，这些信息可能存在在任何可以利用的地方，而数据目录表存储了这些信息的位置和大小。<br><code>DataDirectory</code> 是一个长度为 16 的 <code>IMAGE_DATA_DIRECTORY</code> 类型数组，相关定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16		</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span>				</span><br><span class="line">    DWORD   VirtualAddress;				<span class="comment">//内存偏移</span></span><br><span class="line">    DWORD   Size;				        <span class="comment">//大小</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;				</span><br></pre></td></tr></table></figure></div>

<p>这个数组前 15 项的下标宏以及含义如下，第 16 项保留未使用。</p>
<ul>
<li><code>IMAGE_DIRECTORY_ENTRY_EXPORT</code>：导出表</li>
<li><code>IMAGE_DIRECTORY_ENTRY_IMPORT</code>：导入表</li>
<li><code>IMAGE_DIRECTORY_ENTRY_RESOURCE</code>：资源表</li>
<li><code>IMAGE_DIRECTORY_ENTRY_EXCEPTION</code>：异常信息表</li>
<li><code>IMAGE_DIRECTORY_ENTRY_SECURITY</code>：安全证书表</li>
<li><code>IMAGE_DIRECTORY_ENTRY_BASERELOC</code>：重定位表</li>
<li><code>IMAGE_DIRECTORY_ENTRY_DEBUG</code>：调试信息表</li>
<li><code>IMAGE_DIRECTORY_ENTRY_COPYRIGHT</code>：版权所有表</li>
<li><code>IMAGE_DIRECTORY_ENTRY_GLOBALPTR</code>：全局指针表</li>
<li><code>IMAGE_DIRECTORY_ENTRY_TLS</code>：TLS 表</li>
<li><code>IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG</code>：加载配置表</li>
<li><code>IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</code>：绑定导入表</li>
<li><code>IMAGE_DIRECTORY_ENTRY_IAT</code>：IAT 表</li>
<li><code>IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</code>：延迟导入表</li>
<li><code>IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</code>：COM 信息表</li>
</ul>
</li>
</ul>
<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>重定位表在程序的加载基址不是 <code>ImageBase</code> 时用来修复代码访问字符串，全局变量等数据时使用的地址。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/3477d2f18211ff4e7495029ca11a2c26.png"
                     
                ><br>重定位表是一个由 <code>IMAGE_BASE_RELOCATION + 数据</code> 结构组成的数组。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfBlock;</span><br><span class="line">&#125; IMAGE_BASE_RELOCATION ,* PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure></div>

<p>在内存中的结构如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/06a5522eb1564a035df89341bf6929f4.png"
                      width="80%"
                ><br>每个块用来记录一个内存页中需要重定位的位置。</p>
<ul>
<li><code>VirtualAddress</code> 表示这该内存页的地址</li>
<li><code>SizeOfBlock</code> 表示该块的大小，即 <code>(SizeOfBlock - 8) / 2</code> 为具体项的数量</li>
<li>如果某一项的高 4 位为 0b0011 则该项的低 12 位为需要重定位的位置在该内存页中的偏移</li>
<li>重定位时从需要重定位的位置取出 4 字节长度的数据，将其减去 <code>ImageBase</code> 然后加上模块加载基址，最后将得到的结果写入重定位的位置。</li>
<li>重定位表通过一个模块的起始位置加上 <code>SizeOfBlock</code> 得到下一个模块的起始位置，以一个 <code>VirtualAddress</code> 和 <code>SizeOfBlock</code> 均为 0 的模块为结束标志。</li>
</ul>
<h3 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h3><p>导出表是一个 <code>IMAGE_EXPORT_DIRECTORY</code> 结构：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/ede4f41d2bb72025bbc84ffeba692773.png"
                     
                ></p>
<h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><p>导入表是一个 <code>IMAGE_IMPORT_DESCRIPTOR</code> 结构组成的数组。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;</span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">//RVA 指向IMAGE_THUNK_DATA结构数组</span></span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD   TimeDateStamp;               	<span class="comment">//时间戳</span></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">//RVA,指向IMAGE_THUNK_DATA结构数组</span></span><br><span class="line">    DWORD   Name;						    <span class="comment">//RVA,指向dll名字，该名字已0结尾</span></span><br><span class="line">    DWORD   FirstThunk;                 	<span class="comment">//RVA,指向IMAGE_THUNK_DATA结构数组</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>OriginalFirstThunk</code> 和 <code>FirstThunk</code> 分别指向两个由 <code>IMAGE_THUNK_DATA</code> 结构组成的数组 INT 和 IAT 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PBYTE  ForwarderString;</span><br><span class="line">        PDWORD Function;</span><br><span class="line">        DWORD Ordinal;						    <span class="comment">//序号</span></span><br><span class="line">        PIMAGE_IMPORT_BY_NAME  AddressOfData;	<span class="comment">//指向IMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure></div>

<p><code>IMAGE_THUNK_DATA</code> 可以存储多种类型的数据：</p>
<ul>
<li><code>Function</code>：函数地址</li>
<li><code>Ordinal</code>：函数在其所在 dll 的导出序号</li>
<li><code>AddressOfData</code>：<code>IMAGE_IMPORT_BY_NAME</code> 类型的结构，该结构主要用于存储函数名</li>
</ul>
<p><code>IMAGE_IMPORT_BY_NAME</code> 定义如下，其中 <code>Name</code> 是一个以 <code>\x00</code> 结尾的字符串，长度不确定。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;						<span class="comment">//可能为空，编译器决定 如果不为空 是函数在导出表中的索引						</span></span><br><span class="line">    BYTE    Name[<span class="number">1</span>];					<span class="comment">//函数名称，以0结尾						</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME;	</span><br></pre></td></tr></table></figure></div>

<p>在 PE 文件还未加载到内存时，整个导入表及其相关结构状态如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/878a94b60702926b7b256efb2836305f.png"
                     
                ><br>其中 INT 表和 IAT 表中的内容相同。根据最高位为 1 还是 0 决定 <code>IMAGE_THUNK_DATA</code> 中的内容是 <code>Ordinal</code> 还是 <code>AddressOfData</code> 。</p>
<p>当 PE 文件加载到内存中时，IAT 表会被修为函数地址。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/76b0ffed0b78f020a21f8c16a9db2df2.png"
                     
                ></p>
<h3 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h3><p>节表是由 <code>IMAGE_SECTION_HEADER</code> 构成的数组，数组中元素数量为 <code>IMAGE_FILE_HEADER</code> 中的 <code>NumberOfSections</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SIZEOF_SHORT_NAME              8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>Name</code>：8 个字节 一般情况下是以”\0”结尾的 ASCII 码字符串来标识的名称，内容可以自定义。<br>注意：该名称并不遵守必须以”\0”结尾的规律，如果不是以”\0”结尾，系统会截取 8 个字节的长度进行处理。</li>
<li><code>Misc.VirtualSize</code>：该节在内存中没有对齐前的真实尺寸，该值可以不准确。</li>
<li><code>VirtualAddress</code>：节区在内存中的偏移地址。加上 <code>ImageBase</code> 才是在内存中的真正地址。</li>
<li><code>SizeOfRawData</code>：节在文件中对齐后的尺寸。</li>
<li><code>PointerToRawData</code>：节区在文件中的偏移。</li>
<li><code>PointerToRelocations</code>：在 obj 文件中使用 对 exe 无意义。</li>
<li><code>PointerToLinenumbers</code>：行号表的位置，调试的时候使用。</li>
<li><code>NumberOfRelocations</code>：在 obj 文件中使用，对 exe 无意义。</li>
<li><code>NumberOfLinenumbers</code>：行号表中行号的数量，调试的时候使用。</li>
<li><code>Characteristics</code>：节的属性。</li>
</ul>
<h2 id="常见-dll"><a href="#常见-dll" class="headerlink" title="常见 dll"></a>常见 dll</h2><ul>
<li><code>ntdll.dll</code><ul>
<li>包含未公开 API</li>
<li>系统调用入口</li>
<li>各版本间不同</li>
</ul>
</li>
<li><code>kernel32.dll</code><ul>
<li>堆，虚拟内存，文件 I&#x2F;O 相关的 API</li>
<li>多数函数只是 ntdll 函数的封装</li>
<li>API 几乎不会修改</li>
</ul>
</li>
<li><code>mscrtxxx.dll</code> &#x2F; <code>ucrtbase.dll</code><ul>
<li>类似 linux 中的 glibc</li>
</ul>
</li>
</ul>
<p>dll 之间的函数调用关系如下图所示：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/261d6aaf847878106fa26a586c569086.png"
                      width="60%"
                >

<p><code>mscrtxxx.dll</code> 和 <code>ucrtbase.dll</code> 的区别：</p>
<ul>
<li><p><code>mscrtxxx.dll</code>：Microsoft Visual C++ 运行时库，包含了用于支持早期的 Visual C++ 版本的函数和变量。</p>
</li>
<li><p><code>ucrtbase.dll</code>：Universal C 运行时库，是 Windows 10 中默认的 C 运行时库。它包含了许多标准 C 库函数的实现，以及一些新的安全函数，可以提高代码的安全性和可靠性。</p>
</li>
</ul>
<h2 id="常见结构"><a href="#常见结构" class="headerlink" title="常见结构"></a>常见结构</h2><h3 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h3><p>PEB（Process Environment Block）是 Windows 操作系统中的一个数据结构，它包含了进程的上下文信息。每个进程都有一个唯一的 PEB，它被存储在进程的用户模式地址空间中。<br>PEB 与 TEB 的相对偏移固定，使用 <code>.process</code> 或者 <code>r $peb</code> 查看进程的 PEB 地址，随后使用 <code>dt _PEB peb_addr</code> 查看进程的 PEB 信息。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; .process</span><br><span class="line">Implicit process is now 00995000</span><br><span class="line">0:000&gt; r $peb</span><br><span class="line">$peb=00995000</span><br><span class="line">0:000&gt; dt _PEB 00995000</span><br><span class="line">ntdll!_PEB</span><br><span class="line">   +0x000 InheritedAddressSpace : 0 &#x27;&#x27;</span><br><span class="line">   +0x001 ReadImageFileExecOptions : 0 &#x27;&#x27;</span><br><span class="line">   +0x002 BeingDebugged    : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x003 BitField         : 0x4 &#x27;&#x27;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></div>

<p><code>!peb</code> 查看 PEB 的具体内容，其中 Ldr 的地址为76facb00，即 <code>ntdll!pebldr</code> 地址。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; !peb</span><br><span class="line">PEB at 00995000</span><br><span class="line">    InheritedAddressSpace:    No</span><br><span class="line">    ReadImageFileExecOptions: No</span><br><span class="line">    BeingDebugged:            Yes</span><br><span class="line">    ImageBaseAddress:         00700000</span><br><span class="line">    NtGlobalFlag:             0</span><br><span class="line">    NtGlobalFlag2:            0</span><br><span class="line">    Ldr                       76facb00</span><br><span class="line">    ...</span><br><span class="line">0:000&gt; dc ntdll!pebldr</span><br><span class="line">76facb00  00000030 00000001 00000000 00e12360  0...........`#..</span><br><span class="line">76facb10  00e18418 00e12368 00e18420 00e12278  ....h#.. ...x&quot;..</span><br><span class="line">76facb20  00e182d0 00000000 00000000 00000000  ................</span><br><span class="line">76facb30  00000002 00000000 00000000 00000000  ................</span><br><span class="line">76facb40  00000000 00000000 00000000 00000000  ................</span><br><span class="line">76facb50  00000000 00000000 00000000 00000000  ................</span><br><span class="line">76facb60  00000000 00000000 00000000 00000000  ................</span><br><span class="line">76facb70  00000000 00000000 00000000 00000000  ................</span><br></pre></td></tr></table></figure></div>

<p>PEB 结构在 Windows Pwn 中的作用主要是泄露 TEB 地址，程序基址，以及通过修改其中的 <code>ProcessHeap</code> 完成对进程默认堆的切换。</p>
<h3 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h3><p>TEB（Thread Environment Block）是 Windows 操作系统中的一个线程私有的数据结构，用于存储线程相关的信息。每个线程都有一个对应的 TEB 。32 位程序 FS 寄存器指向当前线程的 TEB ，64 位程序 GS 寄存器指向当前线程的 TEB 。</p>
<p>使用 <code>r $teb</code> 查看进程的 TEB 地址，<code>!teb</code> 可以查看 TEB 详细信息。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; r $teb</span><br><span class="line">$teb=00998000</span><br><span class="line">0:000&gt; !teb</span><br><span class="line">TEB at 00998000</span><br><span class="line">    ExceptionList:        00affcf0</span><br><span class="line">    StackBase:            00b00000</span><br><span class="line">    StackLimit:           00afd000</span><br><span class="line">    SubSystemTib:         00000000</span><br><span class="line">    FiberData:            00001e00</span><br><span class="line">    ArbitraryUserPointer: 00000000</span><br><span class="line">    Self:                 00998000</span><br><span class="line">    EnvironmentPointer:   00000000</span><br><span class="line">    ClientId:             00003638 . 00000ae0</span><br><span class="line">    RpcHandle:            00000000</span><br><span class="line">    Tls Storage:          00e1acb8</span><br><span class="line">    PEB Address:          00995000</span><br><span class="line">    LastErrorValue:       0</span><br><span class="line">    LastStatusValue:      0</span><br><span class="line">    Count Owned Locks:    0</span><br><span class="line">    HardErrorMode:        0</span><br></pre></td></tr></table></figure></div>

<p>TEB 的开头是一个 <code>NT_TIB</code> 结构，具体如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _nt_tib</span><br><span class="line">ntdll!_NT_TIB</span><br><span class="line">   +0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x004 StackBase        : Ptr32 Void</span><br><span class="line">   +0x008 StackLimit       : Ptr32 Void</span><br><span class="line">   +0x00c SubSystemTib     : Ptr32 Void</span><br><span class="line">   +0x010 FiberData        : Ptr32 Void</span><br><span class="line">   +0x010 Version          : Uint4B</span><br><span class="line">   +0x014 ArbitraryUserPointer : Ptr32 Void</span><br><span class="line">   +0x018 Self             : Ptr32 _NT_TIB</span><br></pre></td></tr></table></figure></div>

<p>TEB 结构在 Windows Pwn 中的作用是泄露栈地址。</p>
<p> <code>NT_TIB</code> 中一些重要的字段的解释：</p>
<ul>
<li><code>ExceptionList</code>：指向当前线程的异常处理器链表的头部。当线程发生异常时，系统会将异常处理器添加到该链表中，以便进行异常处理。</li>
<li><code>StackBase</code> 和 <code>StackLimit</code>：分别指向线程栈的起始地址和结束地址。这是我们我们泄露栈基址的一个途径。</li>
<li><code>Self</code>：指向当前 TEB 的指针。对于任何 TEB，该字段的值应该等于 TEB 的地址。</li>
</ul>
<h3 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h3><p>SEH（Structured Exception Handling，结构化异常处理）是 Windows 操作系统中的一种异常处理机制。</p>
<p>异常处理需要注册异常，即在异常处理链表中添加 <code>_EXCEPTION_REGISTRATION_RECORD</code> 节点，代码如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push offset SEHandler</span><br><span class="line">push fs:[0]</span><br><span class="line">mov fs:[0], esp</span><br></pre></td></tr></table></figure></div>

<p>如果程序当前的函数执行完毕需要卸载当前函数中注册的 SEH 处理程序，代码如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov esp, dword ptr fs:[0]</span><br><span class="line">pop dword ptr fs:[0]</span><br></pre></td></tr></table></figure></div>

<p><code>_EXCEPTION_REGISTRATION_RECORD</code> 中的 <code>Next</code> 指向上一个 <code>_EXCEPTION_REGISTRATION_RECORD</code> 结构，<code>Handler</code> 指向异常处理的代码。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/37ce568e423d78eeb65c361cd7a00d37.png"
                     
                ><br>MSC 在 32 位模式对异常处理链表的节点 <code>_EXCEPTION_REGISTRATION_RECORD</code> 被扩充为 <code>CPPEH_RECORD</code> （具体与编译器版本有关），其成员 <code>_EH3_EXCEPTION_REGISTRATION</code> 结构是对原始的 SEH 结构 <code>_EXCEPTION_REGISTRATION_RECORD</code> 的扩充。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EH4_SCOPETABLE_RECORD</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> EnclosingLevel;</span><br><span class="line">    <span class="type">void</span> *FilterFunc;</span><br><span class="line">    <span class="type">void</span> *HandlerFunc;</span><br><span class="line">&#125; *PSCOPETABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EH4_SCOPETABLE</span> &#123;</span></span><br><span class="line">    DWORD GSCookieOffset;</span><br><span class="line">    DWORD GSCookieXOROffset;</span><br><span class="line">    DWORD EHCookieOffset;</span><br><span class="line">    DWORD EHCookieXOROffset;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EH4_SCOPETABLE_RECORD</span> <span class="title">ScopeRecord</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EH3_EXCEPTION_REGISTRATION</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EH3_EXCEPTION_REGISTRATION</span> *<span class="title">Next</span>;</span></span><br><span class="line">    PVOID ExceptionHandler;</span><br><span class="line">    PSCOPETABLE_ENTRY ScopeTable;</span><br><span class="line">    DWORD TryLevel;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CPPEH_RECORD</span> &#123;</span></span><br><span class="line">    DWORD old_esp;</span><br><span class="line">    EXCEPTION_POINTERS *exc_ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EH3_EXCEPTION_REGISTRATION</span> <span class="title">registration</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>MSC编译器引入了<code>_try</code> 、<code>_except</code> 、<code>_finally</code> 关 完成异常处理，使用方法如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__try &#123;</span><br><span class="line">    <span class="comment">/*可能产生异常的代码*/</span></span><br><span class="line">&#125; __except (<span class="comment">/*异常筛选代码*/</span> FilterFunction(GetExceptionCode(), GetExceptionInformation())) &#123;</span><br><span class="line">    <span class="comment">/*异常处理代码*/</span></span><br><span class="line">    ExceptionHandler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__try &#123;</span><br><span class="line">    <span class="comment">/*可能产生异常的代码*/</span></span><br><span class="line">&#125; __finally &#123;</span><br><span class="line">    <span class="comment">/*终结处理代码*/</span></span><br><span class="line">    FinallyHandler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>FilterFunction</code> 由用户定义用来筛选异常，返回值有如下三种：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Defined values for the exception filter expression</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_EXECUTE_HANDLER      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_CONTINUE_SEARCH      0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_CONTINUE_EXECUTION (-1)</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>EXCEPTION_EXECUTE_HANDLER</code>：表示该异常在预料之中，直接执行下面的 <code>ExceptionHandler</code> 。</li>
<li><code>EXCEPTION_CONTINUE_SEARCH</code>：表示不处理该异常，请继续寻找其他处理程序。</li>
<li><code>EXCEPTION_CONTINUE_EXECUTION</code>：表示该异常已被修复，请回到异常现场再次执行。</li>
</ul>
<p><code>ExceptionHandler</code> 处理完异常后，需要返回如下返回值：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exception disposition return values</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">EXCEPTION_DISPOSITION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ExceptionContinueExecution,</span><br><span class="line">    ExceptionContinueSearch,</span><br><span class="line">    ExceptionNestedException,</span><br><span class="line">    ExceptionCollidedUnwind</span><br><span class="line">&#125; EXCEPTION_DISPOSITION;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>ExceptionContinueExecution</code>：表示异常已经被处理，程序可以继续执行。此时，程序会从发生异常的地址处继续执行，而不会跳转到异常处理程序中。</li>
<li><code>ExceptionContinueSearch</code>：表示异常未被处理，程序应该继续搜索异常处理程序。当多个异常处理程序都可以处理同一个异常时，该枚举值可以用于指示程序继续搜索下一个异常处理程序。</li>
<li><code>ExceptionNestedException</code>：表示在处理当前异常时，又发生了一个异常。此时，程序会跳转到新的异常处理程序中，处理新的异常。</li>
<li><code>ExceptionCollidedUnwind</code>：表示发生了一些不可恢复的错误，无法继续执行当前线程。此时，线程的栈会被展开，所有的异常处理程序都会被调用，直到找到一个可以处理当前异常的异常处理程序。如果没有找到这样的异常处理程序，程序将终止。</li>
</ul>
<p>以下面这段代码为例（<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/raw/master/windows_pwn/SEH_learning/SEH.exe" >SEH.exe<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/raw/master/windows_pwn/SEH_learning/SEH.pdb" >SEH.pdb<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    __try &#123;</span><br><span class="line">        __try &#123;</span><br><span class="line">            __try &#123;</span><br><span class="line">                <span class="comment">// 可能会引发异常的代码</span></span><br><span class="line">                *(<span class="type">int</span> *) nullptr = <span class="number">1</span>;</span><br><span class="line">            &#125; __except (EXCEPTION_CONTINUE_SEARCH) &#123;</span><br><span class="line">                <span class="comment">// 处理异常</span></span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Handler 2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">            <span class="comment">// 处理异常</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Handler 1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        __try &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">            x /= x;</span><br><span class="line">        &#125; __finally &#123;</span><br><span class="line">            <span class="comment">// 处理异常</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Handler 3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; __except (EXCEPTION_CONTINUE_EXECUTION) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Handler 4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在不考虑异常处理函数后汇编代码如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">.text:00411810 push    ebp                             ; ebp</span><br><span class="line">.text:00411811 mov     ebp, esp</span><br><span class="line">.text:00411813 push    0FFFFFFFEh                      ; 在 __try 块之外，因此 TryLevel = -2</span><br><span class="line">.text:00411815 push    offset stru_4191F8              ; PSCOPETABLE_ENTRY ScopeTable</span><br><span class="line">.text:0041181A push    offset __except_handler4        ; PVOID ExceptionHandler</span><br><span class="line">.text:0041181F mov     eax, large fs:0</span><br><span class="line">.text:00411825 push    eax                             ; struct _EH3_EXCEPTION_REGISTRATION *Next</span><br><span class="line">.text:00411826 add     esp, -0D4h                      ; 提升栈顶</span><br><span class="line">.text:0041182C push    ebx</span><br><span class="line">.text:0041182D push    esi</span><br><span class="line">.text:0041182E push    edi</span><br><span class="line">.text:0041182F</span><br><span class="line">.text:0041182F __$EncStackInitStart_1:</span><br><span class="line">.text:0041182F lea     edi, [ebp+var_24]</span><br><span class="line">.text:00411832 mov     ecx, 3</span><br><span class="line">.text:00411837 mov     eax, 0CCCCCCCCh</span><br><span class="line">.text:0041183C rep stosd</span><br><span class="line">.text:0041183E</span><br><span class="line">.text:0041183E __$EncStackInitEnd_1:</span><br><span class="line">.text:0041183E mov     eax, ___security_cookie</span><br><span class="line">.text:00411843 xor     [ebp+CPPEH_RECORD.registration.ScopeTable], eax ; ScopeTable ^= ___security_cookie</span><br><span class="line">.text:00411846 xor     eax, ebp</span><br><span class="line">.text:00411848 push    eax                             ; canary = ebp ^ ___security_cookie</span><br><span class="line">.text:00411849 lea     eax, [ebp+CPPEH_RECORD.registration]</span><br><span class="line">.text:0041184C mov     large fs:0, eax                 ; fs:0 -&gt; struct _EH3_EXCEPTION_REGISTRATION registration;</span><br><span class="line">.text:00411852 mov     [ebp+CPPEH_RECORD.old_esp], esp ; DWORD old_esp</span><br><span class="line">.text:00411855 mov     ecx, offset _51A925CF_ConsoleApplication1@cpp ; JMC_flag</span><br><span class="line">.text:0041185A call    j_@__CheckForDebuggerJustMyCode@4 ; __CheckForDebuggerJustMyCode(x)</span><br><span class="line">.text:0041185F mov     [ebp+CPPEH_RECORD.registration.TryLevel], 0 ; 进入 __try0</span><br><span class="line">.text:00411866 mov     [ebp+CPPEH_RECORD.registration.TryLevel], 1 ; 进入 __try1</span><br><span class="line">.text:0041186D mov     [ebp+CPPEH_RECORD.registration.TryLevel], 2 ; 进入 __try2</span><br><span class="line">.text:00411874 mov     large dword ptr ds:0, 1         ; 异常代码</span><br><span class="line">.text:0041187E mov     [ebp+CPPEH_RECORD.registration.TryLevel], 1 ; 退出 __try2</span><br><span class="line">.text:00411885 jmp     short loc_4118AB</span><br><span class="line">...</span><br><span class="line">.text:004118AB loc_4118AB:</span><br><span class="line">.text:004118AB mov     [ebp+CPPEH_RECORD.registration.TryLevel], 0 ; 退出 __try1</span><br><span class="line">.text:004118B2 jmp     short loc_4118DB                ; 进入 __try3</span><br><span class="line">...</span><br><span class="line">.text:004118DB loc_4118DB:</span><br><span class="line">.text:004118DB mov     [ebp+CPPEH_RECORD.registration.TryLevel], 3 ; 进入 __try3</span><br><span class="line">.text:004118E2 mov     [ebp+x], 0</span><br><span class="line">.text:004118E9 mov     eax, [ebp+x]</span><br><span class="line">.text:004118EC cdq</span><br><span class="line">.text:004118ED idiv    [ebp+x]                         ; 异常代码</span><br><span class="line">.text:004118F0 mov     [ebp+x], eax</span><br><span class="line">.text:004118F3 mov     [ebp+CPPEH_RECORD.registration.TryLevel], 0 ; 退出 __try3</span><br><span class="line">.text:004118FA call    $LN20                           ; 调用 __finally</span><br><span class="line">.text:004118FA</span><br><span class="line">.text:004118FF ; ---------------------------------------------------------------------------</span><br><span class="line">.text:004118FF</span><br><span class="line">.text:004118FF loc_4118FF:</span><br><span class="line">.text:004118FF jmp     short $LN23</span><br><span class="line">.text:004118FF</span><br><span class="line">.text:00411901 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00411901</span><br><span class="line">.text:00411901 $LN20:</span><br><span class="line">.text:00411901 ;   __finally // owned by 4118DB</span><br><span class="line">.text:00411901 mov     esi, esp</span><br><span class="line">.text:00411903 push    offset aHandler3                ; &quot;Handler 3&quot;</span><br><span class="line">.text:00411908 call    ds:__imp__puts</span><br><span class="line">.text:00411908</span><br><span class="line">.text:0041190E add     esp, 4</span><br><span class="line">.text:00411911 cmp     esi, esp</span><br><span class="line">.text:00411913 call    j___RTC_CheckEsp</span><br><span class="line">.text:00411913</span><br><span class="line">.text:00411918</span><br><span class="line">.text:00411918 $LN21:</span><br><span class="line">.text:00411918 retn</span><br><span class="line">.text:00411918 ;   &#125; // starts at 4118F3</span><br><span class="line">.text:00411918</span><br><span class="line">.text:00411919 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00411919</span><br><span class="line">.text:00411919 $LN23:</span><br><span class="line">.text:00411919 mov     [ebp+CPPEH_RECORD.registration.TryLevel], 0FFFFFFFEh ; 退出 __try0</span><br><span class="line">.text:00411920 jmp     short loc_411947</span><br><span class="line">...</span><br><span class="line">.text:00411947 loc_411947:</span><br><span class="line">.text:00411947 xor     eax, eax</span><br><span class="line">.text:00411949 mov     ecx, [ebp+CPPEH_RECORD.registration.Next]</span><br><span class="line">.text:0041194C mov     large fs:0, ecx                 ; 卸载 SEH</span><br><span class="line">.text:00411953 pop     ecx</span><br><span class="line">.text:00411954 pop     edi</span><br><span class="line">.text:00411955 pop     esi</span><br><span class="line">.text:00411956 pop     ebx</span><br><span class="line">.text:00411957 add     esp, 0E4h</span><br><span class="line">.text:0041195D cmp     ebp, esp</span><br><span class="line">.text:0041195F call    j___RTC_CheckEsp</span><br><span class="line">.text:0041195F</span><br><span class="line">.text:00411964 mov     esp, ebp</span><br><span class="line">.text:00411966 pop     ebp</span><br><span class="line">.text:00411967 retn</span><br></pre></td></tr></table></figure></div>

<p>通过调试发现相关结构在内存中状态如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/fdf618f495a4eb6c9a668f1beed43595.png"
                     
                ></p>
<p>在 MSC 扩展的 SEH 中，处理函数使用 <code>_except_handler4</code> 作为代理函数来调用用户定义的处理函数。用户定义的 <code>FilterFunc</code> 和 <code>HandlerFunc</code> 保存在 <code>SCOPETABLE</code> 中（实际调试的 <code>SCOPETABLE</code> 可能是使用了 <code>_EH3_SCOPETABLE_RECORD</code> 因此和前面的 <code>_EH4_SCOPETABLE_RECORD</code> 定义有所不同）。<br>通过分析汇编可知，MSC 对用户定义的 <code>__try</code> 块进行了编号，每个 <code>__try</code> 的编号为其在 <code>SCOPETABLE</code> 中对应的 <code>SCOPETABLE_RECORD</code> 的下标，对于不在 <code>__try</code> 块的情况编号为 -2（0xFFFFFE）。当代码执行到某个 <code>__try</code> 块中时，会先将栈中的 <code>CPPEH_RECORD</code> 的 <code>TryLevel</code> 更新为当前所在 <code>__try</code> 块的编号。另外， <code>SCOPETABLE</code> 中的 <code>SCOPETABLE_RECORD</code> 的 <code>EnclosingLevel</code> 记录了 <code>__try</code> 块外层包裹的 <code>__try</code> 块的编号，这样 <code>_except_handler4</code> 进行异常处理的时候就可以按正确的顺序调用处理函数。</p>
<p><strong>注意，_except_handler4 中有一个栈的回滚操作，因此当程序执行到注册在 ScopeTable 中的函数时所在的栈帧是注册该函数所在的栈帧。</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">v6[<span class="number">0</span>] = (<span class="type">int</span>)ExceptionRecord;</span><br><span class="line">v6[<span class="number">1</span>] = (<span class="type">int</span>)ContextRecord;</span><br><span class="line">v16-&gt;Handler = (_EXCEPTION_DISPOSITION (__stdcall *)(_EXCEPTION_RECORD *, <span class="type">void</span> *, _CONTEXT *, <span class="type">void</span> *))v6;</span><br><span class="line"><span class="keyword">for</span> ( i = v16[<span class="number">2</span>].Handler;</span><br><span class="line">      i != (_EXCEPTION_DISPOSITION (__stdcall *)(_EXCEPTION_RECORD *, <span class="type">void</span> *, _CONTEXT *, <span class="type">void</span> *))<span class="number">-2</span>;</span><br><span class="line">      i = EnclosingLevel ) <span class="comment">// 遍历 ScopeTable</span></span><br><span class="line">&#123;</span><br><span class="line">  v12 = &amp;ScopeTable-&gt;ScopeRecord[(_DWORD)i];</span><br><span class="line">  FilterFunc = (<span class="type">int</span> (*)(<span class="type">void</span>))ScopeTable-&gt;ScopeRecord[(_DWORD)i].FilterFunc;</span><br><span class="line">  EnclosingLevel = (_EXCEPTION_DISPOSITION (__stdcall *)(_EXCEPTION_RECORD *, <span class="type">void</span> *, _CONTEXT *, <span class="type">void</span> *))v12-&gt;EnclosingLevel;</span><br><span class="line">  <span class="keyword">if</span> ( FilterFunc )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = _EH4_CallFilterFunc(FilterFunc); <span class="comment">// 调用 Filter 函数</span></span><br><span class="line">    v17 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v10 &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v10 &gt; <span class="number">0</span> ) <span class="comment">// Filter 函数返回值为 EXCEPTION_EXECUTE_HANDLER ，因此调用 Handler 函数</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( ExceptionRecord-&gt;ExceptionCode == <span class="number">0xE06D7363</span></span><br><span class="line">        &amp;&amp; _pDestructExceptionObject</span><br><span class="line">        &amp;&amp; _IsNonwritableInCurrentImage(&amp;_pDestructExceptionObject) )</span><br><span class="line">      &#123;</span><br><span class="line">        Target = (<span class="type">unsigned</span> <span class="type">int</span>)_pDestructExceptionObject;</span><br><span class="line">        _pDestructExceptionObject(ExceptionRecord, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      _EH4_GlobalUnwind2(&amp;v16[<span class="number">1</span>], ExceptionRecord);</span><br><span class="line">      <span class="keyword">if</span> ( v16[<span class="number">2</span>].Handler != i )</span><br><span class="line">        _EH4_LocalUnwind((<span class="type">int</span>)&amp;v16[<span class="number">1</span>], (<span class="type">int</span>)i, (<span class="type">int</span>)FramePointer, (<span class="type">int</span>)CookiePointer); <span class="comment">//栈回滚</span></span><br><span class="line">      v16[<span class="number">2</span>].Handler = EnclosingLevel;</span><br><span class="line">      ValidateLocalCookies(CookieCheckFunction, ScopeTable, FramePointer);</span><br><span class="line">      _EH4_TransferToHandler(v12-&gt;HandlerFunc, FramePointer); <span class="comment">// 调用 Handler 函数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>之后在异常处理函数中还会用 <code>old_esp</code> 替换 esp 进一步完成栈回滚。</strong>（这里非常重要，如果有恢复 <code>esp</code> 为 <code>old_esp</code> 的操作则说明栈帧恢复到注册异常时的栈，异常处理函数准备直接跳转到发生异常的函数的结尾卸载 SEH 然后直接返回，此时 handler 的返回值即为异常函数的返回值，这种情况也对应着 <code>__expect(...)&#123;...&#125;</code> 中没有调用用户定义的异常处理函数而是直接把代码写在 <code>&#123;...&#125;</code> 中而没有返回值的情况。否则说明 handler 在其所在的栈帧中分析处理异常，返回值为异常处理的结果。）</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:004018BD ;   __except(loc_4018B7) // owned by 401869</span><br><span class="line">.text:004018BD mov     esp, [ebp+ms_exc.old_esp]</span><br></pre></td></tr></table></figure></div>

<p><strong>触发异常后</strong>，输入 <code>!exchain</code> 可以查看 seh chain（有一种错误说法是 <code>TryLevel</code> 设为 0 后就可以用 <code>!exchain</code> 查看，实际上必须是触发异常后查看的 chain 才是 seh chain）</p>
<p><code>EXCEPTION_REGISTRATION</code> 依次连接，最后一个 <code>EXCEPTION_REGISTRATION</code> 的 <code>next</code> 为 0xFFFFFFFF ，<code>exceptionhandler</code> 为 <code>ntdll!FinalExceptionHandler</code> 。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; !exchain</span><br><span class="line">0056fcf4: ConsoleApplication1!_except_handler4+0 (00591c70)</span><br><span class="line">  CRT scope  2, filter: ConsoleApplication1!main+77 (00591887)</span><br><span class="line">                func:   ConsoleApplication1!main+7a (0059188a)</span><br><span class="line">  CRT scope  1, filter: ConsoleApplication1!main+a4 (005918b4)</span><br><span class="line">                func:   ConsoleApplication1!main+aa (005918ba)</span><br><span class="line">  CRT scope  0, filter: ConsoleApplication1!main+112 (00591922)</span><br><span class="line">                func:   ConsoleApplication1!main+116 (00591926)</span><br><span class="line">0056fd70: ConsoleApplication1!_except_handler4+0 (00591c70)</span><br><span class="line">  CRT scope  0, filter: ConsoleApplication1!__scrt_common_main_seh+1a3 (00591f93)</span><br><span class="line">                func:   ConsoleApplication1!__scrt_common_main_seh+1be (00591fae)</span><br><span class="line">0056fde8: ntdll!_except_handler4+0 (76efe8b0)</span><br><span class="line">  CRT scope  0, filter: ntdll!__RtlUserThreadStart+40 (76eeb760)</span><br><span class="line">                func:   ntdll!__RtlUserThreadStart+d3 (76eeb7f3)</span><br><span class="line">0056fe00: ntdll!FinalExceptionHandlerPad53+0 (76f18685)</span><br><span class="line">Invalid exception stack at ffffffff</span><br></pre></td></tr></table></figure></div>

<h2 id="常见保护"><a href="#常见保护" class="headerlink" title="常见保护"></a>常见保护</h2><h3 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h3><ul>
<li>类似 Linux 上的 NX 保护，可以理解为内存的可写和可执行不共存。</li>
<li>绕过方法</li>
<li>ROP 调用 VirtualProtect （类似于 Linux 的 mprotect）</li>
</ul>
<h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><ul>
<li>模块加载基址随机而不是按照 ImageBase 加载，每次重启靶机才会改变，而不是每次运行程序时改变。</li>
<li>TEB&#x2F;PEB&#x2F;heap&#x2F;stack 的基址每次运行程序都会改变</li>
<li>一些内核相关的 dll 例如 ntdll.dll 和 kernel32.dll 在所有进程中基址相同</li>
<li>绕过方法<ul>
<li>泄露地址<br>- 一些 dll 的加载基址在所有进程都相同，因此可以在另一个进程中泄露基址。<br>      - 模块加载基址每次重启才会改变，因此只要靶机不重启不必每次运行程序时泄露基址。</li>
<li>爆破<ul>
<li>由于在 32 位程序中地址只随机 8 字节，因此爆破有 1&#x2F;256 的几率成功。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="GS"><a href="#GS" class="headerlink" title="GS"></a>GS</h3><p>windows 版的 canary</p>
<p>在开启 GS 保护的程序的头尾部会有如下代码：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:4B36C225 mov     edi, edi</span><br><span class="line">.text:4B36C227 push    ebp</span><br><span class="line">.text:4B36C228 mov     ebp, esp</span><br><span class="line">.text:4B36C22A sub     esp, 58h</span><br><span class="line">.text:4B36C22D mov     eax, ds:___security_cookie</span><br><span class="line">.text:4B36C232 xor     eax, ebp</span><br><span class="line">.text:4B36C234 mov     [ebp-4], eax</span><br><span class="line">...</span><br><span class="line">.text:4B36C27E mov     ecx, [ebp-4]</span><br><span class="line">...</span><br><span class="line">.text:4B36C282 xor     ecx, ebp                        ; StackCookie</span><br><span class="line">...</span><br><span class="line">.text:4B36C285 call    @__security_check_cookie@4      ; __security_check_cookie(x)</span><br><span class="line">.text:4B36C28A leave</span><br><span class="line">.text:4B36C28B retn</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>__security_check_cookie</code> 函数内容如下，其主要作用是比较 <code>StackCookie</code> 与 <code>___security_cookie</code> 是否相等。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:4B2F83C0 ; void __fastcall __security_check_cookie(uintptr_t StackCookie)</span><br><span class="line">.text:4B2F83C0 @__security_check_cookie@4 proc near</span><br><span class="line">.text:4B2F83C0 cmp     ecx, ds:___security_cookie</span><br><span class="line">.text:4B2F83C6 jnz     short loc_4B2F83CB</span><br><span class="line">.text:4B2F83C8 retn    0</span><br><span class="line">.text:4B2F83CB ; ---------------------------------------------------------------------------</span><br><span class="line">.text:4B2F83CB loc_4B2F83CB:                           ; CODE XREF: __security_check_cookie(x)+6↑j</span><br><span class="line">.text:4B2F83CB jmp     ___report_gsfailure</span><br><span class="line">.text:4B2F83CB @__security_check_cookie@4 endp</span><br></pre></td></tr></table></figure></div>

<p><code>___security_cookie</code> 位于程序模块中的 <code>.data</code> 段中，可读写。在程序入口调用 <code>_security_init_cookie</code> 函数完成该值的初始化。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl _security_init_cookie()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> cookie; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v1; <span class="comment">// [rsp+30h] [rbp+10h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">FILETIME</span> <span class="title">SystemTimeAsFileTime</span>;</span> <span class="comment">// [rsp+38h] [rbp+18h] BYREF</span></span><br><span class="line">  LARGE_INTEGER PerformanceCount; <span class="comment">// [rsp+40h] [rbp+20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  cookie = _security_cookie;</span><br><span class="line">  <span class="keyword">if</span> ( _security_cookie == <span class="number">0x2B992DDFA232</span>i64 )</span><br><span class="line">  &#123;</span><br><span class="line">    SystemTimeAsFileTime = <span class="number">0</span>i64;</span><br><span class="line">    GetSystemTimeAsFileTime(&amp;SystemTimeAsFileTime);</span><br><span class="line">    v1 = (<span class="type">unsigned</span> __int64)SystemTimeAsFileTime;</span><br><span class="line">    v1 ^= GetCurrentThreadId();</span><br><span class="line">    v1 ^= GetCurrentProcessId();</span><br><span class="line">    QueryPerformanceCounter(&amp;PerformanceCount);</span><br><span class="line">    cookie = ((<span class="type">unsigned</span> __int64)&amp;v1 ^ v1 ^ PerformanceCount.QuadPart ^ ((<span class="type">unsigned</span> __int64)PerformanceCount.LowPart &lt;&lt; <span class="number">32</span>)) &amp; <span class="number">0xFFFFFFFFFFFF</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( cookie == <span class="number">0x2B992DDFA232</span>i64 )</span><br><span class="line">      cookie = <span class="number">0x2B992DDFA233</span>i64;</span><br><span class="line">    _security_cookie = cookie;</span><br><span class="line">  &#125;</span><br><span class="line">  qword_140005000 = ~cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>绕过方法：</p>
<ul>
<li>泄露</li>
<li>SEH</li>
</ul>
<h3 id="CheckStackVars"><a href="#CheckStackVars" class="headerlink" title="CheckStackVars"></a>CheckStackVars</h3><p>这个保护是在函数返回前调用 <code>_RTC_CheckStackVars</code> 函数检查栈中的局部变量的前后 4 字节是否被修改，通常在 Debug 版程序中会出现。</p>
<p>以 x64 版本程序为例，通常在函数开头的汇编代码如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">text:0000000140011900 push    rbp</span><br><span class="line">.text:0000000140011902 push    rdi</span><br><span class="line">.text:0000000140011903 sub     rsp, 208h</span><br><span class="line">.text:000000014001190A lea     rbp, [rsp+20h]</span><br><span class="line">.text:000000014001190F mov     rdi, rsp</span><br><span class="line">.text:0000000140011912 mov     ecx, 82h</span><br><span class="line">.text:0000000140011917 mov     eax, 0CCCCCCCCh</span><br><span class="line">.text:000000014001191C rep stosd</span><br></pre></td></tr></table></figure></div>

<p>此时的栈结构如下，其中有一个局部变量 <code>buffer[0x100]</code> 。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/48bb87488b1d525aef7ef8b21bfdd798.png"
                      width="60%"
                >

<p>在函数结束时的汇编代码如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000140011982 lea     rcx, [rbp-20h]                  ; Esp</span><br><span class="line">.text:0000000140011986 lea     rdx, Fd                         ; Fd</span><br><span class="line">.text:000000014001198D call    j__RTC_CheckStackVars</span><br><span class="line">.text:000000014001198D</span><br><span class="line">.text:0000000140011992 mov     eax, edi</span><br><span class="line">.text:0000000140011994 lea     rsp, [rbp+1E8h]</span><br><span class="line">.text:000000014001199B pop     rdi</span><br><span class="line">.text:000000014001199C pop     rbp</span><br><span class="line">.text:000000014001199D retn</span><br></pre></td></tr></table></figure></div>

<p>可以看到函数在结束时调用了 <code>CheckStackVars</code> ，函数原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">RTC_CheckStackVars</span><span class="params">(<span class="type">void</span> *Esp, _RTC_framedesc *Fd)</span></span><br></pre></td></tr></table></figure></div>

<p>其中 <code>Esp</code> 等于上图中的 ESP 寄存器的值， <code>Fd</code> 为一个保存在 <code>.rdata</code> 段的一个 <code>_RTC_framedesc</code> 结构体，该结构体的相关定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">RTC_vardesc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">RTC_framedesc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> varCount;</span><br><span class="line">  _RTC_vardesc *variables;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>在程序中 <code>_RTC_framedesc</code> 相关结构状态如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/6401c342f89ca21ea979e0c3a4c7204e.png"
                     
                ></p>
<ul>
<li><code>varCount</code> 表示 <code>_RTC_vardesc</code> 结构数量，也是该函数中需要检查的局部变量个数。</li>
<li><code>variables</code> 是一个 <code>_RTC_vardesc</code> 结构体指针，指向一个元素个数为 <code>varCount</code> 的结构体数组。</li>
<li><code>_RTC_vardesc</code> 结构体描述了该函数中的一个需要检查的局部变量的相关信息。<ul>
<li><code>addr</code>：变量起始地址相对于 RSP 的偏移。</li>
<li><code>size</code>：变量大小。</li>
<li><code>name</code>：指向变量名称的字符串，用于打印错误信息。</li>
</ul>
</li>
</ul>
<p><code>CheckStackVars</code> 函数定义如下，这个函数遍历 <code>_RTC_vardesc</code> 描述的所有局部变量，检查变量的前后 4 字节是否被修改（即是否不是 0xCCCCCCCC）。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">RTC_CheckStackVars</span><span class="params">(<span class="type">void</span> *Esp, _RTC_framedesc *Fd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> count; <span class="comment">// ebx</span></span><br><span class="line">  __int64 index; <span class="comment">// rdi</span></span><br><span class="line">  _RTC_vardesc *variables; <span class="comment">// rdx</span></span><br><span class="line">  __int64 addr; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">void</span> *retaddr; <span class="comment">// [rsp+28h] [rbp+0h]</span></span><br><span class="line"></span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( Fd-&gt;varCount &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    index = <span class="number">0</span>i64;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      variables = Fd-&gt;variables;</span><br><span class="line">      addr = variables[index].addr;</span><br><span class="line">      <span class="keyword">if</span> ( *(_DWORD *)((<span class="type">char</span> *)Esp + addr - <span class="number">4</span>) != <span class="number">0xCCCCCCCC</span><span class="comment">// 检查变量前面 4 字节是否为 0xCCCCCCCC</span></span><br><span class="line">        || *(_DWORD *)((<span class="type">char</span> *)Esp + addr + variables[index].size) != <span class="number">0xCCCCCCCC</span> )<span class="comment">// 检查变量后面 4 字节是否为 0xCCCCCCCC</span></span><br><span class="line">      &#123;</span><br><span class="line">        _RTC_StackFailure(retaddr, variables[index].name);</span><br><span class="line">      &#125;</span><br><span class="line">      ++count;</span><br><span class="line">      ++index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( count &lt; Fd-&gt;varCount );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在进行栈溢出相关利用时注意在检查的位置填充 <code>\xcc</code> 即可绕过。</p>
<h3 id="SEHOP"><a href="#SEHOP" class="headerlink" title="SEHOP"></a>SEHOP</h3><p>在 <code>ntdll!RtlDispatchException</code> 中有对 SEH 链表的检查（<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/raw/master/windows_pwn/SEH_learning/ntdll.dll" >ntdll.dll<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/raw/master/windows_pwn/SEH_learning/ntdll.dll.idb" >ntdll.dll.idb<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>）：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">      RtlpGetStackLimits(&amp;StackLimit, &amp;StackBase);</span><br><span class="line">      ExceptionList = NtCurrentTeb()-&gt;NtTib.ExceptionList;</span><br><span class="line">      ProcessInformation = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( ZwQueryInformationProcess((HANDLE)<span class="number">0xFFFFFFFF</span>, ProcessExecuteFlags, &amp;ProcessInformation, <span class="number">4u</span>, <span class="number">0</span>) &lt; <span class="number">0</span> )</span><br><span class="line">        ProcessInformation = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (ProcessInformation &amp; <span class="number">0x40</span>) != <span class="number">0</span> || RtlpIsValidExceptionChain(ExceptionList, StackLimit, StackBase) )<span class="comment">// SEHOP</span></span><br><span class="line">      &#123;</span><br><span class="line">LABEL_11:</span><br><span class="line">        RegistrationPointerForCheck = ExceptionList;</span><br><span class="line">        NestedRegistration = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( RegistrationPointerForCheck != (_EXCEPTION_REGISTRATION_RECORD *)<span class="number">-1</span> )<span class="comment">// -1 表示 SEH 链结束</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)RegistrationPointerForCheck &lt; StackLimit</span><br><span class="line">            || (<span class="type">unsigned</span> <span class="type">int</span>)&amp;RegistrationPointerForCheck[<span class="number">1</span>] &gt; StackBase<span class="comment">// SEH 节点不在栈中</span></span><br><span class="line">            || ((<span class="type">unsigned</span> __int8)RegistrationPointerForCheck &amp; <span class="number">3</span>) != <span class="number">0</span><span class="comment">// SEH 节点的位置没有 4 字节对齐</span></span><br><span class="line">            || (Handler = RegistrationPointerForCheck-&gt;Handler, (<span class="type">unsigned</span> <span class="type">int</span>)Handler &lt; StackBase)</span><br><span class="line">            &amp;&amp; StackLimit &lt;= (<span class="type">unsigned</span> <span class="type">int</span>)Handler</span><br><span class="line">            || !RtlIsValidHandler(Handler, ProcessInformation, pContext) )<span class="comment">// safeSEH</span></span><br><span class="line">          &#123;</span><br><span class="line">            pExcptRec-&gt;ExceptionFlags |= EXCEPTION_STACK_INVALID;<span class="comment">// EXCEPTION_STACK_INVALID</span></span><br><span class="line">            <span class="keyword">goto</span> DispatchExit;</span><br><span class="line">          &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>RtlpIsValidExceptionChain</code> 内容如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> __fastcall <span class="title function_">RtlpIsValidExceptionChain</span><span class="params">(</span></span><br><span class="line"><span class="params">        _EXCEPTION_REGISTRATION_RECORD *ExceptionList,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> StackLimit,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> StackBase,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> StackLimita)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> stackBase; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> stackLimit; <span class="comment">// eax</span></span><br><span class="line">  _EXCEPTION_DISPOSITION (__stdcall *Handler)(_EXCEPTION_RECORD *, <span class="type">void</span> *, _CONTEXT *, <span class="type">void</span> *); <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  stackBase = StackBase;</span><br><span class="line">  stackLimit = StackLimit;</span><br><span class="line">  <span class="keyword">while</span> ( ExceptionList != (_EXCEPTION_REGISTRATION_RECORD *)<span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( stackLimit &gt; (<span class="type">unsigned</span> <span class="type">int</span>)ExceptionList )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)ExceptionList &gt;= stackBase - <span class="number">8</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ((<span class="type">unsigned</span> __int8)ExceptionList &amp; <span class="number">3</span>) != <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Handler = ExceptionList-&gt;Handler;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)Handler &lt; stackBase &amp;&amp; StackLimit &lt;= (<span class="type">unsigned</span> <span class="type">int</span>)Handler )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ExceptionList-&gt;Next == (_EXCEPTION_REGISTRATION_RECORD *)<span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      stackBase = StackBase;</span><br><span class="line">      <span class="keyword">if</span> ( (NtCurrentTeb()-&gt;SameTebFlags &amp; <span class="number">0x200</span>) != <span class="number">0</span> &amp;&amp; Handler != RtlpFinalExceptionHandler )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stackLimit = (<span class="type">int</span>)&amp;ExceptionList[<span class="number">1</span>];</span><br><span class="line">    ExceptionList = ExceptionList-&gt;Next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>主要检查 SEH 是否满足如下条件：</p>
<ul>
<li>SEH 节点在栈中</li>
<li>SEH节点指向的 <code>Handler</code> 不在栈中</li>
<li>SEH 节点地址 4 字节对齐</li>
<li>SEH 最后一个节点的 <code>Next</code> 为 -1 且 <code>Handler</code> 为 <code>RtlpFinalExceptionHandler </code></li>
<li>SEH 节点的 <code>Next</code> 指向的下一个节点的地址一定大于当前节点</li>
</ul>
<p>只要泄露栈地址就可以伪造 SEH 链表绕过 SEHOP 检查</p>
<h3 id="SafeSEH"><a href="#SafeSEH" class="headerlink" title="SafeSEH"></a>SafeSEH</h3><p>在 <code>ntdll!RtlDispatchException</code> 中调用 <code>RtlIsValidHandler</code> 进一步检查 SEH 链表，伪代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">RtlIsValidHandler</span><span class="params">(handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (handler image has a SafeSEH table) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler found in the table)</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ExecuteDispatchEnable|ImageDispatchEnable bit <span class="built_in">set</span> in the process flags)</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">if</span> (handler is on a executeable page) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler is in an image) &#123;</span><br><span class="line">            <span class="keyword">if</span> (image has the IMAGE_DLLCHARACTERISTICS_NO_SEH flag <span class="built_in">set</span>)</span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            <span class="keyword">if</span> (image is a .NET assembly whith the ILonly flag <span class="built_in">set</span>)</span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler is not in an image) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ImageDispatchEnable bit <span class="built_in">set</span> in the process flags)</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler is on a non-executable page) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ExecuteDispatchEnable bit <span class="built_in">set</span> in the process flags)</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            raise ACCESS_VIOLATION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>绕过方法：</p>
<ul>
<li>将 <code>Handler</code> 覆盖指向有 SEH 但没有 SafeSEH 保护的 Image 即可绕过。</li>
</ul>
<h3 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h3><p>即 Control Flow Guard ，为函数指针创建白名单，每次调用前都会检查。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00000001400017BD                 mov     rbx, [rdi+Node.FuncPtr]</span><br><span class="line">.text:00000001400017C4                 mov     rcx, rbx</span><br><span class="line">.text:00000001400017C7                 call    cs:__guard_check_icall_fptr</span><br><span class="line">.text:00000001400017CD                 mov     rcx, rdi</span><br><span class="line">.text:00000001400017D0                 call    rbx</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/e7541dac8d6312a1c736ef954694a94c.png"
                     
                ><br>其中函数指针 <code>__guard_check_icall_fptr</code> 位于不可写的 <code>.rdata</code> 段，默认初始化为 <code>ntdll!LdrpValidateUserCallTarget</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">LdrpValidateUserCallTarget</span><span class="params">(<span class="type">unsigned</span> __int64 FuncPtr)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 BitMap; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 Offset; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  BitMap = CFGBitMap[FuncPtr &gt;&gt; <span class="number">9</span>];</span><br><span class="line">  Offset = FuncPtr &gt;&gt; <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (FuncPtr &amp; <span class="number">0xF</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    Offset &amp;= ~<span class="number">1u</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( !_bittest64(&amp;BitMap, Offset) )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_6:</span><br><span class="line">      LdrpHandleInvalidUserCallTarget();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_5:</span><br><span class="line">    <span class="keyword">if</span> ( _bittest64(&amp;BitMap, Offset | <span class="number">1</span>) )</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !_bittest64(&amp;BitMap, Offset) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>绕过方法：</p>
<ul>
<li>ROP</li>
<li>SEH Handler</li>
</ul>
<h3 id="PROCESS-MITIGATION-CHILD-PROCESS-POLICY"><a href="#PROCESS-MITIGATION-CHILD-PROCESS-POLICY" class="headerlink" title="PROCESS_MITIGATION_CHILD_PROCESS_POLICY"></a>PROCESS_MITIGATION_CHILD_PROCESS_POLICY</h3><p><code>PROCESS_MITIGATION_CHILD_PROCESS_POLICY</code> 是Windows操作系统中的一项安全功能。该功能允许管理员指定如何创建子进程以及它们从其父进程继承哪些安全设置。该功能可用于防止子进程继承某些安全设置，例如创建新进程或访问某些系统资源的能力。</p>
<p>可用于配置 <code>PROCESS_MITIGATION_CHILD_PROCESS_POLICY</code> 的几个选项，包括：</p>
<ul>
<li><code>NoChildProcessCreation</code>：防止创建子进程。</li>
<li><code>ParentProcess</code>：允许子进程继承与其父进程相同的安全设置。</li>
<li><code>ChildProcessRestricted</code>：将子进程的安全设置限制为其父进程安全设置的子集。</li>
</ul>
<p>可使用如下命令查询 <code>PROCESS_MITIGATION_CHILD_PROCESS_POLICY</code> 是否已开启（在管理员权限的 Powershell 中查询）：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ProcessMitigation -Name 程序名</span><br></pre></td></tr></table></figure></div>

<p>看到与 <code>PROCESS_MITIGATION_CHILD_PROCESS_POLICY</code> 相关的输出，则表示该保护功能已启用。如果没有相关的输出，则表示该保护功能未启用。（开启并关闭保护也可以查询）</p>
<p>比赛时我们无法查询远程环境的保护是否开启，不过题目会提供远程的启动脚本，其中可能会有 <code>PROCESS_MITIGATION_CHILD_PROCESS_POLICY</code> 保护的开启命令。</p>
<p>可以使用如下命令开启 <code>ChildProcessRestricted</code> 保护，效果是不能执行 <code>system(&quot;cmd.exe&quot;)</code>，只能 ORW 获取 flag 。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ProcessMitigation -Name 程序名 -Enable DisallowChildProcessCreation</span><br></pre></td></tr></table></figure></div>

<h2 id="常见地址泄露方法"><a href="#常见地址泄露方法" class="headerlink" title="常见地址泄露方法"></a>常见地址泄露方法</h2><h3 id="通过导入表泄露"><a href="#通过导入表泄露" class="headerlink" title="通过导入表泄露"></a>通过导入表泄露</h3><p>dll 的基址通常通过另一个模块的导入表泄露，具体各种 dll 之间的导入表关系可以参考前面常见 dll 之间的调用关系。</p>
<h3 id="通过堆泄露"><a href="#通过堆泄露" class="headerlink" title="通过堆泄露"></a>通过堆泄露</h3><p>如果每次重启程序我们都有一次堆基址泄露和一次任意地址读，那么我们可以通过泄露堆上的数据来泄露相关地址。</p>
<ul>
<li><p>ntdll 基址</p>
<p><code>_HEAP</code> 偏移 0x2c0 的地址处存放着一个 <code>ntdll.dll</code> 的地址，我们可以通过任意地址读泄露 <code>&amp;_HEAP + 0x2c0</code> 处存储的 <code>ntdll.dll</code> 地址，从而泄露 <code>ntdll.dll</code> 基址。这里要注意<strong>泄露的 <code>ntdll.dll</code> 地址与 <code>ntdll.dll</code> 基址偏移不固定</strong>，通常需要采用下面这种方法获取 ntdll 的基址。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdll.address = (arbitrary_address_read(heap_base + <span class="number">0x2c0</span>, <span class="literal">True</span>) - <span class="number">0x15f000</span>) &amp; ~<span class="number">0xFFFF</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>程序基址</p>
<p>在 <code>ntdll!LdrpInitializeProcess</code> 函数中有如下代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">LdrpAllocateModuleEntry</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	Heap = RtlAllocateHeap(LdrpHeap, (NtdllBaseTag + <span class="number">0x40000</span>) | <span class="number">8u</span>, <span class="number">288</span>i64);</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">return</span> Heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __fastcall <span class="title function_">LdrpInsertDataTableEntry</span><span class="params">(<span class="type">void</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	qword_1801653D0 = (__int64)a1;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v63 = LdrpAllocateModuleEntry(v137);</span><br><span class="line">...</span><br><span class="line">LdrpImageEntry = v63;</span><br><span class="line">...</span><br><span class="line">v76 = ProcessEnvironmentBlock-&gt;ImageBaseAddress;</span><br><span class="line">v70 = LdrpImageEntry;</span><br><span class="line">...</span><br><span class="line">*(_QWORD *)(v70 + <span class="number">48</span>) = v76;</span><br><span class="line">LdrpInsertDataTableEntry(v70);</span><br></pre></td></tr></table></figure></div>

<p>可以看到，程序在在一个堆地址 <code>v70 + 48</code> 的地方写了一个程序基址。而 <code>v70</code> 是一个堆地址，存储在 ntdll 的全局变量 <code>qword_1801653D0</code> 上。由于 <code>LdrpAllocateModuleEntry</code> 的调用是在默认堆创建不久之后调用的，因此这个堆地址相对于默认堆的基址偏移固定且比较靠近默认堆基址（偏移不超过 16 bit，不会受堆地址随机化影响）。</p>
<p>因此我们可以先用一次任意地址读泄露 <code>qword_1801653D0</code> 存储的数据，根据 <code>qword_1801653D0</code> 的低 16 bit 泄露其与堆基址之间的偏移。</p>
<p>之后再次启动程序，就可以在堆上对应位置泄露出程序基址。</p>
</li>
</ul>
<h3 id="通过-PEB-泄露"><a href="#通过-PEB-泄露" class="headerlink" title="通过 PEB 泄露"></a>通过 PEB 泄露</h3><p>首先我们需要知道如何泄露 PEB 地址。</p>
<p>在 <code>ntdll.dll</code> 中的 <code>ntdll!LdrpInitializeProcess</code> 函数中，有如下代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TEB = NtCurrentTeb();</span><br><span class="line">PEB = (<span class="type">int</span>)TEB-&gt;ProcessEnvironmentBlock;</span><br></pre></td></tr></table></figure></div>

<p>通过查找我们发现 <code>ntdll.dll</code> 中有不少全局变量存放了 PEB 的地址，并且这些变量自从写入 PEB 相关地址后就没有修改过，因此我们可以通过这些变量泄露 PEB 地址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dword_4B3A0C0C = PEB + <span class="number">540</span>;</span><br><span class="line">*(_BYTE *)(PEB + <span class="number">540</span>) |= <span class="number">1u</span>;</span><br><span class="line">*(_DWORD *)(PEB + <span class="number">532</span>) = PEB + <span class="number">528</span>;</span><br><span class="line">*(_DWORD *)(PEB + <span class="number">528</span>) = PEB + <span class="number">528</span>;</span><br><span class="line">TlsBitMap = <span class="number">64</span>;</span><br><span class="line">dword_4B3A0BD4 = PEB + <span class="number">68</span>;</span><br><span class="line">*(_BYTE *)(PEB + <span class="number">68</span>) |= <span class="number">1u</span>;</span><br><span class="line">TlsExpansionBitMap = <span class="number">1024</span>;</span><br><span class="line">dword_4B3A0BBC = PEB + <span class="number">340</span>;</span><br><span class="line">*(_BYTE *)(PEB + <span class="number">340</span>) |= <span class="number">1u</span>;</span><br></pre></td></tr></table></figure></div>

<p>PEB 可以泄露的地址：</p>
<ul>
<li>程序基址：偏移 0x10 的 <code>ImageBaseAddress</code> 为程序基址。</li>
<li>TEB 基址：通常与 PEB 偏移固定，在已知 PEB 基址的情况下可以推算出 TEB 基址。</li>
</ul>
<h3 id="通过-TEB-泄露"><a href="#通过-TEB-泄露" class="headerlink" title="通过 TEB 泄露"></a>通过 TEB 泄露</h3><p>PEB 和 TEB 的相对偏移固定，并且在 WIndows 大版本相同的情况下偏移是一样的，因此在泄露 PEB 地址后 TEB 的地址也可以确定。</p>
<p><strong>注意，一个线程对应一个 TEB 因此要想获取主线程对应的 TEB 地址需要让 WinDbg 段在主程序上然后 <code>r $teb</code> 查看 TEB 地址。</strong></p>
<p>TEB 可以泄露的地址：</p>
<ol>
<li>栈基址：偏移 0x8 的 <code>StackBase</code> 可以泄露栈基址，即栈底地址。</li>
<li>栈顶地址：偏移 0x10 的 <code>StackLimit</code> 可以泄露栈顶地址。</li>
</ol>
<h1 id="windows-异常处理"><a href="#windows-异常处理" class="headerlink" title="windows 异常处理"></a>windows 异常处理</h1><ol>
<li>产生硬件异常通过 IDT 调用异常处理例程， 产生软件异常通过 API 的层层调用产地异常信息。而异常又由于发生位置不同，分为内核异常和用户态异常，二者最后都会靠 <code>kiDispathException</code> 函数来进行异常分发；</li>
<li>当内核产生异常时，程序处理流程进入到 <code>KiDispatchException</code> 函数，在该函数内备份当前线程 R3 的 <code>TrapFrame</code>（即栈帧的基址）。异常处理首先判断这是否是第一次异常，判断是否存在内核调试器，如果有内核调试器，则把当前的异常信息发送给内核调试器；如果没有内核调试器或者内核调试器没有处该异常 ， 则进入<strong>步骤 3</strong> ，调用 <code>RtlDispatchException</code> 。</li>
<li>内核异常进入 <code>RtlDispatchException</code> 函 数， 如果 <code>RtlDispatchException</code> 函数没有处理该异常，那么将再次尝试将异常发送到内核调试器，如果此时内核调试器仍然不存在或者没有处理该异常，那么此时系统会直接蓝屏；</li>
<li>如果是用户态异常则经过 <code>KiDispatchException</code> 进行用户态异常分发和处理。如果是第一次分发异常，则调用 <code>DbgKForwardException</code> 将异常分发到内核调试器；如果内核调试器不存在或没有处理异常，则尝试将异常分发给用户态调试器；如果异常被处理，则进入<strong>步骤 10</strong> ；如果用户态调试器不存在或未处理异常，则检测是否是第一次处理异常，如果是第一次处理异常则进入<strong>第 5 步</strong>中的异常数据准备；</li>
<li>准备一个返回 <code>ntdll!KiUserExceptionDispatcher</code> 函数的应用层调用栈，结束本次 <code>KiDispatchException</code> 函数的运行，调用 <code>KiServiceExit</code> 返回用户层。此时函数栈帧是 <code>ntdll!KiUserExceptionDispatcher</code> 的执行环境，用户态线程从执行 <code>ntdll!KiUserExceptionDispatcher</code> 开始执行。该函数调用 <code>ntdll!RtlDispatchException</code> 进行异常的分发，进入<strong>第 6 步</strong>；</li>
<li>通过 <code>RtlCallVectoredExceptionHandlers</code> 遍历 VEH 链表尝试查找异常处理函数；如果 VEH 未处理异常。则从 <code>fs[0]</code> 读取 <code>ExceptionList</code> 并开始执行 SEH 函数处理，进入<strong>步骤 7</strong>；</li>
<li>如果 SEH 没有处理函数处理该异常，则检查用户是否通过 <code>SetUnhandledExceptionFilter</code> 函数注册过进程的异常处理函数，如果用户注册过异常处理函数，调用该异常处理函数，如果异常没有被成功处理或没有自定义的异常处理函数，则进入<strong>步骤 3</strong> ；</li>
<li>如果最后仍没有处理该异常，便会主动调用 <code>NtRaiseException</code> 将该异常重新跑出来，但是此时不是第一次分发，此时 <code>NtRaiseException</code> 流程重新调用了 <code>ntdll!KiDispatchException</code> ，并再次进入用户态异常的处理分支，进入<strong>步骤 9</strong> ；</li>
<li>第二次进入用户态异常处理时，不会再尝试发送到内核调试器，也不会再进行异常分发，而是直接尝试发送到用户态体异常调试器，如果最后异常仍未被处理则进入<strong>步骤 11</strong> ；</li>
<li>异常被处理，调用 <code>NtContine</code> ，将之前保存的 <code>TrapFrame</code> 还原，程序继续从异常处正常运行；</li>
<li>异常不能被处理，系统调用 <code>ntdll!KiDispatchException</code> 调用 <code>ZwTerminateProcess</code>结束进程。</li>
</ol>
<h1 id="windows-IO-FILE"><a href="#windows-IO-FILE" class="headerlink" title="windows IO_FILE"></a>windows IO_FILE</h1><p>Windows 的 <code>FILE</code> 结构体定义在 <code>ucrtbase.dll</code> 中，在使用 IDA 打开 <code>ucrtbase.dll</code> 时会根据调试信息表 <code>IMAGE_DIRECTORY_ENTRY_DEBUG</code> 中的 pdb 信息下载相关符号，由于 <code>ucrtbase.dll</code> 为 Release 版，因此没有 <code>FILE</code> 结构体的具体定义。不过通过对比 Debug 版的 <code>ucrtbased.dll</code> 我们发现 <code>FILE</code> 结构体实际上是 <code>__crt_stdio_stream_data</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/c414e31385537901b6e031d6bbb97de9.png"
                     
                ><br><code>__crt_stdio_stream_data</code> 相关定义如下，该结构体大小为 0x58 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">RTL_CRITICAL_SECTION</span> &#123;</span></span><br><span class="line">    _RTL_CRITICAL_SECTION_DEBUG *DebugInfo;</span><br><span class="line">    <span class="type">int</span> LockCount;</span><br><span class="line">    <span class="type">int</span> RecursionCount;</span><br><span class="line">    <span class="type">void</span> *OwningThread;</span><br><span class="line">    <span class="type">void</span> *LockSemaphore;</span><br><span class="line">    <span class="type">unsigned</span> __int64 SpinCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">crt_stdio_stream_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        FILE _public_file;</span><br><span class="line">        <span class="type">char</span>* _ptr; <span class="comment">// 当前结构指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *_base; <span class="comment">// 输入缓冲区基址</span></span><br><span class="line">    <span class="type">int</span> _cnt; <span class="comment">// 没有被读出的缓冲区剩余大小</span></span><br><span class="line">    <span class="type">int</span> _flags;</span><br><span class="line">    <span class="type">int</span> _file; <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">int</span> _charbuf; <span class="comment">// Local buffer</span></span><br><span class="line">    <span class="type">int</span> _bufsiz; <span class="comment">// buffer size</span></span><br><span class="line">    <span class="type">char</span> *_tmpfname;</span><br><span class="line">    _RTL_CRITICAL_SECTION _lock; <span class="comment">// lock</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>如果要实现任意地址读，<code>fwrite</code>：</p>
<ul>
<li>设置 <code>_file</code> 文件描述符为 <code>stdout</code> 输出符</li>
<li>设置 <code>_flag</code> 为 <code>_IOWRITE | IOBUFFER_USER | _IOUPDATE</code></li>
<li>设置 <code>_cnt=0</code></li>
<li>设置 <code>_base&amp; _ptr</code> 指向读取的地址</li>
<li>设置 <code>_bufsize</code> 为输出的大小</li>
</ul>
<p>如果要实现任意地址写，<code>fread</code>：</p>
<ul>
<li>设置 <code>_file</code> 文件描述符为 <code>stdin</code> 输出符</li>
<li>设置 <code>_flag</code> 为 <code>_IOALLOCATED | _IOBUFFER_USER</code></li>
<li>设置 <code>_cnt=0</code></li>
<li>设置 <code>_base&amp; _ptr</code> 指向写入的地址</li>
<li>设置 <code>_bufsize</code> 为输入的大小</li>
</ul>
<p>程序在每次执行如下代码时会在进程的<strong>默认堆</strong>中申请一个 0x60 大小的 chunk 并将其填充为 <code>__crt_stdio_stream_data</code> 结构体然后将该结构体地址写入 <code>Stream</code> 中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fopen_s(&amp;Stream, <span class="string">&quot;magic.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>如果我们能够劫持 <code>Stream</code> 指针或者 UAF 修改 <code>__crt_stdio_stream_data</code> 结构体就可以在执行下面这段代码时实现任意地址写。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fread_s(buffer, size, <span class="number">1u</span>i64, size, Stream);</span><br></pre></td></tr></table></figure></div>

<p>具体伪造方式如下，主要操作是把 <code>_base</code> 指向要写入数据的地址，<code>_file</code> 设为 0 即标准输入。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fake_FILE = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_FILE += p64(<span class="number">0</span>)  <span class="comment"># _ptr</span></span><br><span class="line">fake_FILE += p64(target_addr)  <span class="comment"># _base</span></span><br><span class="line">fake_FILE += p32(<span class="number">0</span>)  <span class="comment"># _cnt</span></span><br><span class="line">fake_FILE += p32(<span class="number">0x2080</span>)  <span class="comment"># _flags</span></span><br><span class="line">fake_FILE += p32(<span class="number">0</span>)  <span class="comment"># _file = stdin(0)</span></span><br><span class="line">fake_FILE += p32(<span class="number">0</span>)  <span class="comment"># _charbuf</span></span><br><span class="line">fake_FILE += p64(<span class="number">0x200</span>)  <span class="comment"># _bufsiz</span></span><br><span class="line">fake_FILE += p64(<span class="number">0</span>)  <span class="comment"># _tmpfname</span></span><br><span class="line">fake_FILE += p64(<span class="number">0xffffffffffffffff</span>)  <span class="comment"># DebugInfo</span></span><br><span class="line">fake_FILE += p32(<span class="number">0xffffffff</span>)  <span class="comment"># LockCount</span></span><br><span class="line">fake_FILE += p32(<span class="number">0</span>)  <span class="comment"># RecursionCount</span></span><br><span class="line">fake_FILE += p64(<span class="number">0</span>)  <span class="comment"># OwningThread</span></span><br><span class="line">fake_FILE += p64(<span class="number">0</span>)  <span class="comment"># LockSemaphore</span></span><br><span class="line">fake_FILE += p64(<span class="number">0</span>)  <span class="comment"># SpinCount</span></span><br></pre></td></tr></table></figure></div>



<h1 id="windows-堆基础"><a href="#windows-堆基础" class="headerlink" title="windows 堆基础"></a>windows 堆基础</h1><h2 id="Windows-堆概述"><a href="#Windows-堆概述" class="headerlink" title="Windows 堆概述"></a>Windows 堆概述</h2><h3 id="Windows-堆类型"><a href="#Windows-堆类型" class="headerlink" title="Windows 堆类型"></a>Windows 堆类型</h3><ul>
<li>在 Win10 和 Win Server2016 版本之前，只有一种堆类型 NT Heap</li>
<li>在 Win10 和 Win Server2016 之后，引入了 Segment Heap（段堆）</li>
<li>在之后版本中，除了 UWP 程序之外 一般都继续使用 NT Heap 进行堆管</li>
</ul>
<blockquote>
<p>UWP（Universal Windows Platform）是 Win10 引入的一种新的应用程序开发模型，他们采用了一套共享的 API 。所以采用 UWP开发的程序，可以在所有 Win10 设备上运行。<br><br>要想区分是一个正常程序还是 UWP 程序有以下方法：</p>
<ul>
<li>打开任务管理器，查看其中打开的程序能否展开，如果可以，且其中一个是 Runtime Broker ， 另外一个是应用本身，那么就是 UWP 应用。</li>
<li>在开始菜单右键应用，点击更多，查看其中有没有应用设置 。有的话就是 UWP 应用。</li>
<li>在开始菜单，找到 UWP 应用并右键，打开应用设置，查看版本信息。</li>
</ul>
</blockquote>
<h3 id="Windows-用户态进程堆空间"><a href="#Windows-用户态进程堆空间" class="headerlink" title="Windows 用户态进程堆空间"></a>Windows 用户态进程堆空间</h3><p>每个进程的堆包含两种类型：</p>
<ul>
<li>Process Heap（默认），整个进程共享的堆，它包括两个部分：<ul>
<li>default heap ，其地址信息会存放于 _PEB 的 ProcessHeap 中，在调用 malloc 等函数的时候会用到。</li>
<li>crtheap，但是其本质一样是 default ，封装了一些别的信息，存放于 crt_heap 中。</li>
</ul>
</li>
<li>Private Heap，通过 HeapCreate 创建的堆。</li>
</ul>
<p>普通进程堆空间：</p>
<ul>
<li>默认堆</li>
<li>用于向进程的会话 Csrss.exe 实例传递大参数的共享堆。这是由 CsrClientConnectToServer 函数创建的，该函数在 ntdll.dll 完成的进程初始化早期执行。</li>
<li>由 Microsoft C 运行库创建的堆。该堆是由 C&#x2F;C++ 内存分配函数（如malloc 、free 等）内部使用的堆。</li>
</ul>
<p>UWP 应用程序进程除了普通进程堆空间包含的堆外还包含 Segment Heap 段堆。</p>
<h3 id="堆管理常见函数"><a href="#堆管理常见函数" class="headerlink" title="堆管理常见函数"></a>堆管理常见函数</h3><h4 id="HeapCreate"><a href="#HeapCreate" class="headerlink" title="HeapCreate"></a>HeapCreate</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI HANDLE WINAPI <span class="title function_">HeapCreate</span> <span class="params">(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>作用：创建一个新的堆对象。</li>
<li>参数：<ul>
<li><code>flOptions</code>：堆的选项标志。可以是以下标志的组合：<ul>
<li><code>HEAP_GENERATE_EXCEPTIONS</code>：在内存不足时引发异常。</li>
<li><code>HEAP_NO_SERIALIZE</code>：多线程访问堆时不进行同步。</li>
</ul>
</li>
<li><code>dwInitialSize</code>：堆的初始大小（以字节为单位）。如果为 0 ，则系统会选择一个默认的初始大小。</li>
<li><code>dwMaximumSize</code>：堆的最大大小（以字节为单位）。如果为 0 ，则堆的大小受系统的限制。</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果操作成功，返回堆对象的句柄；</li>
<li>如果操作失败，返回 NULL 。</li>
</ul>
</li>
</ul>
<p><code>HeapCreate</code> 函数用于创建一个新的堆对象，该堆对象提供了一种用于内存分配和管理的机制。堆是进程专用的内存区域，用于动态分配和释放内存块。通过使用堆，可以有效地管理不同大小的内存块，并提供多线程访问的同步机制。</p>
<p>使用 <code>HeapCreate</code> 函数创建堆后，可以使用其他堆相关的函数（如 <code>HeapAlloc</code> 、<code>HeapFree</code> 等）来分配和释放内存块。堆对象可以在不再需要时使用 <code>HeapDestroy</code> 函数进行销毁。</p>
<h4 id="HeapAlloc-HeapFree"><a href="#HeapAlloc-HeapFree" class="headerlink" title="HeapAlloc&#x2F;HeapFree"></a>HeapAlloc&#x2F;HeapFree</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI LPVOID WINAPI <span class="title function_">HeapAlloc</span> <span class="params">(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>作用：在指定的堆中分配指定大小的内存块。</li>
<li>参数：<ul>
<li><code>hHeap</code>：要分配内存的堆的句柄。此句柄通常由HeapCreate函数创建。</li>
<li><code>dwFlags</code>：内存分配的标志。可以是以下标志的组合：<ul>
<li><code>HEAP_ZERO_MEMORY</code>：分配的内存块被初始化为零。</li>
<li><code>HEAP_GENERATE_EXCEPTIONS</code>：在分配内存时发生错误时生成异常。</li>
<li><code>HEAP_NO_SERIALIZE</code>：禁用堆的同步机制，使多线程访问堆时不同步。</li>
</ul>
</li>
<li><code>dwBytes</code>：要分配的内存块的大小（以字节为单位）。</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果分配成功，返回指向分配的内存块的指针；</li>
<li>如果分配失败，返回 NULL 。</li>
</ul>
</li>
</ul>
<p><code>HeapAlloc</code> 函数用于在指定的堆中分配内存块。通过传入合适的堆句柄，可以在特定的堆对象上进行内存分配和管理操作。分配的内存块可以是可变大小的，并且可以根据需要进行零初始化。</p>
<p>需要注意的是，<code>HeapAlloc</code> 函数是在指定的堆上进行内存分配，而不是全局堆或本地堆。因此，使用 <code>HeapAlloc</code> 函数的前提是必须先通过 <code>HeapCreate</code> 函数创建堆对象，并获取相应的堆句柄。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI WINBOOL WINAPI <span class="title function_">HeapFree</span><span class="params">(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>作用：释放指定堆中的内存块。</li>
<li>参数：<ul>
<li><code>hHeap</code>：要释放内存的堆的句柄。</li>
<li><code>dwFlags</code>：释放内存的标志。可以是以下标志的组合：<ul>
<li><code>HEAP_NO_SERIALIZE</code>：禁用堆的同步机制，使多线程访问堆时不同步。</li>
</ul>
</li>
<li><code>lpMem</code>：要释放的内存块的指针。</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果操作成功，返回 TRUE ；</li>
<li>如果操作失败，返回 FALSE 。</li>
</ul>
</li>
</ul>
<p><code>HeapFree</code> 函数用于释放指定堆中的内存块，将之前分配的内存返回给堆以供重用。通过传入适当的堆句柄和内存块指针，可以释放特定堆中的特定内存块。</p>
<h4 id="VirtualAlloc-VirtualFree"><a href="#VirtualAlloc-VirtualFree" class="headerlink" title="VirtualAlloc&#x2F;VirtualFree"></a>VirtualAlloc&#x2F;VirtualFree</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI LPVOID WINAPI <span class="title function_">VirtualAlloc</span> <span class="params">(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>作用：为进程保留或提交指定大小的虚拟内存区域。</li>
<li>参数：<ul>
<li><code>lpAddress</code>：要保留或提交的虚拟内存区域的首字节地址。可以指定为NULL，表示由系统选择地址。</li>
<li><code>dwSize</code>：要保留或提交的虚拟内存区域的大小（以字节为单位）。</li>
<li><code>flAllocationType</code>：内存分配的类型标志。可以是以下标志的组合：<ul>
<li><code>MEM_COMMIT</code>：提交虚拟内存区域。</li>
<li><code>MEM_RESERVE</code>：保留虚拟内存区域。</li>
<li><code>MEM_RESET</code>：将虚拟内存区域的内容重置为零。</li>
<li><code>MEM_RESET_UNDO</code>：撤消对虚拟内存区域的重置操作。</li>
</ul>
</li>
<li><code>flProtect</code>：内存保护标志，指定分配的内存区域的访问权限和保护级别。</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果操作成功，返回分配的虚拟内存区域的首字节地址；</li>
<li>如果操作失败，返回 NULL 。</li>
</ul>
</li>
</ul>
<p><code>VirtualAlloc</code> 函数用于在进程的虚拟地址空间中分配或提交虚拟内存区域。虚拟内存可以用于多种目的，例如分配堆内存、映射文件等。通过指定不同的标志，可以控制对虚拟内存的保留、提交和重置操作，并指定相应的内存保护级别。</p>
<p>需要注意的是，<code>VirtualAlloc</code> 函数操作的是虚拟内存，而非物理内存。分配的虚拟内存区域在使用之前需要进行显式的提交操作（使用 <code>MEM_COMMIT</code> 标志），否则访问该内存区域将导致访问冲突异常。此外，释放虚拟内存区域的操作通常使用 <code>VirtualFree</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI WINBOOL WINAPI <span class="title function_">VirtualFree</span><span class="params">(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>作用：释放指定区域的虚拟内存。</li>
<li>参数：<ul>
<li><code>lpAddress</code>：要释放的虚拟内存区域的起始地址。</li>
<li><code>dwSize</code>：要释放的虚拟内存区域的大小（以字节为单位）。</li>
<li><code>dwFreeType</code>：释放内存的类型。可以是以下常量之一：<ul>
<li><code>MEM_DECOMMIT</code>：取消提交内存，将内存区域标记为未提交状态。</li>
<li><code>MEM_RELEASE</code>：释放内存，将内存区域标记为不再使用。</li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果操作成功，返回 TRUE ；</li>
<li>如果操作失败，返回 FALSE 。</li>
</ul>
</li>
</ul>
<h4 id="LocalAlloc-LocalFree"><a href="#LocalAlloc-LocalFree" class="headerlink" title="LocalAlloc&#x2F;LocalFree"></a>LocalAlloc&#x2F;LocalFree</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI HLOCAL WINAPI <span class="title function_">LocalAlloc</span> <span class="params">(UINT uFlags, SIZE_T uBytes)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>作用：在本地堆中分配指定大小的内存块。</li>
<li>参数：<ul>
<li><code>uFlags</code>：内存分配的标志。可以是以下标志的组合：<ul>
<li><code>LPTR</code>：返回一个指向分配的内存块的指针，并将内存内容初始化为零。</li>
<li><code>LMEM_FIXED</code>：返回一个固定的指针，表示分配的内存块。</li>
<li><code>LMEM_ZEROINIT</code>：分配的内存块被初始化为零。</li>
</ul>
</li>
<li><code>uBytes</code>：要分配的内存块的大小（以字节为单位）。</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果分配成功，返回一个指向分配的内存块的指针（如果使用了 <code>LMEM_FIXED</code> 标志）或句柄（如果使用了 <code>LPTR</code> 标志）。</li>
<li>如果分配失败，返回 NULL 。</li>
</ul>
</li>
</ul>
<p><code>LocalAlloc</code> 函数用于在本地堆中分配内存。本地堆是进程私有的内存区域，只能由相应进程访问。通过指定不同的标志，可以选择返回指针或句柄来表示分配的内存块。分配的内存块可以是固定的（使用指针）或可移动的（使用句柄）。</p>
<p>需要注意的是，<code>LocalAlloc</code> 函数已经过时，不推荐在新的应用程序中使用。现代的 Windows 应用程序通常使用 <code>HeapAlloc</code> 或其他更高级的内存分配函数来进行内存管理。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI HLOCAL WINAPI <span class="title function_">LocalFree</span><span class="params">(HLOCAL hMem)</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>作用：释放指定的本地内存块。</li>
<li>参数：<ul>
<li><code>hMem</code>：要释放的本地内存块的句柄。</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果操作成功，返回 NULL ；</li>
<li>如果操作失败，返回输入的句柄 <code>hMem</code> 。</li>
</ul>
</li>
</ul>
<h4 id="GlobalAlloc-GlobalFree"><a href="#GlobalAlloc-GlobalFree" class="headerlink" title="GlobalAlloc&#x2F;GlobalFree"></a>GlobalAlloc&#x2F;GlobalFree</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI HGLOBAL WINAPI <span class="title function_">GlobalAlloc</span> <span class="params">(UINT uFlags, SIZE_T dwBytes)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>作用：在全局堆中分配指定大小的内存块。</li>
<li>参数：<ul>
<li><code>uFlags</code>：内存分配的标志。可以是以下标志的组合：<ul>
<li><code>GMEM_FIXED</code>：返回一个固定的指针，表示分配的内存块。</li>
<li><code>GMEM_MOVEABLE</code>：返回一个可移动的句柄，表示分配的内存块。</li>
<li><code>GMEM_ZEROINIT</code>：分配的内存块被初始化为零。</li>
<li><code>GMEM_DISCARDABLE</code>：分配的内存块可被丢弃。</li>
</ul>
</li>
<li><code>dwBytes</code>：要分配的内存块的大小（以字节为单位）。</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果分配成功，返回一个指向分配的内存块的句柄（如果使用了 <code>GMEM_MOVEABLE</code> 标志）或指针（如果使用了 <code>GMEM_FIXED</code> 标志）。</li>
<li>如果分配失败，返回 NULL 。</li>
</ul>
</li>
</ul>
<p><code>GlobalAlloc</code> 函数用于在全局堆中分配内存。全局堆是所有进程可访问的公共内存区域。通过指定不同的标志，可以选择返回指针或句柄来表示分配的内存块。分配的内存块可以是固定的（使用指针）或可移动的（使用句柄）。</p>
<p>需要注意的是，<code>GlobalAlloc</code> 函数已经过时，不推荐在新的应用程序中使用。现代的 Windows 应用程序通常使用 <code>HeapAlloc</code> 或其他更高级的内存分配函数来进行内存管理。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI HGLOBAL WINAPI <span class="title function_">GlobalFree</span><span class="params">(HGLOBAL hMem)</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>作用：释放指定的全局内存块。</li>
<li>参数：<ul>
<li><code>hMem</code>：要释放的全局内存块的句柄。</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果操作成功，返回 NULL ；</li>
<li>如果操作失败，返回输入的句柄 <code>hMem</code> 。</li>
</ul>
</li>
</ul>
<h4 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc&#x2F;free"></a>malloc&#x2F;free</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__cdecl <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> _Size)</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>作用：在堆上分配指定大小的内存块。</li>
<li>参数：<ul>
<li><code>_Size</code>：要分配的内存块的大小（以字节为单位）。</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果分配成功，返回指向分配的内存块的指针；</li>
<li>如果分配失败，返回 NULL 。</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">free</span><span class="params">(<span class="type">void</span>* _Memory)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>作用：释放通过动态内存分配函数（如 <code>malloc</code> 、<code>calloc</code> 、<code>realloc</code> 等）分配的内存块。</li>
<li>参数：<ul>
<li><code>_Memory</code>：要释放的内存块的指针。</li>
</ul>
</li>
<li>返回值：无。</li>
</ul>
<h3 id="常用堆调试命令"><a href="#常用堆调试命令" class="headerlink" title="常用堆调试命令"></a>常用堆调试命令</h3><ul>
<li><p><code>!heap</code> 打印当前进程所有堆</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0:001&gt; !heap</span><br><span class="line">        Heap Address      NT/Segment Heap</span><br><span class="line"></span><br><span class="line">         23c9cb00000              NT Heap</span><br><span class="line">         23c9c9d0000              NT Heap</span><br><span class="line">         23c9e530000              NT Heap</span><br><span class="line">         23c9e990000              NT Heap</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>!heap -h</code> 可以查看当前进程所创建的堆空间</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0:001&gt; !heap -h</span><br><span class="line">Index   Address  Name      Debugging options enabled</span><br><span class="line">  1:   233708f0000 </span><br><span class="line">    Segment at 00000233708f0000 to 00000233709ef000 (00012000 bytes committed)</span><br><span class="line">  2:   23370730000 </span><br><span class="line">    Segment at 0000023370730000 to 0000023370740000 (00001000 bytes committed)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>!heap -x address</code> 打印包含 address 的堆块的相关信息<br>申请的堆块：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:001&gt; !heap -x 0000023C9CB2FE80</span><br><span class="line">Entry             User              Heap              Segment               Size  PrevSize  Unused    Flags</span><br><span class="line">-------------------------------------------------------------------------------------------------------------</span><br><span class="line">0000023c9cb2fe40  0000023c9cb2fe50  0000023c9cb00000  0000023c9cb00000       140      1010         c  busy </span><br></pre></td></tr></table></figure></div>

<p>将这个堆块释放后：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:001&gt; !heap -x 0000023C9CB2FE80</span><br><span class="line">Entry             User              Heap              Segment               Size  PrevSize  Unused    Flags</span><br><span class="line">-------------------------------------------------------------------------------------------------------------</span><br><span class="line">0000023c9cb2fe40  0000023c9cb2fe50  0000023c9cb00000  0000023c9cb00000       140      1010         0  free </span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>!heap -i address</code> 显示 address 对应堆块的详细信息，注意这里的 address 指 Entry ，即堆块的起始地址</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:001&gt; !heap -i 0000023c9cb2fe40</span><br><span class="line">Detailed information for block entry 0000023c9cb2fe40</span><br><span class="line">Assumed heap       : 0x0000023c9cb00000 (Use !heap -i NewHeapHandle to change)</span><br><span class="line">Header content     : 0x84D7A09E 0x0000546B (decoded : 0x14000014 0x00000101)</span><br><span class="line">Owning segment     : 0x0000023c9cb00000 (offset 0)</span><br><span class="line">Block flags        : 0x0 (free )</span><br><span class="line">Total block size   : 0x14 units (0x140 bytes)</span><br><span class="line">Previous block size: 0x101 units (0x1010 bytes)</span><br><span class="line">Block CRC          : OK - 0x14  </span><br><span class="line">Free list entry    : OK</span><br><span class="line">Previous block     : 0x0000023c9cb2ee30</span><br><span class="line">Next block         : 0x0000023c9cb2ff80</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>!heap -v address</code> 检查堆是否损坏，address 为 heap 地址。例如伪造 <code>FreeList</code> 链表后可以用这个命令测试是否能通过检查。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; !heap -v 247254a0000</span><br><span class="line">HEAPEXT: Unable to get address of ntdll!RtlpHeapInvalidBadAddress.</span><br><span class="line">Index   Address  Name      Debugging options enabled</span><br><span class="line">  1:   247254a0000 </span><br><span class="line">    Segment at 00000247254a0000 to 000002472559f000 (0000f000 bytes committed)</span><br><span class="line">    Flags:                00000002</span><br><span class="line">    ForceFlags:           00000000</span><br><span class="line">    Granularity:          16 bytes</span><br><span class="line">    Segment Reserve:      00100000</span><br><span class="line">    Segment Commit:       00002000</span><br><span class="line">    DeCommit Block Thres: 00000400</span><br><span class="line">    DeCommit Total Thres: 00001000</span><br><span class="line">    Total Free Size:      00000197</span><br><span class="line">    Max. Allocation Size: 00007ffffffdefff</span><br><span class="line">    Lock Variable at:     00000247254a02c0</span><br><span class="line">    Next TagIndex:        0000</span><br><span class="line">    Maximum TagIndex:     0000</span><br><span class="line">    Tag Entries:          00000000</span><br><span class="line">    PsuedoTag Entries:    00000000</span><br><span class="line">    Virtual Alloc List:   247254a0110</span><br><span class="line">    Uncommitted ranges:   247254a00f0</span><br><span class="line">    FreeList[ 00 ] at 00000247254a0150: 00000247254ad730 . 00000247254a7f40      Unable to read nt!_HEAP_FREE_ENTRY structure at fffffffffffffff0</span><br><span class="line"> (6 blocks)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">##CORRUPTION FOUND at 0x254AC470</span><br><span class="line">    PreviousSize field does not match Size field in previous entry </span><br><span class="line">    Entry-&gt;PreviousSize == 0x9</span><br><span class="line">    PreviousEntry-&gt;Size == 0x41</span><br><span class="line">    </span><br><span class="line">##CORRUPTION FOUND at 0x254AC560</span><br><span class="line">    PreviousSize field does not match Size field in previous entry </span><br><span class="line">    Entry-&gt;PreviousSize == 0x9</span><br><span class="line">    PreviousEntry-&gt;Size == 0x9</span><br><span class="line">##The above errors were found in segment at 0x254A0000</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="NT-Heap"><a href="#NT-Heap" class="headerlink" title="NT Heap"></a>NT Heap</h2><p><strong>具体过程分析见 <a href="attachment/ntdll.dll(NtHeap).i64">ntdll.dll(NtHeap).i64</a> 。</strong></p>
<p>Windows 的 NT Heap 的调用关系如下图所示，NT Heap 分为前端堆（LFH堆）和后端堆两部分。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/9f3ae26e17288d1a8d10da45ae0aaad6.png"
                     
                ></p>
<h3 id="后端堆"><a href="#后端堆" class="headerlink" title="后端堆"></a>后端堆</h3><p>当 LFH 没有启用的时候，我们通过后端堆来分配内存。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/ca4ce43e196de0d83298aff49ffaa21d.png"
                     
                ></p>
<h4 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/6204d11b8fdab993b6bc17f7a1d71668.png"
                     
                ></p>
<h5 id="HEAP"><a href="#HEAP" class="headerlink" title="_HEAP"></a>_HEAP</h5><p><code>_HEAP</code> 是堆管理的最核心结构，和 linux glibc 的 <code>main_arena</code> 作用类似。每一个 HEAP 都有一个 <code>_HEAP</code> 结构，存在于该 HEAP 的开头。</p>
<p><code>_HEAP</code> 的定义如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">0:001&gt; dt _HEAP 233708f0000</span><br><span class="line">ntdll!_HEAP</span><br><span class="line">   +0x000 Segment          : _HEAP_SEGMENT</span><br><span class="line">   +0x000 Entry            : _HEAP_ENTRY</span><br><span class="line">   +0x010 SegmentSignature : 0xffeeffee</span><br><span class="line">   +0x014 SegmentFlags     : 2</span><br><span class="line">   +0x018 SegmentListEntry : _LIST_ENTRY [ 0x00000233`708f0120 - 0x00000233`708f0120 ]</span><br><span class="line">   +0x028 Heap             : 0x00000233`708f0000 _HEAP</span><br><span class="line">   +0x030 BaseAddress      : 0x00000233`708f0000 Void</span><br><span class="line">   +0x038 NumberOfPages    : 0xff</span><br><span class="line">   +0x040 FirstEntry       : 0x00000233`708f0740 _HEAP_ENTRY</span><br><span class="line">   +0x048 LastValidEntry   : 0x00000233`709ef000 _HEAP_ENTRY</span><br><span class="line">   +0x050 NumberOfUnCommittedPages : 0xed</span><br><span class="line">   +0x054 NumberOfUnCommittedRanges : 1</span><br><span class="line">   +0x058 SegmentAllocatorBackTraceIndex : 0</span><br><span class="line">   +0x05a Reserved         : 0</span><br><span class="line">   +0x060 UCRSegmentList   : _LIST_ENTRY [ 0x00000233`70901fe0 - 0x00000233`70901fe0 ]</span><br><span class="line">   +0x070 Flags            : 2</span><br><span class="line">   +0x074 ForceFlags       : 0</span><br><span class="line">   +0x078 CompatibilityFlags : 0</span><br><span class="line">   +0x07c EncodeFlagMask   : 0x100000</span><br><span class="line">   +0x080 Encoding         : _HEAP_ENTRY</span><br><span class="line">   +0x090 Interceptor      : 0</span><br><span class="line">   +0x094 VirtualMemoryThreshold : 0xff00</span><br><span class="line">   +0x098 Signature        : 0xeeffeeff</span><br><span class="line">   +0x0a0 SegmentReserve   : 0x100000</span><br><span class="line">   +0x0a8 SegmentCommit    : 0x2000</span><br><span class="line">   +0x0b0 DeCommitFreeBlockThreshold : 0x400</span><br><span class="line">   +0x0b8 DeCommitTotalFreeThreshold : 0x1000</span><br><span class="line">   +0x0c0 TotalFreeSize    : 0xc2</span><br><span class="line">   +0x0c8 MaximumAllocationSize : 0x00007fff`fffdefff</span><br><span class="line">   +0x0d0 ProcessHeapsListIndex : 1</span><br><span class="line">   +0x0d2 HeaderValidateLength : 0x2c0</span><br><span class="line">   +0x0d8 HeaderValidateCopy : (null) </span><br><span class="line">   +0x0e0 NextAvailableTagIndex : 0</span><br><span class="line">   +0x0e2 MaximumTagIndex  : 0</span><br><span class="line">   +0x0e8 TagEntries       : (null) </span><br><span class="line">   +0x0f0 UCRList          : _LIST_ENTRY [ 0x00000233`70901fd0 - 0x00000233`70901fd0 ]</span><br><span class="line">   +0x100 AlignRound       : 0x1f</span><br><span class="line">   +0x108 AlignMask        : 0xffffffff`fffffff0</span><br><span class="line">   +0x110 VirtualAllocdBlocks : _LIST_ENTRY [ 0x00000233`708f0110 - 0x00000233`708f0110 ]</span><br><span class="line">   +0x120 SegmentList      : _LIST_ENTRY [ 0x00000233`708f0018 - 0x00000233`708f0018 ]</span><br><span class="line">   +0x130 AllocatorBackTraceIndex : 0</span><br><span class="line">   +0x134 NonDedicatedListLength : 0</span><br><span class="line">   +0x138 BlocksIndex      : 0x00000233`708f02e8 Void</span><br><span class="line">   +0x140 UCRIndex         : (null) </span><br><span class="line">   +0x148 PseudoTagEntries : (null) </span><br><span class="line">   +0x150 FreeLists        : _LIST_ENTRY [ 0x00000233`708fa920 - 0x00000233`70901790 ]</span><br><span class="line">   +0x160 LockVariable     : 0x00000233`708f02c0 _HEAP_LOCK</span><br><span class="line">   +0x168 CommitRoutine    : 0x36d0c67f`cfd1ec4e     long  +36d0c67fcfd1ec4e</span><br><span class="line">   +0x170 StackTraceInitVar : _RTL_RUN_ONCE</span><br><span class="line">   +0x178 CommitLimitData  : _RTL_HEAP_MEMORY_LIMIT_DATA</span><br><span class="line">   +0x198 FrontEndHeap     : 0x00000233`707f0000 Void</span><br><span class="line">   +0x1a0 FrontHeapLockCount : 0</span><br><span class="line">   +0x1a2 FrontEndHeapType : 0x2 &#x27;&#x27;</span><br><span class="line">   +0x1a3 RequestedFrontEndHeapType : 0x2 &#x27;&#x27;</span><br><span class="line">   +0x1a8 FrontEndHeapUsageData : 0x00000233`708f2ea0  -&gt; 0</span><br><span class="line">   +0x1b0 FrontEndHeapMaximumIndex : 0x402</span><br><span class="line">   +0x1b2 FrontEndHeapStatusBitmap : [129]  &quot;p&quot;</span><br><span class="line">   +0x238 Counters         : _HEAP_COUNTERS</span><br><span class="line">   +0x2b0 TuningParameters : _HEAP_TUNING_PARAMETERS</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>EncodeFlagMask</code>：Heap 初始化后会设置为 0x100000 ，用于判断是否要加密该 heap 空间中每个堆的 chunk_header 。</li>
<li><code>Encoding</code>（<code>_Heap_Entry</code>）：用于与 chunk_header 做异或的 cookies；所有分配的 chunk 的 chunk_header 都会与 <code>Encoding</code> 进行异或，然后在存入内存中。</li>
<li><code>VirtualAllocdBlocks</code>：一个双向链表的 dummy head ，存放着 <code>Flink</code> 和 <code>Blink</code> ，将 <code>VirtualAllocate</code> 出来的 chunk 链接起来。</li>
<li><code>BlocksIndx</code>（<code>_Heap_LIST_LOOKUP</code>）：Back-End 中用于管理后端管理器中的 chunk 。</li>
<li><code>FreeList</code>（<code>_Heap_Entry</code>）：连接 Back-End 中的所有 free chunk ，类似 unsorted bin 。</li>
<li><code>FrontEndHeap</code>：指向管理 FrontEnd 的 heap 结构。</li>
<li><code>FrontEndHeapUsageData</code>：指向一个对应各大小 chunk 的数组，记录各种大小 chunk 的使用次数，到达某个程度时会开启该对应大小 chunk 的 Front-End 分配器。<strong>如果开启 LFH 后对应的 <code>FrontEndHeapUsageData</code> 是 <code>SegmentInfoArrays</code> 的下标。</strong></li>
<li><code>FrontEndHeapStatusBitmap</code>：非常重要。是一个 bitmap 数组，每一项长度为 1 字节，用来记录某个 size 是否开启了 LFH 。判断方式是 <code>_HEAP.FrontEndHeapStatusBitmap[(size &gt;&gt; 4) &gt;&gt; 3] &amp; (1 &lt;&lt; ((size &gt;&gt; 4) &amp; 7))</code> 是否为 1 ，如果是 1 则说明对应 size 开启了 LFH 。</li>
</ul>
<h5 id="chunk-head"><a href="#chunk-head" class="headerlink" title="chunk head"></a>chunk head</h5><p>后端段的 chunk head，其分为三种情况：</p>
<ul>
<li>Allocated Chunk（<code>_HEAP_ENTRY</code>）：已分配堆</li>
<li>Freed Chunk（<code>_HEAP_ENTRY</code>）：已释放堆</li>
<li>VirtualAlloc Chunk（<code>_HEAP_VIRTUAL_ALLOC_ENTRY</code>）：使用 VirtualAlloc 分配的堆</li>
</ul>
<p><code>_HEAP_VIRTUAL_ALLOC_ENTRY</code> 和 <code>_HEAP_ENTRY</code> 两种结构定义如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; dt _Heap_VIRTUAL_ALLOC_ENTRY</span><br><span class="line">ntdll!_HEAP_VIRTUAL_ALLOC_ENTRY</span><br><span class="line">   +0x000 Entry            : _LIST_ENTRY</span><br><span class="line">   +0x010 ExtraStuff       : _HEAP_ENTRY_EXTRA</span><br><span class="line">   +0x020 CommitSize       : Uint8B</span><br><span class="line">   +0x028 ReserveSize      : Uint8B</span><br><span class="line">   +0x030 BusyBlock        : _HEAP_ENTRY</span><br><span class="line">0:004&gt; dt _HEAP_ENTRY</span><br><span class="line">ntdll!_HEAP_ENTRY</span><br><span class="line">   +0x000 UnpackedEntry    : _HEAP_UNPACKED_ENTRY</span><br><span class="line">   +0x000 PreviousBlockPrivateData : Ptr64 Void</span><br><span class="line">   +0x008 Size             : Uint2B</span><br><span class="line">   +0x00a Flags            : UChar</span><br><span class="line">   +0x00b SmallTagIndex    : UChar</span><br><span class="line">   +0x008 SubSegmentCode   : Uint4B</span><br><span class="line">   +0x00c PreviousSize     : Uint2B</span><br><span class="line">   +0x00e SegmentOffset    : UChar</span><br><span class="line">   +0x00e LFHFlags         : UChar</span><br><span class="line">   +0x00f UnusedBytes      : UChar</span><br><span class="line">   +0x008 CompactHeader    : Uint8B</span><br><span class="line">   +0x000 ExtendedEntry    : _HEAP_EXTENDED_ENTRY</span><br><span class="line">   +0x000 Reserved         : Ptr64 Void</span><br><span class="line">   +0x008 FunctionIndex    : Uint2B</span><br><span class="line">   +0x00a ContextValue     : Uint2B</span><br><span class="line">   +0x008 InterceptorValue : Uint4B</span><br><span class="line">   +0x00c UnusedBytesLength : Uint2B</span><br><span class="line">   +0x00e EntryOffset      : UChar</span><br><span class="line">   +0x00f ExtendedBlockSignature : UChar</span><br><span class="line">   +0x000 ReservedForAlignment : Ptr64 Void</span><br><span class="line">   +0x008 Code1            : Uint4B</span><br><span class="line">   +0x00c Code2            : Uint2B</span><br><span class="line">   +0x00e Code3            : UChar</span><br><span class="line">   +0x00f Code4            : UChar</span><br><span class="line">   +0x00c Code234          : Uint4B</span><br><span class="line">   +0x008 AgregateCode     : Uint8B</span><br></pre></td></tr></table></figure></div>

<h6 id="Allocated-Chunk"><a href="#Allocated-Chunk" class="headerlink" title="Allocated Chunk"></a>Allocated Chunk</h6><p>Allocated Chunk 的 chunk head 为 <code>_HEAP_ENTRY</code>，结构如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/363525fea17a0378df64f4214230bb06.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<ul>
<li><p><code>PreviousBlockPrivateData</code>：8 字节，可为前一块 chunk 的 data ，因为 chunk 必须对齐。</p>
</li>
<li><p><code>Size</code>: chunk 的大小，为实际大小右移 4bit 后的值。比如大小为 0x80 的 chunk 的 <code>Size</code> 值为 0x8 。</p>
</li>
<li><p><code>Flags</code>: 表示该chunk的状态：</p>
<ul>
<li><code>HEAP_ENTRY_BUSY(01)</code> 堆块处于占用状态</li>
<li><code>HEAP_ENTRY_EXTRA_PRESENT(02)</code> 该块存在额外的描述 <code>_HEAP_ENTRY_EXTRA</code></li>
<li><code>HEAP_ENTRY_FILE_PATTERN(03)</code> 使用固定模式填充堆块<ul>
<li><code>HEAP_ENTRY_VIRTUAL_ALLOC(08)</code> 通过 virtual allocation 虚拟分配的堆块</li>
</ul>
</li>
<li><code>HEAP_ENTRY_LAST_ENTRY(10)</code> 表示是该段的最后一个堆块</li>
</ul>
</li>
<li><p><code>SmallTagIndex</code>: 前 3 个字节异或后的值，用于验证。</p>
</li>
<li><p><code>PreviousSize</code>: 前⼀个 chunk 的大小，为实际大小右移 4bit 后的值。</p>
</li>
<li><p><code>SegmentOffset</code>: 在某种情况下用来寻找 Heap 的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SegmentOffset = heap_entry-&gt;UnpackedEntry.SegmentOffset;</span><br><span class="line"><span class="keyword">if</span> ( SegmentOffset )</span><br><span class="line">  Heap = ((heap_entry &amp; <span class="number">0xFFFFFFFFFFFF0000</span>ui64) - (SegmentOffset &lt;&lt; <span class="number">16</span>) + <span class="number">0x10000</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>Unusedbytes</code>：整个 chunk 的大小减去用户 malloc 的大小，因为如果 chunk 是在使用状态 <code>Unusedbytes</code> 一定不为 0 ，因此可以判断 chunk 是否空闲（&amp;0x3F 是否为 0）。另外这个值还有一个 0x80 的标志位也可以用来判断 chunk 的状态是前端堆还是后端堆。</p>
</li>
</ul>
<p>如下图所示，chunk head 在内存中是加密的，要想获取原本的 chunk head 需要异或上 <code>Encoding</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/04bc3ef5200085fc4df54439d8160d45.png"
                     
                ></p>
<p>另外可以看到解密后的 chunk head 的 <code>Size</code> 字段为 <code>0x0034</code> ，<code>Flags</code> 字段为 <code>0x1</code> ，因此 <code>SmallTagIndex = LOBYTE(Size) ^ BYTE1(Size) ^ Flags = 0x35</code> 。</p>
<h6 id="Freed-Chunk"><a href="#Freed-Chunk" class="headerlink" title="Freed Chunk"></a>Freed Chunk</h6><p>Freed Chunk 的 chunk head 同样为 <code>_HEAP_ENTRY</code> ，不过由于是释放状态，因此会被链到 <code>FreeList</code> 链表中，因此在 <code>_HEAP_ENTRY</code> 后多了一个 <code>_LIST_ENTRY</code> 结构，如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/766c62d27cc582231732c56cb4ff13eb.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br><code>_LIST_ENTRY</code> 定义如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; dt _LIST_ENTRY</span><br><span class="line">ntdll!_LIST_ENTRY</span><br><span class="line">   +0x000 Flink            : Ptr64 _LIST_ENTRY</span><br><span class="line">   +0x008 Blink            : Ptr64 _LIST_ENTRY</span><br></pre></td></tr></table></figure></div>

<p>需要特别说明 Freed Chunk 的一些字段：</p>
<ul>
<li><code>Flags</code> 为 0 表示 freed</li>
<li><code>UnusedBytes</code> （&amp;0x3f）始终为 0</li>
<li><code>Flink</code> 指向的是下一个 freed chunk 或 <code>FreeList</code></li>
<li><code>Blink</code> 指向的是上一个 freed chunk 或 <code>FreeList</code></li>
</ul>
<p>在 free 完一块 chunk 后，会将该 chunk 放到 <code>FreeLists</code> 中，并会按照大小决定插在 <code>Freelists</code> 中的位置。</p>
<h6 id="VirtualAlloc-Chunk"><a href="#VirtualAlloc-Chunk" class="headerlink" title="VirtualAlloc Chunk"></a>VirtualAlloc Chunk</h6><p> VirtualAlloc Chunk 的 chunk head 为 <code>_HEAP_VIRTUAL_ALLOC_ENTRY</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/fbf68921442132033b32bea0c35b49c6.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<ul>
<li><code>Flink</code> 和 <code>Blink</code>：分别指向前⼀个和后⼀个 mmap 出来的 chunk（不管是 in use 还是 freed）</li>
<li><code>Size</code>：unused size，而且没有右移</li>
<li><code>Unusedbytes</code>：恒为 4，用来判断 VirtualAlloc Chunk。（注意，<code>_HEAP.Encoding</code> 对应 <code>Unusedbytes</code> 的位置通常为 0 ，因此很多地方在未解密 <code>_HEAP_ENTRY</code> 的时候直接判断 <code>Unusedbytes</code>）</li>
</ul>
<h5 id="BlocksIndex-HEAP-LIST-LOOKUP"><a href="#BlocksIndex-HEAP-LIST-LOOKUP" class="headerlink" title="BlocksIndex (_HEAP_LIST_LOOKUP)"></a>BlocksIndex (_HEAP_LIST_LOOKUP)</h5><p><code>_HEAP</code> 的 <code>BlocksIndex</code> 指向一个类型为 <code>_HEAP_LIST_LOOKUP</code> 的结构体，定义如下。该结构用来管理各种不同大小的 freed chunk ，能快速的找到合适的 chunk 。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0:005&gt; dt _HEAP_LIST_LOOKUP 0x00000233`708f02e8</span><br><span class="line">ntdll!_HEAP_LIST_LOOKUP</span><br><span class="line">   +0x000 ExtendedLookup   : 0x00000233`708f36b0 _HEAP_LIST_LOOKUP</span><br><span class="line">   +0x008 ArraySize        : 0x80</span><br><span class="line">   +0x00c ExtraItem        : 0</span><br><span class="line">   +0x010 ItemCount        : 0xa</span><br><span class="line">   +0x014 OutOfRangeItems  : 0</span><br><span class="line">   +0x018 BaseIndex        : 0</span><br><span class="line">   +0x020 ListHead         : 0x00000233`708f0150 _LIST_ENTRY [ 0x00000233`708f7e80 - 0x00000233`70902300 ]</span><br><span class="line">   +0x028 ListsInUseUlong  : 0x00000233`708f0320  -&gt; 0xdc</span><br><span class="line">   +0x030 ListHints        : 0x00000233`708f0330  -&gt; (null) </span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>ExtendedLookup (Ptr64 _HEAP_LIST_LOOKUP)</code>：指向下一个 <code>BlocksIndex </code>，通常下一个 <code>BlocksIndex </code> 会管理更大的 chunk 。</li>
<li><code>ArraySize (Uint4B)</code>：该结构会管理最大 chunk 的大小 + 0x10 。上面例子中 <code>ArraySize</code> 为 0x80 但由于右移实际是 0x800 。</li>
<li><code>ItemCount (Uint4B)</code>：4 字节，目前该结构所管理的 chunk 数。</li>
<li><code>OutofRangeItems (Uint4B)</code>：超出该结构所管理大小的 chunk 的数量。</li>
<li><code>BaseIndex (Uint4B)</code>：该结构所管理的 chunk 的起始 index ，将 <code>(Aligned(size) &gt;&gt; 4) - BaseIndex</code> 作为 <code>ListHint</code> 中查找的下标。通常下一个 <code>BlocksIndex</code> 将上一个 <code>BlocksIndex</code> 的 <code>ArraySize</code> 作为 <code>BaseIndex</code> 。</li>
<li><code>ListHead (Ptr64 _LIST_ENTRY)</code>：指向 <code>_HEAP</code> 的 <code>FreeList</code> 。 </li>
<li><code>ListsInUseUlong (Ptr64 Uint4B)</code>：用在判断 <code>ListHint</code> 中是否有适合大小的 chunk ，是一个 bitmap 。</li>
<li><code>ListHint (Ptr64 Ptr64 _LIST_ENTRY)</code>：十分重要，用来指向对应大小的 chunk array ，其目的就在于更快速找到适合大小的 chunk ，0x10 大小为一个间隔。</li>
</ul>
<p><code>ListInUseUlong</code> 和 <code>ListHint</code> 组成了一个位图选择，能更快速的找到合适大小的堆块。并且 <code>BlocksIndex</code> 通过 <code>ExtendedLookUp</code> 由组成了一个快速查找的 <code>BlocksIndex</code> 链表。</p>
<h4 id="分配机制"><a href="#分配机制" class="headerlink" title="分配机制"></a>分配机制</h4><h5 id="Allocate-RtlAllocateHeap"><a href="#Allocate-RtlAllocateHeap" class="headerlink" title="Allocate (RtlAllocateHeap)"></a>Allocate (RtlAllocateHeap)</h5><p>判断 <code>Size</code> 大小是否正常，然后对 <code>Size</code> 进行对齐操作：<code>Size = ((Size ? Size : 1) + Heap-&gt;AlignRound) &amp; Heap-&gt;AlignMask = ((Size ? Size : 1) + 0x17) &amp; ~0xF</code> 。另外还有 <code>Index</code> 的值：<code>Index = Size &gt;&gt; 4</code> 。</p>
<p>首先判断 <code>Heap-&gt;Segment.SegmentSignature</code> ，如果值为 0xDDEEDDEE 说明是 Segment Heap ，需要单独处理。否则为 Nt Heap ，值为 0xFFEEFFEE ，继续进行下一步操作。</p>
<p>将 <code>Size</code> 按照大小分成 3 种，分别进行不同操作分配内存。</p>
<ul>
<li>Size ≤ 0x4000</li>
<li>0x4000 &lt; size ≤ 0xff000</li>
<li>Size &gt; 0xff000</li>
</ul>
<h6 id="Size-≤-0x4000"><a href="#Size-≤-0x4000" class="headerlink" title="Size ≤ 0x4000"></a>Size ≤ 0x4000</h6><ul>
<li><p>检查是否有该 <code>Size</code> 对应的 <code>FrontEndHeapStatusBitmap</code>，判断是否启动了LFH</p>
<ul>
<li>如果有，就通过LFH分配，即调用 <code>RtlpLowFragHeapAllocFromContext</code> 函数分配内存。</li>
<li>如果没有，就在对应的 <code>FrontEndHeapUsageData</code> 的值加上 0x21 ，如果该值超过 0xff00 或者与 0x1f 相与后值大于 0x10（ <code>FrontEndHeapUsageData</code> 的低 5 bit 记录的是 malloc 次数减 free 次数，高 11 bit 记录的是 malloc 的次数）就启动 LFH ，即将 <code>FrontEndHeapStatusBitmap</code> 对应位置置 1 。（这个操作实际是在后面进行的，不过为了方便理解写在这里）</li>
</ul>
</li>
<li><p>遍历 <code>BlocksIndex</code> 链表，找到第一个 <code>ArraySize</code> 大于 <code>Size</code> 的 <code>BlocksIndex</code> ，然后找到对应的 <code>ListHint</code> ，即 <code>BlocksIndex-&gt;ListHints[Size - BlocksIndex-&gt;BaseIndex]</code> 。调用 <code>RtlpAllocateHeap</code> 函数分配内存。</p>
</li>
<li><p>查看对应的 <code>ListHint</code> 中是否有值（也就是否有对应 size 的 freed chunk）：</p>
<ul>
<li><p>如果刚好有值，就检查该 chunk 的 <code>Flink</code> 是否是同样 size 的 chunk ：</p>
<ul>
<li>若是则将 <code>Flink</code> 写到对应的 <code>ListHint</code> 中。</li>
<li>若否则清空对应 <code>ListHint</code> 。</li>
</ul>
<p>最后将该 chunk 从 <code>Freelist</code> 中 unlink 出来。</p>
</li>
<li><p>如果对应的 <code>ListHint</code> 中本身就没有值，就从比较大的 <code>ListHint</code> 中找：</p>
<ul>
<li>如果找到了，就以上述同样的方式处理该 <code>ListHint</code> ，并 unlink 该 chunk ，之后对其进行切割，剩下的重新放入 <code>FreeList</code> ，如果可以放进 <code>ListHint</code> 就会放进去，再 encode header 。</li>
<li>如果没较大的 <code>ListHint</code> 也都是空的，那么尝试 <code>ExtendedHeap</code> 加大堆空间，再从 extend 出来的 chunk 拿，接着一样切割，放回 <code>ListHIint</code> ，encode header 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="0x4000-size-≤-0xff000"><a href="#0x4000-size-≤-0xff000" class="headerlink" title="0x4000 &lt; size ≤ 0xff000"></a>0x4000 &lt; size ≤ 0xff000</h6><p>除了没有 LFH 相关操作外，其余都和第一种情况一样。</p>
<h6 id="size-＞-0xff000"><a href="#size-＞-0xff000" class="headerlink" title="size ＞ 0xff000"></a>size ＞ 0xff000</h6><p>直接调用 <code>ZwAllocateVirtualMemroy</code> 进行分配，类似于 linux 下的 <code>mmap</code> 直接给一大块地址，并且插入 <code>_HEAP-&gt;VirtualAllocdBlocks</code> 中。</p>
<h5 id="Free-RtlFreeHeap"><a href="#Free-RtlFreeHeap" class="headerlink" title="Free (RtlFreeHeap)"></a>Free (RtlFreeHeap)</h5><ul>
<li>调用 <code>RtlpValidateHeapEntry</code> 对要释放的 chunk 进行一系列的检查：<ul>
<li>释放的 <code>_HEAP_ENTRY</code> 是否为 NULL</li>
<li>释放的 <code>_HEAP_ENTRY</code> 地址是否关于 0x10 对齐</li>
<li>通过 <code>UnusedBytes &amp; 0x3F</code> 是否为 0 判断  <code>_HEAP_ENTRY</code>  是否已被释放过</li>
<li>检查校验位 <code>SmallTagIndex</code></li>
<li>如果 <code>UnusedBytes</code> 为 4 即通过 <code>ZwAllocateVirtualMemroy</code> 分配的内存，则判断整个 <code>_HEAP_VIRTUAL_ALLOC_ENTRY</code> 是否关于 0x1000 对齐</li>
<li>如果 <code>UnusedBytes</code> 不为 4 则通过 <code>SegmentOffset</code> 找到 <code>_HEAP</code> 然后判断 <code>_HEAP_ENTRY</code> 是否在 <code>[Heap-&gt;Segment.FirstEntry, Heap-&gt;Segment.LastValidEntry)</code> 范围内</li>
</ul>
</li>
<li>调用 <code>RtlFreeHeap</code> ，进而调用 <code>RtlpFreeHeapInternal</code> ，通过 <code>Heap-&gt;Segment.SegmentSignature</code> 判断是否为 Segment Heap ，如果是则单独处理，否则继续执行。</li>
<li>判断地址是否关于 0x10 对齐以及通过 <code>UnusedBytes &amp; 0x3F</code> 是否为 0 判断  <code>_HEAP_ENTRY</code>  是否已被释放过。</li>
<li>根据 <code>UnusedBytes</code> 是否小于 0 （0x80 是否置位）判断是否是 LFH 堆，如果不是则调用后端堆释放的核心函数 <code>RtlpFreeHeap</code> 。</li>
<li>解密 <code>_HEAP_ENTRY</code> 并校验 <code>SmallTagIndex</code> ，根据 chunk 大小找到对应的 <code>BlocksIndex</code> 。</li>
<li>根据 <code>UnusedBytes</code> 是否为 4 判断是否是通过 <code>ZwAllocateVirtualMemroy</code> 分配的内存。如果是则检查该 chunk 的 <code>_HEAP_ENTRY-&gt;Flink-&gt;Blink == _HEAP_ENTRY-&gt;Blink-&gt;Flink == &amp;_HEAP_ENTRY</code> 并从 <code>_HEAP-&gt;VirtualAllocdBlocks</code> 中移除，接着使用 <code>RtlpSecMemFreeVirtualMemory</code> 将 chunk 整个 munmap 掉。</li>
<li>如果 chunk 大小在 LFH 堆的范围内（<code>_HEAP_ENTRY-&gt;Size &lt; _HEAP-&gt;FrontEndHeapMaximumIndex</code>），会将对应的 <code>FrontEndHeapUsageData -= 1</code>（并不是0x21）。</li>
<li>接着判断前后的 chunk 是否是 freed 的状态（根据 <code>_HEAP_ENTRY.Flags</code> 的 1 是否置位判断），如果是的话就检查前后的 freed chunk （校验 <code>SmallTagIndex</code> 以及 <code>_HEAP_ENTRY-&gt;Flink-&gt;Blink == _HEAP_ENTRY-&gt;Blink-&gt;Flink == &amp;_HEAP_ENTRY</code>）然后将前后的 freed chunk 从 <code>FreeList</code> 中 unlink 下来（与上面的方式一样更新 <code>ListHint</code>），再进行合并。</li>
<li>合并完之后更新 <code>Size</code> 和 <code>PreviousSize</code> ，判断一下 <code>Size</code> 较大的情况，然后把合并好的 chunk 插入到 <code>ListHint</code> 中；插入时也会对 <code>FreeList</code> 进行检查（但是此检查不会触发 abort ，原因在于没有做 unlink 写入）。</li>
</ul>
<h3 id="LFH-堆"><a href="#LFH-堆" class="headerlink" title="LFH 堆"></a>LFH 堆</h3><p>当同一个大小的堆块分配次数过多的时候，除了从后端堆分配所需堆块外，还会额外分配一块很大的内存供前端堆使用，之后再次分配该大小的堆块的时候会从前端堆分配。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/fb0c3987f1276779f6861e9555a64ec7.png"
                     
                ></p>
<h4 id="相关数据结构-1"><a href="#相关数据结构-1" class="headerlink" title="相关数据结构"></a>相关数据结构</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/c81311e8c7de48076309b35a3dcd0aeb.png"
                     
                ></p>
<h5 id="FrontEndHeap（-LFH-HEAP）"><a href="#FrontEndHeap（-LFH-HEAP）" class="headerlink" title="FrontEndHeap（_LFH_HEAP）"></a>FrontEndHeap（_LFH_HEAP）</h5><p><code>_LFH_HEAP </code> 是前端堆管理的核心结构，可以通过 <code>_HEAP</code> 的 <code>FrontEndHeap</code> 成员指针访问。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _LFH_HEAP 0x0000016c`cc6f0000</span><br><span class="line">ntdll!_LFH_HEAP</span><br><span class="line">   +0x000 Lock             : _RTL_SRWLOCK</span><br><span class="line">   +0x008 SubSegmentZones  : _LIST_ENTRY [ 0x0000016c`cc7d4ca0 - 0x0000016c`cc7d4ca0 ]</span><br><span class="line">   +0x018 Heap             : 0x0000016c`cc7d0000 Void</span><br><span class="line">   +0x020 NextSegmentInfoArrayAddress : 0x0000016c`cc6f1440 Void</span><br><span class="line">   +0x028 FirstUncommittedAddress : 0x0000016c`cc6f2000 Void</span><br><span class="line">   +0x030 ReservedAddressLimit : 0x0000016c`cc7b3000 Void</span><br><span class="line">   +0x038 SegmentCreate    : 2</span><br><span class="line">   +0x03c SegmentDelete    : 0</span><br><span class="line">   +0x040 MinimumCacheDepth : 0</span><br><span class="line">   +0x044 CacheShiftThreshold : 0</span><br><span class="line">   +0x048 SizeInCache      : 0</span><br><span class="line">   +0x050 RunInfo          : _HEAP_BUCKET_RUN_INFO</span><br><span class="line">   +0x060 UserBlockCache   : [12] _USER_MEMORY_CACHE_ENTRY</span><br><span class="line">   +0x2a0 MemoryPolicies   : _HEAP_LFH_MEM_POLICIES</span><br><span class="line">   +0x2a4 Buckets          : [129] _HEAP_BUCKET</span><br><span class="line">   +0x4a8 SegmentInfoArrays : [129] (null) </span><br><span class="line">   +0x8b0 AffinitizedInfoArrays : [129] (null) </span><br><span class="line">   +0xcb8 SegmentAllocator : (null) </span><br><span class="line">   +0xcc0 LocalData        : [1] _HEAP_LOCAL_DATA</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>Heap (_HEAP)</code>：指向对应的 <code>_HEAP</code></li>
<li><code>Buckets (_HEAP_BUCKET)</code>：用来寻找配置大小对应到 Block 大小的阵列结构</li>
<li><code>SegmentInfoArray (_HEAP_LOCAL_SEGMENT_INFO)</code>：不同大小对应到不同的 <code>_HEAP_LOCAL_SEGMENT_INFO</code> 结构，主要管理对应到的 SubSegment 的结构</li>
<li><code>LocalData (_HEAP_LOCAL_DATA)</code>：主要可以关注其中的 <code>LowFragHeap</code> 成员，该成员指向 <code>_LFH_HEAP</code> 本身，通常用来找回 <code>_LFH_HEAP</code> 。</li>
</ul>
<h5 id="Buckets（-HEAP-BUCKET）"><a href="#Buckets（-HEAP-BUCKET）" class="headerlink" title="Buckets（_HEAP_BUCKET）"></a>Buckets（_HEAP_BUCKET）</h5><p>相关定义如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dx -r1 (*((ntdll!_HEAP_BUCKET *)0x16ccc6f02a8))</span><br><span class="line">(*((ntdll!_HEAP_BUCKET *)0x16ccc6f02a8))                 [Type: _HEAP_BUCKET]</span><br><span class="line">    [+0x000] BlockUnits       : 0x2 [Type: unsigned short]</span><br><span class="line">    [+0x002] SizeIndex        : 0x1 [Type: unsigned char]</span><br><span class="line">    [+0x003 ( 0: 0)] UseAffinity      : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x003 ( 2: 1)] DebugFlags       : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x003] Flags            : 0x0 [Type: unsigned char]</span><br><span class="line">0:000&gt; dq 0x16ccc6f02a4</span><br><span class="line">0000016c`cc6f02a4  00010002`00000001 00030004`00020003</span><br><span class="line">0000016c`cc6f02b4  00050006`00040005 00070008`00060007</span><br><span class="line">0000016c`cc6f02c4  0009000a`00080009 000b000c`000a000b</span><br><span class="line">0000016c`cc6f02d4  000d000e`000c000d 000f0010`000e000f</span><br><span class="line">0000016c`cc6f02e4  00110012`00100011 00130014`00120013</span><br><span class="line">0000016c`cc6f02f4  00150016`00140015 00170018`00160017</span><br><span class="line">0000016c`cc6f0304  0019001a`00180019 001b001c`001a001b</span><br><span class="line">0000016c`cc6f0314  001d001e`001c001d 001f0020`001e001f</span><br></pre></td></tr></table></figure></div>

<p>在 <code>_LFH_HEAP</code> 中 <code>Buckets</code> 是一个长度为 129 的 <code>_HEAP_BUCKET</code> 结构体数组。<code>_HEAP_BUCKET</code> 主要成员解释如下：</p>
<ul>
<li><code>BlockUnits (Uint2B)</code>： 要分配出去的一个 block 大小右移 4 bit ，也就是 <code>SegmentInfoArrays (UChar)</code> 中的 <code>_HEAP_SUBSEGMENT</code> 结构的 <code>BlockSize</code> 。</li>
<li><code>SizeIndex</code>：在 <code>buckets</code> 中的下标，也就是 <code>SegmentInfoArrays</code> 对应位置的 <code>BucketIndex</code> 。</li>
</ul>
<h5 id="SegmentInfoArray（-HEAP-LOCAL-SEGMENT-INFO）"><a href="#SegmentInfoArray（-HEAP-LOCAL-SEGMENT-INFO）" class="headerlink" title="SegmentInfoArray（_HEAP_LOCAL_SEGMENT_INFO）"></a>SegmentInfoArray（_HEAP_LOCAL_SEGMENT_INFO）</h5><p>相关定义如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dx -r1 ((ntdll!_HEAP_LOCAL_SEGMENT_INFO *)0x16ccc6f12c0)</span><br><span class="line">((ntdll!_HEAP_LOCAL_SEGMENT_INFO *)0x16ccc6f12c0)                 : 0x16ccc6f12c0 [Type: _HEAP_LOCAL_SEGMENT_INFO *]</span><br><span class="line">    [+0x000] LocalData        : 0x16ccc6f0cc0 [Type: _HEAP_LOCAL_DATA *]</span><br><span class="line">    [+0x008] ActiveSubsegment : 0x16ccc7d4cc0 [Type: _HEAP_SUBSEGMENT *]</span><br><span class="line">    [+0x010] CachedItems      [Type: _HEAP_SUBSEGMENT * [16]]</span><br><span class="line">    [+0x090] SListHeader      [Type: _SLIST_HEADER]</span><br><span class="line">    [+0x0a0] Counters         [Type: _HEAP_BUCKET_COUNTERS]</span><br><span class="line">    [+0x0a8] LastOpSequence   : 0x1 [Type: unsigned long]</span><br><span class="line">    [+0x0ac] BucketIndex      : 0x7 [Type: unsigned short]</span><br><span class="line">    [+0x0ae] LastUsed         : 0x0 [Type: unsigned short]</span><br><span class="line">    [+0x0b0] NoThrashCount    : 0x0 [Type: unsigned short]</span><br></pre></td></tr></table></figure></div>

<p>在 <code>_LFH_HEAP</code> 中 <code>SegmentInfoArray</code> 是一个长度为 129 的 <code>_HEAP_LOCAL_SEGMENT_INFO</code> 结构体<strong>指针</strong>数组。</p>
<p><code>_HEAP_LOCAL_SEGMENT_INFO</code> 主要成员解释如下：</p>
<ul>
<li><code>LocalData (_HEAP_LOCAL_DATA)</code>：指向 <code>_LFH_HEAP-&gt;LocalData</code> ，方便从 <code>SegmentInfo</code> 找回 <code>_LFH_HEAP</code> 。</li>
<li><code>BucketIndex</code>：<code>buckets</code> 中对应位置的 <code>SizeIndex</code></li>
<li><code>ActiveSubsegment (_HEAP_SUBSEGMENT)</code>：指向当前分配 chunk 使用的 <code>SubSegment</code> ，<code>SubSegment</code> 用于管理 <code>UserBlock</code> 分配 chunk 。</li>
<li><code>CachedItems (_HEAP_SUBSEGMENT)</code>：长度为 16 的 <code>_HEAP_SUBSEGMENT</code> 结构体<strong>指针</strong>数组，存放对应该 <code>SegmentInfo</code> 且还有可以分配 chunk 的 <code>SubSegment</code> 。当 <code>ActiveSubsegment</code> 中的 chunk 用完时，会从这里选择空闲 chunk 最多的 <code>_HEAP_SUBSEGMENT</code> 结构替换掉 <code>ActiveSubsegment</code> 。</li>
</ul>
<h5 id="ActiveSubsegment（-HEAP-SUBSEGMENT）"><a href="#ActiveSubsegment（-HEAP-SUBSEGMENT）" class="headerlink" title="ActiveSubsegment（_HEAP_SUBSEGMENT）"></a>ActiveSubsegment（_HEAP_SUBSEGMENT）</h5><p>相关定义如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt 0x16ccc7d4cc0 _HEAP_SUBSEGMENT</span><br><span class="line">ntdll!_HEAP_SUBSEGMENT</span><br><span class="line">   +0x000 LocalInfo        : 0x0000016c`cc6f12c0 _HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">   +0x008 UserBlocks       : 0x0000016c`cc7d3c90 _HEAP_USERDATA_HEADER</span><br><span class="line">   +0x010 DelayFreeList    : _SLIST_HEADER</span><br><span class="line">   +0x020 AggregateExchg   : _INTERLOCK_SEQ</span><br><span class="line">   +0x024 BlockSize        : 8</span><br><span class="line">   +0x026 Flags            : 0</span><br><span class="line">   +0x028 BlockCount       : 0x1f</span><br><span class="line">   +0x02a SizeIndex        : 0x7 &#x27;&#x27;</span><br><span class="line">   +0x02b AffinityIndex    : 0 &#x27;&#x27;</span><br><span class="line">   +0x024 Alignment        : [2] 8</span><br><span class="line">   +0x02c Lock             : 7</span><br><span class="line">   +0x030 SFreeListEntry   : _SINGLE_LIST_ENTRY</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>LocalInfo (_HEAP_LOCAL_SEGMENT_INFO)</code>：指回对应的 <code>SegmentInfoArray (_HEAP_LOCAL_SSEGMENT_INFO)</code> 。</li>
<li><code>UserBlock (_HEAP_USERDATA_HEADER)</code>：指向该子段所管理的用户数据头（<code>_HEAP_USERDATA_HEADER</code>）的指针。</li>
<li><code>DelayFreeList (_SLIST_HEADER)</code>：用于延迟释放的单向链表头。</li>
<li><code>AggregateExchg (_INTERLOCK_SEQ)</code>：其中的主要成员 <code>Depth</code> 记录了堆分配空间剩余的堆块个数，管理对应到的 UserBlock 中还有多少 freed chunk， LFH 用这个判断是否还从该 UserBlock 分配。</li>
<li><code>BlockSize</code>：表示该子段管理的内存块大小。</li>
<li><code>Flags</code>：用于标识该子段的一些属性。</li>
<li><code>BlockCount</code>：表示该子段中空闲内存块的数量。</li>
<li><code>SizeIndex</code>：表示该子段所管理的内存块大小对应的索引值。</li>
<li><code>AffinityIndex</code>：用于在多处理器系统中进行性能优化的一个指示器。</li>
<li><code>Alignment</code>：表示该子段所管理的内存块的对齐方式。</li>
<li><code>Lock</code>：用于保护该子段的互斥锁。</li>
<li><code>SFreeListEntry (_SINGLE_LIST_ENTRY)</code>：用于单向链表的一个节点，目前没见过这个字段非 0 的情况。</li>
</ul>
<h5 id="AggregateExchg（-INTERLOCK-SEQ）"><a href="#AggregateExchg（-INTERLOCK-SEQ）" class="headerlink" title="AggregateExchg（_INTERLOCK_SEQ）"></a>AggregateExchg（_INTERLOCK_SEQ）</h5><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dx -r1 (*((ntdll!_INTERLOCK_SEQ *)0x16ccc7d4ce0))</span><br><span class="line">(*((ntdll!_INTERLOCK_SEQ *)0x16ccc7d4ce0))                 [Type: _INTERLOCK_SEQ]</span><br><span class="line">    [+0x000] Depth            : 0x1c [Type: unsigned short]</span><br><span class="line">    [+0x002 (14: 0)] Hint             : 0x3 [Type: unsigned short]</span><br><span class="line">    [+0x002 (15:15)] Lock             : 0x0 [Type: unsigned short]</span><br><span class="line">    [+0x002] Hint16           : 0x3 [Type: unsigned short]</span><br><span class="line">    [+0x000] Exchg            : 196636 [Type: long]</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>Depth</code>：该 <code>UserBlock</code> 的 freed chunk 的数量</li>
<li><code>Lock</code>：锁</li>
</ul>
<h4 id="UserBlocks（-HEAP-USERDATA-HEADER）"><a href="#UserBlocks（-HEAP-USERDATA-HEADER）" class="headerlink" title="UserBlocks（_HEAP_USERDATA_HEADER）"></a>UserBlocks（_HEAP_USERDATA_HEADER）</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0:017&gt; dx -r1 ((ntdll!_HEAP_USERDATA_HEADER *)0x20793447a10)</span><br><span class="line">((ntdll!_HEAP_USERDATA_HEADER *)0x20793447a10)                 : 0x20793447a10 [Type: _HEAP_USERDATA_HEADER *]</span><br><span class="line">    [+0x000] SFreeListEntry   [Type: _SINGLE_LIST_ENTRY]</span><br><span class="line">    [+0x000] SubSegment       : 0x2079341f200 [Type: _HEAP_SUBSEGMENT *]</span><br><span class="line">    [+0x008] Reserved         : 0x20793406330 [Type: void *]</span><br><span class="line">    [+0x010] SizeIndexAndPadding : 0xc [Type: unsigned long]</span><br><span class="line">    [+0x010] SizeIndex        : 0xc [Type: unsigned char]</span><br><span class="line">    [+0x011] GuardPagePresent : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x012] PaddingBytes     : 0x0 [Type: unsigned short]</span><br><span class="line">    [+0x014] Signature        : 0xf0e0d0c0 [Type: unsigned long]</span><br><span class="line">    [+0x018] EncodedOffsets   [Type: _HEAP_USERDATA_OFFSETS]</span><br><span class="line">    [+0x020] BusyBitmap       [Type: _RTL_BITMAP_EX]</span><br><span class="line">    [+0x030] BitmapData       [Type: unsigned __int64 [1]]</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>SubSegment (_HEAP_SUBSEGMENT)</code>：指回对应的 <code>SubSegment</code> </p>
</li>
<li><p><code>EncodedOffsets</code>：用来验证 chunk header 是否被修改过，由下面 4 个值异或：</p>
<ul>
<li><code>RtlpLFHKey</code>：进程创建时初始化的一个 8 字节随机数</li>
<li><code>UserBlock</code> 的地址</li>
<li><code>UserBlock</code> 对应的 <code>LowFragHeap</code> 的地址</li>
<li><code>sizeof(UserBlocks) | ((0x10 * BlockIndex) &lt;&lt; 16)</code></li>
</ul>
<p> 在释放一个 LFH chunk 时，NT Heap 会通过 <code>UserBlock ^ RtlpLFHKey ^ _SegmentInfoArray-&gt;EncodedOffsets ^ LowFragHeap</code> 计算出 <code>sizeof(UserBlocks) | ((0x10 * BlockIndex) &lt;&lt; 16)</code> 的值，进而计算出 chunk 的地址与要释放的 chunk 的地址进行比较，从而验证 chunk header 是否被修改过。</p>
</li>
<li><p><code>BusyBitmap</code>：记录 <code>UserBlock</code> 中在使用的 chunk 的 bitmap</p>
</li>
<li><p><code>Block</code>：LFH 返回给使用者的 chunk</p>
</li>
</ul>
<h5 id="chunk-block（-HEAP-ENTRY）"><a href="#chunk-block（-HEAP-ENTRY）" class="headerlink" title="chunk&#x2F;block（_HEAP_ENTRY）"></a>chunk&#x2F;block（_HEAP_ENTRY）</h5><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c50b88d6d437593c0e66466589eaa074.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >

<ul>
<li><p><code>SubSegmentCode</code>：用来计算 <code>UserBlock</code> 的地址，是下面 4 个值的异或：</p>
<ul>
<li>chunk 对应的 <code>_HEAP</code> 地址的低 4 字节</li>
<li><code>RtlpLFHKey</code> 的低 4 字节</li>
<li>chunk 地址右移 4 bit</li>
<li>chunk 与其所在的 <code>UserBlock</code> 的距离左移 12 bit</li>
</ul>
<p>在代码中通常采用 <code>&amp;chunk_head-&gt;UnpackedEntry.PreviousBlockPrivateData - ((RtlpLFHKey ^ Heap ^ chunk_head-&gt;UnpackedEntry.SubSegmentCode ^ (chunk_head &gt;&gt; 4)) &gt;&gt; 12</code> 来找到其所在的 <code>UserBlock</code> 。</p>
</li>
<li><p><code>PreviousSize</code>：该 chunk 在 <code>UserBlock</code> 中的 index 左移 8 bit</p>
</li>
<li><p><code>SegmentOffset</code>：通常为 0 ，没有用。</p>
</li>
<li><p><code>UnusedBytes</code>：在空闲 chunk 中为 0x80，在使用的chunk 中为 <code>UnusedBytes &gt;= 0x3F ? 0xBF : (UnusedBytes | 0x80)</code> 。</p>
</li>
</ul>
<h4 id="分配机制-1"><a href="#分配机制-1" class="headerlink" title="分配机制"></a>分配机制</h4><h5 id="Allocate"><a href="#Allocate" class="headerlink" title="Allocate"></a>Allocate</h5><p>这里仅考虑连续分配相同大小 chunk 的情况</p>
<ul>
<li>第 17 次 malloc：<ul>
<li>在 <code>RtlpAllocateHeap</code> 函数中 <code>heap-&gt;FrontEndHeapUsageData[AlignedIndex]</code> 加上 0x21 后满足 <code>(FrontEndHeapUsageData &amp; 0x1Fu) &gt; 0x10 || FrontEndHeapUsageData &gt; 0xFF00u</code> ：<ul>
<li>会调用 <code>RtlpGetLFHContext</code> 获取该大小对应于 <code>SegmentInfoArray</code> 中的下标，然而此时前端堆未初始化（<code>heap-&gt;FrontEndHeap</code> 为 NULL），因此 <code>RtlpGetLFHContext</code> 返回 -1，此时会将 <code>heap-&gt;CompatibilityFlags</code> 的 0x20000000u 置位，表示表示下次 allocate 时会去初始化 LFH 堆。</li>
</ul>
</li>
<li>继续通过后端堆申请 chunk 。</li>
</ul>
</li>
<li>第 18 次 malloc：<ul>
<li>由于 <code>heap-&gt;CompatibilityFlags</code> 的 0x20000000u 置位，在 <code>RtlpAllocateHeap</code> 函数中会调用 <code>RtlpPerformHeapMaintenance</code> 函数，进而调用 <code>RtlpActivateLowFragmentationHeap</code> 函数创建 LFH 堆。</li>
<li>在 <code>RtlpActivateLowFragmentationHeap</code> 函数中：<ul>
<li>调用 <code>RtlpExtendFrontEndUsageArray</code> 函数扩展 <code>FrontEndUsageData</code> 大小</li>
<li>调用 <code>RtlpExtendListLookup</code> 函数在 <code>heap-&gt;BockIndex-&gt;ExtendedLookup</code> 为 NULL 时创建一个 <code>BlockIndex</code> 并将地址写到 <code>ExtendedLookup</code> 上。</li>
<li>调用 <code>RtlpCreateLowFragHeap</code> 创建一个 LFH 堆并将地址写到 <code>heap-&gt;FrontEndHeap</code> 上。</li>
</ul>
</li>
<li>在 <code>RtlpAllocateHeap</code> 函数中 <code>heap-&gt;FrontEndHeapUsageData[AlignedIndex]</code> 加上 0x21 后满足 <code>(FrontEndHeapUsageData &amp; 0x1Fu) &gt; 0x10 || FrontEndHeapUsageData &gt; 0xFF00u</code> ：<ul>
<li>调用 <code>RtlpGetLFHContext</code> 获取该大小对应于 <code>SegmentInfoArray</code> 中的下标，如果没有创建对应的 <code>SegmentInfoArrays</code> 就调用 <code>RtlpInitializeSegmentInfoForBucket</code> 创建对应的 <code>SegmentInfoArrays</code> 。</li>
<li>在 <code>FrontEndHeapUsageData</code> 对应位置写入 <code>SegmentInfoArray</code> 的下标并更新 <code>FrontEndHeapStatusBitmap</code> 。</li>
</ul>
</li>
<li>继续通过后端堆申请 chunk 。<strong>由于前面创建结构会申请一些堆块，所以造成了第 18 次开始 chunk 申请不连续的假象。</strong></li>
</ul>
</li>
<li>第 19 次 malloc：<ul>
<li>在 <code>RtlpAllocateHeapInternal</code> 函数中因为 <code>FrontEndHeapStatusBitmap</code> 对应位置被置位，因此会调用 <code>RtlpLowFragHeapAllocFromContext</code> 在 LFH 堆中进行分配。</li>
<li>在 <code>RtlpLowFragHeapAllocFromContext</code> 函数中判断 <code>SegmentInfoArray-&gt;ActiveSubsegment</code> 是否不为 NULL。 如果不为 NULL：<ul>
<li>取出随机范围 <code>RtlpSearchWidth[BucketIndex]</code> ，即待会申请 chunk 时的随机选取范围 <code>SearchWidth</code> 。</li>
<li>取出随机种子数组 <code>RtlpLowFragHeapRandomData</code> 的随机下标 <code>TEB-&gt;HeapData</code> 并且更新 <code>TEB-&gt;HeapData</code> 。</li>
<li>调用 <code>RtlpLfhFindClearBitAndSet</code> 函数获取空闲 chunk 的下标：<ul>
<li>从 <code>ActiveSubsegment-&gt;AggregateExchg</code> 中缓存的位置开始按 64 bit 一组循环遍历 <code>UserBlocks-&gt;BusyBitmap</code> ，直到找到有空闲 chunk 的一组。</li>
<li>根据前面传进来的随机数计算出在这个组中查找空闲 chunk 的起始下标 <code>RandomOffset = (SearchWidth * LowFragHeapRandomData) &gt;&gt; 7</code> 。</li>
<li>设置 <code>SearchWidthMask</code> 为 -1，如果查找范围 <code>SearchWidth</code> 小于 64 时为了确保一定能找到空闲 chunk 需要在 <code>BusyBitmap</code> 中用 bsf 指令找到一个空闲 chunk 的位置 <code>FirstOffset</code> ，然后 <code>SearchWidthMask</code> 设置为 <code>((1i64 &lt;&lt; SearchWidth) - 1) &lt;&lt; FirstOffset</code> 确保一定能覆盖到空闲 chunk 。另外还会将 <code>RandomOffset</code> 加上 <code>FirstOffset</code> 。</li>
<li>在 <code>BusyBitmap</code> 的 <code>RandomOffset</code> 偏移处开始，<code>SearchWidthMask</code> 范围内，找到第一个空闲 chunk 的下标 <code>FreeChunkOffset</code> 。</li>
<li>将 <code>FreeChunkOffset</code> 加上 <code>RandomOffset</code> 并关于 64 取模得到在 <code>BusyBitmap</code> 中的真实偏移。</li>
<li>更新 <code>BusyBitmap</code> ，在要取出的 chunk 对应位置置位。</li>
<li>计算并返回空闲 chunk 在整个 <code>UserBlock</code> 中的下标。</li>
</ul>
</li>
<li>缓存这次查找到空闲 chunk 的下标到 <code>ActiveSubsegment-&gt;AggregateExchg</code> 中。</li>
<li>通过 <code>UserBlocks-&gt;EncodedOffsets</code> 计算出空闲 chunk 的具体位置。</li>
<li>通过判断 <code>UnusedBytes</code> 记录未使用大小的位置（&amp;0x3F）是否为 0 来检查是不是已释放的堆块，如果是说明出错。</li>
<li>设置 chunk 的 <code>UnusedBytes</code> 为 <code>UnusedBytes &gt;= 0x3F ? 0xBF : (UnusedBytes | 0x80)</code> 。</li>
<li>返回申请的 chunk 的 User Data 部分的地址。</li>
</ul>
</li>
<li>由于 <code>SegmentInfoArray</code> 刚刚创建还没有创建 <code>_HEAP_SUBSEGMENT</code> ，因此上面的判断不通过，会进入创建和初始化 <code>_HEAP_SUBSEGMENT</code> 的流程。</li>
<li>尝试更换 <code>ActiveSubsegment</code>，在 <code>SegmentInfoArray-&gt;CachedItems</code> 中遍历，找到一个 <code>Depth</code> 最大的（即空闲 chunk 最多的）<code>_HEAP_SUBSEGMENT</code>。如果找到了就将其替换到 <code>SegmentInfoArray-&gt;ActiveSubsegment</code> 然后跳转至 <code>RtlpLowFragHeapAllocFromContext</code> 函数开头尝试重新分配。不过这里由于还没创建  <code>_HEAP_SUBSEGMENT</code> 因此会跳转到创建  <code>_HEAP_SUBSEGMENT</code> 的流程。</li>
<li>调用 <code>RtlpAllocateUserBlock</code> 函数为 <code>UserBlock</code> 申请一块内存。</li>
<li>调用 <code>RtlpLowFragHeapAllocateFromZone</code> 函数为 <code>HeapSubsegment</code> 申请一块内存。</li>
<li>调用 <code>RtlpSubSegmentInitialize</code> 函数初始化 <code>HeapSubsegment</code> 及 <code>UserBlock</code><ul>
<li>初始化 <code>UserBlock</code> 中的每个 chunk 的 <code>SubSegmentCode</code> ，<code>PreviousSize</code> ，<code>UnusedBytes</code> 。</li>
<li>初始化 <code>UserBlock</code> 的 <code>SubSegment</code> ，<code>BusyBitmap</code> ，<code>BitmapData</code> ，<code>EncodedOffsets</code> 等。</li>
<li>初始化 <code>HeapSubsegment</code> 的 <code>BlockSize</code> ，<code>BlockCount</code> ，<code>LocalInfo</code> ，<code>SizeIndex</code> ，<code>UserBlocks</code> 等。</li>
</ul>
</li>
<li>将创建的 <code>HeapSubsegment</code> 替换到 <code>SegmentInfoArray-&gt;ActiveSubsegment</code> ， 然后跳转至 <code>RtlpLowFragHeapAllocFromContext</code> 函数开头尝试重新分配。</li>
</ul>
</li>
</ul>
<h5 id="Free"><a href="#Free" class="headerlink" title="Free"></a>Free</h5><ul>
<li>在 <code>RtlpFreeHeapInternal</code> 函数中首先会检查释放的内存地址是否对齐 0x10 。</li>
<li>通过 <code>_HEAP_ENTRY-&gt;UnpackedEntry.UnusedBytes &amp; 0x3F</code> 是否为 0 判断 chunk 是否已被释放。</li>
<li>通过 <code>_HEAP_ENTRY-&gt;UnpackedEntry.SubSegmentCode</code> 找到对应的 <code>UserBlock</code> 进而找到 <code>HeapSubsegment</code> 。</li>
<li>通过 <code>UserBlock-&gt;EncodedOffsets</code> 再尝试找回 <code>_HEAP_ENTRY</code> 从而校验有无恶意修改。</li>
<li>将 <code>_HEAP_ENTRY.UnusedBytes</code> 设置为 0x80 。</li>
<li>将 <code>UserBlocks-&gt;BusyBitmap.Buffer</code> 中释放的 chunk 对应的位复位。</li>
</ul>
<h2 id="Segment-Heap"><a href="#Segment-Heap" class="headerlink" title="Segment Heap"></a>Segment Heap</h2><p><strong>具体过程分析见 <a href="attachment/ntdll.dll(SegmentHeap).i64">ntdll.dll(SegmentHeap).i64</a> 。</strong></p>
<p>Segment Heap 分为如下几个部分：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/40807d9f243e8d13146a133fd738d050.png"
                     
                ></p>
<ul>
<li><p>Frontend Allocation</p>
<ul>
<li>Variable Size Allocation</li>
<li>Low Fragmentation Heap</li>
</ul>
</li>
<li><p>Backend Allocation</p>
<ul>
<li>Segment Allocation</li>
</ul>
</li>
<li><p>Large Block Allocation</p>
</li>
</ul>
<p>如果想对某个特定进程，开启Segment Heap分配机制，可以为该进程创建如下注册表，设置 <code>FrontEndHeapDebugOptions = 0x8</code> 。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\(executable)</span><br><span class="line">FrontEndHeapDebugOptions = (DWORD)</span><br><span class="line"></span><br><span class="line">Bit 2 (0x04): Disable Segment Heap</span><br><span class="line">Bit 3 (0x08): Enable Segment Heap</span><br></pre></td></tr></table></figure></div>

<p>如果想对整个系统开启 Segment Heap 机制，可以设置注册表：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Mamager\Segment Heap</span><br><span class="line">Enabled = (DWORD)</span><br><span class="line"></span><br><span class="line">0      : Disable Segment Heap</span><br><span class="line">(Not 0): Enable Segment Heap</span><br></pre></td></tr></table></figure></div>

<h3 id="VS-堆"><a href="#VS-堆" class="headerlink" title="VS 堆"></a>VS 堆</h3><h4 id="相关数据结构-2"><a href="#相关数据结构-2" class="headerlink" title="相关数据结构"></a>相关数据结构</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/abd10c3f25bbff3064dd86b1c23440e8.png"
                     
                ></p>
<h5 id="SEGMENT-HEAP"><a href="#SEGMENT-HEAP" class="headerlink" title="_SEGMENT_HEAP"></a>_SEGMENT_HEAP</h5><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _SEGMENT_HEAP 1c48bd70000</span><br><span class="line">ntdll!_SEGMENT_HEAP</span><br><span class="line">   +0x000 EnvHandle        : RTL_HP_ENV_HANDLE</span><br><span class="line">   +0x010 Signature        : 0xddeeddee</span><br><span class="line">   +0x014 GlobalFlags      : 0x1000</span><br><span class="line">   +0x018 Interceptor      : 0</span><br><span class="line">   +0x01c ProcessHeapListIndex : 4</span><br><span class="line">   +0x01e AllocatedFromMetadata : 0y0</span><br><span class="line">   +0x020 CommitLimitData  : _RTL_HEAP_MEMORY_LIMIT_DATA</span><br><span class="line">   +0x020 ReservedMustBeZero1 : 0</span><br><span class="line">   +0x028 UserContext      : (null) </span><br><span class="line">   +0x030 ReservedMustBeZero2 : 0</span><br><span class="line">   +0x038 Spare            : (null) </span><br><span class="line">   +0x040 LargeMetadataLock : 0</span><br><span class="line">   +0x048 LargeAllocMetadata : _RTL_RB_TREE</span><br><span class="line">   +0x058 LargeReservedPages : 0</span><br><span class="line">   +0x060 LargeCommittedPages : 0</span><br><span class="line">   +0x068 Tag              : 0</span><br><span class="line">   +0x070 StackTraceInitVar : _RTL_RUN_ONCE</span><br><span class="line">   +0x080 MemStats         : _HEAP_RUNTIME_MEMORY_STATS</span><br><span class="line">   +0x0d8 GlobalLockCount  : 0</span><br><span class="line">   +0x0dc GlobalLockOwner  : 0</span><br><span class="line">   +0x0e0 ContextExtendLock : 0</span><br><span class="line">   +0x0e8 AllocatedBase    : 0x000001c4`8bd70840  &quot;&quot;</span><br><span class="line">   +0x0f0 UncommittedBase  : 0x000001c4`8bd71000  &quot;--- memory read error at address 0x000001c4`8bd71000 ---&quot;</span><br><span class="line">   +0x0f8 ReservedLimit    : 0x000001c4`8bdc0000  &quot;--- memory read error at address 0x000001c4`8bdc0000 ---&quot;</span><br><span class="line">   +0x100 ReservedRegionEnd : 0x000001c4`8bdc0000  &quot;--- memory read error at address 0x000001c4`8bdc0000 ---&quot;</span><br><span class="line">   +0x108 CallbacksEncoded : _RTL_HP_HEAP_VA_CALLBACKS_ENCODED</span><br><span class="line">   +0x140 SegContexts      : [2] _HEAP_SEG_CONTEXT</span><br><span class="line">   +0x2c0 VsContext        : _HEAP_VS_CONTEXT</span><br><span class="line">   +0x380 LfhContext       : _HEAP_LFH_CONTEXT</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>EnvHandle (RTL_HP_ENV_HANDLE)</code>：Segment Heap 的环境句柄。</li>
<li><code>Signature</code>：区分堆类型的签名，对于 Segment Heap 总是 0xDDEEDDEE 。</li>
<li><code>LargeAllocMetadata (_RTL_RB_TREE)</code>：large blocks 管理信息的红黑树。</li>
<li><code>LargeReservedPages</code>：对于 large blocks 分配保留的页面。</li>
<li><code>LargeCommittedPages</code>：large blocks 分配时被提交的 页面。</li>
<li><code>AllocatedBase</code>：指向 <code>_SEGMENT_HEAP</code> 结构体的底部，用于分配后续的 LFH 结构体等。</li>
<li><code>SegContexts (_HEAP_SEG_CONTEXT)</code>：与 Segment 有关的管理结构体。</li>
<li><code>VsContext (_HEAP_VS_CONTEXT)</code>：Frontend Allocation 中 Variable Size Allocation 的核心结构体，跟踪 variable size allocation 分配状态。</li>
<li><code>LfhContext ( _HEAP_LFH_CONTEXT)</code>：Frontend Allocation 中 Low Fragmentation Heap 的核心结构体，跟踪 LFH 分配状态。</li>
</ul>
<h5 id="RtlpHpHeapGlobals（-RTLP-HP-HEAP-GLOBALS）"><a href="#RtlpHpHeapGlobals（-RTLP-HP-HEAP-GLOBALS）" class="headerlink" title="RtlpHpHeapGlobals（_RTLP_HP_HEAP_GLOBALS）"></a>RtlpHpHeapGlobals（_RTLP_HP_HEAP_GLOBALS）</h5><p>在 Segment Heap 中，许多数据和指针都被加密了。<code>RtlpHpHeapGlobals</code> 用于存放加密用的一些 key 和其他信息。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _RTLP_HP_HEAP_GLOBALS</span><br><span class="line">ntdll!_RTLP_HP_HEAP_GLOBALS</span><br><span class="line">   +0x000 HeapKey          : Uint8B</span><br><span class="line">   +0x008 LfhKey           : Uint8B</span><br><span class="line">   +0x010 FailureInfo      : Ptr64 _HEAP_FAILURE_INFORMATION</span><br><span class="line">   +0x018 CommitLimitData  : _RTL_HEAP_MEMORY_LIMIT_DATA</span><br><span class="line">   +0x038 Flags            : Uint4B</span><br><span class="line">   +0x038 FlagsBits        : &lt;unnamed-tag&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>HeapKey</code>：8 字节随机数，用于 VS Allocator 和 Segment  Allocator 中的数据加密。</li>
<li><code>LfhKey</code>：8 字节随机数，用于 LowFragmentationHeap 中的数据加密。</li>
</ul>
<h5 id="HEAP-VS-CONTEXT"><a href="#HEAP-VS-CONTEXT" class="headerlink" title="_HEAP_VS_CONTEXT"></a>_HEAP_VS_CONTEXT</h5><p>管理 VS 分配的结构体</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dx -r1 (*((ntdll!_HEAP_VS_CONTEXT *)0x1c48bd702c0))</span><br><span class="line">(*((ntdll!_HEAP_VS_CONTEXT *)0x1c48bd702c0))                 [Type: _HEAP_VS_CONTEXT]</span><br><span class="line">    [+0x000] Lock             : 0x1 [Type: unsigned __int64]</span><br><span class="line">    [+0x008] LockType         : HeapLockPaged (0) [Type: _RTLP_HP_LOCK_TYPE]</span><br><span class="line">    [+0x010] FreeChunkTree    [Type: _RTL_RB_TREE]</span><br><span class="line">    [+0x020] SubsegmentList   [Type: _LIST_ENTRY]</span><br><span class="line">    [+0x030] TotalCommittedUnits : 0x3 [Type: unsigned __int64]</span><br><span class="line">    [+0x038] FreeCommittedUnits : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x040] DelayFreeContext [Type: _HEAP_VS_DELAY_FREE_CONTEXT]</span><br><span class="line">    [+0x080] BackendCtx       : 0x380 [Type: void *]</span><br><span class="line">    [+0x088] Callbacks        [Type: _HEAP_SUBALLOCATOR_CALLBACKS]</span><br><span class="line">    [+0x0b0] Config           [Type: _RTL_HP_VS_CONFIG]</span><br><span class="line">    [+0x0b4] Flags            : 0x0 [Type: unsigned long]</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>Lock</code>：锁</li>
<li><code>LockType (_RTLP_HP_LOCK_TYPE)</code>：锁的类型，有 3 种：<ul>
<li><code>HeapLockPaged</code></li>
<li><code>HeapLockNonPaged</code></li>
<li><code>HeapLockTypeMax</code></li>
</ul>
</li>
<li><code>FreeChunkTree (_RTL_RB_TREE)</code>：管理空闲 chunk 的红黑树。红黑树按照 chunk 大小维护，较大的 chunk 在左，较小的 chunk 在右。<ul>
<li><code>Root</code>：指向红黑树的根节点。</li>
<li><code>Encoded</code>：根据最低比特是否为 1 决定红黑树的指针是否加密（默认不加密）。加密方法是当前节点的指针异或当前节点的地址，对于 <code>Root</code> 为 <code>EncodedRoot = Root ^ FreeChunkTree</code> 。</li>
</ul>
</li>
<li><code>SubsegmentList</code>：所有的 VS Subsegment 链表，实际存储的是 <code>SubsegmentList</code> 地址异或指向的 VS Subsegment 的地址。</li>
<li><code>DelayFreeContext (_HEAP_VS_DELAY_FREE_CONTEXT)</code>：<code>VsContext-&gt;Config</code> 决定是否开启（用户态默认不开启，内核态默认开启），当开启时释放的 chunk 会先放到 <code>DelayFreeContext</code> 这个单向链表中，当链表中的 chunk 达到一定数量的时候才会集中释放。 </li>
<li><code>BackendCtx</code>：指向 VS 堆的后端堆分配器，即 <code>_SEGMENT_HEAP.SegContexts (_HEAP_SEG_CONTEXT)</code> 。这个指针异或了 <code>_HEAP_VS_CONTEXT</code> 的地址。</li>
<li><code>Callbacks</code>：用于管理 VS SubSegments 函数指针集合，函数指针都经过加密 <code>RtlpHpHeapGlobals.HeapKey ^ VsContext_addr ^ func_ptr</code> 。<ul>
<li><code>Allocate</code>：<code>RtlpHpSegVsAllocate</code></li>
<li><code>Free</code>：<code>RtlpHpSegLfhVsFree</code></li>
<li><code>Commit</code>：<code>RtlpHpSegLfhVsCommit</code></li>
<li><code>Decommit</code>：<code>RtlpHpSegLfhVsDecommit</code></li>
<li><code>ExtendContext</code>：NULL</li>
</ul>
</li>
<li><code>Config (_RTL_HP_VS_CONFIG)</code>：用于表示 VS 分配器的属性。<ul>
<li><code>PageAlignLargeAllocs</code>： 用户态默认关闭。</li>
<li><code>FullDecommit</code></li>
<li><code>EnableDelayFree</code>：用户态默认关闭。</li>
</ul>
</li>
</ul>
<h5 id="HEAP-VS-SUBSEGMENT"><a href="#HEAP-VS-SUBSEGMENT" class="headerlink" title="_HEAP_VS_SUBSEGMENT"></a>_HEAP_VS_SUBSEGMENT</h5><p>管理 VS SubSegment 的结构体</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _HEAP_VS_SUBSEGMENT</span><br><span class="line">ntdll!_HEAP_VS_SUBSEGMENT</span><br><span class="line">   +0x000 ListEntry        : _LIST_ENTRY</span><br><span class="line">   +0x010 CommitBitmap     : Uint8B</span><br><span class="line">   +0x018 CommitLock       : Uint8B</span><br><span class="line">   +0x020 Size             : Uint2B</span><br><span class="line">   +0x022 Signature        : Pos 0, 15 Bits</span><br><span class="line">   +0x022 FullCommit       : Pos 15, 1 Bit</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>Listentry</code>：每一个 VS SubSegment 是 <code>VsContext.SubsegmentList</code> 链表的一个节点 。实际存储的地址还要再异或 <code>Listentry</code> 本身的地址。</li>
<li><code>CommitBitmap</code>：VS SubSegment 中 pages 的提交位图。</li>
<li><code>Size</code>：VS SubSegment 的大小（去掉 0x30 大小的头部），右移 4 位。</li>
<li><code>Signature</code>：用于检查 VS SubSegment ，通过 <code>Size ^ 0x2BED</code> 计算。</li>
</ul>
<h5 id="chunk-head-1"><a href="#chunk-head-1" class="headerlink" title="chunk head"></a>chunk head</h5><p>Variable Size Allocation 分为 2 种情况：</p>
<ul>
<li>Allocated Chunk（<code>_HEAP_VS_CHUNK_HEADER</code>）：已分配的 chunk</li>
<li>Freed Chunk（<code>_HEAP_VS_CHUNK_FREE_HEADER</code>）：已释放的 chunk</li>
</ul>
<h6 id="Allocated-Chunk-1"><a href="#Allocated-Chunk-1" class="headerlink" title="Allocated Chunk"></a>Allocated Chunk</h6><p>Allocated Chunk 的 chunk head 为 <code>_HEAP_VS_CHUNK_HEADER</code> ，结构如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f0e4fd63a40a4f65ee2f88657ce0f68e.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p>
<ul>
<li><p><code>MemoryCost</code>：只有空闲堆块才会使用。</p>
</li>
<li><p><code>UnsafeSize</code>：堆块 <code>Size</code> ，右移 4 位。</p>
</li>
<li><p><code>UnsafePrevSize</code>：前一个堆块 <code>Size</code> ，右移 4 位。</p>
</li>
<li><p><code>Allocated</code>：表示堆块是否空闲，已分配恒为 0x1 。</p>
</li>
<li><p><code>EncodedSegmentPageOffset</code>：chunk 所在 page 在 VS Subsegment 中的索引，用于查找 VS Subsegment 。这个值是被加密的：<code>EncodedSegmentPageOffset = SegmentPageOffset ^ (int8)chunk address ^ (int8)RtlpHpHeapGlobals.HeapKey</code> 。解密后的 <code>SegmentPageOffset</code> 通过下面的代码寻找 <code>_HEAP_VS_SUBSEGMENT</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VSSubsegment = (_HEAP_VS_SUBSEGMENT *)(((<span class="type">unsigned</span> __int64)__pChunkHeader - (<span class="type">unsigned</span> <span class="type">int</span>)(SegmentPageOffset &lt;&lt; <span class="number">12</span>)) &amp; <span class="number">0xFFFFFFFFFFFFF000</span>ui64);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>UnusedBytes</code>：用于表示堆块有未被使用的内存。</p>
</li>
</ul>
<p>chunk head 的前 8 字节进行了加密：<code>chunk header = chunk header ^ chunk address ^ RtlpHpHeapGlobals.HeapKey</code> 。</p>
<h6 id="Freed-Chunk-1"><a href="#Freed-Chunk-1" class="headerlink" title="Freed Chunk"></a>Freed Chunk</h6><p>Allocated Chunk 的 chunk head 为 <code>_HEAP_VS_CHUNK_FREE_HEADER</code> ，结构如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/778e7f6d9936699367cab7582c5b3894.png"
                     
                ></p>
<ul>
<li><code>MemoryCost</code>：表示 chunk 被申请的时候会有多少 page 被提交。</li>
<li><code>Node (_RTL_BALANCED_NODE)</code><ul>
<li><code>Children[2] (Left/Right)</code>：左右子树节点</li>
<li><code>ParentValue</code>：父节点</li>
</ul>
</li>
</ul>
<p>chunk head 的前 8 字节进行了加密，加密方式和 Allocated Chunk 相同。</p>
<h4 id="分配机制-2"><a href="#分配机制-2" class="headerlink" title="分配机制"></a>分配机制</h4><h5 id="Allocate-1"><a href="#Allocate-1" class="headerlink" title="Allocate"></a>Allocate</h5><ul>
<li>在 <code>RtlpAllocateHeapInternal</code> 函数中，首先判断 <code>Heap-&gt;Signature == 0xDDEEDDEE</code> 确定 <code>Heap</code> 是 <code>_SEGMENT_HEAP</code> 类型的。</li>
<li>如果 <code>(RtlpHpAppCompatFlags &amp; 2) != 0</code>：<ul>
<li>如果申请的内存大小 <code>size</code> 不超过 0xFEFF8 则将 <code>size</code> 加上 0x10，否则加上 0x40。</li>
</ul>
</li>
<li>如果 <code>Size &lt;= 0x4000 - 16</code> 那么需要检查对应的 LFH 是否开启。<ul>
<li>查找 <code>RtlpLfhBucketIndexMap[(Size + 15) &gt;&gt; 4]</code> 得到 <code>Size</code> 对应的 <code>Heap-&gt;LfhContext-&gt;Buckets[]</code> 中的下标。</li>
<li>如果 <code>Bucket</code> 指针最低位不为 1 说明 LFH 已开启，直接进行 LFH 分配。</li>
<li>否则在 <code>Bucket</code> 的第 2 个 WORD 加上 0x21 。</li>
<li>判断 <code>Bucket</code> 的第 2 个 WORD 是否满足与 0x1F 大于 0x10 或者大于 0xFF00（和 Nt Heap 判断条件相同），如果满足则调用 <code>RtlpHpLfhBucketActivate</code> 初始化 <code>Bucket</code> 然后后续用 LFH 分配。</li>
</ul>
</li>
<li>判断 <code>Size</code> 是否大于 0x20000 ，如果大于则使用 Large Block Allocation 分配内存。</li>
<li>否则调用核心函数 <code>RtlpHpVsContextAllocateInternal</code> 使用 Variable Size Allocation 分配内存。</li>
<li>通过 <code>((Size + 15) &gt;&gt; 4) + 1</code> 计算出 <code>ChunkIndex</code> 。</li>
<li>在红黑树 <code>VSContext-&gt;FreeChunkTree</code> 中搜索大于 <code>ChunkIndex</code> 的最小的 chunk 。</li>
<li>如果找不到合适的 chunk 会调用 <code>RtlpHpVsSubsegmentCreate</code> 函数使用 Segment Allocation 分配一个新的 <code>VSSubsegment</code> 。<ul>
<li>依次调用 <code>RtlpHpSegVsAllocate</code> 和 <code>RtlpHpSegLfhVsCommit</code> 使用 Segment Allocation 分配一个新的 <code>VSSubsegment</code> 。</li>
<li>初始化 <code>VSSubsegment-&gt;Size</code> 为整个<code>VSSubsegment</code> 大小减去 0x30 的头部然后右移 4 位 。</li>
<li>初始化 <code>VSSubsegment-&gt;Signature = VSSubsegment-&gt;Size ^ 0x2BED</code> 。</li>
<li>初始化 <code>VSSubsegment</code> 中的 chunk。 <code>VSSubsegment</code> 初始时只有一个 chunk，这里要将 chunk 头清零，然后设置 <code>UnsafeSize</code> 为 <code>VSSubsegment-&gt;Size</code> 并加密 chunk 头部。</li>
<li>检查 <code>VSContext-&gt;SubsegmentList.Blink.Flink = VSContext-&gt;SubsegmentList</code> ，如果检查通过则将新创建的 <code>VSSubsegment</code> 从 <code>SubsegmentList.Blink</code> 插入到 <code>SubsegmentList</code> 链表中。注意这里涉及到的指针都是加密的。</li>
<li>将新申请的 <code>VSSubsegment</code> 中的 chunk 插入到  <code>VSContext-&gt;FreeChunkTree</code> 中然后重新在红黑树中搜索合适的 chunk 。</li>
</ul>
</li>
<li>通过查找到的 chunk 找到 <code>VSSubsegment</code> 然后校验 <code>(VSSubsegment-&gt;Signature ^ VSSubsegment-&gt;Size ^ 0x2BED) &amp; 0x7FFF == 0</code> 。</li>
<li>调用 <code>RtlpHpVsChunkSplit</code> 将 chunk 从红黑树中取出并切掉多余的 chunk ，然后将多余的 chunk 插入到 <code>VSContext-&gt;FreeChunkTree</code> 中。在这一过程中初始化了申请的 chunk 和切下来的 chunk 的 <code>UnsafeSize</code>  ，<code>Allocated</code> ，<code>EncodedSegmentPageOffset</code> 和切下来的 chunk 的下一个相邻 chunk 的 <code>UnsafePreSize</code> 。</li>
</ul>
<h5 id="Free-1"><a href="#Free-1" class="headerlink" title="Free"></a>Free</h5><ul>
<li>在 <code>RtlpFreeHeapInternal</code> 函数中，首先判断 <code>Heap-&gt;Signature == 0xDDEEDDEE</code> 确定 <code>Heap</code> 是 <code>_SEGMENT_HEAP</code> 类型的。</li>
<li>如果 <code>BlockPtr</code> 最低 16 比特为 0 则判定为 Large Block 堆分配。</li>
<li>通过 <code>Heap-&gt;SegContexts[0].SegmentMask &amp; BlockPtr</code> 找到所在的 <code>HeapPageSegment</code> ，然后校验 <code>HeapPageSegment-&gt;Signature ^ HeapPageSegment ^ HeapSegContexts ^ RtlpHpHeapGlobals.HeapKey == 0xA2E64EADA2E64EAD</code> （<code>HeapSegContexts</code> 即 <code>Heap-&gt;SegContexts[0]</code>）。</li>
<li>通过 <code>HeapPageSegment + sizeof(_HEAP_PAGE_RANGE_DESCRIPTOR) * ((BlockPtr - HeapPageSegment) &gt;&gt; HeapSegContext-&gt;UnitShift)</code> 找到 <code>BlockPtr</code> 对应的 <code>_HEAP_PAGE_RANGE_DESCRIPTOR</code> 。</li>
<li>通过 <code>HeapPageSegment + (( HeapPageRangeDesctiptor - HeapPageSegment ) / sizeof(_HEAP_PAGE_RANGE_DESCRIPTOR)) &lt;&lt; HeapSegContext-&gt;UnitShift</code> 找到对应的 Subsegment 。</li>
<li>获取 <code>HeapPageRangeDesctiptor</code> 的属性 <code>HeapPageRangeDesctiptor-&gt;RangeFlags</code> ，根据 <code>RangeFlags &amp; 0xC</code> 是否等于 8 判断是 Low Fragmentation Heap 还是 Variable Size Allocation 分配的。如果是 Variable Size Allocation 分配的 chunk 会调用 <code>RtlpHpVsContextFree</code> 函数完成 chunk 的释放。<ul>
<li>通过 <code>(VSSubsegment-&gt;Signature ^ VSSubsegment-&gt;Size ^ 0x2BED) &amp; 0x7FFF ==0</code> 校验 <code>VSSubsegment-&gt;Signature</code> 。</li>
<li>通过 <code>ChunkHeader.Allocated</code> 判断 chunk 是否已被释放来防止 double free 。</li>
<li>将 <code>ChunkHeader.EncodedSegmentPageOffset</code> 解密成 <code>SegmentPageOffset</code> ，然后通过 <code>SegmentPageOffset</code> 找到 <code>VSSubsegment</code> 并校验这个 <code>VSSubsegment</code> 的 <code>Signature</code> ，以此来校验 <code>SegmentPageOffset</code> 。</li>
<li>再次通过 <code>Allocated</code> 判断 double free 。</li>
<li>调用 <code>RtlpHpVsChunkCoalesce</code> 函数来合并释放的 chunk 的前后空闲 chunk 。<ul>
<li>更新 chunk 的 <code>Allocated</code> 为 0 （free）。</li>
<li>如果 <code>UnsafePrevSize</code> 不为 0 说明有前一个空闲 chunk 。找到前一个空闲 chunk 并判断该 chunk 是否已被释放。如果前一个相邻 chunk 也是释放状态就将该 chunk 从红黑树中取出并记录合并完的 chunk 头位置 <code>FinalChunk</code> 和合并完的大小 <code>MergedChunkSize</code> 。</li>
<li>如果当前 chunk 不是 <code>VSSubsegment</code> 中的最后一个 chunk 那么找到当前 chunk 的后一个相邻 chunk 并判断该 chunk 是否已被释放。如果后一个相邻 chunk 也是释放状态就将该 chunk 从红黑树中取出并更新合并完的大小 <code>MergedChunkSize</code> 。</li>
<li>如果 <code>MergedChunkSize</code> 不等于合并前的 chunk 大小说明发生了 chunk 合并，需要更新更新 <code>FinalChunk</code> 的 <code>UnsafeSize</code> 和后一个 chunk （如果存在）的 <code>UnsafePrevSize</code> 。</li>
</ul>
</li>
<li>如果合并完之后整个 <code>VSSubsegment</code> 都是空闲的则先调用 <code>RtlpHpVsSubsegmentCleanup</code> 函数将 <code>VSSubsegment</code> 从 <code>_HEAP_VS_CONTEXT.SubsegmentList</code> 链表中取出，取出前会进行双向链表的检查。之后调用 <code>RtlpHpVsSubsegmentFree</code> 最终调用 <code>VSContext-&gt;Callbacks.Free</code> 函数释放整个 <code>VSSubsegment</code> 。</li>
<li>否则将合并完的 chunk 插入到 <code>FreeChunkTree</code> 中。</li>
</ul>
</li>
<li>如果在 LFH 范围且未开启 LFH （即对应 <code>Buckets</code> 为初始化）则将对应 <code>LfhContext-&gt;Bucket</code> 减 1 （与 Nt Heap 相同）。</li>
</ul>
<h3 id="LFH-堆-1"><a href="#LFH-堆-1" class="headerlink" title="LFH 堆"></a>LFH 堆</h3><h4 id="相关数据结构-3"><a href="#相关数据结构-3" class="headerlink" title="相关数据结构"></a>相关数据结构</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/2e39581fa7ad4afad1aef558d523778e.png"
                     
                ><br>与之前的内存管理不同，这里 LFH 堆分配的 chunk 没有 chunk  头，并被称为 <code>Block</code> 。</p>
<h5 id="HEAP-LFH-CONTEXT"><a href="#HEAP-LFH-CONTEXT" class="headerlink" title="_HEAP_LFH_CONTEXT"></a>_HEAP_LFH_CONTEXT</h5><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dx -r1 (*((ntdll!_HEAP_LFH_CONTEXT *)0x2bef8360380))</span><br><span class="line">(*((ntdll!_HEAP_LFH_CONTEXT *)0x2bef8360380))                 [Type: _HEAP_LFH_CONTEXT]</span><br><span class="line">    [+0x000] BackendCtx       : 0x2bef8360140 [Type: void *]</span><br><span class="line">    [+0x008] Callbacks        [Type: _HEAP_SUBALLOCATOR_CALLBACKS]</span><br><span class="line">    [+0x030] AffinityModArray : 0x7ff902da7733 : 0x1 [Type: unsigned char *]</span><br><span class="line">    [+0x038] MaxAffinity      : 0x20 [Type: unsigned char]</span><br><span class="line">    [+0x039] LockType         : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x03a] MemStatsOffset   : -768 [Type: short]</span><br><span class="line">    [+0x03c] Config           [Type: _RTL_HP_LFH_CONFIG]</span><br><span class="line">    [+0x040] BucketStats      [Type: _HEAP_LFH_SUBSEGMENT_STATS]</span><br><span class="line">    [+0x048] SubsegmentCreationLock : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x080] Buckets          [Type: _HEAP_LFH_BUCKET * [129]]</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>BackendCtx</code>：指向 LFH 堆的后端堆分配器，即 <code>_SEGMENT_HEAP.SegContexts (_HEAP_SEG_CONTEXT)</code> 。与 <code>_HEAP_VS_CONTEXT.BackendCtx</code> 不同的是这个指针没有被加密。</li>
<li><code>Callbacks (_HEAP_SUBALLOCATOR_CALLBACKS)</code>：用于负责申请释放 LFH SubSegments 所需内存的函数指针集合，函数指针都经过加密：<code>RtlpHpHeapGlobals.HeapKey ^ LFHContext_addr ^ func_ptr</code> 。<ul>
<li><code>Allocate</code>：<code>RtlpHpSegLfhAllocate</code></li>
<li><code>Free</code>：<code>RtlpHpSegLfhVsFree</code></li>
<li><code>Commit</code>：<code>RtlpHpSegLfhVsCommit</code></li>
<li><code>Decommit</code>：<code>RtlpHpSegLfhVsDecommit</code></li>
<li><code>ExtendContext</code>：<code>RtlpHpSegLfhExtendContext</code></li>
</ul>
</li>
<li><code>Config (_RTL_HP_LFH_CONFIG)</code>：用于表示 LFH 管理堆块的属性。<ul>
<li><code>MaxBlockSize</code>：决定多大的堆块适用于 LFH 分配。</li>
<li><code>WitholdPageCrossingBlocks</code>：是否有跨页块。</li>
<li><code>DisableRandomization</code>：是否关闭 LFH 分配随机化。</li>
</ul>
</li>
<li><code>Buckets (_HEAP_LFH_BUCKET )</code>：<code>Buckets</code> 指针数组，与 V8 区分 Obj 指针和 Smi 相似，这个值通过最低位区分为 <code>_HEAP_LFH_BUCKET</code> 结构体和单纯的计数作用。<ul>
<li>如果 LFH 启动，每个 <code>Bucket</code> 存储了对应 <code>Size</code> 的 <code>_HEAP_LFH_BUCKET</code> 结构体地址。</li>
<li>如果 LFH 未启动，每个 <code>Bucket</code> 低 2 字节恒为 0x0001 ，高 2 字节存储了当前 <code>Size</code> 堆块的分配次数，每分配一次加 0x21，每释放一次减 1 。</li>
</ul>
</li>
</ul>
<h5 id="HEAP-LFH-BUCKET"><a href="#HEAP-LFH-BUCKET" class="headerlink" title="_HEAP_LFH_BUCKET"></a>_HEAP_LFH_BUCKET</h5><p>只有在启用 LFH 时，才会分配 <code>Buckets</code> 及其相关结构。LFH 分配器使用该结构体来管理与 <code>Size</code> 相对应的块。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _HEAP_LFH_BUCKET</span><br><span class="line">ntdll!_HEAP_LFH_BUCKET</span><br><span class="line">   +0x000 State            : _HEAP_LFH_SUBSEGMENT_OWNER</span><br><span class="line">   +0x038 TotalBlockCount  : Uint8B</span><br><span class="line">   +0x040 TotalSubsegmentCount : Uint8B</span><br><span class="line">   +0x048 ReciprocalBlockSize : Uint4B</span><br><span class="line">   +0x04c Shift            : UChar</span><br><span class="line">   +0x04d ContentionCount  : UChar</span><br><span class="line">   +0x050 AffinityMappingLock : Uint8B</span><br><span class="line">   +0x058 ProcAffinityMapping : Ptr64 UChar</span><br><span class="line">   +0x060 AffinitySlots    : Ptr64 Ptr64 _HEAP_LFH_AFFINITY_SLOT</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>State (_HEAP_LFH_SUBSEGMENT_OWNER)</code>：用于记录 <code>Buckets</code> 的状态。</li>
<li><code>TotalBlockCount</code>：这个 <code>Bucket</code> 中 LFH Subsegments 中所有的 <code>Block</code> 的数量。</li>
<li><code>TotalSubsegmentCount</code>：这个 <code>Bucket</code> 中 LFH Subsegments 的数量。</li>
<li><code>ReciprocalBlockSize</code>：如果 <code>BlockSize</code> 不是 2 的整数次幂，这个值在判断释放的 block 相对于第一个 block 的距离 <code>BlockOffset</code> 是否关于 <code>BlockSize</code> 对齐时会被用到。判断的方法为看释放的 <code>BlockPtr</code> 是否满足 <code>((ReciprocalBlockSize * BlockOffset) &gt;&gt; Shift) * BlockSize == BlockOffset</code> ，下面会给出该方法正确性的证明。</li>
<li><code>Shift</code>：如果 <code>BlockSize</code> 不是 2 的整数次幂，这个值为 0x20 ，否则为 <code>__builtin_ctz(BlockSize)</code> 。</li>
<li><code>AffinitySlots (_HEAP_LFH_AFFINITY_SLOT)</code>： 存储了当前 <code>Bucket</code> 的 subsegment 管理信息。默认只有一个。</li>
</ul>
<blockquote>
<p>下面证明 <code>BlockOffset</code> 关于 <code>BlockSize</code> 对齐当且仅当 <code>((ReciprocalBlockSize * BlockOffset) &gt;&gt; Shift) * BlockSize == BlockOffset</code>：<br><br>为了方便表述，不妨设 <code>BlockOffset</code> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>a</mi><mo>≤</mo><msup><mn>2</mn><mn>32</mn></msup><mo separator="true">,</mo><mi>a</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a \ (a\le 2^{32},a\in \mathbb{N})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">N</span><span class="mclose">)</span></span></span></span> ，<code>BlockSize</code> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>b</mi><mo>≤</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">b \ (b\le a,b\in \mathbb{N})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">N</span><span class="mclose">)</span></span></span></span> ，<code>Shift</code> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> 则 <code>ReciprocalBlockSize</code> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">⌈</mo><mfrac><msup><mn>2</mn><mn>32</mn></msup><mi>b</mi></mfrac><mo fence="true">⌉</mo></mrow><annotation encoding="application/x-tex">\left \lceil \frac{2^{32}}{b} \right \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">⌈</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0179em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">⌉</span></span></span></span></span></span><br><br>则原命题成立等价为如下等式成立 <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">&gt;</mo><mo stretchy="false">⌊</mo><mfrac><mrow><mi>a</mi><mo>×</mo><mrow><mo fence="true">⌈</mo><mfrac><msup><mn>2</mn><mn>32</mn></msup><mi>b</mi></mfrac><mo fence="true">⌉</mo></mrow><mo>&gt;</mo></mrow><msup><mn>2</mn><mn>32</mn></msup></mfrac><mo fence="true">⌋</mo></mrow><mo>×</mo><mi>b</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">\left
&gt; \lfloor \frac{a\times \left \lceil \frac{2^{32}}{b}  \right \rceil
&gt; }{2^{32}}  \right \rfloor \times b =a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.74em;vertical-align:-1.55em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">⟩</span></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.19em;"><span style="top:-2.464em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.38em;"><span class="pstrut" style="height:3.15em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-4.19em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">⌈</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0179em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">⌉</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.051em;"><span style="top:-2.311em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-3.458em;"><span class="pstrut" style="height:3.216em;"></span><span style="height:1.216em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='1.216em' style='width:0.6667em' viewBox='0 0 666.67 1216' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V1216 H263z M263 0 H347 V1216 H263z'/></svg></span></span><span style="top:-4.666em;"><span class="pstrut" style="height:3.216em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span> 当且仅当  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a \mod b =0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span><br><br>令<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>=</mo><mi>b</mi><mo>×</mo><mi>k</mi><mo>+</mo><mi>r</mi><mtext> </mtext><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><mi>r</mi><mo>&lt;</mo><mi>b</mi><mo separator="true">,</mo><mi>k</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2^{32}=b\times k+r\ (0\le r&lt; b,k\in \mathbb{N})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">N</span><span class="mclose">)</span></span></span></span></span> 则原式等于 <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">&gt;</mo><mo stretchy="false">⌊</mo><mfrac><mrow><mi>a</mi><mo>×</mo><mi>k</mi><mo>+</mo><mi>a</mi><mo>×</mo><mrow><mo fence="true">⌈</mo><mfrac><mi>r</mi><mi>b</mi></mfrac><mo fence="true">&gt;</mo></mrow><mo stretchy="false">⌉</mo></mrow><mrow><mi>b</mi><mo>×</mo><mi>k</mi><mo>+</mo><mi>r</mi></mrow></mfrac><mo fence="true">⌋</mo></mrow><mo>×</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\left
&gt; \lfloor \frac{a\times k +a \times \left \lceil \frac{r}{b}  \right
&gt; \rceil }{b\times k+r}  \right \rfloor \times b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">⟩</span></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.59em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">⌈</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">⟩</span></span></span><span class="mclose">⌉</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">⌋</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span></p>
<ul>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a \mod b =0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时<ul>
<li><p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">r = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时原式等价为<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">⌊</mo><mfrac><mi>a</mi><mi>b</mi></mfrac><mo fence="true">⌋</mo></mrow><mo>×</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\left \lfloor \frac{a}{b}  \right \rfloor \times b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.836em;vertical-align:-0.686em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">⌋</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span>显然成立。</p>
</li>
<li><p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">r \ne 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时，原式等价为 <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">⌊</mo><mfrac><mrow><mi>a</mi><mo>×</mo><mi>k</mi><mo>+</mo><mi>a</mi></mrow><mrow><mi>b</mi><mo>×</mo><mi>k</mi><mo>+</mo><mi>r</mi></mrow></mfrac><mo fence="true">⌋</mo></mrow><mo>×</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\left \lfloor \frac{a\times k +a }{b\times k+r}  \right \rfloor \times b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">⌋</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span> 	因为   <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a \mod b =0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> ，因此原命题成立等价为如下不等式成立</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mi>a</mi><mi>b</mi></mfrac><mo>≤</mo><mfrac><mrow><mi>a</mi><mo>×</mo><mi>k</mi><mo>+</mo><mi>a</mi></mrow><mrow><mi>b</mi><mo>×</mo><mi>k</mi><mo>+</mo><mi>r</mi></mrow></mfrac><mo>&lt;</mo><mfrac><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{a}{b} \le \frac{a\times k +a }{b\times k+r} &lt;\frac{a+b}{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1408em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
<p>首先显然有如下不等式成立：<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi>a</mi><mo>×</mo><mi>k</mi><mo>+</mo><mi>a</mi></mrow><mrow><mi>b</mi><mo>×</mo><mi>k</mi><mo>+</mo><mi>r</mi></mrow></mfrac><mo>&gt;</mo><mfrac><mrow><mi>a</mi><mo>×</mo><mo>&gt;</mo><mi>k</mi><mo>+</mo><mi>a</mi></mrow><mrow><mi>b</mi><mo>×</mo><mi>k</mi><mo>+</mo><mi>b</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex"> \frac{a\times k+a}{b \times k+r} &gt;\frac{a\times
&gt;     k+a}{b \times k+b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.1408em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1408em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mord">×</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span> 	由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">k\in \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> ，因此 <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi>a</mi><mo>×</mo><mi>k</mi><mo>+</mo><mi>a</mi></mrow><mrow><mi>b</mi><mo>&gt;</mo><mo>×</mo><mi>k</mi><mo>+</mo><mi>r</mi></mrow></mfrac><mo>&gt;</mo><mfrac><mi>a</mi><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{a\times k+a}{b
&gt;     \times k+r}&gt;\frac{a}{b} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.1408em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">×</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span> 	而不等式<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi>a</mi><mo>×</mo><mi>k</mi><mo>+</mo><mi>a</mi></mrow><mrow><mi>b</mi><mo>×</mo><mo>&gt;</mo><mi>k</mi><mo>+</mo><mi>r</mi></mrow></mfrac><mo>&lt;</mo><mfrac><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex"> \frac{a \times k+a}{b\times
&gt;     k+r}&lt;\frac{a+b}{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.1408em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mord">×</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span> 	可以化简为<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>b</mi><mo>×</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo>+</mo><mi>a</mi><mo>×</mo><mi>r</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b\times (2^{32}-a)+a\times r&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span> 	显然也成立</p>
</li>
</ul>
</li>
<li>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>b</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a \mod b \ne 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时显然不存在一个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>t</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t\ (t \in  \mathbb{N})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">N</span><span class="mclose">)</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>×</mo><mi>b</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">t \times b = a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6984em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> ，因此原式一定不成立</li>
</ul>
<p><br>综上，原命题成立</p>
</blockquote>
<h5 id="HEAP-LFH-SUBSEGMENT-OWNER"><a href="#HEAP-LFH-SUBSEGMENT-OWNER" class="headerlink" title="_HEAP_LFH_SUBSEGMENT_OWNER"></a>_HEAP_LFH_SUBSEGMENT_OWNER</h5><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _HEAP_LFH_SUBSEGMENT_OWNER</span><br><span class="line">ntdll!_HEAP_LFH_SUBSEGMENT_OWNER</span><br><span class="line">   +0x000 IsBucket         : Pos 0, 1 Bit</span><br><span class="line">   +0x000 Spare0           : Pos 1, 7 Bits</span><br><span class="line">   +0x001 BucketIndex      : UChar</span><br><span class="line">   +0x002 SlotCount        : UChar</span><br><span class="line">   +0x002 SlotIndex        : UChar</span><br><span class="line">   +0x003 Spare1           : UChar</span><br><span class="line">   +0x008 AvailableSubsegmentCount : Uint8B</span><br><span class="line">   +0x010 Lock             : Uint8B</span><br><span class="line">   +0x018 AvailableSubsegmentList : _LIST_ENTRY</span><br><span class="line">   +0x028 FullSubsegmentList : _LIST_ENTRY</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>IsBucket</code>：用来区分该结构是在 <code>Bucket</code> 上还是在 <code>AffinitySlots</code> 上，如果是 <code>Bucket</code> 中的 <code>State</code> 则该位置 1 。</li>
<li><code>BucketIndex</code>：当前 <code>Bucket</code> 的编号，通常可以利用这个值查找全局数组 <code>RtlpBucketBlockSizes</code> 来获取 <code>BlockSize</code>：<code>RtlpBucketBlockSizes[State.BucketIndex]</code></li>
<li><code>AvailableSubsegmentCount</code>：目前可用于分配的的 LFH Subsegments 数量。</li>
<li><code>AvailableSubsegmentList</code>：指向下一个可用的 LFH subsegment 。</li>
<li><code>FullSubsegmentList</code>：指向下一个全被使用的 LFH subsegment ，目前没有发现该链表使用的地方。</li>
</ul>
<h5 id="HEAP-LFH-AFFINITY-SLOT"><a href="#HEAP-LFH-AFFINITY-SLOT" class="headerlink" title="_HEAP_LFH_AFFINITY_SLOT"></a>_HEAP_LFH_AFFINITY_SLOT</h5><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _HEAP_LFH_AFFINITY_SLOT</span><br><span class="line">ntdll!_HEAP_LFH_AFFINITY_SLOT</span><br><span class="line">   +0x000 State            : _HEAP_LFH_SUBSEGMENT_OWNER</span><br><span class="line">   +0x038 ActiveSubsegment : _HEAP_LFH_FAST_REF</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>State</code> ：类似 <code>Bucket</code> 中的 <code>State</code> ，不过这个主要用来管理 Subsegment ，<code>LfhSubsegment.Owner</code> 通常会指向这个结构。</li>
<li><code>ActiveSubsegment</code>：指向当前正在使用的 Subsegment 。</li>
</ul>
<h5 id="HEAP-LFH-SUBSEGMENT"><a href="#HEAP-LFH-SUBSEGMENT" class="headerlink" title="_HEAP_LFH_SUBSEGMENT"></a>_HEAP_LFH_SUBSEGMENT</h5><p>与 Nt Heap 中的 <code>UserBlock</code> 中的非常相似，但每个块没有 chunk 头。主要通过 <code>Buckets-&gt;AffinitySlots</code> 管理。</p>
<p>一旦没有足够的内存，LFH Subsegment 将从 <code>Buckets-&gt;State</code> 获取 LFH Subsegment 。首先尝试从 <code>AvailableSubsegmentList</code> 中获取，如果没有可用的子段，将从后端分配器分配一个新的 LFH Subsegment 。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _HEAP_LFH_SUBSEGMENT</span><br><span class="line">ntdll!_HEAP_LFH_SUBSEGMENT</span><br><span class="line">   +0x000 ListEntry        : _LIST_ENTRY</span><br><span class="line">   +0x010 Owner            : Ptr64 _HEAP_LFH_SUBSEGMENT_OWNER</span><br><span class="line">   +0x010 DelayFree        : _HEAP_LFH_SUBSEGMENT_DELAY_FREE</span><br><span class="line">   +0x018 CommitLock       : Uint8B</span><br><span class="line">   +0x020 FreeCount        : Uint2B</span><br><span class="line">   +0x022 BlockCount       : Uint2B</span><br><span class="line">   +0x020 InterlockedShort : Int2B</span><br><span class="line">   +0x020 InterlockedLong  : Int4B</span><br><span class="line">   +0x024 FreeHint         : Uint2B</span><br><span class="line">   +0x026 Location         : UChar</span><br><span class="line">   +0x027 WitheldBlockCount : UChar</span><br><span class="line">   +0x028 BlockOffsets     : _HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS</span><br><span class="line">   +0x02c CommitUnitShift  : UChar</span><br><span class="line">   +0x02d CommitUnitCount  : UChar</span><br><span class="line">   +0x02e CommitStateOffset : Uint2B</span><br><span class="line">   +0x030 BlockBitmap      : [1] Uint8B</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>ListEntry</code>：指向前（后）一个 LFH Subsegment 。与 VS Subsegment 不同的是这里的指针不加密。</li>
<li><code>Owner (_HEAP_LFH_SUBSEGMENT_OWNER)</code>：指向管理 LFH Subsegment 的结构体，具体来说是指向对应的 <code>AffinitySlots.State</code> 。</li>
<li><code>FreeCount</code>：LFH Subsegment 中空闲 <code>Block</code> 的数量。</li>
<li><code>BlockCount</code>：LFH Subsegment 中 <code>Block</code> 的数量。</li>
<li><code>FreeHint</code>：释放的 <code>Block</code> 中的最小下标。</li>
<li><code>Location</code>：标记该 LFH Subsegment 所在的位置。<ul>
<li>0：<code>AvailableSubsegmentList</code></li>
<li>1：<code>FullSubsegmentList</code></li>
<li>2：表示 FLH Subsegment 不在链表中</li>
</ul>
</li>
<li><code>WitheldBlockCount</code>：当 <code>LfhContext-&gt;Config.WitholdPageCrossingBlocks</code> 置 1 即不允许有跨页 <code>Block</code> 且 <code>Block</code> 不为 2 的整数次幂时这个值用于统计 <code>LfhSubsegment</code> 中的跨页块的数量。</li>
<li><code>BlockOffsets (_HEAP_LFH_SUBSEGMENT_ENCODED_OFFSETS)</code>：被加密为 <code>EncodedData = RtlpHpHeapGlobals.LfhKey ^ BlockOffsets ^ (Subsegment &gt;&gt; 12)</code> 。<ul>
<li><code>BlockSize</code>：LFH Subsegment 中每一个 LFH block 的大小。</li>
<li><code>FirstBlockOffset</code>：第一个 <code>Block</code> 相对于 LFH Subsegment 起始地址的偏移。</li>
</ul>
</li>
<li><code>CommitUnitShift</code>：<code>1 &lt;&lt; CommitUnitShift</code> 为一个 <code>CommitUnit</code> 的大小。</li>
<li><code>CommitUnitCount</code>：LFH Subsegment 中划分的 <code>CommitUnit</code> 的数量。</li>
<li><code>CommitStateOffset</code>：记录每个 <code>CommitUnit</code> 状态的 <code>uint16_t</code> 数组相对于 LFH Subsegment 的偏移。如果一个跨多个 <code>CommitUnit</code> 上的 <code>Block</code> 被申请出去则这个 <code>Block</code> 所覆盖的 <code>CommitUnit</code> 对应的 <code>CommitState</code> 会加 1 。</li>
<li><code>BlockBitmap</code>：每个 LFH 块的状态由该块位图中的 2 个比特表示。<ul>
<li>bit 0：is busy bit</li>
<li>bit 1：unused bytes</li>
</ul>
</li>
<li><code>Block</code>：分配器返回给用户的内存。对于已分配的 <code>Block</code> 如果 <code>UnusedBytes</code> 不为 0 会把 <code>Block</code> 在最后 2 字节作为 <code>UnusedBytes</code> ，如果 <code>UnusedBytes</code> 为 1则将最后 2 字节置为 0x8000（实际上相当于只将最后的 1 字节置为 0x80）。</li>
</ul>
<h4 id="分配机制-3"><a href="#分配机制-3" class="headerlink" title="分配机制"></a>分配机制</h4><h5 id="Allocate-2"><a href="#Allocate-2" class="headerlink" title="Allocate"></a>Allocate</h5><ul>
<li>在 <code>RtlpAllocateHeapInternal</code> 中首先判断 <code>Size &lt;= 0x4000 -16</code> ，如果满足条件说明在 LFH 堆的分配范围。</li>
<li>在 LFH Context 中找到对应的 <code>Buckets</code> 指针，根据其最低 1 比特是否置位判断 LFH 是否已初始化，如果最低 1 比特未置位说明 LFH 已初始化，直接调用 <code>RtlpHpLfhSlotAllocate</code> 进行 LFH 分配。</li>
<li>否则将 <code>Buckets</code> 指针的第二个 2 字节加 0x21 然后判断是否满足与 0x1F 大于 0x10 或者大于 0xFF00（和 Nt Heap 判断条件相同），如果满足则调用 <code>RtlpHpLfhBucketActivate</code> 初始化。<ul>
<li>调用 <code>RtlpHpSegLfhExtendContext</code> 为 <code>Bucket</code> 及其相关结构申请内存。</li>
<li>调用 <code>RtlpHpLfhBucketInitialize</code> 函数初始化 <code>Bucket</code> 。<ul>
<li>调用 <code>RtlpHpLfhOwnerInitialize</code> 初始化 <code>Bucket-&gt;State</code> 。<ul>
<li>将 <code>Bucket-&gt;State.IsBucket</code> 置 1 。</li>
<li>初始化 <code>Bucket-&gt;State.BucketIndex</code> 。</li>
<li>初始化 <code>Bucket-&gt;State.AvailableSubsegmentList</code> 为空链表。</li>
<li>初始化 <code>Bucket-&gt;State.FullSubsegmentList</code> 为空链表。</li>
</ul>
</li>
<li>通过全局数组 <code>RtlpBucketBlockSizes</code> 获取 <code>BlockSize</code> 。</li>
<li>判断 <code>BlockSize</code> 是否是 2 的整数次幂。<ul>
<li>如果 <code>BlockSize</code> 不是 2 的整数次幂则初始化 <code>Bucket-&gt;Shift</code> 为 <code>__builtin_ctz(LFHContext-&gt;Config.MaxBlockSize) + 18 = 32</code>，初始化<code>Bucket-&gt;ReciprocalBlockSize</code> 为 <code>(BlockSizes - 1 + (1i64 &lt;&lt; Shift)) / _BlockSizes</code> 。</li>
<li>否则初始化 <code>Bucket-&gt;Shift</code> 为 <code>__builtin_ctz(BlockSizes)</code> 。</li>
</ul>
</li>
</ul>
</li>
<li>初始化 <code>Bucket-&gt;AffinitySlots</code> 指向 <code>AffinitySlot</code> 数组。然后初始化 <code>AffinitySlot</code> 数组中的每一项（实际只有 1 项）指向具体的 <code>_HEAP_LFH_AFFINITY_SLOT</code> 结构，更新 <code>Bucket-&gt;State.SlotCount</code> 并调用 <code>RtlpHpLfhOwnerInitialize</code> 函数初始化 <code>AffinitySlot-&gt;State</code> 。<ul>
<li>初始化 <code>AffinitySlot-&gt;State.SlotCount</code> 为该 <code>AffinitySlot</code> 在 <code>AffinitySlot</code> 数组中的下标。</li>
<li>初始化 <code>AffinitySlot-&gt;State.BucketIndex</code> 。</li>
<li>初始化 <code>AffinitySlot-&gt;State.AvailableSubsegmentList</code> 为空链表。</li>
<li>初始化 <code>AffinitySlot-&gt;State.FullSubsegmentList</code> 为空链表。</li>
</ul>
</li>
<li><code>LfhContext-&gt;Buckets[BucketIndex]</code> 指向初始化的 <code>Bucket</code> 。</li>
</ul>
</li>
<li>接下来会调用 LFH 堆分配的核心函数 <code>RtlpHpLfhSlotAllocate</code> 。<ul>
<li>根据 <code>AffinitySlot-&gt;State.AvailableSubsegmentCount</code> 是否为 0 判断是否有空闲的 <code>LfhSubsegment</code> 。如果有直接进行后续分配操作，否则需要先创建 <code>LfhSubsegment</code> 。</li>
<li>如果 <code>AffinitySlot-&gt;State.AvailableSubsegmentList</code> 为空则调用 <code>RtlpHpLfhSubsegmentCreate</code> 函数创建 <code>LfhSubsegment</code> 。<ul>
<li>依次调用 <code>RtlpHpSegLfhAllocate</code> 和 <code>RtlpHpSegLfhVsCommit</code> 为 <code>LfhSubsegment</code> 申请内存。</li>
<li>调用 <code>RtlpHpLfhSubsegmentInitialize</code> 函数初始化 <code>LfhSubsegment</code> 。<ul>
<li>根据 <code>BlockSize</code> 和 <code>SubsegmentSize</code> 计算出 <code>BlockCount</code> 和 <code>BlockOffset (BlockSize,FirstBlockOffset)</code> ，然后初始化 <code>LfhSubsegment-&gt;FreeCount</code> 和 <code>LfhSubsegment-&gt;BlockCount</code> 为 <code>BlockCount</code> 以及 <code>LfhSubsegment-&gt;BlockOffsets</code> ，注意这里 <code>BlockOffsets</code> 是被加密的。</li>
<li>根据 <code>CommitUnitSize</code> 和 <code>SubsegmentSize</code> 计算出 <code>LfhSubsegment-&gt;CommitUnitCount</code> ， <code>LfhSubsegment-&gt;CommitUnitShift</code> 和 <code>LfhSubsegment-&gt;CommitStateOffset</code> 。</li>
<li>初始化 <code>LfhSubsegment-&gt;Location</code> 为 2 。</li>
<li>初始化 <code>LfhSubsegment-&gt;BlockBitmap</code> 为全 0 ，关于 8 字节对齐的位置全部位置 1 。</li>
<li>如果 <code>LfhContext-&gt;Config.WitholdPageCrossingBlocks</code> 即不允许有跨页 <code>Block</code> 且 <code>LfhSubsegment</code> 的大小超过 0x1000 则需要进行一些调整来避免跨页的 <code>Block</code> ，不过这个选项默认不开启。</li>
<li>最后初始化一下对应的 <code>RtlpLowFragHeapRandomDat</code> 。</li>
</ul>
</li>
<li>更新 <code>Bucket-&gt;TotalSubsegmentCount++</code> 和 <code>Bucket-&gt;TotalBlockCount += LfhSubsegment-&gt;BlockCount</code> 。</li>
</ul>
</li>
<li>初始化 <code>LfhSubsegment-&gt;Owner</code> 指向对应的 <code>AffinitySlot-&gt;State</code> 。</li>
<li>设置 <code>LfhSubsegment-&gt;Location</code> 为 0 ，然后将新创建的 <code>LfhSubsegment</code> 从 <code>Blink</code> 加入到 <code>AffinitySlot-&gt;State.AvailableSubsegmentList</code> 中，加入时有一个双向链表检查。</li>
<li>如果 <code>AffinitySlot-&gt;State.AvailableSubsegmentCount &gt; 8</code> 会从 <code>AffinitySlot-&gt;State.AvailableSubsegmentList</code> 的 <code>Flink</code> 取出一个 <code>LfhSubsegment</code> 并将其 <code>Location</code> 置为 2 ，<code>Owner</code> 值为 NULL 。</li>
<li>因为此时 <code>AffinitySlot-&gt;State.AvailableSubsegmentList</code> 不为空，因此会尝试从其 <code>Flink</code> 找到一个 <code>LfhSubsegment</code> 用作内存分配，更新 <code>LfhSubsegment-&gt;FreeCount--</code> 。</li>
<li>通过 <code>BucketIndex</code> 查询全局数组 <code>RtlpSearchWidth</code> 得到随机范围 <code>SearchWith</code> 。</li>
<li>判断 <code>LFHContext-&gt;Config.DisableRandomization</code> 是否置位来决定 <code>RandomOffset</code> 是否为 0（不随机）。因为随机化默认开启，因此 <code>DisableRandomization</code> 不置位，会通过 <code>TEB-&gt;HeapData</code> 在 <code>RtlpLowFragHeapRandomData</code> 数组中选取一个随机值作为 <code>RandomOffset</code> 并更新 <code>TEB-&gt;HeapData</code> 。</li>
<li>从 <code>LfhSubsegment-&gt;BlockBitmap</code> 中 <code>LfhSubsegment-&gt;FreeHint</code> 所在的 <code>BitMap</code> 开始循环遍历 <code>BlockBitmap</code> ，直到找到一个有空闲块的 <code>BitMap</code> （<code>busy</code> 位不为 1）。特别的，如果 <code>LfhSubsegment-&gt;BlockCount * 2 &lt; 64</code>（这里乘 2 是因为 2 个 比特对应一个 <code>Block</code> 的状态），那么 <code>BlockBitmap</code> 中不足一个 <code>BitMap</code>（这里定义一个 <code>BitMap</code> 为一个 8 字节长度数据），因此该 <code>BitMap</code> 一定包含空闲块且需要更新 <code>SearchWith = min(SearchWith , LfhSubsegment-&gt;BlockCount * 2)</code> 。</li>
<li>初始化 <code>RandomOffset = ((SearchWidth * RandomOffset) &gt;&gt; 7) &amp; 0x1FFFFFE</code> 。</li>
<li>设置 <code>SearchMask</code> 为 0x5555555555555555 ，如果查找范围 <code>SearchWidth</code> 小于 64 时为了确保一定能找到空闲 chunk 需要在 <code>BitMap</code> 中用找到第一个空闲 <code>Block</code> 的位置 <code>FirstOffset</code> ，然后 <code>SearchWidthMask</code> 设置为 <code>(((1i64 &lt;&lt; SearchWidth) - 1) &lt;&lt; FirstOffset) &amp; 0x5555555555555555i64</code> 确保一定能覆盖到空闲 chunk 。另外还会将 <code>RandomOffset</code> 加上 <code>FirstOffset</code> 。</li>
<li>在 <code>BitMap</code> 的 <code>RandomOffset</code> 偏移处开始，<code>SearchWidthMask</code> 范围内，找到第一个空闲 <code>Block</code> 的下标 <code>FreeChunkOffset</code> 。</li>
<li>将 <code>FreeChunkOffset</code> 加上 <code>RandomOffset</code> 并关于 64 取模得到在 <code>BitMap</code> 中的真实偏移。</li>
<li>更新 <code>BitMap</code> ，在要取出的 <code>Block</code> 的对应位置置位。</li>
<li>计算空闲 <code>Block</code> 在整个 <code>LfhSubsegment</code> 中的下标 <code>FreeBlockIndex</code> 。</li>
<li>如果 <code>Block</code> 横跨多个 <code>CommitUnit</code> 则将这些  <code>CommitUnit</code> 对应的 <code>CommitState</code> 都加 1 。</li>
<li>如果 <code>UnusedBytes</code> 不为 0 会把 <code>Block</code> 在最后 2 字节作为 <code>UnusedBytes</code> ，如果 <code>UnusedBytes</code> 为 1则将最后 2 字节置为 0x8000（实际上相当于只将最后的 1 字节置为 0x80）。最后返回找到的 <code>Block</code> 。</li>
</ul>
</li>
</ul>
<h5 id="Free-2"><a href="#Free-2" class="headerlink" title="Free"></a>Free</h5><ul>
<li>在 <code>RtlpFreeHeapInternal</code> 函数中根据 <code>(HeapPageRangeDesctiptor-&gt;RangeFlags &amp; 0xC) == 8</code> 判断释放的 <code>Block</code> 属于 LFH 堆，因此调用 LFH 堆释放的核心函数 <code>RtlpHpLfhSubsegmentFreeBlock</code> 。</li>
<li>计算 <code>BlockPtr</code> 相对于 <code>LfhSubsegment</code> 中第一个 <code>Block</code> 的偏移 <code>BlockOffset = BlockPtr - FirstBlockOffset - LfhSubsegment</code> ，这里的 <code>FirstBlockOffset</code> 是 <code>LfhSubsegment-&gt;BlockOffsets</code> 解密后的高 2 字节。</li>
<li>通过 <code>LfhContext-&gt;Buckets[RtlpLfhBucketIndexMap[(BlockSize + 15) &gt;&gt; 4]]</code> 找到对应的 <code>Bucket</code> ，这里 <code>BlockSize</code> 是 <code>LfhSubsegment-&gt;BlockOffsets</code> 解密后的低 2 字节。</li>
<li>判断 <code>BlockOffset</code> 是否能被 <code>BlockSize</code> 整除。如果 <code>Bucket-&gt;ReciprocalBlockSize</code> 非 0 说明 <code>BlockSize</code> 不是 2 的整数次幂，需要根据 <code>((BlockOffset * ReciprocalBlockSize) &gt;&gt; Shift) * BlockSize</code> 是否等于 <code>BlockOffset</code> 来判断。如果 <code>Bucket-&gt;ReciprocalBlockSize</code> 为 0 说明 <code>BlockSize</code> 是 2 的整数次幂，可以通过 <code>BlockOffset &amp; ((1 &lt;&lt; Shift) - 1)</code> 来判断。</li>
<li>更新 <code>LfhSubsegment-&gt;FreeHint = min(LfhSubsegment-&gt;FreeHint, BlockIndex)</code> ，这里 <code>BlockIndex</code> 为释放的 <code>Block</code> 在 <code>LfhSubsegment</code> 中的下标，是在前面判断判断 <code>BlockOffset</code> 是否能被 <code>BlockSize</code> 整除的时候计算出的。 </li>
<li>更新 <code>LFHSubsegment.BlockBitmap</code> 。</li>
<li>如果 <code>Block</code> 横跨多个 <code>CommitUnit</code> 则将这些  <code>CommitUnit</code> 对应的 <code>CommitState</code> 都减 1 。</li>
<li>更新 <code>LfhSubsegment-&gt;FreeCount++</code> 。</li>
<li>如果 <code>LfhSubsegment-&gt;FreeCount == LfhSubsegment-&gt;BlockCount</code> 说明 <code>LfhSugsegment</code> 需要从原本所在的链表中取出。如果 <code>LfhSubsegment-&gt;FreeCount == 1</code> 即原先 <code>FreeCount</code> 为 0 则需要将 <code>LfhSubsegment</code> 放到 <code>LfhSubsegment-&gt;Owner-&gt;AvailableSubsegmentList</code> 中。否则直接返回。</li>
<li>如果没有立即返回则说明需要转移 <code>LfhSubsegment</code> 的位置。首先需要将 <code>LfhSubsegment</code> 从原本所在的链表中取出，取出前有双向链表检查。</li>
<li>如果 <code>LfhSugsegment</code> 需要插入新的链表中（这里通常为 <code>AvailableSubsegmentList</code>）则从新的链表的 <code>Blink</code> 插入，在插入之前有双向链表检查。</li>
<li>更新 <code>LfhSugsegment-&gt;Location</code> 。</li>
<li>如果 <code>LfhSubsegment-&gt;Owner-&gt;AvailableSubsegmentCount &gt; 8</code> 需要从 <code>AvailableSubsegmentList</code> 的 <code>Flink</code> 取出一个 <code>LfhSubsegment</code> 并将其 <code>Location</code> 标记为 2 。</li>
<li>如果有从 <code>AvailableSubsegmentList</code> 中取出的 <code>LfhSubsegment</code> 并且 <code>Location == 2</code> 则需要将其 <code>Owner</code> 置为 NULL 。</li>
<li>如果 <code>LfhSubsegment-&gt;FreeCount != LfhSubsegment-&gt;BlockCount</code> 即取出的 <code>LfhSubsegment</code> 不完全空闲则将 <code>LfhSubsegment</code> 重新放回 <code>AvailableSubsegmentList</code> 中，放回过程有双向链表检查。</li>
<li>否则需要将 <code>LfhSubsegment</code> 释放。首先要更新 <code>Bucket-&gt;TotalBlockCount -= LfhSubsegment-&gt;BlockCount</code> 以及更新 <code>Bucket-&gt;TotalSubsegmentCount--</code> ，然后调用 <code>RtlpHpSegLfhVsFree</code> 释放 <code>LfhSubsegment</code> 。</li>
</ul>
<h3 id="后端堆-1"><a href="#后端堆-1" class="headerlink" title="后端堆"></a>后端堆</h3><h4 id="相关数据结构-4"><a href="#相关数据结构-4" class="headerlink" title="相关数据结构"></a>相关数据结构</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/windows-user-pwn-basic-knowlege/images/5ed12569faf5d64f7cd1539c212ea442.png"
                     
                ></p>
<h5 id="HEAP-SEG-CONTEXT"><a href="#HEAP-SEG-CONTEXT" class="headerlink" title="_HEAP_SEG_CONTEXT"></a>_HEAP_SEG_CONTEXT</h5><p>段分配的核心结构，用于管理由段分配器分配的内存，并在堆中记录段分配器的所有信息和结构。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; dx -r1 (*((ntdll!_HEAP_SEG_CONTEXT *)0x23aac050140))</span><br><span class="line">(*((ntdll!_HEAP_SEG_CONTEXT *)0x23aac050140))                 [Type: _HEAP_SEG_CONTEXT]</span><br><span class="line">    [+0x000] SegmentMask      : 0xfffffffffff00000 [Type: unsigned __int64]</span><br><span class="line">    [+0x008] UnitShift        : 0xc [Type: unsigned char]</span><br><span class="line">    [+0x009] PagesPerUnitShift : 0x0 [Type: unsigned char]</span><br><span class="line">    [+0x00a] FirstDescriptorIndex : 0x2 [Type: unsigned char]</span><br><span class="line">    [+0x00b] CachedCommitSoftShift : 0x7 [Type: unsigned char]</span><br><span class="line">    [+0x00c] CachedCommitHighShift : 0x4 [Type: unsigned char]</span><br><span class="line">    [+0x00d] Flags            [Type: &lt;unnamed-tag&gt;]</span><br><span class="line">    [+0x010] MaxAllocationSize : 0x7f000 [Type: unsigned long]</span><br><span class="line">    [+0x014] OlpStatsOffset   : -160 [Type: short]</span><br><span class="line">    [+0x016] MemStatsOffset   : -192 [Type: short]</span><br><span class="line">    [+0x018] LfhContext       : 0x23aac050380 [Type: void *]</span><br><span class="line">    [+0x020] VsContext        : 0x23aac0502c0 [Type: void *]</span><br><span class="line">    [+0x028] EnvHandle        [Type: RTL_HP_ENV_HANDLE]</span><br><span class="line">    [+0x038] Heap             : 0x23aac050000 [Type: void *]</span><br><span class="line">    [+0x040] SegmentLock      : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x048] SegmentListHead  [Type: _LIST_ENTRY]</span><br><span class="line">    [+0x058] SegmentCount     : 0x1 [Type: unsigned __int64]</span><br><span class="line">    [+0x060] FreePageRanges   [Type: _RTL_RB_TREE]</span><br><span class="line">    [+0x070] FreeSegmentListLock : 0x0 [Type: unsigned __int64]</span><br><span class="line">    [+0x078] FreeSegmentList  [Type: _SINGLE_LIST_ENTRY [2]]</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>SegmentMask</code>：用于从 <code>BlockPtr</code> 找到 <code>PageSegment</code> ： <code>PageSegment = BlockPtr &amp; SegmentMask</code> 。</li>
<li><code>UnitShift</code>：一个 <code>PageDescriptor</code> 维护的内存的大小关于 2 取对数，用于计算 <code>BlockPtr</code> 所在 <code>Page</code> 对应的 <code>PageDescriptor</code> 的下标：<code>Index = BlockPtr &gt;&gt; UnitShift</code> 。</li>
<li><code>PagePerUnitShift</code>：一个 <code>PageDescriptor</code> 维护的内存的的内存页数（即大小除以 0x1000）关于 2 取对数。</li>
<li><code>FirstDescriptorIndex</code>：第一个 <code>PageDescriptor</code> 在 <code>SegContext</code> 中的下标。</li>
<li><code>LfhContext</code>：指向 Segment Heap 的 <code>LfhContext</code> 。</li>
<li><code>VsContext</code>：指向 Segment Heap 的 <code>VsContext</code> 。</li>
<li><code>Heap</code>：指向所属的 Segment Heap 。</li>
<li><code>SegmentListHead</code>：指向 <code>PageSegment</code> 的双向链表。</li>
<li><code>SegmentCount</code>：<code>PageSegment</code> 的数量。</li>
<li><code>FreePageRanges</code>：维护空闲的 Subsegment 的红黑树，树的节点为 <code>PageSegment.DescArray</code> 中的元素。与 VS 堆的 <code>FreeChunkTree</code> 相似。</li>
<li><code>FreeSegmentList</code>：存放空闲的 <code>PageSegment</code> 。</li>
</ul>
<h5 id="HEAP-PAGE-SEGMENT"><a href="#HEAP-PAGE-SEGMENT" class="headerlink" title="_HEAP_PAGE_SEGMENT"></a>_HEAP_PAGE_SEGMENT</h5><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0:003&gt; dt _HEAP_PAGE_SEGMENT 0x23026a00000</span><br><span class="line">ntdll!_HEAP_PAGE_SEGMENT</span><br><span class="line">   +0x000 ListEntry        : _LIST_ENTRY [ 0x00000230`26970188 - 0x00000230`26970188 ]</span><br><span class="line">   +0x010 Signature        : 0xe5cd4705`0e7c5890</span><br><span class="line">   +0x018 SegmentCommitState : (null) </span><br><span class="line">   +0x020 UnusedWatermark  : 0 &#x27;&#x27;</span><br><span class="line">   +0x000 DescArray        : [256] _HEAP_PAGE_RANGE_DESCRIPTOR</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>ListEntry</code>：连接链表中的前后 <code>PageSegment</code> 。</li>
<li><code>Signature</code>：用来检验 <code>PageSegment</code> 是否有效，通过 <code>PageSegment ^ SegContext ^ RtlpHpHeapGlobals.HeapKey ^ 0xA2E64EADA2E64EAD</code> 计算。</li>
<li><code>DescArray (_HEAP_PAGE_RANGE_DESCRIPTOR)</code>：数组中的每个元素对应描述 <code>PageSegment</code> 中一个内存页的状态。</li>
</ul>
<h5 id="HEAP-PAGE-RANGE-DESCRIPTOR"><a href="#HEAP-PAGE-RANGE-DESCRIPTOR" class="headerlink" title="_HEAP_PAGE_RANGE_DESCRIPTOR"></a>_HEAP_PAGE_RANGE_DESCRIPTOR</h5><p>页面描述符指示页面段中每个页面的状态（已分配或已释放）和信息（页面是否为块的开始、块的大小等）。它可以被划分为已分配和释放。释放状态下的页面范围描述符将存储在自由页面范围中，这是一个 rbtree 结构。</p>
<p><code>_HEAP_PAGE_RANGE_DESCRIPTOR</code> 处于已分配状态时结构如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8ac4e246eb32e9d376332cff7aee1d80.png"
                      style="zoom: 50%;" 
                ></p>
<ul>
<li><p><code>TreeSignature</code>：<code>PageRangeDescriptor</code> 的签名，值为恒为 0xCCDDCCDD 。只在 <code>Block</code> 的开头对应的 <code>PageRangeDescriptor</code> 才有。</p>
</li>
<li><p><code>UnusedBytes</code>：申请的块未使用的部分的大小。</p>
</li>
<li><p><code>RangeFlag</code>：表示页的状态。</p>
<ul>
<li>Bit 1：allocted bit</li>
<li>Bit 2：block header bit</li>
<li>Bit 3：Commited<ul>
<li>LFH：<code>RangeFlag &amp; 0xc = 8</code></li>
<li>VS：<code>RangeFlag &amp; 0xc = 0xc</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>CommitedPageCount</code>：表示相应页面中提交的页数。</p>
</li>
<li><p><code>key (_HEAP_DESCRIPTOR_KEY)</code>：存储与 <code>PageRangeDescriptor</code> 对应的页面的一些相关信息。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0:003&gt; dt _HEAP_DESCRIPTOR_KEY</span><br><span class="line">ntdll!_HEAP_DESCRIPTOR_KEY</span><br><span class="line">   +0x000 Key              : Uint4B</span><br><span class="line">   +0x000 EncodedCommittedPageCount : Pos 0, 16 Bits</span><br><span class="line">   +0x000 LargePageCost    : Pos 16, 8 Bits</span><br><span class="line">   +0x000 UnitCount        : Pos 24, 8 Bits</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>EncodedCommittedPageCount (2bytes)</code>：<code>~EncodedCommittedPageCount</code> 是 <code>Block</code> 中提交的页面数。只在 <code>Block</code> 的开头对应的 <code>PageRangeDescriptor</code> 才有。</li>
<li><code>UniCount (1byte)</code>：<ul>
<li>如果是 <code>Block</code> 的开头对应的 <code>PageRangeDescriptor</code> ，那么 <code>UniCount </code> 为 <code>Block</code>  的大小，用 <code>Page</code> 的数量来表示。</li>
<li>如果不是 <code>Block</code> 的开头对应的 <code>PageRangeDescriptor</code> ，那么 <code>UniCount </code> 为 <code>Page</code> 在 <code>Block</code> 中的偏移。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>_HEAP_PAGE_RANGE_DESCRIPTOR</code> 处于已释放状态时结构如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f00f1505aecb8d06c56dac2fd2b4243b.png"
                      style="zoom:50%;" 
                ></p>
<ul>
<li><code>TreeNode (_RTL_BALANCED_NODE)</code>：<ul>
<li><code>Left</code>：指向大小小于当前 <code>PageRangeDescriptor</code> 对应 <code>Block</code> 的 <code>Block</code> 对应的 <code>PageRangeDescriptor</code> 。</li>
<li><code>Right</code>：指向大小大于当前 <code>PageRangeDescriptor</code> 对应 <code>Block</code> 的 <code>Block</code> 对应的 <code>PageRangeDescriptor</code> 。</li>
<li><code>ParentValue</code>：指向父节点，指针最低 1 比特表示是否加密。</li>
</ul>
</li>
<li><code>Key(_HEAP_DESCRIPTOR_KEY)</code>：与已分配的 <code>Block</code> 对应的 <code>PageRangeDescriptor</code> 相同，不过 <code>UniCount</code> 为 <code>Page</code> 在 <code>Block</code> 中的偏移。</li>
</ul>
<h4 id="分配机制-4"><a href="#分配机制-4" class="headerlink" title="分配机制"></a>分配机制</h4><h5 id="Allocate-3"><a href="#Allocate-3" class="headerlink" title="Allocate"></a>Allocate</h5><p>VS 堆，LFH 堆和用户申请内存都有可能从后端堆分配内存，这里选择用户申请内存时的过程进行分析，其余过程基本一致。</p>
<ul>
<li>在 <code>RtlpAllocateHeapInternal</code> 函数中，如果中首先判断 <code>Size &lt;= 0x4000 - 16</code> ，不在 LFH 堆的范围内，所以不考虑 FLH 堆的分配。</li>
<li>由于 <code>Size &gt; 0x20000</code> 因此不考虑 VS 堆的分配。</li>
<li>由于不满足 <code>Size &gt; Heap-&gt;SegContexts[1].MaxAllocationSize</code> 即 <code>Size &gt; 0x7f0000</code> ，因此不考虑 Large Block 堆的分配。</li>
<li>根据 <code>Size</code> 是否小于等于 <code>Heap-&gt;SegContexts[0].MaxAllocationSize</code> 决定是使用 <code>Heap-&gt;SegContexts[0]</code> 还是 <code>Heap-&gt;SegContexts[1]</code> 作为 <code>SegContexts</code> 。这两个结构的区别主要在于一个 <code>PageDescriptor</code> 维护的内存的大小， <code>Heap-&gt;SegContexts[0]</code> 对应的是 0x1000 ，而 <code>Heap-&gt;SegContexts[1]</code> 对应的是 0x10000 。然后调用核心分配函数 <code>RtlpHpSegAlloc</code> 进行内存分配。<ul>
<li>调用 <code>RtlpHpSegPageRangeAllocate</code> 函数获取合适的 <code>Block</code> 对应的 <code>PageRangeDescriptor</code> 。<br>- 计算 <code>UnitCount</code> 等于 <code>PageCount</code> 除以 <code>(1 &lt;&lt; HeapSegContext-&gt;PagesPerUnitShift)</code> 向上取整。 <ul>
<li>尝试从红黑树 <code>FreePageRanges</code> 中找合适的 <code>Block</code> 对应的 <code>PageRangeDescriptor</code> 。<ul>
<li>如果找到了合适的 <code>Block</code> 就会将该 <code>PageRangeDescriptor</code> 从红黑树中取出，然后初始化 <code>PageRangeDescriptor-&gt;TreeSignature = 0xCCDDCCDD</code>。</li>
<li>如果没有找到合适的 <code>Block</code><ul>
<li>首先调用 <code>RtlpHpSegSegmentAllocate</code> 申请一个新的 <code>PageSegment</code> 。</li>
<li>然后调用 <code>RtlpHpSegSegmentInitialize</code> 初始化新申请的 <code>PageSegment</code> 。<ul>
<li>首先找到第一个 <code>PageDescriptor</code>： <code>FirstDescriptor = (NewPageSegment + sizeof(_HEAP_PAGE_RANGE_DESCRIPTOR) * HeapSegContext-&gt;FirstDescriptorIndex)</code> 。</li>
<li>设置 <code>FirstDescriptor-&gt;UnitOffset = -HeapSegContext-&gt;FirstDescriptorIndex</code>。因为 <code>PageDescriptor</code> 是 0x100 个，而 <code>FirstDescriptor</code> 是 <code>DescArray</code> 数组中的第 3 个，<code>FirstDescriptorIndex = 2</code>，因此 <code>-FirstDescriptorIndex = 0x100 - 2 = 0xfe</code>，即整个 <code>Block</code> 的大小。</li>
<li>设置 <code>FirstDescriptor-&gt;RangeFlags |= 2u</code> ，即 allocted bit 置位。</li>
<li>设置 <code>FirstDescriptor-&gt;key.EncodedCommittedPageCount</code> 为 0xffff 。</li>
<li>设置 <code>FirstDescriptor-&gt;TreeSignature = 0xCCDDCCDD</code> 。</li>
<li>设置 <code>PageSegment.DescArray</code> 的 <code>UnitOffset </code> 为 <code>~FirstDescriptorIndex</code> ，即该 <code>PageDescriptor</code> 在整个 <code>Block</code> 中的下标。注意此时内存只申请了 <code>DescArray</code> ，后面的 <code>Page</code> 还没有申请，都是无效地址。</li>
</ul>
</li>
<li>调用 <code>RtlpHpSegHeapAddSegment</code> 函数。<ul>
<li>   初始化 <code>PageSegment-&gt;Signature = PageSegment ^ RtlpHpHeapGlobals.HeapKey ^ HeapSegContext ^ 0xA2E64EADA2E64EADui64</code> 。</li>
<li>   将新申请的 <code>PageSegment</code> 从 <code>Blink</code> 插入到 <code>SegContext-&gt;SegmentListHead</code> 中。在插入前有双向链表检查。</li>
<li>   最后 <code>++HeapSegContext-&gt;SegmentCount</code> 。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>调用 <code>RtlpHpSegPageRangeSplit</code> 从获取的 <code>Block</code> 中切下多余的部分。<ul>
<li>如果找到的 <code>Block</code> 大小恰好合适就直接返回 NULL 。</li>
<li>对于切下来的 <code>Block</code>：<ul>
<li>第一个 <code>PageRangeDescriptor</code> 的 <code>RangeFlags</code> 的 2 置位（block header bit）。</li>
<li>第一个 <code>PageRangeDescriptor</code> 的 <code>UnitOffset</code> 设置为该 <code>Block</code> 的 <code>PageRangeDescriptor</code> 数量。</li>
<li>第一个 <code>PageRangeDescriptor</code> 的 <code>TreeSignature</code> 设置为 0xCCDDCCDD 。</li>
<li>第一个 <code>PageRangeDescriptor</code> 的 <code>EncodedCommittedPageCount</code> 设置为该 <code>Block</code> 所有的 <code>CommittedPageCount</code> 之和取反 。</li>
<li>最后一个 <code>PageRangeDescriptor</code> 的 <code>UnitOffset</code> 设置为 <code>PageRangeDescriptor</code> 在 <code>Block</code> 中的下标。</li>
</ul>
</li>
<li>对于保留的 <code>Block</code>：<ul>
<li>第一个 <code>PageRangeDescriptor</code> 的 <code>UnitOffset</code> 设置为该 <code>Block</code> 的 <code>PageRangeDescriptor</code> 数量。</li>
<li>第一个 <code>PageRangeDescriptor</code> 的 <code>EncodedCommittedPageCount</code> 设置为该 <code>Block</code> 所有的 <code>CommittedPageCount</code> 之和取反（通过原有的 <code>EncodedCommittedPageCount</code> 与切下来的 <code>Block</code> 的 <code>EncodedCommittedPageCount</code> 计算） 。</li>
<li>最后一个 <code>PageRangeDescriptor</code> 的 <code>UnitOffset</code> 设置为 <code>PageRangeDescriptor</code> 在 <code>Block</code> 中的下标。</li>
</ul>
</li>
<li>最后返回切下来的 <code>Block</code> 。</li>
</ul>
</li>
<li>如果存在切下来的多余 <code>Block</code> 就调用 <code>RtlpHpSegFreeRangeInsert</code> 将多余部分放回 <code>FreePageRanges</code> 中。</li>
<li>对于申请到的 <code>Block</code> ，将其中第一个 <code>PageRangeDescriptor</code> 的 <code>RangeFlags</code> 或上 1（allocted bit）和 <code>HIBYTE(Flags) &amp; 0xC</code>（由参数决定是 <code>LfhSubsegment</code>，<code>VsSubsegment</code> 还是用户申请的内存）；将其中最后一个 <code>PageRangeDescriptor</code> 的 <code>RangeFlags</code> 或上 1（allocted bit）。</li>
<li>对于申请到的 <code>Block</code> ，将其中除第一个和最后一个的 <code>PageRangeDescriptor</code> 的 <code>RangeFlags</code> 或上 1（allocted bit），<code>UnitOffset</code> 设置为该 <code>PageRangeDescriptor</code> 在 <code>Block</code> 中的下标。</li>
<li>最后返回申请到的 <code>Block</code> 对应的第一个 <code>PageRangeDescriptor</code> 。</li>
</ul>
</li>
<li>调用 <code>RtlpHpSegPageRangeCommit</code> 判断申请到的 <code>Block</code> 中是否有需要提交的页面，如果有会调用 <code>RtlpHpSegMgrCommit -&gt;RtlpHpAllocVA-&gt;MmAllocatePoolMemory</code> 来分配页面。并且更新 <code>PageRangeDescriptor</code> 中的 <code>CommittedPagecount</code> 。</li>
<li>最后返回 <code>((_PageRangeDescriptor &amp; HeapSegContext-&gt;SegmentMask) + ((_PageRangeDescriptor - (_PageRangeDescriptor &amp; HeapSegContext-&gt;SegmentMask)) &gt;&gt; 5 &lt;&lt; HeapSegContext-&gt;UnitShift))</code> 即对应申请到的内存的起始地址。</li>
</ul>
</li>
</ul>
<h5 id="Free-3"><a href="#Free-3" class="headerlink" title="Free"></a>Free</h5><p>VS 堆，LFH 堆和用户释放内存都有可能导致后端堆释放内存，这里选择用户释放内存时的过程进行分析，其余过程基本一致。</p>
<ul>
<li>在 <code>RtlpFreeHeapInternal</code> 函数中，如果 <code>BlockPtr</code> 等于其所在 <code>Block</code> 的开头说明是后端堆分配，因此会调用 <code>RtlpHpSegPageRangeShrink</code> 释放内存。<ul>
<li>将要释放的内存中除了第一个和最后一个的 <code>PageRangeDescriptor</code> 的 <code>RangeFlags</code> 的 allocted bit 复位</li>
<li>将要释放的内存中第一个 <code>PageRangeDescriptor</code> 的 <code>RangeFlags</code> 与上 0xF3 ，即将 VS 或 LFH 相关标志位清除。</li>
<li>调用 <code>RtlpHpSegPageRangeCoalesce</code> 函数尝试合并前后空闲的 <code>Block</code> 。<ul>
<li>如果不是最后一个 <code>Block</code>（<code>DescriptorIndex + PageRangeDescriptor-&gt;UnitOffset &lt; 0x100</code>）尝试向后合并。首先找到后一个 <code>PageRangeDescriptor</code> ，如果后一个 <code>PageRangeDescriptor</code> 的 <code>RangeFlags</code> 的 allocted bit 位没有置位说明空闲，记为 <code>NextPageRangeDescriptor</code> 。</li>
<li>如果不是第一个 <code>Block</code>（<code>DescriptorIndex &gt; SegContext-&gt;FirstDescriptorIndex</code>）尝试向前合并。首先找释放的 <code>Block</code> 的第一个 <code>PageRangeDescriptor</code> 的前一个  <code>PageRangeDescriptor</code> ，然后判断其 <code>RangeFlags</code> 的 block header bit 是否置位来确定是否是其所在 <code>Block</code> 的第一个 <code>PageRangeDescriptor</code> ，如果不是就根据其 <code>UnitOffset</code> 找到第一个 <code>PageRangeDescriptor</code> 。如果前一个 <code>PageRangeDescriptor</code> 的 <code>RangeFlags</code> 的 allocted bit 位没有置位说明空闲，记为 <code>PrevPageRangeDescriptor</code>。</li>
<li>如果找到了 <code>PrevPageRangeDescriptor</code> 则将其合并到释放的 <code>block</code> 中。<ul>
<li>调用 <code>RtlpHpSegFreeRangeRemove</code> 将该 <code>PageRangeDescriptor</code> 从 <code>FreePageRanges</code> 中取出。</li>
<li><code>PrevPageRangeDescriptor-&gt;UnitOffset += PageRangeDescriptor-&gt;UnitOffset</code> </li>
<li><code>PrevPageRangeDescriptor-&gt;Key.CommittedPageCount = ~(~(PrevPageRangeDescriptor-&gt;Key.CommittedPageCount) + ~(PageRangeDescriptor-&gt;Key.CommittedPageCount))</code> </li>
<li><code>PageRangeDescriptor-&gt;RangeFlags &amp;= (PageRangeDescriptor-&gt;UnitOffset &lt;= 1u) - 4</code> </li>
<li><code>PrevPageRangeDescriptor[(unsigned int)PrevPageRangeDescriptor-&gt;UnitOffset - 1].UnitOffset = PrevPageRangeDescriptor-&gt;UnitOffset - 1</code> </li>
<li>记当前的 <code>PageRangeDescriptor</code> 为 <code>PrevPageRangeDescriptor</code> 。</li>
</ul>
</li>
<li><code>PageRangeDescriptor-&gt;RangeFlags |= 0x11u</code> </li>
<li>如果找到了 <code>NextPageRangeDescriptor</code> 则将其合并到释放的 <code>block</code> 中。<ul>
<li>调用 <code>RtlpHpSegFreeRangeRemove</code> 将该 <code>PageRangeDescriptor</code> 从 <code>FreePageRanges</code> 中取出。 </li>
<li><code>PageRangeDescriptor[(unsigned int)PageRangeDescriptor-&gt;UnitOffset - 1].RangeFlags &amp;= ~1u</code> </li>
<li><code>PageRangeDescriptor-&gt;UnitOffset += NextPageRangeDescriptor-&gt;UnitOffset</code> </li>
<li><code>PageRangeDescriptor-&gt;Key.CommittedPageCount = ~(~(PageRangeDescriptor-&gt;Key.CommittedPageCount) + ~(NextPageRangeDescriptor-&gt;Key.CommittedPageCount))</code> </li>
<li><code>NextPageRangeDescriptor-&gt;RangeFlags &amp;= ~2u</code></li>
<li><code>PageRangeDescriptor[PageRangeDescriptor-&gt;UnitOffset - 1].RangeFlags |= 1u</code></li>
<li><code>PageRangeDescriptor[PageRangeDescriptor-&gt;UnitOffset - 1].UnitOffset  = PageRangeDescriptor-&gt;UnitOffset - 1</code></li>
</ul>
</li>
<li>最后将合并完的 <code>Block</code> 的第一个 <code>PageRangeDescriptor</code> 的 <code>RangeFlags</code> 与上 0xEE ，最后一个 <code>PageRangeDescriptor</code> 的 <code>RangeFlags</code> 的 allocted bit 复位。</li>
</ul>
</li>
<li>将合并完的 <code>Block</code> 插入到 <code>FreePageRanges</code> 中，完成释放。</li>
</ul>
</li>
</ul>
<h3 id="LB-堆"><a href="#LB-堆" class="headerlink" title="LB 堆"></a>LB 堆</h3><h4 id="相关数据结构-5"><a href="#相关数据结构-5" class="headerlink" title="相关数据结构"></a>相关数据结构</h4><h5 id="HEAP-LARGE-ALLOC-DATA"><a href="#HEAP-LARGE-ALLOC-DATA" class="headerlink" title="_HEAP_LARGE_ALLOC_DATA"></a>_HEAP_LARGE_ALLOC_DATA</h5><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _HEAP_LARGE_ALLOC_DATA</span><br><span class="line">ntdll!_HEAP_LARGE_ALLOC_DATA</span><br><span class="line">   +0x000 TreeNode         : _RTL_BALANCED_NODE</span><br><span class="line">   +0x018 VirtualAddress   : Uint8B</span><br><span class="line">   +0x018 UnusedBytes      : Pos 0, 16 Bits</span><br><span class="line">   +0x020 ExtraPresent     : Pos 0, 1 Bit</span><br><span class="line">   +0x020 GuardPageCount   : Pos 1, 1 Bit</span><br><span class="line">   +0x020 GuardPageAlignment : Pos 2, 6 Bits</span><br><span class="line">   +0x020 Spare            : Pos 8, 4 Bits</span><br><span class="line">   +0x020 AllocatedPages   : Pos 12, 52 Bits</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>TreeNode</code>：红黑树 <code>_SEGMENT_HEAP.LargeAllocMetadata</code> 上的节点。<ul>
<li><code>Left</code>：指向一个 <code>VirtualAddress</code> 小于当前节点的节点。</li>
<li><code>Right</code>：指向一个 <code>VirtualAddress</code> 大于当前节点的节点。</li>
<li><code>ParentValue</code>：指向父节点。最低 1 比特决定是否加密。</li>
</ul>
</li>
<li><code>VirtualAddress</code>：<code>LargeBlock</code> 的地址，低 16 比特为 <code>UnusedBytes</code> 。</li>
<li><code>AllocatedPages</code>：分配的内存页数量。</li>
</ul>
<h4 id="分配机制-5"><a href="#分配机制-5" class="headerlink" title="分配机制"></a>分配机制</h4><h5 id="Allocate-4"><a href="#Allocate-4" class="headerlink" title="Allocate"></a>Allocate</h5><ul>
<li>在 <code>RtlpAllocateHeapInternal</code> 函数中，由于 <code>Size &gt; Heap-&gt;SegContexts[1].MaxAllocationSize</code> 即 <code>Size &gt; 0x7f0000</code> 则调用 LB 堆核心函数 <code>RtlpHpLargeAlloc</code> 分配内存。<ul>
<li>调用 <code>RtlpHpMetadataAlloc</code> 函数为 <code>LargeAllocData</code> 结构分配内存。</li>
<li>计算 <code>ReservedSize</code> ，通常是 <code>Size + 0x1000</code> 。</li>
<li>调用 <code>RtlpHpAllocVA</code> 函数分配一段虚拟内存空间，注意此时还没有分配物理页。</li>
<li>调用 <code>RtlpHpAllocVA</code> 函数分配实际内存。</li>
<li>初始化 <code>LargeAllocData</code> 结构体。</li>
<li>将 <code>LargeAllocData</code> 插入到 <code>LargeAllocMetadata</code> 中。</li>
<li>更新 <code>Heap-&gt;LargeReservedPages</code> 和 <code>Heap-&gt;LargeCommittedPages</code> 。</li>
<li>将分配的内存的起始地址返回。</li>
</ul>
</li>
</ul>
<h5 id="Free-4"><a href="#Free-4" class="headerlink" title="Free"></a>Free</h5><ul>
<li>在 <code>RtlpAllocateHeapInternal</code> 函数中，如果 <code>BlockPtr</code> 最低 16 比特为 0 则判定为 Large Block 堆分配，调用 LB 堆的核心释放函数 <code>RtlpHpLargeFree</code> 。<ul>
<li>根据 <code>BlockPtr</code> 在 <code>LargeAllocMetadata</code> 中找到对应的 <code>LargeAllocData</code> 。</li>
<li>调用 <code>RtlRbRemoveNode</code> 函数将该 <code>LargeAllocData</code> 从 <code>LargeAllocMetadata</code> 中取出。</li>
<li>调用 <code>RtlpHpFreeVA</code> 函数把 <code>BlockPtr</code> 指向的内存释放掉。</li>
<li>更新 <code>Heap-&gt;LargeReservedPages</code> 和 <code>Heap-&gt;LargeCommittedPages</code> 。</li>
<li>调用 <code>RtlpHpMetadataFree</code> 释放对应的 <code>LargeAllocData</code> 。</li>
</ul>
</li>
</ul>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> windows user pwn 基础知识</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2024-11-08 20:54:39</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-11-21 19:22:41
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2024/11/08/windows-user-pwn-basic-knowlege/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/windows-user-pwn/">#windows user pwn</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/11/08/windows-user-pwn-exploit-technique/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">windows user pwn</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/11/08/linux-kernel-pwn-useful-structs/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">linux kernel pwn 常用结构体</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">windows user pwn 基础知识</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-text">环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#checksec"><span class="nav-text">checksec</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#winchecksec"><span class="nav-text">winchecksec</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#checksec%EF%BC%88x64dbg%EF%BC%89"><span class="nav-text">checksec（x64dbg）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#winpwn"><span class="nav-text">winpwn</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-text">安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%8A%9F%E8%83%BD"><span class="nav-text">添加功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#windbg"><span class="nav-text">windbg</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85-windbg"><span class="nav-text">安装 windbg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ret-sync-%E5%AE%9E%E7%8E%B0-ida-%E5%92%8C-windbg-%E8%81%94%E5%8A%A8%E8%B0%83%E8%AF%95"><span class="nav-text">ret_sync 实现 ida 和 windbg 联动调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80"><span class="nav-text">地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%AD%E7%82%B9"><span class="nav-text">断点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-text">内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E8%AF%95"><span class="nav-text">调试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-text">线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97"><span class="nav-text">运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%AC%A6%E5%8F%B7"><span class="nav-text">查看符号</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gadget-%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7"><span class="nav-text">gadget 搜索工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ROPGadget"><span class="nav-text">ROPGadget</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ropper"><span class="nav-text">ropper</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="nav-text">远程环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%8E%B7%E5%8F%96"><span class="nav-text">系统获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AppJailLauncher"><span class="nav-text">AppJailLauncher</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83"><span class="nav-text">调试环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2-dll"><span class="nav-text">替换 dll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">可能存在的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0x1a-%E9%97%AE%E9%A2%98"><span class="nav-text">0x1a 问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E8%BD%A6%E9%97%AE%E9%A2%98"><span class="nav-text">回车问题</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#windows-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="nav-text">windows 函数调用约定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#x86"><span class="nav-text">x86</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x64"><span class="nav-text">x64</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PE-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-text">PE 文件格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IMAGE-DOS-HEADER"><span class="nav-text">IMAGE_DOS_HEADER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IMAGE-NT-HEADERS32"><span class="nav-text">IMAGE_NT_HEADERS32</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IMAGE-FILE-HEADER"><span class="nav-text">IMAGE_FILE_HEADER</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IMAGE-OPTIONAL-HEADER32"><span class="nav-text">IMAGE_OPTIONAL_HEADER32</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8"><span class="nav-text">重定位表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA%E8%A1%A8"><span class="nav-text">导出表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E8%A1%A8"><span class="nav-text">导入表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8A%82%E8%A1%A8"><span class="nav-text">节表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81-dll"><span class="nav-text">常见 dll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%BB%93%E6%9E%84"><span class="nav-text">常见结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PEB"><span class="nav-text">PEB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TEB"><span class="nav-text">TEB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SEH"><span class="nav-text">SEH</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4"><span class="nav-text">常见保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DEP"><span class="nav-text">DEP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASLR"><span class="nav-text">ASLR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GS"><span class="nav-text">GS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CheckStackVars"><span class="nav-text">CheckStackVars</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SEHOP"><span class="nav-text">SEHOP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SafeSEH"><span class="nav-text">SafeSEH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFG"><span class="nav-text">CFG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PROCESS-MITIGATION-CHILD-PROCESS-POLICY"><span class="nav-text">PROCESS_MITIGATION_CHILD_PROCESS_POLICY</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%9C%B0%E5%9D%80%E6%B3%84%E9%9C%B2%E6%96%B9%E6%B3%95"><span class="nav-text">常见地址泄露方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%AF%BC%E5%85%A5%E8%A1%A8%E6%B3%84%E9%9C%B2"><span class="nav-text">通过导入表泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%A0%86%E6%B3%84%E9%9C%B2"><span class="nav-text">通过堆泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-PEB-%E6%B3%84%E9%9C%B2"><span class="nav-text">通过 PEB 泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-TEB-%E6%B3%84%E9%9C%B2"><span class="nav-text">通过 TEB 泄露</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#windows-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">windows 异常处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#windows-IO-FILE"><span class="nav-text">windows IO_FILE</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#windows-%E5%A0%86%E5%9F%BA%E7%A1%80"><span class="nav-text">windows 堆基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Windows-%E5%A0%86%E6%A6%82%E8%BF%B0"><span class="nav-text">Windows 堆概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows-%E5%A0%86%E7%B1%BB%E5%9E%8B"><span class="nav-text">Windows 堆类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows-%E7%94%A8%E6%88%B7%E6%80%81%E8%BF%9B%E7%A8%8B%E5%A0%86%E7%A9%BA%E9%97%B4"><span class="nav-text">Windows 用户态进程堆空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%AE%A1%E7%90%86%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0"><span class="nav-text">堆管理常见函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HeapCreate"><span class="nav-text">HeapCreate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HeapAlloc-HeapFree"><span class="nav-text">HeapAlloc&#x2F;HeapFree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VirtualAlloc-VirtualFree"><span class="nav-text">VirtualAlloc&#x2F;VirtualFree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LocalAlloc-LocalFree"><span class="nav-text">LocalAlloc&#x2F;LocalFree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GlobalAlloc-GlobalFree"><span class="nav-text">GlobalAlloc&#x2F;GlobalFree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc-free"><span class="nav-text">malloc&#x2F;free</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%A0%86%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="nav-text">常用堆调试命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NT-Heap"><span class="nav-text">NT Heap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E7%AB%AF%E5%A0%86"><span class="nav-text">后端堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HEAP"><span class="nav-text">_HEAP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#chunk-head"><span class="nav-text">chunk head</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BlocksIndex-HEAP-LIST-LOOKUP"><span class="nav-text">BlocksIndex (_HEAP_LIST_LOOKUP)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="nav-text">分配机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Allocate-RtlAllocateHeap"><span class="nav-text">Allocate (RtlAllocateHeap)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Free-RtlFreeHeap"><span class="nav-text">Free (RtlFreeHeap)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LFH-%E5%A0%86"><span class="nav-text">LFH 堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-text">相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FrontEndHeap%EF%BC%88-LFH-HEAP%EF%BC%89"><span class="nav-text">FrontEndHeap（_LFH_HEAP）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Buckets%EF%BC%88-HEAP-BUCKET%EF%BC%89"><span class="nav-text">Buckets（_HEAP_BUCKET）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SegmentInfoArray%EF%BC%88-HEAP-LOCAL-SEGMENT-INFO%EF%BC%89"><span class="nav-text">SegmentInfoArray（_HEAP_LOCAL_SEGMENT_INFO）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ActiveSubsegment%EF%BC%88-HEAP-SUBSEGMENT%EF%BC%89"><span class="nav-text">ActiveSubsegment（_HEAP_SUBSEGMENT）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AggregateExchg%EF%BC%88-INTERLOCK-SEQ%EF%BC%89"><span class="nav-text">AggregateExchg（_INTERLOCK_SEQ）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UserBlocks%EF%BC%88-HEAP-USERDATA-HEADER%EF%BC%89"><span class="nav-text">UserBlocks（_HEAP_USERDATA_HEADER）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#chunk-block%EF%BC%88-HEAP-ENTRY%EF%BC%89"><span class="nav-text">chunk&#x2F;block（_HEAP_ENTRY）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6-1"><span class="nav-text">分配机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Allocate"><span class="nav-text">Allocate</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Free"><span class="nav-text">Free</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Segment-Heap"><span class="nav-text">Segment Heap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#VS-%E5%A0%86"><span class="nav-text">VS 堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2"><span class="nav-text">相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SEGMENT-HEAP"><span class="nav-text">_SEGMENT_HEAP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RtlpHpHeapGlobals%EF%BC%88-RTLP-HP-HEAP-GLOBALS%EF%BC%89"><span class="nav-text">RtlpHpHeapGlobals（_RTLP_HP_HEAP_GLOBALS）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HEAP-VS-CONTEXT"><span class="nav-text">_HEAP_VS_CONTEXT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HEAP-VS-SUBSEGMENT"><span class="nav-text">_HEAP_VS_SUBSEGMENT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#chunk-head-1"><span class="nav-text">chunk head</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6-2"><span class="nav-text">分配机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Allocate-1"><span class="nav-text">Allocate</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Free-1"><span class="nav-text">Free</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LFH-%E5%A0%86-1"><span class="nav-text">LFH 堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3"><span class="nav-text">相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HEAP-LFH-CONTEXT"><span class="nav-text">_HEAP_LFH_CONTEXT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HEAP-LFH-BUCKET"><span class="nav-text">_HEAP_LFH_BUCKET</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HEAP-LFH-SUBSEGMENT-OWNER"><span class="nav-text">_HEAP_LFH_SUBSEGMENT_OWNER</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HEAP-LFH-AFFINITY-SLOT"><span class="nav-text">_HEAP_LFH_AFFINITY_SLOT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HEAP-LFH-SUBSEGMENT"><span class="nav-text">_HEAP_LFH_SUBSEGMENT</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6-3"><span class="nav-text">分配机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Allocate-2"><span class="nav-text">Allocate</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Free-2"><span class="nav-text">Free</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E7%AB%AF%E5%A0%86-1"><span class="nav-text">后端堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4"><span class="nav-text">相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HEAP-SEG-CONTEXT"><span class="nav-text">_HEAP_SEG_CONTEXT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HEAP-PAGE-SEGMENT"><span class="nav-text">_HEAP_PAGE_SEGMENT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HEAP-PAGE-RANGE-DESCRIPTOR"><span class="nav-text">_HEAP_PAGE_RANGE_DESCRIPTOR</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6-4"><span class="nav-text">分配机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Allocate-3"><span class="nav-text">Allocate</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Free-3"><span class="nav-text">Free</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LB-%E5%A0%86"><span class="nav-text">LB 堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5"><span class="nav-text">相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HEAP-LARGE-ALLOC-DATA"><span class="nav-text">_HEAP_LARGE_ALLOC_DATA</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6-5"><span class="nav-text">分配机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Allocate-4"><span class="nav-text">Allocate</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Free-4"><span class="nav-text">Free</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        27 posts in total
                    </span>
                    
                        <span>
                            396.5k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>